{"project": "FFmpeg", "commit_id": "83c285f88016b087c2f0f4b9ef356ad8ef12d947", "target": 1, "func": "static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12273, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "service", "t", "sg", "a", "sup", "g", "settings", "os", "sets", "js", "es", "si", "sq", "session", "server", "v", "storage", "ss", "client", "o", "w", "u", "an", "p", "e", "options", "socket", "http", "b", "sb", "sf", "n", "f", "gs", "spec", "c", "ns", "parser", "is", "stats", "sn", "ssl", "sv", "sl", "ops", "r", "ds", "services", "src", "aws"], "buf": ["aka", "runner", "port", "proc", "ff", "ha", "bc", "batch", "uint", "auc", "pool", "cmp", "fp", "loc", "br", "begin", "brace", "rb", "bed", "box", "count", "cat", "tab", "cb", "offset", "cas", "cp", "num", "prop", "context", "utf", "ru", "rc", "mount", "home", "uf", "front", "loader", "img", "wb", "length", "Buff", "feed", "cap", "um", "header", "alloc", "path", "queue", "fd", "cv", "config", "fb", "uber", "pg", "uu", "uno", "buffer", "bag", "grab", "sb", "gb", "bu", "loop", "cf", "chrom", "cur", "usr", "ph", "ctx", "vec", "ffff", "uc", "pkg", "tmp", "job", "buff", "feat", "la", "pb", "ab", "bg", "cmd", "fam", "src", "seq", "su", "coord", "pad", "len"], "buf_size": ["buffer_end", "bufallsmall", "bufacshape", "buffer_size", "buflexlarge", "buffer_shape", "buflexsmall", "path_small", "path_size", "path_end", "buflexend", "bufacsize", "bufallend", "bufaclength", "bufalllarge", "path_large", "pathallsmall", "buf_small", "pathalllarge", "bufallsize", "buf_shape", "buffer_length", "bufacend", "buf_large", "buf_length", "pathallend", "buflexsize", "pathallsize"], "filename": ["path", "ename", "location", "fd", "config", "memory", "un", "binary", "directory", "description", "buffer", "fp", "fn", "uri", "package", "Filename", "NAME", "names", "size", "ame", "rb", "wb", "b", "sf", "nil", "length", "f", "url", "number", "nm", "file", "text", "sn", "prefix", "username"], "filename_size": ["directory_size", "username_size", "name_Size", "username_end", "filename128size", "filename_sized", "file_day", "filename_length", "filename128end", "filename_day", "directory_name", "filename_width", "filename_Size", "username_scale", "directory_end", "filename_term", "filename_scale", "name_sized", "name_scale", "file_size", "username_term", "filename_end", "name_length", "file_scale", "filename_name", "directory_width", "filename128width", "file_sized", "filename128name"], "buf_end": ["room_end", "rb_end", "rb_e", "room_size", "buf_add", "fd_offset", "bufenend", "bufenoffset", "buf_e", "buf_start", "bufenenter", "buf0end", "buf0ent", "buf67e", "buf67add", "rb_add", "buf_ent", "buf_enter", "buf67ended", "bufenstart", "rb_ended", "buf_stop", "fd_end", "buf67end", "buf0stop", "buf0size", "fd_start", "buf_offset", "room_ent", "room_stop", "fd_enter", "buf_ended"], "dir_length": ["dir64length", "dir_size", "dir54weight", "dir64size", "dir__number", "dir54duration", " dir_weight", " dir_duration", "dir_time", "file_depth", "dir64len", "dir__size", "dir_depth", "dir___depth", "dir54length", "dir_len", "dir_number", "diraclength", "dir__length", "diracscale", "diracduration", "dir54scale", "dir__len", "dir_scale", "dir_duration", "file_size", "diracweight", "file_number", "dir64number", "dir_weight", " dir_scale", "file_time", "dir___time", "dir___length", "file_len", "dir___size"], "name_size": ["name_loc", "prefix_size", "username_length", "username_size", "uri___fee", "prefix_offset", "name_len", "namepscale", "nameploc", "uri___len", "username___sized", "name___fee", "uri_len", "name_mode", "uri___name", "uri_name", "uri_size", "file_mode", "name_name", "name___sized", "uri_fee", "filename_member", "file_type", "username___size", "uri___size", "name_type", "username___scale", "file_width", "filename_length", "username_sized", "name_number", "name___length", "name___number", "nameladdress", "username___length", "username_scale", "name_fee", "name_address", "filename_scale", "name___scale", "name_small", "filename_loc", "name_width", "name_sized", "name_scale", "file_size", "prefix_length", "name_length", "namellength", "name_offset", "file_scale", "filename_number", "name___len", "name___size", "file_small", "namepmember", "name_member", "namepsize", "prefix_address", "namelsize", "nameloffset", "name___name"], "first_sector": ["last_part", "first_storage", "firstSubpart", "firstallpart", "first_section", "last_sector", "firstSubcontext", "firstalllocation", "last_storage", "firstallsector", "first_context", "last_section", "firstallsection", "last_context", "first_location", "firstSubsection", "last_location", "first_part", "firstSubsector"], "depth": ["path", "priority", "context", "deep", "slice", "d", "dist", "level", "details", "weight", "progress", "position", "scope", "dir", "package", "der", "rank", "size", "layer", "time", "distance", "rate", "length", "count", "mode", "parent", "padding", "dep", "feature", "Depth", "type", "side", "scale", "debug", "stack", "dr", "order", "dim", "len", "ptr", "height"], "file_length": ["dir_size", "file_start", "file_offset", "file_capacity", "name_capacity", "filepsize", "file_depth", "fileplength", "dir_offset", "file\u00b7or", "name_depth", "name_len", "filepoffset", "file\u00b7size", "file_size", "dir_start", "filepstart", "file\u00b7depth", "file_or", "name_or", "file\u00b7length", "file_len", "name_length"], "name": ["channel", "word", "path", "vision", "part", "nam", "with", "id", "up", "memory", "home", "large", "connection", "image", "ident", "description", "option", "comment", "username", "member", "session", "key", "package", "Name", "NAME", "names", "size", "mem", "ame", "time", "info", "data", "base", "n", "parent", "number", "url", "block", "span", "type", "file", "common", "no", "prefix", "alias", "space", "nm", "node"]}}
{"project": "FFmpeg", "commit_id": "527f89e05922e840083ac6d49eeb838b1e350dd4", "target": 1, "func": "static void stereo_processing(PSContext *ps, INTFLOAT (*l)[32][2], INTFLOAT (*r)[32][2], int is34)\n\n{\n\n    int e, b, k;\n\n\n\n    INTFLOAT (*H11)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H11;\n\n    INTFLOAT (*H12)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H12;\n\n    INTFLOAT (*H21)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H21;\n\n    INTFLOAT (*H22)[PS_MAX_NUM_ENV+1][PS_MAX_NR_IIDICC] = ps->H22;\n\n    int8_t *opd_hist = ps->opd_hist;\n\n    int8_t *ipd_hist = ps->ipd_hist;\n\n    int8_t iid_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t icc_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t ipd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t opd_mapped_buf[PS_MAX_NUM_ENV][PS_MAX_NR_IIDICC];\n\n    int8_t (*iid_mapped)[PS_MAX_NR_IIDICC] = iid_mapped_buf;\n\n    int8_t (*icc_mapped)[PS_MAX_NR_IIDICC] = icc_mapped_buf;\n\n    int8_t (*ipd_mapped)[PS_MAX_NR_IIDICC] = ipd_mapped_buf;\n\n    int8_t (*opd_mapped)[PS_MAX_NR_IIDICC] = opd_mapped_buf;\n\n    const int8_t *k_to_i = is34 ? k_to_i_34 : k_to_i_20;\n\n    TABLE_CONST INTFLOAT (*H_LUT)[8][4] = (PS_BASELINE || ps->icc_mode < 3) ? HA : HB;\n\n\n\n    //Remapping\n\n    if (ps->num_env_old) {\n\n        memcpy(H11[0][0], H11[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[0][0][0]));\n\n        memcpy(H11[1][0], H11[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H11[1][0][0]));\n\n        memcpy(H12[0][0], H12[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[0][0][0]));\n\n        memcpy(H12[1][0], H12[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H12[1][0][0]));\n\n        memcpy(H21[0][0], H21[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[0][0][0]));\n\n        memcpy(H21[1][0], H21[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H21[1][0][0]));\n\n        memcpy(H22[0][0], H22[0][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[0][0][0]));\n\n        memcpy(H22[1][0], H22[1][ps->num_env_old], PS_MAX_NR_IIDICC*sizeof(H22[1][0][0]));\n\n    }\n\n\n\n    if (is34) {\n\n        remap34(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap34(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap34(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap34(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (!ps->is34bands_old) {\n\n            map_val_20_to_34(H11[0][0]);\n\n            map_val_20_to_34(H11[1][0]);\n\n            map_val_20_to_34(H12[0][0]);\n\n            map_val_20_to_34(H12[1][0]);\n\n            map_val_20_to_34(H21[0][0]);\n\n            map_val_20_to_34(H21[1][0]);\n\n            map_val_20_to_34(H22[0][0]);\n\n            map_val_20_to_34(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    } else {\n\n        remap20(&iid_mapped, ps->iid_par, ps->nr_iid_par, ps->num_env, 1);\n\n        remap20(&icc_mapped, ps->icc_par, ps->nr_icc_par, ps->num_env, 1);\n\n        if (ps->enable_ipdopd) {\n\n            remap20(&ipd_mapped, ps->ipd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n            remap20(&opd_mapped, ps->opd_par, ps->nr_ipdopd_par, ps->num_env, 0);\n\n        }\n\n        if (ps->is34bands_old) {\n\n            map_val_34_to_20(H11[0][0]);\n\n            map_val_34_to_20(H11[1][0]);\n\n            map_val_34_to_20(H12[0][0]);\n\n            map_val_34_to_20(H12[1][0]);\n\n            map_val_34_to_20(H21[0][0]);\n\n            map_val_34_to_20(H21[1][0]);\n\n            map_val_34_to_20(H22[0][0]);\n\n            map_val_34_to_20(H22[1][0]);\n\n            ipdopd_reset(ipd_hist, opd_hist);\n\n        }\n\n    }\n\n\n\n    //Mixing\n\n    for (e = 0; e < ps->num_env; e++) {\n\n        for (b = 0; b < NR_PAR_BANDS[is34]; b++) {\n\n            INTFLOAT h11, h12, h21, h22;\n\n            h11 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][0];\n\n            h12 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][1];\n\n            h21 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][2];\n\n            h22 = H_LUT[iid_mapped[e][b] + 7 + 23 * ps->iid_quant][icc_mapped[e][b]][3];\n\n\n\n            if (!PS_BASELINE && ps->enable_ipdopd && b < NR_IPDOPD_BANDS[is34]) {\n\n                //The spec say says to only run this smoother when enable_ipdopd\n\n                //is set but the reference decoder appears to run it constantly\n\n                INTFLOAT h11i, h12i, h21i, h22i;\n\n                INTFLOAT ipd_adj_re, ipd_adj_im;\n\n                int opd_idx = opd_hist[b] * 8 + opd_mapped[e][b];\n\n                int ipd_idx = ipd_hist[b] * 8 + ipd_mapped[e][b];\n\n                INTFLOAT opd_re = pd_re_smooth[opd_idx];\n\n                INTFLOAT opd_im = pd_im_smooth[opd_idx];\n\n                INTFLOAT ipd_re = pd_re_smooth[ipd_idx];\n\n                INTFLOAT ipd_im = pd_im_smooth[ipd_idx];\n\n                opd_hist[b] = opd_idx & 0x3F;\n\n                ipd_hist[b] = ipd_idx & 0x3F;\n\n\n\n                ipd_adj_re = AAC_MADD30(opd_re, ipd_re, opd_im, ipd_im);\n\n                ipd_adj_im = AAC_MSUB30(opd_im, ipd_re, opd_re, ipd_im);\n\n                h11i = AAC_MUL30(h11,  opd_im);\n\n                h11  = AAC_MUL30(h11,  opd_re);\n\n                h12i = AAC_MUL30(h12,  ipd_adj_im);\n\n                h12  = AAC_MUL30(h12,  ipd_adj_re);\n\n                h21i = AAC_MUL30(h21,  opd_im);\n\n                h21  = AAC_MUL30(h21,  opd_re);\n\n                h22i = AAC_MUL30(h22,  ipd_adj_im);\n\n                h22  = AAC_MUL30(h22,  ipd_adj_re);\n\n                H11[1][e+1][b] = h11i;\n\n                H12[1][e+1][b] = h12i;\n\n                H21[1][e+1][b] = h21i;\n\n                H22[1][e+1][b] = h22i;\n\n            }\n\n            H11[0][e+1][b] = h11;\n\n            H12[0][e+1][b] = h12;\n\n            H21[0][e+1][b] = h21;\n\n            H22[0][e+1][b] = h22;\n\n        }\n\n        for (k = 0; k < NR_BANDS[is34]; k++) {\n\n            LOCAL_ALIGNED_16(INTFLOAT, h, [2], [4]);\n\n            LOCAL_ALIGNED_16(INTFLOAT, h_step, [2], [4]);\n\n            int start = ps->border_position[e];\n\n            int stop  = ps->border_position[e+1];\n\n            INTFLOAT width = Q30(1.f) / ((stop - start) ? (stop - start) : 1);\n\n#if USE_FIXED\n\n            width <<= 1;\n\n#endif\n\n            b = k_to_i[k];\n\n            h[0][0] = H11[0][e][b];\n\n            h[0][1] = H12[0][e][b];\n\n            h[0][2] = H21[0][e][b];\n\n            h[0][3] = H22[0][e][b];\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n            //Is this necessary? ps_04_new seems unchanged\n\n            if ((is34 && k <= 13 && k >= 9) || (!is34 && k <= 1)) {\n\n                h[1][0] = -H11[1][e][b];\n\n                h[1][1] = -H12[1][e][b];\n\n                h[1][2] = -H21[1][e][b];\n\n                h[1][3] = -H22[1][e][b];\n\n            } else {\n\n                h[1][0] = H11[1][e][b];\n\n                h[1][1] = H12[1][e][b];\n\n                h[1][2] = H21[1][e][b];\n\n                h[1][3] = H22[1][e][b];\n\n            }\n\n            }\n\n            //Interpolation\n\n            h_step[0][0] = AAC_MSUB31_V3(H11[0][e+1][b], h[0][0], width);\n\n            h_step[0][1] = AAC_MSUB31_V3(H12[0][e+1][b], h[0][1], width);\n\n            h_step[0][2] = AAC_MSUB31_V3(H21[0][e+1][b], h[0][2], width);\n\n            h_step[0][3] = AAC_MSUB31_V3(H22[0][e+1][b], h[0][3], width);\n\n            if (!PS_BASELINE && ps->enable_ipdopd) {\n\n                h_step[1][0] = AAC_MSUB31_V3(H11[1][e+1][b], h[1][0], width);\n\n                h_step[1][1] = AAC_MSUB31_V3(H12[1][e+1][b], h[1][1], width);\n\n                h_step[1][2] = AAC_MSUB31_V3(H21[1][e+1][b], h[1][2], width);\n\n                h_step[1][3] = AAC_MSUB31_V3(H22[1][e+1][b], h[1][3], width);\n\n            }\n\n            ps->dsp.stereo_interpolate[!PS_BASELINE && ps->enable_ipdopd](\n\n                l[k] + start + 1, r[k] + start + 1,\n\n                h, h_step, stop - start);\n\n        }\n\n    }\n\n}\n", "idx": 12278, "substitutes": {"ps": ["hes", "PS", "pse", "tx", "parts", "posts", "ples", "bs", "ins", "pc", "mp", "phys", "pins", "docs", "pt", "Ps", "changes", "ups", "clips", "qs", "sp", "details", "pg", "hs", "pp", "points", "pres", "ras", "pps", "aps", "ss", "times", "ges", "files", "ms", "params", "p", "s", "plugins", "eps", "pa", "amps", "lines", "tests", "gs", "powers", "wp", "ns", "pe", "per", "ports", "pes", "ep", "als", "ops", "services", "cases", "pers", "pr", "ips", "ls", "pos", "ts", "ppa", "ph", "gp"], "l": ["m", "fl", "lc", "lp", "v", "o", "ul", "ll", "lo", "lr", "kl", "lt", "li", "pl", "j", "L", "f", "rl", "c", "ol", "lu", "sl", "ls", "wl", "el", "bl", "ln"], "r": ["m", "ru", "R", "rc", "rs", "g", "er", "rg", "sr", "rh", "cr", "rec", "lr", "ir", "rb", "rx", "j", "rl", "ro", "re", "q", "rt", "ri", "nr", "ar", "res", "err"], "is34": ["id94", "is35", "is533", " is533", " is94", " is12", "id12", "id35", "C12", " is35", "is94", "id533", "C533", "is12", "C94", "C35"], "e": ["m", "en", "E", "d", "t", "i", "g", "h", "x", "v", "o", "w", "u", "z", "p", "j", "n", "f", "fe", "c", "end", "pe", "ae", "y"], "b": ["d", "bs", "i", "bb", "a", "g", "h", "aa", "v", "o", "bp", "w", "p", "s", "sb", "j", "n", "f", "ab", "c", "bi", "B", "lb", "y"], "k": ["m", "ak", "t", "i", "g", "ki", "sk", "h", "x", "v", "o", "w", "z", "p", "s", "ck", "j", "n", "f", "K", "q", "ik", "y", "ks"], "opd_hist": ["opd_history", "opds_path", "opd_master", "opds_orig", "opds_hist", "opds_history", "opd_orig", "opd_path", "opds_master", "opds_seq", "opd_seq"], "ipd_hist": ["ipds_history", "ipds_reg", "ipd__history", "ipds_hist", "ipd_dict", "ipd__conf", "ipd_Hist", "ipds_Hist", "ipds_dict", "ipd_conf", "ipd_reg", "ipds_conf", "ipd__hist", "ipd__dict", "ipd_history"], "iid_mapped_buf": ["iid_mached_conv", "iid_mapped_buff", "iid_mappedallbuf", "iid_mappedallmap", "iid_mapping_buff", "iid_mapping_map", "iid_mached_uf", "iid_mapped_buffer", "iid_mappedallbuffer", "iid_mapped_map", "iid_mappedallbuff", "iid_mached_buff", "iid_mapping_buf", "iid_mached_buf", "iid_mapping_buffer", "iid_mapped_conv", "iid_mapped_uf"], "PS_MAX_NUM_ENV": ["PS_MAX_NUM_EnC", "PS_MAX_NUM_DENVICE", "PS_MAX_NUM_INU", "PS_MAX_NUM_DENF", "PS_MAX_NUMIPenV", "PS_MAX_NUM_ENCH", "PS_MAX_NUM_EnH", "PS_MAX_NUMIPENC", "PS_MAX_NUM_PNv", "PS_MAX_NUM_EnU", "PS_MAX_NUM_ENVICE", "PS_MAX_NUM_env", "PS_MAX_NUM_ENF", "PS_MAX_NUM_ENC", "PS_MAX_NUMIPENv", "PS_MAX_NUM_ENSP", "PS_MAX_NUMIPenv", "PS_MAX_NUM_INP", "PS_MAX_NUM_DENV", "PS_MAX_NUM_INV", "PS_MAX_NUM_EnCH", "PS_MAX_NUMIPenU", "PS_MAX_NUM_EnP", "PS_MAX_NUM_ENH", "PS_MAX_NUM_ENSv", "PS_MAX_NUM_ETV", "PS_MAX_NUM_EnF", "PS_MAX_NUM_ENSCH", "PS_MAX_NUM_INQ", "PS_MAX_NUMIPenC", "PS_MAX_NUM_INVICE", "PS_MAX_NUM_PNH", "PS_MAX_NUM_ENVs", "PS_MAX_NUM_EnV", "PS_MAX_NUM_ENv", "PS_MAX_NUM_ENSVICE", "PS_MAX_NUM_ENSV", "PS_MAX_NUM_INv", "PS_MAX_NUM_EnVs", "PS_MAX_NUM_ETv", "PS_MAX_NUM_ENSQ", "PS_MAX_NUM_DENv", "PS_MAX_NUM_PNV", "PS_MAX_NUM_ETH", "PS_MAX_NUM_ENQ", "PS_MAX_NUM_ENP", "PS_MAX_NUM_ENSC", "PS_MAX_NUM_ENSF", "PS_MAX_NUM_ETVs", "PS_MAX_NUM_enV", "PS_MAX_NUMIPENV", "PS_MAX_NUM_ENSU", "PS_MAX_NUMIPENU", "PS_MAX_NUM_PNVs", "PS_MAX_NUM_INF", "PS_MAX_NUM_ENU", "PS_MAX_NUM_enQ", "PS_MAX_NUM_enU", "PS_MAX_NUM_Env", "PS_MAX_NUM_enC", "PS_MAX_NUM_INC", "PS_MAX_NUM_EnQ"], "icc_mapped_buf": ["icc_mappedfcb", "icc_mappedfbuf", "icc_mapping_cb", "icc_mapped_cb", "icc_mapped_buff", "icc_mached_buff", "icc_mapping_buf", "icc_mappedfbuff", "icc_mapping_uf", "icc_mapped_map", "icc_mached_cb", "icc_mapping_buff", "icc_mappedfmap", "icc_mapped_uf", "icc_mached_buf", "icc_mached_map"], "ipd_mapped_buf": ["ipd_mapping_buff", "ipd_mapped_uf", "ipd_mapping_buffer", "ipd_mapped_cb", "ipd_mached_buff", "ipd_mapped_map", "ipd_mached_buf", "ipd_mached_cb", "ipd_mapping_uf", "ipd_mapping_buf", "ipd_mapped_buffer", "ipd_mached_map", "ipd_mapped_buff"], "opd_mapped_buf": ["opd_mapped_buffer", "opd_mached_cb", "opd_mached_buffer", "opd_mapped_cap", "opd_mapped_cb", "opd_mached_buf", "opd_mapped_buff", "opd_mached_cap", "opd_mached_buff"], "iid_mapped": ["iid_smapped", "iid_hached", "iid_Mached", "iid_Mapping", "iid_hraped", "iid_happed", "iid_mached", "iid_mapping", "iid_smraped", "iid_mraped", "iid_smached", "iid_happing", "iid_Mraped", "iid_smapping", "iid_Mapped"], "icc_mapped": ["icc_cmuted", "icc_cmaken", "icc__muted", "icc__maken", "icc_cmapped", "icc_mduted", "icc__matted", "icc__cmaken", "icc_watted", "icc_wapped", "icc__cmuted", "icc_muted", "icc_wuted", "icc_mdatted", "icc_matted", "icc__mapped", "icc_mdaken", "icc_mdapped", "icc_cmatted", "icc_waken", "icc__cmatted", "icc_maken", "icc__cmapped"], "ipd_mapped": ["ipd_bapped", "ipd_batched", "ipd_bached", "ipd_Matched", "ipd_matched", "ipd_watched", "ipd_wached", "ipd_Movered", "ipd_mached", "ipd_Mapped", "ipd_wapped", "ipd_bovered", "ipd_wovered", "ipd_Mached", "ipd_movered"], "opd_mapped": ["opd_rmached", "opd_mached", "opd_rmaped", "opd_map", "opd_amap", "opd_Maped", "opd_Mapped", "opd_rmapped", "opd_Mached", "opd_maped", "opd_amaped", "opd_rmap", "opd_amached", "opd_Map", "opd_amapped"], "INTFLOAT": ["INTHLFOAT", "INTALLOATER", "INTFLOINT", "INTFLOHATING", "INTALLOAR", "INTFlEINT", "INTFTOAT", "INTFROHATING", "INTFLOHat", "INTFLROAT", "INTFlOATS", "INTFLoAT", "INTFLTEATER", "INTALLoATER", "INTFLOOAT", "INTFTMOat", "INTHLOATS", "INTFLOOINT", "INTFLOat", "INTFLOOATS", "INTFlEATS", "INTFTMOAT", "INTFLTINT", "INTFROAT", "INTFlOAT", "INTFLROATT", "INTFLMOATING", "INTFTOATING", "INTFLROATING", "INTFLOHAT", "INTFLFOAR", "INTFLPOATS", "INTHLFOAR", "INTFLEINT", "INTFTOat", "INTFLTEAT", "INTFLROat", "INTFLPOAR", "INTFLTATH", "INTFLOREat", "INTFLFOATER", "INTHLOAR", "INTFLFOAT", "INTFTOATS", "INTFLOATT", "INTFlOATH", "INTFLTEATS", "INTFTMOATING", "INTFLPOAT", "INTHLFOATS", "INTHLOATER", "INTFLEAT", "INTFLTATS", "INTFlEATH", "INTALLOAT", "INTFLMOat", "INTALLOATS", "INTFLOATH", "INTFLoat", "INTFLOATS", "INTFROARD", "INTFTMOATS", "INTFLoATS", "INTFLMOATS", "INTALLoAT", "INTFLTAT", "INTFLROAR", "INTFROHat", "INTFLPOATER", "INTFLEATH", "INTFROHAT", "INTHLOAT", "INTHLFOATER", "INTFLFOATS", "INTALLoAR", "INTFLOREATING", "INTFROATING", "INTFlEAT", "INTFLROATS", "INTFLTEAR", "INTFLMOAT", "INTFLoATT", "INTFLFOATT", "INTFLOOAR", "INTFLOOATER", "INTFLoATER", "INTFLEATS", "INTFLROARD", "INTFLOOATH", "INTFLOREARD", "INTFlOINT", "INTFLOREAT", "INTFLoAR", "INTFLOATER", "INTFROat", "INTFROHARD", "INTFLOATING", "INTALLoATS", "INTFLOAR", "INTFLoATING", "INTFLOARD", "INTFLOHARD"]}}
{"project": "qemu", "commit_id": "04f8c053cca9c329eebb761f3a1ffef3d349b84c", "target": 1, "func": "static void handle_qmp_command(JSONMessageParser *parser, QList *tokens)\n\n{\n\n    int err;\n\n    QObject *obj;\n\n    QDict *input, *args;\n\n    const mon_cmd_t *cmd;\n\n    Monitor *mon = cur_mon;\n\n    const char *cmd_name, *info_item;\n\n\n\n    args = NULL;\n\n\n\n    obj = json_parser_parse(tokens, NULL);\n\n    if (!obj) {\n\n        // FIXME: should be triggered in json_parser_parse()\n\n        qerror_report(QERR_JSON_PARSING);\n\n        goto err_out;\n\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"object\");\n\n        qobject_decref(obj);\n\n        goto err_out;\n\n    }\n\n\n\n    input = qobject_to_qdict(obj);\n\n\n\n    mon->mc->id = qdict_get(input, \"id\");\n\n    qobject_incref(mon->mc->id);\n\n\n\n    obj = qdict_get(input, \"execute\");\n\n    if (!obj) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n\n    } else if (qobject_type(obj) != QTYPE_QSTRING) {\n\n        qerror_report(QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\", \"string\");\n\n\n    }\n\n\n\n    cmd_name = qstring_get_str(qobject_to_qstring(obj));\n\n\n\n    if (invalid_qmp_mode(mon, cmd_name)) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    }\n\n\n\n    /*\n\n     * XXX: We need this special case until we get info handlers\n\n     * converted into 'query-' commands\n\n     */\n\n    if (compare_cmd(cmd_name, \"info\")) {\n\n        qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n    } else if (strstart(cmd_name, \"query-\", &info_item)) {\n\n        cmd = monitor_find_command(\"info\");\n\n        qdict_put_obj(input, \"arguments\",\n\n                      qobject_from_jsonf(\"{ 'item': %s }\", info_item));\n\n    } else {\n\n        cmd = monitor_find_command(cmd_name);\n\n        if (!cmd || !monitor_handler_ported(cmd)) {\n\n            qerror_report(QERR_COMMAND_NOT_FOUND, cmd_name);\n\n\n        }\n\n    }\n\n\n\n    obj = qdict_get(input, \"arguments\");\n\n    if (!obj) {\n\n        args = qdict_new();\n\n\n\n\n    } else {\n\n        args = qobject_to_qdict(obj);\n\n        QINCREF(args);\n\n    }\n\n\n\n    QDECREF(input);\n\n\n\n    err = monitor_check_qmp_args(cmd, args);\n\n    if (err < 0) {\n\n        goto err_out;\n\n    }\n\n\n\n    if (monitor_handler_is_async(cmd)) {\n\n        qmp_async_cmd_handler(mon, cmd, args);\n\n    } else {\n\n        monitor_call_handler(mon, cmd, args);\n\n    }\n\n    goto out;\n\n\n\nerr_input:\n\n    QDECREF(input);\n\nerr_out:\n\n    monitor_protocol_emitter(mon, NULL);\n\nout:\n\n    QDECREF(args);\n\n}", "idx": 12281, "substitutes": {"parser": ["xml", "worker", "pc", "mp", "monkey", "prot", "er", "manager", "pool", "writer", "fp", "Parser", "server", "conn", "pd", "processor", "loader", "parse", "p", "handler", "reader", "json", "parent", "state", "lex", "jack", "tp", "php"], "tokens": ["pokens", "targers", "takkens", "pargens", "taken", "targets", "takents", "pakens", "tokenents", "pargents", "takers", "tokenkens", "tokets", "tokeners", "tokers", "pakets", "targens", "pokers", "takens", "tokenen", "pargkens", "takets", "targkens", "token", "pokets", "pakers", "pokents", "pokkens", "paken", "pargets", "tokkens", "tokenets", "targen", "targents", "tokents", "tokenens", "poken"], "err": ["rr", "proc", "call", "ctr", "Error", "er", "str", "error", "Er", "lr", "e", "handler", "f", "result", "c", "arr", "inner", "message", " Err", " error", "out", "load", "all", "r", "resp", "nr", "ise"], "obj": ["amp", "art", "oa", "module", "str", "js", "active", "ind", "dict", "rb", "pot", "ocr", "att", "cb", "attr", "objects", "out", "clone", "lock", "func", "adj", "part", "sync", "obb", "api", "Object", "txt", "fn", "bj", "img", "bm", "data", "yo", "inst", "json", "ns", "arr", "body", "aj", "po", "so", "os", "nb", "ref", "init", "output", "conn", "o", "bot", "nc", "j", "bo", "nt", "aos", "om", "pos", "ctx", "ob", "tmp", "jp", "object", "pt", "utils", "act", "orb", "fact", "buff", "Obj", "p", "op", "coll", "org"], "input": ["head", "bin", "amp", "xml", "array", "qa", "batch", "config", "id", "i", "object", "inf", "binary", "local", "current", "child", "source", "act", "image", "ref", "unit", "arg", "init", "method", "model", "raw", "key", "session", "output", "client", "request", "form", "element", "active", "dict", "instance", "img", "data", "reader", "list", "json", "parent", "Input", "inc", "block", "inner", "argument", "type", "iq", "text", "pull", "out", "q", "command", "param", "empty", "work", "in"], "args": ["actions", "call", "blocks", "amp", "enc", "config", "arms", "extra", "fields", "msg", "cs", "lang", "arg", "init", "items", "conf", "conn", "flags", "help", "kw", "params", "doc", "options", "cli", "data", "Args", "acl", "gs", "ns", "arr", "argument", "comm", "vals"], "cmd": ["func", "kind", "head", "call", "pkg", "cc", "id", "code", "bb", "unk", "child", "msg", "def", "name", "g", "act", "req", "module", "method", "init", "ct", "session", "gn", "client", "conn", "help", "cd", "clean", "plugin", "dict", "pipe", "cli", "ck", "op", "cfg", "c", "cat", "dc", "bind", "cb", "md", "Cmd", "cf", "cod", "command", "cookie", "cp", "vc", "comm", "num", "dom", "cl", "ctx", "node"], "mon": ["m", "bin", "mc", "cm", "Mon", "wm", "po", "config", "mp", "month", "msg", "mat", "manager", "mons", "mn", "module", "unit", "con", "mm", "key", "master", "dog", "session", "mx", "mot", "conn", "admin", "col", "mr", "plugin", "mun", "mor", "bm", "atom", "mi", "mic", "yo", "monitor", "mo", "mos", "pm", "block", "MON", "bo", "don", "md", "mag", "man", "db", "comm", "lock", "pos", "dm", "mand", "mu", "message"], "cmd_name": ["cmd_word", "cmdDNAME", "cmd_num", "cmdknone", "cmdKname", "cmd_named", "cmdXcode", "cmdkName", " cmd_named", "cmXspan", "cmd_none", "comm_word", "cmd_NAME", "cmd2span", "comm2name", "cmdsnamed", "command_names", "comm2ref", "cmd2num", "cmd2name", "cmdkNAME", "cmdDname", "cmd_id", "cmdKcode", "cmdXname", "cmd_def", "cm_code", "comm_def", " cmd_id", "command_type", "cmdvname", "cmd_search", "comm_num", "cmdsname", "cmdUname", "cmdXalias", "cmd2key", "cmdUword", "cmdUdef", " cmd_Name", "cmdvkey", "cmdksearch", "cmdNtype", "cmd_Name", "cmdUName", "cmd_key", "cmdknames", "comm_key", "cmd_code", "cm_name", "cmdkname", "cmdDnone", "cmd_names", "md_none", "cmd_span", "cmd2code", "cmd_ref", "cmd_nam", "cm_alias", "cm_span", "comm2key", "cmd_type", "md_NAME", "command_name", "comm_ref", "md_names", "cmdDnames", "cmdsnames", "cmXname", "md_Name", "comm_name", "cmdXspan", "cmdNnam", "cmdNname", "cmXcode", "cmd_alias", "comm_Name", "cmdKspan", "cmdNnames", "cmdvnum", "cmdsName", "md_name", "cmdKalias", "cmdvref", "cmXalias", " cmd_names", "comm2num", "cmd2ref", "md_search", "cmd2alias", "command_nam"], "info_item": ["infoayinfo", "infoaypage", "infoWname", "infoaychannel", "info_name", " info_name", "info_info", " info_info", "info_Item", "infoestvalue", "infoayname", "infoayvalue", "infoWpage", "info_page", "infoWchannel", "infoestitem", "infoWitem", " info_value", "info_value", " info_Item", "infoestinfo", "infoayitem", "info_channel", " info_channel", "infoayItem", " info_page"]}}
{"project": "FFmpeg", "commit_id": "32c3047cac9294bb56d23c89a40a22409db5cc70", "target": 0, "func": "static int idcin_decode_init(AVCodecContext *avctx)\n\n{\n\n    IdcinContext *s = avctx->priv_data;\n\n    int i, j, histogram_index = 0;\n\n    unsigned char *histograms;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the Huffman tables make it */\n\n    if (s->avctx->extradata_size != HUFFMAN_TABLE_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  Id CIN video: expected extradata size of %d\\n\", HUFFMAN_TABLE_SIZE);\n\n        return -1;\n\n    }\n\n\n\n    /* build the 256 Huffman decode trees */\n\n    histograms = (unsigned char *)s->avctx->extradata;\n\n    for (i = 0; i < 256; i++) {\n\n        for(j = 0; j < HUF_TOKENS; j++)\n\n            s->huff_nodes[i][j].count = histograms[histogram_index++];\n\n        huff_build_tree(s, i);\n\n    }\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 12305, "substitutes": {"avctx": ["afcca", "AVconfig", "AVpc", "AVcmd", "abcontext", "Avcontext", "evctx", "AVcmp", "avca", "Avctx", "ajcu", " avcca", " avcf", "ajcontext", "avcmp", "abcmp", "abpkg", "avepkg", "afcf", " avpc", "avcf", "evcci", "AVcontext", "avecu", "AVca", "avectx", "vercontext", "abcu", "aveca", "AVcu", "afcu", "abconfig", "Avpc", "Avca", "afcmp", "evcu", "evcf", " avca", "AVcf", "vercf", "ajctx", "afcontext", "afconfig", "avcmd", "avecci", "abcf", "avcu", "ajcmd", " avcontext", "avcontext", "avecf", "verctx", "ajcmp", "afctx", "avpc", "afcmd", "avcci", "AVctx", "avecontext", " avcci", "avconfig", "ajcf", " avcu", "avpkg", "abctx", "vercca", "ajpkg", "avcca"], "s": ["rs", "qs", "new", "js", "si", "server", "ps", "spec", "c", "is", "sv", "states", "aws", "args", "south", "m", "self", "d", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "full", "session", "storage", "b", "sf", "ns", "sa", "space", "ks", "sys", "parts", "service", "os", "sets", "opens", "o", "e", "sec", "http", "sb", "f", "services", "ls", "comments", "ctx", "ses", "a", "S", "settings", "sq", "v", "conf", "ss", "p", "se", "n", "gs", "xs", "stats", "ssl", "ds", "src", "su", "ts", "us"], "i": ["qi", "it", "ui", "adi", "m", "I", "d", "ai", "ni", "xi", "jp", "iu", "ini", "gi", "id", "a", "io", "oi", "api", "l", "ci", "ki", "x", "di", "si", "ie", "ii", "v", "vi", "uri", "yi", "u", "ind", "z", "p", "e", "fi", "info", "mini", "mi", "k", "li", "b", "ix", "multi", "n", "f", "ip", "c", "eni", "ji", "pi", "bi", "ri", "zi", "y", "ij", "index", "start"], "j": ["jj", "uj", "adj", "qi", "m", "ch", "aj", "kj", "ja", "jp", "l", "xi", "oj", "name", "g", "dj", "h", "di", "js", "si", "ie", "ii", "key", "bj", "v", "job", "o", "obj", "z", "ind", "jit", "p", "e", "u", "note", "k", "li", "b", "ix", "n", "jo", "jl", "jc", "je", "ji", "q", "J", "pr", "y", "ij", "index"], "histograms": ["historyograms", "historyures", "histrams", "gregographies", "thambers", "historyobs", "thobs", "rhograms", " histambers", " histros", "histores", "historyros", " histrams", "gregograms", "histobs", "histambers", "rhores", "thograms", " histores", "thros", "rhures", "historyambers", "historyographies", "histros", "historyores", "histographies", " histobs", "rhographies", "gregrams", "histures", " histures", "historyrams", "gregambers", " histographies"]}}
{"project": "qemu", "commit_id": "245f7b51c0ea04fb2224b1127430a096c91aee70", "target": 0, "func": "static void find_best_solid_area(VncState *vs, int x, int y, int w, int h,\n\n                                 uint32_t color, int *w_ptr, int *h_ptr)\n\n{\n\n    int dx, dy, dw, dh;\n\n    int w_prev;\n\n    int w_best = 0, h_best = 0;\n\n\n\n    w_prev = w;\n\n\n\n    for (dy = y; dy < y + h; dy += VNC_TIGHT_MAX_SPLIT_TILE_SIZE) {\n\n\n\n        dh = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, y + h - dy);\n\n        dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, w_prev);\n\n\n\n        if (!check_solid_tile(vs, x, dy, dw, dh, &color, true)) {\n\n            break;\n\n        }\n\n\n\n        for (dx = x + dw; dx < x + w_prev;) {\n\n            dw = MIN(VNC_TIGHT_MAX_SPLIT_TILE_SIZE, x + w_prev - dx);\n\n\n\n            if (!check_solid_tile(vs, dx, dy, dw, dh, &color, true)) {\n\n                break;\n\n            }\n\n            dx += dw;\n\n        }\n\n\n\n        w_prev = dx - x;\n\n        if (w_prev * (dy + dh - y) > w_best * h_best) {\n\n            w_best = w_prev;\n\n            h_best = dy + dh - y;\n\n        }\n\n    }\n\n\n\n    *w_ptr = w_best;\n\n    *h_ptr = h_best;\n\n}\n", "idx": 12307, "substitutes": {"vs": ["vers", "acs", "env", "vr", "ys", "cv", "bs", "lbs", "fs", "vp", "rs", "forces", "verts", "cs", "fps", "hs", "px", "styles", "v", "ps", "ss", "views", "ms", "VS", "obs", "s", "otes", "vas", "sb", "ums", "gs", "kins", "blogs", "state", "ns", "xs", "vg", "ports", "stats", "ov", "sv", "states", "services", "ds", "ops", "ls", "ils", "las", "iss", "vals", "sts"], "x": ["hi", "m", "ch", "tx", "hy", "d", "t", "on", "xi", "id", "l", "i", "up", "ww", "ex", "ey", "wx", "fx", "xp", "px", "v", "win", "yi", "z", "u", "yx", "p", "e", "ady", "du", "rx", "b", "ix", "n", "f", "xx", "xd", "ax", "c", "vy", "xs", "X", "xf", "wa", "q", "dd", "xc", "xy", "wy", "pos", "xxx", "work", "wd", "index"], "y": ["hi", "ny", "yt", "ch", "hy", "d", "ys", "t", "sky", "l", "i", "iy", "ey", "yd", "py", "cy", "ym", "ye", "v", "o", "yi", "z", "yl", "p", "e", "b", "yo", "j", "n", "yn", "ay", "c", "vy", "oy", "ry", "yu", "yah", "q", "Y", "ya", "ky", "xy", "yy", "wy", "zy", "ty", "sy"], "w": ["wh", "d", "iw", "l", "i", "ww", "ew", "weight", "sw", "wt", "v", "wn", "nw", "win", "z", "u", "p", "aw", "max", "wb", "b", "n", "rw", "W", "ow", "wa", "we", "hw", "wd", "fw"], "h": ["hi", "m", "hy", "d", "t", "l", "i", "hor", "g", "hs", "gh", "v", "rh", "z", "u", "p", "e", "k", "b", "j", "n", "f", "th", "hm", "bh", "c", "end", "ht", "q", "r", "H", "sh", "hd", "hop", "ph", "height"], "color": ["normal", "bin", "light", "rc", "id", "pal", "style", "olor", "name", "lc", "source", "cor", "border", "cre", "loc", "Color", "gl", "win", "alpha", "col", "roy", "gray", "size", "term", "colour", "resource", "colored", " colors", "background", "blue", "gb", "number", "black", "c", "opal", "ol", "cu", "ac", "type", "ion", "bg", "COLOR", "lace", "roman", "cell", "ors", "ori", "white"], "w_ptr": ["sw_last", "w_rt", "w___ptr", "sw___rt", "wPrt", "wa_pointer", "w___last", "wPbest", "sw_best", "wa_alloc", "w_last", "w___rt", "w_alloc", "sw___best", "w_pointer", "sw___ptr", "wa_dest", "w___best", "wa_ptr", "wPlast", "sw_rt", "w_dest", "w_best", "wPptr", "sw___last", "sw_ptr"], "h_ptr": [" h_best", " h_cur", "h_best", "w_thread", " h_grad", "h_src", "h_cur", "happptr", "w_src", "h_grad", "w_pointer", "happgrad", "happcur", "happbest", "h_thread", "h_pointer"], "dx": [" DX", "hi", "wh", "tx", "dq", "d", "dist", " dow", " d", "up", "xe", "xi", "ww", " Dy", "sup", "ex", " dim", "ci", "dj", "fx", "wx", "ud", "di", "dl", "xa", "xp", "px", "loc", "eddy", " delta", "nw", "quad", "z", "ady", "ctx", "du", "zi", "rx", "ix", " dd", "xd", "xx", "ax", "diff", "xs", "dt", "dra", "dc", "dp", "ds", "dd", "xc", "su", "xy", "wy", "zx", "ty", "dim", "zy", "dom", "wd"], "dy": ["hi", "ny", "dq", "d", "dist", "hy", "ni", "fy", "xi", "lon", "ww", "ded", " Dy", "die", "ey", "yd", "dj", "dl", "ud", "py", "di", "ld", "dir", "ye", "eddy", "dm", "yi", "z", "ady", "du", "zi", "li", "distance", "b", "did", "j", "phi", "xd", "dat", "vy", "dad", "dt", "dra", "md", "dim", "ds", "dd", "db", "hd", "dn", "xy", "yy", "idy", "wy", "zy", "ty", "wd", "dom", "phy"], "dw": ["adw", "dws", "Dwd", "pw", "pws", " dws", "sdw", "dew", "sdwd", " dwd", "cdwa", "ldw", "ldew", "ddw", "dsr", "fh", "pew", "fx", "sdh", "dsw", "px", "adh", "adws", "sdws", "cdew", "adwd", "ldW", "adew", "ddh", "adr", "Dew", " dwa", "ddW", "ddx", "Dwa", " dr", " dW", "ldx", " dew", "dsh", "fW", "Dw", "ddew", "dwd", "dwa", "adx", "ddws", "cdw", "dr", "dsws", "cdwd", "ldh", "adW", "dW", "fw"], "dh": ["hi", "wm", "dq", "d", "dist", "fd", "hy", "bd", "DH", "dl", "sth", "di", "wt", "dal", "ohl", "adh", "nw", "conn", "hh", "pd", "wb", "hm", "bh", "dad", "wd", "dt", "dra", "dc", "md", "wa", "dial", "deb", "yah", "dp", "zh", "ds", "den", "db", "hd", "dd", "dn", "vd", "dr", "wy", "dim", "dm", "phy", "dyl"], "w_prev": ["w_orig", "wa_prev", "wa_rev", "w_req", "w_adj", "w_reverse", "wa_ref", "wa_req", " w_best", " w_orig", "w___pre", "w_ref", "wa_adj", " w_next", "w_best", " w_pre", "w___rev", "w___prev", "wa_vious", "wa_best", "w_rev", " w_final", "wa_next", " w_reverse", "w_final", "wa_orig", "w_pre", "w___final", "w_vious", " w_rev", "w_next"]}}
{"project": "qemu", "commit_id": "43771539d4666cba16298fc6b0ea63867425277c", "target": 0, "func": "static RAMBlock *qemu_get_ram_block(ram_addr_t addr)\n\n{\n\n    RAMBlock *block;\n\n\n\n    /* The list is protected by the iothread lock here.  */\n\n    block = ram_list.mru_block;\n\n    if (block && addr - block->offset < block->max_length) {\n\n        goto found;\n\n    }\n\n    QTAILQ_FOREACH(block, &ram_list.blocks, next) {\n\n        if (addr - block->offset < block->max_length) {\n\n            goto found;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Bad ram offset %\" PRIx64 \"\\n\", (uint64_t)addr);\n\n    abort();\n\n\n\nfound:\n\n    ram_list.mru_block = block;\n\n    return block;\n\n}\n", "idx": 12314, "substitutes": {"addr": ["area", "args", "port", "Address", "rr", "rss", "docker", "amp", "adder", "inter", "array", "arm", "amd", "config", "art", "code", "name", "align", "image", "progress", "ref", "ace", "hash", " address", "error", "access", "grad", "ad", "size", "adr", "layer", "info", "resource", "data", "ext", "base", "pointer", "byte", "length", "arp", "point", "address", "ip", "number", "url", "ac", "offset", "clock", "network", "host", "ack", "mac", "ress", "nr", "src", "ar", "dr", "hop", "prefix", "seq", "pad", "len", "ptr", "slice", "node"], "block": ["map", "blocks", "tx", "bc", "build", "batch", "val", "i", "label", "def", "pre", "image", "new", "pool", "module", "raw", "loc", "frame", "limit", "base", "box", "list", "flow", "line", "out", "work", "off", "lock", "num", "index", "bin", "part", "sync", "id", "full", "key", "error", "check", "group", "clean", " Block", "pack", "page", "byte", "length", "result", "ip", "number", "clock", "function", "body", "link", "ack", "cache", "run", "condition", "config", "Block", "null", "ref", "unit", "buffer", "update", "square", "valid", "value", "o", "none", "point", "address", "type", "wall", "no", "bl", "prev", "node", "record", "object", "orig", "name", "row", "range", "chain", "inv", "open", "plugin", "parent"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "static int usbnet_can_receive(VLANClientState *nc)\n\n{\n\n    USBNetState *s = DO_UPCAST(NICState, nc, nc)->opaque;\n\n\n\n    if (s->rndis && !s->rndis_state == RNDIS_DATA_INITIALIZED)\n\n        return 1;\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 12320, "substitutes": {"nc": ["cm", "bc", "uc", "cv", "enc", "unc", "cc", "pc", "rc", "cdn", "nn", "lc", "cs", "ci", "rn", "cn", "nd", "ct", "nw", "conn", "np", "ctx", "online", "n", "ns", "c", "inc", "dc", "fc", "ne", "anc", "ng", "nt", "nec", "dn", "ec", "nic", "NC", "nm"], "s": ["secondary", "south", "ses", "m", "parts", "sync", "sg", "fs", "i", "sym", "rs", "g", "cs", "qs", "S", "hs", "settings", "its", "sets", "si", "js", "uns", "sq", "es", "ps", "ss", "o", "p", "e", "sb", "n", "gs", "state", "acks", "c", "ns", "ans", "xs", "is", "ssl", "sv", "sl", "als", "states", "r", "ds", "services", "comm", "su", "ls", "ts", "ads", "ks"]}}
{"project": "qemu", "commit_id": "333d50fe3d9a1ff0a6a1a44ef42a0d3a2a7f2abe", "target": 0, "func": "static int scsi_disk_emulate_mode_sense(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    uint64_t nb_sectors;\n\n    int page, dbd, buflen, page_control;\n\n    uint8_t *p;\n\n    uint8_t dev_specific_param;\n\n\n\n    dbd = req->cmd.buf[1]  & 0x8;\n\n    page = req->cmd.buf[2] & 0x3f;\n\n    page_control = (req->cmd.buf[2] & 0xc0) >> 6;\n\n    DPRINTF(\"Mode Sense(%d) (page %d, len %d, page_control %d)\\n\",\n\n        (req->cmd.buf[0] == MODE_SENSE) ? 6 : 10, page, len, page_control);\n\n    memset(outbuf, 0, req->cmd.xfer);\n\n    p = outbuf;\n\n\n\n    if (bdrv_is_read_only(s->bs)) {\n\n        dev_specific_param = 0x80; /* Readonly.  */\n\n    } else {\n\n        dev_specific_param = 0x00;\n\n    }\n\n\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        p[1] = 0; /* Default media type.  */\n\n        p[2] = dev_specific_param;\n\n        p[3] = 0; /* Block descriptor length.  */\n\n        p += 4;\n\n    } else { /* MODE_SENSE_10 */\n\n        p[2] = 0; /* Default media type.  */\n\n        p[3] = dev_specific_param;\n\n        p[6] = p[7] = 0; /* Block descriptor length.  */\n\n        p += 8;\n\n    }\n\n\n\n    bdrv_get_geometry(s->bs, &nb_sectors);\n\n    if ((~dbd) & nb_sectors) {\n\n        if (req->cmd.buf[0] == MODE_SENSE) {\n\n            outbuf[3] = 8; /* Block descriptor length  */\n\n        } else { /* MODE_SENSE_10 */\n\n            outbuf[7] = 8; /* Block descriptor length  */\n\n        }\n\n        nb_sectors /= s->cluster_size;\n\n        if (nb_sectors > 0xffffff)\n\n            nb_sectors = 0;\n\n        p[0] = 0; /* media density code */\n\n        p[1] = (nb_sectors >> 16) & 0xff;\n\n        p[2] = (nb_sectors >> 8) & 0xff;\n\n        p[3] = nb_sectors & 0xff;\n\n        p[4] = 0; /* reserved */\n\n        p[5] = 0; /* bytes 5-7 are the sector size in bytes */\n\n        p[6] = s->cluster_size * 2;\n\n        p[7] = 0;\n\n        p += 8;\n\n    }\n\n\n\n    if (page_control == 3) { /* Saved Values */\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    switch (page) {\n\n    case 0x04:\n\n    case 0x05:\n\n    case 0x08:\n\n    case 0x2a:\n\n        p += mode_sense_page(req, page, p, page_control);\n\n        break;\n\n    case 0x3f:\n\n        p += mode_sense_page(req, 0x08, p, page_control);\n\n        p += mode_sense_page(req, 0x2a, p, page_control);\n\n        break;\n\n    default:\n\n        return -1; /* ILLEGAL_REQUEST */\n\n    }\n\n\n\n    buflen = p - outbuf;\n\n    /*\n\n     * The mode data length field specifies the length in bytes of the\n\n     * following data that is available to be transferred. The mode data\n\n     * length does not include itself.\n\n     */\n\n    if (req->cmd.buf[0] == MODE_SENSE) {\n\n        outbuf[0] = buflen - 1;\n\n    } else { /* MODE_SENSE_10 */\n\n        outbuf[0] = ((buflen - 2) >> 8) & 0xff;\n\n        outbuf[1] = (buflen - 2) & 0xff;\n\n    }\n\n    if (buflen > req->cmd.xfer)\n\n        buflen = req->cmd.xfer;\n\n    return buflen;\n\n}\n", "idx": 12326, "substitutes": {"req": ["sem", "proc", "rs", "def", "low", "str", "mr", "rec", "tar", "requ", "rw", "spec", "serv", "cb", "pro", "call", "ru", "dq", "ra", "sr", "fr", "client", "grad", "resource", "require", "data", "r", "exec", "cache", "comm", "res", "reg", "rf", "rr", "gr", "tr", "config", "wx", "ref", "rh", "conn", "ir", "desc", "rx", "http", "comp", "qt", "j", "f", "query", "ro", "wa", "rob", "re", "rt", "cur", "ctx", "err", "input", "jp", "required", "row", "sq", "conf", "request", "crit", "q", "cmd", "org", "resp", "qq", "src", "seq"], "outbuf": ["bootbuff", "OUTbuf", "outbuffer", "outcb", "Outcb", "newbuff", "blockbuff", " outbuffer", "upbuff", "blockbuf", " outbuff", "OUTbuff", "infb", "Outbuff", " outuf", "newuf", "Outuf", "OUTbuffer", "OUTuf", "OUTcb", "incb", "inbuffer", "outfp", "inbuff", "Outbuf", "infp", "Outbuffer", "outbuff", "bootbuf", "newbuffer", "newbuf", "bootfp", "upfb", "bootfb", "blockuf", "upfp", "blockbuffer", "outfb", "upbuf", "inuf", "outuf", "inbuf"], "s": ["qs", "js", "si", "ps", "requ", "spec", "c", "serv", "st", "m", "self", "d", "t", "sync", "sg", "sym", "g", "cs", "session", "w", "b", "ns", "r", "sa", "sis", "ks", "sys", "service", "sp", "os", "o", "z", "e", "http", "j", "f", "services", "ls", "ses", "_", "l", "S", "sq", "v", "n", "gs", "ssl", "q", "ds", "su", "y"], "nb_sectors": ["nb_geeters", "nb_gector", "nb_enseats", "nb_tectors", "nb_vector", "nb_exctions", "nb_secs", "nb_secctors", "nb_veapters", "nb_seats", "nb_teors", "nb_exxes", "nb_vecs", "nb_seors", "nb_tegments", "nb_ensectors", "nb_serets", "nb_secors", "nb_pecs", "nb_peivers", "nb_pections", "nb_vegments", "nb_tragments", "nb_pectors", "nb_schegments", "nb_selos", "nb_sixctors", "nb_cecs", "nb_spectors", "nb_secgments", "nb_seapters", "nb_tractors", "nb_ensegments", "nb_pegments", "nb_seccs", "nb_cegments", "nb_gexes", "nb_seivers", "nb_secrets", "nb_verets", "nb_peats", "nb_vectors", "nb_exctors", "nb_vections", "nb_ceors", "nb_sections", "nb_vexes", "nb_seitors", "nb_legments", "nb_schelos", "nb_segments", "nb_traitors", "nb_schectors", "nb_leivers", "nb_ensecs", "nb_sector", "nb_gectors", "nb_lections", "nb_secctions", "nb_spegments", "nb_geapters", "nb_geitors", "nb_gecs", "nb_lectors", "nb_cectors", "nb_exgments", "nb_scheeters", "nb_ceats", "nb_gerets", "nb_seeters", "nb_gections", "nb_traors", "nb_sixlos", "nb_geors", "nb_gelos", "nb_geivers", "nb_spector", "nb_sixeters", "nb_gegments", "nb_sexes", "nb_tections", "nb_sixgments", "nb_secapters", "nb_ceitors", "nb_spections"], "page": ["en", "id", "pixel", "pages", "name", "row", "pg", "sp", "pp", "aa", "loc", "server", "pid", "limit", "col", "size", "rec", "pl", "min", "data", "length", "n", "Page", " Page", "result", "line", "f", "count", "ip", "number", "url", "next", "block", "c", "per", "type", "offset", "pri", "cache", "age", "pos", "order", "len", "net", "start"], "dbd": ["bdd", "devcd", "dbcd", "debn", "dbdc", " dbdn", "devd", "dbf", " dbn", "bmd", "dbdl", " dbcd", "ddds", "dbdn", "bdf", "dbid", "dbn", "bmdl", "dddc", "devdl", " dbds", "debdc", " dbdl", " dbid", "ddd", " dbdc", "bddc", "bddn", "devid", "ddf", " dbf", "bdds", "bmcd", "dbds", "debdn", "bmid", "bdn", "debd"], "buflen": ["buvelens", "bufline", "buselen", "auvelens", "buveline", "bugllen", "busellen", "bugline", "aufline", "auflen", "buflens", "auvelen", "buseline", "buglen", "auflens", "buselens", "bufllen", "auveline", "auvellen", "aufllen", "buvelen", "buvellen", "buglens"], "page_control": ["page_limit", " page_length", " page_lock", "page_con", "page__limit", "pagelexcontrol", "page_lock", "page_adjust", "page__control", " page_con", "page_length", " page_adjust", "page_controlled", "page__ctrl", "page_ctrl", " page_limit", " page_controlled", " page_ctrl", "pagelexlock", "pagelexadjust", "page__length"], "p": ["port", "it", "m", "hp", "part", "po", "d", "t", "after", "array", "jp", "l", "i", "pc", "up", "a", "pre", "api", "g", "sp", "h", "lp", "py", "x", "pp", "post", "ap", "fp", "v", "patch", "ps", "br", "o", "np", "w", "u", "params", "z", "e", "y", "pa", "b", "data", "k", "j", "op", "n", "f", "point", "wp", "at", "result", "pair", "c", "pin", "pe", "per", "pi", "q", "r", "cp", "param", "cache", "pos", "prev", "P", "tp"], "dev_specific_param": ["dev_specific_item", "dev_specificacnum", "dev_specific_ref", "dev_specific_part", "dev_special_par", "dev_special_channel", "dev_special_part", "dev_general_params", "dev_general_item", "dev_specific_channel", "dev_specificacpar", "dev_specific_params", "dev_specificaccm", "dev_specific_num", "dev_special_num", "dev_specificacparam", "dev_special_ref", "dev_general_num", "dev_special_cm", "dev_special_params", "dev_special_param", "dev_specific_par", "dev_general_param", "dev_specific_cm"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "void tcg_add_target_add_op_defs(const TCGTargetOpDef *tdefs)\n\n{\n\n    TCGOpcode op;\n\n    TCGOpDef *def;\n\n    const char *ct_str;\n\n    int i, nb_args;\n\n\n\n    for(;;) {\n\n        if (tdefs->op == (TCGOpcode)-1)\n\n            break;\n\n        op = tdefs->op;\n\n        assert((unsigned)op < NB_OPS);\n\n        def = &tcg_op_defs[op];\n\n#if defined(CONFIG_DEBUG_TCG)\n\n        /* Duplicate entry in op definitions? */\n\n        assert(!def->used);\n\n        def->used = 1;\n\n#endif\n\n        nb_args = def->nb_iargs + def->nb_oargs;\n\n        for(i = 0; i < nb_args; i++) {\n\n            ct_str = tdefs->args_ct_str[i];\n\n            /* Incomplete TCGTargetOpDef entry? */\n\n            assert(ct_str != NULL);\n\n            tcg_regset_clear(def->args_ct[i].u.regs);\n\n            def->args_ct[i].ct = 0;\n\n            if (ct_str[0] >= '0' && ct_str[0] <= '9') {\n\n                int oarg;\n\n                oarg = ct_str[0] - '0';\n\n                assert(oarg < def->nb_oargs);\n\n                assert(def->args_ct[oarg].ct & TCG_CT_REG);\n\n                /* TCG_CT_ALIAS is for the output arguments. The input\n\n                   argument is tagged with TCG_CT_IALIAS. */\n\n                def->args_ct[i] = def->args_ct[oarg];\n\n                def->args_ct[oarg].ct = TCG_CT_ALIAS;\n\n                def->args_ct[oarg].alias_index = i;\n\n                def->args_ct[i].ct |= TCG_CT_IALIAS;\n\n                def->args_ct[i].alias_index = oarg;\n\n            } else {\n\n                for(;;) {\n\n                    if (*ct_str == '\\0')\n\n                        break;\n\n                    switch(*ct_str) {\n\n                    case 'i':\n\n                        def->args_ct[i].ct |= TCG_CT_CONST;\n\n                        ct_str++;\n\n                        break;\n\n                    default:\n\n                        if (target_parse_constraint(&def->args_ct[i], &ct_str) < 0) {\n\n                            fprintf(stderr, \"Invalid constraint '%s' for arg %d of operation '%s'\\n\",\n\n                                    ct_str, i, def->name);\n\n                            exit(1);\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        /* TCGTargetOpDef entry with too much information? */\n\n        assert(i == TCG_MAX_OP_ARGS || tdefs->args_ct_str[i] == NULL);\n\n\n\n        /* sort the constraints (XXX: this is just an heuristic) */\n\n        sort_constraints(def, 0, def->nb_oargs);\n\n        sort_constraints(def, def->nb_oargs, def->nb_iargs);\n\n\n\n#if 0\n\n        {\n\n            int i;\n\n\n\n            printf(\"%s: sorted=\", def->name);\n\n            for(i = 0; i < def->nb_oargs + def->nb_iargs; i++)\n\n                printf(\" %d\", def->sorted_args[i]);\n\n            printf(\"\\n\");\n\n        }\n\n#endif\n\n        tdefs++;\n\n    }\n\n\n\n#if defined(CONFIG_DEBUG_TCG)\n\n    i = 0;\n\n    for (op = 0; op < tcg_op_defs_max; op++) {\n\n        const TCGOpDef *def = &tcg_op_defs[op];\n\n        if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n            /* Wrong entry in op definitions? */\n\n            if (def->used) {\n\n                fprintf(stderr, \"Invalid op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        } else {\n\n            /* Missing entry in op definitions? */\n\n            if (!def->used) {\n\n                fprintf(stderr, \"Missing op definition for %s\\n\", def->name);\n\n                i = 1;\n\n            }\n\n        }\n\n    }\n\n    if (i == 1) {\n\n        tcg_abort();\n\n    }\n\n#endif\n\n}\n", "idx": 12329, "substitutes": {"tdefs": ["qtdefaultp", "tdescks", "tdiverences", "qtdefaultines", "tDefe", "tDefs", "tDEFcs", "tdivp", " tdefp", "tdeclines", "dtdescies", "tcomplks", "qtdefs", "dtdescs", "treferences", "tdefaultines", "tdeferences", " trefp", "tdfs", "tdecls", "dtdescks", "tcondp", "tdescs", "tcompls", "tDefines", "tdefp", "dtdefb", "tdefaulties", "tdeclp", "tcomplies", "tDEFerences", "dtdescb", "qtdefines", "tfunines", "trefs", "tconds", "dtdefks", "qtdefies", "qtdefp", "tdfines", "tdefines", " trefcs", "tdefb", "tdescb", "tdefaultp", "tcondines", "trefcs", "tfune", "tdivs", " tdfe", "tdefcs", "tdfe", "tDEFies", "tdefies", "trefp", "tdefe", "tdescies", "tDEFs", "tdivcs", "dtdefies", "tcomplb", " treferences", "tDEFks", "tdefaults", "dtdefs", "qtdefaults", "tdefks", "tDEFp", " tdefines", " tdfs", " tdefcs", "tcondies", " tdeferences", " tdfines", "tdeclies", "qtdefaulties", " trefs", "tfuns", "tDEFb", " tdefe"], "op": ["oper", "oid", "OP", "ype", "d", "cop", "jp", "top", "up", "mp", "orig", "code", "id", "pre", "name", "sp", "act", "operation", "x", "pp", "option", "cmp", " opt", "mod", " operation", "pop", "node", "loc", "error", "key", "force", "init", "operator", "o", "set", "open", "opus", "ant", "ind", "oc", "p", " cop", "ok", "info", "comp", "pl", "opp", "omp", "expr", "ax", "ip", " ip", "Op", "cat", "type", "gen", "loop", " operator", "ops", " Op", "hop", "dr", "prop", "lock", "off", "pos", "post", "opt", "bit"], "def": ["proc", "dist", "val", "inf", "eval", "new", "final", "raw", "nd", "pred", "obj", "dev", "old", "spec", "end", "md", "pro", "aux", "dr", "off", "ef", "DEF", "call", "d", "rc", "sup", "define", "ra", "req", "di", "gh", "error", "pass", "du", "data", "Def", "feed", "gen", "exec", "decl", "el", "defined", "config", "ref", "init", "lit", "valid", "adv", "der", "view", "info", "desc", "f", "dep", "diff", "df", "block", "cf", "pos", "push", "prev", "cl", "pkg", "da", "die", "conf", "de", "definition", "crit", "dc", "cmd", "del"], "ct_str": ["ct_exp", "apt_enc", "att_STR", "ectXwr", "cat\n", "ectXstr", "ct1exp", "unctWarr", "ct2STR", "ctWstr", "ctppath", "ctLstrip", "ctFst", "ct_oct", "satLdr", "ct_res", "ct_string", "ct64req", "ectXres", "sat_strip", "ct_strip", "ct_enc", "att_exp", "ctFenc", "dc_strip", "ct64arr", "ctwstr", "ctpexp", "ctpSTR", "ect_str", "satLstr", "ctXstr", "ect_wr", "dc_str", "ct64str", "ctXrs", "apt\n", "unct_line", "CT_exp", "ct_wr", "ct_path", "ct_arr", "ct64cur", "ctwreq", "ct64line", "unctWcur", "satLsp", "unct_cur", "ct_line", "pt_Str", "ct2exp", "ct_sp", "ctXres", "att1STR", "ct2path", "ctFstr", "cat_string", "unctWstr", "pt_string", "ectXrs", "ct64strip", "apt_string", "sat_dr", "unctWline", "ct_dr", "CT_arr", "ct2str", "ct_cur", "att1exp", "ct_req", "ctWarr", "ct_Str", "CT_br", "CT_str", "ct64oct", "pt_str", "att_str", "apt_str", "ctwstrip", "ect_res", "pt_arr", "ctXwr", "ctwoct", "dc_oct", "cat_str", "apt_st", "ect_rs", "ctLdr", "ctWline", "ct1path", "cat_st", "unct_arr", "ctLsp", "att1path", "ctFstri", "unct_str", "dc_req", "ct_stri", "ct_st", "satLstrip", "sat_sp", "ct_STR", "sat_str", "apt_stri", "ct1str", "ct_rs", "ctLstr", "att1str", "ct1STR", "ct\n", "cat_STR", "ct_br", "att_path", "ctWcur", "ctpstr", "apt_dr"], "i": ["hi", "qi", "it", "ui", "adi", "m", "I", "d", "ni", "ai", "xi", "id", "ini", "iu", "gi", "l", "iv", "io", "in", "mu", "ci", "lc", "g", "h", "x", "di", "module", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "ind", "z", "p", "e", "s", "fi", "info", "mi", "li", "k", "ix", "b", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "ij", "inner", "pi", "ic", "r", "bi", "ri", "ik", "ori", "y", "abi", "index"], "nb_args": ["wb_groups", "nb__Args", "bi_arms", "nbwcats", "NB_cats", "nb_groups", "nb_objects", "nb2aux", "nb67groups", "nb_flags", "wb_objects", "wb_args", "nb67args", "nb_pieces", "nb_cats", "NB_Args", "nb2arms", "nb___flags", "wb67pieces", "wb67objects", "nb___args", "NB__cats", "nb__args", "NB__args", "NB__Args", "nbOfgroups", "nbwargs", "bi_args", "nb___Args", "NB_args", "wb67groups", "bi_aux", "nb_Args", "nbOfpieces", "NB_flags", "nb2cs", "nb67pieces", "nb_aux", "nb__flags", "nbOfobjects", "nb__cats", "nbwArgs", "wb67args", "nb_arms", "nb_cs", "wb_pieces", "nbwflags", "nb2args", "NB__flags", "nb___cats", "nb67objects", "bi_cs", "nbOfargs"], "oarg": ["oark", "oaamp", " oblank", "soarr", "ogen", " oerg", " oark", " oar", " oang", "oblank", "oarm", "oarr", "oainc", "oavar", "oablank", "ioerg", "woang", "oargs", "oargument", "oerg", "noamp", "togen", "oaArg", "oaarg", "noargument", " oarr", "osArg", "osarg", "nogen", "soargument", "woarr", "earg", "osad", "soArg", "oad", "oaargs", "toargument", "oArg", "soarg", "ioargs", "Oarr", "oang", "osinc", " oinc", "noarg", "ecat", "osarm", " oamp", "toamp", "eArg", " ovar", "ioarg", "toar", "woarg", "ioArg", "floarg", "oinc", "ovar", "toad", "floargument", "Ovar", "ioark", " oarm", "Oarg", " oargument", "oar", "oaarr", "oamp", " ocat", "toarg", "osgen", "floarr", " oargs", " oad", "ocat", "osamp", "oaang", "oaark", "iocat", "flovar", "ioargument", "ioarr", "eerg", " oArg", "Oargument", "woblank", "osar", "osargument", "iovar", "toarm"]}}
{"project": "qemu", "commit_id": "06ac27f683c52890a6d174adba8c92354fa1eceb", "target": 1, "func": "void AUD_vlog (const char *cap, const char *fmt, va_list ap)\n\n{\n\n    if (conf.log_to_monitor) {\n\n        if (cap) {\n\n            monitor_printf(default_mon, \"%s: \", cap);\n\n        }\n\n\n\n        monitor_vprintf(default_mon, fmt, ap);\n\n    }\n\n    else {\n\n        if (cap) {\n\n            fprintf (stderr, \"%s: \", cap);\n\n        }\n\n\n\n        vfprintf (stderr, fmt, ap);\n\n    }\n\n}\n", "idx": 12347, "substitutes": {"cap": ["plug", "map", "ha", "bc", "ak", "capt", "ca", "pac", "lan", "except", "mp", "api", "caps", "gap", "null", "pool", "capacity", "cmp", "ace", "xa", "snap", "app", " caps", "apy", "aps", "av", "clip", "p", "wal", "pad", "hab", "CAP", "fab", "op", "acl", "ape", "ab", "c", "ip", "ping", "pan", "ac", "cb", "csv", "cas", "scale", "san", "Cap", "com", "mac", "span", "rap", "cl"], "fmt": ["lformat", "sfmt", "fprint", "Fformat", "iflt", "sfformat", "Fprint", "Flt", "sfprintf", "ifmt", " fformat", "fformat", " fprint", "Fmt", "flt", "llt", "ifprintf", "Fprintf", "ifformat", " flt", "lprint", "sflt", "lmt"], "ap": ["apt", "as", "ak", "amp", "array", "pac", "or", "api", "aper", "gap", "sp", "snap", "tap", "app", "aps", "apy", "av", "p", "ang", " app", "ag", "pa", "b", "af", "op", "arp", "ape", "ab", "ip", "am", "AP", "ats", "ac", "ep", "ast", "cp", "rep", "db", "age", "ar", "al", "el", "rap"]}}
{"project": "FFmpeg", "commit_id": "59c6178a54c414fd19e064f0077d00b82a1eb812", "target": 0, "func": "static int ogg_build_flac_headers(const uint8_t *extradata, int extradata_size,\n\n                                  OGGStreamContext *oggstream, int bitexact)\n\n{\n\n    const char *vendor = bitexact ? \"ffmpeg\" : LIBAVFORMAT_IDENT;\n\n    uint8_t *p;\n\n    if (extradata_size != 34)\n\n        return -1;\n\n    oggstream->header_len[0] = 51;\n\n    oggstream->header[0] = av_mallocz(51); // per ogg flac specs\n\n    p = oggstream->header[0];\n\n    bytestream_put_byte(&p, 0x7F);\n\n    bytestream_put_buffer(&p, \"FLAC\", 4);\n\n    bytestream_put_byte(&p, 1); // major version\n\n    bytestream_put_byte(&p, 0); // minor version\n\n    bytestream_put_be16(&p, 1); // headers packets without this one\n\n    bytestream_put_buffer(&p, \"fLaC\", 4);\n\n    bytestream_put_byte(&p, 0x00); // streaminfo\n\n    bytestream_put_be24(&p, 34);\n\n    bytestream_put_buffer(&p, extradata, 34);\n\n    oggstream->header_len[1] = 1+3+4+strlen(vendor)+4;\n\n    oggstream->header[1] = av_mallocz(oggstream->header_len[1]);\n\n    p = oggstream->header[1];\n\n    bytestream_put_byte(&p, 0x84); // last metadata block and vorbis comment\n\n    bytestream_put_be24(&p, oggstream->header_len[1] - 4);\n\n    bytestream_put_le32(&p, strlen(vendor));\n\n    bytestream_put_buffer(&p, vendor, strlen(vendor));\n\n    bytestream_put_le32(&p, 0); // user comment list length\n\n    return 0;\n\n}\n", "idx": 12353, "substitutes": {"extradata": ["extadata", "extractata", "extradana", "extramar", "extramata", "extrastatum", "interradada", "extmandaton", "exradata", "extradar", "extadar", "interradar", "interramaton", "interramar", "extramaton", "exrastATA", "extradada", "extadada", "extractana", "interradaton", "extractATA", "interradata", "extadaton", "extredATA", "extmandata", "interramata", "extredata", "extradaton", "exradatum", "extramada", "extmandada", "exradana", "exrastata", "interramada", "exrastatum", "extrastana", "extradATA", "extmandar", "extractatum", "extradatum", "extredana", "extrastata", "exradATA", "exrastana", "extrastATA", "extredatum"], "extradata_size": ["extradATA_len", "extradada_capacity", "extradata_capacity", "extradada_size", "extradATA_capacity", "extradada_address", "extradata_address", "extradATA_size", "extradata_len"], "oggstream": ["ggform", "obbstream", "oggstage", "oggedcontext", "oghost", "oggconfig", "oglthread", "ogaconsole", "oggfile", "obbserver", "oggedmodel", "oggthread", "ottserver", "oggedstream", "oggstring", "ogastack", "oggview", "awkview", "gowthread", "ottchannel", "ogastring", "oggserver", "oggsystem", "ottform", "oggcontext", "obbrun", "ogconsole", "oggstack", "awkstack", "awkserver", "oggtable", "ggsw", "oggcloud", "ogchannel", "ogmodel", "awkstream", "oglchannel", "ogcontext", "ogghost", "oglsw", "awkfile", "ogstack", "awkhost", "awkconfig", "oggrun", "oggedgraph", "oglsystem", "obbchannel", "awkmodel", "ottstring", "ogastream", "awkconsole", "ggmodel", "ogtable", "ottsystem", "oglstream", "oglstage", "oglform", "gowfile", "oggchannel", "awkstage", "ogserver", "ogltable", "gggraph", "obbconfig", "oggmodel", "oglfile", "ottrun", "ogsw", "ogacloud", "obbmodel", "ogggraph", "ogagraph", "awkthread", "ottstream", "ogsystem", "awkchannel", "ottmodel", "ogstream", "ogform", "ogamodel", "ogacontext", "ogview", "ggstream", "oglcontext", "ogahost", "gowstage", "oggconsole", "oglserver", "gowstream", "ogachannel", "ogconfig", "ogaview", "otttable", "ogstring", "oggform", "awkcloud", "ogcloud", "oglrun", "ggcontext", "oggsw"], "bitexact": ["itteXACT", "bitepexacting", "bitexacting", "antineXract", "antineXacting", "biteexACT", "biteexacts", "biteXact", "ittexact", "itteXact", "bitexract", "bitepexact", "itteXacts", "biterexacts", "bitexACT", "ittexract", "biterexact", "bitexacts", "ittexacts", "biteXacting", "biteXacts", "ittexACT", "antinexact", "biterexACT", "biterexract", "bitextact", "bitextacting", "biteXract", "antineXact", "bitextract", "biteXACT", "biteexact", "bitepexract", "antinexacting", "itteXract", "biteexract", "antinexract"], "vendor": ["score", "svendor", "coy", " volution", "svavor", "svorer", " vavor", "sender", "cector", "envolution", "cirgin", "ivarn", "envoice", "varn", "volution", "svirgin", "vcore", "coid", "virgin", "volendor", "cendor", "vector", "sendor", "volector", " voy", "ivcore", "voy", " vcore", "ivoy", "Vorer", "ivendor", "ivector", " voice", "vsoice", "vsolution", "svender", "vavor", "ivender", "Vavor", "vorer", "voloid", " vorer", "envoid", "vsoid", "ivoid", "envendor", "volarn", "carn", " vender", "vsendor", "svoy", "soy", "voice", "ivirgin", "cender", "vender", "Vendor"], "p": ["port", "m", "part", "po", "d", "t", "pc", "l", "i", "up", "jp", "a", "pre", "api", "g", "sp", "h", "lp", "x", "pp", "post", "ap", "fp", "v", "patch", "ps", "o", "np", "bp", "u", "z", "e", "y", "s", "pa", "pointer", "data", "b", "k", "j", "op", "n", "f", "point", "parent", "wp", "at", "ip", "c", "parser", "per", "pn", "pe", "pi", "q", "cp", "r", "param", "pr", "cache", "P", "tp", "php"]}}
{"project": "FFmpeg", "commit_id": "a6191d098a03f94685ae4c072bfdf10afcd86223", "target": 0, "func": "static void put_subframe(DCAEncContext *c, int subframe)\n\n{\n\n    int i, band, ss, ch;\n\n\n\n    /* Subsubframes count */\n\n    put_bits(&c->pb, 2, SUBSUBFRAMES -1);\n\n\n\n    /* Partial subsubframe sample count: dummy */\n\n    put_bits(&c->pb, 3, 0);\n\n\n\n    /* Prediction mode: no ADPCM, in each channel and subband */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 1, 0);\n\n\n\n    /* Prediction VQ address: not transmitted */\n\n    /* Bit allocation index */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 5, c->abits[band][ch]);\n\n\n\n    if (SUBSUBFRAMES > 1) {\n\n        /* Transition mode: none for each channel and subband */\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                put_bits(&c->pb, 1, 0); /* codebook A4 */\n\n    }\n\n\n\n    /* Scale factors */\n\n    for (ch = 0; ch < c->fullband_channels; ch++)\n\n        for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n            put_bits(&c->pb, 7, c->scale_factor[band][ch]);\n\n\n\n    /* Joint subband scale factor codebook select: not transmitted */\n\n    /* Scale factors for joint subband coding: not transmitted */\n\n    /* Stereo down-mix coefficients: not transmitted */\n\n    /* Dynamic range coefficient: not transmitted */\n\n    /* Stde information CRC check word: not transmitted */\n\n    /* VQ encoded high frequency subbands: not transmitted */\n\n\n\n    /* LFE data: 8 samples and scalefactor */\n\n    if (c->lfe_channel) {\n\n        for (i = 0; i < DCA_LFE_SAMPLES; i++)\n\n            put_bits(&c->pb, 8, quantize_value(c->downsampled_lfe[i], c->lfe_quant) & 0xff);\n\n        put_bits(&c->pb, 8, c->lfe_scale_factor);\n\n    }\n\n\n\n    /* Audio data (subsubframes) */\n\n    for (ss = 0; ss < SUBSUBFRAMES ; ss++)\n\n        for (ch = 0; ch < c->fullband_channels; ch++)\n\n            for (band = 0; band < DCAENC_SUBBANDS; band++)\n\n                    put_subframe_samples(c, ss, band, ch);\n\n\n\n    /* DSYNC */\n\n    put_bits(&c->pb, 16, 0xffff);\n\n}\n", "idx": 12357, "substitutes": {"c": ["call", "m", "mc", "cm", "self", "bc", "d", "t", "uc", "enc", "rc", "config", "l", "cc", "pc", "core", "C", "lc", "cs", "g", "ci", "ctrl", "h", "this", "cy", "con", "abc", "ct", "v", "conf", "cr", "o", "col", "w", "u", "z", "oc", "p", "e", "s", "y", "nc", "k", "tc", "b", "co", "n", "f", "cu", "dc", "ac", "cb", "sc", "cont", "ce", "cod", "cf", "ic", "coll", "cp", "cpp", "com", "vc", "cache", "xc", "ec", "cell", "cur", "fc", "cl", "ctx"], "subframe": ["ubFrame", "ubframes", "supersequence", "ubsequence", " subframes", "ubframe", "superframes", "superframe", "subFrame", "subsequence", "subframes", " subsequence", "superFrame", " subFrame"], "i": ["qi", "it", "ui", "I", "d", "ni", "ai", "xi", "id", "ini", "iu", "gi", "l", "oi", "io", "g", "ci", "ki", "x", "di", "si", "ie", "ii", "key", "v", "yi", "z", "u", "p", "e", "s", "fi", "k", "li", "b", "ix", "multi", "j", "n", "f", "ti", "ip", "inc", "is", "type", "pi", "chi", "bi", "ri", "zi", "y", "index"], "band": ["word", "device", "port", "ff", "amp", "batch", "child", "period", "low", "h", "x", "model", "nd", "ct", "br", "dev", "ver", "pl", "count", "flow", "line", "cat", "sc", "eb", "broad", "cle", "cell", "class", "work", "tag", "off", "st", "dom", "plug", "kat", "head", "part", "ground", "bb", "g", "front", "product", "gh", "bus", "key", "fr", "pass", "group", "version", "Band", "kt", "b", "length", "th", "ann", "url", "feed", "function", "uch", "wd", "core", "brand", "path", "way", "bands", "config", "nn", "connection", "sp", "kk", "step", "layer", "stage", "arch", "be", "boot", "j", "f", "gb", "block", "type", "field", "pos", "ph", "cl", "bit", "channel", "bug", "cm", "code", "back", "range", "ass", "gap", "pp", "v", "patch", "job", "plugin", "p", "not", "direction", "match", "component", "rule", "cmd", "db", "day"], "ss": ["ess", "sem", "rss", "ses", "ff", "series", "bs", "oss", "rs", "style", "nn", "SS", "ass", "cs", "sp", "test", "os", "sw", "sk", "str", "pp", "si", "es", "sq", "patch", "ps", "sch", "pass", "se", "s", "vs", "sf", "length", "spec", "ns", "ross", "feed", "ng", "uss", "sn", "sc", "tz", "sl", "ds", "su", "seq", "css", "ls", "pos", "us", "hess", "st", "iss", "ks"], "ch": ["ach", "batch", "child", "kick", "cht", "h", "br", "cher", "dev", "ver", "count", "sc", "cp", "zh", "com", "cell", "sub", "work", "part", "chip", "g", "cor", "gh", "ech", "och", "u", "b", "length", "th", "ich", "uch", "el", "core", "gr", "CH", "ci", "sw", "app", "conn", "sch", "qu", "z", "arch", "co", "j", "f", "chan", "chrom", "sh", "hop", "cur", "ph", "cl", "che", "channel", "bug", "wh", "cm", "code", "l", "sk", "tch", "v", "patch", "conf", "col", "p", "chart", "chn", "cho", "k", "Ch", "chi", "ht", "q", "coll", "vc", "inch", "y"]}}
{"project": "FFmpeg", "commit_id": "11b47038135442ec546dc348f2411e52e47549b8", "target": 0, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n\n\n    count/=2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (31 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for(i=0; i<count; i++){\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n}\n", "idx": 12362, "substitutes": {"s": ["south", "m", "ses", "context", "self", "bis", "service", "t", "sync", "fs", "your", "rs", "a", "g", "cs", "sites", "S", "settings", "qs", "this", "sets", "es", "js", "si", "sq", "session", "times", "ps", "ss", "conf", "o", "u", "p", "e", "temp", "ions", "http", "k", "b", "sf", "sb", "n", "f", "lines", "gb", "gs", "c", "ns", "is", "ssl", "side", "ops", "r", "services", "ds", "ls", "ts", "comments", "y", "ctx", "ks"], "count": ["call", "ch", "allow", "close", "cc", "id", "code", "l", "second", "child", "cast", "current", "name", "low", "weight", "pool", "sum", "force", "limit", "col", "size", "ind", "p", "Count", "e", "found", "max", "li", "page", "b", "base", "length", "n", "list", "f", "number", "c", "scroll", "try", "find", "offset", "now", "process", "all", "coll", "cache", "num", "core", "len", "depth", "index", "err"], "i": ["hi", "qi", "it", "ui", "m", "adi", "slice", "I", "d", "ai", "ni", "xi", "id", "l", "iu", "ini", "gi", "a", "oi", "io", "api", "lc", "ci", "mu", "di", "x", "si", "ie", "init", "ii", "uri", "v", "gu", "o", "yi", "u", "ind", "p", "e", "fi", "info", "mi", "li", "cli", "b", "ix", "multi", "j", "n", "f", "phi", "ti", "line", "ip", "c", "eni", "diff", "is", "inner", "ji", "pi", "bi", "ri", "zi", "abi", "index"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int start_auth_vencrypt_subauth(VncState *vs)\n\n{\n\n    switch (vs->vd->subauth) {\n\n    case VNC_AUTH_VENCRYPT_TLSNONE:\n\n    case VNC_AUTH_VENCRYPT_X509NONE:\n\n       VNC_DEBUG(\"Accept TLS auth none\\n\");\n\n       vnc_write_u32(vs, 0); /* Accept auth completion */\n\n       vnc_read_when(vs, protocol_client_init, 1);\n\n       break;\n\n\n\n    case VNC_AUTH_VENCRYPT_TLSVNC:\n\n    case VNC_AUTH_VENCRYPT_X509VNC:\n\n       VNC_DEBUG(\"Start TLS auth VNC\\n\");\n\n       return start_auth_vnc(vs);\n\n\n\n    default: /* Should not be possible, but just in case */\n\n       VNC_DEBUG(\"Reject auth %d\\n\", vs->vd->auth);\n\n       vnc_write_u8(vs, 1);\n\n       if (vs->minor >= 8) {\n\n           static const char err[] = \"Unsupported authentication type\";\n\n           vnc_write_u32(vs, sizeof(err));\n\n           vnc_write(vs, err, sizeof(err));\n\n       }\n\n       vnc_client_error(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12365, "substitutes": {"vs": ["args", "vers", "env", "ses", "vr", "cv", "versions", "bs", "iss", "fs", "ins", "vp", "rs", "Vs", "iv", "verts", "cs", "qs", "pg", "sk", "os", "nets", "vm", "opens", "es", "js", "server", "v", "pps", "ps", "ss", "ves", "ms", "VS", "alls", "obs", "plugins", "s", "vas", "eps", "otes", "ver", "ums", "lines", "gs", "state", "flows", "ns", "xs", "lv", "stats", "ov", "outs", "sv", "va", "asts", "org", "ds", "vc", "ls", "css", "vt", "ils", "vals", "sts", "ks"], "err": ["ror", "bug", "rr", "rss", "hr", "gr", "code", "extra", "orig", "ctr", "msg", "or", "range", "Error", "er", "req", "status", "str", "ner", "init", "eor", "loc", "error", "Er", "br", "fr", "var", "mr", "ind", "doc", "e", "fi", "exc", "ver", "rb", "data", "nil", "result", "magic", "diff", "arr", "type", "message", "cb", "iter", " error", "out", "r", "errors", "resp", "fee", "dr", "rage", "order"]}}
{"project": "qemu", "commit_id": "1dde716ed6719c341c1bfa427781f0715af90cbc", "target": 0, "func": "iscsi_unmap_cb(struct iscsi_context *iscsi, int status,\n\n                     void *command_data, void *opaque)\n\n{\n\n    IscsiAIOCB *acb = opaque;\n\n\n\n    if (acb->canceled != 0) {\n\n        return;\n\n    }\n\n\n\n    acb->status = 0;\n\n    if (status < 0) {\n\n        error_report(\"Failed to unmap data on iSCSI lun. %s\",\n\n                     iscsi_get_error(iscsi));\n\n        acb->status = -EIO;\n\n    }\n\n\n\n    iscsi_schedule_bh(acb);\n\n}\n", "idx": 12367, "substitutes": {"iscsi": ["ecsb", "fcci", "iscni", "ircsa", "licsi", "ircni", "fcsb", "iscsb", "fcsi", "uscdi", "fcsa", "licci", "iscsa", "ircdi", "uscsi", "iscdi", "ircsi", "ircci", "ecsa", "uscni", "ecci", "iscci", "ecsi", "uscci", "licni", "licdi", "ircsb"], "acb": ["Acb", "ACsb", "accbb", "agbb", "ucba", "ancbb", "acba", "acab", " acab", "Acsb", " acbd", "Acbd", "ACa", "Acbb", "anca", "aca", "accsb", "rcbb", "agab", " acbb", "agsb", "rca", "ancsb", "ucbb", "acbd", "ACab", "ancba", "ucbd", "ucb", "rcb", "acsb", "acbb", "accba", "ACb", "ACbd", "accbd", "ACbb", "ACba", " acsb", "rcba", "agb", "ancb", "ancbd", "accb"]}}
{"project": "qemu", "commit_id": "abd696e4f74a9d30801c6ae2693efe4e5979c2f2", "target": 0, "func": "static void virtio_notify(struct subchannel_id schid)\n\n{\n\n    kvm_hypercall(KVM_S390_VIRTIO_CCW_NOTIFY, *(u32*)&schid, 0);\n\n}\n", "idx": 12376, "substitutes": {"schid": ["appID", "chx", " schids", "schids", "skname", "skx", "chID", "appname", "chids", "schx", "appid", "SchID", "schname", "Schids", "appids", "skids", "skid", "chid", "Schname", " schx", "schID", "Schid", " schname", "chname"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static void kvm_mce_inj_srao_memscrub2(CPUState *env, target_phys_addr_t paddr)\n\n{\n\n    struct kvm_x86_mce mce = {\n\n        .bank = 9,\n\n        .status = MCI_STATUS_VAL | MCI_STATUS_UC | MCI_STATUS_EN\n\n                  | MCI_STATUS_MISCV | MCI_STATUS_ADDRV | MCI_STATUS_S\n\n                  | 0xc0,\n\n        .mcg_status = MCG_STATUS_MCIP | MCG_STATUS_RIPV,\n\n        .addr = paddr,\n\n        .misc = (MCM_ADDR_PHYS << 6) | 0xc,\n\n    };\n\n\n\n    kvm_inject_x86_mce_on(env, &mce, ABORT_ON_ERROR);\n\n    kvm_mce_broadcast_rest(env);\n\n}\n", "idx": 12377, "substitutes": {"env": ["forge", "args", "erv", "en", "context", "enh", "enc", "ea", "rc", "config", "eye", "cv", "profile", "eu", "ah", "txt", "init", "scope", "skin", "server", "conf", "conn", "np", "console", "loader", "energy", "e", "viron", "exc", "engine", "buf", "eng", "ext", "qt", "Environment", "dep", "eni", "cb", "que", "gui", "db", "ev", "ec", "emb", "him", "environment", "fen", "debug", "core", "ef", "esi", "esm", "err"], "paddr": ["lpager", "tpager", " ipamd", " ipaddress", "lpaddress", "paddress", "tpname", " pname", "tpaddr", "pamd", " paddress", " pager", "pname", "pager", "pcaddress", "pcamd", "pcaddr", " ipaddr", "tpaddress", "lpaddr", " pamd", "lpname"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lm32_evr_init(QEMUMachineInitArgs *args)\n\n{\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    LM32CPU *cpu;\n\n    CPULM32State *env;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *address_space_mem =  get_system_memory();\n\n    MemoryRegion *phys_ram = g_new(MemoryRegion, 1);\n\n    qemu_irq *cpu_irq, irq[32];\n\n    ResetInfo *reset_info;\n\n    int i;\n\n\n\n    /* memory map */\n\n    target_phys_addr_t flash_base  = 0x04000000;\n\n    size_t flash_sector_size       = 256 * 1024;\n\n    size_t flash_size              = 32 * 1024 * 1024;\n\n    target_phys_addr_t ram_base    = 0x08000000;\n\n    size_t ram_size                = 64 * 1024 * 1024;\n\n    target_phys_addr_t timer0_base = 0x80002000;\n\n    target_phys_addr_t uart0_base  = 0x80006000;\n\n    target_phys_addr_t timer1_base = 0x8000a000;\n\n    int uart0_irq                  = 0;\n\n    int timer0_irq                 = 1;\n\n    int timer1_irq                 = 3;\n\n\n\n    reset_info = g_malloc0(sizeof(ResetInfo));\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"lm32-full\";\n\n    }\n\n    cpu = cpu_lm32_init(cpu_model);\n\n    env = &cpu->env;\n\n    reset_info->cpu = cpu;\n\n\n\n    reset_info->flash_base = flash_base;\n\n\n\n    memory_region_init_ram(phys_ram, \"lm32_evr.sdram\", ram_size);\n\n    vmstate_register_ram_global(phys_ram);\n\n    memory_region_add_subregion(address_space_mem, ram_base, phys_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    /* Spansion S29NS128P */\n\n    pflash_cfi02_register(flash_base, NULL, \"lm32_evr.flash\", flash_size,\n\n                          dinfo ? dinfo->bdrv : NULL, flash_sector_size,\n\n                          flash_size / flash_sector_size, 1, 2,\n\n                          0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1);\n\n\n\n    /* create irq lines */\n\n    cpu_irq = qemu_allocate_irqs(cpu_irq_handler, env, 1);\n\n    env->pic_state = lm32_pic_init(*cpu_irq);\n\n    for (i = 0; i < 32; i++) {\n\n        irq[i] = qdev_get_gpio_in(env->pic_state, i);\n\n    }\n\n\n\n    sysbus_create_simple(\"lm32-uart\", uart0_base, irq[uart0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer0_base, irq[timer0_irq]);\n\n    sysbus_create_simple(\"lm32-timer\", timer1_base, irq[timer1_irq]);\n\n\n\n    /* make sure juart isn't the first chardev */\n\n    env->juart_state = lm32_juart_init();\n\n\n\n    reset_info->bootstrap_pc = flash_base;\n\n\n\n    if (kernel_filename) {\n\n        uint64_t entry;\n\n        int kernel_size;\n\n\n\n        kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL,\n\n                               1, ELF_MACHINE, 0);\n\n        reset_info->bootstrap_pc = entry;\n\n\n\n        if (kernel_size < 0) {\n\n            kernel_size = load_image_targphys(kernel_filename, ram_base,\n\n                                              ram_size);\n\n            reset_info->bootstrap_pc = ram_base;\n\n        }\n\n\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, reset_info);\n\n}\n", "idx": 12378, "substitutes": {"args": ["actions", "parts", "enc", "sg", "arm", "config", "arms", "ins", "utils", "resources", "api", "ass", "g", "cs", "ig", "words", "ants", "lang", "arg", "init", "module", "ras", "flags", "ms", "parse", "params", "ext", "apps", "Args", "lines", "gs", "ns", "parser", "ands", "arr", "ams", "atts", "sci", "Arg", "cmd", "ae", "alloc", "ks", "aws"], "cpu_model": ["cpu_location", "cpuslocation", "cpusmodel", "cpuallmodel", "cpubookdir", "cpufmachine", "modulesmodels", "core_models", "modulesmodel", "cpuallmodule", "modulesserver", "module_model", "cpu_range", "processor_mode", "module_models", "gpu_module", "cpusserver", "cpufmodels", "cpufserver", "processor_base", "gpu_dir", "module_machine", "cpu_models", "module_server", "core_model", "cpusmodels", "cpubookmodule", "modulesmachine", "cpu_base", "cpufmodel", "gpu_network", "cpu_module", "cpualldir", "cpusrange", "cpu_network", "core_range", "core_location", "processor_models", "cpu_machine", "cpu_mode", "cpusmachine", "cpuallnetwork", "gpu_base", "processor_model", "gpu_models", "cpu_dir", "cpu_string", "gpu_model", "cpubooknetwork", "cpu_server", "cpubookmodel", "gpu_string"], "kernel_filename": ["kernel_definition", "kernelacuri", "cpu_directory", "kernelacfilename", "kernelffilename", "kernel_image", "cpu_definition", "cpu_file", "process_image", "kernelfuri", "process_filename", "kernelandfile", "process_uri", "process_resource", "kernelanddirectory", "kernelfimage", "kernel_uri", "cpu_filename", "kernelacresource", "kernel_file", "kernelandfilename", "kernelacimage", "kernelfresource", "kernel_resource", "kernel_directory", "kernelanddefinition"], "cpu": ["consumer", "proc", "hp", "bench", "python", "queue", "ram", "pc", "jp", "memory", "chip", "utils", "home", "gc", "lc", "kernel", "cn", "uu", "pool", "module", "vm", "unit", "image", "cmp", "node", "linux", "hu", "performance", "gru", "computer", "pu", "platform", "conn", "np", "processor", "loader", "GPU", "mem", "p", " CPU", "ctx", "boot", "cli", "CPU", "nc", "component", "c", "eni", "gpu", "prem", "lu", "clock", "process", "cp", "host", "cache", "prefix", "nic", "program", "core", "hw", "net", "phy", "gp"], "env": ["path", "edge", "context", "en", "ea", "enc", "config", "profile", "ini", " environment", "extra", "eu", "style", "vm", "scope", "skin", "dir", "session", "v", "conf", "conn", "np", "console", "loader", "energy", "dev", "enable", "equ", "info", "engine", "exc", "viron", "exe", "e", "ext", "Environment", "state", "shell", "eni", "ne", "attr", "network", "uv", "exec", "gui", "db", "cache", "ev", "ec", "theme", "environment", "el", "core", "ef", "err"], "dinfo": ["pconfig", "dinf", "ldconfig", "dcdata", "dvalue", " daction", "lderror", "pinfo", " dinf", "bconfig", "ldinfo", " ddata", "ddconfig", "binfo", "bni", " dconfig", "dcinfo", "fdvalue", "ddinf", "dconfig", "derror", "dderror", " dvalue", "fdaction", " dni", "dbconfig", "dbinfo", "dninfo", "ldinf", "dcconfig", "dnaction", "pinf", "dnvalue", "dbdata", "dni", "ddinfo", "daction", "pni", "dninf", " derror", "binf", "fdinf", "ddata", "fdinfo"], "address_space_mem": ["address_area_ram", "address_space__memory", "address_space_memory", "address_space__mem", "address_space_ram", "address_space__lim", "address_service_mem", "address_space2lim", "address_space__ram", "address_service_nm", "address_area_mem", "address_space_mm", "address_service_ram", "address_space2memory", "address_space_nm", "address_service_mm", "address_space2ram", "address_area_memory", "address_area_lim", "address_space_lim", "address_space2mem"], "phys_ram": ["physFgram", "physFram", "physfdisk", "physical_resource", "phys_region", "physFarray", "physibgram", "physical_channel", "phys_mode", "phys__ram", "physical_ram", "phys_array", "physfregion", "las_array", "physibmodel", "physical_flash", "physibram", "phys__channel", "physical_model", "phys__flash", "physfram", "phys_gram", "physibresource", "phys__region", "phys_disk", "las_disk", "las_region", "physjregion", "phys_flash", "phys_resource", "physfgram", "physical_region", "physFmode", "las_gram", "physjflash", "physjchannel", "physjram", "las_mode", "phys_model", "phys_channel", "physical_gram", "las_ram"], "cpu_irq": ["cpu_mirq", "cpu_iperqu", "cpu_iperqs", "cpu_iperq", "cpu_mirqu", "cpu_irqs", "cpu_irequ", "cpu_ireq", "cpu_mirqs", "cpu_iperce", "cpu_irece", "cpu_irqu", "cpu_mirce", "cpu_irce", "cpu_ireqs"], "irq": ["iraq", " irqs", "IRqs", "IRq", " irch", "iraqs", "irach", "irqs", "irch", "iraf", "IRch", "irf", " irf", "IRf"], "reset_info": [" reset_information", "config_information", "updateerid", "reset_image", "reset_result", "reseterinformation", "resetjinfo", "update_id", "launch_image", "launch_ori", "reset_information", "launch_id", "configerinfo", "reseterinfo", " reset_Info", "reset_Info", "reset_ori", "configerobject", "reset_id", "updateerresult", "config_info", "reset\u00b7ori", "configerinformation", "resetallinformation", "update_info", "reseterresult", " reset_internal", "config_Info", "resetjinformation", "reseterInfo", "reseterid", "reset\u00b7id", "reseterinner", "reset_inner", "update_inner", "reset_object", "resetallInfo", "updateerinfo", "launch_info", "resetjInfo", "resetallinfo", "reset\u00b7info", "update_result", "configerInfo", "config_object", "reseterobject", "reset\u00b7image", "updateerinner", "resetjinternal", "reset_internal", "resetallobject"], "i": ["m", "I", "d", "l", "a", "io", "or", "g", "h", "ii", "v", "o", "ed", "z", "u", "p", "e", "s", "b", "j", "n", "f", "c", "is", "pi", "r", "in"]}}
{"project": "qemu", "commit_id": "075a1fe788d36b271ec25507466c30b9a90b5d54", "target": 0, "func": "static void gen_msa_branch(CPUMIPSState *env, DisasContext *ctx, uint32_t op1)\n\n{\n\n    uint8_t df = (ctx->opcode >> 21) & 0x3;\n\n    uint8_t wt = (ctx->opcode >> 16) & 0x1f;\n\n    int64_t s16 = (int16_t)ctx->opcode;\n\n\n\n    check_msa_access(ctx);\n\n\n\n    if (ctx->insn_flags & ISA_MIPS32R6 && ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        generate_exception_end(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n    switch (op1) {\n\n    case OPC_BZ_V:\n\n    case OPC_BNZ_V:\n\n        {\n\n            TCGv_i64 t0 = tcg_temp_new_i64();\n\n            tcg_gen_or_i64(t0, msa_wr_d[wt<<1], msa_wr_d[(wt<<1)+1]);\n\n            tcg_gen_setcondi_i64((op1 == OPC_BZ_V) ?\n\n                    TCG_COND_EQ : TCG_COND_NE, t0, t0, 0);\n\n            tcg_gen_trunc_i64_tl(bcond, t0);\n\n            tcg_temp_free_i64(t0);\n\n        }\n\n        break;\n\n    case OPC_BZ_B:\n\n    case OPC_BZ_H:\n\n    case OPC_BZ_W:\n\n    case OPC_BZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        break;\n\n    case OPC_BNZ_B:\n\n    case OPC_BNZ_H:\n\n    case OPC_BNZ_W:\n\n    case OPC_BNZ_D:\n\n        gen_check_zero_element(bcond, df, wt);\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, bcond, bcond, 0);\n\n        break;\n\n    }\n\n\n\n    ctx->btarget = ctx->pc + (s16 << 2) + 4;\n\n\n\n    ctx->hflags |= MIPS_HFLAG_BC;\n\n    ctx->hflags |= MIPS_HFLAG_BDS32;\n\n}\n", "idx": 12383, "substitutes": {"env": ["proc", "en", "ch", "queue", "enc", "gr", "rc", "eu", "def", "req", "txt", "scope", "conf", "console", "obj", "dev", "e", "viron", "exc", "buf", "inst", "cb", "que", "exec", "ec", "environment", "cl", "err"], "ctx": ["context", "tx", "pkg", "bc", "qa", "cm", "cv", "ca", "sync", "rc", "config", "pc", "cc", "jp", "utils", "msg", "Context", "ctrl", "cs", "ci", "lc", "req", "wx", "cpu", "std", "cn", "conv", "wcs", "txt", "cmp", "cms", "fp", "ct", "loc", "conn", "kw", "client", "console", "obj", "lib", "cli", "ck", "tc", "qt", "acl", "wp", "cfg", "c", "cca", "cu", "anc", "cb", "cas", "sc", "sci", "cmd", "cf", "cp", "exec", "kb", "vc", "cpp", "xc", "ga", "fc", "git", "hw", "node", "fw"], "op1": ["OP1", "hop1", "hopOne", "optnum", " op2", "op3", "oper2", "OP2", "oper1", "oper0", "optOne", "opernum", "Op1", "op0", "OpOne", "opnum", "Op2", "opt1", " op0", "Op3", "hop2", "oper3", "opOne", "OP3", "op2", "opt2", " opnum", "opt0"]}}
{"project": "qemu", "commit_id": "65c0f1e9558c7c762cdb333406243fff1d687117", "target": 0, "func": "static QObject *parse_keyword(JSONParserContext *ctxt, QList **tokens)\n\n{\n\n    QObject *token, *ret;\n\n    QList *working = qlist_copy(*tokens);\n\n\n\n    token = qlist_pop(working);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    qobject_decref(token);\n\n    QDECREF(*tokens);\n\n    *tokens = working;\n\n\n\n    return ret;\n\n\n\nout: \n\n    qobject_decref(token);\n\n    QDECREF(working);\n\n\n\n    return NULL;\n\n}\n", "idx": 12384, "substitutes": {"ctxt": ["CTbl", "catxt", "ctbl", "CTtx", "catbl", "CText", "qtbl", "actxt", "cttxt", "CTxt", "cattxt", "catext", "qttxt", "ctext", "CTtxt", "actext", "qtext", "qtxt", "cext", "acttxt", "cttx", "ctx", "acttx", "cxt"], "tokens": ["Tokenos", "Tokents", "pokens", "targentials", "tokenentials", "tokenings", "toksens", "Tokentials", "tokicks", "pargens", "targets", "topets", "torenos", "tensentials", "pargenos", "torets", "tokenses", "tokenenses", "Tokenses", "targenos", "Targets", "Targenos", "Token", "tocents", "tokenenos", "tokenents", "pargents", "tokentials", "tokets", "torens", "topicks", "tocenos", "torents", "tensens", "Tokicks", "Tokens", "targens", "targenses", "Tokings", "tensents", "Targenses", "topenos", "Targicks", "tocets", "tokenen", "Targents", "Tokets", "toksings", "targings", "pokets", "topens", "targicks", "pokents", "Targings", "toksen", "tokings", "tokenos", "toksents", "tocens", "tokenicks", "Targens", "pargets", "Targen", "tokenets", "pokenos", "tensenses", "targen", "targents", "tokents", "tokenens", "Targentials"], "token": ["word", "translation", "event", "method", "ok", "text", "iter", "lex", "pattern", "tag", "span", "normal", "KEN", "call", "context", "bin", "sync", "seed", "or", "writer", "key", "session", "pass", "version", "resource", "socket", "data", "result", "oken", "number", "function", "cookie", "column", "header", "false", "service", "random", "current", "connection", "variable", "source", "Token", "null", "option", "character", "operator", "valid", "value", "o", "element", "document", "stop", "bot", "atom", "note", "type", "prefix", "node", "tick", "channel", "date", "notice", "before", "root", "name", "user", "tree", "request", "p", "sign", "parent", "parser", "argument", "target", "rule", "tool", "start"], "ret": ["true", "alt", "ft", "rev", "format", "reply", "complete", "tmp", "jp", "val", "id", "back", "def", "rets", "gt", "Return", "auth", "pret", "ref", "det", "hash", "arg", "lit", "value", "job", "output", "feat", "obj", "active", "mem", "bot", "fi", "info", "success", "data", "match", "base", "Ret", "j", "result", "att", " RET", "arr", "function", "re", "rt", "repl", "RET", "res", "reg", "flag", "len", "python"], "working": ["channel", "reading", "worked", "forcing", "checking", "existing", "using", "ordering", "thing", "array", "breaking", "workers", "worker", "containing", "Working", "locking", "missing", "wrong", "works", "writing", "starting", "session", "binding", "conf", "testing", "broken", "conn", "same", "setting", "w", "active", "including", "found", "ring", "moving", "winning", "running", "calling", "opening", "ending", "ping", "leading", "going", "ng", "inner", "network", "hand", "ing", "work", "between", "wd", "picking", "processing", "won", "loading"]}}
{"project": "FFmpeg", "commit_id": "892bbbcdc171ff0d08d69636a240ffb95f54243c", "target": 0, "func": "static av_cold int vaapi_encode_config_attributes(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext *ctx = avctx->priv_data;\n\n    VAStatus vas;\n\n    int i, n, err;\n\n    VAProfile    *profiles    = NULL;\n\n    VAEntrypoint *entrypoints = NULL;\n\n    VAConfigAttrib attr[] = {\n\n        { VAConfigAttribRTFormat        },\n\n        { VAConfigAttribRateControl     },\n\n        { VAConfigAttribEncMaxRefFrames },\n\n    };\n\n\n\n    n = vaMaxNumProfiles(ctx->hwctx->display);\n\n    profiles = av_malloc_array(n, sizeof(VAProfile));\n\n    if (!profiles) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigProfiles(ctx->hwctx->display, profiles, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query profiles: %d (%s).\\n\",\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (profiles[i] == ctx->va_profile)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding profile not found (%d).\\n\",\n\n               ctx->va_profile);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    n = vaMaxNumEntrypoints(ctx->hwctx->display);\n\n    entrypoints = av_malloc_array(n, sizeof(VAEntrypoint));\n\n    if (!entrypoints) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    vas = vaQueryConfigEntrypoints(ctx->hwctx->display, ctx->va_profile,\n\n                                   entrypoints, &n);\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Failed to query entrypoints for \"\n\n               \"profile %u: %d (%s).\\n\", ctx->va_profile,\n\n               vas, vaErrorStr(vas));\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < n; i++) {\n\n        if (entrypoints[i] == ctx->va_entrypoint)\n\n            break;\n\n    }\n\n    if (i >= n) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Encoding entrypoint not found \"\n\n               \"(%d / %d).\\n\", ctx->va_profile, ctx->va_entrypoint);\n\n        err = AVERROR(ENOSYS);\n\n        goto fail;\n\n    }\n\n\n\n    vas = vaGetConfigAttributes(ctx->hwctx->display,\n\n                                ctx->va_profile, ctx->va_entrypoint,\n\n                                attr, FF_ARRAY_ELEMS(attr));\n\n    if (vas != VA_STATUS_SUCCESS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to fetch config \"\n\n               \"attributes: %d (%s).\\n\", vas, vaErrorStr(vas));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for (i = 0; i < FF_ARRAY_ELEMS(attr); i++) {\n\n        if (attr[i].value == VA_ATTRIB_NOT_SUPPORTED) {\n\n            // Unfortunately we have to treat this as \"don't know\" and hope\n\n            // for the best, because the Intel MJPEG encoder returns this\n\n            // for all the interesting attributes.\n\n            continue;\n\n        }\n\n        switch (attr[i].type) {\n\n        case VAConfigAttribRTFormat:\n\n            if (!(ctx->va_rt_format & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Surface RT format %#x \"\n\n                       \"is not supported (mask %#x).\\n\",\n\n                       ctx->va_rt_format, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRTFormat,\n\n                .value = ctx->va_rt_format,\n\n            };\n\n            break;\n\n        case VAConfigAttribRateControl:\n\n            if (!(ctx->va_rc_mode & attr[i].value)) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Rate control mode %#x \"\n\n                       \"is not supported (mask: %#x).\\n\",\n\n                       ctx->va_rc_mode, attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            ctx->config_attributes[ctx->nb_config_attributes++] =\n\n                (VAConfigAttrib) {\n\n                .type  = VAConfigAttribRateControl,\n\n                .value = ctx->va_rc_mode,\n\n            };\n\n            break;\n\n        case VAConfigAttribEncMaxRefFrames:\n\n        {\n\n            unsigned int ref_l0 = attr[i].value & 0xffff;\n\n            unsigned int ref_l1 = (attr[i].value >> 16) & 0xffff;\n\n\n\n            if (avctx->gop_size > 1 && ref_l0 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"P frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n            if (avctx->max_b_frames > 0 && ref_l1 < 1) {\n\n                av_log(avctx, AV_LOG_ERROR, \"B frames are not \"\n\n                       \"supported (%#x).\\n\", attr[i].value);\n\n                err = AVERROR(EINVAL);\n\n                goto fail;\n\n            }\n\n        }\n\n        break;\n\n        default:\n\n            av_assert0(0 && \"Unexpected config attribute.\");\n\n        }\n\n    }\n\n\n\n    err = 0;\n\nfail:\n\n    av_freep(&profiles);\n\n    av_freep(&entrypoints);\n\n    return err;\n\n}\n", "idx": 12395, "substitutes": {"avctx": ["afconn", "AVcontext", "avectx", "navctx", "avtx", " avxc", "AVconn", "AVctrl", "AVxc", "afcontext", " avcontext", "avcontext", "avxc", "avconn", "aveconn", "avectrl", "afctx", "navxc", "AVctx", "navtx", "navcontext", "avecontext", "afctrl", "avctrl", " avtx", "AVtx"], "ctx": [" context", "tx", "ha", "bc", "mc", "ja", "ko", "auc", "wcs", "cmp", "loc", "ct", "np", "obj", "media", "ck", "concept", "c", "cat", "cb", "cas", "sc", "cp", "lex", "ga", "las", "fc", "anon", "context", "cam", "sync", "rc", "cc", "lc", "cs", "cn", "cms", "fn", "client", "pa", "kt", "anc", "cal", "exec", "kb", "xc", "git", "cv", "ca", "config", "pc", "ci", "wx", "px", "conn", "kw", "nc", "co", "qt", "voc", "cf", "prefix", "hw", "cl", "fw", "pkg", "cm", "qa", "iw", "jp", "Context", "ctrl", "act", "na", "sq", "feat", "ka", "la", "ku", "cli", "component", "cus", "wp", "cca", "cu", "sci", "cmd", "vc", "qq", "css", "gal"], "vas": ["aka", "bridge", "port", "gly", "ares", "ja", "native", "avin", "CS", "kes", "auc", "virt", "anus", "status", "wcs", "avi", "Stage", "isi", "cat", "goo", "cas", "sv", "nec", "miss", "las", "span", "kit", "true", "pas", "draw", "pse", "rus", "fs", "wordpress", "facebook", "mas", "di", "bus", "session", "nav", "ras", "pass", "s", "fi", " dc", "ns", "outs", "ops", "cal", "cache", "layout", "pic", "microsoft", "aver", "complete", "cv", "BA", "pc", "ta", "wt", "px", "valid", "inas", "opus", "document", "stage", "wal", "alls", "gpu", "wa", "va", "cf", " cs", "Va", "fw", "board", "qa", "jp", "na", "jas", "aba", "mus", "ss", "var", "av", "nw", "request", "feat", " va", "ba", "p", "buf", "vis", "cus", "nas", "wp", "usa", " canvas", "scale", "ds", "css", "kas", "vs", "sts"], "i": ["hi", "ani", "qi", "ui", "adi", "slice", "I", "d", "ni", "ai", "xi", "my", "iu", "l", "ini", "gi", "oi", "io", "id", "iv", "name", "mu", "ci", "x", "di", "si", "ie", "ii", "key", "v", "uri", "o", "yi", "u", "ind", "z", "p", "e", "info", "fi", "mini", "mi", "li", "ix", "b", "multi", "j", "phi", "f", "ti", "ip", "c", "eni", "inner", "type", "ji", "pi", "chi", "uli", "q", "bi", "ri", "ori", "y", "index"], "n": ["adj", "m", "en", "d", "t", "len", "ni", "l", "un", "N", "nn", "name", "g", "na", "rn", "h", "mn", "nb", "x", "inn", "cn", "init", "nd", "ii", "fn", "v", "nw", "conn", "o", "np", "w", "u", "z", "size", "p", "e", "nan", "s", "nc", "k", "b", "min", "j", "f", "nu", "none", "c", "ns", "ne", "pn", "sn", "nt", "network", "all", "r", "dn", "no", "num", "el", "span", "ln", "y", "net", "in", "node"], "err": ["bug", "rr", "call", "erer", "fy", "gr", "ini", "kr", "msg", "Error", "er", "act", "req", "ner", "str", "fg", "aster", "aa", "error", "Er", "rh", "fr", "late", "der", "cr", "feat", "br", "wr", "mr", "ind", "doc", "ir", "fi", "ler", "aaa", "result", "rl", "arr", "acer", "cb", " Err", "iter", "resp", "r", "fee", "pr", "ar", "dr", "rage", "usr", "y", "esi", "go"], "profiles": ["suppiles", "suppils", "facules", "metilities", "attiles", "buffiles", "compilers", "memps", "facilies", "memories", "memilies", "servessions", "compilies", "profils", "facils", "facilers", "facples", "buffilings", "Profories", "attils", "compples", "attilers", "metules", "profules", "profilings", "protilers", "protilings", "buffils", " profories", "attories", "compiles", "suppories", "protils", "Profiles", "protilies", "faciles", "profilers", "protessions", "professions", "servils", "Profils", "similers", "protiles", "similes", "metils", "protples", "memiles", "profilies", "facilities", "profps", "suppilers", "metiles", "serviles", "profples", "Profilies", "profilities", " profilies", "Profps", " profps", "Profules", "simories", "profories", "buffessions", "Profilities", "simils", "servilings"], "entrypoints": ["EntryPoints", " entryps", " entryPoints", "gepoints", "enterports", "enterpoint", "entports", "entryps", "entPoints", "Entrypoints", "entryPoints", "entps", " entryports", "entryports", "enterpoints", " entrypoint", "geports", "gePoints", "enterps", "Entryports", "Entrypoint", "entpoints", "entrypoint", "gepoint", "enterPoints"], "attr": ["types", "map", "d", "array", "rs", "eval", "lib", "Interface", "params", "options", "info", "buf", "data", "list", "att", "spec", "arr", "type", "stats", "Attribute", "r", "cache"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static int targa_encode_frame(AVCodecContext *avctx, AVPacket *pkt,\n\n                              const AVFrame *p, int *got_packet)\n\n{\n\n    int bpp, picsize, datasize = -1, ret;\n\n    uint8_t *out;\n\n\n\n    if(avctx->width > 0xffff || avctx->height > 0xffff) {\n\n        av_log(avctx, AV_LOG_ERROR, \"image dimensions too large\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    picsize = av_image_get_buffer_size(avctx->pix_fmt,\n\n                                       avctx->width, avctx->height, 1);\n\n    if ((ret = ff_alloc_packet(pkt, picsize + 45)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* zero out the header and only set applicable fields */\n\n    memset(pkt->data, 0, 12);\n\n    AV_WL16(pkt->data+12, avctx->width);\n\n    AV_WL16(pkt->data+14, avctx->height);\n\n    /* image descriptor byte: origin is always top-left, bits 0-3 specify alpha */\n\n    pkt->data[17] = 0x20 | (avctx->pix_fmt == AV_PIX_FMT_BGRA ? 8 : 0);\n\n\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_GRAY8:\n\n        pkt->data[2]  = TGA_BW;     /* uncompressed grayscale image */\n\n        pkt->data[16] = 8;          /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_RGB555LE:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompresses true-color image */\n\n        pkt->data[16] = 16;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGR24:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 24;         /* bpp */\n\n        break;\n\n    case AV_PIX_FMT_BGRA:\n\n        pkt->data[2]  = TGA_RGB;    /* uncompressed true-color image */\n\n        pkt->data[16] = 32;         /* bpp */\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Pixel format '%s' not supported.\\n\",\n\n               av_get_pix_fmt_name(avctx->pix_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    bpp = pkt->data[16] >> 3;\n\n\n\n    out = pkt->data + 18;  /* skip past the header we just output */\n\n\n\n    /* try RLE compression */\n\n    if (avctx->coder_type != FF_CODER_TYPE_RAW)\n\n        datasize = targa_encode_rle(out, picsize, p, bpp, avctx->width, avctx->height);\n\n\n\n    /* if that worked well, mark the picture as RLE compressed */\n\n    if(datasize >= 0)\n\n        pkt->data[2] |= 8;\n\n\n\n    /* if RLE didn't make it smaller, go back to no compression */\n\n    else datasize = targa_encode_normal(out, p, bpp, avctx->width, avctx->height);\n\n\n\n    out += datasize;\n\n\n\n    /* The standard recommends including this section, even if we don't use\n\n     * any of the features it affords. TODO: take advantage of the pixel\n\n     * aspect ratio and encoder ID fields available? */\n\n    memcpy(out, \"\\0\\0\\0\\0\\0\\0\\0\\0TRUEVISION-XFILE.\", 26);\n\n\n\n    pkt->size   = out + 26 - pkt->data;\n\n    pkt->flags |= AV_PKT_FLAG_KEY;\n\n    *got_packet = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 12402, "substitutes": {"avctx": ["afcv", "airctx", "avfw", "afxc", "akpkg", "AVcf", "afconfig", "vercf", "avcu", " avcontext", "avecmp", "avxc", "evcmp", "afcmd", "avecontext", "avconfig", "evcmd", "avctl", "AVconfig", "afconn", "verfw", "ajcontext", "avcv", "apcontext", "afcf", "ajfw", "AVcontext", "avectx", "afcu", "AVconn", "afcontext", "alctrl", "avectl", "evcontext", "AVpkg", "akctx", "avconn", "avectrl", "afci", "airci", "avctrl", "akcontext", "airpkg", "evctx", "akcv", "afcb", "avecb", "ajci", "avci", "avepkg", " avpkg", "avcf", "avecu", "ajxc", "vercontext", "alcb", "ajctx", "aveconfig", "aveci", "verctx", "avecf", "aircontext", "afctx", "afctl", "ajcf", "alcontext", "appkg", "afpkg", "AVcmp", "affw", "avcmp", "apctl", "airctl", "AVcu", "afcmp", "avecv", "apctx", "aircf", "avcmd", "aircmd", "aircmp", "avcontext", "avcb", "aveconn", " avconn", "AVctx", "avexc", "alctx", "avpkg", "afctrl"], "pkt": ["spkt", "pet", "pct", "pett", "prekt", "facket", "ipet", "prent", "pekt", "fkg", "peacket", " pct", "Pct", "spacket", "prect", "execitting", "pwk", "wnt", "ppacket", "execwk", "tdc", "cpct", "lacket", "cpkit", "pdc", "Pet", "ppct", "lkt", "patten", "telt", "fnt", " piece", "preacket", "fkit", "pitting", " pdc", "Piece", "fkt", "pracket", "Pkt", "ppiece", "execkt", "preett", "Patten", " pkg", "fct", " patten", "Pwk", " pet", " pnt", " pwk", "wct", "prkg", "Pnt", "packet", "ppkt", " pett", "pratten", "Pitting", "lnt", "Pett", "pnt", "ipkt", "pelt", "prkt", "piece", "pkg", "Packet", "cpnt", "Pdc", "cpkt", "ipelt", " pitting", "Pelt", "wkt", "spkg", "execacket", "tct", "Pkg", "wacket", "lkg", "pekit", " pelt", "spett", "pkit", "pent", "ipacket", "cpacket", "tacket", "tkt", " packet"], "p": ["m", "d", "i", "a", "pre", "g", "lp", "fp", "v", "o", "np", "bp", "w", "e", "pointer", "b", "j", "n", "f", "at", "wp", "c", "parser", "q", "r", "pad", "P", "tp"], "got_packet": ["buf_packet", "buf2octct", "buf2packets", "buf_compct", "buf_packct", "buf_paramets", "buf2octacket", "buf2packet", "buf_compets", "buf_paramacket", "buf_compacket", "buf_octct", "buf2packct", "buf_compet", "buf_paramct", "buf_packacket", "buf_octets", "buf2packacket", "buf_paramet", "buf_packets", "buf2octets", "buf_octet", "buf2octet", "buf_octacket"], "bpp": ["bcp", "ppps", "ppp", " bep", "Bpps", " bcp", "lbep", "Bep", "bmp", "Bcp", "lbcp", " bpps", "lbmp", "bpps", "Bpp", "pmp", "pep", "Bmp", " bmp", "bep", "lbpp"], "picsize": ["picssize", "pnicizes", "pipsiz", "pnicze", "pixze", "apicsize", "Picsization", "apicksizer", "pipsize", "pixizer", "Picssize", "Picsize", "pixiz", "pixize", "Picsiz", "picksizes", "apicksizes", "piciz", "picsiz", "apicsze", "pnicsize", "picize", "apicksze", "picizes", "Picksize", "pitssize", "picsizer", "pniciz", "pnicize", "picksiz", "picksization", "pitsization", "pnicizer", "picsizes", "picksze", "apicsizes", "picsization", "apicssize", "pitsiz", "pipsization", "picksizer", "Picksization", "apicsiz", "pickssize", "picksize", "pipssize", "Picksiz", "apickssize", "apicsizer", "apicksize", "picsze", "pitsize", "Pickssize", "apicksiz"], "ret": ["alt", "ft", "en", "reply", "rc", "val", "code", "back", "def", "msg", "rets", "fun", "ref", "arg", "det", "lit", "valid", "error", "value", "obj", "ut", "mt", "ben", "mem", "info", "success", "match", "ext", "data", "Ret", "f", "result", "att", "cat", "nt", "re", "rt", "fail", "r", "rep", "resp", "RET", "al", "res", "reg", "flag", "len", "bit"], "out": ["bin", "format", "reply", "len", "tmp", "val", "back", "new", "arg", "output", "img", "Ret", "n", "result", "arr", "Out", "res", "num", "post", "opt", "nm", "in", "bit", "err"]}}
{"project": "qemu", "commit_id": "7ef8cf9a0861b6f67f5e57428478c31bfd811651", "target": 1, "func": "static int scsi_req_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    cmd->xfer = scsi_cdb_length(buf);\n\n    switch (buf[0]) {\n\n    case TEST_UNIT_READY:\n\n    case REWIND:\n\n    case START_STOP:\n\n    case SET_CAPACITY:\n\n    case WRITE_FILEMARKS:\n\n    case WRITE_FILEMARKS_16:\n\n    case SPACE:\n\n    case RESERVE:\n\n    case RELEASE:\n\n    case ERASE:\n\n    case ALLOW_MEDIUM_REMOVAL:\n\n    case SEEK_10:\n\n    case SYNCHRONIZE_CACHE:\n\n    case SYNCHRONIZE_CACHE_16:\n\n    case LOCATE_16:\n\n    case LOCK_UNLOCK_CACHE:\n\n    case SET_CD_SPEED:\n\n    case SET_LIMITS:\n\n    case WRITE_LONG_10:\n\n    case UPDATE_BLOCK:\n\n    case RESERVE_TRACK:\n\n    case SET_READ_AHEAD:\n\n    case PRE_FETCH:\n\n    case PRE_FETCH_16:\n\n    case ALLOW_OVERWRITE:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case VERIFY_10:\n\n    case VERIFY_12:\n\n    case VERIFY_16:\n\n        if ((buf[1] & 2) == 0) {\n\n            cmd->xfer = 0;\n\n        } else if ((buf[1] & 4) == 1) {\n\n            cmd->xfer = 1;\n\n        }\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case MODE_SENSE:\n\n        break;\n\n    case WRITE_SAME_10:\n\n    case WRITE_SAME_16:\n\n        cmd->xfer = dev->blocksize;\n\n        break;\n\n    case READ_CAPACITY_10:\n\n        cmd->xfer = 8;\n\n        break;\n\n    case READ_BLOCK_LIMITS:\n\n        cmd->xfer = 6;\n\n        break;\n\n    case SEND_VOLUME_TAG:\n\n        /* GPCMD_SET_STREAMING from multimedia commands.  */\n\n        if (dev->type == TYPE_ROM) {\n\n            cmd->xfer = buf[10] | (buf[9] << 8);\n\n        } else {\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case WRITE_6:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case WRITE_10:\n\n    case WRITE_VERIFY_10:\n\n    case WRITE_12:\n\n    case WRITE_VERIFY_12:\n\n    case WRITE_16:\n\n    case WRITE_VERIFY_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n        /* length 0 means 256 blocks */\n\n        if (cmd->xfer == 0) {\n\n            cmd->xfer = 256;\n\n        }\n\n    case READ_10:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case READ_12:\n\n    case READ_16:\n\n        cmd->xfer *= dev->blocksize;\n\n        break;\n\n    case FORMAT_UNIT:\n\n        /* MMC mandates the parameter list to be 12-bytes long.  Parameters\n\n         * for block devices are restricted to the header right now.  */\n\n        if (dev->type == TYPE_ROM && (buf[1] & 16)) {\n\n            cmd->xfer = 12;\n\n        } else {\n\n            cmd->xfer = (buf[1] & 16) == 0 ? 0 : (buf[1] & 32 ? 8 : 4);\n\n        }\n\n        break;\n\n    case INQUIRY:\n\n    case RECEIVE_DIAGNOSTIC:\n\n    case SEND_DIAGNOSTIC:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    case READ_CD:\n\n    case READ_BUFFER:\n\n    case WRITE_BUFFER:\n\n    case SEND_CUE_SHEET:\n\n        cmd->xfer = buf[8] | (buf[7] << 8) | (buf[6] << 16);\n\n        break;\n\n    case PERSISTENT_RESERVE_OUT:\n\n        cmd->xfer = ldl_be_p(&buf[5]) & 0xffffffffULL;\n\n        break;\n\n    case ERASE_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* MMC command GET PERFORMANCE.  */\n\n            cmd->xfer = scsi_get_performance_length(buf[9] | (buf[8] << 8),\n\n                                                    buf[10], buf[1] & 0x1f);\n\n        }\n\n        break;\n\n    case MECHANISM_STATUS:\n\n    case READ_DVD_STRUCTURE:\n\n    case SEND_DVD_STRUCTURE:\n\n    case MAINTENANCE_OUT:\n\n    case MAINTENANCE_IN:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* GPCMD_REPORT_KEY and GPCMD_SEND_KEY from multi media commands */\n\n            cmd->xfer = buf[9] | (buf[8] << 8);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_12:\n\n        if (dev->type == TYPE_ROM) {\n\n            /* BLANK command of MMC */\n\n            cmd->xfer = 0;\n\n        } else {\n\n            cmd->xfer = ata_passthrough_12_xfer_size(dev, buf);\n\n        }\n\n        break;\n\n    case ATA_PASSTHROUGH_16:\n\n        cmd->xfer = ata_passthrough_16_xfer_size(dev, buf);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12409, "substitutes": {"cmd": ["device", "head", "call", "root", "pkg", "input", "config", "cc", "code", "child", "utils", "msg", "ht", "def", "ctrl", "req", "MD", "send", "std", "module", "cmp", "init", "nd", "ct", "force", "client", "conn", "help", "cd", "grad", "clean", "ind", "plugin", "cli", "ck", "acl", "parent", "cfg", "add", "c", "cat", "dc", "bind", "cb", "target", "md", "text", "gen", "Cmd", "cod", "cf", "nt", "command", "cookie", "cp", "mac", "comm", "host", "vc", "window", "cur", "wd", "dom", "hw", "ctx"], "dev": ["device", "proc", "ch", "cam", "d", "enc", "priv", "def", "serial", "ve", "user", "Dev", "mod", "comment", "server", "app", "valid", "conf", "unknown", "var", "der", "conn", "client", "de", "pub", "prof", "adv", "pad", "info", "ver", "engine", "temp", "desc", "data", "driver", "error", "des", "diff", "serv", "dem", "end", "dc", "DEV", "md", "dd", "ev", "off", "reg", "debug", "dom", "err"], "buf": ["func", "vec", "ff", "context", "uc", "bc", "queue", "fd", "array", "cv", "enc", "batch", "rc", "uint", "bb", "fb", "home", "bd", "msg", "uf", "conv", "bytes", "nb", "buffer", "bus", "bag", "v", "br", "buff", "band", "grab", "img", "rb", "exc", "data", "b", "fab", "Buffer", "box", "wb", "Buff", "bf", "result", "gb", "usb", "bh", "ab", "bu", "tab", "cb", "bo", "bg", "comb", "db", "src", "seq", "window", "cur", "pad", "ctx", "alloc"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static void qdm2_init(QDM2Context *q) {\n\n    static int inited = 0;\n\n\n\n    if (inited != 0)\n\n        return;\n\n    inited = 1;\n\n\n\n    qdm2_init_vlc();\n\n    ff_mpa_synth_init(mpa_window);\n\n    softclip_table_init();\n\n    rnd_table_init();\n\n    init_noise_samples();\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"init done\\n\");\n\n}\n", "idx": 12412, "substitutes": {"q": ["qi", "m", "ch", "dq", "qa", "queue", "g", "qs", "req", "h", "py", "sq", "v", "w", "qu", "quad", "u", "p", "k", "qt", "f", "query", "c", "iq", "r", "qq", "Q", "y"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static int encode_frame(FlacEncodeContext *s)\n\n{\n\n    int ch, count;\n\n\n\n    count = count_frame_header(s);\n\n\n\n    for (ch = 0; ch < s->channels; ch++)\n\n        count += encode_residual_ch(s, ch);\n\n\n\n    count += (8 - (count & 7)) & 7; // byte alignment\n\n    count += 16;                    // CRC-16\n\n\n\n    return count >> 3;\n\n}\n", "idx": 12429, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "d", "t", "sg", "fs", "i", "rs", "sym", "ches", "a", "g", "cs", "qs", "S", "settings", "os", "sets", "si", "es", "js", "sq", "conf", "ss", "o", "p", "e", "ions", "http", "sf", "sb", "b", "f", "gs", "c", "ns", "xs", "is", "ssl", "ops", "services", "cpp", "ds", "ts", "ctx", "ks"], "ch": ["channel", "che", "patch", "enc", "ach", "code", "i", "CH", "cht", "cor", "h", "sk", "v", "cha", "conf", "app", "cher", "mot", "conn", "ech", "col", "och", "sch", "ind", "dev", "p", "e", "arch", "chart", "cry", "cho", "chn", "k", "anch", "b", "length", "f", "Ch", "th", "bh", "oy", "c", "chan", "cb", "chi", "ht", "ich", "q", "change", "ur", "coll", "zh", "cp", "sh", "work", "el", "y", "err"], "count": ["call", "carry", "build", "allow", "cc", "id", "code", "l", "child", "current", "range", "name", "cond", "low", "weight", "sum", "comment", "key", "force", "error", "conf", "catch", "col", "size", "ind", "Count", "p", "found", "e", "max", "base", "length", "f", "n", "list", "c", "start", "try", "find", "type", "offset", "now", "body", "process", "cache", "num", "cur", "core", "len", "depth", "index", "err"]}}
{"project": "qemu", "commit_id": "7df9381b7aa56c897e344f3bfe43bf5848bbd3e0", "target": 0, "func": "static int vfio_add_std_cap(VFIOPCIDevice *vdev, uint8_t pos)\n\n{\n\n    PCIDevice *pdev = &vdev->pdev;\n\n    uint8_t cap_id, next, size;\n\n    int ret;\n\n\n\n    cap_id = pdev->config[pos];\n\n    next = pdev->config[pos + PCI_CAP_LIST_NEXT];\n\n\n\n    /*\n\n     * If it becomes important to configure capabilities to their actual\n\n     * size, use this as the default when it's something we don't recognize.\n\n     * Since QEMU doesn't actually handle many of the config accesses,\n\n     * exact size doesn't seem worthwhile.\n\n     */\n\n    size = vfio_std_cap_max_size(pdev, pos);\n\n\n\n    /*\n\n     * pci_add_capability always inserts the new capability at the head\n\n     * of the chain.  Therefore to end up with a chain that matches the\n\n     * physical device, we insert from the end by making this recursive.\n\n     * This is also why we pre-calculate size above as cached config space\n\n     * will be changed as we unwind the stack.\n\n     */\n\n    if (next) {\n\n        ret = vfio_add_std_cap(vdev, next);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n    } else {\n\n        /* Begin the rebuild, use QEMU emulated list bits */\n\n        pdev->config[PCI_CAPABILITY_LIST] = 0;\n\n        vdev->emulated_config_bits[PCI_CAPABILITY_LIST] = 0xff;\n\n        vdev->emulated_config_bits[PCI_STATUS] |= PCI_STATUS_CAP_LIST;\n\n    }\n\n\n\n    /* Use emulated next pointer to allow dropping caps */\n\n    pci_set_byte(vdev->emulated_config_bits + pos + PCI_CAP_LIST_NEXT, 0xff);\n\n\n\n    switch (cap_id) {\n\n    case PCI_CAP_ID_MSI:\n\n        ret = vfio_msi_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_EXP:\n\n        vfio_check_pcie_flr(vdev, pos);\n\n        ret = vfio_setup_pcie_cap(vdev, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_MSIX:\n\n        ret = vfio_msix_setup(vdev, pos);\n\n        break;\n\n    case PCI_CAP_ID_PM:\n\n        vfio_check_pm_reset(vdev, pos);\n\n        vdev->pm_cap = pos;\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    case PCI_CAP_ID_AF:\n\n        vfio_check_af_flr(vdev, pos);\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    default:\n\n        ret = pci_add_capability(pdev, cap_id, pos, size);\n\n        break;\n\n    }\n\n\n\n    if (ret < 0) {\n\n        error_report(\"vfio: %04x:%02x:%02x.%x Error adding PCI capability \"\n\n                     \"0x%x[0x%x]@0x%x: %d\", vdev->host.domain,\n\n                     vdev->host.bus, vdev->host.slot, vdev->host.function,\n\n                     cap_id, size, pos, ret);\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12434, "substitutes": {"vdev": ["jdev", "wpack", "pde", "svDev", "prad", "pdiv", "cdiv", "fdev", "vapp", "ppack", "VDev", "papp", "cdevice", " vdata", "hdef", "cdev", "lprof", "vdc", "vDev", "svev", "ldata", " vprof", "gdevice", "pdef", "cpriv", "wev", "lDev", "svdev", "wdef", "fdc", "pmod", "fver", "ld", "cde", "fdevice", "vserv", "svver", "pdevice", "gdev", "vprof", "vmod", "crad", "Vdevice", "vpack", "gdc", "vde", "vev", " vrad", " vapp", "svdef", " vmod", "vdef", "wdev", "svd", "mdiv", "Vdev", " vpriv", " vde", " vev", "svdevelopment", "vdi", "hdevice", " vserv", "fdiv", "svdevice", "jdc", " vdevelopment", "svprof", "svdiff", "vrad", " vpack", "vd", "ldevice", "svserv", " vdiff", "svde", "fdi", "jdi", " vdiv", "mde", "mapp", "ldevelopment", "pev", " vver", "hev", "vver", "vdiff", "vdevelopment", "svrad", "fdef", "hdev", "vpriv", "vdiv", "jdevice", "ldef", "fde", "lrad", "fdata", "pdiff", "Vd", "gdi", "ldev", "vdevice", "fpriv", "pserv", "svdiv", " vdevice", "vdata", "mdev", " vdef"], "pos": ["port", "val", "i", "def", "new", "x", "str", "loc", "POS", "mon", "pl", "base", "line", "spec", "end", "offset", "pro", "pri", "off", "prop", "num", "kit", "index", "args", "part", "nos", "pose", "pass", "doc", "axis", "min", "length", "body", "cache", "slot", "po", "pc", "mid", "style", "os", "ref", "unit", "lit", "pid", "pres", "sec", "add", "state", "block", "reset", "type", "no", "push", "post", "location", "pt", "name", "position", "conf", "present", "set", "col", "open", "p", "pointer", "neg", "all", "seq", "Pos", "len", "opt", "start"], "pdev": ["pconn", "pcserv", "pcdi", " prad", "svconn", " pconf", "pcdevice", " pdef", " pconn", "lpdevice", "pdi", "Pconf", "Pdev", "pcdev", "pgu", " pdevice", "lserv", "prad", "vdiff", "pdiv", "cdiv", "svrad", "fdev", "ldiff", "cdevice", " pdiv", "ldef", " pdc", "lprad", " pserv", " pdiff", "pdiff", "cdev", "cdef", "svdevice", "fdevice", "lprof", "vdc", "pprof", "ldev", "ldi", "lpdev", "pdevice", "vdevice", " pgu", "cprof", "Pgu", "ldc", "vprof", "vrad", "pserv", "crad", "cconn", "fprof", "vgu", "pconf", " pdi", "vconf", "ldevice", "pdc", "pdef", "Pdevice", "svdev"], "cap_id": ["captPtype", "capPids", "cp_name", "captPbit", "cap_info", "cap2id", " cap_style", "cap_num", "cp_type", " cap_i", " cap_ids", "ap_ID", "cap2name", "cap_style", "cap_bit", "capt_ids", " cap_ID", "capt_bit", "capPtype", "ap_path", "cap_type", " cap_name", "cap_lit", "capPbit", "caperi", "cp_info", "cap_ids", "captPid", "caperlit", "cap_ID", " cap_num", "cap_i", "ap_id", " cap_lit", "cap2num", "capt_id", "cap_path", "captPids", "capPid", "capt_type", "cp_id", "caperid", "cap_name", " cap_path", "caperID", "ap_type"], "next": ["future", "en", "small", "done", "reply", "complete", "enc", "config", "shift", "mid", "extra", "style", "second", "Next", "current", "range", "front", "new", "sequence", "full", "loc", "valid", "append", "frame", "job", "client", "step", "open", "doc", "sec", "success", "page", "min", "entry", "length", "result", "skip", "line", "state", "big", "close", "block", "first", "end", "feed", "gen", "now", "more", "last", "seq", "prev", "len", "max", "start"], "size": ["en", "small", "cm", "sync", "enc", "shift", "extra", "shape", "large", "name", "range", "g", "fun", "sp", "new", "Size", "use", "unit", "si", "full", "sum", "fat", "loc", "form", "set", "z", "ize", "six", "sec", "time", "ix", "min", "count", "n", "address", "big", "global", "end", "SIZE", "offset", "cap", "esc", "scale", "sent", "last", "empty", "el", "len", "cl", "max"], "ret": ["alt", "ft", "let", "rev", "done", "part", "reply", "bc", "art", "rc", "val", "back", "orig", "pt", "def", "rets", "gt", "fun", "flat", "status", "ref", "str", "det", "arg", "lit", "valid", "value", "feat", "pass", "obj", "pub", "mt", "fin", "info", "lt", "match", "data", "success", "Ret", "bf", "f", "result", "fit", "bare", " RET", "att", "url", "cat", "nt", "re", "out", "rt", "get", "resp", "last", "db", "pat", "RET", "al", "res", "reg", "usr", "flag", "len", "opt", "bit"]}}
{"project": "qemu", "commit_id": "fb9fb692312a84ebc6e9c10da6f374c5871ff7b0", "target": 0, "func": "int cpu_exec(CPUState *env1)\n\n{\n\n#define DECLARE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    int ret, interrupt_request;\n\n    TranslationBlock *tb;\n\n    uint8_t *tc_ptr;\n\n    unsigned long next_tb;\n\n\n\n    if (cpu_halted(env1) == EXCP_HALTED)\n\n        return EXCP_HALTED;\n\n\n\n    cpu_single_env = env1;\n\n\n\n    /* first we save global registers */\n\n#define SAVE_HOST_REGS 1\n\n#include \"hostregs_helper.h\"\n\n    env = env1;\n\n\n\n#if defined(TARGET_I386)\n\n    /* put eflags in CPU temporary format */\n\n    CC_SRC = env->eflags & (CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n    DF = 1 - (2 * ((env->eflags >> 10) & 1));\n\n    CC_OP = CC_OP_EFLAGS;\n\n    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_M68K)\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->cc_dest = env->sr & 0xf;\n\n    env->cc_x = (env->sr >> 4) & 1;\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_ARM)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n    env->exception_index = -1;\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    for(;;) {\n\n        if (setjmp(env->jmp_env) == 0) {\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n            /* if an exception is pending, we execute it here */\n\n            if (env->exception_index >= 0) {\n\n                if (env->exception_index >= EXCP_INTERRUPT) {\n\n                    /* exit request from the cpu execution loop */\n\n                    ret = env->exception_index;\n\n                    if (ret == EXCP_DEBUG)\n\n                        cpu_handle_debug_exception(env);\n\n                    break;\n\n                } else {\n\n#if defined(CONFIG_USER_ONLY)\n\n                    /* if user mode only, we simulate a fake exception\n\n                       which will be handled outside the cpu execution\n\n                       loop */\n\n#if defined(TARGET_I386)\n\n                    do_interrupt_user(env->exception_index,\n\n                                      env->exception_is_int,\n\n                                      env->error_code,\n\n                                      env->exception_next_eip);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#endif\n\n                    ret = env->exception_index;\n\n                    break;\n\n#else\n\n#if defined(TARGET_I386)\n\n                    /* simulate a real cpu exception. On i386, it can\n\n                       trigger new exceptions, but we do not handle\n\n                       double or triple faults yet. */\n\n                    do_interrupt(env->exception_index,\n\n                                 env->exception_is_int,\n\n                                 env->error_code,\n\n                                 env->exception_next_eip, 0);\n\n                    /* successfully delivered */\n\n                    env->old_exception = -1;\n\n#elif defined(TARGET_PPC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_MIPS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SPARC)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_ARM)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_SH4)\n\n\t\t    do_interrupt(env);\n\n#elif defined(TARGET_ALPHA)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_CRIS)\n\n                    do_interrupt(env);\n\n#elif defined(TARGET_M68K)\n\n                    do_interrupt(0);\n\n#endif\n\n                    env->exception_index = -1;\n\n#endif\n\n                }\n\n            }\n\n\n\n            if (kvm_enabled()) {\n\n                kvm_cpu_exec(env);\n\n                longjmp(env->jmp_env, 1);\n\n            }\n\n\n\n            next_tb = 0; /* force lookup of first TB */\n\n            for(;;) {\n\n                interrupt_request = env->interrupt_request;\n\n                if (unlikely(interrupt_request)) {\n\n                    if (unlikely(env->singlestep_enabled & SSTEP_NOIRQ)) {\n\n                        /* Mask out external interrupts for this step. */\n\n                        interrupt_request &= ~(CPU_INTERRUPT_HARD |\n\n                                               CPU_INTERRUPT_FIQ |\n\n                                               CPU_INTERRUPT_SMI |\n\n                                               CPU_INTERRUPT_NMI);\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_DEBUG) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_DEBUG;\n\n                        env->exception_index = EXCP_DEBUG;\n\n                        cpu_loop_exit();\n\n                    }\n\n#if defined(TARGET_ARM) || defined(TARGET_SPARC) || defined(TARGET_MIPS) || \\\n\n    defined(TARGET_PPC) || defined(TARGET_ALPHA) || defined(TARGET_CRIS) || \\\n\n    defined(TARGET_MICROBLAZE)\n\n                    if (interrupt_request & CPU_INTERRUPT_HALT) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_HALT;\n\n                        env->halted = 1;\n\n                        env->exception_index = EXCP_HLT;\n\n                        cpu_loop_exit();\n\n                    }\n\n#endif\n\n#if defined(TARGET_I386)\n\n                    if (interrupt_request & CPU_INTERRUPT_INIT) {\n\n                            svm_check_intercept(SVM_EXIT_INIT);\n\n                            do_cpu_init(env);\n\n                            env->exception_index = EXCP_HALTED;\n\n                            cpu_loop_exit();\n\n                    } else if (interrupt_request & CPU_INTERRUPT_SIPI) {\n\n                            do_cpu_sipi(env);\n\n                    } else if (env->hflags2 & HF2_GIF_MASK) {\n\n                        if ((interrupt_request & CPU_INTERRUPT_SMI) &&\n\n                            !(env->hflags & HF_SMM_MASK)) {\n\n                            svm_check_intercept(SVM_EXIT_SMI);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_SMI;\n\n                            do_smm_enter();\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                                   !(env->hflags2 & HF2_NMI_MASK)) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_NMI;\n\n                            env->hflags2 |= HF2_NMI_MASK;\n\n                            do_interrupt(EXCP02_NMI, 0, 0, 0, 1);\n\n                            next_tb = 0;\n\n\t\t\t} else if (interrupt_request & CPU_INTERRUPT_MCE) {\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_MCE;\n\n                            do_interrupt(EXCP12_MCHK, 0, 0, 0, 0);\n\n                            next_tb = 0;\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                                   (((env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->hflags2 & HF2_HIF_MASK)) ||\n\n                                    (!(env->hflags2 & HF2_VINTR_MASK) && \n\n                                     (env->eflags & IF_MASK && \n\n                                      !(env->hflags & HF_INHIBIT_IRQ_MASK))))) {\n\n                            int intno;\n\n                            svm_check_intercept(SVM_EXIT_INTR);\n\n                            env->interrupt_request &= ~(CPU_INTERRUPT_HARD | CPU_INTERRUPT_VIRQ);\n\n                            intno = cpu_get_pic_interrupt(env);\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing hardware INT=0x%02x\\n\", intno);\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            /* ensure that no TB jump will be modified as\n\n                               the program flow was changed */\n\n                            next_tb = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n                        } else if ((interrupt_request & CPU_INTERRUPT_VIRQ) &&\n\n                                   (env->eflags & IF_MASK) && \n\n                                   !(env->hflags & HF_INHIBIT_IRQ_MASK)) {\n\n                            int intno;\n\n                            /* FIXME: this should respect TPR */\n\n                            svm_check_intercept(SVM_EXIT_VINTR);\n\n                            intno = ldl_phys(env->vm_vmcb + offsetof(struct vmcb, control.int_vector));\n\n                            qemu_log_mask(CPU_LOG_TB_IN_ASM, \"Servicing virtual hardware INT=0x%02x\\n\", intno);\n\n                            do_interrupt(intno, 0, 0, 0, 1);\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_VIRQ;\n\n                            next_tb = 0;\n\n#endif\n\n                        }\n\n                    }\n\n#elif defined(TARGET_PPC)\n\n#if 0\n\n                    if ((interrupt_request & CPU_INTERRUPT_RESET)) {\n\n                        cpu_reset(env);\n\n                    }\n\n#endif\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        ppc_hw_interrupt(env);\n\n                        if (env->pending_interrupts == 0)\n\n                            env->interrupt_request &= ~CPU_INTERRUPT_HARD;\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD)\n\n                        && (env->sregs[SR_MSR] & MSR_IE)\n\n                        && !(env->sregs[SR_MSR] & (MSR_EIP | MSR_BIP))\n\n                        && !(env->iflags & (D_FLAG | IMM_FLAG))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_MIPS)\n\n                    if ((interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                        (env->CP0_Status & env->CP0_Cause & CP0Ca_IP_mask) &&\n\n                        (env->CP0_Status & (1 << CP0St_IE)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_EXL)) &&\n\n                        !(env->CP0_Status & (1 << CP0St_ERL)) &&\n\n                        !(env->hflags & MIPS_HFLAG_DM)) {\n\n                        /* Raise it */\n\n                        env->exception_index = EXCP_EXT_INTERRUPT;\n\n                        env->error_code = 0;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SPARC)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        if (cpu_interrupts_enabled(env) &&\n\n                            env->interrupt_index > 0) {\n\n                            int pil = env->interrupt_index & 0xf;\n\n                            int type = env->interrupt_index & 0xf0;\n\n\n\n                            if (((type == TT_EXTINT) &&\n\n                                  cpu_pil_allowed(env, pil)) ||\n\n                                  type != TT_EXTINT) {\n\n                                env->exception_index = env->interrupt_index;\n\n                                do_interrupt(env);\n\n                                next_tb = 0;\n\n                            }\n\n                        }\n\n\t\t    } else if (interrupt_request & CPU_INTERRUPT_TIMER) {\n\n\t\t\t//do_interrupt(0, 0, 0, 0, 0);\n\n\t\t\tenv->interrupt_request &= ~CPU_INTERRUPT_TIMER;\n\n\t\t    }\n\n#elif defined(TARGET_ARM)\n\n                    if (interrupt_request & CPU_INTERRUPT_FIQ\n\n                        && !(env->uncached_cpsr & CPSR_F)) {\n\n                        env->exception_index = EXCP_FIQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    /* ARMv7-M interrupt return works by loading a magic value\n\n                       into the PC.  On real hardware the load causes the\n\n                       return to occur.  The qemu implementation performs the\n\n                       jump normally, then does the exception return when the\n\n                       CPU tries to execute code at the magic address.\n\n                       This will cause the magic PC value to be pushed to\n\n                       the stack if an interrupt occured at the wrong time.\n\n                       We avoid this by disabling interrupts when\n\n                       pc contains a magic address.  */\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((IS_M(env) && env->regs[15] < 0xfffffff0)\n\n                            || !(env->uncached_cpsr & CPSR_I))) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_SH4)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_ALPHA)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD) {\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_CRIS)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && (env->pregs[PR_CCS] & I_FLAG)) {\n\n                        env->exception_index = EXCP_IRQ;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n                    if (interrupt_request & CPU_INTERRUPT_NMI\n\n                        && (env->pregs[PR_CCS] & M_FLAG)) {\n\n                        env->exception_index = EXCP_NMI;\n\n                        do_interrupt(env);\n\n                        next_tb = 0;\n\n                    }\n\n#elif defined(TARGET_M68K)\n\n                    if (interrupt_request & CPU_INTERRUPT_HARD\n\n                        && ((env->sr & SR_I) >> SR_I_SHIFT)\n\n                            < env->pending_level) {\n\n                        /* Real hardware gets the interrupt vector via an\n\n                           IACK cycle at this point.  Current emulated\n\n                           hardware doesn't rely on this, so we\n\n                           provide/save the vector when the interrupt is\n\n                           first signalled.  */\n\n                        env->exception_index = env->pending_vector;\n\n                        do_interrupt(1);\n\n                        next_tb = 0;\n\n                    }\n\n#endif\n\n                   /* Don't use the cached interupt_request value,\n\n                      do_interrupt may have updated the EXITTB flag. */\n\n                    if (env->interrupt_request & CPU_INTERRUPT_EXITTB) {\n\n                        env->interrupt_request &= ~CPU_INTERRUPT_EXITTB;\n\n                        /* ensure that no TB jump will be modified as\n\n                           the program flow was changed */\n\n                        next_tb = 0;\n\n                    }\n\n                }\n\n                if (unlikely(env->exit_request)) {\n\n                    env->exit_request = 0;\n\n                    env->exception_index = EXCP_INTERRUPT;\n\n                    cpu_loop_exit();\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                if (qemu_loglevel_mask(CPU_LOG_TB_CPU)) {\n\n                    /* restore flags in standard format */\n\n#if defined(TARGET_I386)\n\n                    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n                    log_cpu_state(env, X86_DUMP_CCOP);\n\n                    env->eflags &= ~(DF_MASK | CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C);\n\n#elif defined(TARGET_ARM)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SPARC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_PPC)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_M68K)\n\n                    cpu_m68k_flush_flags(env, env->cc_op);\n\n                    env->cc_op = CC_OP_FLAGS;\n\n                    env->sr = (env->sr & 0xffe0)\n\n                              | env->cc_dest | (env->cc_x << 4);\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MICROBLAZE)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_MIPS)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_SH4)\n\n\t\t    log_cpu_state(env, 0);\n\n#elif defined(TARGET_ALPHA)\n\n                    log_cpu_state(env, 0);\n\n#elif defined(TARGET_CRIS)\n\n                    log_cpu_state(env, 0);\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n                }\n\n#endif\n\n                spin_lock(&tb_lock);\n\n                tb = tb_find_fast();\n\n                /* Note: we do it here to avoid a gcc bug on Mac OS X when\n\n                   doing it in tb_find_slow */\n\n                if (tb_invalidated_flag) {\n\n                    /* as some TB could have been invalidated because\n\n                       of memory exceptions while generating the code, we\n\n                       must recompute the hash index here */\n\n                    next_tb = 0;\n\n                    tb_invalidated_flag = 0;\n\n                }\n\n#ifdef CONFIG_DEBUG_EXEC\n\n                qemu_log_mask(CPU_LOG_EXEC, \"Trace 0x%08lx [\" TARGET_FMT_lx \"] %s\\n\",\n\n                             (long)tb->tc_ptr, tb->pc,\n\n                             lookup_symbol(tb->pc));\n\n#endif\n\n                /* see if we can patch the calling TB. When the TB\n\n                   spans two pages, we cannot safely do a direct\n\n                   jump. */\n\n                if (next_tb != 0 && tb->page_addr[1] == -1) {\n\n                    tb_add_jump((TranslationBlock *)(next_tb & ~3), next_tb & 3, tb);\n\n                }\n\n                spin_unlock(&tb_lock);\n\n\n\n                /* cpu_interrupt might be called while translating the\n\n                   TB, but before it is linked into a potentially\n\n                   infinite loop and becomes env->current_tb. Avoid\n\n                   starting execution if there is a pending interrupt. */\n\n                if (!unlikely (env->exit_request)) {\n\n                    env->current_tb = tb;\n\n                    tc_ptr = tb->tc_ptr;\n\n                /* execute the generated code */\n\n#if defined(__sparc__) && !defined(CONFIG_SOLARIS)\n\n#undef env\n\n                    env = cpu_single_env;\n\n#define env cpu_single_env\n\n#endif\n\n                    next_tb = tcg_qemu_tb_exec(tc_ptr);\n\n                    env->current_tb = NULL;\n\n                    if ((next_tb & 3) == 2) {\n\n                        /* Instruction counter expired.  */\n\n                        int insns_left;\n\n                        tb = (TranslationBlock *)(long)(next_tb & ~3);\n\n                        /* Restore PC.  */\n\n                        cpu_pc_from_tb(env, tb);\n\n                        insns_left = env->icount_decr.u32;\n\n                        if (env->icount_extra && insns_left >= 0) {\n\n                            /* Refill decrementer and continue execution.  */\n\n                            env->icount_extra += insns_left;\n\n                            if (env->icount_extra > 0xffff) {\n\n                                insns_left = 0xffff;\n\n                            } else {\n\n                                insns_left = env->icount_extra;\n\n                            }\n\n                            env->icount_extra -= insns_left;\n\n                            env->icount_decr.u16.low = insns_left;\n\n                        } else {\n\n                            if (insns_left > 0) {\n\n                                /* Execute remaining instructions.  */\n\n                                cpu_exec_nocache(insns_left, tb);\n\n                            }\n\n                            env->exception_index = EXCP_INTERRUPT;\n\n                            next_tb = 0;\n\n                            cpu_loop_exit();\n\n                        }\n\n                    }\n\n                }\n\n                /* reset soft MMU for next block (it can currently\n\n                   only be set by a memory fault) */\n\n            } /* for(;;) */\n\n        }\n\n    } /* for(;;) */\n\n\n\n\n\n#if defined(TARGET_I386)\n\n    /* restore flags in standard format */\n\n    env->eflags = env->eflags | helper_cc_compute_all(CC_OP) | (DF & DF_MASK);\n\n#elif defined(TARGET_ARM)\n\n    /* XXX: Save/restore host fpu exception state?.  */\n\n#elif defined(TARGET_SPARC)\n\n#elif defined(TARGET_PPC)\n\n#elif defined(TARGET_M68K)\n\n    cpu_m68k_flush_flags(env, env->cc_op);\n\n    env->cc_op = CC_OP_FLAGS;\n\n    env->sr = (env->sr & 0xffe0)\n\n              | env->cc_dest | (env->cc_x << 4);\n\n#elif defined(TARGET_MICROBLAZE)\n\n#elif defined(TARGET_MIPS)\n\n#elif defined(TARGET_SH4)\n\n#elif defined(TARGET_ALPHA)\n\n#elif defined(TARGET_CRIS)\n\n#elif defined(TARGET_S390X)\n\n    /* XXXXX */\n\n#else\n\n#error unsupported target CPU\n\n#endif\n\n\n\n    /* restore global registers */\n\n#include \"hostregs_helper.h\"\n\n\n\n    /* fail safe : never use cpu_single_env outside cpu_exec() */\n\n    cpu_single_env = NULL;\n\n    return ret;\n\n}\n", "idx": 12451, "substitutes": {"env1": [" env3", "environment0", "ec1", "ec3", "zone01", "env0", "zone1", "environment2", " envOne", "zone2", "env01", "en3", "environmentOne", "en1", "environment01", "en0", "envOne", "environment1", "en2", "ec0", "ecOne", "zone0", "env3", " env2", "env2", "ec2", "environment3", " env01", "enOne", " env0"], "ret": ["alt", "proc", "utf", "reply", "capt", "inter", "val", "def", "rets", "Return", "fun", "eval", "status", "buffer", "arg", "det", "mt", "mem", "info", "match", "data", "ait", "Ret", "f", "result", " RET", "att", "reset", "red", " Ret", "nt", "eth", "re", "resp", "RET", "res", "run", "len", "net", "bit"], "interrupt_request": ["interrupt67request", "intersect_request", "intersect_progress", "interrupt67window", "interrupt_window", "intersect_req", "intersect67request", "intersect67progress", "interrupt67progress", "interrupt_req", "interrupt_progress", "interrupt67req", "intersect67window", "intersect67req", "intersect_window"], "tb": ["ttb", "ltbh", "ltbl", "tbl", " tbh", "ltb", "ttbh", "ttbl", " tbl", " tbb", "ttbb", "tbh", "tbb", "ltbb"], "tc_ptr": ["tc2ptr", "tc2tr", "TC_proc", "tcfptr", "tc2proc", "tcfproc", "tc_tr", "tcfpointer", "tc_proc", "tc2pointer", "tc_pointer", "tcftr", "TC_ptr", "TC_tr", "TC_pointer"], "next_tb": ["next_Tb", "next_intb", "next_etb", "next_intbl", "next_tbl", "next_Tbb", "next_etbb", "next_intp", "next_Tp", "next_intbb", "next_Tbl", "next_tp", "next_etbl", "next_tbb", "next_etp"]}}
{"project": "qemu", "commit_id": "42a6686b2f6199d086a58edd7731faeb2dbe7c14", "target": 0, "func": "void HELPER(v7m_msr)(CPUARMState *env, uint32_t maskreg, uint32_t val)\n\n{\n\n    /* We're passed bits [11..0] of the instruction; extract\n\n     * SYSm and the mask bits.\n\n     * Invalid combinations of SYSm and mask are UNPREDICTABLE;\n\n     * we choose to treat them as if the mask bits were valid.\n\n     * NB that the pseudocode 'mask' variable is bits [11..10],\n\n     * whereas ours is [11..8].\n\n     */\n\n    uint32_t mask = extract32(maskreg, 8, 4);\n\n    uint32_t reg = extract32(maskreg, 0, 8);\n\n\n\n    if (arm_current_el(env) == 0 && reg > 7) {\n\n        /* only xPSR sub-fields may be written by unprivileged */\n\n        return;\n\n    }\n\n\n\n    switch (reg) {\n\n    case 0 ... 7: /* xPSR sub-fields */\n\n        /* only APSR is actually writable */\n\n        if (!(reg & 4)) {\n\n            uint32_t apsrmask = 0;\n\n\n\n            if (mask & 8) {\n\n                apsrmask |= XPSR_NZCV | XPSR_Q;\n\n            }\n\n            if ((mask & 4) && arm_feature(env, ARM_FEATURE_THUMB_DSP)) {\n\n                apsrmask |= XPSR_GE;\n\n            }\n\n            xpsr_write(env, val, apsrmask);\n\n        }\n\n        break;\n\n    case 8: /* MSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->v7m.other_sp = val;\n\n        } else {\n\n            env->regs[13] = val;\n\n        }\n\n        break;\n\n    case 9: /* PSP */\n\n        if (env->v7m.control & R_V7M_CONTROL_SPSEL_MASK) {\n\n            env->regs[13] = val;\n\n        } else {\n\n            env->v7m.other_sp = val;\n\n        }\n\n        break;\n\n    case 16: /* PRIMASK */\n\n        env->v7m.primask[env->v7m.secure] = val & 1;\n\n        break;\n\n    case 17: /* BASEPRI */\n\n        env->v7m.basepri[env->v7m.secure] = val & 0xff;\n\n        break;\n\n    case 18: /* BASEPRI_MAX */\n\n        val &= 0xff;\n\n        if (val != 0 && (val < env->v7m.basepri[env->v7m.secure]\n\n                         || env->v7m.basepri[env->v7m.secure] == 0)) {\n\n            env->v7m.basepri[env->v7m.secure] = val;\n\n        }\n\n        break;\n\n    case 19: /* FAULTMASK */\n\n        env->v7m.faultmask = val & 1;\n\n        break;\n\n    case 20: /* CONTROL */\n\n        /* Writing to the SPSEL bit only has an effect if we are in\n\n         * thread mode; other bits can be updated by any privileged code.\n\n         * switch_v7m_sp() deals with updating the SPSEL bit in\n\n         * env->v7m.control, so we only need update the others.\n\n         */\n\n        if (!arm_v7m_is_handler_mode(env)) {\n\n            switch_v7m_sp(env, (val & R_V7M_CONTROL_SPSEL_MASK) != 0);\n\n        }\n\n        env->v7m.control &= ~R_V7M_CONTROL_NPRIV_MASK;\n\n        env->v7m.control |= val & R_V7M_CONTROL_NPRIV_MASK;\n\n        break;\n\n    default:\n\n        qemu_log_mask(LOG_GUEST_ERROR, \"Attempt to write unknown special\"\n\n                                       \" register %d\\n\", reg);\n\n        return;\n\n    }\n\n}\n", "idx": 12452, "substitutes": {"env": ["en", "esp", "oa", "ah", "event", "gear", "server", "np", "obj", "dev", "export", "c", "end", "ep", "here", "ec", "lock", "ef", "args", "context", "rev", "iv", "eu", "vm", "txt", "skin", "console", "loader", "equ", "viron", "data", "ext", "entry", "eni", "qv", "uv", "cal", "exec", "gui", "cache", "ev", "ou", "el", "iss", "erv", "edge", "queue", "po", "ea", "cv", "config", "un", "style", "init", "scope", "app", "output", "conn", "stage", "e", "enable", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "state", "global", "ne", "que", "inet", "net", "ctx", "err", "enc", "eye", "code", "er", "act", "v", "energy", "dat", "shell", "esc", "org", "db", "vel", "emb", "environment", "vs", "et", "esi", "esm"], "maskreg": ["filterbar", "filterregister", "maskrun", "switchReg", "switchrun", "filterrec", "askregister", "markREG", "askreg", "flagrec", "maskblock", " maskrec", "askbar", "markblock", "flagReg", "flagrun", "maskregister", "filterreg", " maskbar", "filterblock", "switchrec", "filterREG", "askrun", "maskREG", " maskREG", "flagreg", "maskReg", "markregister", "markreg", "switchreg", "maskrec", "askrec", "askReg", "askREG", "maskbar", "askblock"], "val": ["tx", "fl", "local", "def", "pre", "eval", "x", "vol", "loc", "pol", "ind", "mem", "dev", "Value", "sol", "pl", "base", "count", "play", "serv", "end", "text", "sl", "fail", "rot", "index", "bin", "arg", "key", "lib", "ut", "data", "b", "entry", "ann", "item", "arr", "cal", "pr", "al", "reg", "el", "vals", "alt", "slot", "config", "VAL", "test", "fx", "pret", "ref", "buffer", "unit", "update", "lit", "live", "pid", "valid", "value", "mask", "fe", "Val", "sel", "pos", "bl", "it", "ret", "enc", "pal", "pt", "cond", "v", "sil", "var", "col", "p", "ee", "buf", "ol", "rule", "all", "aval", "len"]}}
{"project": "qemu", "commit_id": "d7651f150d61936344c4fab45eaeb0716c606af2", "target": 0, "func": "static bool migrate_caps_check(bool *cap_list,\n\n                               MigrationCapabilityStatusList *params,\n\n                               Error **errp)\n\n{\n\n    MigrationCapabilityStatusList *cap;\n\n    bool old_postcopy_cap;\n\n\n\n    old_postcopy_cap = cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM];\n\n\n\n    for (cap = params; cap; cap = cap->next) {\n\n        cap_list[cap->value->capability] = cap->value->state;\n\n    }\n\n\n\n#ifndef CONFIG_LIVE_BLOCK_MIGRATION\n\n    if (cap_list[MIGRATION_CAPABILITY_BLOCK]) {\n\n        error_setg(errp, \"QEMU compiled without old-style (blk/-b, inc/-i) \"\n\n                   \"block migration\");\n\n        error_append_hint(errp, \"Use drive_mirror+NBD instead.\\n\");\n\n        return false;\n\n    }\n\n#endif\n\n\n\n    if (cap_list[MIGRATION_CAPABILITY_POSTCOPY_RAM]) {\n\n        if (cap_list[MIGRATION_CAPABILITY_COMPRESS]) {\n\n            /* The decompression threads asynchronously write into RAM\n\n             * rather than use the atomic copies needed to avoid\n\n             * userfaulting.  It should be possible to fix the decompression\n\n             * threads for compatibility in future.\n\n             */\n\n            error_setg(errp, \"Postcopy is not currently compatible \"\n\n                       \"with compression\");\n\n            return false;\n\n        }\n\n\n\n        /* This check is reasonably expensive, so only when it's being\n\n         * set the first time, also it's only the destination that needs\n\n         * special support.\n\n         */\n\n        if (!old_postcopy_cap && runstate_check(RUN_STATE_INMIGRATE) &&\n\n            !postcopy_ram_supported_by_host()) {\n\n            /* postcopy_ram_supported_by_host will have emitted a more\n\n             * detailed message\n\n             */\n\n            error_setg(errp, \"Postcopy is not supported\");\n\n            return false;\n\n        }\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 12470, "substitutes": {"cap_list": ["cl_set", "CAP_list", "capFtable", "capFlist", "cap_info", "CAP_base", "cap_map", "cp_type", "cap_listed", "cap_base", "apeFtable", "capFlists", "cap_lists", "CAP_map", "cp_cache", "cl_list", "apeFedit", "cap_edit", "cap_type", "cap_def", "caps_list", "cap_set", "capsmap", "cp_info", "caps_set", "capFedit", "cap_note", "cap_cache", "capslists", "CAP_note", "cap_LIST", "capslist", "cl_listed", "ape_lists", "cp_list", "caps_table", "cl_LIST", "ape_edit", "cap_table", "capsset", "ape_list", "apeFlists", "CAP_lists", "ape_table", "CAP_set", "caps_def", "apeFlist"], "params": ["types", "args", "proc", "camp", "mc", "array", "tmp", "ram", "config", "rs", "shape", "changes", "pre", "api", "caps", "cs", "sp", "cms", "cmp", "ps", "conf", "instance", "options", "plugins", "cli", "eps", "comp", "acl", "json", "spec", "ip", "par", "ams", "cas", "param", "mac", "ips", "copy", "opt", "ctx"], "errp": [" errr", "serr", " errf", " errps", "serpr", " errpe", "erfp", "errf", "cerp", " errsp", "errpr", "errr", "resultfp", "resultpr", "errpe", " errcp", "errsp", "erpr", "resultps", "terr", "errfp", "terp", "derp", "verpe", "derpe", "errps", "cerps", " errfp", " errpr", "erp", "cersp", "resultp", "Err", "derpc", "verfp", "resultr", "resultsp", "verp", "Erp", "errpc", " errpc", "errcp", "verpc", "Erpr", "erf", "erps", "derfp", "terps", "sercp", "terf", "Ercp", "serp", "err"], "cap": ["plug", "card", "call", "ch", "cm", "bc", "capt", "ca", "cop", "config", "pc", "mp", "pac", "jp", "account", "caps", "ctrl", "gap", "sp", "act", "cmp", "ace", "ap", "crop", "ct", "app", "cr", "av", "clip", "an", "p", "pack", "pl", "CAP", "can", "fab", "cut", "op", "rap", "acl", "ape", "spec", "c", "ip", "block", "ab", "cat", "crit", "ac", "sc", "ce", "sv", "cf", "cod", "ep", "Cap", "cp", "com", "exec", "lex", "mac", "tool", "fac", "span", "cl"], "old_postcopy_cap": ["old_postcopy_CAP", "old_postcopy_mac", "old_postcopy__ap", "old_posttransfer_cp", "old_postshare__caps", "old_postshare__ap", "old_postshare__CAP", "old_postcopy__CAP", "old_postcopy_cp", "old_postshare__cap", "old_posttransfer_CAP", "old_postcopy__caps", "old_postcopy_caps", "old_postshare_caps", "old_posttransfer_ap", "old_postcopy_ap", "old_posttransfer_mac", "old_postshare_ap", "old_posttransfer_cap", "old_postshare_cap", "old_postshare_CAP", "old_postcopy__cap"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int virtio_blk_handle_rw_error(VirtIOBlockReq *req, int error,\n\n    bool is_read)\n\n{\n\n    BlockErrorAction action = bdrv_get_error_action(req->dev->bs, is_read, error);\n\n    VirtIOBlock *s = req->dev;\n\n\n\n    if (action == BLOCK_ERROR_ACTION_STOP) {\n\n        req->next = s->rq;\n\n        s->rq = req;\n\n    } else if (action == BLOCK_ERROR_ACTION_REPORT) {\n\n        virtio_blk_req_complete(req, VIRTIO_BLK_S_IOERR);\n\n        block_acct_done(bdrv_get_stats(s->bs), &req->acct);\n\n        virtio_blk_free_request(req);\n\n    }\n\n\n\n    bdrv_error_action(s->bs, action, is_read, error);\n\n    return action != BLOCK_ERROR_ACTION_IGNORE;\n\n}\n", "idx": 12477, "substitutes": {"req": ["sem", "proc", "rs", "def", "qs", "str", "js", "obj", "mr", "rec", "dev", "temp", "rb", "ver", "reader", "tar", "requ", "spec", "c", "pro", "args", "call", "dq", "d", "sr", "arg", "fr", "client", "w", "grad", "resource", "require", "r", "exec", "cache", "res", "reg", "rf", "rr", "ch", "gr", "tr", "config", "test", "ref", "app", "rh", "e", "sec", "info", "desc", "rx", "http", "qt", "f", "query", "load", "rt", "cur", "err", "root", "input", "required", "er", "sq", "patch", "quest", "request", "p", "crit", "pull", "q", "cmd", "org", "resp"], "error": ["ror", "bug", "action", "rr", "rss", "root", "rc", "code", "ERROR", "name", "row", "Error", "er", "event", "ace", "wrong", "comment", " Error", "patch", "unknown", "server", "o", "admin", "danger", "active", "e", "info", "resource", "data", "base", " exception", "parent", "address", "query", "block", "route", " err", "type", "function", "change", "r", "errors", "ack", "rage", "no", "index", "err"], "is_read": [" is_READ", "is_write", "is_READ", " is_valid", "is_reading", "as_read", "is_ok", "is_valid", "is_readable", "is6readable", "is6READ", "is6write", "is6read", " is_write", "as_reading", " is_ok", " is_readable", "as_write"], "s": ["sys", "ses", "self", "m", "service", "input", "t", "sg", "bs", "fs", "sync", "rs", "sym", "g", "cs", "qs", "S", "os", "sr", "si", "js", "scope", "sq", "v", "server", "ps", "ss", "app", "conf", "o", "w", "u", "p", "se", "e", "info", "sec", "http", "k", "b", "sb", "j", "n", "f", "requ", "gs", "spec", "ns", "c", "is", "q", "ops", "r", "ds", "sa", "su", "ls", "sis", "y"]}}
{"project": "FFmpeg", "commit_id": "45198477de19ccb00729b7eec07d81494f0353e0", "target": 1, "func": "static inline void FUNC(idctRowCondDC_extrashift)(int16_t *row, int extra_shift)\n\n#else\n\nstatic inline void FUNC(idctRowCondDC)(int16_t *row, int extra_shift)\n\n#endif\n\n{\n\n    int a0, a1, a2, a3, b0, b1, b2, b3;\n\n\n\n#if HAVE_FAST_64BIT\n\n#define ROW0_MASK (0xffffLL << 48 * HAVE_BIGENDIAN)\n\n    if (((AV_RN64A(row) & ~ROW0_MASK) | AV_RN64A(row+4)) == 0) {\n\n        uint64_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        temp += temp * ((uint64_t) 1 << 32);\n\n        AV_WN64A(row, temp);\n\n        AV_WN64A(row + 4, temp);\n\n        return;\n\n    }\n\n#else\n\n    if (!(AV_RN32A(row+2) |\n\n          AV_RN32A(row+4) |\n\n          AV_RN32A(row+6) |\n\n          row[1])) {\n\n        uint32_t temp;\n\n        if (DC_SHIFT - extra_shift >= 0) {\n\n            temp = (row[0] * (1 << (DC_SHIFT - extra_shift))) & 0xffff;\n\n        } else {\n\n            temp = ((row[0] + (1<<(extra_shift - DC_SHIFT-1))) >> (extra_shift - DC_SHIFT)) & 0xffff;\n\n        }\n\n        temp += temp * (1 << 16);\n\n        AV_WN32A(row, temp);\n\n        AV_WN32A(row+2, temp);\n\n        AV_WN32A(row+4, temp);\n\n        AV_WN32A(row+6, temp);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    a0 = (W4 * row[0]) + (1 << (ROW_SHIFT + extra_shift - 1));\n\n    a1 = a0;\n\n    a2 = a0;\n\n    a3 = a0;\n\n\n\n    a0 += W2 * row[2];\n\n    a1 += W6 * row[2];\n\n    a2 -= W6 * row[2];\n\n    a3 -= W2 * row[2];\n\n\n\n    b0 = MUL(W1, row[1]);\n\n    MAC(b0, W3, row[3]);\n\n    b1 = MUL(W3, row[1]);\n\n    MAC(b1, -W7, row[3]);\n\n    b2 = MUL(W5, row[1]);\n\n    MAC(b2, -W1, row[3]);\n\n    b3 = MUL(W7, row[1]);\n\n    MAC(b3, -W5, row[3]);\n\n\n\n    if (AV_RN64A(row + 4)) {\n\n        a0 +=   W4*row[4] + W6*row[6];\n\n        a1 += - W4*row[4] - W2*row[6];\n\n        a2 += - W4*row[4] + W2*row[6];\n\n        a3 +=   W4*row[4] - W6*row[6];\n\n\n\n        MAC(b0,  W5, row[5]);\n\n        MAC(b0,  W7, row[7]);\n\n\n\n        MAC(b1, -W1, row[5]);\n\n        MAC(b1, -W5, row[7]);\n\n\n\n        MAC(b2,  W7, row[5]);\n\n        MAC(b2,  W3, row[7]);\n\n\n\n        MAC(b3,  W3, row[5]);\n\n        MAC(b3, -W1, row[7]);\n\n    }\n\n\n\n    row[0] = (a0 + b0) >> (ROW_SHIFT + extra_shift);\n\n    row[7] = (a0 - b0) >> (ROW_SHIFT + extra_shift);\n\n    row[1] = (a1 + b1) >> (ROW_SHIFT + extra_shift);\n\n    row[6] = (a1 - b1) >> (ROW_SHIFT + extra_shift);\n\n    row[2] = (a2 + b2) >> (ROW_SHIFT + extra_shift);\n\n    row[5] = (a2 - b2) >> (ROW_SHIFT + extra_shift);\n\n    row[3] = (a3 + b3) >> (ROW_SHIFT + extra_shift);\n\n    row[4] = (a3 - b3) >> (ROW_SHIFT + extra_shift);\n\n}\n", "idx": 12493, "substitutes": {"row": ["word", "device", "port", "batch", "ko", "low", "x", "raw", "model", "server", "pub", "reader", "flow", "line", "spec", "c", "end", "tab", "sc", "cell", "dd", "order", "roll", "index", "ow", "head", "ward", "slice", "array", "sync", "container", "Row", "comment", "key", "error", "w", "check", "group", "page", "data", "entry", "length", "result", "item", "feed", "ack", "um", "column", "header", "tr", "config", "update", "value", "scan", "element", "view", "multi", "none", "wheel", "block", "ro", "loop", "load", "cur", "post", "node", "bug", "record", "board", "insert", "input", "object", "month", "user", "mod", "rows", "form", "col", "p", "match", "where", "pull", "now", "coll"], "extra_shift": ["relative_spin", "extravelshift", "absolute_slave", "finalvelshift", "secondaryalshock", "absoluteityshift", "extra_pop", "final_weight", "special_slave", "extraxshift", "extra67offset", "extra_weight", "extraityswitch", "extravelsup", "unique_shift", "absoluteityslave", "finalvelweight", "extraitylow", "secondary_set", "special_offset", "context_shift", "extraJslave", "extra67shift", "extra_offset", "extra67transform", "expectedityoffset", "secondaryaltransform", "final_shift", "expected_offset", "extravelfix", "extraityoffset", "relative_force", "finalvelload", "external_switch", "extra67shock", "extra_shock", "extra_eight", "secondary_transform", "extra_sync", "external_push", "extraitysync", "extralysup", "extra\u05bcsquare", "extra_load", "secondaryalset", "secondaryalshift", "extraJoffset", "relative_sq", "extra_square", "extra67weight", "extra_sq", "extra_space", "extreme_fix", "expected_shift", "extraitysecondary", "extraxfix", "expectedityshift", "extraxslave", "extralyshift", "extraaltransform", "uniqueitylow", "uniqueitysup", "extraJshift", "extreme_pop", "uniqueitysecondary", "extra_low", "extra_switch", "expecteditycheck", "extra_slave", "final_offset", "extralylow", "extravelload", "secondary_shock", "absoluteityswitch", "special_shift", "extra67set", "extra_force", "relative_shift", "extraveltransform", "extravelweight", "extraxoffset", "special_fix", "expected_check", "extravellow", "external_eight", "absolute_shift", "extra_transform", "extra_fix", "unique_sup", "extra_secondary", "external_shift", "extra67load", "extravelpop", "extraitysup", "finalveloffset", "extralysecondary", "final_load", "extraalset", "extravelcheck", "extravelsecondary", "extraitycheck", "unique_secondary", "context_square", "extreme_offset", "extraalshock", "extraityslave", "extra\u05bcshift", "extra_set", "extra_sup", "extra_spin", "context_space", "extra_check", "expected_transform", "extraJfix", "absolute_switch", "unique_low", "extraityshift", "expecteditytransform", "extra_push", "absolute_sync", "secondary_shift", "extra\u05bcspace", "extraalshift", "extreme_shift", "absoluteitysync", "extraitytransform", "extraveloffset", "uniqueityshift"], "a0": ["A2", "A1", "a4", "b4", "A0", "A4", " a4"], "a1": ["b6", " a6", "a6", "A3", "A2", "A1", "A6"], "a2": ["bB", "alpha2", "alphaB", " aB", "aB", "alpha4", "a4", "b4", "alpha1", " a4"], "a3": ["alpha2", "alpha3", "alpha4", "a4", "b4", " a4"], "b0": ["B0", "B4", " b4", "B2", "B3", "a4", "b4"], "b1": ["B0", "B1", "a11", " b11", "B3", "B11", "b11"], "b2": ["B0", "B1", "B2", "B3"], "b3": ["B0", "a5", "B1", " b5", "B3", "B5", "b5"], "temp": ["cook", "i", "memory", "level", "pre", "local", "flat", "new", "status", "str", "method", "raw", "model", "total", "loc", "cum", "wait", "sol", "base", "cel", "count", "magic", "c", "tw", "offset", "iter", "get", "cell", "off", "num", "comb", "index", "stable", "adj", "partial", "slice", "t", "lc", "txt", "full", "key", "w", "clean", "fake", "data", "result", "item", "try", "body", "cont", "cookie", "exec", "cache", "empty", "white", "wr", "zip", "small", "format", "tr", "extra", "style", "current", "perature", "porary", "source", "test", "null", "option", "tt", "unit", "buffer", "valid", "output", "term", "atom", "tc", "f", "diff", "inc", "EMP", "cur", "err", "input", "tmp", "unc", "shift", "code", "orig", "name", "ctrl", "ex", "emp", "tem", "var", "form", "col", "size", "p", "mini", "read", "dat", "margin", "now", "content", "Temp", "wrap", "opt"]}}
{"project": "qemu", "commit_id": "f3c7d0389fe8a2792fd4c1cf151b885de03c8f62", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499, "substitutes": {"ta": ["area", "ada", "aka", "sta", "ha", "te", "qa", "ca", "t", "ea", "tk", "da", "a", "oa", "asi", "nda", "sha", "TA", "sth", "si", "tm", "meta", "oma", "tor", "ka", "ba", "oda", "oga", "pa", "ti", "ma", "dc", "eta", "va", "ata", "ga", "sa", "ya", "sea", "Ta", "ppa", "ty", "fa", "tta"], "bd": ["bt", "dh", "bc", "zb", "fd", "d", "bb", "cdn", "ded", "da", "BD", "td", "bda", "nb", "nd", "ld", "gd", "pd", "cd", "bm", "rb", "pb", "sd", "b", "sb", "bf", "gb", "isd", "df", "dt", "dc", "bind", "cb", "md", "bg", "ds", "dd", "db", "kb", "vd", "bl", "dm"], "irq": ["ierqi", "IRq", " irch", "riqs", "lrk", "irqs", " irquest", "riq", "lrqs", "ierq", "IRquest", "irqi", "irke", "arqi", "irk", "arqs", "lrQ", "rik", "irQ", "igrke", "arq", "nirq", "igrqi", "IRQ", "IRk", "nirqs", "igrq", "nirch", " irqs", "IRqs", "igrqs", "irquest", "lrq", "riQ", "ierke", "irch", "IRch", "ierqs", "nirquest", "arke"], "dma": [" dga", "dmma", " dmas", "dyfa", "bfa", "dyma", "bpa", "lmma", "adma", "dga", "dymma", "bga", "admc", "dmas", "admas", "bwa", "lfa", "datma", "dmc", "lwa", "bmc", " dpa", "bma", "dfa", "dywa", " dmc", "adga", "bmma", " dmma", "lma", "datpa", "dwa", "dpa", "datmma", "bmas", "datmas"], "fclk": ["faclks", "fCLc", "rfclk", "fClk", "fplq", "faclc", " fplp", "fClq", "fCLks", "fplb", "fplp", "fClp", "faclb", "rfplks", "rfplc", "fClc", "fCLb", "fclc", " fplk", "fclb", "rfplk", "fclp", "fmlq", "fCLk", "fplks", "fmlp", "rfclc", " fplc", "fclq", " fclq", "fmlk", "fplk", "rfplb", " fclp", "fclks", "faclk", "rfclb", "fmlc", "rfclks", " fplq", "fplc", " fclc"], "iclk": ["icLks", "icilk", "iclq", "icplk", "icplks", "icplq", "icilq", "ccplsk", "cclsk", "cclks", "icLsk", "icplsk", "icLk", "ccplk", "iclsk", "iclks", "icilsk", "ccplks", "ccplq", "cclq", "icilks", "cclk", "icLq"], "s": ["i", "rs", "qs", "new", "h", "si", "js", "ps", "lines", "tests", "spec", "c", " is", "is", "sc", "sl", "states", "aws", "args", "south", "m", "self", "d", "t", "sg", "sync", "fs", "sym", "or", "g", "cs", "es", "session", "w", "u", "b", "ns", "results", "als", "r", "sa", "sys", "service", "your", "ows", "hs", "os", "sets", "o", "ms", "z", " values", "e", "sb", "f", "ans", "services", "sh", "ls", "comments", "ses", "l", "a", " parts", "S", "settings", "its", "uns", "v", "ss", "p", "se", "plugins", "k", "n", "gs", "ssl", "ds", "su", "ts", "us", "vs", "y"]}}
{"project": "qemu", "commit_id": "dca6eeed8c2a1c131d161139428dd18a35e58b03", "target": 0, "func": "static void calxeda_init(MachineState *machine, enum cxmachines machine_id)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    DeviceState *dev = NULL;\n\n    SysBusDevice *busdev;\n\n    qemu_irq pic[128];\n\n    int n;\n\n    qemu_irq cpu_irq[4];\n\n    qemu_irq cpu_fiq[4];\n\n    MemoryRegion *sysram;\n\n    MemoryRegion *dram;\n\n    MemoryRegion *sysmem;\n\n    char *sysboot_filename;\n\n\n\n    if (!cpu_model) {\n\n        switch (machine_id) {\n\n        case CALXEDA_HIGHBANK:\n\n            cpu_model = \"cortex-a9\";\n\n            break;\n\n        case CALXEDA_MIDWAY:\n\n            cpu_model = \"cortex-a15\";\n\n            break;\n\n        }\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        ObjectClass *oc = cpu_class_by_name(TYPE_ARM_CPU, cpu_model);\n\n        Object *cpuobj;\n\n        ARMCPU *cpu;\n\n        Error *err = NULL;\n\n\n\n        if (!oc) {\n\n            error_report(\"Unable to find CPU definition\");\n\n            exit(1);\n\n        }\n\n\n\n        cpuobj = object_new(object_class_get_name(oc));\n\n        cpu = ARM_CPU(cpuobj);\n\n\n\n        /* By default A9 and A15 CPUs have EL3 enabled.  This board does not\n\n         * currently support EL3 so the CPU EL3 property is disabled before\n\n         * realization.\n\n         */\n\n        if (object_property_find(cpuobj, \"has_el3\", NULL)) {\n\n            object_property_set_bool(cpuobj, false, \"has_el3\", &err);\n\n            if (err) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        }\n\n\n\n        if (object_property_find(cpuobj, \"reset-cbar\", NULL)) {\n\n            object_property_set_int(cpuobj, MPCORE_PERIPHBASE,\n\n                                    \"reset-cbar\", &error_abort);\n\n        }\n\n        object_property_set_bool(cpuobj, true, \"realized\", &err);\n\n        if (err) {\n\n            error_report_err(err);\n\n            exit(1);\n\n        }\n\n        cpu_irq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ);\n\n        cpu_fiq[n] = qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ);\n\n    }\n\n\n\n    sysmem = get_system_memory();\n\n    dram = g_new(MemoryRegion, 1);\n\n    memory_region_allocate_system_memory(dram, NULL, \"highbank.dram\", ram_size);\n\n    /* SDRAM at address zero.  */\n\n    memory_region_add_subregion(sysmem, 0, dram);\n\n\n\n    sysram = g_new(MemoryRegion, 1);\n\n    memory_region_init_ram(sysram, NULL, \"highbank.sysram\", 0x8000,\n\n                           &error_fatal);\n\n    memory_region_add_subregion(sysmem, 0xfff88000, sysram);\n\n    if (bios_name != NULL) {\n\n        sysboot_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (sysboot_filename != NULL) {\n\n            if (load_image_targphys(sysboot_filename, 0xfff88000, 0x8000) < 0) {\n\n                hw_error(\"Unable to load %s\\n\", bios_name);\n\n            }\n\n            g_free(sysboot_filename);\n\n        } else {\n\n           hw_error(\"Unable to find %s\\n\", bios_name);\n\n        }\n\n    }\n\n\n\n    switch (machine_id) {\n\n    case CALXEDA_HIGHBANK:\n\n        dev = qdev_create(NULL, \"l2x0\");\n\n        qdev_init_nofail(dev);\n\n        busdev = SYS_BUS_DEVICE(dev);\n\n        sysbus_mmio_map(busdev, 0, 0xfff12000);\n\n\n\n        dev = qdev_create(NULL, \"a9mpcore_priv\");\n\n        break;\n\n    case CALXEDA_MIDWAY:\n\n        dev = qdev_create(NULL, \"a15mpcore_priv\");\n\n        break;\n\n    }\n\n    qdev_prop_set_uint32(dev, \"num-cpu\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"num-irq\", NIRQ_GIC);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, MPCORE_PERIPHBASE);\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        sysbus_connect_irq(busdev, n, cpu_irq[n]);\n\n        sysbus_connect_irq(busdev, n + smp_cpus, cpu_fiq[n]);\n\n    }\n\n\n\n    for (n = 0; n < 128; n++) {\n\n        pic[n] = qdev_get_gpio_in(dev, n);\n\n    }\n\n\n\n    dev = qdev_create(NULL, \"sp804\");\n\n    qdev_prop_set_uint32(dev, \"freq0\", 150000000);\n\n    qdev_prop_set_uint32(dev, \"freq1\", 150000000);\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff34000);\n\n    sysbus_connect_irq(busdev, 0, pic[18]);\n\n    sysbus_create_simple(\"pl011\", 0xfff36000, pic[20]);\n\n\n\n    dev = qdev_create(NULL, \"highbank-regs\");\n\n    qdev_init_nofail(dev);\n\n    busdev = SYS_BUS_DEVICE(dev);\n\n    sysbus_mmio_map(busdev, 0, 0xfff3c000);\n\n\n\n    sysbus_create_simple(\"pl061\", 0xfff30000, pic[14]);\n\n    sysbus_create_simple(\"pl061\", 0xfff31000, pic[15]);\n\n    sysbus_create_simple(\"pl061\", 0xfff32000, pic[16]);\n\n    sysbus_create_simple(\"pl061\", 0xfff33000, pic[17]);\n\n    sysbus_create_simple(\"pl031\", 0xfff35000, pic[19]);\n\n    sysbus_create_simple(\"pl022\", 0xfff39000, pic[23]);\n\n\n\n    sysbus_create_simple(\"sysbus-ahci\", 0xffe08000, pic[83]);\n\n\n\n    if (nd_table[0].used) {\n\n        qemu_check_nic_model(&nd_table[0], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[0]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff50000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[77]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[78]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[79]);\n\n\n\n        qemu_check_nic_model(&nd_table[1], \"xgmac\");\n\n        dev = qdev_create(NULL, \"xgmac\");\n\n        qdev_set_nic_properties(dev, &nd_table[1]);\n\n        qdev_init_nofail(dev);\n\n        sysbus_mmio_map(SYS_BUS_DEVICE(dev), 0, 0xfff51000);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 0, pic[80]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 1, pic[81]);\n\n        sysbus_connect_irq(SYS_BUS_DEVICE(dev), 2, pic[82]);\n\n    }\n\n\n\n    highbank_binfo.ram_size = ram_size;\n\n    highbank_binfo.kernel_filename = kernel_filename;\n\n    highbank_binfo.kernel_cmdline = kernel_cmdline;\n\n    highbank_binfo.initrd_filename = initrd_filename;\n\n    /* highbank requires a dtb in order to boot, and the dtb will override\n\n     * the board ID. The following value is ignored, so set it to -1 to be\n\n     * clear that the value is meaningless.\n\n     */\n\n    highbank_binfo.board_id = -1;\n\n    highbank_binfo.nb_cpus = smp_cpus;\n\n    highbank_binfo.loader_start = 0;\n\n    highbank_binfo.write_secondary_boot = hb_write_secondary;\n\n    highbank_binfo.secondary_cpu_reset_hook = hb_reset_secondary;\n\n    arm_load_kernel(ARM_CPU(first_cpu), &highbank_binfo);\n\n}\n", "idx": 12544, "substitutes": {"machine": ["bug", "device", "database", "proc", "m", "interface", "mom", "part", "service", "config", "object", "motion", "connection", "manager", "image", "kernel", "project", "module", "vm", "model", "linux", "comment", "server", "computer", "slave", "table", "view", "loader", "instance", "handler", "engine", "boot", "Machine", "base", "mode", "address", "state", "block", "process", "hard", "link", "host", "mac", "template", "class", "space", "controller", "node", "message"], "machine_id": ["machine_type", "machine_ids", "vm_mode", "vm_id", "machine_mode", "machine_name", "vm_ids", " machine_name", " machine_type", " machine_ids"], "cpu_model": ["cpu_location", "cpu_field", "currencyjlanguage", "cpu_type", " cpu_Model", "vm_field", "cpu2language", "currency_loader", "cpu_loader", "cpujlanguage", "memLogmodel", "cpujsource", "cpu2resource", " cpu_location", " cpu_type", "memLogmodels", "cpu67language", "cpu_source", "cpu_size", "cpujloader", "gpu_mode", "currency_resource", "cpu67string", "mem_models", "currency_model", "mem_string", "cpu2loader", "cpu_channel", "gpu_source", "gpu_channel", "cpu_models", "currencyjmodel", "cpujfield", "cpujresource", "currencyjloader", "mem_language", "cpuamlanguage", "vm_language", "cpujmodel", "currencyjresource", "mem_model", "vm_source", "cpu_class", "cpu_mode", "vm_model", "cpu67models", "cpuamfield", "gpu_models", "cpuLogmodels", "cpu_language", "cpu_resource", "cpuamsource", "cpu67model", "cpu2model", "memLoglanguage", "cpu_string", "gpu_model", "currency_language", "cpuLogmodel", "cpu_Model", "gpu_class", "gpu_size", "cpuLogstring", "cpuammodel", "memLogstring", "cpuLoglanguage"], "kernel_filename": ["system_file", "cpu_files", "kernel___file", "kernel__location", "kernel__mode", "system_location", "kernel__file", "kernel___files", "kernel__filename", "cpu_file", "kernel___filename", "cpu_license", "cpu_filename", "kernel_file", "kernel_license", "kernel___license", "system_filename", "kernel_location", "system_mode", "kernel_files", "kernel_mode"], "kernel_cmdline": ["kernel_bootlines", "kernel_bootli", "kernel_commandline", "kernel_commandlines", "kernel_commandLine", "kernel_hostLine", "kernel_hostlines", "kernel_bootline", "kernel_cfglines", "kernel_cmdlines", "kernel_hostli", "kernel_cfgline", "kernel_bootLine", "kernel_cmdLine", "kernel_cfgli", "kernel_cfgLine", "kernel_cmdli", "kernel_hostline"], "initrd_filename": ["initrt_directory", "initrd_uri", "initrd_path", "initrt_path", "initrt_uri", "initrd__filename", "initrd_file", "initrd__uri", "initrt_file", "initrt_name", "initrd__file", "initrd_name", "initrd__path", "initrd_directory", "initrt_filename"], "dev": ["device", "ch", "priv", "def", "rad", "serial", "Dev", "bus", "mod", "app", "conf", "gu", "pu", "conn", "w", "pub", "prof", "loader", "mem", "temp", "ver", "serv", "block", "DEV", "cache", "ev", "debug"], "busdev": ["BusDev", "busdevice", "bootdev", "bootinfo", "BUSdev", "bootdevice", "BUSDev", "Businfo", "BUSinfo", "businfo", "Busdev", "Busdevice", "busDev", "bootDev", "BUSdevice"], "pic": ["path", "proc", "mc", "sync", "fs", "pins", "lc", "kernel", "py", " pci", "uu", "cmp", "pid", "conn", "lib", "processor", "loader", "img", "cli", "rx", "vidia", "itect", "eni", "gui", "mac", "seq", "css", "nic", "cci"], "n": ["m", "en", "d", "t", "ni", "l", "i", "un", "N", "a", "nn", "name", "g", "syn", "h", "mn", "nb", "x", "cn", "fn", "v", " N", "o", "np", "w", "u", "z", "p", "s", "e", "not", "nc", "k", "b", "j", "count", "f", "nu", "c", "ns", "number", "nm", "ne", "ng", "sn", "nt", "network", "r", "nr", "no", "num", "pn", "net", "node"], "cpu_irq": ["cpu_mirq", "cpu_pirqq", "cpu_drqa", "cpu_irqa", "cpu_mirqq", "cpu_mircl", "cpu_pirce", "cpu_drqs", "cpu_IRp", "cpu_arp", "cpu_arqs", "cpu_iice", "cpu_pirq", "cpu_irp", "cpu_arq", "cpu_pircl", "cpu_irqs", "cpu_IRq", "cpu_IRqa", "cpu_IRqs", "cpu_irqq", "cpu_arqa", "cpu_iiqq", "cpu_mirce", "cpu_irce", "cpu_ircl", "cpu_iicl", "cpu_drq", "cpu_drp", "cpu_iiq"], "cpu_fiq": ["cpu_iniQ", "cpu_rfqq", "cpu_inique", "cpu_rfQ", "cpu_fique", "cpu_irque", "cpu_rfq", "cpu_rfque", "cpu_iniqq", "cpu_iniq", "cpu_irqq", "cpu_fiqq", "cpu_irQ", "cpu_fiQ"], "sysram": ["bootgram", "osmem", "sysmac", "sysgram", "osram", "bootmem", "systemram", "bootram", "osmac", "bootmac", "systemmac", "systemgram", "osgram", "systemmem"], "dram": ["xdarm", "dgram", "dmem", "fdgram", "xdram", "fram", "fdmem", "fdarm", "darm", "fdram", "fmem", "fgram", "xdmem", "farm", "xdgram"], "sysmem": [" sysMem", "syslim", "ysMem", "ysmb", "Sysmb", "SysMem", "sysmb", "ysmem", "yslim", "Sysmem", "Syslim", " sysmb", "sysMem", " syslim"], "sysboot_filename": ["sysboot_number", "sysboot__Filename", "syscpu_number", "syscpu_Filename", "syscpu_file", "sysboot_file", "sysboot_Filename", "syscpu_filename", "sysboot__number", "sysboot__file", "sysboot__filename"], "oc": ["toc", "oid", "proc", "acs", "uc", "bc", "ob", "enc", "unc", "cc", "pc", "rc", "roc", "os", "loc", "OC", "mot", "isc", "o", "obj", "oco", "doc", "rec", "nc", "co", "oo", "ocol", "ocr", "c", "voc", "dc", "ac", "anc", "org", "oci", "ec", "soc", "orc", "nic", "fc", "oca", "alloc", "ow"], "cpuobj": ["gpuct", "clocklab", "gpuapi", "gpucb", "clockObj", "procobject", "procob", "cpobject", "cpuob", "gpulab", "procapi", "gpuo", "pucb", "puapi", "proccb", "cachebj", "pubj", "cpulab", "processorobject", "processorlab", "gpuobject", "gpuObj", "cpuo", "procobj", "cpucb", "bootobj", "clockobj", "clockapi", "procact", "puct", "clockob", "gpuobj", "bootobject", "cpObj", "cacheobj", "procObj", "bootObj", "processorObj", "cpo", "cpuapi", "cpuct", "puobj", "bootstr", "processorobj", "cacheo", "cpuObj", "gpuact", "procct", "cpustr", "gpubj", "puo", "clockobject", "cpuobject", "puact", "cpubj", "gpuob", "gpustr", "cpuact", "puObj", "cacheObj", "cpobj", "puobject", "pustr"], "cpu": ["runner", "proc", "uc", "bc", "cow", "rc", "pc", "jp", "roc", "gc", "fps", "cn", "lp", "vm", "cmp", "performance", "px", "pu", "mx", "conn", "np", "processor", "instance", "boot", "nc", "CPU", "gpu", "dc", "fc", "clock", "cp", "mac", "cache", "soc", "lb", "nic", "core", "net", "node"], "err": ["runner", "ah", "msg", "str", "ace", "loc", "Er", "br", "yer", "mr", "lr", "orer", "rb", "ver", "pl", "ler", "magic", "ry", "acer", "cb", "attr", "iter", "here", "dr", "orr", "oller", "call", "rev", "oll", "rar", "req", "rn", "sr", "eor", "error", "fr", "doc", "aer", "aaa", "arr", "ev", "pr", "rage", "res", "rr", "erer", "gr", "kr", "ref", "rh", "der", "ir", "yr", "exc", "rx", "f", "inc", "rt", "ner", "bug", "hr", "fy", "orig", "er", "later", "aster", "conf", "var", "cr", "ait", "nil", "nor", "norm", "org", "resp", "rag", "irm", "ise"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "static int get_phys_addr_v5(CPUState *env, uint32_t address, int access_type,\n\n\t\t\t    int is_user, uint32_t *phys_ptr, int *prot)\n\n{\n\n    int code;\n\n    uint32_t table;\n\n    uint32_t desc;\n\n    int type;\n\n    int ap;\n\n    int domain;\n\n    uint32_t phys_addr;\n\n\n\n    /* Pagetable walk.  */\n\n    /* Lookup l1 descriptor.  */\n\n    table = get_level1_table_address(env, address);\n\n    desc = ldl_phys(table);\n\n    type = (desc & 3);\n\n    domain = (env->cp15.c3 >> ((desc >> 4) & 0x1e)) & 3;\n\n    if (type == 0) {\n\n        /* Section translation fault.  */\n\n        code = 5;\n\n        goto do_fault;\n\n    }\n\n    if (domain == 0 || domain == 2) {\n\n        if (type == 2)\n\n            code = 9; /* Section domain fault.  */\n\n        else\n\n            code = 11; /* Page domain fault.  */\n\n        goto do_fault;\n\n    }\n\n    if (type == 2) {\n\n        /* 1Mb section.  */\n\n        phys_addr = (desc & 0xfff00000) | (address & 0x000fffff);\n\n        ap = (desc >> 10) & 3;\n\n        code = 13;\n\n    } else {\n\n        /* Lookup l2 entry.  */\n\n\tif (type == 1) {\n\n\t    /* Coarse pagetable.  */\n\n\t    table = (desc & 0xfffffc00) | ((address >> 10) & 0x3fc);\n\n\t} else {\n\n\t    /* Fine pagetable.  */\n\n\t    table = (desc & 0xfffff000) | ((address >> 8) & 0xffc);\n\n\t}\n\n        desc = ldl_phys(table);\n\n        switch (desc & 3) {\n\n        case 0: /* Page translation fault.  */\n\n            code = 7;\n\n            goto do_fault;\n\n        case 1: /* 64k page.  */\n\n            phys_addr = (desc & 0xffff0000) | (address & 0xffff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 2: /* 4k page.  */\n\n            phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n            ap = (desc >> (4 + ((address >> 13) & 6))) & 3;\n\n            break;\n\n        case 3: /* 1k page.  */\n\n\t    if (type == 1) {\n\n\t\tif (arm_feature(env, ARM_FEATURE_XSCALE)) {\n\n\t\t    phys_addr = (desc & 0xfffff000) | (address & 0xfff);\n\n\t\t} else {\n\n\t\t    /* Page translation fault.  */\n\n\t\t    code = 7;\n\n\t\t    goto do_fault;\n\n\t\t}\n\n\t    } else {\n\n\t\tphys_addr = (desc & 0xfffffc00) | (address & 0x3ff);\n\n\t    }\n\n            ap = (desc >> 4) & 3;\n\n            break;\n\n        default:\n\n            /* Never happens, but compiler isn't smart enough to tell.  */\n\n            abort();\n\n        }\n\n        code = 15;\n\n    }\n\n    *prot = check_ap(env, ap, domain, access_type, is_user);\n\n    if (!*prot) {\n\n        /* Access permission fault.  */\n\n        goto do_fault;\n\n    }\n\n    *phys_ptr = phys_addr;\n\n    return 0;\n\ndo_fault:\n\n    return code | (domain << 4);\n\n}\n", "idx": 12545, "substitutes": {"env": ["dh", "forge", "en", "context", "enh", "queue", "enc", "ea", "eye", "config", "profile", "enter", "eu", "ey", "txt", "vm", "estate", "server", "v", "conf", "conn", "np", "obj", "energy", "dev", "dict", "e", "equ", "viron", "engine", "exc", "fi", "her", "nc", "eng", "ext", "qt", "Environment", "dat", "eni", "serv", "dt", "dc", "esc", "ep", "cp", "que", "db", "ev", "ec", "vt", "environment", "header", "ef", "ctx", "esi", "esm"], "address": ["area", "device", "email", "port", "interface", "en", "shape", "hello", "image", "event", "ace", "server", "loc", "grade", "end", "offset", "order", "index", "message", "context", "array", "api", "reference", "error", "expression", "password", "adr", "resource", "length", "ip", "url", "number", "route", "average", "feed", "eni", "ion", "ast", "host", "ress", "archive", "addr", "alias", "asm", "ge", "Address", "complete", "config", "abuse", "account", "test", "description", "master", "output", "element", "alpha", "layer", "add", "state", "ne", "channel", "date", "ord", "record", "location", "enter", "object", "name", "position", "uri", "pointer", "pair", "attribute", "target", "network"], "access_type": ["access2info", "access2port", "access_port", "ec_level", "access_level", "ec_port", "ec_info", "access2level", "access_info", "access2type", "ec_type"], "is_user": ["id_uid", "is_pos", "is_server", "id_user", "id_server", "id_pos", "is_uid"], "phys_ptr": ["phys__pointer", "phys__struct", "phy_ptr", "phys__addr", "phy_struct", "phys_pointer", "phys_struct", "phys__ptr", "phy_pointer", "phy_addr"], "prot": ["channel", "nat", "port", "len", "config", "test", "server", "chain", "platform", "conn", "client", "np", "col", "sec", "ext", "ocol", "mode", "ip", " protocol", "eth", "pro", "pri", "pattern", "pat", "seq", "pos", "prop", "dim", "rot"], "code": ["codes", "ode", "charge", "bug", "call", "ch", "rc", "cc", "id", "name", "test", "x", "status", "err", "comment", "loc", "error", "key", "step", "catch", "check", "index", "size", "sec", "info", "comp", "success", "data", "co", "min", "count", "Code", "length", "result", "line", "state", "fe", "c", "close", "cat", "reason", "pe", "start", "create", "change", "ce", "cod", "fail", "cache", "ec", "class", "order", "comb", "go", "message"], "table": ["port", "record", "database", "interface", "root", "part", "trace", "ca", "tmp", "config", "level", "object", "account", "name", "row", "td", "flat", "test", "public", "section", "description", "module", "model", "total", "session", "server", "package", "conf", "app", "tree", "conn", "form", "key", "col", "cot", "stage", "pod", "chart", "data", "tc", "base", "where", "error", "count", "mode", "result", "th", "state", "query", "block", "tab", "ac", "file", "body", "db", "cache", "TABLE", "class", "order", "bl", "header", "round", "stable", "Table"], "desc": ["proc", "en", "dist", "def", "public", "asc", "loc", "server", "phrase", "rec", "spec", "end", "sc", "text", "sub", "ec", "prop", "dim", "contract", "comb", "done", "d", "Desc", "rc", "req", "progress", "acc", "comment", "dir", "error", "client", "password", "cd", "adr", "doc", "ext", "entry", "result", "url", "feed", "cont", "exec", "decl", "path", "complete", "config", "td", "section", "description", "der", "aug", "conn", "summary", "layer", "stage", "sec", "info", "dep", "des", "diff", "cur", "toc", "ord", "record", "uc", "enc", "name", "dest", "conf", "meta", "form", "de", "parent", "dc", "esc", "org", "disc", "usc", "src", "seq", "day"], "type": ["types", "Type", "port", "call", "typ", "ype", "format", "part", "t", "id", "pc", "level", "style", "shape", "pre", "name", "test", "py", "unit", "model", "TYPE", "comment", "key", "error", "like", "form", "role", "group", "size", "version", "p", "info", "ver", "http", "page", "op", "count", "length", "parent", "state", "ping", "block", "cat", "pe", "function", "rule", "year", "field", "class", "pos", "prop", "ty", "order", "no", "day", "post", "y"], "ap": ["map", "apa", "apt", "aj", "amp", "array", "ai", "mp", "or", "apper", "api", "aper", "gap", "sp", "acc", "snap", "tap", "nav", "app", "aps", "av", "ad", "apped", "af", "op", "arp", "ape", "ab", "ip", " cap", "AP", "apping", "arr", "Ap", "ac", "ng", "cap", "attr", "ep", "ast", "rep", "hap", "ar", "tp", "pad", "rap"], "domain": ["channel", "device", "port", "root", "format", "part", "dist", "Domain", "controller", "api", "name", "range", "lot", "gap", "sp", "description", "ref", "module", "unit", "model", "country", "dir", "server", "app", "error", "role", "sec", "net", "nc", "site", "page", "count", "ape", "magic", "feature", "cat", "dc", "phy", "ng", "change", "rule", "cmd", "year", "command", "rep", "host", "cache", "reg", "order", "debug", "core", "dom", "y", "depth", "asm", "node", "index", "sy"], "phys_addr": ["phys64addr", "las_addr", "phys64src", "phys2address", "phys_offset", "phys_grad", "physPaddress", "phys_address", "phys_attr", "phys_ord", "physPaddr", "las_src", "phys__address", "physPwrapper", "phys_adr", "phys67offset", "phys2addr", "physical_address", "physical_add", "phys__attr", "physPoffset", "phys64oa", "physical_adr", "phys24oa", "phys_wrapper", "physical_addr", "physical_ord", "phys67wrapper", "phys2ord", "phys_src", "phys_add", "phys67address", "phys67addr", "physical_wrapper", "physical_attr", "physical_offset", "phys__addr", "phys24addr", "phys2add", "phys_oa", "phys24src", "physical_ptr", "las_oa", "phys__ptr", "physical_grad"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548, "substitutes": {"s": ["native", "rs", "qs", "new", "status", "devices", "js", "si", "server", "ps", "stat", "spec", "c", "serv", "is", "sv", "states", "in", "aws", "args", "south", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "cs", "es", "full", "session", "storage", "u", "socket", "sf", "ns", "ops", "sie", "ks", "sys", "parts", "service", "os", "sets", "o", "ms", "e", "options", "http", "sb", "f", "state", "services", "ls", "ses", "l", "S", "settings", "its", "uns", "sq", "ss", "strings", "request", "p", "se", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us"], "i": ["hi", "qi", "it", "ui", "I", "ai", "in", "xi", "id", "iu", "ini", "gi", "ni", "a", "child", "io", "oi", "mu", "ci", "di", "x", "si", "ie", "ii", "uri", "gu", "o", "yi", "u", "z", "p", "e", "fi", "info", "li", "k", "ix", "b", "multi", "j", "phi", "f", "n", "ti", "ip", "c", "eni", "ji", "pi", "chi", "bi", "ri", "ami", "zi", "y", "abi", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "7546964f96168cd6ac819ef4c3212ee586619f1a", "target": 0, "func": "int ff_nvdec_decode_init(AVCodecContext *avctx, unsigned int dpb_size)\n\n{\n\n    NVDECContext *ctx = avctx->internal->hwaccel_priv_data;\n\n\n\n    NVDECFramePool      *pool;\n\n    AVHWFramesContext   *frames_ctx;\n\n    const AVPixFmtDescriptor *sw_desc;\n\n\n\n    CUVIDDECODECREATEINFO params = { 0 };\n\n\n\n    int cuvid_codec_type, cuvid_chroma_format;\n\n    int ret = 0;\n\n\n\n    sw_desc = av_pix_fmt_desc_get(avctx->sw_pix_fmt);\n\n    if (!sw_desc)\n\n        return AVERROR_BUG;\n\n\n\n    cuvid_codec_type = map_avcodec_id(avctx->codec_id);\n\n    if (cuvid_codec_type < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported codec ID\\n\");\n\n        return AVERROR_BUG;\n\n    }\n\n\n\n    cuvid_chroma_format = map_chroma_format(avctx->sw_pix_fmt);\n\n    if (cuvid_chroma_format < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported chroma format\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->thread_type & FF_THREAD_FRAME)\n\n        dpb_size += avctx->thread_count;\n\n\n\n    if (!avctx->hw_frames_ctx) {\n\n        AVHWFramesContext *frames_ctx;\n\n\n\n        if (!avctx->hw_device_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware device or frames context \"\n\n                   \"is required for CUVID decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n        if (!avctx->hw_frames_ctx)\n\n            return AVERROR(ENOMEM);\n\n        frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n        frames_ctx->format            = AV_PIX_FMT_CUDA;\n\n        frames_ctx->width             = avctx->coded_width;\n\n        frames_ctx->height            = avctx->coded_height;\n\n        frames_ctx->sw_format         = AV_PIX_FMT_NV12;\n\n        frames_ctx->sw_format         = sw_desc->comp[0].depth > 8 ?\n\n                                        AV_PIX_FMT_P010 : AV_PIX_FMT_NV12;\n\n        frames_ctx->initial_pool_size = dpb_size;\n\n\n\n        ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n        if (ret < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error initializing internal frames context\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n\n\n    params.ulWidth             = avctx->coded_width;\n\n    params.ulHeight            = avctx->coded_height;\n\n    params.ulTargetWidth       = avctx->coded_width;\n\n    params.ulTargetHeight      = avctx->coded_height;\n\n    params.bitDepthMinus8      = sw_desc->comp[0].depth - 8;\n\n    params.OutputFormat        = params.bitDepthMinus8 ?\n\n                                 cudaVideoSurfaceFormat_P016 : cudaVideoSurfaceFormat_NV12;\n\n    params.CodecType           = cuvid_codec_type;\n\n    params.ChromaFormat        = cuvid_chroma_format;\n\n    params.ulNumDecodeSurfaces = dpb_size;\n\n    params.ulNumOutputSurfaces = 1;\n\n\n\n    ret = nvdec_decoder_create(&ctx->decoder_ref, frames_ctx->device_ref, &params, avctx);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    pool = av_mallocz(sizeof(*pool));\n\n    if (!pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    pool->dpb_size = dpb_size;\n\n\n\n    ctx->decoder_pool = av_buffer_pool_init2(sizeof(int), pool,\n\n                                             nvdec_decoder_frame_alloc, av_free);\n\n    if (!ctx->decoder_pool) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\nfail:\n\n    ff_nvdec_decode_uninit(avctx);\n\n    return ret;\n\n}\n", "idx": 12556, "substitutes": {"avctx": ["avalloc", "avlc", "avcas", "aflc", "AVctl", "avalcca", "navctx", "evconn", "evcf", "AVcf", "afconfig", "vercf", " avcmp", "avesync", "avcu", "varpkg", " avcontext", "afbc", "avecli", "AVcas", "avecontext", "verconnection", "navcontext", "avconfig", "avctl", "varcontext", "abctx", "AVconfig", "abcontext", "avekb", "ajcontext", "abcmp", "AVloc", "Avcmp", "AVcontext", "varbc", "avectx", "avcli", "afcu", "avercli", "AVconn", "averctx", "AVlc", "afcontext", "AVconnection", "avectl", "avbc", "aveqa", "evcontext", "avkb", "AVpkg", "avconn", "avectrl", "avloc", "avercas", " avcu", "avalkb", "ajctl", "navctrl", "averwcs", "avctrl", "AVcmd", "AVsync", "evctx", "navcmd", "avcm", "avepkg", "avcf", "avalqa", "avecu", "averctl", "vercontext", " avcm", "averconn", "avsync", " avsync", "ajctx", "abcf", "aveconfig", "aveloc", "vercmp", "verctx", "avecf", "navcf", "afctx", "avalcf", "evconnection", "vercca", "Avconn", "avcca", "avebc", "avcomponent", "Avcontext", "afpkg", "vercas", "avecmd", "avewcs", "avecca", "afkb", "AVcmp", " avcmd", "Avctx", "avwcs", "avcmp", "avalwcs", "avecomponent", "avelc", "AVcu", "avconnection", "avqa", "verpkg", "verqa", "avalcli", "AVctrl", "vercm", "varctx", "avalcontext", "verconn", "ajconn", "avcmd", "afcm", "avalctx", "avcontext", "avalcomponent", "aveconn", " avconn", "AVctx", "vercu", "afcomponent", "avpkg", "averloc", "avercontext"], "dpb_size": ["dpb_capacity", "dpb8channel", "dpfb_handle", "dpb_channel", "dpfb_small", "dpb8small", "dpb_handle", "dpb_small", "dpb8size", "dpfb_capacity", "dpfb_size", "dpfb_channel"], "ctx": [" context", "context", "tx", "cm", "cam", "bc", "cv", "ca", "cc", "pc", "config", "lc", "conv", "cmp", "sq", "loc", "client", "conn", "obj", "nc", "tc", "c", "cca", "anc", "cb", "cas", "cf", "alloc"], "pool": ["port", "pkg", "queue", "config", "val", "container", "Pool", "image", "cpu", "conv", "buffer", "writer", "client", "conn", "lib", "col", "mem", "buf", "box", "parent", "block", "coll", "host", "cache", "prefix", "util", "thread", "alloc"], "frames_ctx": ["hops_tx", "framesingcmp", "frames___conn", "finals_voc", "frames_cv", "hops_ctx", "framesalctx", "frames_crit", "images_coll", "framesingctx", "hops_conn", "framesalalloc", "frames_alloc", "images_cn", "frames___cas", " frames_wcs", "images_lc", "frames_cc", "framesalcf", "frames___lc", "images_alloc", " frames_cc", "framesplc", "frames_cmp", "frames_lc", "frames_conn", "frames___voc", "frames___cv", "frames_cn", "frames_wcs", " frames_lc", "frames_coll", "frames_cf", "images_ctx", "framesptx", "hops_cas", "images_cf", "finals_ctx", "frames___cc", "framespctx", "images_cmp", "frames_context", "framespcontext", "framesingcontext", "finals_crit", "framesalcontext", "frames___ctx", "images_context", "frames_tx", "frames_cas", "frames___wcs", "framesingtx", "frames___tx", "images_tx", "frames_voc", "finals_cv", "frames___crit"], "sw_desc": ["sw2description", "sw_description", "swaysec", "swayentry", "swpsc", " sw2description", "swaydesc", " sw_sec", "sw_decl", "sw2desc", "sw_rec", "swpentry", "sw_doc", "sw_sc", "nw_decl", "swpsec", "nw_sc", " sw_doc", "sw2esc", "sw_sec", "sw_esc", " sw_esc", "nw_rec", " sw_rec", " sw_entry", "swpdecl", " sw2desc", " sw2doc", "sw_entry", "swprec", "sw2doc", " sw_description", " sw2esc", "nw_desc", "swayrec", "swpdesc"], "cuvid_codec_type": ["cuvid_codec_info", "cuvid_codac_type", "cuvid_codac_count", "cuvid_codac_id", "cuvid_codEC_name", "cuvid_codec_types", "cuvid_codac_types", "cuvid_codec_id", "cuvid_codac_info", "cuvid_codEC_type", "cuvid_codEC_types", "cuvid_codec_count", "cuvid_codEC_id", "cuvid_codec_name"], "cuvid_chroma_format": ["cuvid_chromas_version", "cuvid_chromla_pattern", "cuvid_chroma___format", "cuvid_chroma_unit", "cuvid_chroma___form", "cuvid_chromas_unit", "cuvid_chroma_family", "cuvid_chromla_type", "cuvid_chroma_version", "cuvid_chroma___family", "cuvid_chroma___type", "cuvid_chromas_format", "cuvid_chromas_family", "cuvid_chroma_form", "cuvid_chroma_pattern", "cuvid_chromas_type", "cuvid_chromla_version", "cuvid_chromla_format", "cuvid_chroma_type", "cuvid_chromas_form"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "void hmp_info_snapshots(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    QEMUSnapshotInfo *sn_tab, *sn, s, *sn_info = &s;\n\n    int nb_sns, i, ret, available;\n\n    int total;\n\n    int *available_snapshots;\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No available block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    nb_sns = bdrv_snapshot_list(bs, &sn_tab);\n\n    if (nb_sns < 0) {\n\n        monitor_printf(mon, \"bdrv_snapshot_list: error %d\\n\", nb_sns);\n\n        return;\n\n    }\n\n\n\n    if (nb_sns == 0) {\n\n        monitor_printf(mon, \"There is no snapshot available.\\n\");\n\n        return;\n\n    }\n\n\n\n    available_snapshots = g_malloc0(sizeof(int) * nb_sns);\n\n    total = 0;\n\n    for (i = 0; i < nb_sns; i++) {\n\n        sn = &sn_tab[i];\n\n        available = 1;\n\n        bs1 = NULL;\n\n\n\n        while ((bs1 = bdrv_next(bs1))) {\n\n            if (bdrv_can_snapshot(bs1) && bs1 != bs) {\n\n                ret = bdrv_snapshot_find(bs1, sn_info, sn->id_str);\n\n                if (ret < 0) {\n\n                    available = 0;\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (available) {\n\n            available_snapshots[total] = i;\n\n            total++;\n\n        }\n\n    }\n\n\n\n    if (total > 0) {\n\n        bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, NULL);\n\n        monitor_printf(mon, \"\\n\");\n\n        for (i = 0; i < total; i++) {\n\n            sn = &sn_tab[available_snapshots[i]];\n\n            bdrv_snapshot_dump((fprintf_function)monitor_printf, mon, sn);\n\n            monitor_printf(mon, \"\\n\");\n\n        }\n\n    } else {\n\n        monitor_printf(mon, \"There is no suitable snapshot available\\n\");\n\n    }\n\n\n\n    g_free(sn_tab);\n\n    g_free(available_snapshots);\n\n\n\n}\n", "idx": 12558, "substitutes": {"mon": ["mc", "non", "my", "lon", "wan", "tom", "mn", "module", "vol", "mx", "mr", "mun", "nan", "mol", "MON", "prem", "md", "mag", "lock", "dom", "m", "bin", "on", "mat", "ml", "con", "amon", "mt", "ran", "an", "ann", "pin", "don", "minute", "rock", "comm", "reg", "mu", "wm", "meter", "Mon", "phys", "mp", "bean", "un", "mail", "fun", "mons", "member", "ms", "boot", "atom", "mos", "token", "bo", "man", "net", "date", "lin", "pal", "month", "plan", "mm", "platform", "col", "mer", "mor", "mini", "mi", "monitor", "mo", "login", "day", "chron"], "qdict": [" qdat", "qdat", "dqdict", "qudat", "qudict", "dqdat", "dqdef", "qudef", "qdf", "qdef", "qudf", " qdf", " qdef", "dqdf"], "bs": ["sys", "rss", "ses", "bid", "bis", "bc", "ob", "BS", "fs", "ins", "bb", "fb", "rs", "bn", "cs", "os", "js", "ps", "ss", "conn", "obj", "ba", "obs", "pb", "vs", "b", "sb", "base", "nas", "banks", "gb", "gs", "less", "bh", "ns", "bu", "bps", "xs", "bes", "eb", "bas", "ds", "bi", "db", "src", "ls", "css", "bos", "lb", "ubs", "bl", "iss"], "bs1": ["resone", "cs3", "cs0", "resOne", "bsone", "bes2", "bb1", "cs1", "bb81", "nsone", "psone", "obs81", "bis1", "bs01", "bosone", "bsOne", "ns2", "bes1", "ls01", "ns81", "bb0", "bingpre", "bbOne", "sespre", "psOne", "ps01", "ses3", "bisOne", "bisone", "bing0", "obsOne", "bs2", "besone", "bes0", "ses2", "bos0", "ls2", "csOne", "bs3", "lsOne", "bis81", "fs1", "bos81", "lsone", "fsOne", "res01", "ls1", "fs3", "bbone", "csone", "bing11", "cs11", "sesOne", "ns0", "cspre", "fs2", "ns1", "bing1", "ps1", "cs2", "bs81", "fsone", "ses1", "obs1", "bos1", "bs0", "ses0", "bspre", "ses11", "obsone", "bs11", "res1"], "sn_tab": ["sb8tab", "sn__tab", "sn__list", "sb_group", "sn_group", "SN_info", "snappinfo", "sn_list", "SN_tab", "snappstat", "SN_stack", "SN_bar", "sn__lab", "sn_stat", "sn1stat", "snappstack", "sb_tab", "sn8tab", "sn1info", "fn_cell", "SN_stat", "SN_list", "sn_stack", "sn_range", "sn2tab", "sb8group", "sn1tab", "sb_info", "sn_cell", "sn8group", "fn_tab", "sb8range", "snapptab", "sn2bar", "sb8info", "sn8info", "sb_range", "sn2info", "sn_lab", "sn__info", "fn_state", "SN_lab", "sn1stack", "sn_state", "sn_bar", "sn8range", "fn_info", "sn2list"], "sn": ["ny", "sync", "ni", "nn", "kn", "syn", "sp", "na", "sk", "cn", "nb", "sw", "si", "sq", "ii", "fn", "session", "conn", "sch", "p", "li", "sb", "sf", "sd", "n", "ski", "ann", "ns", "skill", "shell", "pn", "sc", "ssl", "sv", "nt", "sl", "attr", "sh", "sa", "SN", "dn", "ls", "su", "span", "Sn", "sm"], "s": ["sys", "m", "service", "sync", "t", "sg", "d", "g", "S", "sp", "settings", "js", "si", "sq", "session", "server", "ps", "ss", "o", "p", "e", "sb", "sf", "b", "n", "gs", "state", "spec", "ns", "is", "stats", "sv", "sl", "services", "ds", "sa", "ls", "space", "sm"], "sn_info": ["sn2info", "SN_list", "sn__info", "sn__Info", "sn_fo", "sn2id", "sn2tab", "sn__tab", "sn__list", "sn_id", "SN_id", "SN_info", "SN_fo", "sn_Info", "SN_Info", "sn_list", "sn2fo", "SN_tab"], "nb_sns": ["nb_exns", "nb_psts", "nb_ssns", "nb_sxs", "nb_kls", "nb_csls", "nbJexls", "nb_pns", "nb_ssgs", "nb_kns", "nb_Samples", "nb_ngs", "nb_snapvs", "nbJsns", "nb_nessions", "nb_csgs", "nb_inds", "nb_snapnas", "nb_sesls", "nb_nsts", "nb_pgs", "nb_pls", "nb_kvs", "nb_shults", "nb_csns", "nbJssts", "nbJsessions", "nb_ssls", "nb_pcs", "nb_snas", "nb_sscs", "nb_exsts", "nb_ncs", "nb_sssts", "nb_exls", "nb_pamples", "nb_snapessions", "nb_Sns", "nb_pds", "nbJsgs", "nb_inns", "nb_snapns", "nb_ssvs", "nb_sgs", "nb_samples", "nb_pxs", "nbJsnapls", "nbJsls", "nb_ssnas", "nb_pults", "nb_nns", "nb_shns", "nb_sults", "nb_nls", "nb_scs", "nbJexvs", "nb_sesgs", "nb_snapgs", "nb_Sxs", "nbJexsts", "nb_nults", "nb_shsts", "nb_inxs", "nbJsnapgs", "nbJsnapessions", "nb_snapls", "nb_ssds", "nb_sesds", "nbJexns", "nbJsvs", "nb_sesns", "nb_nvs", "nb_sls", "nb_sds", "nb_inamples", "nbJsnapns", "nb_Sds", "nb_shls", "nb_csessions", "nb_exvs", "nb_ssts", "nb_svs", "nb_knas", "nb_sessions"], "i": ["hi", "qi", "it", "ui", "slice", "I", "ni", "ai", "xi", "id", "ini", "iu", "gi", "l", "my", "io", "oi", "api", "mu", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "limit", "o", "yi", "u", "ind", "size", "p", "e", "ib", "info", "fi", "z", "mi", "li", "k", "ix", "multi", "j", "count", "n", "phi", "f", "ti", "ski", "ip", "c", "eni", "end", "inner", "pi", "iter", "bi", "ri", "ori", "ami", "zi", "y", "abi", "index", "start"], "ret": ["alt", "part", "complete", "reply", "art", "trial", "val", "back", "def", "rets", "fun", "option", "ref", "post", "arg", "det", "full", "lit", "sr", "valid", "error", "job", "failed", "open", "mem", "found", "rb", "desc", "mi", "match", "data", "ext", "success", "Ret", "bit", "f", "result", "att", "rl", "url", "nt", "selected", "re", "rt", "sur", "r", "RET", "al", "res", "reg", "usr", "len", "stable"], "available": ["supported", "enough", "enabled", "existing", "complete", "usable", "shared", "ai", "successful", "external", "confirmed", "extra", "disabled", "current", "api", "bound", "limited", "public", "safe", "expected", "missing", "published", "full", "sum", "valid", "open", "able", "active", "instance", "resource", "visible", "initialized", "info", "effective", "running", "used", "length", "availability", "protected", "ready", "installed", "ac", "allowed", "selected", "Available", "empty", "volume", "accessible", "stable"], "total": ["percent", "partial", "done", "part", "non", "complete", "qa", "t", "shared", "id", "private", "current", "tax", "limited", "final", "null", "by", "full", "sum", "fat", "valid", "error", "key", "meta", "Total", "open", "index", "active", "size", "e", "temp", "info", "not", "li", "base", "multi", "used", "length", "count", "result", "parent", "list", "html", "next", "cat", "type", "now", "pi", "nt", "scale", "all", " Total", "last", "volume", "we", "no", "post", "max", "stable"], "available_snapshots": ["available_sputs", "available__captctions", "available_gallipes", "available_sshot", "available_simages", "available2captpoints", "available_gallshots", "available_nipes", "available_gallots", "available_snapcs", "available2captments", "available_captpoints", "available_sblems", "available_batchpoints", "available_batchuts", "available_spshots", "available__snapots", "available_gallimages", "available_snapots", "available_captots", "available__captets", "available__snapctions", "available2snapments", "available2snaputs", "available_captshots", "available_captets", "available_snappoints", "available_synshots", "available_synets", "available_snapments", "available_batchments", "available_snapipes", "available_prections", "available_spments", "available__snapshots", "available_snapets", "available_snapctions", "available_sppoints", "available_Snapshots", "available_synots", "available_captctions", "available_preets", "available_fourshot", "available_Snapshot", "available2snapshots", "available_preots", "available_Snapcs", "available_synctions", "available_sshots", "available_preshots", "available_recordshots", "available_captments", "available2snappoints", "available_fourcs", "available_nots", "available2captuts", "available_recordblems", "available_nimages", "available_captuts", "available__captots", "available_fourshots", "available_snaputs", "available_recordshot", "available_recordimages", "available_nshots", "available_scs", "available_snapshot", "available__snapets", "available_Snapblems", "available2captshots", "available_snapblems", "available_batchshots", "available__captshots", "available_snapimages", "available_Snapimages"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n", "idx": 12585, "substitutes": {"c": ["m", "ch", "self", "mc", "cm", "d", "t", "enc", "cc", "l", "pc", "code", "C", "g", "cs", "ci", "h", "cy", "chain", "o", "lib", "w", "u", "oc", "p", "e", "s", "comp", "k", "b", "n", "f", "cu", "dc", "ac", "ce", "ic", "r", "icc", "vc", "cache", "ec", "cur", "ctx"], "block": ["channel", "board", "blocks", "bin", "root", "batch", "config", "code", "object", "label", "pre", "row", "Block", "panel", "buffer", "unit", "position", "comment", "frame", "chain", "output", "inv", "group", "clean", "oc", "base", "length", "flow", "parent", "ip", "token", "number", "type", "clock", "out", "coll", "cache", "lock", "bl", "contract", "cl", "node"], "probs": ["Prob", "Probes", "robes", " prob", "prebes", " provs", "prob", "rocs", " procs", "rops", " probes", "probes", "prebs", "preps", "provs", "robs", "Procs", "procs", "preb", "rovs", "rob", "props", "prevs", "Probs", " props"], "i": ["qi", "it", "ui", "m", "I", "d", "t", "ai", "xi", "id", "iu", "l", "gi", "ini", "io", "ci", "di", "x", "si", "ii", "v", "yi", "u", "z", "ind", "p", "e", "li", "k", "b", "ix", "j", "n", "f", "ip", "token", "pi", "bi", "y", "index", "start"], "zero_nhood": ["zero_anighth", "zero_lmi", "zero_nighth", "zero_lhood", "zero_lumbers", "zero_ddd", "zero_anumbers", "zero_ndd", "zero_dhood", "zero_dumbers", "zero_ldd", "zero_lighth", "zero_anmi", "zero_nmi", "zero_numbers", "zero_dighth", "zero_anhood"], "qmul": [" qmUL", "qdmUL", " qbmul", "iqcmUL", "qrmulator", "qrmult", "qcmulator", "qcmul", "qMul", "iqcmulator", "iqmul", "qrmul", "qmulator", "qbmuli", "iqmulator", "iqmult", "qcmUL", "qMUL", "qrmUL", " qmuli", "iqcmult", " qbmUL", "qdmult", "iqmUL", "qcmult", "qmUL", "qmult", " qbmuli", "qdmulator", "qMuli", "iqcmul", "qmuli", "qbmul", "qbmUL", "qdmul", "qcmuli"], "token_prob": ["token_promb", "token_prebs", "token_funb", "token_rek", "token_probe", "token_promk", "token_funbs", "token_func", "token_funbe", "token_prombs", "token_promv", "token_perbe", "token_prox", "token_reb", "token_rebs", "token_prok", "token_prex", "token_preb", "token_probs", "token_perx", "token_prov", "token_prebe", "token_prec", "token_rev", "token_proc", "token_perb", "token_perc", "token_perbs"]}}
{"project": "qemu", "commit_id": "913a87885f589d263e682c2eb6637c6e14538061", "target": 1, "func": "static int cirrus_bitblt_solidfill(CirrusVGAState *s, int blt_rop)\n\n{\n\n    cirrus_fill_t rop_func;\n\n\n\n    if (blit_is_unsafe(s)) {\n\n        return 0;\n\n    }\n\n    rop_func = cirrus_fill[rop_to_index[blt_rop]][s->cirrus_blt_pixelwidth - 1];\n\n    rop_func(s, s->vga.vram_ptr + (s->cirrus_blt_dstaddr & s->cirrus_addr_mask),\n\n             s->cirrus_blt_dstpitch,\n\n             s->cirrus_blt_width, s->cirrus_blt_height);\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t     s->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t     s->cirrus_blt_height);\n\n    cirrus_bitblt_reset(s);\n\n    return 1;\n\n}\n", "idx": 12596, "substitutes": {"s": ["native", "i", "rs", "qs", "status", "js", "si", "server", "sim", "params", "spec", "c", "is", "states", "aws", "south", "m", "self", "d", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "full", "session", "storage", "w", "u", "data", "b", "sf", "ns", "results", "r", "sis", "sports", "secondary", "sys", "phys", "os", "sets", "o", "e", "http", "site", "sb", "f", "services", "ses", "as", "l", "rates", "a", "sites", "S", "settings", "its", "sq", "v", "conf", "ss", "request", "p", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "src", "su", "ts", "us", "ims", "y"], "blt_rop": ["blt2clip", "bls_hop", "blt__rop", "blt__hop", "blt2rop", "blt_hop", "blt2rot", "blit_crop", "blt__crop", "blit_rop", "blt_rot", "blt2crop", "blt_crop", "blt__role", "bls_crop", "blt__rot", "blit_rot", "bls_rop", "blt_clip", "bls_role", "blt_role", "blit_clip", "blt__clip"], "rop_func": ["clip2cb", "rop_function", "ropflambda", "rop2cb", "crop_fn", "rop_callback", "clip_cb", "ropffunc", "rop_unc", "clip_func", "rop2lambda", "crop_fun", "crop_function", "crop_unc", "rop_lambda", "clip_lambda", "rop2func", "rop_fn", "clip2func", "ropfcb", "crop_callback", "crop_func", "rop_cb", "clip2lambda", "rop_fun"]}}
{"project": "FFmpeg", "commit_id": "f5be84cfbc9c132a867ae8a8c0e0de26ed1a4e88", "target": 1, "func": "static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n\n    AVPacket *pkt) {\n\n\n\n    int chunk_type;\n\n\n\n    if (s->audio_chunk_offset) {\n\n\n\n\n\n\n\n\n        /* adjust for PCM audio by skipping chunk header */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {\n\n            s->audio_chunk_offset += 6;\n\n            s->audio_chunk_size -= 6;\n\n\n\n\n        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);\n\n        s->audio_chunk_offset = 0;\n\n\n\n        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))\n\n            return CHUNK_EOF;\n\n\n\n        pkt->stream_index = s->audio_stream_index;\n\n        pkt->pts = s->audio_frame_count;\n\n\n\n        /* audio frame maintenance */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)\n\n            s->audio_frame_count +=\n\n            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));\n\n        else\n\n            s->audio_frame_count +=\n\n                (s->audio_chunk_size - 6) / s->audio_channels;\n\n\n\n        av_dlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\",\n\n                pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n", "idx": 12607, "substitutes": {"s": ["rs", "qs", "h", "si", "js", "ps", "params", "scl", "spec", "c", "is", "sv", "sl", "ing", "aws", "args", "m", "self", "d", "sync", "sg", "t", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "b", "sf", "ns", "results", "als", "ops", "r", "sports", "ks", "secondary", "sys", "parts", "service", "your", "details", "hs", "os", "sets", "o", "e", "site", "sb", "multi", "features", "f", "less", "services", "ls", "comments", "ess", "ses", "as", "l", "sites", "S", "settings", "its", "uns", "sq", "conf", "ss", "p", "plugins", "ions", "ments", "gs", "xs", "ssl", "ds", "su", "ts", "us"], "pb": ["xb", "proc", "typ", "hp", "pkg", "bc", "amp", "tk", "pc", "mp", "jp", "vp", "fb", "bb", "uf", "prot", "api", "pit", "pg", "tta", "hub", "lp", "pp", "txt", "kk", "fp", "aph", "apy", "phrase", "platform", "bp", "pd", "pub", "np", "p", "rb", "bm", "kt", "pl", "sb", "pa", "b", "wp", "gb", "bh", "ab", "pm", "bps", "cb", "eb", "PB", "dp", "cp", "db", "lb", "ppa", "fc", "tp", "cpp", "asm"], "pkt": ["spkt", "pet", "pct", "pett", "opck", "sppt", "fkg", "lpeth", " pct", "Pct", "spacket", "pwk", "pki", "hwk", "psth", "Pet", "bkt", "spki", " ppt", "lpdt", "fok", "pck", "fkt", "Pkt", "mett", " pkg", "hnt", "Psth", "opeth", "macket", "mkt", "fwk", " pdt", "hkt", " pet", "tpct", "opkt", " pnt", " pwk", "tpkg", "tpnt", "opdt", "hkg", " pck", " psth", "packet", "hett", " pett", "hok", "bwk", "bkg", "peth", "Pett", "opct", "tpett", "Pck", "ppt", "lpacket", "pnt", "tpacket", "pkg", "Packet", "pdt", "tpkt", "spkg", "met", "Pkg", "spsth", " peth", "lpkt", "Pki", "bok", "pok", "opacket", " pki", "Ppt", "tpwk", " packet"], "chunk_type": ["chunk_id", "chunkerstyle", "chkg_Type", "chunk_state", "chunkertype", "chunk_style", "chunk_Type", "chunk_num", "chkg_type", "chunker_style", "chunk_size", "chkg_size", "chkg_num", "chunkerstate", "chunker_id", "chunkerid", "chunker_type", "chunker_state"], "pal": ["plug", "bin", "ch", "nl", "val", "nn", "label", "local", "ass", "wan", "pel", "panel", "py", "sk", "stal", "pp", "skin", "bat", "nav", "app", "Pal", "sil", "raf", "pol", "pid", "sal", "ill", "bl", "pod", "wal", "li", "pl", "data", "nil", "cel", "ask", "dat", "opal", "pe", "pan", "ne", "isal", "chi", "fal", "cal", "cell", "real", "chal", "al", "el", "ph", "apple"]}}
{"project": "FFmpeg", "commit_id": "f21cf2b38365caaa8a130a32521c2648600c3f50", "target": 0, "func": "static int encode_hq_slice(AVCodecContext *avctx, void *arg)\n\n{\n\n    SliceArgs *slice_dat = arg;\n\n    VC2EncContext *s = slice_dat->ctx;\n\n    PutBitContext *pb = &slice_dat->pb;\n\n    const int slice_x = slice_dat->x;\n\n    const int slice_y = slice_dat->y;\n\n    const int quant_idx = slice_dat->quant_idx;\n\n    const int slice_bytes_max = slice_dat->bytes;\n\n    uint8_t quants[MAX_DWT_LEVELS][4];\n\n    int p, level, orientation;\n\n\n\n    avpriv_align_put_bits(pb);\n\n    skip_put_bytes(pb, s->prefix_bytes);\n\n    put_bits(pb, 8, quant_idx);\n\n\n\n    /* Slice quantization (slice_quantizers() in the specs) */\n\n    for (level = 0; level < s->wavelet_depth; level++)\n\n        for (orientation = !!level; orientation < 4; orientation++)\n\n            quants[level][orientation] = FFMAX(quant_idx - s->quant[level][orientation], 0);\n\n\n\n    /* Luma + 2 Chroma planes */\n\n    for (p = 0; p < 3; p++) {\n\n        int bytes_start, bytes_len, pad_s, pad_c;\n\n        bytes_start = put_bits_count(pb) >> 3;\n\n        put_bits(pb, 8, 0);\n\n        for (level = 0; level < s->wavelet_depth; level++) {\n\n            for (orientation = !!level; orientation < 4; orientation++) {\n\n                encode_subband(s, pb, slice_x, slice_y,\n\n                               &s->plane[p].band[level][orientation],\n\n                               quants[level][orientation]);\n\n            }\n\n        }\n\n        avpriv_align_put_bits(pb);\n\n        bytes_len = (put_bits_count(pb) >> 3) - bytes_start - 1;\n\n        if (p == 2) {\n\n            int len_diff = slice_bytes_max - (put_bits_count(pb) >> 3);\n\n            pad_s = FFALIGN((bytes_len + len_diff), s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        } else {\n\n            pad_s = FFALIGN(bytes_len, s->size_scaler)/s->size_scaler;\n\n            pad_c = (pad_s*s->size_scaler) - bytes_len;\n\n        }\n\n        pb->buf[bytes_start] = pad_s;\n\n        flush_put_bits(pb);\n\n        skip_put_bytes(pb, pad_c);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12616, "substitutes": {"avctx": ["evconv", "Avconv", "Avpkg", "afconv", "afpkg", "avconv", "afctx", "avcontext", "Avcontext", "evctx", "afcontext", "Avctx", "avpkg", "evcontext", "evpkg"], "arg": [" argument", "args", "call", "slice", "amp", "array", "arm", "ai", "val", "ray", "or", "g", "ig", "ace", "v", "AR", "var", "ad", "parse", "ang", "ag", "Args", "arp", "ann", "arc", "att", "ay", "am", "parser", "arr", "par", "ac", "argument", "anc", "attr", "Arg", "load", "param", "mac", "ar", "alias", "asm"], "slice_dat": ["pixel_not", "volume_typ", " slice_def", " slice_att", "slice_vari", "sliceOgrad", "pixel_grad", "slice_not", " sliceacinit", "volumeJgat", "sliceingdest", "volume_gat", "package_dim", "slice___att", "sliceOvari", "slice_def", "slice_typ", "slice_data", "sliceOld", "sliceOdef", " slice_Dat", "slice_init", "slice_grad", "package_bat", "pixelOgrad", "slicealldist", "pixelOdat", "packageOdim", "sliceJbatch", "slice_batch", "volumeJbatch", "slice_dest", "pixel_dat", "sliceOdat", "slice_Dat", "seed_dist", "slice_att", "sliceJdat", "pixelOld", "slice_gat", " slice_list", "volumeJdat", "package_dat", "sliceObat", "pixel_ld", "sliceacinit", "sliceOatt", "sliceingdata", "slice_dim", "pixelOnot", "volume_dat", "slice___dat", "packageObat", "seed_data", "sliceJtyp", "slicealldest", "slice_dist", "volume_batch", "slice_list", "sliceingdat", "sliceingdist", "seed_ld", "slice_ld", "sliceOlist", "slicealldata", "sliceOnot", "seed_dest", "seed_dat", "volumeJtyp", "slice___def", "slice_conn", "sliceOdim", "package_vari", "slice_dan", "packageOdat", "slice___list", "slice_bat", "sliceJgat", " sliceacDat", "seed_conn", " sliceacdat", " slice_init", "sliceacdat", " sliceacdan", "sliceacDat", "packageOvari", " slice_dan", "sliceacdan", "slicealldat"], "s": ["secondary", "south", "sys", "ses", "self", "m", "slice", "service", "sync", "t", "sg", "fs", "ins", "l", "i", "rs", "sym", "utils", "g", "cs", "qs", "S", "settings", "os", "js", "si", "scope", "sq", "es", "session", "v", "ps", "ss", "client", "w", "u", "e", "groups", "site", "sf", "b", "sb", "j", "n", "f", "gs", "spec", "c", "ns", "single", "is", "sc", "ssl", "side", "sv", "sl", "ops", "services", "ds", "r", "sa", "su", "ls", "ts", "core", "ctx", "aws"], "pb": ["xb", "proc", "pkg", "python", "bc", "slice", "plain", "tmp", "pc", "jp", "vp", "mp", "fb", "phys", "api", "prot", "ub", "uf", "pg", "hub", "lp", "nb", "dl", "pp", "buffer", "esi", "fp", "bj", "phrase", "platform", "bp", "pd", "alist", "summary", "plugin", "bot", "bm", "rb", "pa", "buf", "sb", "wb", "b", "pl", "tc", "bf", "wp", "gb", "bh", "ab", "pm", "parser", "bps", "lab", "cb", "eb", "rob", "PB", "dp", "cp", "cpp", "db", "prototype", "lb", "ppa", "fc", "tp", "ctx", "asm", "gp"], "quants": ["quats", "instants", "aquants", "chants", "quands", "operans", "quant", "instats", "aquant", "operant", "chant", "aquands", " quads", "iquads", " quats", "iquANT", "iquants", "chads", "aquans", "aquats", " quans", "quANT", "quans", "chANT", " quands", " quANT", "instaints", "operants", "quaints", "quads", " quant", "iquant", "aquaints", "instant", "operands", " quaints"], "MAX_DWT_LEVELS": ["MAX_DWT_LEVELN", "MAX_DWT_SLLLING", "MAX_DWT_LEENGTHN", "MAX_DWT_LELLV", "MAX_DWT_LEENGTHV", "MAX_DWT_SLLLN", "MAX_DWT_LEENGTHING", "MAX_DWT_SLVELV", "MAX_DWT_LELLN", "MAX_DWT_LELLS", "MAX_DWT_LEVELV", "MAX_DWT_SLVELING", "MAX_DWT_SLVELN", "MAX_DWT_SLVELS", "MAX_DWT_SLLLV", "MAX_DWT_LEVELING", "MAX_DWT_SLLLS", "MAX_DWT_LELLING", "MAX_DWT_LEENGTHS"], "p": ["port", "m", "part", "po", "d", "t", "pc", "code", "i", "l", "jp", "a", "pre", "period", "g", "pg", "h", "lp", "pp", "pressure", "position", "fp", "pid", "v", "patch", "ps", " P", "o", "np", "bp", "u", "e", "pa", "pl", "b", "base", "op", "j", "n", "f", "point", "at", "parent", "pair", "ip", "c", "ping", "pe", "per", "type", "pi", "q", "dp", "r", "cp", "pr", "pos", "pad", "P", "tp", "depth"], "level": ["fl", "ale", "child", "local", "pre", "low", "status", "model", "loc", "limit", "ul", "lo", "temp", "sol", "pl", "count", "flow", "line", "sc", "iter", "fail", "pri", "lock", "index", "sync", "id", "lc", "weight", "full", "ld", "key", "error", "w", "pass", "clean", "version", "length", "url", "al", "rel", "wl", "el", "round", "path", "condition", "lvl", "levels", "style", "variable", "unit", "update", "like", "value", "o", "step", "layer", "stage", "found", "lf", "point", "f", "global", "inc", "Level", "type", "wall", "cl", "any", "l", "code", "letter", "name", "col", "size", "time", "where", "rol", "parent", "file", "rule", "scale", "coll", "vel", "day", "len", "depth"], "orientation": ["pectation", "pection", "orientoration", "denation", "directionication", "rientmentation", "varioration", "rientment", "orientization", "rientication", "animation", "designrelation", "organimation", " orientimation", "orientotation", "orientication", "rientATION", " orientate", "occupate", "rotator", " orientization", "rientator", "orientification", "designations", "directionrelation", "orientator", "designATION", "occupance", "orientration", "organization", " orientification", "denization", "orientated", "variation", "animification", "oriention", "pectning", "rientoration", " orientated", "variational", "organment", "rientational", "rotization", "variimation", "organification", "ortator", "ortning", "rientization", "directionration", "rientration", "organature", "rientimation", "orientmentation", "animication", "designation", "orientature", "orientance", " orientmentation", "ortion", "directionation", "occupment", "animimation", "rotature", "rotation", "denotation", "organator", "designate", "directionment", "rientated", "orientATION", "orientning", "riention", "organication", "rientature", "rientning", "occupATION", "animment", "directionated", "rientance", "occupration", " orientations", "orientational", "organoration", "orientimation", "organation", " orientration", "animator", "denated", "animmentation", "rientotation", "occupotation", " orientication", "orientment", "occupication", "ortation", "orientrelation", "rientation", "occupations", "directionization", "orientations", "organational", "animance", "animotation", " orientotation", "pectator", "designration", "orientate", "rientification", "occupator", "occupation", "rientrelation", "directionATION"], "bytes_start": ["bytes_mean", "bytes_init", "bytes_ad", "bytes_n", "bytes_end", "bits_init", "bits_mean", " bytes_n", "bits_start", " bytes_count", "bits_end", " bytes_ad", " bytes_end", "bytes_count"], "bytes_len": ["tes_en", "seconds_min", "bytes_max", "seconds_base", "bytes_", "bytes_min", "files_l", "bytesxdl", "files_diff", "tes_", "bits2", " bytes2", " bytes\n", "bytes_dl", "tes2", "tes_dl", "tesxmax", "bytes5dl", "files_start", "bytes_diff", "tes\n", "seconds_len", "tesxdl", "bytesxen", "bytesxmax", "bytes5en", "bytes_l", "bytesxlen", "bytes\n", "bytes5max", "tesxen", "seconds_start", "bits_", "tes_max", "bytes2", "bytes5len", "bytes_base", "bytes_en", "tesxlen", " bytes_", "bits\n", "files_len", "tes_len"], "pad_s": ["pad_space", "padregsum", " pad_i", "pad_y", "pad_sum", "strip_y", "strip_sum", "padregs", "pad_su", "padregspace", "padXspace", "strip_s", "stripregy", "padXy", "padregy", "pad_i", "padXs", "pad_d", "strip_space", "stripregsum", "stripregspace", "padXsum", " pad_su", " pad_d", "stripregs"], "pad_c": ["pad24cn", "pad___c", "padPcat", "pad_sc", "pad67c", "pad_cat", "padding_c", "pad_cn", "pad___count", "pad24c", "pad___s", "pad67s", "pad24cat", " pad_cn", "padding_s", "padding_count", "pad67sc", "padding_sc", "padPc", " pad_cat", "pad_count", "padPcn", "pad___sc", "padPs", "pad67count", "pad24s"]}}
{"project": "qemu", "commit_id": "2e061a7c86d77c599676d89c3461f8efe9c275b1", "target": 0, "func": "static void do_info_commands(Monitor *mon, QObject **ret_data)\n\n{\n\n    QList *cmd_list;\n\n    const mon_cmd_t *cmd;\n\n\n\n    cmd_list = qlist_new();\n\n\n\n    for (cmd = qmp_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd) &&\n\n            !compare_cmd(cmd->name, \"info\")) {\n\n            qlist_append_obj(cmd_list, get_cmd_dict(cmd->name));\n\n        }\n\n    }\n\n\n\n    for (cmd = qmp_query_cmds; cmd->name != NULL; cmd++) {\n\n        if (monitor_handler_ported(cmd) && !monitor_cmd_user_only(cmd)) {\n\n            char buf[128];\n\n            snprintf(buf, sizeof(buf), \"query-%s\", cmd->name);\n\n            qlist_append_obj(cmd_list, get_cmd_dict(buf));\n\n        }\n\n    }\n\n\n\n    *ret_data = QOBJECT(cmd_list);\n\n}\n", "idx": 12624, "substitutes": {"mon": ["bin", "mc", "meter", "Mon", "mid", "mat", "module", "met", "con", "mm", "mod", "mem", "mun", "sam", " monitor", "mi", "atom", "min", "monitor", "ann", "pm", "MON", "bo", "mag", "man", "om", "wat", "mu"], "ret_data": ["ret_result", "ret_obj", "retacresult", "ret_body", " ret_body", " ret_obj", " ret_di", "ret_list", "retacdata", " ret_result", "ret_di", " ret_list", "retacdi"], "cmd_list": ["cmdiptable", "cmdenval", "cfg_val", "cfgxdel", "cmdsstack", "cfgxlist", "cmdxval", "cmdendata", "command_stack", "cmdenlist", "cmdendel", "cmd_head", "msg_list", "cmd_set", "msg_record", "cfgxdata", "cookiellist", "cmdxback", "msg_table", "cookielhead", "msg_List", "cmdllist", "msg_main", "cmdenmain", "cmdldata", "cmdipset", "cmdlhead", "cmd_record", "cmd_data", "cfg_del", "cookie_back", "cmdlback", "cmdxdel", "cmd_main", "cmdxhead", "cmdiplist", "cmd_table", "cmdsset", "msg_set", "cmdenList", "cfg_data", "cookie_data", "command_set", "cookielback", "cmdxlist", "cmd_stack", "cmdiprecord", "cookie_head", "cfgxval", "cookieldata", "cookie_list", "cmd_del", "msg_pre", "cmd_pre", "cmdxdata", "cmd_val", "command_list", "cfg_list", "cmd_back", "cmdenpre", "cmdslist", "cmd_List"], "cmd": ["call", "domain", "pkg", "cm", "cook", "config", "cc", "code", "id", "pt", "child", "ctr", "msg", "name", "ctrl", "g", "req", "cn", "auth", "module", "method", "mod", "cmp", "ct", "opt", "conn", "client", "cd", "check", "clean", "obj", "grad", "plugin", "cli", "ck", "mode", "cfg", "custom", "c", "block", "crit", "cat", "dc", "cb", "gen", "md", "ht", "nick", "Cmd", "cf", "q", "kg", "command", "cp", "cookie", "vc", "comm", "cod", "content", "host", "prefix", "header", "dom", "cl", "ctx"], "buf": ["path", "map", "vec", "port", "bin", "ff", "uc", "bc", "queue", "rc", "batch", "code", "bn", "bd", "msg", "uf", "fun", "bytes", "pool", "str", "buffer", "raw", "lit", "bag", "loc", "br", "buff", "value", "la", " buffer", "doc", "brace", "rb", "data", "b", "byte", "box", "base", "Buffer", "wb", "block", "alloc", "bo", "cap", "text", "cb", "cas", "coll", "src", "seq", "num", "addr", "pad", "ctx", " buff"]}}
{"project": "qemu", "commit_id": "f1c2dc7c866a939c39c14729290a21309a1c8a38", "target": 0, "func": "static void spapr_msi_write(void *opaque, hwaddr addr,\n\n                            uint64_t data, unsigned size)\n\n{\n\n    sPAPRPHBState *phb = opaque;\n\n    int ndev = addr >> 16;\n\n    int vec = ((addr & 0xFFFF) >> 2) | data;\n\n    uint32_t irq = phb->msi_table[ndev].irq + vec;\n\n\n\n    trace_spapr_pci_msi_write(addr, data, irq);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, irq));\n\n}\n", "idx": 12635, "substitutes": {"opaque": ["opace", "openace", "opatile", "iopatile", "hopque", "operace", "openaque", "hopaque", "opena", " opa", "iopace", "operaque", "hopace", "iopaque", "hopatile", "opa", " opque", "opera", "opque", "iopque", " opace", " opatile"], "addr": ["ord", "device", "sta", "enc", "ea", "amd", "config", "code", "da", "oa", "name", "align", "x", "ref", "ace", "frame", "np", "grad", "layer", "ad", "adr", "pointer", "ext", "mode", "add", "address", "padding", "eni", "next", "arr", "advert", "offset", "attr", "md", "cmd", "ast", "ack", "host", "dd", "mac", "nr", "src", "ino", "pos", "dr", "hop", "pad", "work", "len", "coord", "ptr", "asm", "node", "start"], "data": ["ada", "vec", "format", "slice", "array", "batch", "shift", "val", "memory", "da", "a", "def", "bytes", "buffer", "uri", "alpha", "buf", "pointer", "reader", "length", "mode", "parent", "dat", "address", "padding", "next", "timeout", "arr", "Data", "feed", "offset", "DATA", "ata", "dd", "cache", "seq", "xy", "pos", "window", "res", "pad", "len"], "size": ["format", "id", "val", "large", " length", "Size", " len", " payload", "buffer", "raw", "ize", " buffer", " ecc", "length", "SIZE", "seq", "ec", "len", "ctx"], "phb": ["phab", "ophab", "PHbar", "PHb", "ophsb", "ophc", "PHa", " phbar", " phab", "Phb", "mphc", "phc", "PHsb", "Phsb", "pha", "Phbar", "ophb", "phbar", "Pha", "phsb", " phc", "mphsb", "mphab", "mphb", " phsb", " pha"]}}
{"project": "qemu", "commit_id": "2a1639291bf9f3c88c62d10459fedaa677536ff5", "target": 0, "func": "static void pxa2xx_pm_write(void *opaque, target_phys_addr_t addr,\n\n                uint32_t value)\n\n{\n\n    struct pxa2xx_state_s *s = (struct pxa2xx_state_s *) opaque;\n\n    if (addr > s->pm_base + PCMD31) {\n\n        /* Special case: PWRI2C registers appear in the same range.  */\n\n        pxa2xx_i2c_write(s->i2c[1], addr, value);\n\n        return;\n\n    }\n\n    addr -= s->pm_base;\n\n\n\n    switch (addr) {\n\n    case PMCR:\n\n        s->pm_regs[addr >> 2] &= 0x15 & ~(value & 0x2a);\n\n        s->pm_regs[addr >> 2] |= value & 0x15;\n\n        break;\n\n\n\n    case PSSR:\t/* Read-clean registers */\n\n    case RCSR:\n\n    case PKSR:\n\n        s->pm_regs[addr >> 2] &= ~value;\n\n        break;\n\n\n\n    default:\t/* Read-write registers */\n\n        if (addr >= PMCR && addr <= PCMD31 && !(addr & 3)) {\n\n            s->pm_regs[addr >> 2] = value;\n\n            break;\n\n        }\n\n\n\n        printf(\"%s: Bad register \" REG_FMT \"\\n\", __FUNCTION__, addr);\n\n        break;\n\n    }\n\n}\n", "idx": 12642, "substitutes": {"opaque": [" opaques", "oppaco", "optca", "ipaques", "oppaques", "ipaco", "opac", "oppaque", "opaco", "ospaques", "opaques", "optaque", "opca", "ipac", "optac", "optaques", "ipaque", "ospca", " opac", "ospaque", " opaco", "ospac", "oppac", " opca"], "addr": ["area", "port", "sta", "intel", "en", "amp", "adder", "art", "val", "oa", "align", "x", "str", "cmp", "ace", "loc", "ady", "base", "driver", "padding", "afi", "offset", "cb", "md", "attr", "nick", "od", "work", "dr", "order", "index", "part", "id", "anne", "ld", "error", "grad", "adr", "data", "ext", "byte", "butt", "ip", "url", "route", "cap", "ack", "host", "mac", "ar", "reg", "alias", "el", "round", "ptr", "asm", "wr", "alt", "rr", "edge", "vr", "slot", "amd", "fx", "ref", "xp", "conn", "alpha", "ad", "layer", "rx", "site", "sb", "point", "address", "state", "east", "rt", "nr", "hop", "pos", "node", "xxx", "ord", "location", "enc", "code", "name", "hash", "flags", "access", "size", "p", "pointer", "dc", "advert", "eth", "cmd", "src", "seq", "coord", "pad", "len", "start"], "value": ["alt", "port", "m", "format", "native", "id", "val", "memory", "iv", "current", "name", "range", "values", "reference", "VALUE", "image", "hello", "null", "x", "buffer", "comment", "key", "valid", "v", "server", "output", "set", "w", "password", "size", "version", "p", "Value", "info", "dollar", "data", "none", "flow", "padding", "address", "json", "number", "end", "type", "start", "function", "va", "command", "fee", "age", "content", "reg", "num", "max", "index", "message"], "s": ["south", "sys", "m", "ses", "self", "d", "t", "service", "sg", "fs", "sync", "i", "l", "sym", "rs", "a", "g", "cs", "S", "settings", "new", "os", "sets", "si", "js", "scope", "sq", "es", "session", "server", "v", "ps", "ss", "conf", "o", "w", "u", "p", "e", "se", "socket", "site", "http", "b", "sf", "sb", "n", "f", "gs", "spec", "c", "ns", "is", "ssl", "sl", "states", "r", "ds", "services", "sie", "sa", "su", "ls", "ts", "space", "ssh", "aws"]}}
{"project": "qemu", "commit_id": "9c605cb13547a5faa5cb1092e3e44ac8b0d0b841", "target": 0, "func": "CPUX86State *cpu_x86_init(void)\n\n{\n\n    CPUX86State *env;\n\n    int i;\n\n    static int inited;\n\n\n\n    cpu_x86_tblocks_init();\n\n\n\n    env = malloc(sizeof(CPUX86State));\n\n    if (!env)\n\n        return NULL;\n\n    memset(env, 0, sizeof(CPUX86State));\n\n    /* basic FPU init */\n\n    for(i = 0;i < 8; i++)\n\n        env->fptags[i] = 1;\n\n    env->fpuc = 0x37f;\n\n    /* flags setup */\n\n    env->eflags = 0;\n\n\n\n    /* init various static tables */\n\n    if (!inited) {\n\n        inited = 1;\n\n        optimize_flags_init();\n\n    }\n\n    return env;\n\n}\n", "idx": 12645, "substitutes": {"env": ["args", "erv", "en", "context", "esp", "enc", "ea", "core", "config", "code", "eu", "oa", "ah", "eval", "manager", "event", "vm", "init", "fg", "scope", "session", "server", "v", "forest", "conf", "app", "output", "conn", "np", "console", "obj", "password", "loader", "energy", "dict", "e", "equ", "viron", "exc", "enable", "nc", "her", "engine", "ext", "eng", "qt", "inst", "f", "global", "export", "eni", "token", "ce", "cf", "uv", "exec", "db", "ev", "cache", "ec", "empty", "environment", "addr", "vs", "python", "ctx", "err"], "i": ["hi", "qi", "ui", "m", "slice", "I", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "mu", "ci", "di", "x", "si", "ie", "ii", "v", "uri", "gu", "u", "ind", "z", "p", "e", "fi", "cli", "li", "k", "b", "multi", "j", "phi", "f", "n", "ti", "ski", "ip", "c", "eni", "ji", "pi", "chi", "uli", "bi", "zi", "abi", "index"], "inited": ["inITED", " initted", " inite", "ninite", " INited", "incended", "initing", "init", " INitted", "inite", "incitted", "ninitted", "inciting", "insit", " initing", " INITED", "incited", "initted", " init", "insitted", " INiting", "insited", "inended", "incit", "incITED", " inITED", "ninITED", " inended", "insended", "ninited", "incite"]}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "void readline_show_prompt(ReadLineState *rs)\n\n{\n\n    monitor_printf(rs->mon, \"%s\", rs->prompt);\n\n    monitor_flush(rs->mon);\n\n    rs->last_cmd_buf_index = 0;\n\n    rs->last_cmd_buf_size = 0;\n\n    rs->esc_state = IS_NORM;\n\n}\n", "idx": 12663, "substitutes": {"rs": ["RC", "args", "Rs", "rr", "acs", "rss", "as", "hr", "rd", "bs", "rc", "ins", "pc", "airs", "rates", "rics", "ra", "cs", "req", "hs", "rg", "sw", "sr", "str", "rows", "ros", "ras", "ps", "ss", "cr", "ms", "mr", "ris", "rb", "rx", "ars", "RS", "gs", "arts", "acks", "spec", "ans", "xs", "ats", "ro", "rys", "stats", "results", "rt", "ack", "r", "ds", "pr", "src", "ls", "dr", "res", "ts", "ks"]}}
{"project": "qemu", "commit_id": "f61eddcb2bb5cbbdd1d911b7e937db9affc29028", "target": 0, "func": "static int parallel_parse(const char *devname)\n\n{\n\n    static int index = 0;\n\n    char label[32];\n\n\n\n    if (strcmp(devname, \"none\") == 0)\n\n        return 0;\n\n    if (index == MAX_PARALLEL_PORTS) {\n\n        fprintf(stderr, \"qemu: too many parallel ports\\n\");\n\n        exit(1);\n\n    }\n\n    snprintf(label, sizeof(label), \"parallel%d\", index);\n\n    parallel_hds[index] = qemu_chr_new(label, devname, NULL);\n\n    if (!parallel_hds[index]) {\n\n        fprintf(stderr, \"qemu: could not connect parallel device\"\n\n                \" to character backend '%s'\\n\", devname);\n\n        return -1;\n\n    }\n\n    index++;\n\n    return 0;\n\n}\n", "idx": 12667, "substitutes": {"devname": ["devnum", "devnames", "evName", "DevName", " devnames", "evnum", "Devname", "deviceName", "Devno", "devicename", "devName", "deviceno", "varnum", " devnum", "evname", "devicenames", "varname", " devno", "Devnames", " devName", "evno", "varName", "devno"], "label": ["abel", "call", "hide", "val", "code", "fb", "bad", "child", "name", "binary", "variable", "msg", "eval", "align", "test", "ref", "unit", "comment", "key", "member", "unknown", "value", "output", "error", "loc", "valid", "col", "console", "group", "summary", "bl", "ind", "display", "desc", "leaf", "li", "data", "byte", "base", "mask", "line", "address", "span", "block", "lab", "type", "cell", "field", "class", "num", "alias", "el", "Label", "len", "bel", "prefix"], "index": ["date", "Index", "path", "action", "condition", "insert", "part", "slice", "input", "id", "search", "i", "object", "current", "connection", "row", "weight", "section", "x", "option", "module", "update", "position", "comment", "append", "key", "error", "valid", "localhost", "element", "open", "active", "ind", "version", "ticket", "instance", "socket", "match", "pointer", "page", "axis", "j", "length", "count", "old", "point", "xx", "address", "number", "inc", "diff", "end", "type", "offset", "loop", "pattern", "pos", "num", "prefix", "column", "len", "find"]}}
{"project": "qemu", "commit_id": "a9e1c28ddaae5a48415fec1f336b5560eb85d3e1", "target": 0, "func": "START_TEST(qfloat_destroy_test)\n\n{\n\n    QFloat *qf = qfloat_from_double(0.0);\n\n    QDECREF(qf);\n\n}\n", "idx": 12668, "substitutes": {"qf": [" qp", "quf", "iqf", "iqF", "qfp", "qdf", "eqf", "qup", " qc", "eqfs", "quc", "eqfp", " qfs", "qp", " qdf", "eqF", "Qc", "iqfs", "Qp", " qF", "Qf", " qfp", "qfs", "Qdf", "iqfp", "qudf", "qF", "qc"]}}
{"project": "qemu", "commit_id": "b97400caef60ccfb0bc81c59f8bd824c43a0d6c8", "target": 0, "func": "static int local_lstat(FsContext *fs_ctx, V9fsPath *fs_path, struct stat *stbuf)\n\n{\n\n    int err;\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    err =  lstat(rpath(fs_ctx, path, buffer), stbuf);\n\n    if (err) {\n\n        return err;\n\n    }\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        /* Actual credentials are part of extended attrs */\n\n        uid_t tmp_uid;\n\n        gid_t tmp_gid;\n\n        mode_t tmp_mode;\n\n        dev_t tmp_dev;\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.uid\", &tmp_uid,\n\n                    sizeof(uid_t)) > 0) {\n\n            stbuf->st_uid = tmp_uid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.gid\", &tmp_gid,\n\n                    sizeof(gid_t)) > 0) {\n\n            stbuf->st_gid = tmp_gid;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.mode\",\n\n                    &tmp_mode, sizeof(mode_t)) > 0) {\n\n            stbuf->st_mode = tmp_mode;\n\n        }\n\n        if (getxattr(rpath(fs_ctx, path, buffer), \"user.virtfs.rdev\", &tmp_dev,\n\n                        sizeof(dev_t)) > 0) {\n\n                stbuf->st_rdev = tmp_dev;\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 12672, "substitutes": {"fs_ctx": ["fsxctx", "fs_xc", "fs_lc", "fs_course", "aws_exc", "vs_lc", "aws_course", "ws_path", "fs_cf", "fsJcf", "fs_anc", "fsxrc", "fs___voc", "fsprectx", "vs_connection", "fs_rc", "fsgcn", "fs_cn", "fsjctx", "FS_context", "raf_ctx", "raf_crit", "fsprexc", "fs_context", "FS_rc", "fs_c", "fs___conn", "fb_anc", "FS_src", "fb_lc", "fsJxc", "aws_cf", "fb_ctx", "fsJctx", "fs_conn", "fsprecf", "fsJcrit", "fs_sem", "fs_src", "aws_exec", "fs_voc", "fs___path", "aws_ctx", "fs_exc", "fsjconnection", "raf_sem", "ws_ctx", "fsprecrit", "fsjc", "vs_ctx", "ws_voc", "fsgctx", "vs_c", "fs___ctx", "fsjlc", "aws_xc", "FS_ctx", "fsgcrit", "fsgsem", "ws_conn", "fs_crit", "fsxsrc", "fs_exec", "aws_crit", "raf_cn", "fb_src", "fsxcontext", "fs_connection"], "fs_path": [" fs___anc", "fs___context", "fs_config", " fs_tx", "fs___batch", " fs_batch", "fs_context", " fs_context", " fs_anc", " fs___context", " fs___path", "fs_tx", "fs_batch", "fs_anc", " fs_config", "fs___path", "fs___anc", " fs___batch"], "stbuf": ["ftgb", "STcb", "putport", "resttext", "ostbuf", " stfb", "ctbuffer", "ctbuff", "STblock", "stport", " stbuff", "putgb", "stblock", "ostbuff", "stgb", "STport", "lbuf", " stbh", "ftbuffer", "STbuff", "ctblock", "restbuf", "stbuffer", "STbuffer", "stcb", "STgb", " stcb", "STuf", "restfb", " stbuffer", "luf", " stport", "putfb", "puttext", "ftcb", " sttext", "stuf", "putbuff", "ostbuffer", "stbuff", "stfb", "ctbh", "constbuffer", "STbuf", "sttext", "constuf", "ftbuf", "constbuff", " stblock", "restcb", "lbuffer", "putbuf", "ostbh", " stgb", "putcb", "ctbuf", "stbh", "constbuf", "lbuff"], "err": ["ah", "msg", "Error", "str", "loc", "Er", "br", "ind", "mr", "lr", "ok", "ver", "ler", "count", "magic", "cb", " Err", "attr", "eb", "out", "here", "fee", "dr", "order", "self", "rc", "id", "ctr", "or", "req", "error", "result", "aaa", "arr", "try", "r", "pr", "ar", "rage", "rr", "fer", "gr", "test", "ref", "init", "rh", "der", "e", "found", "f", "fe", "type", "more", "go", "ner", "bug", "it", "fy", "orig", "die", "range", "er", "act", "later", "aster", "dy", "ee", "nil", "nor", "all", "resp", "ise", "len", "y"], "buffer": [" buffers", "seek", "channel", "map", "transfer", "device", " buf", "bin", "context", "slice", "queue", "array", "batch", "texture", "seed", "fb", "shape", "binary", "memory", "uf", "FFER", " Buffer", "source", "reference", "str", "raw", "position", "writer", "slave", "server", "buff", "limit", "table", "phrase", "bar", "document", "loader", "size", "handler", "buf", "data", "b", "base", "Buffer", "reader", "length", "byte", "pointer", "flow", "holder", "url", "block", "feed", "counter", "uffer", "file", "loop", "iter", "cache", "pad", "header", "filename", "message"], "path": ["area", "port", "context", "root", "location", "part", "ath", "uc", "sync", "thin", "config", "mount", "id", "child", "home", "current", "name", "connection", "source", "image", "ref", "full", "dir", "fn", "conn", "col", "view", "loader", "p", "temp", "folder", "data", "pointer", "base", "mode", "Path", "parent", "c", "PATH", "url", "block", "route", "cat", "end", "inner", "file", "text", "transform", "host", "cache", "pattern", "content", "prop", "prefix", "alias", "ctx", "node"], "tmp_uid": ["tmp___u", "mp_uid", "mp_mode", "tmp_pid", "tmp00mode", "tmp00uu", "tmp___uid", " tmp_u", "tmp00uid", "tmp___dev", " tmp_uu", "mp_pid", "tmp00user", "tmp_machine", "tmp___uu", "mp_machine", "tmp_uu", "tmp_u", "tmp_user", "mp_user", "mp_uu"], "tmp_gid": ["tmp_gident", "tmp_appids", "tmp_rad", "tmp_cids", "tmp_guids", "tmp_rid", "tmp_guident", "tmp_guax", "tmp_appax", "tmp_uids", "tmp_egids", "tmp_gax", "tmp_guad", "tmp_cone", "tmp_uip", "tmp_rident", "tmp_guid", "tmp_uone", "tmp_cid", "tmp_gamiden", "tmp_gamids", "tmp_appiden", "tmp_gad", "tmp_rids", "tmp_egid", "tmp_cip", "tmp_egad", "tmp_gamid", "tmp_egident", "tmp_gip", "tmp_appid", "tmp_gone", "tmp_guip", "tmp_guiden", "tmp_guone", "tmp_gamax", "tmp_gids", "tmp_giden"], "tmp_mode": ["tmp67user", "mp_mode", "tmp_option", "temp_dev", "vt_mod", "temp_mac", "vt_mode", "mp_mod", "tmp5mode", "tmp67mod", "tmp_mac", "tmp_dim", "tmp5user", "temp_mod", "tmp5mod", "tmp67mode", "temp_mode", "tmp5option", "vt_raid", "tmp_mod", "tmp67option", "vt_dim", "tmp_user", "tmp_raid", "mp_user", "mp_option"], "tmp_dev": ["tmp_debug", "mp_mode", "tmp__diff", "mp_debug", "mp_device", "tmp__dev", "mp_push", "tmp__device", "tmp_device", "mp_dev", "tmp_diff", "tmp__push", "tmp_de", " tmp_de", "tmp_home", "tmp_push", " tmp_home", " tmp_device", "mp_diff"]}}
{"project": "qemu", "commit_id": "becf8217deb2afc347d5172d9f30c8a8964b8b27", "target": 0, "func": "void QEMU_NORETURN runtime_exception(CPUS390XState *env, int excp,\n\n                                     uintptr_t retaddr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    int t;\n\n\n\n    cs->exception_index = EXCP_PGM;\n\n    env->int_pgm_code = excp;\n\n\n\n    /* Use the (ultimate) callers address to find the insn that trapped.  */\n\n    cpu_restore_state(cs, retaddr);\n\n\n\n    /* Advance past the insn.  */\n\n    t = cpu_ldub_code(env, env->psw.addr);\n\n    env->int_pgm_ilen = t = get_ilen(t);\n\n    env->psw.addr += t;\n\n\n\n    cpu_loop_exit(cs);\n\n}\n", "idx": 12686, "substitutes": {"env": ["forge", "args", "en", "context", "bc", "enc", "cv", "ea", "config", "code", " environment", "eve", "eu", "utils", "ah", "oa", "ass", "manager", "settings", "kernel", "cn", "txt", "vm", "init", "server", "v", "conf", "conn", "np", "console", "obj", "energy", "dev", "dict", "e", "net", "viron", "exc", "engine", "nc", "vs", "her", "ext", "eng", "site", "Environment", "dat", "export", "c", "eni", "global", "agent", "dt", "ne", "cb", "ce", "cf", "here", "que", "exec", "db", "ev", "inet", "ec", "cache", "environment", "fen", "el", "core", "et", "ctx", "err"], "excp": ["axcp", "extcp", "nexcpp", "excm", "nexpp", "nexcp", "napc", "nexcm", "Expc", "execcpp", "extcpp", "excs", "execcm", "axcs", "axCP", "axpc", "expp", "exCP", "execpp", "Excp", "nacs", "extcm", "excpp", "expc", "execcp", "naCP", "extpp", "ExCP", "nacp", "Excs"], "retaddr": ["RETaddr", "Retace", "Retaddr", "retwork", "RETwork", " retwork", "RETaddress", "Retaddress", " retnode", " retace", "retaddress", "retace", "RETace", " retaddress", "RETnode", "Retwork", "Retnode", "retnode"], "cs": ["args", "acs", "bc", "ca", "sync", "bs", "cc", "pc", "fs", "rs", "lc", "CS", "ci", "sk", "cn", "os", "wcs", "js", "Cs", "ras", "ps", "ss", "conn", "cons", "s", "cks", "ck", "cus", "ars", "gs", "spec", "c", "ns", "cas", "sc", "cf", "cp", "ds", "ec", "css", "ls", "ts", "ces", "vs", "ctx", "ks"], "t": ["T", "port", "it", "m", "d", "l", "i", "pt", "a", "ta", "g", "test", "h", "tt", "wt", "x", "null", "total", "v", "tm", "o", "w", "z", "ant", "u", "p", "e", "y", "s", "temp", "mt", "b", "tc", "j", "n", "f", "ti", "at", "token", "c", "dt", "tf", "type", "tz", "target", " p", "out", "rt", "off", " T", "ts", "ty", "et", "tp"]}}
{"project": "qemu", "commit_id": "a277c3e094d5e9f653ccc861f59e07c94c7fe6c7", "target": 0, "func": "static int usb_host_init(void)\n\n{\n\n    const struct libusb_pollfd **poll;\n\n    int i, rc;\n\n\n\n    if (ctx) {\n\n        return 0;\n\n    }\n\n    rc = libusb_init(&ctx);\n\n    if (rc != 0) {\n\n        return -1;\n\n    }\n\n    libusb_set_debug(ctx, loglevel);\n\n\n\n    libusb_set_pollfd_notifiers(ctx, usb_host_add_fd,\n\n                                usb_host_del_fd,\n\n                                ctx);\n\n    poll = libusb_get_pollfds(ctx);\n\n    if (poll) {\n\n        for (i = 0; poll[i] != NULL; i++) {\n\n            usb_host_add_fd(poll[i]->fd, poll[i]->events, ctx);\n\n        }\n\n    }\n\n    free(poll);\n\n    return 0;\n\n}\n", "idx": 12701, "substitutes": {"poll": ["batch", "child", "event", "pool", "fp", "loc", "server", "rec", "wait", "play", "list", "timeout", "cb", "fail", "lex", "ga", "work", "lock", "index", "call", "oll", "sync", "vote", "irc", "bb", "io", "lot", "lc", "pick", "progress", "comment", "lib", "data", "feed", "friend", "exec", "reg", "run", "thread", "zip", "queue", "config", "pc", "Poll", "ock", "live", "install", "ll", "download", "pipe", "query", "block", "ac", "loop", "load", "delay", "bl", "cl", "ctx", "board", "search", "job", "patch", "col", "wave", "oc", "p", "select", "draft", "quit", "ctl", "pull", "db", "sleep"], "i": ["qi", "it", "ui", "m", "adi", "I", "d", "ai", "xi", "id", "l", "ini", "gi", "iu", "oi", "io", "iv", "api", "lc", "ci", "mu", "x", "di", "init", "si", "ie", "ii", "uri", "v", "o", "yi", "z", "u", "iii", "p", "e", "fi", "info", "cli", "li", "b", "ix", "multi", "j", "abi", "phi", "f", "ti", "ip", "c", "ji", "pi", "uli", "bi", "ri", "ei", "in", "index"], "rc": ["RC", "rr", "uc", "bc", "qa", "reply", "cv", "sync", "cc", "pc", "iv", "roc", "gc", "lc", "rn", "ref", "init", "loc", "error", "rh", "cr", "conn", "oc", "rec", "rb", "rx", "nc", "ck", "tc", "result", "ann", "rl", "inc", "c", "dc", "ry", "ac", "anc", "cb", "sc", "ic", "ack", "r", "ri", "xc", "src", "ec", "cur", "fc", "irc", "err"]}}
{"project": "qemu", "commit_id": "2dfb4c033f2f8fbad252bed1ba3e0fed112cbb7c", "target": 0, "func": "SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,\n\n                                                         bool has_id,\n\n                                                         const char *id,\n\n                                                         bool has_name,\n\n                                                         const char *name,\n\n                                                         Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    BlockBackend *blk;\n\n    AioContext *aio_context;\n\n    QEMUSnapshotInfo sn;\n\n    Error *local_err = NULL;\n\n    SnapshotInfo *info = NULL;\n\n    int ret;\n\n\n\n    blk = blk_by_name(device);\n\n    if (!blk) {\n\n        error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,\n\n                  \"Device '%s' not found\", device);\n\n        return NULL;\n\n    }\n\n\n\n    aio_context = blk_get_aio_context(blk);\n\n    aio_context_acquire(aio_context);\n\n\n\n    if (!has_id) {\n\n        id = NULL;\n\n    }\n\n\n\n    if (!has_name) {\n\n        name = NULL;\n\n    }\n\n\n\n    if (!id && !name) {\n\n        error_setg(errp, \"Name or id must be provided\");\n\n        goto out_aio_context;\n\n    }\n\n\n\n    if (!blk_is_available(blk)) {\n\n        error_setg(errp, \"Device '%s' has no medium\", device);\n\n        goto out_aio_context;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    if (bdrv_op_is_blocked(bs, BLOCK_OP_TYPE_INTERNAL_SNAPSHOT_DELETE, errp)) {\n\n        goto out_aio_context;\n\n    }\n\n\n\n    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n    if (!ret) {\n\n        error_setg(errp,\n\n                   \"Snapshot with id '%s' and name '%s' does not exist on \"\n\n                   \"device '%s'\",\n\n                   STR_OR_NULL(id), STR_OR_NULL(name), device);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    bdrv_snapshot_delete(bs, id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        goto out_aio_context;\n\n    }\n\n\n\n    aio_context_release(aio_context);\n\n\n\n    info = g_new0(SnapshotInfo, 1);\n\n    info->id = g_strdup(sn.id_str);\n\n    info->name = g_strdup(sn.name);\n\n    info->date_nsec = sn.date_nsec;\n\n    info->date_sec = sn.date_sec;\n\n    info->vm_state_size = sn.vm_state_size;\n\n    info->vm_clock_nsec = sn.vm_clock_nsec % 1000000000;\n\n    info->vm_clock_sec = sn.vm_clock_nsec / 1000000000;\n\n\n\n    return info;\n\n\n\nout_aio_context:\n\n    aio_context_release(aio_context);\n\n    return NULL;\n\n}\n", "idx": 12704, "substitutes": {"device": ["path", "port", "d", "service", "connection", "task", "directory", "serial", "project", "di", "devices", "module", "unit", "product", "model", "scope", "description", "server", "error", "package", "platform", "conn", "de", "password", "Device", "dev", "sid", "direct", "direction", "display", "mobile", "data", "component", "driver", "mode", "address", "feature", "ip", "block", "gpu", "dc", "phy", "attribute", "type", "target", "md", "cmd", "dp", "host", "disk", "mac", "dn", "tag", "node", "uid"], "has_id": ["hasWname", "has_version", "hasCsource", " has_ids", "hasCversion", " has_device", " has_version", "has64vid", "hasOid", "hasOdevice", "has_vid", "hasCname", "hasCid", "has64ids", "has64id", " has_source", "has_device", "hasOvid", "has_source", "has64device", "has_ids", "hasWsource", " has_vid", "hasOids", "hasWversion", "hasWid"], "id": ["oid", "head", "it", "ui", "root", "bid", "d", "rid", "input", "search", "i", "mid", "code", "vid", "def", "Id", " fid", "act", "ident", "image", "user", "ide", "key", "pid", "error", "value", "like", "ID", "ids", "size", "ad", "version", "sid", "dev", " ID", "data", "length", "address", "ip", "number", "url", "block", "start", "end", "type", "md", "aid", "hid", "pad", "in", "kid", "index", "uid"], "has_name": ["nasJlong", "hasSdescription", "has_long", "nas_name", "nasJid", "hasSresource", "main_resource", "has__name", "has__description", "mainSdescription", "nas_long", "hasJlong", "main_description", "has__resource", "has_time", "has_description", "hasJid", "hasSname", "main_name", "hasJtime", "hasJname", "nasJname", "nas_time", "has_resource", "nas_id", "mainSname", "nasJtime", "mainSresource"], "name": ["word", "path", "part", "non", "ni", "nam", "search", "style", "label", "na", "image", "new", "ident", "description", "x", "user", "comment", "key", "error", "package", "Name", "NAME", "pass", "names", "term", "size", "version", "dev", "time", "named", "engine", "resource", "mini", "data", "base", "min", "n", "none", "office", "custom", "number", "block", "nm", "end", "type", "create", "nice", "wa", "no", "prefix", "space", "alias", "filename"], "errp": ["arrps", "rrfp", "errorp", "errpi", "errpatch", "errc", " erc", "orderp", "arrpi", " errP", "errpa", "armp", "oderpi", "oderps", "errpoint", "arrp", " erP", "ierpoint", "rrr", " errf", "rrf", "ierp", "erfp", "ierpatch", "erpre", "rrb", " errc", "yrpa", "oderr", "oderp", "errr", "errps", " errfp", "erp", "codepa", "errpre", "codep", " errb", " errpa", "arrr", "erpi", "errorr", "finderpc", " errr", "errf", "erpc", "rrpre", " erp", " errpre", "rrp", "errorP", "errP", "yrps", "erc", "finderp", " err", "erps", "errb", "codeps", "err", " errps", "finderr", "codef", "yrp", "errfp", "armpc", "rrP", "armps", "errorf", "errorb", "armr", "errpc", " errpoint", "finderps", "erf", "orderpatch", " errpatch", "yrf", "erP", "orderpoint"], "bs": ["bin", "bid", "bis", "bc", "sync", "BS", "fs", "iss", "ins", "bb", "rs", "fb", "cs", "os", "bytes", "js", "ros", "br", "ps", "ss", "platform", "conn", "lib", "android", "obs", "pb", "socket", "b", "sb", "base", "banks", "gb", "gs", "bits", "bh", "state", "ns", "bps", "cb", "bg", "bes", "bas", "ops", "org", "ds", "kb", "db", "bi", "src", "ls", "css", "lb", "bos", "pos", "las", "bl", "vs", "us", "kit", "res", "ks"], "blk": ["BLks", " bluk", "dlok", "slk", "clke", "dlks", "blK", "clc", "Blk", "belc", "plkt", "blke", " blb", "BLok", "clks", "sld", "brb", "plk", " bld", " blK", "belck", "plke", "BLuk", " blks", "Blb", "plks", "blok", "selke", "bld", "plK", "BLk", "belk", "blck", "selc", "plck", "brk", "BlK", "bluk", "clk", "selk", "blkt", "pld", "blc", " blkt", "brK", "plc", "blb", "Blkt", "Blck", " blok", " blc", "selks", "Blks", " blck", "dluk", "dlk", "brck", "blks", "BLb", "BLkt", "belK", "slck", "slkt"], "aio_context": ["aio_ctx", "aios_ctx", "aioacconnection", "aio_config", "aio_control", "aios_context", "aio_connection", "aios_connection", "aioaccontext", "aio_stream", "aios_control", "aios_stream", "aioacchannel", "aioacctx", "aio_channel", "aios_config"], "sn": [" sc", " syn", "service", "sync", "i", " stats", " resp", "handle", " SN", "uid", " sr", " rc", " el", " si", "details", "sk", "os", " Sn", "auth", "settings", "si", " ac", "fn", " sys", "server", "loc", "opt", " conf", "session", "conn", "detail", " obj", " rec", "sid", "rec", "dev", "s", "spec", " li", "ip", "Syn", " ob", " detail", " res", "nt", "attr", " cs", "cache", "SN", "dn", "addr", "Sn", " disp", " ex"], "local_err": ["local_error", "localapperror", "locallyrr", "local_data", "localencor", "erroringrr", "localalerr", "localalerror", "standardendata", "localapperr", "localayerr", "locallyerr", "locallyvar", " local_er", "localaycor", "localinginit", "localingkey", "localendata", "internal_error", "local_er", "local_key", "standard_data", "localappmsg", "locallyinit", "foreign_error", "error_err", "erroringkey", "internal_msg", "localaybug", "localenbug", "standardenbug", "erroringinit", "localenerr", "local_cor", "local5ler", "locallykey", "global_user", "internal_exp", "global_error", "localalvar", "global_err", "locallyuser", "error_key", "local5err", "local_sys", "localaluser", "local_msg", "localingrr", "foreign_sys", "local_var", "locallyerror", "error_init", "localaydata", "local_init", "standardencor", "standardenerr", "local_bug", "localappsys", " local_ler", "erroringerr", "local5req", "error_rr", " local_req", "local_exp", "foreignappsys", "local_req", "standard_err", "standard_bug", "global_var", " local_error", "localingerr", "localappexp", "foreignapperror", "foreign_err", "local_ler", "internal_err", "local_rr", "foreignapperr", "local_user", "standard_cor"], "info": ["sys", "part", "i", "inf", "extra", "def", "api", "details", "source", "os", "fo", "error", "detail", "obj", "data", "op", "f", "stat", "att", "state", "ip", "diff", "INFO", "inner", "cache", "Info"], "ret": ["alt", "rev", "reply", "rc", "val", "code", "def", "rets", "fun", "ref", "arg", "det", "full", "hash", "lit", "feat", "obj", "mt", "rec", "fin", "success", "data", "match", "Ret", "bit", "count", "result", " RET", "att", "arr", " Ret", "nt", "re", "rt", "resp", "RET", "res", "no", "reg", "flag", "num", "len", "red"]}}
{"project": "qemu", "commit_id": "3eff1f46f08a360a4ae9f834ce9fef4c45bf6f0f", "target": 0, "func": "static void virtio_scsi_complete_req(VirtIOSCSIReq *req)\n\n{\n\n    VirtIOSCSI *s = req->dev;\n\n    VirtQueue *vq = req->vq;\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    virtqueue_push(vq, &req->elem, req->qsgl.size + req->elem.in_sg[0].iov_len);\n\n    if (req->sreq) {\n\n        req->sreq->hba_private = NULL;\n\n        scsi_req_unref(req->sreq);\n\n    }\n\n    virtio_scsi_free_req(req);\n\n    virtio_notify(vdev, vq);\n\n}\n", "idx": 12710, "substitutes": {"req": ["sem", "proc", "def", "low", "str", "cmp", "mr", "rec", "ver", "tar", "requ", "spec", "pro", "pri", "call", "ru", "dq", "ctr", "progress", "fr", "grad", "resource", "require", "data", "ext", "iq", "r", "exec", "ev", "res", "rf", "rr", "tr", "config", "wx", "ref", "init", "app", "rh", "conn", "war", "sec", "desc", "rx", "http", "qt", "f", "dep", "query", "wa", "load", "rt", "cur", "push", "ctx", "err", "pkg", "hr", "worker", "required", "row", "this", "user", "sq", "conf", "request", "p", "crit", "pull", "q", "cmd", "org", "resp", "qq", "seq"], "s": ["sys", "ses", "m", "service", "d", "t", "fs", "sym", "g", "S", "os", "sk", "js", "si", "es", "sq", "session", "server", "v", "ss", "client", "o", "w", "dev", "p", "e", "sb", "b", "sf", "n", "f", "gs", "spec", "c", "ns", "ssl", "r", "ds", "services", "su"], "vq": ["hq", " vque", "jque", "vrw", "vqt", "vp", "tvq", "vqu", "vqa", "fqu", "hg", "nqt", "vrdev", " vw", "fdev", "fqs", "fp", "hqt", "evqs", "tvp", "tvqs", "nw", " vg", "hque", " vqa", "fque", "nq", "vque", "evp", "vw", "fq", "fqa", "vrq", "vqs", "nqu", "nque", "vg", "vrqa", "ng", "jw", "jq", " vqt", "evq", "evque", "jqu", "tvque", "fw"], "vdev": [" vdiv", "Vdiv", "vconn", "wconn", "wdev", "Vdev", " vev", "vdiv", "Vrc", "wdevice", " vconn", "lconn", "Vev", "wdiv", "vrc", "ldev", "vmdiv", "vdevice", " vrc", "vmrc", " vdevice", "vmev", "vmdev", "ldevice", "vev"]}}
{"project": "qemu", "commit_id": "978f2205c791de0e02c8802a645bea657408abfd", "target": 0, "func": "bool timer_pending(QEMUTimer *ts)\n\n{\n\n    QEMUTimer *t;\n\n    for (t = ts->timer_list->active_timers; t != NULL; t = t->next) {\n\n        if (t == ts) {\n\n            return true;\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 12724, "substitutes": {"ts": ["types", "acs", "m", "tx", "te", "uts", "tk", "tr", "fs", "rs", "ta", "td", "er", "qs", "tes", "test", "tl", "cs", "this", "tt", "its", "tg", "os", "es", "times", "ps", "ss", "tm", "e", "s", "options", "Ts", "tc", "tests", "TS", "ns", "xs", "dt", "ted", "ats", "tf", "tz", "outs", "als", "ops", "tips", "ter", "ls", "las", "tp"], "t": ["T", "that", "it", "m", "te", "d", "tr", "l", "pt", "ta", "er", "test", "tg", "h", "tt", "x", "wt", "null", "ct", "v", "tree", "o", "ant", "u", "p", "e", "s", "y", "temp", "time", "tc", "b", "qt", "n", "f", "ti", "at", "timer", "token", "c", "dt", "tw", "tf", "type", "tz", "target", "you", "rt", "unt", "the", "template", "tim", "ot", "tp"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int av_cold libopus_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibopusEncContext *opus = avctx->priv_data;\n\n    const uint8_t *channel_mapping;\n\n    OpusMSEncoder *enc;\n\n    int ret = OPUS_OK;\n\n    int coupled_stream_count, header_size, frame_size;\n\n\n\n    coupled_stream_count = opus_coupled_streams[avctx->channels - 1];\n\n    opus->stream_count   = avctx->channels - coupled_stream_count;\n\n    channel_mapping      = libav_libopus_channel_map[avctx->channels - 1];\n\n\n\n    /* FIXME: Opus can handle up to 255 channels. However, the mapping for\n\n     * anything greater than 8 is undefined. */\n\n    if (avctx->channels > 8)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Channel layout undefined for %d channels.\\n\", avctx->channels);\n\n\n\n    if (!avctx->bit_rate) {\n\n        /* Sane default copied from opusenc */\n\n        avctx->bit_rate = 64000 * opus->stream_count +\n\n                          32000 * coupled_stream_count;\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"No bit rate set. Defaulting to %d bps.\\n\", avctx->bit_rate);\n\n    }\n\n\n\n    if (avctx->bit_rate < 500 || avctx->bit_rate > 256000 * avctx->channels) {\n\n        av_log(avctx, AV_LOG_ERROR, \"The bit rate %d bps is unsupported. \"\n\n               \"Please choose a value between 500 and %d.\\n\", avctx->bit_rate,\n\n               256000 * avctx->channels);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    frame_size = opus->opts.frame_duration * 48000 / 1000;\n\n    switch (frame_size) {\n\n    case 120:\n\n    case 240:\n\n        if (opus->opts.application != OPUS_APPLICATION_RESTRICTED_LOWDELAY)\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"LPC mode cannot be used with a frame duration of less \"\n\n                   \"than 10ms. Enabling restricted low-delay mode.\\n\"\n\n                   \"Use a longer frame duration if this is not what you want.\\n\");\n\n        /* Frame sizes less than 10 ms can only use MDCT mode, so switching to\n\n         * RESTRICTED_LOWDELAY avoids an unnecessary extra 2.5ms lookahead. */\n\n        opus->opts.application = OPUS_APPLICATION_RESTRICTED_LOWDELAY;\n\n    case 480:\n\n    case 960:\n\n    case 1920:\n\n    case 2880:\n\n        opus->opts.packet_size =\n\n        avctx->frame_size      = frame_size * avctx->sample_rate / 48000;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame duration: %g.\\n\"\n\n               \"Frame duration must be exactly one of: 2.5, 5, 10, 20, 40 or 60.\\n\",\n\n               opus->opts.frame_duration);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->compression_level < 0 || avctx->compression_level > 10) {\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Compression level must be in the range 0 to 10. \"\n\n               \"Defaulting to 10.\\n\");\n\n        opus->opts.complexity = 10;\n\n    } else {\n\n        opus->opts.complexity = avctx->compression_level;\n\n    }\n\n\n\n    if (avctx->cutoff) {\n\n        switch (avctx->cutoff) {\n\n        case  4000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_NARROWBAND;\n\n            break;\n\n        case  6000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_MEDIUMBAND;\n\n            break;\n\n        case  8000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_WIDEBAND;\n\n            break;\n\n        case 12000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_SUPERWIDEBAND;\n\n            break;\n\n        case 20000:\n\n            opus->opts.max_bandwidth = OPUS_BANDWIDTH_FULLBAND;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Invalid frequency cutoff: %d. Using default maximum bandwidth.\\n\"\n\n                   \"Cutoff frequency must be exactly one of: 4000, 6000, 8000, 12000 or 20000.\\n\",\n\n                   avctx->cutoff);\n\n            avctx->cutoff = 0;\n\n        }\n\n    }\n\n\n\n    enc = opus_multistream_encoder_create(avctx->sample_rate, avctx->channels,\n\n                                          opus->stream_count,\n\n                                          coupled_stream_count,\n\n                                          channel_mapping,\n\n                                          opus->opts.application, &ret);\n\n    if (ret != OPUS_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Failed to create encoder: %s\\n\", opus_strerror(ret));\n\n        return ff_opus_error_to_averror(ret);\n\n    }\n\n\n\n    ret = libopus_configure_encoder(avctx, enc, &opus->opts);\n\n    if (ret != OPUS_OK) {\n\n        ret = ff_opus_error_to_averror(ret);\n\n        goto fail;\n\n    }\n\n\n\n    header_size = 19 + (avctx->channels > 2 ? 2 + avctx->channels : 0);\n\n    avctx->extradata = av_malloc(header_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if (!avctx->extradata) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate extradata.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    avctx->extradata_size = header_size;\n\n\n\n    opus->samples = av_mallocz(frame_size * avctx->channels *\n\n                               av_get_bytes_per_sample(avctx->sample_fmt));\n\n    if (!opus->samples) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Failed to allocate samples buffer.\\n\");\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    ret = opus_multistream_encoder_ctl(enc, OPUS_GET_LOOKAHEAD(&avctx->delay));\n\n    if (ret != OPUS_OK)\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Unable to get number of lookahead samples: %s\\n\",\n\n               opus_strerror(ret));\n\n\n\n    libopus_write_header(avctx, opus->stream_count, coupled_stream_count,\n\n                         opus_vorbis_channel_map[avctx->channels - 1]);\n\n\n\n    ff_af_queue_init(avctx, &opus->afq);\n\n\n\n    opus->enc = enc;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opus_multistream_encoder_destroy(enc);\n\n    av_freep(&avctx->extradata);\n\n    return ret;\n\n}\n", "idx": 12730, "substitutes": {"avctx": ["abconn", "apcf", "avlc", "ajconfig", "afcdn", "avsci", " avvoc", "aflc", "navctx", "umcontext", "abcp", "ausci", "ajcdn", "afconfig", "AVcf", "vercf", " avcmp", "avecci", "avcu", "umtx", " avcontext", "avecmp", "AVkb", "avecoll", " avcci", "umcmp", "afcus", "avecontext", "navcontext", "avconfig", "avcp", "abctx", "afvoc", "AVconfig", "plugconfig", "afconn", "abcontext", " avci", "aucontext", "avekb", "awnas", "avecp", "ajcontext", "navrc", "apcontext", "afcf", "AVloc", " avconfig", "aftx", "AVcontext", "navvoc", "avectx", "afrc", "akloc", "afnas", "AVconn", "AVlc", "avcdn", "apkb", "afcontext", "alctrl", "avcoll", "avcn", "navsci", " avloc", "avkb", "avecus", "akctx", "aucu", "avconn", "avloc", "afci", "avcus", "avrc", "avctrl", "akcontext", "avetx", "afsci", " avkw", "avkw", "avesci", "plugcn", "plugctx", "avci", "avepkg", "avcf", "avnas", "akconfig", "AVci", "afkw", "vercoll", "avvoc", "avecu", "auconn", "apconn", "vercontext", "plugcontext", "awlc", "AVnas", "avtx", "AVsci", "ajctx", "ajctrl", "aveconfig", "aveloc", "afloc", "Avloc", "verctx", "avecf", "afctx", "afcci", "avcci", "alcontext", "Avconn", "afcoll", "auconfig", " avcoll", "avcca", "Avcontext", "afpkg", "avecca", "afkb", "AVcmp", "Avctx", "awctx", "avcmp", "avekw", "avelc", "afcn", "avalpkg", "avevoc", "AVcu", "afcmp", "avalcus", "afcp", "apctx", "avalcontext", "auctx", "alcdn", "navconfig", "avalctx", "AVcca", "avcontext", "aveconn", "ajcci", "apcca", " avconn", "AVctx", "avecn", "alctx", "awcontext", "avpkg", "afctrl", "averc", "umctx"], "opus": ["capt", "cop", "avin", "roc", "audio", "auc", "image", "lp", "anus", "avi", "abo", "append", "np", "obj", "office", "oga", "ocr", "afi", "author", "apa", "slice", "osa", "oss", "api", "opa", "iop", "data", "abi", "ip", "ops", "ahi", "archive", "alias", "iti", "oper", "asu", "osi", "opted", "edit", "gmail", "mp", "opl", "fb", "original", "wikipedia", "umi", "operator", "eff", "apache", "o", "opter", "ave", "opp", "voc", "php", "root", "jp", "split", "object", "orb", "effect", "oph", "av", "opers", "oc", "pb", "op", "wp", "wav", "wiki", "creator", "ogg", "org", "voice", "bos", "join", "esi"], "channel_mapping": ["channel_smapping", "channel_latching", "channel_Mappings", "channel_smasing", "channel_dimmap", "channel_lappings", "channel_mappings", "channel_lmap", "channel_mmap", "channel_smapper", "channel_Masing", "channel_lasing", "channel_smappings", "channel_lapper", "channel_lapping", "channel_dimatching", "channel_Mmap", "channel_dimapping", "channel_matching", "channel_mapper", "channel_Mapper", "channel_Mapping", "channel_dimappings", "channel_Matching", "channel_masing"], "enc": ["acs", "sys", "cv", "iv", "alg", "conv", "auth", "acc", "conn", "obj", "ant", "rec", "Enc", "nc", "eng", "inc", "cat", "voc", "ac", "transform", "sl", "ack", "nec", "mac", "ec", "util", "alloc"], "coupled_stream_count": ["coupled_stream_length", "coupled_stream_path", "coupled_channel_path", "coupled_stream_type", "coupled_channel_count", "coupled_streamslength", "coupled_channel_type", "coupled_channel_length", "coupled_stream_sum", "coupled_channel_sum", "coupled_streamssize", "coupled_channel_size", "coupled_stream_size", "coupled_streamscount"], "header_size": ["header64size", " header_count", " header64bytes", "header_bytes", "header_count", " header64size", " header_number", "header64bytes", " header64number", " header64count", " header_bytes", "header64count", "header64number", "header_number"], "frame_size": ["fram_Size", "iframe_count", "frame64size", "frame_rate", "frame_Size", "frame64scale", "image_start", "file_mode", "fram_rate", "frame_speed", "frame_count", "frame_start", "frame64start", "image_scale", "frame64type", "window_offset", "iframe___count", "iframe_size", "file_length", "window_rate", "frame_scale", "frame_offset", "iframe___duration", "frame_mode", "image_size", "iframe_duration", "frame___count", "frame___duration", "file_size", "iframe___size", "frame_duration", "frame___size", "fram_size", "frame_length", "frame_type", "window_size", "window_count", "fram_speed", "file_speed", "image_type"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int sig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUX86State *env)\n\n{\n\n\tstruct rt_sigframe *frame;\n\n\tint err = 0;\n\n\n\n\tframe = get_sigframe(ka, env, sizeof(*frame));\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))\n\n\t\tgoto give_sigsegv;\n\n#endif\n\n\n\n\terr |= __put_user((/*current->exec_domain\n\n\t\t    \t   && current->exec_domain->signal_invmap\n\n\t\t    \t   && sig < 32\n\n\t\t    \t   ? current->exec_domain->signal_invmap[sig]\n\n\t\t\t   : */sig),\n\n\t\t\t  &frame->sig);\n\n\terr |= __put_user((target_ulong)&frame->info, &frame->pinfo);\n\n\terr |= __put_user((target_ulong)&frame->uc, &frame->puc);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Create the ucontext.  */\n\n\terr |= __put_user(0, &frame->uc.uc_flags);\n\n\terr |= __put_user(0, &frame->uc.uc_link);\n\n\terr |= __put_user(/*current->sas_ss_sp*/ 0, &frame->uc.uc_stack.ss_sp);\n\n\terr |= __put_user(/* sas_ss_flags(regs->esp) */ 0,\n\n\t\t\t  &frame->uc.uc_stack.ss_flags);\n\n\terr |= __put_user(/* current->sas_ss_size */ 0, &frame->uc.uc_stack.ss_size);\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, &frame->fpstate,\n\n\t\t\t        env, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up to return from userspace.  If provided, use a stub\n\n\t   already in userspace.  */\n\n\tif (ka->sa.sa_flags & TARGET_SA_RESTORER) {\n\n\t\terr |= __put_user(ka->sa.sa_restorer, &frame->pretcode);\n\n\t} else {\n\n\t\terr |= __put_user(frame->retcode, &frame->pretcode);\n\n\t\t/* This is movl $,%eax ; int $0x80 */\n\n\t\terr |= __put_user(0xb8, (char *)(frame->retcode+0));\n\n\t\terr |= __put_user(TARGET_NR_rt_sigreturn, (int *)(frame->retcode+1));\n\n\t\terr |= __put_user(0x80cd, (short *)(frame->retcode+5));\n\n\t}\n\n\n\n\tif (err)\n\n\t\tgoto give_sigsegv;\n\n\n\n\t/* Set up registers for signal handler */\n\n\tenv->regs[R_ESP] = (unsigned long) frame;\n\n\tenv->eip = (unsigned long) ka->sa._sa_handler;\n\n\n\n        cpu_x86_load_seg(env, R_DS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_ES, __USER_DS);\n\n        cpu_x86_load_seg(env, R_SS, __USER_DS);\n\n        cpu_x86_load_seg(env, R_CS, __USER_CS);\n\n\tenv->eflags &= ~TF_MASK;\n\n\n\n\treturn;\n\n\n\ngive_sigsegv:\n\n\tif (sig == TARGET_SIGSEGV)\n\n\t\tka->sa._sa_handler = TARGET_SIG_DFL;\n\n\tforce_sig(TARGET_SIGSEGV /* , current */);\n\n}\n", "idx": 12741, "substitutes": {"sig": ["psigs", " sigs", "nsIG", "pock", "ssigs", "psigma", "gsIG", "setsigh", "sesigma", "pigma", "SIG", "dsigma", "nsigma", "sesigs", "ssock", "sesig", "setsig", "sesigh", "gsigs", "sigma", "setsigma", "nsigs", "pig", "sIG", "pigs", "sigs", " sIG", "psock", "ssig", "nsig", "setsIG", "Sig", "gsigma", " sigma", "gsig", "sesIG", "dsigh", "sock", "Sigs", "ssigma", "sigh", "dsig", "Sigma", "psig", "dsIG"], "ka": ["aka", "ua", "area", "sta", "eka", "ha", "qa", "ca", "ea", "ai", "ja", "ia", "ker", "da", "oa", "LA", "ta", "ko", "ra", "za", "KA", "ki", "na", "ema", "ama", "qua", "cha", "la", "ba", "ku", "ket", "kt", "au", "ma", "cca", "sc", "wa", "va", "kb", "ga", "sa", "ya", "asa", "ae", "ctx"], "info": ["zip", "hi", "path", "isu", "ui", "context", " inf", "uc", "ai", "config", "id", "ini", "i", "inf", "code", "up", "home", "api", "name", "ci", "source", "image", "py", "fo", "about", "init", "si", "update", "ii", "loc", "hel", "job", "meta", "conf", "buff", "help", "summary", "fi", "mi", "abi", "f", "stat", "information", "inc", "diff", "setup", "INFO", "afi", "iso", "hand", "Info", "ami", "util", "in", "index"], "set": ["en", "context", "sche", "enc", "config", "pre", "SET", "msg", "ex", "send", "section", " en", "status", "ner", "sets", "init", "si", "update", "loc", "setting", "vert", "ut", "parse", "clear", "ind", "se", "e", "eq", "Set", "site", "base", "from", "stat", "store", "dat", "state", "export", "spec", "setup", "reset", "block", "end", "ne", "gen", "sc", "get", "cal", "que", "sh", "exec", "sel", "ise", "iss", "et", "kit", "net", "ze", "start"], "env": ["en", "context", "enc", "ea", "config", "ini", "eu", " en", "si", "init", "loc", "estate", "v", "conf", "np", "stage", "dev", "dict", "e", "ctx", "viron", "exc", "eq", "ind", "data", "eng", "ext", "qt", "dat", "ette", "eni", "ne", "ep", "db", "ev", "et", "ec", "environment", "el", "ise", "vs", "ef", "net"], "frame": ["build", "profile", "motion", "def", "za", "image", "event", "module", "ace", "model", "rame", "base", "raise", "flow", "line", "frames", "c", "class", "cycle", "dr", "lock", "window", "fc", "message", "draw", "call", "part", "slice", "sche", "flower", "session", "cha", "fr", "parse", "version", "fake", "fi", "data", "b", "result", "design", "pe", "function", "body", "layout", "el", "thread", "zip", "ch", "Frame", "fram", "config", "iframe", "fb", "framework", "style", "shot", "connection", "source", "plane", "cpu", "section", "game", "update", "scope", "step", "element", "role", "view", "layer", "processor", "stage", "e", "boot", "note", "f", "point", "none", "cfg", "feature", "state", "fe", "block", "ne", "cf", "load", "que", "hop", "scene", "plate", "ctx", "node", "tick", "ze", "jp", "code", "object", "range", "row", "user", "position", "feat", "component", "nil", "setup", "next", "file", "target", "figure", "seq"]}}
{"project": "qemu", "commit_id": "f2001a7e0555b66d6db25a3ff1801540814045bb", "target": 0, "func": "static void tcp_chr_telnet_init(QIOChannel *ioc)\n\n{\n\n    char buf[3];\n\n    /* Send the telnet negotion to put telnet in binary, no echo, single char mode */\n\n    IACSET(buf, 0xff, 0xfb, 0x01);  /* IAC WILL ECHO */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x03);  /* IAC WILL Suppress go ahead */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfb, 0x00);  /* IAC WILL Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n    IACSET(buf, 0xff, 0xfd, 0x00);  /* IAC DO Binary */\n\n    qio_channel_write(ioc, buf, 3, NULL);\n\n}\n", "idx": 12777, "substitutes": {"ioc": ["iocol", "liocl", "atiuc", "atiocol", "iuoci", "iniocol", "aiog", "aoc", "tioc", "yiuc", "atioci", "iniocl", "aocl", "siow", "siog", "ialloc", "iroc", " iog", "diocol", "atialloc", "atiocl", "tioci", "ioci", "iow", "tialloc", "siroc", "iuocl", "yioc", "iocation", "lioc", "yiocation", "yiocol", "inioc", " iocl", "aioc", "inioo", "atioo", "diocation", "atioc", "dioc", "iuocation", "iog", "liocation", " ialloc", "iuoc", "atiocation", "lioci", "aoo", "ioo", "aocol", "iuc", " ioci", " iow", "iocl", "sioc", "airoc", "diuc", " iroc", "tiocl", "aiow"], "buf": ["func", "port", "vec", "proc", "context", "ff", "uc", "bc", "queue", "fd", "cv", "pkg", "rc", "config", "batch", "ru", "bb", "fb", "home", "uf", "lc", "req", "auc", "conv", "null", "uu", "pool", "buffer", "cmp", "fp", "bag", "loc", "br", "buff", "output", "begin", "av", "feat", "la", "rb", "fi", "fab", "b", "Buffer", "wb", "bf", "ptr", "ab", "bh", "c", "bu", "block", "cat", "font", "cb", "cap", "text", "cas", "cmd", "cf", "comb", "aux", "coll", "src", "seq", "usr", "ctx", "alloc"]}}
{"project": "qemu", "commit_id": "1606e4cf8a976513ecac70ad6642a7ec45744cf5", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780, "substitutes": {"blk": ["plb", "belb", "clku", "brok", "belks", "belkt", "clke", "belke", "Blk", "plkt", "blke", " blb", "flsk", "flck", " blke", "plk", "belck", "brsk", "blsk", "plke", " blks", "plks", "flke", "blok", "clkt", "elsk", "belk", "blck", "plck", "brk", "clk", "blku", "Blke", "blkt", "elkt", "elck", "plok", "brks", " blkt", "brkt", " blsk", "elok", " blok", "belok", "brke", " blck", "Blks", "Blck", "blb", "elke", "brck", "plsk", "flk", "blks", "brku", "elk", "belku"]}}
{"project": "qemu", "commit_id": "bb16172c52ac18742f3df156912c169904e92147", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785, "substitutes": {"port": ["path", "nat", "proc", "config", "Port", "pt", "name", "ref", "method", "pid", "server", "v", "value", "loc", "PORT", "p", "socket", "count", "length", "point", "ort", "address", "ip", "proxy", "route", "end", "type", "ports", "file", "host", "cp", "db", "pos"], "sockaddr": [" sipaddr", "dsockptr", "sipdriver", "sOCKaddr", "statesocketptr", "sinklayer", "Sockadr", "Socksadr", "sworkadr", "sigwork", "sworkaddress", "sighost", "sipaddress", "sockhost", "synptr", "songaddress", "ingsockhost", "synhost", "sockshost", "insvcaddr", "ingsockdriver", "sinkhost", "sworkaddr", "sigaddress", "songaddr", "statesockhost", "insigaddr", "swinlayer", "sinkopt", "insockaddress", "insockattr", "songattr", "sinkwork", "socketaddr", "sockdriver", "sigptr", "sigadr", "sigaddr", "ingsockethost", "sinkserver", "sigoa", "Sockswork", "socksadr", "sOCKoa", "sworkopt", "sockoa", "sockswork", "sinkadr", "sockethost", "dsipaddress", "svclayer", "sOCKaddress", "svcattr", "ingsockaddr", "dsipattr", "statesockserver", "Sockaddr", "sipaddr", "dsockaddress", "socketdriver", "sOCKadr", "ingsocketaddress", "socketptr", "insockadr", "statesockaddr", "socketaddress", "dsipptr", " sipadr", "statesockptr", "Sockhost", "siphost", "songptr", " sockoa", "svcaddr", " sockadr", "insigaddress", "socksaddress", "sigattr", "ingsocketdriver", "socksaddr", "statesockethost", "insigopt", "Sockwork", "synserver", "sinkptr", "Sockshost", "insvcopt", "swinopt", "insvcattr", "socksdriver", "sipattr", "insvclayer", "sinkattr", "insocklayer", "sockopt", "statesocketserver", "insigadr", "insockopt", "synaddr", "swinattr", "sipadr", "swinaddr", "sockadr", "sockaddress", "statesocketaddr", "svcopt", "dsipaddr", "ingsocketaddr", "socklayer", "socketserver", "Socksaddr", "sockserver", "sockattr", "dsockattr", "dsockaddr", "sigopt", "sipptr", " sockaddress", "ingsockaddress", "insockaddr", "sockptr", "sockwork", "sipoa", " sipoa", "sinkaddr", " sipaddress", "sipopt"], "fd": ["func", "ff", "d", "fl", "fs", "l", "fb", "da", "bd", "def", "td", " fid", "fun", "fx", "dl", "nd", "fat", "fp", "ld", "dir", "fn", "frame", "ct", "v", "conn", "pd", "dy", "cd", "ad", "ind", "pipe", "fi", "handler", "fin", "socket", "buf", "fed", "sf", "sd", "bf", "f", "lf", "xd", "dat", "fe", "c", "df", "feed", "dc", "dt", "cb", "file", "eth", "md", "cf", "sl", "ds", "dd", "db", "hd", "exec", "dn", "vd", "fen", "wd", "fc", "ln", "FD", "red"], "val": ["pet", "alt", "slot", "fl", "pt", "cond", "VAL", "eval", "test", "x", "ref", "pret", "arg", "unit", "lit", "pid", "valid", "v", "value", "loc", "grad", "ind", "sec", "rx", "buf", "base", "byte", "serv", "timeout", "ol", "sl", "rt", "fail", "resp", "Val", "rot", "RET", "al", "sel", "rel", "res", "el", "addr", "lv", "len", "opt", "reg", "vals", "bit", "index"], "ret": ["pet", "alt", "ft", "part", "art", "pt", "rets", "fun", "eval", "py", "ref", "arg", "hash", "det", "lit", "valid", "v", "flag", "pass", "obj", "ben", "mt", "fin", "rb", "rx", "success", "Ret", "j", "count", "bf", "result", "ann", "att", "rl", "arr", "cb", "eth", "nt", "re", "rt", "resp", "r", "db", "RET", "al", "res", "reg", "sel", "num", "el", "len", "del", "bit"]}}
{"project": "qemu", "commit_id": "280503ee9d7833a793770d732dda5358659825e9", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786, "substitutes": {"klass": ["Klasses", "klasses", " kclass", "kclass", "sklf", "skclass", " klf", " kcl", "kcl", " klasses", "skcl", "Klf", "sklasses", "Kclass", "Klass", "sklass", "Kcl", "klf"], "data": ["device", "context", "m", "input", "d", "config", " d", "i", "da", "def", "di", "o", "info", "reader", "f", "result", "parent", "dat", "df", "Data", "DATA", "ds", "dd", "db"], "dc": ["dk", "mc", "bc", "d", "tk", "director", "cc", "config", "enter", "rc", "cdn", "da", "DC", "gc", "lc", "di", "acc", "cd", "doc", "desc", "nc", "tc", "driver", "f", "dat", "c", "cca", "df", "design", "dt", "ac", "sc", "cf", "disc", "coll", "ds", "dd", "ga", "db", "center", "ec", "fc", "deck"], "k": ["ke", "dk", "kind", "wk", "self", "ijk", "ak", "d", "t", "tk", "cc", "kr", "ko", "kn", "kick", "ki", "g", "uk", "sk", "kk", "key", "kw", "o", "ka", "ad", "u", "p", "e", "ok", "ku", "kt", "ck", "n", "f", "mk", "c", "K", "q", "kin", "ik", "work", "kid", "ks"]}}
{"project": "qemu", "commit_id": "aedbe19297907143f17b733a7ff0e0534377bed1", "target": 1, "func": "static void cpu_handle_ioreq(void *opaque)\n\n{\n\n    XenIOState *state = opaque;\n\n    ioreq_t *req = cpu_get_ioreq(state);\n\n\n\n    handle_buffered_iopage(state);\n\n    if (req) {\n\n        ioreq_t copy = *req;\n\n\n\n        xen_rmb();\n\n        handle_ioreq(state, &copy);\n\n        req->data = copy.data;\n\n\n\n        if (req->state != STATE_IOREQ_INPROCESS) {\n\n            fprintf(stderr, \"Badness in I/O request ... not in service?!: \"\n\n                    \"%x, ptr: %x, port: %\"PRIx64\", \"\n\n                    \"data: %\"PRIx64\", count: %u, size: %u, type: %u\\n\",\n\n                    req->state, req->data_is_ptr, req->addr,\n\n                    req->data, req->count, req->size, req->type);\n\n            destroy_hvm_domain(false);\n\n            return;\n\n        }\n\n\n\n        xen_wmb(); /* Update ioreq contents /then/ update state. */\n\n\n\n        /*\n\n         * We do this before we send the response so that the tools\n\n         * have the opportunity to pick up on the reset before the\n\n         * guest resumes and does a hlt with interrupts disabled which\n\n         * causes Xen to powerdown the domain.\n\n         */\n\n        if (runstate_is_running()) {\n\n            if (qemu_shutdown_requested_get()) {\n\n                destroy_hvm_domain(false);\n\n            }\n\n            if (qemu_reset_requested_get()) {\n\n                qemu_system_reset(VMRESET_REPORT);\n\n                destroy_hvm_domain(true);\n\n            }\n\n        }\n\n\n\n        req->state = STATE_IORESP_READY;\n\n        xenevtchn_notify(state->xce_handle,\n\n                         state->ioreq_local_port[state->send_vcpu]);\n\n    }\n\n}\n", "idx": 12787, "substitutes": {"opaque": ["ompaque", "opusaques", "ompque", "oaques", "popaques", "oaque", "opusque", "oaco", "opaco", "opaques", "cataque", "OPaques", "popque", "opacity", "OPacity", "catacity", "OPque", "cataques", "opque", "ompaques", "OPaque", "opusaco", "opusaque", "oque", "ompacity", "popaque", "catque", "popaco"], "state": ["area", "port", "art", "msg", "use", "status", "str", "ace", "loc", "media", "trigger", "driver", "count", "stat", "grade", "is", "offset", "states", "are", "tag", "work", "index", "message", "sy", "head", "action", "call", "self", "part", "slice", "kill", "id", "seed", "g", "manager", "session", "error", "key", "parse", "version", "instance", "resource", "socket", "powered", "data", "length", "cache", "reg", "addr", "core", "ptr", "ch", "config", "private", "un", "style", "source", "State", "update", "scope", "pid", "o", "role", "stage", "e", "info", "j", "address", "STATE", "type", "power", "pos", "cur", "handle", "node", "err", "code", "range", "name", "er", "this", "estate", "patch", "job", "request", "set", "size", "p", "se", "ate", "mode", "store", "parent", "rule", "scale", "q", "start"], "req": ["sem", "proc", "art", "child", "cmp", "rec", "requ", "stat", "flow", "spec", "ry", "cb", "pro", "cp", "fail", "pri", "copy", "call", "dq", "id", "ctr", "progress", "key", "error", "client", "grad", "loader", "resource", "require", "data", "r", "exec", "repl", "cache", "reg", "rel", "rf", "core", "ptr", "release", "transfer", "rr", "queue", "config", "task", "ref", "State", "conn", "download", "grab", "ir", "info", "desc", "rx", "comp", "http", "diff", "type", "ro", "load", "rt", "quire", "hop", "prefix", "cur", "push", "ctx", "err", "qa", "worker", "orig", "required", "name", "er", "mod", "sq", "patch", "conf", "request", "access", "op", "read", "parent", "next", "pull", "q", "cmd", "write", "org", "resp", "seq"]}}
{"project": "qemu", "commit_id": "846424350b292f16b732b573273a5c1f195cd7a3", "target": 1, "func": "static bool scsi_target_emulate_inquiry(SCSITargetReq *r)\n\n{\n\n    assert(r->req.dev->lun != r->req.lun);\n\n    if (r->req.cmd.buf[1] & 0x2) {\n\n        /* Command support data - optional, not implemented */\n\n        return false;\n\n    }\n\n\n\n    if (r->req.cmd.buf[1] & 0x1) {\n\n        /* Vital product data */\n\n        uint8_t page_code = r->req.cmd.buf[2];\n\n        r->buf[r->len++] = page_code ; /* this page */\n\n        r->buf[r->len++] = 0x00;\n\n\n\n        switch (page_code) {\n\n        case 0x00: /* Supported page codes, mandatory */\n\n        {\n\n            int pages;\n\n            pages = r->len++;\n\n            r->buf[r->len++] = 0x00; /* list of supported pages (this page) */\n\n            r->buf[pages] = r->len - pages - 1; /* number of pages */\n\n            break;\n\n        }\n\n        default:\n\n            return false;\n\n        }\n\n        /* done with EVPD */\n\n        assert(r->len < sizeof(r->buf));\n\n        r->len = MIN(r->req.cmd.xfer, r->len);\n\n        return true;\n\n    }\n\n\n\n    /* Standard INQUIRY data */\n\n    if (r->req.cmd.buf[2] != 0) {\n\n        return false;\n\n    }\n\n\n\n    /* PAGE CODE == 0 */\n\n    r->len = MIN(r->req.cmd.xfer, 36);\n\n    memset(r->buf, 0, r->len);\n\n    if (r->req.lun != 0) {\n\n        r->buf[0] = TYPE_NO_LUN;\n\n    } else {\n\n        r->buf[0] = TYPE_NOT_PRESENT | TYPE_INACTIVE;\n\n        r->buf[2] = 5; /* Version */\n\n        r->buf[3] = 2 | 0x10; /* HiSup, response data format */\n\n        r->buf[4] = r->len - 5; /* Additional Length = (Len - 1) - 4 */\n\n        r->buf[7] = 0x10 | (r->req.bus->info->tcq ? 0x02 : 0); /* Sync, TCQ.  */\n\n        memcpy(&r->buf[8], \"QEMU    \", 8);\n\n        memcpy(&r->buf[16], \"QEMU TARGET     \", 16);\n\n        pstrcpy((char *) &r->buf[32], 4, qemu_get_version());\n\n    }\n\n    return true;\n\n}\n", "idx": 12789, "substitutes": {"r": ["rr", "m", "self", "ru", "R", "d", "hr", "t", "tr", "rc", "gr", "l", "i", "rs", "or", "kr", "range", "rar", "ra", "er", "g", "req", "h", "rg", "this", "sr", "str", "x", "br", "fr", "rh", "cr", "request", "o", "u", "mr", "rec", "p", "e", "ir", "rb", "s", "lr", "rx", "k", "b", "rw", "result", "f", "c", "arr", "ur", "re", "rt", "pr", "nr", "ar", "dr", "res", "usr", "cur", "run", "rf", "wr", "err"], "pages": ["codes", "types", "users", "cats", "planes", "blocks", "posts", "cycles", "packages", "qa", "workers", "ins", "docs", "fields", "sites", "classes", "bytes", "seconds", "words", "points", "devices", "total", "rows", "pid", " page", "files", "items", "limit", "Pages", "views", "groups", "breaks", "s", "packs", "images", "plugins", "members", "page", "books", "sections", "apps", "length", "lines", "count", "heads", "frames", "n", "features", "days", "c", "cells", "ages", "per", "objects", "links", "events", "ips", "steps", "num", "comments", "ks"]}}
{"project": "qemu", "commit_id": "de82815db1c89da058b7fb941dab137d6d9ab738", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799, "substitutes": {"bs": ["ses", "blocks", "bis", "bc", "sync", "BS", "fs", "iss", "ob", "bb", "oss", "fb", "lbs", "cs", "qs", "fps", "os", "es", "js", "ros", "ps", "ss", "obs", "plugins", "pb", "http", "b", "sb", "bing", "gs", "gb", "bits", "bh", "state", "ns", "ab", "is", "outs", "bes", "bas", "ds", "bi", "db", "sa", "src", "ec", "ls", "css", "lb", "bos", "us", "las", "bl", "vs", "ubs", "abi", "ks", "aws"], "s": ["sys", "ses", "rss", "self", "parts", "service", "sync", "fs", "sg", "t", "ins", "rs", "sym", "l", "g", "cs", "qs", "S", "settings", "sites", "os", "its", "sets", "js", "si", "uns", "sq", "session", "server", "storage", "ss", "ps", "o", "p", "e", "obs", "site", "b", "sb", "f", "gs", "state", "spec", "c", "ns", "xs", "is", "stats", "sc", "ssl", "sv", "sl", "states", "services", "ds", "r", "ops", "sa", "src", "su", "ls", "ts", "us", "iss", "ks", "aws"], "l1_table": ["lOne_table", "l167table", "l1_cache", "l11_module", "lOne_body", "l11_entry", "l1_private", "lOne_binary", "l11pentry", "lOne_shape", "l3_cache", "l1_course", "l3_db", "lartJprivate", "lart_table", "l3_TABLE", "l1pslice", "l11_table", "l1__private", "l11_key", "l1_slice", "lartJcolumn", "l1_key", "l1stable", "l11ptable", "l2_cache", "l3_table", "l1stree", "l2_table", "l1__column", "l2_db", "l1_time", "l11_tree", "l1_shape", "l1_session", "l11pslice", "lart_column", "l1Jprivate", "l11psession", "l1_body", "l167binary", "l1_binary", "l1_file", "l1Jtable", "l11_session", "l1Jcolumn", "l1_entry", "lartJtable", "l167shape", "l11_slice", "l1__table", "lart_file", "l1smodule", "lart_private", "lartJfile", "l1_tree", "l167body", "l1psession", "l1_TABLE", "l1skey", "l1__file", "l1ptable", "l1_db", "l1pentry", "l1_module", "l1_column", "l1_size", "l1Jfile", "l2_size"], "nb_clusters": ["nb_splapses", "nb_clunks", "nb_CLuster", "nb67declords", "nb_slusters", "nb_decluster", "nb\u00b7llodes", "nb_Clords", "nb_scusters", "nb_Clones", "nb_slunks", "nb_scodes", "nb67clusters", "nb_colodes", "nb_coluster", "nb_llappers", "nb67clapses", "nb_scashes", "nb_clones", "nb_llones", "nb_bcunks", "nb_colluster", "nb67declapses", "nb\u00b7clones", "nb_slroups", "nb_bcairs", "nb_clodes", "nb67declusters", "nb_CLappers", "nb\u00b7llones", "nb_bcroups", "nb_llusters", "nb_splusters", "nb_collusters", "nb_llodes", "nb_declusters", "nb_sluster", "nb_spluster", "nb_clappers", "nb_Clapses", "nb_flunks", "nb_scones", "nb67decluster", "nb_clapses", "nb_Clodes", "nb_clashes", "nb_slapses", "nb_Clashes", "nb\u00b7llashes", "nb\u00b7clashes", "nb_collards", "nb_lluster", "nb\u00b7clusters", "nb_slairs", "nb_Cluster", "nb67cluster", "nb_clords", "nb_CLards", "nb_declapses", "nb_clairs", "nb_cluster", "nb_llashes", "nb_bcusters", "nb67clords", "nb_flairs", "nb_collappers", "nb_flroups", "nb\u00b7clodes", "nb_colusters", "nb_llards", "nb_slodes", "nb_declords", "nb_CLusters", "nb_clroups", "nb_flusters", "nb_colapses", "nb\u00b7llusters", "nb_clards", "nb_Clusters", "nb_splords"], "expanded_clusters": ["expandedsslusters", "expandedsslayers", "expanded_chosures", "expanded_chusters", "expanded_cluster", "expanded_lions", "expanded2clusters", "expanded_Clores", "expanded_slures", "expand\n", "expandedsclures", "expanded_slayers", "expanded_buster", "expanded_blusters", "escanded\n", "expanded_sclusters", "expanded_scliffs", "expanded_chresses", "expanded_collusters", "escanding\n", "expandedssliffs", "expanded_clions", "expanded_Cluster", "expanded2sclust", "expanded_bust", "expanded_slresses", "expanded_biffs", "expanding\n", "expanded_scluster", "expanded_lresses", "expandedscliffs", "expanded_blores", "expanded2scluster", "expanded2cluster", "expanded_chuster", "expanded_chores", "expandedsclusters", "expanded_sclures", "expanded_chodes", "expanded_sclust", "expanded_clresses", "expanded2sclusters", "expanded_closures", "expanded2cliffs", "expanded_Clodes", "expanded_clust", "expanded_Clust", "expanded2clust", "expanded_slusters", "expanded_Cliffs", "expanded_busters", "expandedsclayers", "expanded_sliffs", "expanded_clores", "expanded\n", "expanded_slosures", "expanded_bluster", "expanded_chions", "expanded_sclayers", "expanded_Clusters", "expanded_lusters", "expanded2scliffs", "expanded_collures", "expanded_cliffs", "expanded_colliffs", "expanded_clures", "expandedsslures", "expanded_clodes", "expanded_blodes", "expanded_clayers", "expanded_collayers", "expanded_slions", "expended\n", "expanded_losures"], "ret": ["true", "alt", "ft", "let", "rev", "en", "part", "reply", "art", "rc", "val", "pt", "def", "rets", "g", "gt", "fun", "ref", "det", "arg", "hash", "lit", "ct", "error", "job", "feat", "obj", "group", "ut", "mt", "pass", "mem", "grad", "rb", "info", "lt", "success", "match", "Ret", "bf", "result", "fit", "att", "rl", "url", "cat", " Ret", "nt", "re", "out", "rt", "resp", "db", "RET", "res", "reg", "usr", "flag", "len", "opt", "bit", "err"], "i": ["qi", "ui", "m", "part", "I", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "iv", "io", "ci", "ki", "x", "di", "si", "ie", "init", "ii", "v", "uri", "yi", "u", "ind", "jit", "p", "e", "fi", "info", "mi", "li", "b", "ix", "multi", "n", "phi", "ti", "ip", "c", "eni", "ij", "inner", "pi", "q", "r", "bi", "ik", "ri", "y", "in", "index"], "j": ["jj", "adj", "jen", "uj", "it", "m", "aj", "kj", "d", "t", "ni", "ja", "jp", "l", "oj", "g", "dj", "h", "x", "other", "jet", "js", "ii", "key", "v", "job", "br", "jam", "o", "z", "u", "jit", "p", "e", "not", "k", "li", "b", "n", "f", "jo", "c", "jl", "jc", "ji", "q", "out", "r", "J", "pr", "el", "y", "ij"]}}
{"project": "qemu", "commit_id": "12848bfc5d719bad536c5448205a3226be1fda47", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805, "substitutes": {"fs_ctx": ["fs__ctx", "fsdefctx", "fs_lc", "FS_conn", "fs6context", "fskbc", "fs6cos", "fs6bc", "fsprebc", "fs_loc", "fitsdefcrit", "fs7loc", "vs_ctrl", "fs6ctx", "feed_cos", "fs_cu", "ns_ctx", "fs_gb", "fsprectx", "fitsdefcca", "fsprectrl", "fskcu", "feed_ctx", "fsdefcos", "FS_context", "fs6gb", "fitsdefloc", "fs_cca", "ns_context", "fs7ctx", "fs_context", "fsdefloc", "fitsdefctx", "ns_loc", "vs_context", "fs__cu", "fs6ctrl", "fs7cca", "FS_cu", "fits_cca", "fsdefgb", "fskcontext", "fs_conn", "fs__bc", "fskctx", "feeddefgb", "fs_cos", "fs_cmp", "fsdefcca", "fs_tx", "fsprecontext", "fs_cas", "FS_cas", "fs__context", "FS_cmp", "ns_ci", "FS_cm", "feeddeflc", "vs_ctx", "FS_bc", "fs6lc", "fits_crit", "fsdefcrit", "fs_ci", "feed_lc", "fits_ctx", "FS_tx", "fs7crit", "fs_cm", "fs_ctrl", "FS_ctx", "feed_gb", "fits_loc", "fs_crit", "feeddefctx", "feeddefcos", "vs_bc", "fs_bc", "fsdeflc"], "path": ["context", "root", "location", "part", "ath", "sync", "enc", "config", "id", "mount", "child", "name", "image", "user", "ref", "txt", "str", "method", "full", "dir", "key", "uri", "patch", "loc", "col", "loader", "version", "p", "resource", "pointer", "mode", "Path", "parent", "PATH", "url", "route", "c", "inner", "type", "anc", "ion", "text", "transform", "file", "host", "cache", "pattern", "content", "prefix", "prop", "alias", "ctx", "filename", "node"], "flags": ["types", "args", "parts", "FLAG", "fd", "fl", "fs", "locks", "prot", "cs", "fps", "settings", "bytes", "status", "opens", "linux", "files", "items", "reads", "s", "options", "alls", "faces", "af", "features", "lines", "mask", "lag", "f", "lf", "bits", "missions", "feed", "ats", "Flags", "xff", "stats", "ops", "links", "ds", "fee", "ips", "ils", "flag", "len", "vals"], "credp": [" cribP", " crsm", "lcribpa", "crede", "credc", "crsm", "credita", "crdP", " crspc", "decwdph", "corsc", " creeda", "crdpc", "cronm", "crdp", "lcredpa", "creedpa", "cwdu", "creds", "credpa", "cribs", "cronpc", " creedpa", "cachedpa", "cribpa", "cronc", "lcredc", "creede", "lcredpe", "crsp", " creedp", "cachedp", "crecp", "lcribpe", "crsc", "cwdp", "crecu", "cribpe", "crdc", "crds", "cdefpc", "crecpc", " cribc", "cribp", " credpc", "creedp", " credpa", "decredu", " cribp", "cldP", "creda", "credite", "decredp", "corsp", "cronp", "creditp", "credpc", " cdefc", "cwdpc", "credm", "cdefpe", " creede", "corspa", "lcribp", " credc", "decredpc", "lcribc", "crda", "cramu", "cachedpc", "cdefp", " crede", "decwdp", " creda", "creeda", "credpe", "lcredp", "corspe", " crsp", "credph", " credm", " crsc", "cachedc", "cramph", "credP", "cldc", "credu", "clds", " cdefpa", "crampc", "decwdpc", "decwdu", "cramp", "crecph", "crde", "cwdph", "decredph", "cdefpa", "cribc", " cdefp", " cdefpc", " credP", "crdm", "crspc", "crdpa", "cldp", "cribP", "cdefc", "creditpa", " cribs", " creds"]}}
{"project": "FFmpeg", "commit_id": "221b804f3491638ecf2eec1302c669ad2d9ec799", "target": 1, "func": "static inline void yuv2packedXinC(SwsContext *c, int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n\t\t\t\t    int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n\t\t\t\t    uint8_t *dest, int dstW, int y)\n\n{\n\n\tint i;\n\n\tswitch(c->dstFormat)\n\n\t{\n\n\tcase PIX_FMT_BGR32:\n\n\tcase PIX_FMT_RGB32:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint32_t)\n\n\t\t\t((uint32_t*)dest)[i2+0]= r[Y1] + g[Y1] + b[Y1];\n\n\t\t\t((uint32_t*)dest)[i2+1]= r[Y2] + g[Y2] + b[Y2];\n\n\t\t}\n\n\t\tbreak;\n\n\tcase PIX_FMT_RGB24:\n\n\t\tYSCALE_YUV_2_RGBX_C(uint8_t)\n\n\t\t\t((uint8_t*)dest)[0]= r[Y1];\n\n\t\t\t((uint8_t*)dest)[1]= g[Y1];\n\n\t\t\t((uint8_t*)dest)[2]= b[Y1];\n\n\t\t\t((uint8_t*)dest)[3]= r[Y2];\n\n\t\t\t((uint8_t*)dest)[4]= g[Y2];\n\n\t\t\t((uint8_t*)dest)[5]= b[Y2];\n\n\t\t\tdest+=6;\n\n\t\t}\n", "idx": 12809, "substitutes": {"c": ["m", "ch", "mc", "cm", "uc", "cam", "d", "cv", "enc", "ca", "t", "cc", "pc", "l", "C", "lc", "ci", "cs", "cit", "cy", "con", "ct", "cr", "cd", "u", "p", "e", "k", "tc", "b", "dc", "cu", "ac", "ce", "cf", "icc", "cp", "vc", "ec", "cpp"], "lumFilter": [" lrumFilter", " lrumfilter", "lumbListener", " lrumF", "lrumListener", "lumbfilter", "lumiListener", "lrumFilter", "lumbFilter", " lumfilter", "lumiF", "lumF", " lrumListener", " lumF", "lumListener", "lrumF", "lrumfilter", "lumfilter", " lumListener", "lumbF", "lumiFilter", "lumifilter"], "lumSrc": ["lumbAsrc", "lumOsource", "lumbAsuc", "lumAsrc", "lumAsRC", "lumOsRC", "lumOsuc", "lumbAsRC", "lumbSRC", "lumSRC", "lumbAsource", "lumAsource", "lumSource", "lumSuc", "lumbSrc", "lumbSuc", "lumAsuc", "lumbSource", "lumOsrc"], "lumFilterSize": ["lumFiltersize", "lumBufferC", "lumsFilterC", "lumFilterC", "lumBuffersize", "lumFsize", "lumBufferSize", "lumFC", "lumsFiltersize", "lumFSize", "lumsFilterSize"], "chrFilter": ["chmfilter", "chrumFormat", "chrfilter", "echrFil", "echrbfilter", "chmFormat", "chrbFormat", "chrbfilter", "chrbFilter", "echrFilter", "chmFilter", "echrbFil", "echrbFormat", "chrumFil", "chrFil", "chmFil", "chrumfilter", "chrumFilter", "chrbFil", "echrfilter", "echrbFilter", "echrFormat", "chrFormat"], "chrSrc": ["chrAsrc", "chrSubrc", "chrfSource", "chrfSRC", "chrSubource", "chrAsources", "chrSubources", "chrfSources", "chrAsRC", "chrSRC", "chrAsource", "chrfSrc", "chrSource", "chrSources", "chrSubRC"], "chrFilterSize": ["chreFilterSIZE", "chrfilterLen", "chreFilterSize", "chrFilterLen", "chrControlLen", "chreControlSIZE", "chrFiltersize", "chreFiltersize", "chrFilterSIZE", "chrfilterSize", "chrControlSize", "chrFilesize", "chrfilterSIZE", "chrFileSIZE", "chrfiltersize", "chrControlsize", "chreControlsize", "chrFileLen", "chrControlSIZE", "chreFilterLen", "chreControlLen", "chreControlSize", "chrFileSize"], "dest": ["dist", "shape", "flat", "loc", "end", "transform", "iter", "walk", "Dest", "class", "prop", "destroy", "num", "dim", "comb", "south", "ward", "draw", "done", " Dest", "d", "home", "sup", "txt", "sum", "img", "du", "data", "wb", "origin", "result", "route", "gen", "cont", "uv", "wd", "path", "transfer", "sort", "config", "source", "test", "desc", "includes", "usr", "replace", "err", "ord", "wh", "uc", " destination", "shift", "orig", "ident", "this", "feat", "sign", "move", "match", "mode", "trans", "store", "dc", "esc", "target", "src", "rest", "coord", "gest", "opt"], "dstW": [" dstH", " dSTW", " dSTw", " dSTVW", "dstH", "dostVW", "dSTH", "dostH", "dSTW", " dstw", "dSTw", "ddestH", "ddestW", "dostw", "ddestw", "dstVW", "ddestVW", " dstVW", " dSTH", "dostW", "dstw", "dSTVW"], "y": ["ny", "ch", "d", "ys", "t", "iy", "ey", "h", "py", "x", "w", "yi", "dy", "z", "p", "e", "b", "ay", "oy", "vy", "type", "Y", "yy", "ty"], "i": ["ui", "I", "d", "t", "l", "iu", "code", "ci", "h", "ii", "v", "w", "p", "e", "k", "li", "b", "j", "count", "n", "f", "end", "type", "pi", "start"]}}
{"project": "FFmpeg", "commit_id": "2fc9a3eb7a8c606bd403dc9fbdb8463144b243cf", "target": 1, "func": "static int write_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, did_split;\n    if (s->output_ts_offset) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = av_rescale_q(s->output_ts_offset, AV_TIME_BASE_Q, st->time_base);\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n    }\n    if (s->avoid_negative_ts > 0) {\n        AVStream *st = s->streams[pkt->stream_index];\n        int64_t offset = st->mux_ts_offset;\n        int64_t ts = s->internal->avoid_negative_ts_use_pts ? pkt->pts : pkt->dts;\n        if (s->internal->offset == AV_NOPTS_VALUE && ts != AV_NOPTS_VALUE &&\n            (ts < 0 || s->avoid_negative_ts == AVFMT_AVOID_NEG_TS_MAKE_ZERO)) {\n            s->internal->offset = -ts;\n            s->internal->offset_timebase = st->time_base;\n        }\n        if (s->internal->offset != AV_NOPTS_VALUE && !offset) {\n            offset = st->mux_ts_offset =\n                av_rescale_q_rnd(s->internal->offset,\n                                 s->internal->offset_timebase,\n                                 st->time_base,\n                                 AV_ROUND_UP);\n        }\n        if (pkt->dts != AV_NOPTS_VALUE)\n            pkt->dts += offset;\n        if (pkt->pts != AV_NOPTS_VALUE)\n            pkt->pts += offset;\n        if (s->internal->avoid_negative_ts_use_pts) {\n            if (pkt->pts != AV_NOPTS_VALUE && pkt->pts < 0) {\n                av_log(s, AV_LOG_WARNING, \"failed to avoid negative \"\n                    \"pts %s in stream %d.\\n\"\n                    \"Try -avoid_negative_ts 1 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        } else {\n            av_assert2(pkt->dts == AV_NOPTS_VALUE || pkt->dts >= 0 || s->max_interleave_delta > 0);\n            if (pkt->dts != AV_NOPTS_VALUE && pkt->dts < 0) {\n                av_log(s, AV_LOG_WARNING,\n                    \"Packets poorly interleaved, failed to avoid negative \"\n                    \"timestamp %s in stream %d.\\n\"\n                    \"Try -max_interleave_delta 0 as a possible workaround.\\n\",\n                    av_ts2str(pkt->dts),\n                    pkt->stream_index\n                );\n            }\n        }\n    }\n    did_split = av_packet_split_side_data(pkt);\n    if (!s->internal->header_written) {\n        ret = s->internal->write_header_ret ? s->internal->write_header_ret : write_header_internal(s);\n        if (ret < 0)\n            goto fail;\n    }\n    if ((pkt->flags & AV_PKT_FLAG_UNCODED_FRAME)) {\n        AVFrame *frame = (AVFrame *)pkt->data;\n        av_assert0(pkt->size == UNCODED_FRAME_PACKET_SIZE);\n        ret = s->oformat->write_uncoded_frame(s, pkt->stream_index, &frame, 0);\n        av_frame_free(&frame);\n    } else {\n        ret = s->oformat->write_packet(s, pkt);\n    }\n    if (s->pb && ret >= 0) {\n        if (s->flush_packets && s->flags & AVFMT_FLAG_FLUSH_PACKETS)\n            avio_flush(s->pb);\n        if (s->pb->error < 0)\n            ret = s->pb->error;\n    }\nfail:\n    if (did_split)\n        av_packet_merge_side_data(pkt);\n    if (ret < 0) {\n        pkt->pts = pts_backup;\n        pkt->dts = dts_backup;\n    }\n    return ret;\n}", "idx": 12810, "substitutes": {"s": ["i", "rs", "qs", "h", "js", "si", "server", "ps", "params", "spec", "c", "single", "is", "sc", "sv", "sl", "aws", "args", "south", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "g", "cs", "txt", "es", "session", "storage", "client", "u", "sf", "b", "ns", "ops", "r", "sa", "support", "ks", "sys", "service", "your", "hs", "os", "sets", "o", "e", "sec", "site", "sb", "f", "less", "ans", "services", "ls", "ses", "l", "S", "its", "sq", "v", "conf", "ss", "set", "request", "p", "se", "n", "gs", "xs", "ssl", "ds", "su", "ts", "us", "vs", "sts"], "pkt": ["spkt", "pet", "pct", "facket", "pskg", "spcht", "cpkg", "pswk", " pct", "fet", "ipcht", "Pct", "apet", "spacket", "spelt", "pwk", "feter", "tpck", "ppacket", "helt", "opcht", "cpct", "pskt", "ipft", "Pet", "wpet", "pset", "pcht", "wpelt", "opet", "opkg", "peter", "ppeter", "opwk", "ppnt", "pck", "cpwk", "cpet", "fkt", "apnt", "Pkt", "ppet", "ppwk", "Pcht", " pkg", "hnt", "fct", "ipwk", "macket", "mkt", "fwk", "spnt", "hkt", " pet", "apacket", "opkt", " pnt", " pwk", "wpkt", "mct", "ppdt", "tpnt", "ptp", "Ptp", "psct", "Pnt", "packet", "ppkt", " ptp", "apkt", "wpacket", "Pft", "ipnt", "pert", "pscht", "apck", "opct", "ipct", "Pck", "pnt", "tpacket", "psert", "ipkt", "apelt", "pelt", "apkg", "Peter", "pkg", "Packet", "cpnt", "pft", "cpkt", "ipelt", "tpelt", "tpkt", "pdt", "Pelt", "cpert", "spkg", "Pert", "Pkg", "psacket", "hacket", " pert", " pelt", " pcht", "opacket", "spdt", "ipacket", "Pdt", "wpft", "mtp", " packet"], "ret": ["alt", "id", "val", " resp", " alt", " rc", " sa", " reply", " rs", "mt", "sec", " temp", "Ret", " RET", "TS", " status", " fut", " result", "nt", " res", " success", " error", "RET", "seq", "num", "len", "ets"], "did_split": ["ip__sync", "ip_send", "did_sec", "did__split", "ip__split", "did_send", "ip_sync", "did__sec", "did__send", "ip_sec", "ip__sec", "ip__send", "ip_split", "did__sync", "did_sync"], "st": ["ess", "sta", "ft", "d", "t", "service", "pt", "td", "sp", "ste", "sk", "std", "sth", "sw", "str", "sr", "stable", "ct", "ld", "fr", "storage", "ss", "client", "cr", "step", "ut", "stage", "stop", "se", "ST", "sb", "sd", "St", "inst", "est", "dt", "sn", "sc", "sl", "stress", "ast", "station", "sh", "sa", "rest", "src", "stack", "ist", "ts", "iss", "post", "cl", "sm", "sts", "ost", "start"]}}
{"project": "FFmpeg", "commit_id": "568e18b15e2ddf494fd8926707d34ca08c8edce5", "target": 1, "func": "static void read_sgi_header(ByteIOContext *f, SGIInfo *info)\n{\n    info->magic = (unsigned short) get_be16(f);\n    info->rle = get_byte(f);\n    info->bytes_per_channel = get_byte(f);\n    info->dimension = (unsigned short)get_be16(f);\n    info->xsize = (unsigned short) get_be16(f);\n    info->ysize = (unsigned short) get_be16(f);\n    info->zsize = (unsigned short) get_be16(f);\n#ifdef DEBUG\n    printf(\"sgi header fields:\\n\");\n    printf(\"  magic: %d\\n\", info->magic);\n    printf(\"    rle: %d\\n\", info->rle);\n    printf(\"    bpc: %d\\n\", info->bytes_per_channel);\n    printf(\"    dim: %d\\n\", info->dimension);\n    printf(\"  xsize: %d\\n\", info->xsize);\n    printf(\"  ysize: %d\\n\", info->ysize);\n    printf(\"  zsize: %d\\n\", info->zsize);\n#endif\n    return;\n}", "idx": 12814, "substitutes": {"f": ["m", "ff", "fd", "t", "fs", "l", "i", "inf", "fb", "fm", "uf", "fore", "fx", "fo", "fp", "fr", "buff", "of", "form", "conf", "F", "u", "p", "e", "fi", "fed", "data", "sf", "af", "b", "bf", "lf", "fe", "c", "feed", "fa", "tf", "xf", "file", "cf", "r", "exec", "rf", "fen", "fc", "fac", "fw"], "info": ["i", "inf", "def", "image", "si", "of", "obj", "base", "information", "end", "is", "tf", "aux", "work", "off", "num", "Info", "index", "hi", "self", "part", "id", "home", "io", "api", "di", "txt", "full", "key", "error", "check", "parse", "fi", "data", "result", "inner", "xml", "config", "extra", "fo", "init", "ie", "update", "app", "help", "options", "note", "http", "comp", "j", "from", "add", "diff", "INFO", "type", "fw", "bug", "it", "ui", "gi", "name", "py", "ii", "conf", "buff", "same", "op", "now", "iso", "hand", "opt", "start"]}}
{"project": "qemu", "commit_id": "e9ebead2b5c70890454e698d9ff174e3020ea861", "target": 1, "func": "static void pc_init1(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename,\n\n                     int pci_enabled, const char *cpu_model)\n\n{\n\n    char buf[1024];\n\n    int ret, linux_boot, i;\n\n    ram_addr_t ram_addr, vga_ram_addr, bios_offset, vga_bios_offset;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size = 0;\n\n    int bios_size, isa_bios_size, vga_bios_size;\n\n    PCIBus *pci_bus;\n\n    int piix3_devfn = -1;\n\n    CPUState *env;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *i8259;\n\n    int index;\n\n    BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BlockDriverState *fd[MAX_FD];\n\n\n\n    if (ram_size >= 0xe0000000 ) {\n\n        above_4g_mem_size = ram_size - 0xe0000000;\n\n        below_4g_mem_size = 0xe0000000;\n\n    } else {\n\n        below_4g_mem_size = ram_size;\n\n    }\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL) {\n\n#ifdef TARGET_X86_64\n\n        cpu_model = \"qemu64\";\n\n#else\n\n        cpu_model = \"qemu32\";\n\n#endif\n\n    }\n\n    \n\n    for(i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find x86 CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (i != 0)\n\n            env->halted = 1;\n\n        if (smp_cpus > 1) {\n\n            /* XXX: enable it in all cases */\n\n            env->cpuid_features |= CPUID_APIC;\n\n        }\n\n        qemu_register_reset(main_cpu_reset, env);\n\n        if (pci_enabled) {\n\n            apic_init(env);\n\n        }\n\n    }\n\n\n\n    vmport_init();\n\n\n\n    /* allocate RAM */\n\n    ram_addr = qemu_ram_alloc(0xa0000);\n\n    cpu_register_physical_memory(0, 0xa0000, ram_addr);\n\n\n\n    /* Allocate, even though we won't register, so we don't break the\n\n     * phys_ram_base + PA assumption. This range includes vga (0xa0000 - 0xc0000),\n\n     * and some bios areas, which will be registered later\n\n     */\n\n    ram_addr = qemu_ram_alloc(0x100000 - 0xa0000);\n\n    ram_addr = qemu_ram_alloc(below_4g_mem_size - 0x100000);\n\n    cpu_register_physical_memory(0x100000,\n\n                 below_4g_mem_size - 0x100000,\n\n                 ram_addr);\n\n\n\n    /* above 4giga memory allocation */\n\n    if (above_4g_mem_size > 0) {\n\n        ram_addr = qemu_ram_alloc(above_4g_mem_size);\n\n        cpu_register_physical_memory(0x100000000ULL,\n\n                                     above_4g_mem_size,\n\n                                     ram_addr);\n\n    }\n\n\n\n\n\n    /* allocate VGA RAM */\n\n    vga_ram_addr = qemu_ram_alloc(vga_ram_size);\n\n\n\n    /* BIOS load */\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, bios_name);\n\n    bios_size = get_image_size(buf);\n\n    if (bios_size <= 0 ||\n\n        (bios_size % 65536) != 0) {\n\n        goto bios_error;\n\n    }\n\n    bios_offset = qemu_ram_alloc(bios_size);\n\n    ret = load_image(buf, phys_ram_base + bios_offset);\n\n    if (ret != bios_size) {\n\n    bios_error:\n\n        fprintf(stderr, \"qemu: could not load PC BIOS '%s'\\n\", buf);\n\n        exit(1);\n\n    }\n\n\n\n    if (cirrus_vga_enabled || std_vga_enabled || vmsvga_enabled) {\n\n        /* VGA BIOS load */\n\n        if (cirrus_vga_enabled) {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_CIRRUS_FILENAME);\n\n        } else {\n\n            snprintf(buf, sizeof(buf), \"%s/%s\", bios_dir, VGABIOS_FILENAME);\n\n        }\n\n        vga_bios_size = get_image_size(buf);\n\n        if (vga_bios_size <= 0 || vga_bios_size > 65536)\n\n            goto vga_bios_error;\n\n        vga_bios_offset = qemu_ram_alloc(65536);\n\n\n\n        ret = load_image(buf, phys_ram_base + vga_bios_offset);\n\n        if (ret != vga_bios_size) {\n\nvga_bios_error:\n\n            fprintf(stderr, \"qemu: could not load VGA BIOS '%s'\\n\", buf);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* setup basic memory access */\n\n    cpu_register_physical_memory(0xc0000, 0x10000,\n\n                                 vga_bios_offset | IO_MEM_ROM);\n\n\n\n    /* map the last 128KB of the BIOS in ISA space */\n\n    isa_bios_size = bios_size;\n\n    if (isa_bios_size > (128 * 1024))\n\n        isa_bios_size = 128 * 1024;\n\n    cpu_register_physical_memory(0x100000 - isa_bios_size,\n\n                                 isa_bios_size,\n\n                                 (bios_offset + bios_size - isa_bios_size) | IO_MEM_ROM);\n\n\n\n    {\n\n        ram_addr_t option_rom_offset;\n\n        int size, offset;\n\n\n\n        offset = 0;\n\n        if (linux_boot) {\n\n            option_rom_offset = qemu_ram_alloc(TARGET_PAGE_SIZE);\n\n            load_linux(phys_ram_base + option_rom_offset,\n\n                       kernel_filename, initrd_filename, kernel_cmdline);\n\n            cpu_register_physical_memory(0xd0000, TARGET_PAGE_SIZE,\n\n                                         option_rom_offset | IO_MEM_ROM);\n\n            offset = TARGET_PAGE_SIZE;\n\n        }\n\n\n\n        for (i = 0; i < nb_option_roms; i++) {\n\n            size = get_image_size(option_rom[i]);\n\n            if (size < 0) {\n\n                fprintf(stderr, \"Could not load option rom '%s'\\n\",\n\n                        option_rom[i]);\n\n                exit(1);\n\n            }\n\n            if (size > (0x10000 - offset))\n\n                goto option_rom_error;\n\n            option_rom_offset = qemu_ram_alloc(size);\n\n            ret = load_image(option_rom[i], phys_ram_base + option_rom_offset);\n\n            if (ret != size) {\n\n            option_rom_error:\n\n                fprintf(stderr, \"Too many option ROMS\\n\");\n\n                exit(1);\n\n            }\n\n            size = (size + 4095) & ~4095;\n\n            cpu_register_physical_memory(0xd0000 + offset,\n\n                                         size, option_rom_offset | IO_MEM_ROM);\n\n            offset += size;\n\n        }\n\n    }\n\n\n\n    /* map all the bios at the top of memory */\n\n    cpu_register_physical_memory((uint32_t)(-bios_size),\n\n                                 bios_size, bios_offset | IO_MEM_ROM);\n\n\n\n    bochs_bios_init();\n\n\n\n    cpu_irq = qemu_allocate_irqs(pic_irq_request, NULL, 1);\n\n    i8259 = i8259_init(cpu_irq[0]);\n\n    ferr_irq = i8259[13];\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, i8259);\n\n        piix3_devfn = piix3_init(pci_bus, -1);\n\n    } else {\n\n        pci_bus = NULL;\n\n    }\n\n\n\n    /* init basic PC hardware */\n\n    register_ioport_write(0x80, 1, 1, ioport80_write, NULL);\n\n\n\n    register_ioport_write(0xf0, 1, 1, ioportF0_write, NULL);\n\n\n\n    if (cirrus_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_cirrus_vga_init(pci_bus,\n\n                                ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        } else {\n\n            isa_cirrus_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                                vga_ram_addr, vga_ram_size);\n\n        }\n\n    } else if (vmsvga_enabled) {\n\n        if (pci_enabled)\n\n            pci_vmsvga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                            vga_ram_addr, vga_ram_size);\n\n        else\n\n            fprintf(stderr, \"%s: vmware_vga: no PCI bus\\n\", __FUNCTION__);\n\n    } else if (std_vga_enabled) {\n\n        if (pci_enabled) {\n\n            pci_vga_init(pci_bus, ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size, 0, 0);\n\n        } else {\n\n            isa_vga_init(ds, phys_ram_base + vga_ram_addr,\n\n                         vga_ram_addr, vga_ram_size);\n\n        }\n\n    }\n\n\n\n    rtc_state = rtc_init(0x70, i8259[8]);\n\n\n\n    qemu_register_boot_set(pc_boot_set, rtc_state);\n\n\n\n    register_ioport_read(0x92, 1, 1, ioport92_read, NULL);\n\n    register_ioport_write(0x92, 1, 1, ioport92_write, NULL);\n\n\n\n    if (pci_enabled) {\n\n        ioapic = ioapic_init();\n\n    }\n\n    pit = pit_init(0x40, i8259[0]);\n\n    pcspk_init(pit);\n\n    if (!no_hpet) {\n\n        hpet_init(i8259);\n\n    }\n\n    if (pci_enabled) {\n\n        pic_set_alt_irq_func(isa_pic, ioapic_set_irq, ioapic);\n\n    }\n\n\n\n    for(i = 0; i < MAX_SERIAL_PORTS; i++) {\n\n        if (serial_hds[i]) {\n\n            serial_init(serial_io[i], i8259[serial_irq[i]], 115200,\n\n                        serial_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < MAX_PARALLEL_PORTS; i++) {\n\n        if (parallel_hds[i]) {\n\n            parallel_init(parallel_io[i], i8259[parallel_irq[i]],\n\n                          parallel_hds[i]);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < nb_nics; i++) {\n\n        NICInfo *nd = &nd_table[i];\n\n\n\n        if (!pci_enabled || (nd->model && strcmp(nd->model, \"ne2k_isa\") == 0))\n\n            pc_init_ne2k_isa(nd, i8259);\n\n        else\n\n            pci_nic_init(pci_bus, nd, -1, \"ne2k_pci\");\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        index = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n\tif (index != -1)\n\n\t    hd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    hd[i] = NULL;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1, i8259);\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            isa_ide_init(ide_iobase[i], ide_iobase2[i], i8259[ide_irq[i]],\n\n\t                 hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n        }\n\n    }\n\n\n\n    i8042_init(i8259[1], i8259[12], 0x60);\n\n    DMA_init(0);\n\n#ifdef HAS_AUDIO\n\n    audio_init(pci_enabled ? pci_bus : NULL, i8259);\n\n#endif\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        index = drive_get_index(IF_FLOPPY, 0, i);\n\n\tif (index != -1)\n\n\t    fd[i] = drives_table[index].bdrv;\n\n\telse\n\n\t    fd[i] = NULL;\n\n    }\n\n    floppy_controller = fdctrl_init(i8259[6], 2, 0, 0x3f0, fd);\n\n\n\n    cmos_init(below_4g_mem_size, above_4g_mem_size, boot_device, hd);\n\n\n\n    if (pci_enabled && usb_enabled) {\n\n        usb_uhci_piix3_init(pci_bus, piix3_devfn + 2);\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        uint8_t *eeprom_buf = qemu_mallocz(8 * 256); /* XXX: make this persistent */\n\n        i2c_bus *smbus;\n\n\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100, i8259[9]);\n\n        for (i = 0; i < 8; i++) {\n\n            smbus_eeprom_device_init(smbus, 0x50 + i, eeprom_buf + (i * 256));\n\n        }\n\n    }\n\n\n\n    if (i440fx_state) {\n\n        i440fx_init_memory_mappings(i440fx_state);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n\tint max_bus;\n\n        int bus, unit;\n\n        void *scsi;\n\n\n\n        max_bus = drive_get_max_bus(IF_SCSI);\n\n\n\n\tfor (bus = 0; bus <= max_bus; bus++) {\n\n            scsi = lsi_scsi_init(pci_bus, -1);\n\n            for (unit = 0; unit < LSI_MAX_DEVS; unit++) {\n\n\t        index = drive_get_index(IF_SCSI, bus, unit);\n\n\t\tif (index == -1)\n\n\t\t    continue;\n\n\t\tlsi_scsi_attach(scsi, drives_table[index].bdrv, unit);\n\n\t    }\n\n        }\n\n    }\n\n\n\n    /* Add virtio block devices */\n\n    if (pci_enabled) {\n\n        int index;\n\n        int unit_id = 0;\n\n\n\n        while ((index = drive_get_index(IF_VIRTIO, 0, unit_id)) != -1) {\n\n            virtio_blk_init(pci_bus, drives_table[index].bdrv);\n\n            unit_id++;\n\n        }\n\n    }\n\n\n\n    /* Add virtio balloon device */\n\n    if (pci_enabled)\n\n        virtio_balloon_init(pci_bus);\n\n\n\n    /* Add virtio console devices */\n\n    if (pci_enabled) {\n\n        for(i = 0; i < MAX_VIRTIO_CONSOLES; i++) {\n\n            if (virtcon_hds[i])\n\n                virtio_console_init(pci_bus, virtcon_hds[i]);\n\n        }\n\n    }\n\n}\n", "idx": 12828, "substitutes": {"ram_size": ["ram_scale", "vm_term", "cam_shape", "ram\u00b7term", "sim_size", "gram_loc", "ram_shape", "ram_num", "cam_len", "sim_addr", "cam_type", "gram_scale", "sim_offset", "ram_offset", "gram_size", "ram_len", "simingoffset", "cam_size", "simingaddr", "ram\u00b7size", "simingnum", "vm_cap", "vm_size", "ram00offset", "ram00addr", "ram_cap", "ramingnum", "ramingoffset", "vm_scale", "ram00num", "ram_type", "ram\u00b7scale", "ramingsize", "ram\u00b7cap", "ram00size", "ram_loc", "ram_term", "ramingaddr", "simingsize", "sim_num"], "vga_ram_size": ["vga_gram_length", "vga_gram_width", "vga_ram_width", "vga_gram_size", "vga_ram_length"], "boot_device": ["bootingdevices", "bootmingdevice", "kernel_device", "bootmingmode", "bootingdevice", "bootmingengine", "kernel_devices", "bootingengine", "bootmingdevices", "boot_mode", "kernel_engine", "boot_devices", "boot_engine", "kernel_mode", "bootingmode"], "ds": ["dh", "tx", "ys", "bs", "Ds", "fs", "irs", "rs", "da", "cs", "ps", "ss", "gd", "pd", "DS", "des", "ns", "df", "xs", "dt", "dds", "ops", "dd", "db", "ls", "ils", "vs", "dm", "ks"], "kernel_filename": ["kernel_software", "config_file", "kernel___sequence", "kernel___file", "config_name", "configlogsequence", " kernel_file", "kernellogfile", "kernellogfilename", "kernel_name", "configlogname", "kerneldbfiles", "kerneldbfile", "kernel___filename", "kernel___name", " kernel_software", " kernel_files", "configlogfile", "kernellogname", "kerneldbsoftware", "kernel_file", "configlogfilename", "kernellogsequence", "kerneldbfilename", "config_filename", "config_sequence", "kernel_files", "kernel_sequence"], "kernel_cmdline": ["kernel_commandlines", "kernel_commandline", "kernel_argse", "kernel_hostlines", "kernel_cmdend", "kernel_argline", "kernel_cmdlines", "kernel_hostend", "kernel_arglines", "kernel_commandse", "kernel_hostse", "kernel_argend", "kernel_hostline", "kernel_cmdse", "kernel_commandend"], "initrd_filename": ["initrd_source", "initrfmatlocation", "initrdmatpath", "initrd_location", "initrfmatpath", "initrd_path", "initrf_filename", "initrddfilename", "initrddpath", "initrdmatfilename", "initrdmatsource", "initrf_location", "initrf_source", "initrddlocation", "initrf_path", "initrdmatlocation", "initrddsource", "initrfmatfilename", "initrfmatsource"], "pci_enabled": ["pili_enable", "pili_required", "pci_disabled", "pili_enabled", "pci_supported", "pki_mode", "pili_disabled", "pci__enable", "pci__enabled", "pki_disabled", "pci__disabled", "pci_enable", "pci2supported", "pci2enabled", "pci__required", "pci2mode", "pci2disabled", "pki_supported", "pci_required", "pci_mode", "pki_enabled"], "cpu_model": ["cpu__mode", "cpu_view", "pc_models", "pc_module", "pc_model", " cpu_mode", "CPU_device", "processor_mode", "cpu__base", "cpu___device", "cpu_handler", "cpu_command", "processor_Model", "cpu_scale", " cpu_models", "CPU_models", "cpu_models", "cpu_device", "processor_view", "cpu_base", "cpu___model", "cpu67device", "cpu_module", " cpu_base", "cpu__model", " cpu_module", "cpu___command", "cpu___models", "cpu_mode", "processor_model", "cpu67models", "CPU_model", "cpu67model", " cpu_scale", "pc_handler", "CPU_command", "cpu67command", "cpu_Model"], "buf": ["func", "map", "proc", "blocks", "bin", "uf", "buffer", "bag", "br", "buff", "ba", " buffer", "mem", "ctx", "rb", "fi", "data", "b", "Buffer", "box", "block", "cb", "cap", "seq", "pad", "ptr", "alloc"], "ret": ["rc", "val", "code", "def", " rc", "test", "status", "script", "v", "conn", "info", "Ret", "result", "stat", " RET", "ports", "out", "all", "exec", "RET", "res", "reg", "len"], "linux_boot": ["kernel_bit", "kernel_Boot", "kernel_setup", " linux_lock", "kernel_boot", "linux_Boot", "linux_lock", " linux_bit", " linux_config", "linux_config", "linux_bit", "linux_setup"], "i": ["hi", "qi", "it", "ui", "uni", "slice", "I", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "io", "mu", "ci", "image", "h", "di", "x", "si", "init", "ie", "ii", "uri", "v", "limit", "gu", "yi", "u", "p", "info", "mini", "fi", "mi", "li", "cli", "ix", "b", "multi", "j", "count", "n", "f", "phi", "ti", "ski", "ip", "c", "eni", "pi", "udi", "chi", "ami", "y", "start"], "ram_addr": ["ramMoffset", "ream_size", "ream_device", "mem_addr", "mem_ptr", "ram_ptr", "ramMptr", "ramMaddress", "mem_address", "ream_address", "mem_offset", "ramddevice", "ram_address", "ramMaddr", "ramdaddr", "ramdsize", "ram_offset", "ream_addr", "ramdaddress", "ram_device"], "vga_ram_addr": ["vga_ramingaddress", "vga_ram_src", "vga_ramingoffset", "vga_ramingsrc", "vga_ramingaddr", "vga_mem_offset", "vga_mem_addr", "vga_mem_address", "vga_mem_src", "vga_ram_address", "vga_ram_offset"], "bios_offset": ["bio_offset", "bio_data", "bio_size", "bios_position", "biosacposition", "biosacdata", "biosacsize", "bio_position", "bios_data", "biosacoffset"], "vga_bios_offset": ["vga_bio_size", "vga_bio_len", "vga_bio_pos", "vga_bio_offset", "vga_bios_len", "vga_bios_pos"], "below_4g_mem_size": ["below_4g_mem_small", "below_4g_memory_stream", "below_4g_memsspeed", "below_4g_mem_stream", "below_4g_memssize", "below_4g_memacstream", "below_4g_memory_speed", "below_4g_memacspeed", "below_4g_ram_size", "below_4g_mem_address", "below_4g_ram_address", "below_4g_mem_speed", "below_4g_memory_small", "below_4g_memory_size", "below_4g_memacsize", "below_4g_memssmall", "below_4g_ram_small"], "bios_size": ["bio_size", "bios_ize", "bios_address", "bio_ize", "bio_address", "bio_len", "bios_len"], "isa_bios_size": ["isa_bio_size", "isa_bios_len", "isa_bio_ize", "isa_bios_ize", "isa_bio_len"], "vga_bios_size": ["vga_bias_size", "vga_bios_capacity", "vga_bias_scale", "vga_bios_scale", "vga_bias_capacity"], "pci_bus": ["pki_bus", "pki_boot", "pci2boot", "pci_device", "pci_boot", "pci2bus", "pci_BUS", "pci2device", "pki_BUS", "pci2BUS", "pki_device"], "env": ["args", "en", "context", "bc", "enc", "ea", "config", " environment", "eu", "oa", "ah", "style", "ass", "act", "ig", "virt", "py", "h", "vm", "txt", "scope", "dir", "session", "v", "app", "conf", "output", "inv", "conn", "np", "console", "obj", "dev", "dict", "e", "ctx", "viron", "exc", "engine", "nc", "her", "enable", "ext", "eng", "site", "qt", "Environment", "dat", "state", "export", "c", "eni", "global", "dc", "end", "ne", "eb", "here", "cal", "exec", "db", "ev", "inet", "ec", "cache", "et", "chal", "ven", "environment", "el", "vs", "ef", "net", "err"], "cpu_irq": ["cpu_mirq", "cpu_irch", "cpu_crck", "cpu_crq", "cpu_IRch", "cpu_IRp", "cpu_crp", "cpu_mirck", "cpu_irck", "cpu_irp", "cpu_mirch", "cpu_mirp", "cpu_crch", "cpu_IRq", "cpu_IRck"], "i8259": ["i18257", "i6258", "i8258", "i6266", "i8257", "i6257", "int8257", "i18258", "i8266", "int8259", "int8266", "int8258", "i18259", "i6259", "i18266"], "index": ["Index", "action", "sync", "config", "name", "weight", "x", "position", "error", "value", "output", "conn", "version", "ind", "info", "engine", "data", "diff", "type", "loop", "pos", "num", "addr", "run", "len", "thread"], "hd": ["hp", "ha", "cow", "amd", "da", "bd", "hs", "hub", "di", "rh", "gd", "pd", "cd", "ad", "du", "ck", "xd", "hm", "df", "dt", "dc", "ht", "md", "dd", "vd", "hid", "wd", "hw"], "MAX_IDE_BUS": ["MAX_IDEADBUS", "MAX_IDEADBus", "MAX_IDE__DIR", "MAX_DE_BUS", "MAX_IDE_USE", "MAX_IDEADUSE", "MAX_DE_DIR", "MAX_IDE__USE", "MAX_DE_Bus", "MAX_IDE_Bus", "MAX_IDE_DIR", "MAX_IDEADDIR", "MAX_DE_USE", "MAX_IDE__Bus", "MAX_IDE__BUS"], "MAX_IDE_DEVS": ["MAX_IDE_DEFS", "MAX_IDE_DVICE", "MAX_IDE_DRPS", "MAX_IDE_DIVICE", "MAX_IDE_DEVICE", "MAX_IDE_DIFS", "MAX_IDE_DRVICE", "MAX_IDE_DFS", "MAX_IDE_DEPS", "MAX_IDE_DIVS", "MAX_IDE_DRFS", "MAX_IDE_DPS", "MAX_IDE_DVS", "MAX_IDE_DRVS", "MAX_IDE_DIPS"], "fd": ["ff", "d", "fl", "fs", "fb", "bd", "cond", "fx", "dl", "fat", "dir", "fr", "dev", "du", "sd", "f", "lf", "flow", "df", "dc", "cb", "md", "cf", "db", "wd", "fc", "ef", "FD", "fw"], "MAX_FD": ["MAX__HD", "MAX_DEF", "Max_MODE", "MAX_MODE", "MAX__DEF", "MAX__MODE", "MAX__FD", "Max_FD", "Max_HD", "Max_DEF", "MAX_HD"]}}
{"project": "qemu", "commit_id": "0bed71edbc323de12ed1e5390a85a013f6a143f4", "target": 0, "func": "static int slirp_hostfwd(SlirpState *s, const char *redir_str,\n\n                         int legacy_format)\n\n{\n\n    struct in_addr host_addr = { .s_addr = INADDR_ANY };\n\n    struct in_addr guest_addr = { .s_addr = 0 };\n\n    int host_port, guest_port;\n\n    const char *p;\n\n    char buf[256];\n\n    int is_udp;\n\n    char *end;\n\n\n\n    p = redir_str;\n\n    if (!p || get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (!strcmp(buf, \"tcp\") || buf[0] == '\\0') {\n\n        is_udp = 0;\n\n    } else if (!strcmp(buf, \"udp\")) {\n\n        is_udp = 1;\n\n    } else {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (!legacy_format) {\n\n        if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n            goto fail_syntax;\n\n        }\n\n        if (buf[0] != '\\0' && !inet_aton(buf, &host_addr)) {\n\n            goto fail_syntax;\n\n        }\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, legacy_format ? ':' : '-') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    host_port = strtol(buf, &end, 0);\n\n    if (*end != '\\0' || host_port < 1 || host_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (get_str_sep(buf, sizeof(buf), &p, ':') < 0) {\n\n        goto fail_syntax;\n\n    }\n\n    if (buf[0] != '\\0' && !inet_aton(buf, &guest_addr)) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    guest_port = strtol(p, &end, 0);\n\n    if (*end != '\\0' || guest_port < 1 || guest_port > 65535) {\n\n        goto fail_syntax;\n\n    }\n\n\n\n    if (slirp_add_hostfwd(s->slirp, is_udp, host_addr, host_port, guest_addr,\n\n                          guest_port) < 0) {\n\n        error_report(\"could not set up host forwarding rule '%s'\",\n\n                     redir_str);\n\n        return -1;\n\n    }\n\n    return 0;\n\n\n\n fail_syntax:\n\n    error_report(\"invalid host forwarding rule '%s'\", redir_str);\n\n    return -1;\n\n}\n", "idx": 12846, "substitutes": {"s": ["ses", "m", "t", "sg", "fs", "g", "S", "h", "sq", "session", "server", "v", "ss", "o", "e", "b", "sf", "n", "f", "spec", "c", "ssl", "sv", "sl", "r", "services", "sa", "su"], "redir_str": ["redir_arr", "redIR_string", "redirect_str", "redir2Str", "redirect_arr", "redir2arr", "redir_format", "redir2str", "redIR_Str", "redirect_Str", "redIR_tr", "redir_Str", "redIR_str", "redirect_format", "redir2format", "redir_tr", "redir_string"], "legacy_format": ["legcore_form", "legacy__prefix", "legcore__prefix", "legcore_prefix", "legcore__format", "legacy_form", "legACY_style", "legACY_format", "legcore_mode", "legacy_str", "legcore__mode", "legcore_format", "legACY_magic", "legacy__mode", "legacy_style", "legacy__form", "legacy__format", "legacy_magic", "legcore__form", "legacy_prefix", "legacy_mode"], "host_port": ["hostinglength", "hostingexp", "hostspool", "hostalport", "master_port", " host_position", "host_position", "host67direction", " hostspool", "host\u00b7limit", "host_direction", "host\u00b7direction", " host_pool", "host_path", "hostablelimit", "hostingport", " host_ip", "master_path", "hostalpool", "hostaldirection", "hostalwidth", "host7port", "host67ip", "host67port", "host_exp", "host7pool", "hostingdirection", "host_pool", "hostablepath", "hostabledirection", "hostableport", "hostswidth", "host_length", "host\u00b7position", " hostswidth", "host\u00b7ip", "host7width", "hostallength", "hostalexp", " hostsport", "host7hop", "master_direction", "host\u00b7port", " host_exp", " host_width", " host_direction", " host_hop", "hostalhop", "hostshop", " hostshop", "host67position", "host_limit", "host_ip", "master_limit", "host_width", "host_hop", " host_length", "host\u00b7path", "hostsport"], "guest_port": ["guest\u00b7address", "guest__port", "guest6number", "guest6port", "guest_length", "guest6ports", "guest\u00b7Port", "guility_address", "guest_address", "gugest_port", "guility\u00b7Port", "guility\u00b7depth", "guestDport", "guest_limit", "guestDports", "guestDlimit", "gugest_ports", "guility\u00b7address", "guest\u00b7depth", "guest_end", "guest__ports", "guest_name", "guility_depth", "guest_ports", "guest6end", "guess_port", "gugest__ports", "guest\u00b7port", "guest_depth", "gugest__port", "guess_end", "gugest_limit", "guess_number", "gugest__limit", "guess_ports", "guility\u00b7port", "guility_port", "guess_name", "guility_Port", "guess_length", "guest_number", "guest_Port", "guest__limit"], "p": ["path", "port", "m", "pen", "en", "part", "python", "po", "d", "t", "after", "pkg", "pc", "jp", "i", "vp", "l", "pt", "a", "pre", "api", "g", "sp", "h", "lp", "py", "pp", "ap", "fp", "v", "o", "np", "bp", "u", "e", "y", "pb", "pa", "b", "op", "j", "n", "f", "point", "at", "padding", "wp", "pair", "ip", "c", "pe", "pn", "pi", "ep", "dp", "pro", "r", "cp", "param", "pr", "pat", "pos", "prefix", "prop", "pad", "P", "tp", "start"], "buf": ["aka", "bridge", "map", "port", "proc", "ff", "bc", "val", "msg", "prot", "bytes", "h", "pool", "str", "fp", "loc", "br", "mem", "brace", "rb", "box", "Buffer", "padding", "c", "cat", "cb", "text", "prop", "func", "plug", "context", "bb", "home", "uf", "front", "conv", "bus", "u", "img", "data", "b", "wb", "result", "feed", "cap", "r", "cache", "lb", "path", "queue", "fd", "cv", "config", "fb", "bd", "buffer", "bag", "grab", "exc", "desc", "sb", "f", "gb", "bh", "bu", "block", "bo", "cur", "ph", "ctx", "err", "bt", "vec", "font", "pkg", "uc", "input", "pt", "binary", "a", "hal", "buff", "la", "pb", "ab", "cmd", "src", "seq", "pad"], "is_udp": ["is_dupa", "is_udspp", "is_webp", "is_udpa", "is_udm", "is_urpa", "is_adp", "is_dupe", "is__udm", "is_webb", "is_audpa", "is_udspa", "is_udspe", "is_adpe", "is_urm", "is_udsp", "is_adb", "is_adm", "is_urb", "is_urpe", "is_webpe", "is__udsb", "is_dupp", "is__udspe", "is__udb", "is__udpe", "is_udsm", "is_udb", "is__udsp", "is__udpa", "is_webpa", "is_dup", "is__udsm", "is_udpp", "is__udp", "is__udspa", "is_audpe", "is_udpe", "is_urp", "is_audp", "is_audpp", "is_udsb"], "end": ["path", "port", "en", "after", "END", "len", "enc", "d", "id", "enter", "End", "api", "eval", "send", "h", "nd", "append", "until", "ent", "begin", "set", "win", "w", "open", "pass", "z", "ad", "stop", "dev", "e", "desc", "k", "entry", "est", "pend", "f", "line", "ending", "ip", "c", "close", "text", "all", "ast", "r", "last", "ended", "rest", "pos", "post", "max", "in", "index", "start"]}}
{"project": "qemu", "commit_id": "e6eef7c221634c942e9f586df84aae623aa06cd5", "target": 0, "func": "int kvm_arch_put_registers(CPUState *cs, int level)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    struct kvm_fpu fpu;\n\n    int r;\n\n    int i;\n\n\n\n    /* always save the PSW  and the GPRS*/\n\n    cs->kvm_run->psw_addr = env->psw.addr;\n\n    cs->kvm_run->psw_mask = env->psw.mask;\n\n\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.gprs[i] = env->regs[i];\n\n            cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_GPRS;\n\n        }\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            regs.gprs[i] = env->regs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Floating point */\n\n    for (i = 0; i < 16; i++) {\n\n        fpu.fprs[i] = env->fregs[i].ll;\n\n    }\n\n    fpu.fpc = env->fpc;\n\n\n\n    r = kvm_vcpu_ioctl(cs, KVM_SET_FPU, &fpu);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    /* Do we need to save more than that? */\n\n    if (level == KVM_PUT_RUNTIME_STATE) {\n\n        return 0;\n\n    }\n\n\n\n    /*\n\n     * These ONE_REGS are not protected by a capability. As they are only\n\n     * necessary for migration we just trace a possible error, but don't\n\n     * return with an error return code.\n\n     */\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CPU_TIMER, &env->cputm);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_CLOCK_COMP, &env->ckc);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_TODPR, &env->todpr);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_GBEA, &env->gbea);\n\n    kvm_set_one_reg(cs, KVM_REG_S390_PP, &env->pp);\n\n\n\n    if (cap_async_pf) {\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFTOKEN, &env->pfault_token);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFCOMPARE, &env->pfault_compare);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n        r = kvm_set_one_reg(cs, KVM_REG_S390_PFSELECT, &env->pfault_select);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            cs->kvm_run->s.regs.acrs[i] = env->aregs[i];\n\n            cs->kvm_run->s.regs.crs[i] = env->cregs[i];\n\n        }\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_ACRS;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_CRS;\n\n    } else {\n\n        for (i = 0; i < 16; i++) {\n\n            sregs.acrs[i] = env->aregs[i];\n\n            sregs.crs[i] = env->cregs[i];\n\n        }\n\n        r = kvm_vcpu_ioctl(cs, KVM_SET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    /* Finally the prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        cs->kvm_run->s.regs.prefix = env->psa;\n\n        cs->kvm_run->kvm_dirty_regs |= KVM_SYNC_PREFIX;\n\n    } else {\n\n        /* prefix is only supported via sync regs */\n\n    }\n\n    return 0;\n\n}\n", "idx": 12853, "substitutes": {"cs": ["args", "cing", "acs", "sys", "ch", "bc", "ca", "sync", "core", "rc", "cc", "fs", "bs", "ins", "ys", "utils", "lc", "CS", "qs", "ci", "sk", "cn", "cms", "wcs", "js", "ace", "Cs", "ct", "ras", "ps", "conn", "cons", "s", "cks", "nc", "ck", "tc", "cus", "co", "ix", "gs", "ocr", "spec", "acks", "c", "ns", "cells", "ac", "ics", "cb", "cas", "sc", "ce", "cf", "ops", "cp", "ds", "vc", "cal", "cache", "ec", "css", "ls", "ts", "ces", "vs", "ctx", "ks"], "level": ["path", "len", "d", "enc", "id", "lvl", "levels", "code", "style", "l", "name", "status", "method", "scope", "key", "limit", "col", "role", "clean", "layer", "stage", "where", "mode", "lf", "rol", "parent", "line", "state", "inc", "c", "Level", "type", "sc", "loop", "scale", "vel", "lock", "cl", "depth"], "cpu": ["sys", "bench", "cm", "bc", "uc", "mc", "cv", "ca", "rc", "pc", "lc", "kernel", "cn", "vm", "cmp", "pu", "platform", "conn", "np", "processor", "instance", "net", "nc", "CPU", "cli", "spec", "uci", "c", "gpu", "fc", "clock", "sc", "cp", "cache", "core", "hw", "ctx", "node"], "env": ["en", "oa", "gear", "server", "np", "exe", "export", "c", "end", "ec", "fen", "ef", "args", "context", "cdn", "eu", "eve", "req", "console", "viron", "her", "ext", "eni", "dt", "anc", "csv", "ce", "uv", "cal", "exec", "gui", "cache", "ev", "el", "iss", "header", "core", "visor", "edge", "ea", "cv", "config", "scope", "conn", "stage", "e", "exc", "engine", "nc", "site", "eng", "Environment", "cfg", "ne", "osc", "cf", "que", "ctx", "enc", "code", "ass", "estate", "v", "conf", "zone", "energy", "cli", "dat", "shell", "den", "db", "vel", "environment", "et", "esm"], "sregs": ["sconfigos", "srecs", "gsregn", "sconfign", "gsregb", "gsregs", "srecn", "sregn", "sarchn", "srecos", "sarchb", "sarchs", "sregb", "gsregos", "sconfigs", "gsarchb", "gsarchos", "sconfigb", "gsarchs", "sregos", "sarchos", "srecb", "gsarchn"], "regs": ["recp", "egs", "systems", "reges", "recd", "gregs", "reggs", "rolls", "regp", "memcs", "REGcs", "rcns", "Regp", "gregb", "rolld", "rcds", " reges", "fund", "recsets", "recds", "Regs", "statp", "REGps", "orgds", "greges", "gregds", " regp", "REGp", "eggs", "egds", "REGs", "rollsets", "orgs", "regd", "gregns", "regh", "REGd", "greggs", "recps", "recs", "REGds", "stath", "statcs", "orges", "funs", "systemd", "rcs", "regb", "memp", "stats", "memh", "Regd", "regsets", "regcs", "regps", "orgb", " regds", " regb", " regps", "regds", "egns", "funsets", "mems", "rcgs", "regns", "REGh", "systemp"], "fpu": ["ppu", "sfcpu", "vpu", "ppac", "Fcp", "frcpu", " fpr", "fcp", "lpr", "lpc", "vpc", "fpr", "vpac", "fpac", "fcpu", "lpac", "Fpac", "sfproc", "Fpl", "frproc", "fproc", "Fpc", " fpc", "Fpu", "vpl", "vcp", "sfpc", "Fcpu", "ppr", "fpl", "frpc", "sfpu", "frpu", " fpl", "ppc", "fpc", "lpu", " fpac", "vcpu", " fproc", " fcp", " fcpu"], "r": ["it", "rr", "m", "vr", "ru", "R", "d", "hr", "rc", "l", "rs", "or", "rar", "er", "h", "rg", "sr", "error", "v", "br", "rh", "fr", "cr", "o", "w", "u", "mr", "rec", "p", "e", "lr", "rb", "ir", "k", "b", "n", "f", "result", "c", "ur", "attr", "q", "re", "rt", "pr", "nr", "ar", "dr", "res", "rf", "run", "err"], "i": ["my", "oi", "x", "si", "phi", "c", "anti", "ji", "zi", "in", "index", "hi", "m", "slice", "d", "t", "xi", "id", "iu", "io", "g", "di", "key", "w", "u", "fi", "resource", "data", "b", "ti", "ip", "eni", "inner", "bi", "mu", "qi", "ni", "ini", "current", "ci", "source", "ie", "vi", "o", "z", "e", "info", "li", "ix", "multi", "j", "f", "none", "block", "field", "it", "ui", "adi", "I", "ai", "l", "gi", "a", "ii", "v", "uri", "yi", "p", "mini", "cli", "k", "mi", "n", "pi", "uli", "ri", "ori", "y", "abi"]}}
{"project": "qemu", "commit_id": "ffbb1705a33df8e2fb12b24d96663d63b22eaf8b", "target": 0, "func": "static void spapr_hotplug_req_event(uint8_t hp_id, uint8_t hp_action,\n\n                                    sPAPRDRConnectorType drc_type,\n\n                                    uint32_t drc)\n\n{\n\n    sPAPRMachineState *spapr = SPAPR_MACHINE(qdev_get_machine());\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n    hp->hotplug_identifier = hp_id;\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        if (hp->hotplug_action == RTAS_LOG_V6_HP_ACTION_ADD) {\n\n            spapr_hotplug_set_signalled(drc);\n\n        }\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_LMB:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_MEMORY;\n\n        break;\n\n    case SPAPR_DR_CONNECTOR_TYPE_CPU:\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_CPU;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    if (hp_id == RTAS_LOG_V6_HP_ID_DRC_COUNT) {\n\n        hp->drc.count = cpu_to_be32(drc);\n\n    } else if (hp_id == RTAS_LOG_V6_HP_ID_DRC_INDEX) {\n\n        hp->drc.index = cpu_to_be32(drc);\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp, true);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->xics, spapr->check_exception_irq));\n\n}\n", "idx": 12887, "substitutes": {"hp_id": ["hp_type", "cp_name", "cp_image", "cp_type", "hp_image", "cp_id", "hp_name"], "hp_action": ["hp_type", "gp_action", "gp_name", "gp_type", "hp_uri", "hp_name", "gp_uri"], "drc_type": ["ddc_types", "ddc_type", "drc_id", "ddc_name", "ddc_id", "drc_types", "drc_name"], "drc": ["Drd", "drt", "pdrd", "pdri", "drd", " drd", "pdrt", " dri", "Drc", "Dri", "pdrc", "Drt", "dri", " drt"], "spapr": ["spAPr", "spaprm", "spapyR", "pAPrm", "spAPR", "spapyrator", "spaprator", "paprm", "spampR", "papR", "pAPrator", "spapR", "spampr", "papr", "spAPrm", "spamprator", "spAPrator", "pAPR", "spapyrm", "paprator", "spapyr", "spamprm", "pAPr"], "new_hp": ["New_hp", "newJht", "new_hai", "private_hp", " new_cp", "private_pai", "newjtp", "newlexmph", " new_cpp", "new_phy", "new_gp", "new_cp", "remote_hop", "remote67fp", "newjcp", "new_pai", "newjhp", "newjgp", "new_http", "New_gp", "new_tp", " new_tp", "new_xml", "private_hai", "newJhm", "newplepai", "new_hy", "New_hap", "newlexcpp", "remote_hp", "new_dh", "remote_fp", "newlexgp", "newplehp", " new_http", "newlexhp", "private_xml", " new_gp", "remote67hp", " new_hm", "new___gp", "newJgp", "new67hop", "new___hm", "newThehw", "new_hop", "newThecpp", " new_hw", "new___ht", "new67fp", "remote67hy", "new67hy", "new_cpp", "new___hp", "new_ht", "new_hw", "new_fp", "newplehai", "newplexml", "newJhp", "new_hap", "new_hm", "New_phy", "new67hp", "remote_hy", " new_ht", "remote67hop", "new_mph", "newThemph", " new_dh", "newThehp", " new_mph"], "hdr": ["shride", "ohDR", "khrt", "shendor", "hmvr", "shrid", "hvr", "hendor", "ohmt", "Hmt", "hrder", "ihDR", "ehmt", "ohirt", " hDR", "shstr", "shint", "ohrid", "HDr", "enhbr", "hmDR", "ihder", "dhdr", "Hrid", "ehdr", "enhirt", "dhride", " hder", "ohvr", "shDR", "hder", "hirt", "Hbr", "hride", "enhint", "enhDr", "thdr", "hint", "hrt", "hmrid", "shder", "hrstr", "thendor", "ehDR", "khder", " hirt", "ihdr", "rhendor", "rhdr", "dhDR", "ihstr", "Hdr", "shbr", " hrt", "hrdr", "thrid", " hint", "thvar", "rhint", "hbr", " hstr", "ehrid", "hmirt", "hvar", "Hride", "hDR", "hmt", "HDR", " hrid", "dhint", " hvr", "thrt", "thder", "ohdr", "khvar", "Hint", "enhdr", "shdr", "shirt", " hvar", " hDr", "thint", "Hstr", "hstr", "hrDR", "rhrid", "khdr", "enhrid", "hDr", "hmstr", "hmint", "Hirt", "hrid", "hmdr"], "v6hdr": ["v3bhride", "v9hrt", "v6Hr", "v3hride", "v3bhrt", "v4hhint", "v6Hdr", "v6mrt", "v9hDR", "v3bhrid", "v9ehDR", "v4hhdr", "v6ehrid", "v3hrid", "v9hdr", "v0hdr", "v3bhdr", "v9ehrt", "v6hrid", "v6phint", "v6phrid", "v4hdr", "v6ehDR", "v3hdr", "v6hhdr", "v6bhride", "v4hr", "v6hint", "v6ghrid", "v0ehint", "v9ehdr", "v6hDR", "v0hint", "v6ehdr", "v6bhint", "v6phdr", "v0hDR", "v9ehint", "v6ghint", "v4hDR", "v6HDR", "v6ghdr", "v6hhrt", "v4hhDR", "v6ehrt", "v6hlrid", "v6bhrid", "v6hrt", "v6hride", "v6ehint", "v6phDR", "v0hrid", "v6mrid", "v6bhdr", "v0ehDR", "v3hrt", "v0ehdr", "v6Hint", "v6mride", "v6hlrt", "v4hint", "v4hhr", "v9hint", "v6hr", "v6bhrt", "v6ghDR", "v0ehrid", "v6mdr", "v6hlride", "v6bhDR", "v6phr", "v6hhr", "v6hldr", "v6hhint", "v6hhDR"], "maina": ["mainc", "centralb", "mainA", "masterb", "minas", "mainaa", "mainab", "westb", "minab", "westA", "mainas", " mainan", " mainc", "masterA", "minA", "minaa", "Mainan", "mina", "Maina", "westa", "mastera", "centrala", "masteran", "Mainc", "Mainb", "MainA", " mainaa", "minb", " mainas", "centralc", " mainA", "masterab", "minan", "Mainas", "masterc", "centralan", "mainan", "minc", "masteraa", "westab"], "mainb": ["centralbody", "mainc", "centralb", "masterb", "westb", "mainab", " mainB", "markba", "mainbar", " maine", " mainc", "markbody", "Mainab", "mina", "minf", "Maina", "nighta", "mainf", "mine", " mainbase", "mastera", "centrala", "Mainc", "minB", "nightbase", "minbase", "nightf", "Mainb", " mainbreak", "mainbody", "minb", "markb", "defaultbar", "defaulta", "Maine", "mainbase", "centralc", "masterab", "dayb", "daybreak", "centralba", "dayab", " mainab", " mainba", "markf", "defaultc", "defaultb", "centralf", "maine", "mainB", "westbreak", "mainbreak", " mainf", "minc", "masterB", "Mainf", "nightb", "Mainbar", "mainba", "mastere", "centrale", " mainbody", " mainbar", "centralab", "centralbar", "westab"], "hp": ["dh", "pkg", "ha", "ssh", "hy", "ih", "wm", "hl", "config", "jp", "phys", "vp", "prot", "pg", "hs", "h", "lp", "pp", "xp", "igh", "fp", "rpm", "rh", "imp", "np", "bp", "hh", "p", "hai", "drm", "cli", "wp", "hm", "ip", "helm", "ph", "ht", "eth", "dp", "cp", "hd", "hap", "pai", "hop", "him", "tp", "gp", "hw", "cpp", "phy", "php"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_broadcast_packet(USBHubState *s, USBPacket *p)\n\n{\n\n    USBHubPort *port;\n\n    USBDevice *dev;\n\n    int i, ret;\n\n\n\n    for(i = 0; i < NUM_PORTS; i++) {\n\n        port = &s->ports[i];\n\n        dev = port->port.dev;\n\n        if (dev && (port->wPortStatus & PORT_STAT_ENABLE)) {\n\n            ret = usb_handle_packet(dev, p);\n\n            if (ret != USB_RET_NODEV) {\n\n                return ret;\n\n            }\n\n        }\n\n    }\n\n    return USB_RET_NODEV;\n\n}\n", "idx": 12894, "substitutes": {"s": ["south", "sys", "ses", "parts", "service", "t", "sg", "fs", "private", "sym", "cs", "S", "os", "si", "js", "sq", "ps", "ss", "o", "u", "share", "http", "n", "f", "state", "spec", "ns", "c", "is", "stats", "ssl", "side", "sv", "sl", "states", "services", "ds", "sie", "su", "ls", "sports"], "p": ["m", "d", "t", "pc", "jp", "pt", "a", "api", "g", "sp", "h", "pp", "ap", "fp", "v", "ps", "o", "np", "w", "e", "pb", "pa", "data", "b", "pl", "j", "n", "f", "point", "c", "pi", "r", "cp", "P", "tp", "gp"], "port": ["device", "bridge", "transfer", "m", "interface", "part", "service", "t", "config", "mount", "Port", "object", "pt", "child", "api", "connection", "source", "test", "pool", "machine", "slave", "v", "server", "PORT", "band", "group", "plugin", "pipe", "pod", "match", "component", "driver", "j", "op", "f", "point", "ort", "parent", "address", "state", "pair", "ip", "proxy", "export", "end", "type", "ports", "pi", "target", "cp", "host", "tag", "hop", "prop"], "dev": ["plug", "bug", "device", "development", "kind", "ch", "part", "d", "dist", "priv", "pu", "home", " device", "def", "rad", "bd", "api", "name", "pt", "serial", "sk", "user", "di", "Dev", "mod", "bus", "comment", "raw", "valid", "app", "error", "conf", "gu", "var", "conn", "der", "gd", "w", "de", "adv", "ad", "pub", "ind", "obj", "info", "ver", "boot", "prom", "data", "driver", "mode", "diff", "block", "dem", "end", "DEV", "md", "cmd", "debug", "dd", "od", "ev", "off", "prop", "pad", "wd"], "i": ["hi", "qi", "ui", "adi", "m", "slice", "I", "d", "t", "ni", "ai", "xi", "id", "l", "ini", "gi", "iu", "a", "io", "oi", "mu", "ci", "ki", "h", "x", "di", "si", "ie", "ii", "v", "uri", "var", "o", "u", "e", "fi", "mi", "li", "k", "b", "ix", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "inner", "pi", "udi", "r", "bi", "ori", "ami", "zi", "in", "index"], "ret": ["pet", "alt", "secret", "en", "rev", "reply", "id", "val", "code", "orig", "rets", "gt", "fun", "py", "std", "status", "ref", "det", "lit", "error", "obj", "pass", "pub", "fi", "rb", "success", "data", "ext", "match", "Ret", "result", "rl", "red", "cat", "nt", "re", "rt", "rep", "db", "pat", "RET", "res", "num", "reg", "flag", "len", "bit"]}}
{"project": "qemu", "commit_id": "c6d2283068026035a6468aae9dcde953bd7521ac", "target": 1, "func": "BlockDriverAIOCB *bdrv_aio_writev(BlockDriverState *bs, int64_t sector_num,\n\n                                  QEMUIOVector *qiov, int nb_sectors,\n\n                                  BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bs->read_only)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    if (bs->dirty_tracking) {\n\n        set_dirty_bitmap(bs, sector_num, nb_sectors, 1);\n\n    }\n\n\n\n    ret = drv->bdrv_aio_writev(bs, sector_num, qiov, nb_sectors,\n\n                               cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->wr_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->wr_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 12916, "substitutes": {"bs": ["sys", "blocks", "ses", "bis", "bid", "bc", "sync", "BS", "fs", "iss", "ins", "bb", "ob", "fb", "lc", "cs", "os", "bytes", "js", "es", "ras", "ps", "ss", "obj", "obs", "s", "plugins", "pb", "http", "b", "base", "sb", "banks", "bing", "nas", "gb", "gs", "bits", "ab", "ns", "bu", "bps", "is", "outs", "bes", "eb", "bas", "org", "ds", "bi", "db", "ec", "ls", "css", "bos", "ubs", "lb", "las", "bl", "vs", "us", "ts", "abi", "ks"], "sector_num": ["sector_ident", "sector__number", "section_loc", "sector_um", "section_um", "sector_name", "sector_nr", "sector_number", "sector__nr", "sector__name", "sector__ident", "section_number", "section_ident", "section_name", "sector_loc", "section_nr", "section_num", "sector__num"], "qiov": ["xicho", "ixiev", "quiov", "questicho", "quiban", "qqliv", " qovi", "xiov", "xliv", "quovi", "ixiov", "ixicho", "questovi", "qqiev", "quicho", "qovi", "questiban", "qliv", "qiban", "questiov", "qiev", "qicho", "xiev", "qqiov", " qiban", "qqicho", "ixliv", " qicho"], "nb_sectors": ["nb_serctors", "nb_sections", "nb_pefs", "nb_searers", "nb_spectors", "nb_secgments", "nb_cecs", "nb_spections", "nb_vector", "nb_segments", "nb_secs", "nb_secctors", "nb_speors", "nb_geors", "nb_veors", "nb_pegments", "nb_sercs", "nb_sergments", "nb_seccs", "nb_negments", "nb_sector", "nb_gectors", "nb_spector", "nb_serctor", "nb_seors", "nb_sefs", "nb_vecs", "nb_spegments", "nb_cegments", "nb_secivers", "nb_serctions", "nb_seivers", "nb_spearers", "nb_pecs", "nb_peivers", "nb_nectors", "nb_serivers", "nb_neors", "nb_vearers", "nb_vectors", "nb_gegments", "nb_cectors", "nb_vegments", "nb_peors", "nb_pectors", "nb_vections", "nb_gearers", "nb_specs", "nb_nefs", "nb_ceors", "nb_vefs"], "cb": ["func", "xb", "bc", "zb", "ob", "cv", "unc", "pc", "bb", "fb", "obb", "gc", "lc", "fun", "orb", "abc", "fp", "fn", "CB", "rb", "pb", "sb", "b", "wb", "bf", "f", "c", "nob", "function", "eb", "cmd", "cf", "abb", "db", "lb", "fc", "ctx", "callback"], "opaque": [" opaques", "ospacity", "uppatile", "oppaques", "oppacity", "opatile", " copacre", "ospacre", "opacre", "uppaque", "oppaque", " opacre", "oppatile", "ospaques", "opaques", "opacity", "ospaque", " copaque", "uppaques", " copacity", " copaques", " opacity", "uppacity", " opatile"], "drv": [" drb", "DRc", "DRb", "rrf", "Drp", "DRw", "hrc", "rdw", "drV", "rrp", "Drb", "Drf", "rdb", " drver", "Drv", " drf", "rdv", "rrv", "rrver", "rdf", "DRv", "drb", " drw", "hrb", " drp", "drw", "DRf", "srv", "drf", "hrf", "srb", "srV", "hrv", "src", "srf", "drc", "Drver", "drp", " drV", "drver", "DrV"], "ret": ["alt", "ft", "sys", "rev", "reply", "tmp", "rc", "id", "val", "code", "back", "bd", "def", "gc", "gt", "rets", "fun", "str", "ref", "det", "arg", "full", "lit", "valid", "br", "job", "obj", "ut", "ben", "mem", "fin", "success", "match", "ext", "data", "Ret", "base", "bf", "f", "result", "bare", "att", "url", "cat", " Ret", "nt", "re", "out", "rt", "resp", "db", "real", "RET", "res", "reg", "flag", "len", "bit"], "wr_ops": ["wr_bits", "rw_bytes", "rw_ops", "wr_bytes", "rw_cycles", "rw_bits", "wr_cycles"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_dct_init_x86(DCTContext *s)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_SSE(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse;\n\n    if (EXTERNAL_SSE2(cpu_flags))\n\n        s->dct32 = ff_dct32_float_sse2;\n\n    if (EXTERNAL_AVX(cpu_flags))\n\n        s->dct32 = ff_dct32_float_avx;\n\n}\n", "idx": 12927, "substitutes": {"s": ["sys", "m", "ses", "parts", "t", "sync", "fs", "l", "rs", "g", "cs", "qs", "hs", "settings", "os", "uses", "its", "h", "sets", "es", "js", "ps", "ss", "an", "p", "e", "sf", "features", "f", "gs", "ns", "c", "ans", "ats", "stats", "ssl", "ops", "services", "r", "states", "ls", "ips", "ts", "us", "aws"]}}
{"project": "FFmpeg", "commit_id": "5ecabd3c54b7c802522dc338838c9a4c2dc42948", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940, "substitutes": {"avctx": ["AVconfig", "afconn", "avscope", "AVpc", "abcontext", "evctx", "AVcmp", "ablc", " avscope", " avcf", "ajcontext", "avcmp", "avlc", "abctx", "abcmp", "avescope", "avcf", " avconfig", "avcit", "AVcontext", "aflc", "ajpc", "avectx", "AVcci", "evconn", "afcmp", "AVconn", "AVlc", "AVcf", "afconfig", "AVscope", "ajctx", " avcmp", "afcontext", "ajcit", "AVcit", " avcontext", "evcontext", "avcontext", "avecf", "abpc", "evlc", "avconn", "ajcmp", "afctx", "avpc", "afcci", "avcci", "AVctx", "avecontext", " avcci", "avconfig", " avcit"], "pic": ["proc", "typ", "mc", "cam", "bc", "sync", "rc", "xi", "pc", "pins", "cdn", "gc", "lc", "ctrl", "image", "Pic", "bus", "conn", "lib", "quad", "parse", "oc", "doc", "img", "fi", "sec", "cli", "picture", "cus", "spec", "pict", "pin", "jc", "ac", "pi", "sci", "mag", "ic", "coll", "bi", "gui", "vc", "mac", "cycle", "inch", "fc", "cci", "ctx"], "gb": ["bridge", "ui", "gz", "cam", "bc", "pc", "bb", "gio", "gc", "ub", "g", "hub", "rg", "nb", "gy", "gin", "gnu", "cgi", "gru", "mb", "storage", "gd", "gm", "gg", "bm", "rb", "sb", "usb", "jpg", "bf", "gs", "cfg", "greg", "agi", "gam", "vg", "gram", "cb", "bg", "eb", "abb", "kb", "db", "GB", "gui", "ga", "src", "gal", "gp"], "rle_code": ["rseOpbyte", "rle8count", "rseOpcode", "rLE_module", "rleOpbyte", "rse_value", "rle_Code", "rle_byte", "rle__codes", "rle__code", "rle8number", "rLE_name", "rLE_code", "rle_name", "rle_cod", "rle64code", "rleOpcode", "rLE_Code", "rle__const", "rLE_const", "rlembyte", "rle64number", "rle64call", "rLE_call", "rlemconst", "rle9name", "rle9count", "rle8code", "rle_codes", "rlemcode", "rse_code", "rle_call", "rle64Code", "rLE_number", "rle__byte", "rLE_count", "rLE_byte", "rle_const", "rle8name", "rle_value", "rle_module", "rle9code", "rle__Code", "rse_byte", "rle9number", "rleOpvalue", "rle__cod", "rLE_cod", "rle_number", "rle_count", "rseOpvalue"], "extra_byte": ["extra67byte", "extra67message", "random_value", "extra___character", "stream_bit", "extra___byte", "random_byte", "extra___message", "extra___value", "extra_bit", "extra_message", "random_message", "random___value", "stream_character", "extra67bit", "extra___bit", "random___byte", "stream_layer", "extra_value", "random___message", "extra___layer", "extra_layer", "random___bit", "extra67value", "random_bit", "extra_character"], "odd_pixel": ["odd\u00b7pin", " oddxpixel", "auto_byte", "auto_character", "oddvelpixel", "oddxpin", "oddencharacter", " odd_byte", "auto_hole", "oddenhole", "odd_byte", "odd\u00b7byte", "oddvelbyte", " odd_pin", "oddvelcharacter", "odd\u00b7color", "auto_pixel", " oddxpin", "odd_character", "odd\u00b7pixel", "odd_hole", "oddxcolor", " oddxcolor", "odd_pin", " oddxbyte", "oddvelhole", " odd_color", "oddxbyte", "oddenbyte", "oddxpixel", "oddenpixel", "odd_color"], "stream_byte": [" stream_channel", "roll_byte", "console_byte", "console_outine", "stream_type", "rollMchannel", "filter_layer", "streamJblock", "drawdcode", "model_route", "stream_Byte", "stream67position", "draw_bytes", "streamStoken", "stream_size", "streamMnode", "reader_byte", "streamdbytes", "stream_source", "stream_full", "streamCblock", "stream_bin", "streamablechannel", "stream67job", "sslflowchannel", "drawdbyte", "filterolayer", "streamablebinary", "streamaccode", "draw_unit", " stream_bytes", "header_byte", "header_position", "roll_rule", "stream___block", "readerJphase", "filterSfee", "streamdunit", "readerJbyte", "stream___byte", "streamedoutine", "streamJphase", "rollMbyte", "stream_phase", "stream_unit", "streamflowbyte", "streamflowconnection", "streamdbyte", "stream_page", "streamingbytes", "header_token", "streamablebyte", "streamingblock", "stream_binary", "stream67byte", "streamPcode", "stream_outine", "draw_code", "stream_block", "sslflowconnection", "streamedByte", "stream_note", "stream67value", "stream_function", "filterobin", "roll_channel", "streamacfee", "streamMsource", "streamdcode", "stream___job", "streamJjob", "stream_job", "filter_bin", "streamJval", "model_byte", "stream_layer", "reader_reference", "streamJreference", "filter_token", "stream_connection", "streamMphase", "feed___full", "sslflowbyte", "stream_level", "readerJreference", "filterosecond", "streamedlevel", "streamedbyte", " stream_size", "drawdbytes", "model_node", "streamCreference", "streamMrule", "filterSbyte", "video_node", "streamPtoken", "stream_value", "streamJbyte", "streamallbyte", "feed_full", "streamallnode", "streamMbyte", " stream_binary", "stream_rule", "streamScode", "feed_val", "streamflowoutine", " stream_Byte", "filterobyte", "streammbyte", "video_source", "streamactoken", "feed_byte", "streammsize", "stream67full", "streamMreference", "rollMtoken", "feed___val", "stream_fee", "feed___byte", "console_level", "streamMblock", "video_type", "stream_bytes", "drawdunit", "streamobyte", "filter_fee", "streamingbyte", "streamPposition", " stream_job", "model_function", "stream67token", "streamingchannel", "video_byte", "stream_second", "streamflowchannel", "streammcode", "streamPnote", "streamallsource", "streamSbyte", "reader_block", "streammByte", "streamacbyte", "stream_code", "reader_note", "feed___job", "stream_node", "ssl_connection", "streamolayer", "streamJfull", "streamJfee", "streamalltype", "stream_route", "streamPbyte", "streamPvalue", "ssl_outine", "filter_byte", "console_Byte", "filterScode", "streamobin", "streamSfee", "reader_page", "readerJblock", " stream_block", "feed_job", "streamJtoken", "stream_val", "header_value", "streamPpage", "stream_channel", "streamCbyte", "streamJcode", "roll_token", "ssl_byte", "ssl_channel", " stream_code", "stream67val", "sslflowoutine", "reader_code", "stream___channel", "streamablejob", "streamCphase", "filterStoken", "stream___val", "stream_position", "stream_reference", "streamMtoken", "filter_second", "filter_code", "draw_byte", "stream___bytes", "stream___full", "streamMtype", "streamMchannel", "streamosecond", "reader_phase", "stream_token", "rollMrule"], "i": ["hi", "qi", "it", "ui", "I", "d", "t", "ni", "ai", "xi", "id", "iu", "split", "gi", "code", "ini", "l", "io", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "v", "yi", "u", "ind", "p", "e", "mini", "fi", "cli", "li", "page", "k", "ix", "multi", "j", "count", "phi", "b", "n", "ti", "ski", "f", "ip", "c", "eni", "ji", "pi", "chi", "bi", "ri", "zi", "in", "index", "start"], "pixel_ptr": ["row_wr", " pixel_cro", "row_addr", "cpuIdpair", "pixelPoaddr", "pixel_pos", "row_ptr", "pixelaldim", "pixelIdref", "cpuIdptr", "pixelitypair", "pixelityptr", "pixelPowr", "pixelIdptr", "pixelityref", " pixel_addr", "pixelxptr", "pixelalptr", "pixelxpointers", "cpuIdref", "pixelitycro", "pixelalpointer", "row_dim", "row_inter", "pixelacref", "pixel_proc", "pixel_dim", "pixelPopointer", " pixel_pointers", "pixelitydegree", "pixelPpointer", "pixel_inter", "pixelPoptr", "row_proc", "pixel_ref", "pixelacptr", "pixelIddegree", "pixelxpointer", "pixelPdim", "pixelalinter", "cpuIddegree", "pixelPptr", "pixel_wr", "pixel_pointers", " pixel_pointer", " pixel_slice", "pixelitypointer", "pixel_slice", "pixel_pointer", "pixel_cro", "cpu_degree", "pixelacdegree", "cpu_ref", "pixel_addr", "pixel_degree", "pixelacpair", "pixelPinter", "cpu_pair", "pixelxdegree", "pixel_pair", "cpu_ptr", "row_pointer", "row_pos", "pixelityaddr", "pixelIdpair", " pixel_degree"]}}
{"project": "qemu", "commit_id": "068593deea6cc61b06243a33c7fcfadb1650b654", "target": 1, "func": "void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src)\n\n{\n\n    int i = 0;\n\n    int x = 0;\n\n    uint32_t l_64 = (l + 1) / 8;\n\n\n\n    HELPER_LOG(\"%s l %d dest %\" PRIx64 \" src %\" PRIx64 \"\\n\",\n\n               __func__, l, dest, src);\n\n\n\n#ifndef CONFIG_USER_ONLY\n\n    if ((l > 32) &&\n\n        (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) &&\n\n        (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) {\n\n        if (dest == (src + 1)) {\n\n            mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src));\n\n            return;\n\n        } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) {\n\n            mvc_fast_memmove(env, l + 1, dest, src);\n\n            return;\n\n        }\n\n    }\n\n#else\n\n    if (dest == (src + 1)) {\n\n        memset(g2h(dest), cpu_ldub_data(env, src), l + 1);\n\n        return;\n\n    } else {\n\n        memmove(g2h(dest), g2h(src), l + 1);\n\n        return;\n\n    }\n\n#endif\n\n\n\n    /* handle the parts that fit into 8-byte loads/stores */\n\n    if (dest != (src + 1)) {\n\n        for (i = 0; i < l_64; i++) {\n\n            cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x));\n\n            x += 8;\n\n        }\n\n    }\n\n\n\n    /* slow version crossing pages with byte accesses */\n\n    for (i = x; i <= l; i++) {\n\n        cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i));\n\n    }\n\n}\n", "idx": 12946, "substitutes": {"env": ["forge", "proc", "en", "context", "enh", "esp", "queue", "qa", "enc", "ea", "ench", "config", "cdn", "priv", "iv", "eu", "ah", "style", "kn", "er", "vm", "init", "gear", "server", "v", "conn", "np", "console", "loader", "energy", "e", "equ", "viron", "exc", "info", "engine", "buf", "net", "eng", "tern", "her", "qt", "Environment", "assets", "dep", "export", "eni", "shell", "dt", "here", "atten", "que", "exec", "db", "ev", "vel", "ec", "chal", "stack", "hess", "environment", "el", "fen", "opt", "ctx", "esi", "esm"], "l": ["ln", "m", "nl", "lin", "d", "fl", "t", "level", "lc", "g", "source", "dl", "lp", "h", "x", "lang", "lit", "loc", "v", "o", "ul", "w", "layer", "ll", "la", "p", "lr", "kl", "z", "u", "s", "e", "li", "k", "b", "j", "L", "n", "f", "length", "line", "rl", "c", "shell", "url", "il", "ol", "lu", "ell", "sl", "ls", "al", "lb", "el", "len"], "dest": ["future", "proc", "dist", "delete", "priv", "bound", "other", "loc", "dev", "temp", "pl", "end", "attr", "text", "transform", "Dest", "class", "prop", "destroy", "st", "comb", "south", "head", "vision", "done", "slice", "d", "seed", "cdn", "home", "sup", "lc", "front", "lower", "di", "txt", "dir", "session", "grad", "img", "resource", "du", "data", "wb", "b", "inst", "origin", "url", "route", "gen", "cont", "uv", "wd", "path", "gz", "config", "again", "source", "null", "lit", "secure", "master", "output", "desc", "dep", "diff", "usr", "uc", "tmp", " destination", "shift", "name", "ident", "later", "v", "gl", "de", "feat", "sign", "trans", "store", "dat", "dc", "norm", "target", "ssl", "rest", "coord", "opt", "start"], "src": ["rib", "proc", "remote", "bc", "dist", "fl", "low", "image", "sth", "project", "gin", "loc", "ul", "rb", "cb", "sn", "sc", "sl", "sur", "sub", "ruby", "st", "vision", "slice", "sync", "rc", "iv", "sup", "lc", "front", "req", "sr", "img", "resource", "s", "b", "inst", "length", "url", "r", "ource", "support", "username", "filename", "sys", "gz", "config", "source", "null", "lit", "gn", "view", "download", "sec", "desc", "sb", "gb", "rl", "rob", "sh", "SOURCE", "sel", "cur", "bl", "RC", "connect", "uc", "hl", "stream", "back", "uri", "gl", "feat", "nil", "target", "ssl", "rest", "start"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "id", "ini", "gi", "iu", "my", "io", "mu", "ci", "x", "di", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "z", "p", "e", "fi", "mi", "li", "b", "ix", "j", "L", "n", "f", "phi", "ti", "ip", "c", "ji", "pi", "bi", "ri", "zi", "y", "index"]}}
{"project": "qemu", "commit_id": "0d2cd785ef1282b14687f9f7f4b63ae4a2430be3", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949, "substitutes": {"path": ["call", "location", "format", "ath", "xml", "sync", "enc", "config", "id", "code", "child", "name", "api", "row", "test", "image", "ref", "str", "method", "raw", "model", "full", "dest", "key", "error", "uri", "value", "patch", "loc", "request", "step", "col", "pass", "clean", "view", "p", "temp", "resource", "handler", "desc", "match", "pointer", "success", "axis", "mode", "Path", "parent", "url", "PATH", "route", "inner", "type", "text", "transform", "param", "pattern", "pat", "prefix", "node", "index", "ith"], "recurse": ["recursive", "Recieve", " recursion", "rursion", "recursion", "curse", "Recursive", " recursive", "cieve", "recursed", "cursed", "Recurse", "cursive", "recieve", "rursive", "rursed", "rurse", "Recursed", "Recursion", " recieve", " recursed"], "child_path": ["child_name", "childfulpath", "child_request", "parent_ath", "child_pointer", "child___request", "parent_full", "childfulrow", "childsath", "childfulpointer", "child_full", "child___name", "childsrow", "parent_name", "parent_pointer", " childspointer", "child_ath", "childspointer", " child_prop", "childspath", " childspath", " childsrow", "child___pointer", " child_child", " childsath", "childfulath", "child_prop", " child_pointer", "parent_path", "child_child", " child_ath", " child_row", "parent_request", "child___path", "child_row"], "response": ["reply", "example", "queue", "array", "service", "xml", "received", "complete", "object", "successful", "child", "def", "connection", "api", "respond", "answer", "image", "os", "status", "err", "sequence", "model", "onse", "server", "error", "value", "uri", "output", "tree", "request", "o", "document", "view", "version", "dict", "e", "resource", "collection", "success", "data", "site", "f", "result", "parent", "json", "property", "route", "feed", "given", "reason", "body", "application", "Response", "resp", "respons", "graph", "r", "host", "su", "react", "relation", "message"], "tuple": ["taple", "Turtle", " ticket", "taken", "tutor", "pticket", "tuesday", " turtle", "torachment", " taken", "tauple", "artple", "ptple", "Ticket", "typle", "Tickle", "turtle", "protoutine", "tple", "tenoutine", "taicle", "ytutor", "tautor", "protple", "Tachment", "ptuple", "tenple", "artrie", "ytictionary", "toruple", "tachment", "taque", "ticle", "taoutine", "tyrie", "torickle", "protque", "ticket", "taictionary", " tachment", "proticle", "tutable", "mictionary", "protutor", "tictionary", " tictionary", "toraken", "tyuple", "ytuple", " tickle", "muple", " tuesday", "Tictionary", "ytque", "ptutable", "pturtle", "tickle", "tque", "Tuple", "Tuesday", "tenicle", "trie", "Taken", "protictionary", "protuple", "muesday", "toutine", "ptickle", "ptrie", "tyutable", "artuple", "tenuple", "mickle", "artutable"], "list": ["call", "self", "part", "queue", "array", "batch", "l", "val", "child", "range", "name", "g", "lc", "test", "pool", "ml", "listed", "sequence", "session", "server", "table", "LIST", "chain", "tree", "client", "lists", "ul", "List", "parse", "ll", "p", "la", "collection", "li", "data", "base", "result", "parent", "type", "out", "all", "coll", "cache", "el", "cl"], "entry": ["card", "ge", "record", "insert", "part", "array", "id", "search", "enter", "object", "child", "range", "row", "connection", "event", "ie", "comment", "key", "server", "error", "member", "element", "obj", "term", "parse", "se", "e", "info", "data", "ries", "reader", "result", "line", "address", "query", "item", "feed", "ry", "nt", "r", "cell", "archive", "Entry", "index"], "prop": ["vec", "proc", "part", "config", "id", "val", "priv", "pt", "name", "lc", "option", "ref", "arg", "lit", "key", "loc", "pred", "value", "ps", "feat", "col", "p", "info", "comp", "pb", "data", "op", "property", "line", "rop", "type", "attr", "pro", "cp", "Prop", "field", "param", "pr", "properties", "xy", "pos", "num", "opt"]}}
{"project": "FFmpeg", "commit_id": "482ee63641f4fa50f017538af384aadbceee7a18", "target": 1, "func": "static int thp_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    ThpDemuxContext *thp = s->priv_data;\n\n    AVStream *st;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n\n\n    /* Read the file header.  */\n\n                           avio_rb32(pb); /* Skip Magic.  */\n\n    thp->version         = avio_rb32(pb);\n\n\n\n                           avio_rb32(pb); /* Max buf size.  */\n\n                           avio_rb32(pb); /* Max samples.  */\n\n\n\n    thp->fps             = av_d2q(av_int2float(avio_rb32(pb)), INT_MAX);\n\n    thp->framecnt        = avio_rb32(pb);\n\n    thp->first_framesz   = avio_rb32(pb);\n\n                           avio_rb32(pb); /* Data size.  */\n\n\n\n    thp->compoff         = avio_rb32(pb);\n\n                           avio_rb32(pb); /* offsetDataOffset.  */\n\n    thp->first_frame     = avio_rb32(pb);\n\n    thp->last_frame      = avio_rb32(pb);\n\n\n\n    thp->next_framesz    = thp->first_framesz;\n\n    thp->next_frame      = thp->first_frame;\n\n\n\n    /* Read the component structure.  */\n\n    avio_seek (pb, thp->compoff, SEEK_SET);\n\n    thp->compcount       = avio_rb32(pb);\n\n\n\n    /* Read the list of component types.  */\n\n    avio_read(pb, thp->components, 16);\n\n\n\n    for (i = 0; i < thp->compcount; i++) {\n\n        if (thp->components[i] == 0) {\n\n            if (thp->vst != 0)\n\n                break;\n\n\n\n            /* Video component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* The denominator and numerator are switched because 1/fps\n\n               is required.  */\n\n            avpriv_set_pts_info(st, 64, thp->fps.den, thp->fps.num);\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_id = CODEC_ID_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->width = avio_rb32(pb);\n\n            st->codec->height = avio_rb32(pb);\n\n            st->codec->sample_rate = av_q2d(thp->fps);\n\n            thp->vst = st;\n\n            thp->video_stream_index = st->index;\n\n\n\n            if (thp->version == 0x11000)\n\n                avio_rb32(pb); /* Unknown.  */\n\n        } else if (thp->components[i] == 1) {\n\n            if (thp->has_audio != 0)\n\n                break;\n\n\n\n            /* Audio component.  */\n\n            st = avformat_new_stream(s, NULL);\n\n            if (!st)\n\n                return AVERROR(ENOMEM);\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->codec_id = CODEC_ID_ADPCM_THP;\n\n            st->codec->codec_tag = 0;  /* no fourcc */\n\n            st->codec->channels    = avio_rb32(pb); /* numChannels.  */\n\n            st->codec->sample_rate = avio_rb32(pb); /* Frequency.  */\n\n\n\n            avpriv_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n            thp->audio_stream_index = st->index;\n\n            thp->has_audio = 1;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12951, "substitutes": {"s": ["sys", "ses", "service", "t", "sg", "ins", "sym", "g", "cs", "S", "sp", "os", "sr", "si", "sq", "aps", "ps", "ss", "p", "e", "sam", "se", "sb", "sf", "b", "n", "f", "gs", "spec", "c", "ns", "sn", "sc", "ssl", "sci", "sv", "sl", "services", "ds", "r", "sa", "su", "src", "ls", "sis", "ts", "us", "ks"], "ap": ["aram", "map", "as", "amp", "array", "ai", "pac", "mp", "api", "sp", "pp", "aps", "av", "pa", "arp", "au", "att", "am", "AP", "pm", "ac", "ams", "cap", "attr", "ast", "cp", "ar", "al"], "thp": [" thfp", "uthf", "stht", "ethe", "ftw", "aklp", "ethn", "uthpe", "athcp", "phfp", "ethcp", "htjp", "thv", "althp", "ithpo", "ithtp", " thpc", "ethv", "hell", "pathp", "ithf", "Thps", "ntlp", "helt", "othlp", "rahpc", "sthf", "thps", "ethw", "whg", "whf", "thpi", " thw", "whpc", " thg", "helpe", "ethpi", "ithpc", "ntn", "whpe", "thinm", "sthn", "akpe", " thm", "thinpe", "sthlp", "thcp", "thjp", "akp", "othpc", " the", "ethp", "sthtp", "pathop", " thv", " thwp", "harpe", " thf", "ethop", "htp", "rahp", "tht", "thf", "sthpe", "althtp", "ithn", "thg", "ethper", " thper", " thip", "ithfp", "ethf", "ftp", "whlp", "ethk", "ethl", "ethlp", "ntpe", "whl", "thm", "phn", "ithop", "harl", "ithlp", " thcp", "ethg", "ithe", "ethps", "whp", "patht", "thwp", "sthps", "htpe", "athpc", "ftf", "Thp", "sthpo", " thlp", "athp", "othp", " thpe", "athl", "thfp", "help", "sthpc", "ithm", "thpc", "thk", "thpe", "thip", "thpo", "ethm", "ithip", "thlp", "uthp", "sthv", "phl", "thbp", "thper", "thop", "thn", "pathps", "the", "akwp", "rahk", "ethpc", "hellp", "sthper", " thn", "php", "rahpi", " thk", "ithl", "thtp", " thl", "sthp", "althpo", "Thbp", "htm", " thpi", "thinop", "hart", "othf", "thw", "thinp", "ithpe", "helwp", "althn", "ethjp", "ethpe", " tht", "rahl", "itht", "harp", "sthop", "rahip", "etht", "Thpc", " thps", "thl", "ithp", " thjp", " thbp", "ntp", "uthpc", "ftpe", "ethbp"], "st": ["bt", "sta", "ft", "part", "amp", "t", "rd", "art", "put", "pc", "l", "pt", "td", "sp", "ust", "ste", "sth", "std", "sw", "pp", "str", "sr", "nd", "ct", "ld", "fr", "ss", "irst", "obj", "ut", "bl", "stop", "sec", "ST", "kt", "sb", "sf", "sd", "St", "inst", "est", "sty", "pe", "sn", "sc", "nt", "stim", "sv", "sl", "rt", "ast", "stress", "sh", "sa", "src", "rest", "ist", "ts", "et", "cl", "sts", "ost", "start"], "pb": ["plug", "xb", "typ", "pkg", "uc", "bc", "cv", "tmp", "pc", "mp", "vp", "jp", "fb", "phys", "bb", "api", "prot", "ub", "uf", "pg", "pit", "hub", "lp", "txt", "wikipedia", "abc", "fp", "pid", "apy", "rpm", "platform", "phrase", "bp", "pd", "summary", "plugin", "p", "bot", "bm", "rb", "pl", "pa", "sb", "wb", "b", "http", "bf", "wp", "gb", "bh", "ab", "pm", "bps", "lab", "cb", "eb", "rob", "PB", "dp", "cp", "db", "um", "src", "lb", "prop", "ppa", "fc", "tp", "cpp"], "i": ["hi", "qi", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "code", "gi", "ini", "a", "l", "sup", "ci", "di", "x", "si", "ie", "ii", "key", "v", "gu", "clip", "yi", "u", "p", "e", "fi", "mini", "mi", "li", "k", "b", "ix", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "diff", "counter", "is", "inner", "pi", "chi", "loop", "uli", "bi", "ri", "pos", "num", "zi", "y", "abi", "index"]}}
{"project": "qemu", "commit_id": "97f3ad35517e0d02c0149637d1bb10713c52b057", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968, "substitutes": {"rdma": ["ridmas", "rdmad", "ridmma", "raftsta", "ridqa", "rxmma", "rgmas", "rgma", "ndma", "ldta", "ldama", "raftmma", "rrta", "rxqa", "ldmas", "rdqa", "rdama", "rlda", "rnma", "rrama", "rlsta", "vrmar", "raftda", "rtmma", "rdea", "rgea", "ldmma", "ndmas", "raftma", "rtmas", "rtma", "rrda", "rdmar", "rlma", "rgda", "ridma", "rtama", "rlmma", "rnea", "ndda", "vrda", "vrmas", "rdda", "rtta", "rxma", "ldmar", "rdsta", "rtsta", "rdmas", "ldda", "vrma", "ldqa", "rtmar", "rdta", "ldma", "rtda", "rnmas", "rnda", "rtea", "rxmas", "rnmad", "rtmad", "rrma", "ndmad", "rdmma"], "block_name": ["blockingname", "block__name", "block_names", "byte_name", "byte_names", "blockfullclass", "byte_def", "blockfullspec", " block_number", "block__size", "blockingdef", "block___spec", "block_size", "byte_spec", "blockfulldescription", "block___name", "block_class", "plugin_spec", "blockfullname", " block_size", "block_def", "block__number", "block___class", "block_number", "blockingnames", "block_description", "block___description", "plugin_class", "plugin_description", "blockingspec", "block_spec", "plugin_name"], "host_addr": ["block_addr", "host_off", "hostingad", "host_index", "hostingoffset", "hostacindex", "server_name", "hostalindex", "host_address", "hostingname", "hostingaddress", "hostalslot", "block_index", "host_name", "hostingaddr", " host_nr", " host_ad", "hostacaddress", "block_slot", "hostingnr", "host6addr", "host6address", "hostipindex", "hostacaddr", "hostipaddr", "hostingoff", "hostaladdress", " host_offset", "host_slot", "hostipslot", "server_addr", "hostaladdr", "host_ad", "host_offset", "server_address", "host_nr", "host6index", "hostipaddress", "host6size", "block_size", "host_size", "hostacsize", "server_off", "block_address"], "block_offset": ["block_prefix", "block_padding", "block_addr", "block___size", " block_prefix", "block___padding", "block_length", "byte_size", "byte_padding", "byte_offset", "block___addr", "block_size", "byte_addr", " block_size", "block___offset", " block_length"], "length": ["zip", "path", "ch", "part", "slice", "build", "l", "code", "split", "style", "shape", "range", "name", "weight", "section", "h", "capacity", "sequence", "lang", "position", "live", "key", "limit", "form", "size", "p", "time", "base", "Length", "count", "th", "padding", "address", "line", "url", "number", "end", "pull", "type", "offset", "body", "load", "angle", "duration", "seq", "lock", "len", "depth", "ength", "height", "index"], "local": ["remote", "partial", "small", "tx", "self", "build", "shared", "l", "private", "back", "external", "child", "current", "home", "standard", "container", "public", "new", "final", "event", "pool", "missing", "lang", "foreign", "user", "model", "update", "full", "loc", "session", "valid", "server", "package", "client", "same", "pass", "group", "clean", "parse", "instance", "plugin", "joined", "pack", "temp", "http", "base", "Local", "list", "parent", "custom", "state", "global", "single", "inner", "all", "link", "get", "wall", "initial", "lock", "el", "util", "post", "join", "node"], "block": ["map", "blocks", "build", "child", "def", "label", "pre", "image", "new", "event", "panel", "pool", "other", "raw", "model", "loc", "frame", "base", "flow", "line", "out", "work", "tag", "lock", "num", "copy", "off", "index", "call", "bin", "part", "sync", "container", "full", "comment", "key", "error", "session", "script", "check", "group", "clean", "instance", "pack", "byte", "BL", "ip", "number", "clock", "link", "exec", "cache", "header", "condition", "random", "config", "un", "style", "builder", "Block", "section", "null", "option", "unit", "buffer", "init", "update", "view", "info", "http", "none", "point", "address", "global", "close", "type", "load", "wall", "bl", "prev", "post", "cl", "bit", "node", "channel", "record", "before", "object", "name", "row", "user", "patch", "chain", "request", "open", "plugin", "match", "parent", "outer", "ban", "join"], "old": ["before", "small", "existing", "part", "slice", "build", "array", "val", "object", "orig", "and", "l", "pre", "or", "current", "row", "low", "new", "OLD", "original", "other", "arg", "update", "full", "model", "ld", "buff", "o", "obj", "clean", "an", "ind", "p", "e", "where", "base", "from", "f", "ore", "att", "state", "diff", "inner", "gen", "now", "last", "ard", "Old", "el", "older", "prev", "post", "handle"], "x": ["xb", "m", "tx", "t", "xi", "id", "code", "i", "val", "ww", "xe", "name", "ex", "wx", "h", "fx", "sw", "xt", "xa", "xp", "v", "w", "dx", "z", "ady", "u", "p", "e", "rx", "k", "ix", "b", "base", "j", "ext", "f", "xx", "ax", "c", "xs", "pe", "X", "sex", "wa", "r", "lex", "xc", "work", "xxx", "xy", "num", "y", "max", "index", "ux"], "nb_blocks": ["nb64works", "nb__chains", "nb_chains", "nn_blocks", "nb_locks", "b_ins", "nb_works", "nb__images", "b_classes", "nb___images", "nb_images", "nbJbars", "nb54works", "nbJrooms", "b_bars", "nbJclasses", "nb___quarters", "nb_heads", "nb_boxes", "nbJlocks", "nb__frames", "nr__blocks", "nn54chains", "b_blocks", "nb64heads", "nbJins", "nn_heads", "nb54heads", "nb_bars", "nr__maps", "nb64blocks", "num_rooms", "nn_chains", "num_chains", "nr__frames", "nr_images", "num_frames", "nb___blocks", "nr__images", "nb_quarters", "nb__locks", "nn54works", "nbJboxes", "nb_maps", "nr_blocks", "num_images", "nr_maps", "nb__maps", "nb_classes", "num_quarters", "num_locks", "nb_rooms", "num_blocks", "nb__blocks", "nr_frames", "nb54chains", "nb64chains", "nbJblocks", "nn_works", "nn54blocks", "nb_frames", "nb___locks", "num_boxes", "nn54heads", "nb_ins", "nb54blocks"]}}
{"project": "qemu", "commit_id": "65f82df0d7a71ce1b10cd4c5ab08888d176ac840", "target": 1, "func": "process_tx_desc(E1000State *s, struct e1000_tx_desc *dp)\n\n{\n\n    uint32_t txd_lower = le32_to_cpu(dp->lower.data);\n\n    uint32_t dtype = txd_lower & (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D);\n\n    unsigned int split_size = txd_lower & 0xffff, bytes, sz, op;\n\n    unsigned int msh = 0xfffff, hdr = 0;\n\n    uint64_t addr;\n\n    struct e1000_context_desc *xp = (struct e1000_context_desc *)dp;\n\n    struct e1000_tx *tp = &s->tx;\n\n\n\n    if (dtype == E1000_TXD_CMD_DEXT) {\t// context descriptor\n\n        op = le32_to_cpu(xp->cmd_and_length);\n\n        tp->ipcss = xp->lower_setup.ip_fields.ipcss;\n\n        tp->ipcso = xp->lower_setup.ip_fields.ipcso;\n\n        tp->ipcse = le16_to_cpu(xp->lower_setup.ip_fields.ipcse);\n\n        tp->tucss = xp->upper_setup.tcp_fields.tucss;\n\n        tp->tucso = xp->upper_setup.tcp_fields.tucso;\n\n        tp->tucse = le16_to_cpu(xp->upper_setup.tcp_fields.tucse);\n\n        tp->paylen = op & 0xfffff;\n\n        tp->hdr_len = xp->tcp_seg_setup.fields.hdr_len;\n\n        tp->mss = le16_to_cpu(xp->tcp_seg_setup.fields.mss);\n\n        tp->ip = (op & E1000_TXD_CMD_IP) ? 1 : 0;\n\n        tp->tcp = (op & E1000_TXD_CMD_TCP) ? 1 : 0;\n\n        tp->tse = (op & E1000_TXD_CMD_TSE) ? 1 : 0;\n\n        tp->tso_frames = 0;\n\n        if (tp->tucso == 0) {\t// this is probably wrong\n\n            DBGOUT(TXSUM, \"TCP/UDP: cso 0!\\n\");\n\n            tp->tucso = tp->tucss + (tp->tcp ? 16 : 6);\n\n        }\n\n        return;\n\n    } else if (dtype == (E1000_TXD_CMD_DEXT | E1000_TXD_DTYP_D)) {\n\n        // data descriptor\n\n        if (tp->size == 0) {\n\n            tp->sum_needed = le32_to_cpu(dp->upper.data) >> 8;\n\n        }\n\n        tp->cptse = ( txd_lower & E1000_TXD_CMD_TSE ) ? 1 : 0;\n\n    } else {\n\n        // legacy descriptor\n\n        tp->cptse = 0;\n\n    }\n\n\n\n    if (vlan_enabled(s) && is_vlan_txd(txd_lower) &&\n\n        (tp->cptse || txd_lower & E1000_TXD_CMD_EOP)) {\n\n        tp->vlan_needed = 1;\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header),\n\n                      le16_to_cpup((uint16_t *)(s->mac_reg + VET)));\n\n        cpu_to_be16wu((uint16_t *)(tp->vlan_header + 2),\n\n                      le16_to_cpu(dp->upper.fields.special));\n\n    }\n\n        \n\n    addr = le64_to_cpu(dp->buffer_addr);\n\n    if (tp->tse && tp->cptse) {\n\n        hdr = tp->hdr_len;\n\n        msh = hdr + tp->mss;\n\n        do {\n\n            bytes = split_size;\n\n            if (tp->size + bytes > msh)\n\n                bytes = msh - tp->size;\n\n\n\n            bytes = MIN(sizeof(tp->data) - tp->size, bytes);\n\n            pci_dma_read(&s->dev, addr, tp->data + tp->size, bytes);\n\n            if ((sz = tp->size + bytes) >= hdr && tp->size < hdr)\n\n                memmove(tp->header, tp->data, hdr);\n\n            tp->size = sz;\n\n            addr += bytes;\n\n            if (sz == msh) {\n\n                xmit_seg(s);\n\n                memmove(tp->data, tp->header, hdr);\n\n                tp->size = hdr;\n\n            }\n\n        } while (split_size -= bytes);\n\n    } else if (!tp->tse && tp->cptse) {\n\n        // context descriptor TSE is not set, while data descriptor TSE is set\n\n        DBGOUT(TXERR, \"TCP segmentaion Error\\n\");\n\n    } else {\n\n\n        pci_dma_read(&s->dev, addr, tp->data + tp->size, split_size);\n\n        tp->size += split_size;\n\n    }\n\n\n\n    if (!(txd_lower & E1000_TXD_CMD_EOP))\n\n        return;\n\n    if (!(tp->tse && tp->cptse && tp->size < hdr))\n\n        xmit_seg(s);\n\n    tp->tso_frames = 0;\n\n    tp->sum_needed = 0;\n\n    tp->vlan_needed = 0;\n\n    tp->size = 0;\n\n    tp->cptse = 0;\n\n}", "idx": 12984, "substitutes": {"bytes": ["blocks", "units", "os", "files", "items", "ps", "flags", "eps", "data", "seconds", "byte", "frames", "gs", "bits", "days", "ns", "bps", "hops", "outs", "ops", "ds", "fee", "seq", "ips", "ls"], "sz": ["Sce", "lsize", "sce", "Size", " scl", " sce", "lsz", " size", "scl", "Sz", "lsce", "Scl", "lscl", "size"], "op": ["oper", "oid", "proc", "OP", "root", "ob", "cop", "top", "up", "or", "sp", "operation", "orb", "option", "pp", "pop", "cmp", "ap", "init", "operator", "update", "loc", "error", "app", "google", "o", "set", "open", "opus", "oc", "p", "oop", "http", "iop", "comp", "omp", "mode", "opp", "dot", "wp", "ocr", "OPER", "ip", "route", "Op", "cat", "type", "gen", "cmd", "ep", "ops", "cp", "om", "ips", "hop", "dr", "pos", "num", "copy", "off", "prev", "post", "opt", "opy", "bit"], "addr": ["args", "transfer", "port", "map", "tx", "extra", "apper", "sp", "mx", "pack", "nc", "data", "ptr", "arp", "wp", "address", "ip", " ip", "parser", "route", "rt", "dp", "mac", "src", "opt", "ctx", "gp"], "xp": ["zip", "XP", "adj", "osi", "hp", "tx", "Pg", "esp", "qa", "xml", "python", "pkg", "xe", "jp", "lvl", "vp", "fm", "pg", "wx", "fx", "lp", "dj", "isp", "project", "txt", "xt", "fp", "rpm", "imp", "bp", "p", "pipe", "eps", "nc", "cli", "yp", "sf", "ix", "qt", "omp", "expr", "wp", "xs", "axe", "php", "dp", "org", "cp", "ppo", "cpp", "exec", "xc", "hw", "xy", "hop", "opy", "ppa", "dm", "ctx", "asm", "esm", "gp"], "tp": ["port", "vp", "prot", "gt", "lp", "sth", "cmp", "fp", "tm", "np", "arp", "bps", "end", "tf", "TP", "sv", "cp", "typ", "d", "t", "id", "ctr", "api", "g", "tg", "txt", "tap", "bp", "mt", "s", "pack", "byte", "ip", "dt", "vt", "transfer", "sys", "tk", "mp", "ta", "sp", "http", "tc", "qt", "dp", "prefix", "php", "gp", "hp", "pkg", "_", "tmp", "jp", "pt", "utils", "py", "plugin", "p", "pb", "cli", "wp", "tif", "parser", "ht", "ssl", "all"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_input_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)\n\n{\n\n    VirtIOInputPCI *vinput = VIRTIO_INPUT_PCI(vpci_dev);\n\n    DeviceState *vdev = DEVICE(&vinput->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));\n\n    /* force virtio-1.0 */\n\n    vpci_dev->flags &= ~VIRTIO_PCI_FLAG_DISABLE_MODERN;\n\n    vpci_dev->flags |= VIRTIO_PCI_FLAG_DISABLE_LEGACY;\n\n    object_property_set_bool(OBJECT(vdev), true, \"realized\", errp);\n\n}\n", "idx": 13001, "substitutes": {"vpci_dev": ["vpcifdev", "vpcisdev", "vpci2conf", "vpccifdevice", "vpcci_dev", "vpci_pub", "vpcivdev", "vpi_dist", "vpci5dev", "vpix_debug", "vpci2dev", "vpcivdist", "vpci_device", "vpci_rc", "vpdi_conf", "vpc_device", "vpci1debug", "vpccifpub", "vpcifpub", "vpci2device", "vpcivdevice", "vpci1dev", "vpcivdriver", "vpci_priv", "vpci_ver", "vpdi_device", "vpdi_dev", "vpci5rc", "vpc_rc", "vpci_development", "vpci5engine", "vpci_engine", "vpci1development", "vpci_driver", "vpcci_pub", "vpix_dev", "vpi_dev", "vpcisengine", "vpi_driver", "vpc_engine", "vpci_dist", "vpix_development", "vpci1ver", "vpi_device", "vpdi_priv", "vpcifdevice", "vpix_ver", "vpcisdevice", "vpci_debug", "vpccifdev", "vpci2priv", "vpci_conf", "vpcci_device", "vpcisrc", "vpc_dev", "vpci5device"], "errp": ["errop", " errf", " errop", "Erop", "erfp", "errf", "Erf", " errcp", "errfp", "ercp", "errP", " errfp", " errP", "erp", "erP", "Erp", "errcp", "erf", "ErP", "erop", "Erfp", "Ercp"], "vinput": ["vanstruct", "vanconst", "construct", "conconst", "vanper", "vidper", "evinper", "vidcut", "evincut", "evinsec", "conput", "evinput", "vancut", "vinper", "kinconst", "kinPUT", "kinput", "vincut", "vanput", "vinconst", "conPUT", "vinstruct", "vansec", "vidput", "vinsec", "vidsec", "kinstruct", "vanPUT", "vinPUT"], "vdev": ["qdev", " vdiv", "vdef", "rdevice", "pprop", "pev", "rconf", "lvdevice", " vev", "lvprop", "lvdiv", "qconf", "pdiv", "vdevelopment", "evdevelopment", "evdiv", "qev", "qdevice", "vdiv", "evdev", "rbus", "lvdev", "pdev", "evdevice", "vprop", " vdevelopment", "pbus", "vdevice", "pdevice", "rdev", " vdevice", "vbus", "qbus", "pconf", "vconf", "pdevelopment", "qdef", " vdef", "pdef", " vprop", "vev"]}}
{"project": "qemu", "commit_id": "3f66f764ee25f10d3e1144ebc057a949421b7728", "target": 0, "func": "static void test_visitor_out_string(TestOutputVisitorData *data,\n\n                                    const void *unused)\n\n{\n\n    char *string = (char *) \"Q E M U\";\n\n    Error *err = NULL;\n\n    QObject *obj;\n\n\n\n    visit_type_str(data->ov, &string, NULL, &err);\n\n    g_assert(!err);\n\n\n\n    obj = qmp_output_get_qobject(data->qov);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QSTRING);\n\n    g_assert_cmpstr(qstring_get_str(qobject_to_qstring(obj)), ==, string);\n\n\n\n    qobject_decref(obj);\n\n}\n", "idx": 13002, "substitutes": {"data": ["database", "record", "draw", "ui", "done", "input", "d", "batch", "config", "code", "i", "object", "da", "style", "def", "connection", "test", "new", "this", "missing", "str", "module", "model", "writer", "session", "script", "o", "ad", "stage", "la", "p", "info", "base", "reader", "result", "parent", "dat", "parser", "dt", "Data", "inner", "results", "DATA", "exec", "ds", "db", "dd", "window"], "unused": ["UNusing", "UNused", "unusing", "Unuse", "Unchecked", "unchecked", "Unusing", "UNuse", "unuse", " unusing", "UNchecked", " unuse", "Unused", " unchecked"], "err": ["ln", "rr", "fer", "fy", "msg", "Error", "er", "req", "rn", "str", "ref", "init", "aster", "error", "Er", "fr", "rh", "var", "cr", "der", "ind", "mr", "e", "ir", "fi", "exc", "found", "ler", "result", "raise", "spec", "inc", "arr", "cb", "iter", "resp", "r", "finder", "pr", "nr", "ar", "dr", "rage", "cur", "order", "ise"], "obj": ["args", "adj", "alt", "aj", "po", "ob", "tmp", "art", "t", "so", "jp", "val", "id", "object", "pt", "oa", "io", "oi", "name", "api", "ex", "act", "orb", "os", "nb", "x", "str", "ref", "js", "ie", "eff", "fn", "bj", "br", "Obj", "o", "lib", "p", "bot", "img", "fi", "rb", "instance", "sb", "b", "j", "inst", "n", "parent", "arr", "bo", "cb", "nt", "elt", "rt", "coll", "db", "src", "el", "ctx", "node"]}}
{"project": "qemu", "commit_id": "d1048bef9df0aacde9a54bf9b5b97a6e10950d8c", "target": 0, "func": "static void pc_machine_set_vmport(Object *obj, bool value, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    pcms->vmport = value;\n\n}\n", "idx": 13012, "substitutes": {"obj": ["func", "args", "po", "ob", "tmp", "so", "code", "object", "pt", "oa", "api", "act", "orb", "os", "nb", "module", "ref", "Obj", "o", "office", "instance", "p", "img", "boot", "pl", "b", "base", "j", "inst", "bh", "cb", "attr", "objects", "org", "od", "src", "emb", "pos", "core", "opt", "ctx", "node"], "value": ["action", "paid", "enabled", "done", "complete", "service", "val", "current", "name", "values", "VALUE", "test", "null", "status", "accept", "update", "slave", "v", "valid", "pause", "w", "active", "size", "Value", "primary", "b", "mode", "property", "result", "state", "down", "type", "bo", "function", "allowed", "change", "selected", "create", "age", "valued", "off", "message"], "errp": ["errr", "errpc", "erp", " errpc", "rrp", " errr", "rrpc", "erfp", "errfp", "rrfp", "erpc", "rrr", " errfp", "err"], "pcms": ["mcMS", "pcws", "PCMS", "fcfs", "pcMS", "cMS", "PCms", " pcws", "PCws", "cms", " pcfs", "ucMs", "fcMS", "PCfs", "cps", "mcMs", "pcfs", "pcps", "mcps", "mcms", "ucms", "fcws", " pcMS", "pcMs", "fcms", "ucMS", "ucps", "cMs"]}}
{"project": "FFmpeg", "commit_id": "5763f675024765df8f256d8b5b01926a5fbd997d", "target": 1, "func": "static int mov_read_trak(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    int ret;\n\n\n\n    st = avformat_new_stream(c->fc, NULL);\n\n    if (!st) return AVERROR(ENOMEM);\n\n    st->id = c->fc->nb_streams;\n\n    sc = av_mallocz(sizeof(MOVStreamContext));\n\n    if (!sc) return AVERROR(ENOMEM);\n\n\n\n    st->priv_data = sc;\n\n    st->codec->codec_type = AVMEDIA_TYPE_DATA;\n\n    sc->ffindex = st->index;\n\n\n\n    if ((ret = mov_read_default(c, pb, atom)) < 0)\n\n        return ret;\n\n\n\n    /* sanity checks */\n\n    if (sc->chunk_count && (!sc->stts_count || !sc->stsc_count ||\n\n                            (!sc->sample_size && !sc->sample_count))) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"stream %d, missing mandatory atoms, broken header\\n\",\n\n               st->index);\n\n        return 0;\n\n    }\n\n\n\n    fix_timescale(c, sc);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, sc->time_scale);\n\n\n\n    mov_build_index(c, st);\n\n\n\n    if (sc->dref_id-1 < sc->drefs_count && sc->drefs[sc->dref_id-1].path) {\n\n        MOVDref *dref = &sc->drefs[sc->dref_id - 1];\n\n        if (mov_open_dref(&sc->pb, c->fc->filename, dref, &c->fc->interrupt_callback,\n\n            c->use_absolute_path, c->fc) < 0)\n\n            av_log(c->fc, AV_LOG_ERROR,\n\n                   \"stream %d, error opening alias: path='%s', dir='%s', \"\n\n                   \"filename='%s', volume='%s', nlvl_from=%d, nlvl_to=%d\\n\",\n\n                   st->index, dref->path, dref->dir, dref->filename,\n\n                   dref->volume, dref->nlvl_from, dref->nlvl_to);\n\n    } else {\n\n        sc->pb = c->fc->pb;\n\n        sc->pb_is_copied = 1;\n\n    }\n\n\n\n    if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (!st->sample_aspect_ratio.num &&\n\n            (st->codec->width != sc->width || st->codec->height != sc->height)) {\n\n            st->sample_aspect_ratio = av_d2q(((double)st->codec->height * sc->width) /\n\n                                             ((double)st->codec->width * sc->height), INT_MAX);\n\n        }\n\n\n\n#if FF_API_R_FRAME_RATE\n\n        if (sc->stts_count == 1 || (sc->stts_count == 2 && sc->stts_data[1].count == 1))\n\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den,\n\n                      sc->time_scale, sc->stts_data[0].duration, INT_MAX);\n\n#endif\n\n    }\n\n\n\n    // done for ai5q, ai52, ai55, ai1q, ai12 and ai15.\n\n    if (!st->codec->extradata_size && st->codec->codec_id == AV_CODEC_ID_H264 &&\n\n        TAG_IS_AVCI(st->codec->codec_tag)) {\n\n        ret = ff_generate_avci_extradata(st);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n\n\n    switch (st->codec->codec_id) {\n\n#if CONFIG_H261_DECODER\n\n    case AV_CODEC_ID_H261:\n\n#endif\n\n#if CONFIG_H263_DECODER\n\n    case AV_CODEC_ID_H263:\n\n#endif\n\n#if CONFIG_MPEG4_DECODER\n\n    case AV_CODEC_ID_MPEG4:\n\n#endif\n\n        st->codec->width = 0; /* let decoder init width/height */\n\n        st->codec->height= 0;\n\n        break;\n\n    }\n\n\n\n    /* Do not need those anymore. */\n\n    av_freep(&sc->chunk_offsets);\n\n    av_freep(&sc->stsc_data);\n\n    av_freep(&sc->sample_sizes);\n\n    av_freep(&sc->keyframes);\n\n    av_freep(&sc->stts_data);\n\n    av_freep(&sc->stps_data);\n\n    av_freep(&sc->elst_data);\n\n    av_freep(&sc->rap_group);\n\n\n\n    return 0;\n\n}\n", "idx": 13024, "substitutes": {"c": ["m", "ch", "mc", "uc", "bc", "cm", "self", "ca", "enc", "t", "rc", "cc", "pc", "l", "config", "C", "lc", "cs", "ci", "g", "cit", "cn", "this", "cy", "con", "abc", "ct", "v", "conf", "cr", "cd", "u", "p", "e", "nc", "k", "co", "cus", "tc", "b", "f", "arc", "cu", "dc", "jc", "cat", "anc", "ac", "ce", "cf", "cod", "ic", "coll", "icc", "cp", "com", "vc", "xc", "cache", "ec", "cur", "fc", "cl", "ctx"], "pb": ["xb", "typ", "pkg", "uc", "bc", "cm", "ob", "tmp", "pc", "mp", "bb", "fb", "utils", "uf", "prot", "lc", "api", "pg", "auc", "py", "lp", "dl", "ref", "con", "abc", "fp", "platform", "bp", "pd", "np", "summary", "metadata", "p", "ctx", "rb", "bm", "ib", "pl", "nc", "sb", "wb", "fab", "tc", "b", "pa", "bf", "lf", "gb", "wp", "ab", "bh", "pm", "bps", "dc", "anc", "cb", "lab", "PB", "dp", "cp", "icc", "db", "lb", "prop", "ppa", "fc", "cpp", "primary"], "atom": ["xb", "typ", "m", "mom", "cm", "bc", "amp", "xml", "config", "pc", "bb", "sym", "mat", "oms", "atomic", "orb", "tom", "abc", "ap", "app", "tm", "obj", "an", "arch", "tc", "op", "at", "att", "spec", "am", "ab", "ac", "attr", " parent", "com", "om", "param", "ar", " om", "num", "asm", "node"], "st": ["sta", "ft", "typ", "uc", "t", "rc", "config", "pc", "l", "stream", "back", "spect", "td", "lc", "cs", "sp", "ust", "ste", "sk", "sth", "std", "sw", "str", "sr", "nd", "ld", "ct", "storage", "ss", "cr", "step", "set", "ut", "stage", "se", "s", "ST", "sec", "nc", "sb", "sd", "sf", "St", "inst", "est", "Sc", "co", "fe", "dc", "sn", "osc", "sl", "ast", "sh", "sa", "rest", "src", "ist", "stack", "ts", "cur", "post", "cl", "sts", "ost", "start"], "sc": ["sem", "mc", "bc", "capt", "asc", "si", "loc", "imp", "ul", "scl", "spec", "com", "ga", "ec", "sub", "fc", "sync", "sche", "rc", "cc", "sup", "lc", "cs", "acc", "con", "Sc", "inst", "anc", "cont", "exec", "sa", "ch", "cv", "ca", "config", "pc", "pg", "sp", "sw", "scope", "scan", "sec", "desc", "nc", "sd", "sb", "tc", "inc", "osc", "cf", "icc", "sh", "cur", "cl", "ctx", "SC", "uc", "enc", "cer", "sq", "ss", "isc", "cr", "access", "oc", "se", "match", "cus", "dc", "esc", "sci", "usc", "src", "soc"], "ret": ["alt", "en", "reply", "rc", "val", "code", "back", "def", "gc", "rets", "fun", "status", "ref", "det", "lit", "valid", "job", "value", "pass", "ut", "mt", "rb", "desc", "success", "data", "match", "ext", "Ret", "bf", "result", " RET", "att", "reset", "arr", " Ret", "offset", "nt", "re", "out", "rt", "resp", "rep", "RET", "al", "res", "reg", "cur", "no", "run", "len", "red", "ner"], "dref": ["fdref", " dference", "pdreference", "sdref", "drel", " drol", "DRef", "Drel", "bdrev", " drev", "preference", "Dref", "prel", "dreference", "pference", "pdref", "Dreference", "drol", " dreference", "Drec", "Dre", "pdror", "pdRef", "Dror", "dror", "drec", "amdref", "fdre", "pdference", " drel", "bref", "bRef", "sdrec", "amdrol", "pRef", "prol", "amdrel", "pdrel", "bdreference", "brel", "dre", "breference", " dRef", "drev", "pref", "Drev", "bdref", "dference", "dRef", "amdreference", "sdreference", "fdreference", " dror", "sdre", "fdrec"]}}
{"project": "qemu", "commit_id": "2f9606b3736c3be4dbd606c46525c7b770ced119", "target": 1, "func": "static int buffer_empty(Buffer *buffer)\n\n{\n\n    return buffer->offset == 0;\n\n}\n", "idx": 13031, "substitutes": {"buffer": ["bridge", "transfer", "port", "interface", "context", "queue", "object", "fb", "container", "builder", "source", "reference", "border", "image", "writer", "comment", "fp", "table", "buff", "document", "loader", "buf", "data", "b", "Buffer", "reader", "result", "timer", "url", "timeout", "uffer", "iter", "command", "cache", "window", "pad", "header", "ptr"]}}
{"project": "qemu", "commit_id": "b0d768c35e08d2057b63e8e77e7a513c447199fa", "target": 1, "func": "static gboolean pty_chr_timer(gpointer opaque)\n\n{\n\n    struct CharDriverState *chr = opaque;\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (s->connected) {\n\n        goto out;\n\n    }\n\n\n\n    /* Next poll ... */\n\n    pty_chr_update_read_handler(chr);\n\n\n\nout:\n\n    s->timer_tag = 0;\n\n    return FALSE;\n\n}\n", "idx": 13035, "substitutes": {"opaque": [" opaques", "ipaques", "oppaques", "oppacity", "opatile", "hopque", "opcode", "oppaque", "oppatile", "opac", "ipque", "operacity", "hopaque", "opaques", "operaque", "opercode", "ipacity", "opacity", "ipaque", "OPacity", " opac", "operque", "OPac", "OPque", " opque", "ipcode", "opque", " opacity", "OPaque", "ipatile", "hopacity", "hopac", " opatile", " opcode"], "chr": ["schr", "echr", "CHrb", "cherb", "ichrb", "chrs", "schsr", " chrs", "chsr", "chelr", "ichrs", "echsr", "cher", "chlr", "corlr", " chra", "Chra", " chrb", "Chr", "chrb", "CHr", "chra", "Chrb", "chrf", "corrf", "chers", "CHra", "CHrs", "echlr", "corr", "echrf", "Chrs", "corsr", "schlr", "schrf", "ichlr", "ichr", "Chlr"], "s": ["secondary", "args", "sys", "ses", "m", "self", "sync", "sg", "t", "sym", "g", "cs", "S", "submit", "new", "os", "si", "js", "sq", "session", "ps", "ss", "o", "w", "u", "p", "e", "http", "sf", "b", "n", "f", "gs", "spec", "c", "ns", "stats", "ssl", "out", "ops", "r", "services", "sie", "ds", "sa", "ts", "comments", "in"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void h263_encode_init(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_uni_dc_tab();\n\n\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        \n\n        init_uni_mpeg4_rl_tab(&rl_intra, uni_mpeg4_intra_rl_bits, uni_mpeg4_intra_rl_len);\n\n        init_uni_mpeg4_rl_tab(&rl_inter, uni_mpeg4_inter_rl_bits, uni_mpeg4_inter_rl_len);\n\n\n\n        init_uni_h263_rl_tab(&rl_intra_aic, NULL, uni_h263_intra_aic_rl_len);\n\n        init_uni_h263_rl_tab(&rl_inter    , NULL, uni_h263_inter_rl_len);\n\n\n\n        init_mv_penalty_and_fcode(s);\n\n    }\n\n    s->me.mv_penalty= mv_penalty; //FIXME exact table for msmpeg4 & h263p\n\n    \n\n    s->intra_ac_vlc_length     =s->inter_ac_vlc_length     = uni_h263_inter_rl_len;\n\n    s->intra_ac_vlc_last_length=s->inter_ac_vlc_last_length= uni_h263_inter_rl_len + 128*64;\n\n    if(s->h263_aic){\n\n        s->intra_ac_vlc_length     = uni_h263_intra_aic_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_h263_intra_aic_rl_len + 128*64;\n\n    }\n\n    s->ac_esc_length= 7+1+6+8;\n\n\n\n    // use fcodes >1 only for mpeg4 & h263 & h263p FIXME\n\n    switch(s->codec_id){\n\n    case CODEC_ID_MPEG4:\n\n        s->fcode_tab= fcode_tab;\n\n        s->min_qcoeff= -2048;\n\n        s->max_qcoeff=  2047;\n\n        s->intra_ac_vlc_length     = uni_mpeg4_intra_rl_len;\n\n        s->intra_ac_vlc_last_length= uni_mpeg4_intra_rl_len + 128*64;\n\n        s->inter_ac_vlc_length     = uni_mpeg4_inter_rl_len;\n\n        s->inter_ac_vlc_last_length= uni_mpeg4_inter_rl_len + 128*64;\n\n        s->luma_dc_vlc_length= uni_DCtab_lum_len;\n\n        s->chroma_dc_vlc_length= uni_DCtab_chrom_len;\n\n        s->ac_esc_length= 7+2+1+6+1+12+1;\n\n        s->y_dc_scale_table= ff_mpeg4_y_dc_scale_table;\n\n        s->c_dc_scale_table= ff_mpeg4_c_dc_scale_table;\n\n\n\n        if(s->flags & CODEC_FLAG_GLOBAL_HEADER){\n\n\n\n            s->avctx->extradata= av_malloc(1024);\n\n            init_put_bits(&s->pb, s->avctx->extradata, 1024);\n\n            \n\n            mpeg4_encode_visual_object_header(s);\n\n            mpeg4_encode_vol_header(s, 0, 0);\n\n\n\n//            ff_mpeg4_stuffing(&s->pb); ?\n\n            flush_put_bits(&s->pb);\n\n            s->avctx->extradata_size= (put_bits_count(&s->pb)+7)>>3;\n\n        }\n\n        \n\n        break;\n\n    case CODEC_ID_H263P:\n\n        if(s->umvplus)\n\n            s->fcode_tab= umv_fcode_tab;\n\n        if(s->modified_quant){\n\n            s->min_qcoeff= -2047;\n\n            s->max_qcoeff=  2047;\n\n        }else{\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        break;\n\n        //Note for mpeg4 & h263 the dc-scale table will be set per frame as needed later \n\n    case CODEC_ID_FLV1:\n\n        if (s->h263_flv > 1) {\n\n            s->min_qcoeff= -1023;\n\n            s->max_qcoeff=  1023;\n\n        } else {\n\n            s->min_qcoeff= -127;\n\n            s->max_qcoeff=  127;\n\n        }\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n        break;\n\n    default: //nothing needed default table allready set in mpegvideo.c\n\n        s->min_qcoeff= -127;\n\n        s->max_qcoeff=  127;\n\n        s->y_dc_scale_table=\n\n        s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n    }\n\n}\n", "idx": 13040, "substitutes": {"s": ["args", "secondary", "sys", "ses", "m", "self", "d", "t", "service", "sg", "fs", "l", "i", "rs", "sym", "sup", "g", "cs", "qs", "S", "settings", "os", "its", "sets", "si", "js", "es", "sq", "uns", "session", "server", "ps", "ss", "sim", "conf", "request", "o", "w", "p", "e", "ions", "sf", "b", "sb", "features", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "ssl", "states", "services", "ds", "r", "ops", "sa", "su", "ls", "ts", "comments", "y", "ks"]}}
{"project": "qemu", "commit_id": "fdfab37dfeffefbd4533b4158055c9b82d7c3e69", "target": 0, "func": "static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n\n                              BdrvCheckMode fix)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n\n    int ret;\n\n    uint64_t refcount;\n\n    int i, j;\n\n\n\n    for (i = 0; i < s->l1_size; i++) {\n\n        uint64_t l1_entry = s->l1_table[i];\n\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n\n        bool l2_dirty = false;\n\n\n\n        if (!l2_offset) {\n\n            continue;\n\n        }\n\n\n\n        ret = qcow2_get_refcount(bs, l2_offset >> s->cluster_bits,\n\n                                 &refcount);\n\n        if (ret < 0) {\n\n            /* don't print message nor increment check_errors */\n\n            continue;\n\n        }\n\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n\n                    \"l1_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                            \"ERROR\",\n\n                    i, l1_entry, refcount);\n\n            if (fix & BDRV_FIX_ERRORS) {\n\n                s->l1_table[i] = refcount == 1\n\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n\n                ret = qcow2_write_l1_entry(bs, i);\n\n                if (ret < 0) {\n\n                    res->check_errors++;\n\n                    goto fail;\n\n                }\n\n                res->corruptions_fixed++;\n\n            } else {\n\n                res->corruptions++;\n\n            }\n\n        }\n\n\n\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n\n                         s->l2_size * sizeof(uint64_t));\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n\n                    strerror(-ret));\n\n            res->check_errors++;\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->l2_size; j++) {\n\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n\n            QCow2ClusterType cluster_type = qcow2_get_cluster_type(l2_entry);\n\n\n\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n\n                ret = qcow2_get_refcount(bs,\n\n                                         data_offset >> s->cluster_bits,\n\n                                         &refcount);\n\n                if (ret < 0) {\n\n                    /* don't print message nor increment check_errors */\n\n                    continue;\n\n                }\n\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n\n                            \"l2_entry=%\" PRIx64 \" refcount=%\" PRIu64 \"\\n\",\n\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n\n                                                    \"ERROR\",\n\n                            l2_entry, refcount);\n\n                    if (fix & BDRV_FIX_ERRORS) {\n\n                        l2_table[j] = cpu_to_be64(refcount == 1\n\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n\n                        l2_dirty = true;\n\n                        res->corruptions_fixed++;\n\n                    } else {\n\n                        res->corruptions++;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        if (l2_dirty) {\n\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n\n                                                l2_offset, s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n\n\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table,\n\n                              s->cluster_size);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n\n                        strerror(-ret));\n\n                res->check_errors++;\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    qemu_vfree(l2_table);\n\n    return ret;\n\n}\n", "idx": 13050, "substitutes": {"bs": ["ses", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "iss", "bb", "sync", "rs", "fb", "cs", "qs", "os", "its", "js", "ros", "ps", "ss", "obs", "rb", "pb", "b", "base", "sb", "banks", "bing", "gb", "gs", "bits", "bh", "ab", "ns", "bps", "is", "outs", "bes", "bas", "ds", "bi", "db", "sa", "ec", "ls", "css", "lb", "bos", "ts", "bl", "vs", "ubs", "us", "ctx", "ks", "aws"], "res": ["args", "rez", "rr", "proc", "sys", "rev", "self", "reply", "Res", "rus", "response", "gr", "rc", "fs", "val", "rs", "changes", "pre", "def", "cs", "details", "req", "qs", "os", "sr", "js", "es", "scope", "rows", "RES", "report", "pres", "ras", "ros", "ps", "conf", "rh", "ss", "obj", "ms", "mr", "p", "RS", "result", "resolution", "spec", "des", "ns", "reset", "arr", "results", "re", "resp", "r", "rep", "ress", "pers", " Res", "css", "reg", "rem", "vals", "err"], "fix": ["bug", "call", "tx", "edit", "config", "def", "test", "method", "hack", "update", "init", "comment", "append", "valid", "force", "patch", "conf", "fixes", "commit", " Fix", " FIX", "check", "pack", "ix", "op", "mode", "result", "xx", "magic", "add", "Fix", "reset", "next", "pull", "FIX", " fixes", "cod", "correct", " prefix", "cache", "prefix", "delay", "pad", "prev", "post", "apply", "replace", "err"], "s": ["args", "sys", "ses", "m", "parts", "bis", "service", "sync", "ins", "sym", "utils", "g", "cs", "details", "S", "settings", "qs", "hs", "sets", "js", "si", "es", "sq", "session", "ps", "ss", "conf", "params", "p", "e", "obs", "site", "b", "sb", "n", "f", "gs", "state", "spec", "c", "ns", "xs", "is", "stats", "ssl", "sv", "sl", "states", "services", "ds", "sie", "ops", "sa", "su", "ls", "ts", "ubs", "iss", "y", "ks"], "l2_table": ["l4_offset", "l2_offset", "l2_block", "l2ftable", "l4_table", "l2foffset", "l1_offset", "l2stable", "l2fblock", "l1_table", "l4_size", "l1_block", "l2fentry", "l2sentry", "l4_entry", "l2ssize", "l1_entry", "l2soffset", "l2_entry", "l2_size"], "ret": ["alt", "en", "ft", "rev", "let", "reply", "art", "rc", "id", "val", "code", "back", "pt", "def", "rets", "gt", "fun", "status", "ref", "det", "arg", "hash", "lit", "error", "conn", "feat", "pass", "obj", "mt", "mem", "success", "match", "ext", "Ret", "count", "result", "att", "html", "url", "cat", "end", "nt", "re", "out", "hard", "rt", "rep", "fail", "db", "RET", "al", "rel", "reg", "num", "flag", "no", "len", "bit", "err"], "refcount": ["referenceount", "referencesize", "reflimit", "referencecount", "bfc", "refsize", "relCount", " refsize", "RefCount", "arcref", "relsize", " refCount", " refcode", "arcCount", "relref", "arccount", " reflimit", "Refsize", "referencelimit", "refref", "refcode", " refc", "refount", "refc", " refref", "relount", "referenceCount", "referencec", "refCount", "Refcode", "bflimit", "relcount", "Refcount", " refount", "bfcount", "arcsize", "relcode"], "i": ["qi", "it", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "a", "io", "ci", "ki", "x", "di", "si", "ie", "ii", "key", "v", "uri", "yi", "u", "ind", "p", "e", "fi", "info", "mi", "li", "k", "b", "ix", "multi", "n", "f", "ti", "ip", "c", "eni", "anti", "ji", "pi", "r", "bi", "ik", "ri", "ori", "zi", "y", "in", "index", "start"], "j": ["jj", "adj", "uj", "m", "aj", "d", "t", "ja", "jp", "l", "oj", "pt", "g", "syn", "dj", "x", "ref", "js", "ii", "key", "v", "job", "fr", "jam", "o", "obj", "z", "ind", "jit", "p", "e", "k", "li", "b", "ix", "n", "f", "c", "next", "jl", "jc", "ji", "q", "r", "J", "pos", "rel", "num", "y", "ij", "index", "err"], "check_errors": ["fix_issues", "fix_errors", "check__rors", "checkMsuccess", "fix_rors", " check_rors", "checkMerrors", "check_rors", "check___success", "check___issues", "check_issues", "check_results", "check__issues", "check__results", " check_results", "checkMissues", "check___rors", "check__errors", "check_success", "check___errors", "fix_success", " check_issues", "checkMrors"], "corruptions_fixed": ["corruptions_fix", "corruption_handled", "corruption_failed", "corruptions_failed", "corruptions_handled", "corruption_fixed", "corruption_fix"], "corruptions": ["corruptedures", "corritures", "corruption", "corruptures", "corruptedion", "corritions", "morruption", "corrition", "corruptIONS", "corritIONS", "morruptedures", "corruptedions", "corruptedIONS", "morruptions", "morruptures", "morruptedIONS", "morruptedion", "morruptedions", "morruptIONS"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void mainstone_common_init(MemoryRegion *address_space_mem,\n\n                                  MachineState *machine,\n\n                                  enum mainstone_model_e model, int arm_id)\n\n{\n\n    uint32_t sector_len = 256 * 1024;\n\n    hwaddr mainstone_flash_base[] = { MST_FLASH_0, MST_FLASH_1 };\n\n    PXA2xxState *mpu;\n\n    DeviceState *mst_irq;\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    int be;\n\n    MemoryRegion *rom = g_new(MemoryRegion, 1);\n\n    const char *cpu_model = machine->cpu_model;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"pxa270-c5\";\n\n\n\n    /* Setup CPU & memory */\n\n    mpu = pxa270_init(address_space_mem, mainstone_binfo.ram_size, cpu_model);\n\n    memory_region_init_ram(rom, NULL, \"mainstone.rom\", MAINSTONE_ROM,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(rom);\n\n    memory_region_set_readonly(rom, true);\n\n    memory_region_add_subregion(address_space_mem, 0, rom);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    /* There are two 32MiB flash devices on the board */\n\n    for (i = 0; i < 2; i ++) {\n\n        dinfo = drive_get(IF_PFLASH, 0, i);\n\n        if (!dinfo) {\n\n            if (qtest_enabled()) {\n\n                break;\n\n            }\n\n            fprintf(stderr, \"Two flash images must be given with the \"\n\n                    \"'pflash' parameter\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        if (!pflash_cfi01_register(mainstone_flash_base[i], NULL,\n\n                                   i ? \"mainstone.flash1\" : \"mainstone.flash0\",\n\n                                   MAINSTONE_FLASH,\n\n                                   blk_bs(blk_by_legacy_dinfo(dinfo)),\n\n                                   sector_len, MAINSTONE_FLASH / sector_len,\n\n                                   4, 0, 0, 0, 0, be)) {\n\n            fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    mst_irq = sysbus_create_simple(\"mainstone-fpga\", MST_FPGA_PHYS,\n\n                    qdev_get_gpio_in(mpu->gpio, 0));\n\n\n\n    /* setup keypad */\n\n    pxa27x_register_keypad(mpu->kp, map, 0xe0);\n\n\n\n    /* MMC/SD host */\n\n    pxa2xx_mmci_handlers(mpu->mmc, NULL, qdev_get_gpio_in(mst_irq, MMC_IRQ));\n\n\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[0],\n\n            qdev_get_gpio_in(mst_irq, S0_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S0_CD_IRQ));\n\n    pxa2xx_pcmcia_set_irq_cb(mpu->pcmcia[1],\n\n            qdev_get_gpio_in(mst_irq, S1_IRQ),\n\n            qdev_get_gpio_in(mst_irq, S1_CD_IRQ));\n\n\n\n    smc91c111_init(&nd_table[0], MST_ETH_PHYS,\n\n                    qdev_get_gpio_in(mst_irq, ETHERNET_IRQ));\n\n\n\n    mainstone_binfo.kernel_filename = machine->kernel_filename;\n\n    mainstone_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    mainstone_binfo.initrd_filename = machine->initrd_filename;\n\n    mainstone_binfo.board_id = arm_id;\n\n    arm_load_kernel(mpu->cpu, &mainstone_binfo);\n\n}\n", "idx": 13051, "substitutes": {"address_space_mem": ["address_space_model", "address_pace_mm", "address_space_memory", "address_stack_memory", "address_space67memory", "address_space_ram", "address_space_cpu", "address_service_lim", "address_space67cpu", "address_service_mem", "address_space2lim", "address_stack_cpu", "address_pace_mem", "address_space2mm", "address_pace_ram", "address_space_mm", "address_service_model", "address_stack_ram", "address_service_ram", "address_space2model", "address_space2memory", "address_space67mem", "address_space2ram", "address_space67ram", "address_space2mem", "address_space_lim", "address_pace_memory", "address_stack_mem"], "machine": ["device", "m", "mom", "service", "ram", "config", "mount", "memory", "object", "connection", "manager", "image", "cpu", "vm", "session", "slave", "managed", "computer", "storage", "loader", "mem", "resource", "boot", "comp", "Machine", "mode", "mo", "state", "process", "link", "host", "cache", "mac", "param", "node"], "model": ["Model", "zero", "vision", "cm", "complete", "array", "config", "code", "gment", "serial", "module", "mod", "scope", "gu", "de", "view", "data", "base", "mode", "address", "global", "block", "lu", "type", "man", "class", "core"], "arm_id": ["arm_root", " app_type", " app_ids", "arm_type", "armOtype", " app_id", "armOid", "armOids", " app_root", "armOroot", "arm_ids"], "mainstone_flash_base": ["mainstone_boot_base", "mainstone_booterarea", "mainstone_system_Base", "mainstone_boot_support", "mainstone_bootersupport", "mainstone_flash_Base", "mainstone_flasherbas", "mainstone_flashalarea", "mainstone_flasherbase", "mainstone_booterbase", "mainstone_flash_server", "mainstone_flash_bas", "mainstone_flashalsupport", "mainstone_flashalbas", "mainstone_system_bas", "mainstone_flashalbase", "mainstone_flash_area", "mainstone_flash_support", "mainstone_system_server", "mainstone_boot_area", "mainstone_flashersupport", "mainstone_flasherarea", "mainstone_boot_bas", "mainstone_booterbas", "mainstone_system_base"], "mpu": ["ppu", "mpcu", "mpus", "ampo", "ppcu", "mpui", "ampcu", "ppui", "mbui", "mpo", "mbiu", "mbu", " mpg", "mmc", "ampc", "ampa", "spu", "ppi", "ampi", "ppus", " mpo", "mpiu", " mpi", " mpc", "spui", "ampg", "mmg", "spus", "mmu", "spiu", "mpi", "mbus", "ppiu", "mpg", "ppo", " mpcu", "mpc", "mpa", " mpa", "ampu", "mma"], "mst_irq": ["mst_lrq", "mst_brp", "mst_lrqq", "mst_rinch", "mst_arce", "mst_mirch", "mst_rinp", "mst_mirce", "mst_mirw", "mst_irqq", "mst_arq", "mst_arch", "mst_rinq", "mst_brqq", "mst_mirqq", "mst_irw", "mst_mirq", "mst_irp", "mst_brw", "mst_rince", "mst_mirp", "mst_irch", "mst_irce", "mst_arp", "mst_lrw", "mst_lrp", "mst_brq"], "dinfo": ["dinf", "pinfo", " dinf", "ptype", "ddfo", "linfo", "dcheck", "bfi", "pfi", "dedinf", "ldinfo", "dedfo", "btype", "ddconfig", "binfo", " dconfig", " dfo", "dconfig", "kcheck", "dedInfo", "ddfi", "dInfo", "dtype", " dfi", "dedfi", "ldinf", "ldInfo", " dInfo", "kinfo", "pinf", "lInfo", " dtype", "ldfo", "dedconfig", "ddinfo", "dedinfo", "linf", "dfo", "kinf", " dcheck", "binf", "kInfo", "lcheck", "dfi"], "i": ["hi", "qi", "uni", "ui", "it", "adi", "slice", "I", "d", "input", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "mu", "ci", "di", "x", "init", "ie", "si", "ii", "uri", "gu", "yi", "u", "z", "p", "e", "info", "mini", "mi", "li", "cli", "b", "multi", "j", "n", "phi", "ti", "ip", "c", "eni", "ji", "type", "pi", "chi", "udi", "r", "bi", "ri", "ori", "zi", "index"], "be": ["ke", "obe", " Be", "bis", "te", "ignore", " b", "Be", "ome", "ere", "trace", "me", "ine", "range", "ste", "ve", "use", "pose", "fore", "oe", "de", "console", "bee", "ee", "se", "e", "boot", " e", "he", "enable", " ne", "b", "byte", "component", "ore", "ape", "none", "fe", "BE", "pe", "ne", "is", "ro", "abe", "bes", "eb", " probe", " je", "ce", "scale", "le", "debug", "ble", "bi", "ache", "ae", "we", "see", "are", " BE", "bl", "ze"], "rom": ["aram", "camp", "m", "mc", "cm", "ru", "REM", "arm", "ram", "ray", "rs", "roc", "ra", "cpu", "rg", "vm", "gra", "ros", "rim", "prom", "region", "rum", "cr", "roy", "ran", "mem", "mor", "resource", "drm", "rb", "iam", "mode", "rm", "roma", "dem", "prem", "gram", "rome", "ro", "norm", "ROM", "rob", "cmd", "chrom", "coll", "pro", "com", "rock", "param", "r", "cp", "irm", "rem", "dim", "core", "ream", "sm", "lim"], "cpu_model": ["cache_channel", "cpu_location", "cpu_type", "cpu_view", "cpuermode", "core_models", "cpu_size", "gpu_mode", " cpu_contract", " cpu_mode", "cpuromodels", "cpuroimage", "cache_model", "cpufimage", "cpu_contract", "cpufmodels", "cpurotype", " cpu_resource", "cpu_channel", " cpu_view", "cpuerlayout", "cpuftype", "cpu_models", "core_model", "cpu_layout", "cpuromodel", "cpu_address", "cpufmodel", "core_type", "core_image", " cpu_layout", "cpu_mode", "cpu_image", "gpu_models", "cpu_resource", "cache_location", "gpu_model", "cpuermodel", "cpuercontract", "gpu_size", "cache_address"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068, "substitutes": {"src1": [" src0", "supp2", "rc2", "source3", "rc0", "rcFirst", "source2", "sourceOne", "source1", " srcOne", "source0", "suppOne", "src3", "rcOne", "rc3", "suppFirst", "src0", " srcFirst", "rc1", " src3", "srcOne", "supp1", "srcFirst"], "src2": [" src0", "source8", "sur20", "rc2", "rc0", "source2", " src8", "source1", " src4", "source0", "src4", "sourceB", "sb1", "sur2", "sur0", "sb20", "rc4", "rc20", "sb2", "src0", "rc8", "source4", "sb0", "src20", "srcB", "sur1", "rc1", " srcB", "src8", "rcB"], "dst1": ["drest2", "dsc3", "Dst2", "adst3", "adsts2", "adstsOne", "dsp1", "Dst01", "dst3", "dsc2", "adst1", "dscOne", "Dsc1", "dst01", "dsp3", "drest001", "adst2", "dstsOne", "dsc1", "adsts3", "Dsc2", "drc01", "dsts2", "Dst1", "dstOne", "drest1", "dst001", "dsc01", "adsts1", "dsts3", "drc2", "dsp2", "drc1", "dsts1", "drest01", "adstOne", "dspOne", "Dsc01", "dsc001", "drc001", "Dst001", "Dsc001"], "dst2": [" dsp0", "dste1", "dspTwo", "ddest02", "dsc62", "dst02", " dsp2", "sst2", "dsp1", "drc0", "dste02", "dsc2", " dspTwo", "sdest62", "dsc02", "dscTwo", "dst62", "sdest02", "dste62", "sdest1", " dsp1", "dst0", "dstTwo", "dsc1", " dstTwo", "sdest2", "sst62", "drcTwo", "ddest62", "ddest1", "sst1", "dste2", "dsp0", "drc2", "drc1", "dsp2", "dsc0", "sst02", "ddest2", " dst0"], "height": ["head", "Height", "build", "thin", "density", "shape", "style", "image", "crop", "size", "pad", "img", "direction", "length", "th", "padding", "resolution", "gravity", "inches", "ph", "ht", "wa", "hold", "angle", "sh", "layout", "hd", "window", "ty", "dim", "depth"], "srcStride1": ["srcstride2", "srcstide1", "srcStride0", "srcStrite1", "srcScriteOne", "srcStri01", "srcScrite1", "srcStrideOne", "srcStrub2", "srcStrip2", "srcStride3", "srcStrub1", "srcStri2", "srcstideOne", "srcStide3", "srcScrideOne", "srcStrite11", "srcStrub11", "srcStrubOne", "srcstide0", "srcScrite11", "srcstide01", "srcStrite3", "srcstride3", "srcstide2", "srcstride01", "srcstride1", "srcStri0", "srcStide01", "srcStride11", "srcStrue3", "srcStrue2", "srcStrip1", "srcStrue1", "srcScride11", "srcScride2", "srcstide3", "srcStrite2", "srcStrueOne", "srcStri1", "srcStide1", "srcScrite2", "srcStide2", "srcStrip0", "srcStideOne", "srcStide0", "srcStriteOne", "srcScride1", "srcStrip01", "srcstrideOne", "srcStrue11", "srcStride01", "srcstride0"], "srcStride2": ["srcScride4", "srcShide3", "srcShide2", "srcStrb4", "srcStride0", "srcShride1", "srcStrite1", "srcScrite1", "srcScrite0", "srcStrue4", "srcStrite4", "srcStrip2", "srcStride3", "srcStrb1", "srcStide3", "srcScrite4", "srcShride3", "srcStide8", "srcStrip4", "srcScride0", "srcStrb0", "srcStrite8", "srcShride4", "srcStrite3", "srcShide1", "srcSterve2", "srcStrue3", "srcStride8", "srcStrue2", "srcStrue1", "srcStrip1", "srcStrite0", "srcScride2", "srcStrite2", "srcSterve4", "srcSterve8", "srcStrb2", "srcStide1", "srcScrite2", "srcStide4", "srcStide2", "srcStrip0", "srcStride4", "srcSterve1", "srcScride1", "srcShride2", "srcShide4"], "dstStride1": ["dstStride4", "dstStrite1", "dstScride1", "dstStro1", "dstStrip8", "dstStrip3", "dstStro01", "dstStro4", "dstStrideX", "dstStride8", "dstScrideX", "dstStrite01", "dstStro3", "dstStro8", "dstStride01", "dstScriteX", "dstScrite1", "dstStrip2", "dstStriteX", "dstStgrade1", "dstStgrade4", "dstStrite2", "dstScride4", "dstStrip1", "dstStro2", "dstScrite01", "dstStgrade01", "dstScride01", "dstStgradeX", "dstStrite4", "dstStroX", "dstStrite8", "dstScrite4", "dstStride3", "dstStrite3"], "dstStride2": ["dstStride4", "dstStrideTwo", "dstStrid4", "dstStriteTwo", "dststrTwo", "dstStgrade\n", "dststrideTwo", "dstStrTwo", "dststr52", "dstStridTwo", "dstStrite2", "dstStrip\n", "dstStr4", "dststride4", "dstStr52", "dstStride52", "dststr4", "dstStr2", "dststride2", "dstStrite4", "dstStride\n", "dstStrid52", "dstSterve\n", "dstStrid2", "dstResterve\n", "dstRestride\n", "dststr2", "dststride52", "dstStrite52"], "y": ["ny", "yt", "m", "hy", "ys", "t", "sky", "id", "l", "i", "lon", "iy", "a", "io", "name", "ey", "yd", "py", "gy", "cy", "by", "ym", "ye", "v", "key", "o", "dy", "yi", "z", "yl", "ady", "p", "e", "u", "yr", "uy", "b", "yo", "j", "n", "f", "yn", "oy", "c", "vy", "ay", "ry", "type", "year", "Y", "ya", "ky", "xy", "yy", "wy", "zy", "ty", "sy"], "x": ["m", "tx", "t", "on", "xi", "id", "l", "i", "code", "ww", "any", "my", "name", "ex", "g", "wx", "fx", "sw", "event", "image", "xt", "xp", "full", "px", "v", "key", "ct", "win", "yx", "dx", "view", "z", "u", "ady", "p", "e", "s", "time", "rx", "wait", "b", "ix", "j", "n", "f", "cross", "xx", "ax", "c", "xs", "pe", "xes", "X", "sex", "wa", "q", "r", "lex", "host", "xc", "xy", "work", "pos", "index", "php"], "w": ["m", "wh", "t", "iw", "l", "i", "ww", "ew", "g", "weight", "wx", "sw", "wt", "v", "wn", "win", "z", "p", "e", "s", "aw", "max", "b", "wb", "n", "wp", "c", "W", "tw", "ow", "wa", "r", "wall", "we", "hw", "wy", "window", "wd", "fw"], "h": ["hi", "m", "ch", "en", "t", "l", "i", "ww", "g", "hs", "gh", "v", "rh", "uh", "z", "p", "s", "k", "b", "j", "n", "f", "th", "hm", "c", "W", "ht", "wa", "q", "H", "sh", "high", "ph"], "s1": ["saOne", "ps8", "sa1", "ses5", "ns1", "s8", "ps2", "ps1", "dsOne", "cs2", " s5", "csX", "sesX", "sesone", "saone", "ses8", "s91", "ns91", "ses1", "s5", " s8", "dsone", "ds91", "nsOne", " sX", "sX", "cs1", "sone", "ds1", "sOne", "nsone", "psone", "sa91", "cs5", "ses2", " sone"], "d": ["D", "dh", "m", "done", "fd", "t", "l", "id", "i", "ded", "da", "bd", "g", "dl", "di", "ld", "ct", "v", "del", "o", "dy", "cd", "ad", "z", "p", "e", "s", "du", "data", "sd", "did", "b", "j", "n", "f", "dat", "c", "dt", "dc", "md", "q", "r", "ds", "dd", "db", "dr", "dim", "dos"], "s2": ["p2", " s92", "s8", " s8", "p8", "p92", "sync92", "p1", "sync8", "sync2", "sync1", "s92"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void puv3_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    CPUUniCore32State *env;\n\n    UniCore32CPU *cpu;\n\n\n\n    if (initrd_filename) {\n\n        error_report(\"Please use kernel built-in initramdisk\");\n\n        exit(1);\n\n    }\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"UniCore-II\";\n\n    }\n\n\n\n    cpu = UNICORE32_CPU(cpu_generic_init(TYPE_UNICORE32_CPU, cpu_model));\n\n    if (!cpu) {\n\n        error_report(\"Unable to find CPU definition\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    puv3_soc_init(env);\n\n    puv3_board_init(env, ram_size);\n\n    puv3_load_kernel(kernel_filename);\n\n}\n", "idx": 13077, "substitutes": {"machine": ["database", "proc", "m", "mom", "part", "service", "config", "object", "manager", "image", "project", "module", "vm", "game", "model", "comment", "linux", "server", "computer", "app", "slave", "sim", "loader", "parse", "instance", "boot", "Machine", "data", "base", "mode", "address", "state", "agent", "rule", "process", "hard", "host", "cache", "template", "mac", "class", "space", "environment", "controller", "node", "message"], "cpu_model": ["cpuleximage", "cpu_loader", "core_base", "core_size", "cpu_size", "gpu_mode", "cpujmode", "kernel_mode", " cpu_mode", "gpu_image", "gpu_layout", "gpu_resource", "kernel_manager", "cpujmanager", "kernel_model", "cpulexmodel", "cpuamserver", "cpulexresource", "kernel_service", " cpu_models", "cpu_models", "core_model", "cpu_layout", "cpuamsize", "cpu_base", "kerneljmodel", "cpuidmode", "kerneljservice", "cpujmodel", "cpu_service", " cpu_size", "kerneljmode", "cpuidmodel", "cpuambase", "cpuidresource", "cpu_mode", "cpu_image", "cpu_resource", "cpuidimage", "gpu_model", "cpulexmode", "cpujservice", "kerneljmanager", "core_server", "cpu_manager", "cpuammodel", "cpu_server", "gpu_loader"], "kernel_filename": ["kernelpsize", "kernel_title", " kernelpfilename", " kernelpfile", "kerneldbtitle", "ernel_filename", " kernelpsize", "kernel_label", "kernel2file", " kernel_file", "kernelFlabel", " kernelplabel", "kernel1download", "kernel2filename", "kernelblockfilename", "nn_filename", "kerneldbdownload", "kernelpfile", "nn_function", "erneldbfilename", "kernelFdownload", "kerneldblabel", "erneldbtitle", "kernel1title", "ernel_label", "kernelblocksize", "kernel_function", "ernel_download", "ernel_title", "kernel_file", " kernel_label", "erneldbdownload", "erneldblabel", "kernelFfilename", "kernelFtitle", "kerneldbfilename", "kernelpfilename", "kernel_size", "kernel2size", "nn_file", "nn_size", " kernel_size", "kernelblockfunction", "kernel1label", "kernel1filename", "kernelplabel", "kernelblockfile", "kernel2label", "kernel_download"], "initrd_filename": ["initrs_file", "initr_fn", "initr_maximum", "initrd___fn", "initrd___Filename", "initrt_module", "initrd_selection", "initrd_module", "initr_Filename", "initrd_file", "initrd_fn", "initrt_file", "initrd_name", "initrd_maximum", "initrs_Filename", "initrt_selection", "initrs_filename", "initrd___maximum", "initrs_name", "initrd___filename", "initrt_filename", "initrd_Filename", "initr_filename"], "env": ["args", "path", "egg", "en", "context", "edge", "queue", "enc", "ea", "eye", "config", "cv", " environment", "code", "eu", "oa", "ah", "style", "vm", "scope", "skin", "estate", "v", "conf", "conn", "np", "console", "loader", "energy", "size", "doc", "e", "ctx", "viron", "exc", "equ", "exe", "img", "her", "ext", "engine", "eng", "qt", "Environment", "cfg", "state", "global", "eni", "shell", "agent", "end", "pe", "attr", "osc", "network", "here", "exec", "gui", "db", "ev", "cache", "ec", "work", "que", "environment", "core", "net", "err"], "cpu": ["proc", "bench", "po", "cow", "ni", "config", "pc", "roc", "gc", "lc", "currency", "cn", "kernel", "uno", "vm", "linux", "uca", "px", "computer", "performance", "gnu", "pu", "fp", "conn", "np", "console", "processor", "loader", "GPU", "instance", " CPU", "net", "boot", "nc", "CPU", "nu", "eni", "gpu", "prem", "clock", "process", "cp", "hw", "css", "lb", "environment", "core", "python", "ctx", "node"]}}
{"project": "FFmpeg", "commit_id": "caa845851d790f894a2ccbe12580934f75545f92", "target": 0, "func": "static int output_data_internal(MLPDecodeContext *m, unsigned int substr,\n\n                                uint8_t *data, unsigned int *data_size, int is32)\n\n{\n\n    SubStream *s = &m->substream[substr];\n\n    unsigned int i, out_ch = 0;\n\n    int32_t *data_32 = (int32_t*) data;\n\n    int16_t *data_16 = (int16_t*) data;\n\n\n\n    if (*data_size < (s->max_channel + 1) * s->blockpos * (is32 ? 4 : 2))\n\n        return -1;\n\n\n\n    for (i = 0; i < s->blockpos; i++) {\n\n        for (out_ch = 0; out_ch <= s->max_matrix_channel; out_ch++) {\n\n            int mat_ch = s->ch_assign[out_ch];\n\n            int32_t sample = m->sample_buffer[i][mat_ch]\n\n                          << s->output_shift[mat_ch];\n\n            s->lossless_check_data ^= (sample & 0xffffff) << mat_ch;\n\n            if (is32) *data_32++ = sample << 8;\n\n            else      *data_16++ = sample >> 8;\n\n        }\n\n    }\n\n\n\n    *data_size = i * out_ch * (is32 ? 4 : 2);\n\n\n\n    return 0;\n\n}\n", "idx": 13081, "substitutes": {"m": ["wm", "mc", "cm", "d", "t", "mp", "l", "fm", "g", "manager", "mn", "this", "module", "mod", "mm", "ym", "machine", "em", "tm", "v", "sim", "o", "ms", "mt", "gm", "mr", "p", "u", "bm", "e", "media", "b", "n", "f", "hm", "mos", "c", "pm", "M", "md", "man", "im", "mac", "dm", "y", "sm", "mu"], "substr": ["subStr", "conchar", "thstrings", "thstr", "constring", "constrings", "ubstring", "substring", " substring", "constr", "thstring", " subStr", "SubStr", "Substr", "Substring", "thchar", "ubStr", "subchar", " substrings", "substrings", "Subr", "ubstr", "ubr", " subchar", " subr", "subr"], "data": ["draw", "slice", "input", "d", "array", "batch", "shift", "code", "memory", "da", "sample", "a", "mu", "source", "image", "missing", "di", "buffer", "value", "frame", "output", "alpha", "open", "size", "p", "base", "multi", "result", "none", "dat", "block", "Data", "body", "change", "results", "scale", "one", "DATA", "cache", "window", "index", "start"], "data_size": ["sample_speed", "data_time", "data_speed", "data_scale", " data_depth", "sample_size", "data_depth", " data_scale", " data_speed", " data_time", "sample_scale"], "is32": [" is128", "Is128", "bis32", " is72", "isi31", "lis64", "is16", "Is64", " is16", "bis33", "Is16", "IS16", "mis31", "isi34", "isa31", "is31", "mis32", "iss33", "isa33", "iss64", "is72", "lis33", " is31", "mis34", "isa32", "lis72", "iss32", "isa16", "Is32", "isi64", "IS32", "isi32", "Is34", "Is31", "is34", "is64", "bis16", "is128", " is64", "is33", "lis32", "bis31", "IS128", " is33", "mis64", "iss72"], "s": ["ses", "d", "t", "service", "sync", "fs", "ins", "l", "sg", "rs", "rates", "g", "cs", "qs", "S", "hs", "os", "si", "js", "es", "sq", "session", "v", "ps", "ss", "sim", "client", "o", "w", "ms", "u", "p", "e", "site", "b", "sf", "sb", "n", "f", "gs", "hm", "spec", "c", "ns", "xs", "is", "ssl", "sl", "services", "ds", "r", "sa", "su", "comm", "ls", "ts", "space", "ims", "y", "sm"], "i": ["qi", "it", "ui", "ch", "I", "d", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "oi", "io", "mu", "ci", "h", "di", "x", "si", "ie", "ii", "v", "uri", "yi", "u", "p", "e", "fi", "info", "mini", "mi", "li", "k", "b", "ix", "multi", "j", "phi", "n", "f", "ti", "ip", "c", "eni", "pi", "chi", "bi", "ri", "ei", "zi", "y", "index", "start"], "data_32": ["data_62", "data___16", "data___62", " data_62", " data_8", "data___8", " data_64", "data___32", "data_64", "data_8"], "data_16": [" data_36", " data_8", "data_18", " data_64", "data_36", "data_64", "data_8", " data_18"], "out_ch": ["mat_zh", "outRCH", "out_CH", "outxchan", "outxch", "outLchy", "mat_chi", "outJcher", "out_zh", "mat_chan", "outLcha", "outRconn", "at_chan", " outRCH", " outRch", "win_char", "out_size", "outRch", "out_chan", "outCch", " out_CH", " out_conn", "at_ch", "win_ach", "outCchi", "outLCh", "win_coll", "out_chy", "data_Ch", "out_char", "outLch", "outxzh", " outRcher", "out_conn", "outJconn", "data_cha", "data_chy", "outJch", "mat_ch", "out_ach", "outRcher", "outCchan", "data_ch", "at_char", "win_ch", "out_cher", " out_char", "outJach", " out_chan", "outCzh", "out_chi", " outRconn", " out_cher", "outJchar", "at_size", "out_coll", "outxchi", "out_cha", "outJCH", "outJcoll", "out_Ch"]}}
{"project": "qemu", "commit_id": "2ebafc854d109ff09b66fb4dd62c2c53fc29754a", "target": 1, "func": "static int qcow2_read_extensions(BlockDriverState *bs, uint64_t start_offset,\n\n                                 uint64_t end_offset, void **p_feature_table,\n\n                                 Error **errp)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    QCowExtension ext;\n\n    uint64_t offset;\n\n    int ret;\n\n\n\n#ifdef DEBUG_EXT\n\n    printf(\"qcow2_read_extensions: start=%ld end=%ld\\n\", start_offset, end_offset);\n\n#endif\n\n    offset = start_offset;\n\n    while (offset < end_offset) {\n\n\n\n#ifdef DEBUG_EXT\n\n        /* Sanity check */\n\n        if (offset > s->cluster_size)\n\n            printf(\"qcow2_read_extension: suspicious offset %lu\\n\", offset);\n\n\n\n        printf(\"attempting to read extended header in offset %lu\\n\", offset);\n\n#endif\n\n\n\n        ret = bdrv_pread(bs->file, offset, &ext, sizeof(ext));\n\n        if (ret < 0) {\n\n            error_setg_errno(errp, -ret, \"qcow2_read_extension: ERROR: \"\n\n                             \"pread fail from offset %\" PRIu64, offset);\n\n            return 1;\n\n        }\n\n        be32_to_cpus(&ext.magic);\n\n        be32_to_cpus(&ext.len);\n\n        offset += sizeof(ext);\n\n#ifdef DEBUG_EXT\n\n        printf(\"ext.magic = 0x%x\\n\", ext.magic);\n\n#endif\n\n        if (ext.len > end_offset - offset) {\n\n            error_setg(errp, \"Header extension too large\");\n\n            return -EINVAL;\n\n        }\n\n\n\n        switch (ext.magic) {\n\n        case QCOW2_EXT_MAGIC_END:\n\n            return 0;\n\n\n\n        case QCOW2_EXT_MAGIC_BACKING_FORMAT:\n\n            if (ext.len >= sizeof(bs->backing_format)) {\n\n                error_setg(errp, \"ERROR: ext_backing_format: len=%\" PRIu32\n\n                           \" too large (>=%zu)\", ext.len,\n\n                           sizeof(bs->backing_format));\n\n                return 2;\n\n            }\n\n            ret = bdrv_pread(bs->file, offset, bs->backing_format, ext.len);\n\n            if (ret < 0) {\n\n                error_setg_errno(errp, -ret, \"ERROR: ext_backing_format: \"\n\n                                 \"Could not read format name\");\n\n                return 3;\n\n            }\n\n            bs->backing_format[ext.len] = '\\0';\n\n#ifdef DEBUG_EXT\n\n            printf(\"Qcow2: Got format extension %s\\n\", bs->backing_format);\n\n#endif\n\n            break;\n\n\n\n        case QCOW2_EXT_MAGIC_FEATURE_TABLE:\n\n            if (p_feature_table != NULL) {\n\n                void* feature_table = g_malloc0(ext.len + 2 * sizeof(Qcow2Feature));\n\n                ret = bdrv_pread(bs->file, offset , feature_table, ext.len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: ext_feature_table: \"\n\n                                     \"Could not read table\");\n\n                    return ret;\n\n                }\n\n\n\n                *p_feature_table = feature_table;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            /* unknown magic - save it in case we need to rewrite the header */\n\n            {\n\n                Qcow2UnknownHeaderExtension *uext;\n\n\n\n                uext = g_malloc0(sizeof(*uext)  + ext.len);\n\n                uext->magic = ext.magic;\n\n                uext->len = ext.len;\n\n                QLIST_INSERT_HEAD(&s->unknown_header_ext, uext, next);\n\n\n\n                ret = bdrv_pread(bs->file, offset , uext->data, uext->len);\n\n                if (ret < 0) {\n\n                    error_setg_errno(errp, -ret, \"ERROR: unknown extension: \"\n\n                                     \"Could not read data\");\n\n                    return ret;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n\n\n        offset += ((ext.len + 7) & ~7);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13097, "substitutes": {"bs": ["bt", "ses", "blocks", "bis", "bc", "sync", "BS", "ins", "fs", "iss", "bb", "lbs", "rs", "fb", "bn", "utils", "cs", "qs", "bytes", "cms", "its", "js", "abc", "ros", "boxes", "ras", "ps", "ss", "obj", "obs", "vals", "plugins", "pb", "bm", "b", "sb", "base", "bing", "gs", "gb", "bits", "bh", "ab", "ns", "bps", "cb", "outs", "bes", "bas", "org", "blog", "ds", "bi", "db", "sa", "ls", "css", "lb", "bos", "ubs", "las", "bl", "vs", "abi", "aws"], "start_offset": ["begin_offset", "begin_size", "start67slot", "start00offset", "begin_align", " start_size", "start_position", "start___start", "start__size", "begin___offset", "start_align", "end_slot", "start67offset", "start_start", "start__slot", "begin_start", "start67position", "begin___start", "start_index", "start_area", "end_size", " start_area", "end_position", "start67size", "start00area", " start_index", "start__offset", "start_slot", "start00index", "start_size", "start00size", "start___align", "begin___size", "start___size", "start___offset", "start__position", "begin___align"], "end_offset": ["end_addr", "end_Offset", "stop_format", "start_off", "end_end", "start_start", "stop00Offset", "end00Offset", "end_area", "stop_Offset", "start_area", "end_size", "end_off", "end_format", "start_end", "end00offset", "end00format", "start_addr", "start_size", "stop00format", "end_start", "stop_offset", "stop00offset"], "p_feature_table": ["p_features_details", "p_featureingtable", "p_feature_list", "p_featurelogdetails", "p_featurelogtable", "p_features_file", "p_featurelogfile", "P_\n", "p_features_table", "p_str", "p_featureloglist", "p_featureinglist", "p_features_list", "P_str", "p_feature_details", "p_\n", "p_feature_file", "p_featureingfile", "p_featureingdetails"], "errp": ["nerP", " errr", "ierp", "erfp", "acert", "erpatch", "errjp", "Erpoint", "erpre", "errorp", "errorjp", "erjp", "errr", " erp", "dert", "errpatch", "iterpc", " errt", "iterb", "derp", "errfp", " erpre", "ierr", "errorP", "errP", " errP", "erp", " erfp", "nerp", "errpre", "Err", "derpc", "erP", "errpoint", "ierP", "errt", "errorpc", "errorb", "errpc", "acerp", "nerb", "iterp", "nerpc", "derP", "iterP", "Erp", "Erpatch", "erpoint", "errb", "Erpre", " errjp", "acerP", "ErP", "acerpc", "Erfp", "ierpoint", " errpc", " erpatch", "errorr", "err"], "s": ["sys", "ses", "t", "fs", "rs", "cs", "qs", "S", "settings", "os", "si", "js", "sq", "storage", "ss", "ps", "p", "e", "sb", "b", "sf", "stat", "gs", "spec", "state", "c", "ns", "xs", "is", "stats", "ssl", "sv", "sl", "states", "ops", "ds", "sa", "ls", "ts"], "ext": ["word", " EXT", "dist", "art", " extent", "def", "x", "xt", "str", "fp", "append", " extend", "br", "vert", "obj", "ind", "temp", "tf", "cb", "text", "aux", "ec", "off", "ef", " extended", "ft", "inter", "lc", "req", "txt", "full", "fr", " aux", "lib", "img", "cut", " parent", "exec", "Ext", " ep", "zip", "ch", "config", "external", "extra", "test", "section", "fx", "xp", "init", "eff", "app", "z", " aug", "e", "sec", "info", "desc", "eng", "ix", "f", " intr", "diff", "cf", "EXT", " fmt", "ord", " cont", " orig", " instr", "code", "ex", "later", "abc", "feat", "p", "fit", "next", "org", "seq"], "offset": ["bound", "align", "offer", "fp", "loc", "append", "limit", "af", "base", "count", "skip", "padding", "timeout", "end", "afi", "fee", "off", "num", "order", "index", "Offset", "part", "slice", "id", "api", "optional", "operation", "error", "ut", "entry", "abi", "length", "origin", "url", "layout", "et", "addr", "alias", "ptr", "alt", "format", "slot", "absolute", "section", "null", "ref", "adjust", "output", "o", "stop", "online", "f", "address", "scroll", "reset", "type", "nt", "hop", "pos", "prefix", "ui", "adjusted", "location", "position", "set", "size", "pointer", "next", "outer", "attribute", "initial", "seq", "len", "exclusive", "start"], "ret": ["alt", "ft", "en", "rev", "part", "let", "reply", "art", "id", "val", "back", "def", "rets", "gt", "fun", "str", "ref", "det", "arg", "lit", "key", "job", "conn", "obj", "mt", "mem", "info", "desc", "success", "match", "af", "Ret", "count", "bf", "f", "result", " RET", "att", "url", "cat", "arr", " Ret", "nt", "re", "out", "rt", "et", "pat", "RET", "res", "num", "reg", "usr", "flag", "no", "len", "opt", "bit"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "inline static void RENAME(hcscale)(SwsContext *c, uint16_t *dst, int dstWidth, const uint8_t *src1, const uint8_t *src2,\n\n                                   int srcW, int xInc, const int16_t *hChrFilter,\n\n                                   const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                   uint8_t *formatConvBuffer,\n\n                                   uint32_t *pal)\n\n{\n\n\n\n    src1 += c->chrSrcOffset;\n\n    src2 += c->chrSrcOffset;\n\n\n\n    if (c->chrToYV12) {\n\n        c->chrToYV12(formatConvBuffer, formatConvBuffer+VOFW, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= formatConvBuffer+VOFW;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hScale(dst     , dstWidth, src1, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hScale(dst+VOFW, dstWidth, src2, srcW, xInc, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst, dstWidth);\n\n}\n", "idx": 13100, "substitutes": {"c": ["call", "m", "context", "ch", "mc", "cm", "bc", "d", "cv", "enc", "t", "ca", "config", "l", "pc", "cc", "rc", "C", "lc", "cs", "ci", "ctrl", "g", "h", "cit", "cn", "this", "cy", "cmp", "con", "ct", "v", "conf", "cr", "u", "uc", "oc", "p", "e", "s", "ctx", "nc", "b", "co", "tc", "self", "n", "f", "cu", "dc", "ac", "sc", "ce", "cf", "r", "cp", "com", "vc", "xc", "cache", "ec", "cur", "core", "cl", "cpp"], "dst": ["gdST", "ddst", " dsts", "madstr", "ddsta", "sdST", "mdsth", "Dst", " dST", "adsth", " dsth", "ddsts", "dstr", "Dsts", "dsta", "adst", "dsts", " dsrc", "adsts", " drc", "sdsts", "idrest", "drest", "dsrc", "madst", "mdsts", "madsta", "sdst", "madsts", "adST", "gdsth", "ddstr", "idsrc", "adrc", "dsth", "idST", "idst", " dstr", "dST", "mdrest", "DST", "idsth", "idsts", "mdst", "gdst", " drest", "gdrc", "drc", "sdsth", " dsta", "Dsrc"], "dstWidth": ["dscwidth", " dSTwidth", "dStHeight", " dstHeight", "dSTWidth", "drcHeight", " drcWidth", "DstWidth", "dscHeight", " dstWill", " dstwidth", "dSTW", " dstsWidth", "dstwidth", "drcWidth", " dscHeight", "DSTW", " dSTHeight", "dstsHeight", "ddestwidth", " drcHeight", "destHeight", "dscWidth", "dstsWidth", " dscwidth", "destWidth", "dSTHeight", "ddestWill", " dscWidth", "dSTwidth", "dstswidth", "dStWidth", "ddestHeight", "drcWill", " dstsHeight", " drcwidth", "dSTWill", "DstHeight", "dstHeight", "dStwidth", "dstWill", " dstswidth", "DSTHeight", "dStW", "destwidth", "drcwidth", "dstW", "Dstwidth", "drcW", "DSTwidth", "DstW", " dSTWidth", "ddestWidth", "DSTWidth", " drcWill"], "src1": [" src0", "uc1", "structN", "struct2", "attrOne", "const2", "img1", "source01", "srcone", "rc2", "srcFirst", "source3", "ucOne", "rc0", "srcN", "rcone", "const0", "uc2", "rc01", "source2", "sourceOne", "rcW", "const1", "source1", "attrFirst", " src01", "source0", " srcOne", "attr01", "imgOne", "src3", "rcOne", "src01", "rc3", "src0", "const01", " srcFirst", "struct1", "img01", " srcone", " srcN", "imgFirst", "rcN", "rc1", " src3", "srcOne", "ucW", "attr1", "structone"], "src2": [" src0", " src002", "rcTwo", "dist002", "srcTwo", "src002", "sc2", "rc2", " srcTwo", "sc02", "st2", "loc0", "sc1", "scTwo", "rc0", "dest1", "loc4", "source2", "destTwo", "distTwo", "source1", "dist02", " src4", "src4", "dest2", "st02", "loc1", "stB", "rc02", "rc4", "reflect002", "src02", "source4", "src0", "reflectTwo", "dist2", "dest4", "srcB", "st1", "loc2", "reflect2", "rc1", "reflect02", " src02", " srcB", "rcB"], "srcW": ["instN", "srcL", "inst1", "sourcew", "locN", "imgCW", "rc2", "srcN", "inst2", "locw", "rcL", "source2", "rcW", " srcCW", "instL", " srcw", "instw", "img2", "sourceW", "imgw", " srcL", "locW", " srcN", "loc2", "imgW", "rcN", "rc1", "srcw", "srcCW", "sourceN", "rcw", "locCW", "instW"], "xInc": ["yinc", "sexExc", "aIncrease", "sexInc", "ainc", "xIncre", "txIncre", "yEnc", "xSec", "Xinc", "yInc", " xSec", "wInc", "nexInc", "dxINC", "wINC", "xxIncre", "xinc", "ySec", "aInc", "yxINC", "yxExec", "xIncrease", "XExc", "XSec", "txInc", "xxInc", "XINC", "xxINC", "XInc", "xxExc", "XIncre", "nexINC", "xExc", "dxExec", "winc", "txINC", " xinc", "xExec", "dxIncre", "nexIncrease", "yxInc", "wIncrease", "aINC", "sexIncre", "XEnc", "sexINC", "txExec", "xINC", "dxInc", " xEnc", "nexinc", "xEnc", "yxIncre"], "hChrFilter": ["hChlrFormat", "hChoFormat", "hChrFl", "hQurFl", "hChrHandler", "hChrsFormat", "hChrlFilter", "hQrbFi", "hchlFilter", "hQrFilter", "hChlrFilter", "hChlFl", "hChrFi", "hQurFormat", "hQurlFactor", "hChlHandler", "hchrFactor", "hChrFormat", "hchlLimit", "hCharFactor", "hchrFilter", "hChrbFormat", "hchrLimit", "hChlFilter", "hChrsLimit", "hQrbFilter", "hChrsFilter", "hChoFl", "hChlrFl", "hChrbFi", "hChrbFl", "hchlHandler", "hChlFormat", "hCharHandler", "hQurlFormat", "hQrFormat", "hQurlFl", "hQurFactor", "hchlFactor", "hQurlFilter", "hChrsFactor", "hChrlFl", "hChrsFl", "hChlLimit", "hChrFactor", "hCharFilter", "hQrFi", "hChoFilter", "hChrsHandler", "hChrbFilter", "hCharLimit", "hChoFi", "hChrLimit", "hQrbFormat", "hChlrFi", "hChrlFactor", "hChlFactor", "hChrlFormat", "hchrHandler", "hQurFilter", "hQrFl", "hQrbFl"], "hChrFilterPos": ["hChuFactorLen", "hChbFilterpos", "hChrFilterNum", "hChrBufferPos", "hChrFilterOffset", "hChrMaskPos", "hChbListenerNum", "hChrBufferOffset", "hChrFactorLen", "hChrtRulePos", "hChrListenerSlot", "hChrtFilterpos", "hChrLimitPos", "hChrFilterLen", "hChrLayerOffset", "hChrFilterpos", "hChrBufferMin", "hChrListenerPos", "hChrtFilterMin", "hChrRuleTop", "hChrtFilterTop", "hChrFilterMin", "hChrListenerNum", "hChrtRulepos", "hChbListenerpos", "hChrMaskMin", "hChrFormatPos", "hChrFactorPos", "hChuFilterMin", "hChrBufferLen", "hChrLimitNum", "hChrListenerpos", "hChrRulePos", "hChuFactorOffset", "hChrFormatMin", "hChbFilterNum", "hChuFilterLen", "hChrMaskpos", "hChrtFilterPos", "hChuFactorPos", "hChrtRuleTop", "hChrFormatTop", "hChuFilterOffset", "hChbFilterPos", "hChrFilterSlot", "hChbListenerPos", "hChuFilterPos", "hChrLayerPos", "hChrRuleNum", "hChrtRuleMin", "hChrLayerMin", "hChbListenerSlot", "hChrMaskTop", "hChrLimitSlot", "hChrFactorOffset", "hChbFilterSlot", "hChrFilterTop", "hChrRuleMin", "hChrLayerLen", "hChrRuleSlot", "hChrFormatpos", "hChrLimitpos", "hChuFactorMin", "hChrFactorMin", "hChrRulepos"], "hChrFilterSize": ["hCherFilterStyle", "hChrlFilterNumber", "hChrFactorSize", "hChrRefSize", "hChrFilterStyle", "hChrFilterOffset", "hChrBufferOffset", "hCherBufferConf", "hChrtFilterInfo", "hChrBufferInfo", "hChrFactorStyle", "hChrFilterLen", "hChrFilter2", "hChrFileSize", "hCherBufferStyle", "hChrtLimitInfo", "hChrFileStyle", "hChrFilterConf", "hChrBufferStyle", "hChrLimitOffset", "hChrtFilterOffset", "hChrlFactorSize", "hChrRefStyle", "hCherFilterConf", "hChrFactorNumber", "hChrBufferConf", "hChrChannelSize", "hChrlFilter2", "hChrChannelNumber", "hCherFilterSize", "hChrRefConf", "hChrLimitStyle", "hChrUserSize", "hChrUserNumber", "hChrBufferLen", "hChrUser2", "hCherFilterLen", "hChrtFilterSize", "hChrlFactorSource", "hChrFilterSource", "hChrFactorInfo", "hChrtLimitStyle", "hCherBufferSize", "hChrUserSource", "hCherBufferLen", "hChrlFactor2", "hChrFileConf", "hChrtFilterStyle", "hChrBufferSize", "hChrFilterInfo", "hChrLimitSize", "hChrlFilterSource", "hChrFilterNumber", "hChrLimitInfo", "hChrtLimitSize", "hChrFactorOffset", "hChrFileLen", "hChrRefLen", "hChrFactor2", "hChrlFactorNumber", "hChrChannelSource", "hChrChannel2", "hChrlFilterSize", "hChrFactorSource", "hChrtLimitOffset"], "formatConvBuffer": ["formatEnvBuff", "formatConcBuffer", "formatRevBuffer", "formatConcbuffer", "formatConcFile", "formatEnVEnd", "formatConverBuff", "formatRefBuff", "formatAncBuffer", "formatConviBuffer", "formatConfbuffer", "formatConVbuffer", "formatAncbuffer", "formatEnvBuffer", "formatConVBegin", "formatConfLimit", "formatConvBuff", "formatEnVBegin", "formatAnvFile", "formatRevFile", "formatConvcBegin", "formatEnvFormat", "formatConvcLimit", "formatConVBuffer", "formatConfFile", "formatConfBuff", "formatConVEnd", "formatConverbuffer", "formatAncBuff", "formatEnVFile", "formatConcBuff", "formatEnVBuffer", "formatConviBuff", "formatAncFile", "formatConfEnd", "formatAnfBuffer", "formatAnfBegin", "formatConvBegin", "formatEnvEnd", "formatConfBuffer", "formatConVFormat", "formatConvcBuffer", "formatEnvBegin", "formatConVBuff", "formatAnvBuff", "formatAnfBuff", "formatConvbuffer", "formatConfFormat", "formatAnvBegin", "formatRefFile", "formatConvtBegin", "formatConvtBuff", "formatConverFile", "formatEnVFormat", "formatAnvBuffer", "formatConvtBuffer", "formatConviFile", "formatAnvLimit", "formatConvLimit", "formatConvFile", "formatConvtEnd", "formatEnVBuff", "formatRevbuffer", "formatRefbuffer", "formatConfBegin", "formatRefBuffer", "formatConVLimit", "formatAnvbuffer", "formatConvibuffer", "formatRevBuff", "formatConVFile", "formatConvtFormat", "formatEnvFile", "formatConverBuffer", "formatConvtFile", "formatConvcBuff", "formatAnfLimit", "formatConvFormat", "formatConvEnd"], "pal": ["area", "phil", "val", "pixel", "local", "align", "pel", "stal", "paren", " Pal", "sal", "nav", "app", "Pal", "raf", "conf", "pol", "ascal", "alpha", "abl", "pl", "padding", "opal", "gam", "par", "isal", "scale", "fal", "cal", "real", "ar", "chal", "al", "color", "rel", "alias", "fac", "pad", "gal"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114, "substitutes": {"base": ["channel", "ode", "ada", "area", "zero", "root", "as", "m", "bin", "ca", "fs", "id", "code", "i", "l", "native", "a", "name", "source", "os", "x", "ase", "buffer", "ace", "ite", "Base", "scope", "total", "server", "frame", "u", "size", "p", "e", "resource", "http", "b", "byte", "ix", "n", "f", "origin", "gb", "padding", "address", "state", "parent", "c", "proxy", "type", "offset", "file", "bas", "scale", "bi", "cache", "ases", "prefix", "core", "et", "y", "bit", "index", "start"], "irq": ["ircqi", "irqs", "iperqa", "irf", "ircqs", "mirf", "iraqu", "earqi", "iperq", "ircp", "irqa", "irqi", "irtq", "irtx", "irtf", "irep", "ircq", "mirq", "earqu", "iraq", "ircqa", "yrx", "iperqs", "iperp", "ireqa", "irx", "earqs", "irtc", "ircqu", "irp", "ireq", "iraqs", "yrq", "mirx", "mirc", "earq", "ireqs", "yrc", "yrf", "iraqi", "irqu", "irc"], "chr": ["corc", "schran", "corrt", "chanrar", " chro", "Chrn", "schrt", "schr", "chro", "echr", "schc", "CHrb", "chrs", "thrt", "chnr", " chrs", "chsr", " chsr", "echrs", "Char", "chnar", "chnrar", "chrn", "CHlr", "CHrt", "schru", "schrb", "corru", "chlr", "echrt", "CHro", " chru", " chrb", "chanrn", " chlr", "Chsr", "chanr", "Chr", "chran", "chc", "CHr", "chrb", "CHran", " chran", " chc", "thrs", "Chrar", "chrar", "chrf", "chrt", "corrf", "CHsr", "chru", "chnrn", "schrs", "corrs", "corr", "echrf", "Chro", "thrf", " chrt", "thr", "chanar", "Chlr"], "iomemtype": ["iominemype", "iomemersize", "iomamformat", "iomomstate", "iomademping", "iomomtypes", "iomemsize", "homademtype", "homademtypes", "iomemype", "iominemror", "iomemformat", "iomademtypes", "iomamype", "iomademtype", "iomademstate", "oriademsize", "iomemstate", "iomemType", "iomomtype", "oriemType", "homemstate", "iominemtype", "iomeltypes", "oriemping", "iomembformat", "homademcat", "iomemeType", "homademstate", "ionicemformat", "iomemerType", "iomemcat", "homemtypes", "ionicemtype", "iomemror", "iomemeping", "iomamtype", "iomembtype", "oriademType", "ionicembtype", "ionicembype", "ionicemror", "oriemtype", "iomemesize", "iomembror", "oriemsize", "iomemetype", "iomemertype", "oriademping", "iomelstate", "iomembype", "iomamror", "iomemping", "oriademtype", "ionicembformat", "iomemtypes", "iomeltype", "iomademType", "ionicemype", "iomemerping", "iomelcat", "ionicembror", "homemtype", "iomademsize", "iomomcat", "iominemformat", "homemcat", "iomademcat"], "s": ["south", "sys", "ses", "m", "d", "t", "service", "sg", "sync", "fs", "l", "i", "rs", "a", "g", "cs", "S", "settings", "os", "new", "its", "status", "si", "js", "es", "sq", "full", "session", "server", "v", "ps", "ss", "conf", "o", "w", "u", "p", "e", "se", "socket", "http", "b", "sb", "site", "n", "f", "gs", "state", "spec", "c", "ns", "is", "ssl", "sl", "states", "r", "ds", "services", "su", "ls", "ts", "support", "y"]}}
{"project": "qemu", "commit_id": "dd09c36159858c66ab6e47c688e4177dd3912bf0", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118, "substitutes": {"ctx": ["context", "tx", "cam", "pkg", "cm", "bc", "cv", "ca", "rc", "cc", "pc", "Context", "lc", "ctrl", "conv", "txt", "cmp", "abc", " cx", "conn", "grad", "cca", "c", "anc", "cb", "cas", "cp", "xc", "cpp"], "gprn": ["gPRr", "gPRn", "rgPRN", "gprr", "gPRns", "gPrN", "rgprN", " gprns", " gprN", "gprN", "gprne", "gPrn", "gPrne", "gprns", " gPrne", " gPrn", "rgprns", "rgPRns", "gPRne", "gPrr", "rgPRn", " gprne", "gPRN", "rgPRr", "rgprn", "gPrns", "rgprr", " gPrN", " gPrns"], "sprn": ["prb", "prr", "sprr", "sprN", "Sprr", "prn", " sprN", " sprr", " sprb", "SprN", "prN", "sprb", "Sprb", "Sprn"]}}
{"project": "qemu", "commit_id": "f3c75d42adbba553eaf218a832d4fbea32c8f7b8", "target": 1, "func": "static int cpu_load_old(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    PowerPCCPU *cpu = opaque;\n\n    CPUPPCState *env = &cpu->env;\n\n    unsigned int i, j;\n\n    target_ulong sdr1;\n\n    uint32_t fpscr;\n\n    target_ulong xer;\n\n\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gpr[i]);\n\n#if !defined(TARGET_PPC64)\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->gprh[i]);\n\n#endif\n\n    qemu_get_betls(f, &env->lr);\n\n    qemu_get_betls(f, &env->ctr);\n\n    for (i = 0; i < 8; i++)\n\n        qemu_get_be32s(f, &env->crf[i]);\n\n    qemu_get_betls(f, &xer);\n\n    cpu_write_xer(env, xer);\n\n    qemu_get_betls(f, &env->reserve_addr);\n\n    qemu_get_betls(f, &env->msr);\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->tgpr[i]);\n\n    for (i = 0; i < 32; i++) {\n\n        union {\n\n            float64 d;\n\n            uint64_t l;\n\n        } u;\n\n        u.l = qemu_get_be64(f);\n\n        env->fpr[i] = u.d;\n\n    }\n\n    qemu_get_be32s(f, &fpscr);\n\n    env->fpscr = fpscr;\n\n    qemu_get_sbe32s(f, &env->access_type);\n\n#if defined(TARGET_PPC64)\n\n    qemu_get_betls(f, &env->spr[SPR_ASR]);\n\n    qemu_get_sbe32s(f, &env->slb_nr);\n\n#endif\n\n    qemu_get_betls(f, &sdr1);\n\n    for (i = 0; i < 32; i++)\n\n        qemu_get_betls(f, &env->sr[i]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->DBAT[i][j]);\n\n    for (i = 0; i < 2; i++)\n\n        for (j = 0; j < 8; j++)\n\n            qemu_get_betls(f, &env->IBAT[i][j]);\n\n    qemu_get_sbe32s(f, &env->nb_tlb);\n\n    qemu_get_sbe32s(f, &env->tlb_per_way);\n\n    qemu_get_sbe32s(f, &env->nb_ways);\n\n    qemu_get_sbe32s(f, &env->last_way);\n\n    qemu_get_sbe32s(f, &env->id_tlbs);\n\n    qemu_get_sbe32s(f, &env->nb_pids);\n\n    if (env->tlb.tlb6) {\n\n        // XXX assumes 6xx\n\n        for (i = 0; i < env->nb_tlb; i++) {\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte0);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].pte1);\n\n            qemu_get_betls(f, &env->tlb.tlb6[i].EPN);\n\n        }\n\n    }\n\n    for (i = 0; i < 4; i++)\n\n        qemu_get_betls(f, &env->pb[i]);\n\n    for (i = 0; i < 1024; i++)\n\n        qemu_get_betls(f, &env->spr[i]);\n\n    ppc_store_sdr1(env, sdr1);\n\n    qemu_get_be32s(f, &env->vscr);\n\n    qemu_get_be64s(f, &env->spe_acc);\n\n    qemu_get_be32s(f, &env->spe_fscr);\n\n    qemu_get_betls(f, &env->msr_mask);\n\n    qemu_get_be32s(f, &env->flags);\n\n    qemu_get_sbe32s(f, &env->error_code);\n\n    qemu_get_be32s(f, &env->pending_interrupts);\n\n    qemu_get_be32s(f, &env->irq_input_state);\n\n    for (i = 0; i < POWERPC_EXCP_NB; i++)\n\n        qemu_get_betls(f, &env->excp_vectors[i]);\n\n    qemu_get_betls(f, &env->excp_prefix);\n\n    qemu_get_betls(f, &env->ivor_mask);\n\n    qemu_get_betls(f, &env->ivpr_mask);\n\n    qemu_get_betls(f, &env->hreset_vector);\n\n    qemu_get_betls(f, &env->nip);\n\n    qemu_get_betls(f, &env->hflags);\n\n    qemu_get_betls(f, &env->hflags_nmsr);\n\n    qemu_get_sbe32s(f, &env->mmu_idx);\n\n    qemu_get_sbe32(f); /* Discard unused power_mode */\n\n\n\n    return 0;\n\n}\n", "idx": 13130, "substitutes": {"f": ["func", "m", "ff", "self", "fd", "elf", "d", "t", "fs", "l", "inf", "fb", "def", "uf", "fm", "g", "fun", "fore", "h", "fx", "this", "fo", "full", "fp", "fn", "v", "fr", "buff", "of", "form", "o", "conf", "F", "p", "e", "fi", "info", "fed", "k", "b", "sf", "af", "bf", "fe", "c", "df", "feed", "tf", "file", "function", "cf", "rf", "fen", "fc", "fa", "fw"], "opaque": [" opcoe", "oplaque", " opaques", "Opaque", "opec", "operaco", "Opaco", "plaque", "opaco", "opaques", "operaque", "oplaques", " opacs", "operque", " opaco", " opque", "plaques", "operec", "placs", "Opec", "opque", "Opque", " opec", "plcoe", "opacs", "opcoe", "oplcoe", "oplacs"], "version_id": [" version0ids", " versionidsid", " version0hash", " versionidids", " version_ids", " versionidhash", " version_hash", " versionidid", "version_ids", "version_sid", " version0sid", " version_sid", " version0id", "version_hash"], "cpu": ["proc", "sys", "bench", "cow", "pc", "lc", "kernel", "uu", "pool", "uno", "vm", " cp", "linux", "fp", "hu", "pu", "platform", "conn", "prof", "processor", "loader", "p", " CPU", "fi", "boot", "cli", "CPU", "uci", "c", " gcc", "gpu", "clock", "cp", "cal", "cache", "ec", "core", "hw", "net", "node"], "env": ["en", "ff", "enh", "inf", "priv", "oa", "gear", "server", "np", "obj", "dict", "exe", "export", "end", "here", "ec", "chal", "fen", "ef", "forge", "args", "context", "eu", "limits", "vm", "dir", "console", "loader", "equ", "viron", "fi", "her", "ext", "assets", "eni", "qv", "ern", "enos", "cal", "exec", "gui", "cache", "ev", "el", "erv", "ea", "cv", "config", "extra", "fb", "style", "fun", "fg", "scope", "output", "conn", "e", "enable", "info", "exc", "engine", "site", "eng", "Environment", "cfg", "fe", "ne", "que", "inet", "pos", "net", "fw", "err", "enc", "ass", "estate", "v", "conf", "inv", "energy", "cli", "dat", "org", "den", "vel", "emb", "environment", "vs", "len", "esi", "esm"], "i": ["hi", "qi", "ui", "m", "slice", "I", "d", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "my", "io", "jp", "name", "me", "mu", "ci", "image", "x", "di", "si", "ie", "init", "ii", "v", "uri", "vi", "o", "yi", "z", "p", "e", "fi", "info", "mi", "li", "k", "b", "ix", "multi", "data", "n", "phi", "ti", "ip", "c", "eni", "ji", "type", "pi", "chi", "cli", "uli", "bi", "r", "ri", "ei", "zi", "y", "in", "index"], "j": ["it", "uni", "aj", "sync", "xi", "jp", "jump", "ja", "g", "jet", "js", "bj", "v", "job", "o", "obj", "z", "jit", "k", "b", "n", "jc", "je", "ji", "J", "ij"], "sdr1": ["ssdrone", "ssDRone", "ssdr1", "ssDR1", "scr1", "sdrone", "srs1", "sDR1", "ssrone", "sscrone", "ssdr2", "scrone", "srs2", "sdr2", "ssr2", "sDRone", "ssDR2", "scr3", "sscr3", "ssdr3", "ssr1", "sDR2", "ssr3", "sscr1", "sdr3", "srsone"], "fpscr": ["fpspr", "flagscr", "flagscre", "flagskr", "tailscr", "fpskr", "framescr", "framesrc", "fpscre", "msctr", " fpsctr", "fpsCR", "tailsCR", "tailsrc", "fpsctr", "bpscr", "msCr", "bpsCr", "bitscr", "mscr", "bitscre", " fpsCr", "fscre", "tailscre", "fsrr", "flagsrr", "fspr", " fpsCR", "fsctr", " fpsrc", "bitsrr", " fpscre", "fpsrc", "fpsCr", "framesCR", "fscr", "bitskr", "bpsCR", " fpspr", "bpscre", "fsCr", "fskr", "mspr", "fpsrr", "bpsrc", "framesCr"], "xer": ["wer", "xesers", " xers", "exer", "xeseri", "xesar", "xester", "txer", "xe", " Xel", " Xe", "exers", "xers", "wers", " xeri", " Xer", "war", "xeri", "xeser", "txester", "exe", " Xester", " xester", "xar", "xel", " xel", "exeri", "txe", "exar", " xar", "we", "txel", " xe"], "u": ["ui", "uc", "ru", "d", "l", "up", "ue", "un", "iu", "back", "fu", "h", "uu", "x", "user", "hu", "v", "pu", "o", "ul", "w", "ut", "p", "e", "du", "nu", "c", "cu", "lu", "ur", "tu", "uv", "um", "su", "U", "us", "ou", "util", "y", "mu", "uid"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtoul_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 13136, "substitutes": {"str": ["Str", "vec", "rr", "stri", "frac", "hr", "enc", "tr", "in", "id", "code", "rs", "ctr", "kr", "lc", "cs", "er", "sp", "sr", "txt", "br", "fr", "cr", "obj", "temp", "STR", "ext", "old", "f", "spec", "arr", "start", "inner", "text", "iter", "r", "pr", "seq", "dr", "wrap", "res", "st", "prev", "ptr"], "endptr": ["endedproc", " endpointers", "endprot", "endpointer", "adpointers", "endedpointer", "endingptr", "endPtr", " endPtr", " endpointer", " endtr", "endproc", "endingpointers", "endedptr", "adpointer", " endproc", " endprot", "endedprot", "adproc", "endingpointer", "endpointers", "startpointer", "startproc", "endedtr", "startptr", "starttr", "adPtr", "endtr", "endingPtr", "adprot", "adptr"], "err": ["rr", "gr", "rc", "code", "ctr", "rar", "Error", "er", "req", "ner", "aster", "error", "Er", "fr", "rh", "var", "der", "cr", "z", "ind", "mr", "lr", "yr", "ver", "ler", "result", "c", "arr", "try", "acer", "iter", "out", "resp", "r", "pr", "ar", "dr", "res", "order", "ise", "ptr"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_midv_qrt_4w_msa(const uint8_t *src, int32_t src_stride,\n\n                                     uint8_t *dst, int32_t dst_stride,\n\n                                     int32_t height, uint8_t ver_offset)\n\n{\n\n    uint32_t loop_cnt;\n\n    v16i8 src0, src1, src2, src3, src4;\n\n    v16i8 mask0, mask1, mask2;\n\n    v8i16 hz_out0, hz_out1, hz_out2, hz_out3;\n\n    v8i16 hz_out4, hz_out5, hz_out6, hz_out7, hz_out8;\n\n    v8i16 dst0, dst1, dst2, dst3, dst4, dst5, dst6, dst7;\n\n\n\n    LD_SB3(&luma_mask_arr[48], 16, mask0, mask1, mask2);\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n\n\n    hz_out0 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                          mask0, mask1, mask2);\n\n    hz_out2 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                          mask0, mask1, mask2);\n\n\n\n    PCKOD_D2_SH(hz_out0, hz_out0, hz_out2, hz_out2, hz_out1, hz_out3);\n\n\n\n    hz_out4 = AVC_HORZ_FILTER_SH(src4, mask0, mask1, mask2);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src0, src1, src2, src3);\n\n        src += (4 * src_stride);\n\n        XORI_B4_128_SB(src0, src1, src2, src3);\n\n\n\n        hz_out5 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src0, src1,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n        hz_out7 = AVC_XOR_VSHF_B_AND_APPLY_6TAP_HORIZ_FILT_SH(src2, src3,\n\n                                                              mask0, mask1,\n\n                                                              mask2);\n\n\n\n        PCKOD_D2_SH(hz_out5, hz_out5, hz_out7, hz_out7, hz_out6, hz_out8);\n\n\n\n        dst0 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out0, hz_out1, hz_out2,\n\n                                               hz_out3, hz_out4, hz_out5);\n\n        dst2 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out1, hz_out2, hz_out3,\n\n                                               hz_out4, hz_out5, hz_out6);\n\n        dst4 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out2, hz_out3, hz_out4,\n\n                                               hz_out5, hz_out6, hz_out7);\n\n        dst6 = AVC_CALC_DPADD_H_6PIX_2COEFF_SH(hz_out3, hz_out4, hz_out5,\n\n                                               hz_out6, hz_out7, hz_out8);\n\n\n\n        if (ver_offset) {\n\n            dst1 = __msa_srari_h(hz_out3, 5);\n\n            dst3 = __msa_srari_h(hz_out4, 5);\n\n            dst5 = __msa_srari_h(hz_out5, 5);\n\n            dst7 = __msa_srari_h(hz_out6, 5);\n\n        } else {\n\n            dst1 = __msa_srari_h(hz_out2, 5);\n\n            dst3 = __msa_srari_h(hz_out3, 5);\n\n            dst5 = __msa_srari_h(hz_out4, 5);\n\n            dst7 = __msa_srari_h(hz_out5, 5);\n\n        }\n\n\n\n        SAT_SH4_SH(dst1, dst3, dst5, dst7, 7);\n\n\n\n        dst0 = __msa_aver_s_h(dst0, dst1);\n\n        dst1 = __msa_aver_s_h(dst2, dst3);\n\n        dst2 = __msa_aver_s_h(dst4, dst5);\n\n        dst3 = __msa_aver_s_h(dst6, dst7);\n\n\n\n        PCKEV_B2_SB(dst1, dst0, dst3, dst2, src0, src1);\n\n        XORI_B2_128_SB(src0, src1);\n\n\n\n        ST4x4_UB(src0, src1, 0, 2, 0, 2, dst, dst_stride);\n\n\n\n        dst += (4 * dst_stride);\n\n        hz_out0 = hz_out4;\n\n        hz_out1 = hz_out5;\n\n        hz_out2 = hz_out6;\n\n        hz_out3 = hz_out7;\n\n        hz_out4 = hz_out8;\n\n    }\n\n}\n", "idx": 13137, "substitutes": {"src": ["RC", "gz", "uc", "dist", "sync", "tmp", "rc", "config", "stream", "rs", "ctr", "sup", "source", "low", "sr", "cmp", "dest", "sq", "loc", "gru", "sil", "gn", "gl", "lib", "img", "rb", "sec", "desc", "comp", "pl", "sb", "inst", "scl", "gb", "url", "cb", "sc", "ssl", "rob", "sci", "bg", "sl", "chrom", "sub", "sel", "cur", "st", "fc", "ctx", "filename"], "src_stride": ["src_drides", "src_Strides", "src_bride", "src_strride", "src_brider", "src_brIDE", "src_Stride", "src_drider", "src_strides", "src_STRider", "src_trride", "src_striided", "src_strider", "src_tride", "src_STRides", "src_StrIDE", "src_brides", "src_striides", "src_striride", "src_strIDE", "src_brided", "src_STRided", "src_Strided", "src_STRide", "src_trided", "src_Strride", "src_brride", "src_trides", "src_drride", "src_striide", "src_STRIDE", "src_strided", "src_dride", "src_STRride"], "dst": ["bsp", "Dsp", "fest", "fsp", "fst", "Dest", "dest", "Dst", "Drc", "brc", "drc", "best", "frc", "dsp", "bst"], "dst_stride": ["dst_arrided", "dst_tride", "dst_trided", "dst_strride", "dst_strides", "dst_trides", "dst_divride", "dst_trride", "dst_strided", "dst_arrride", "dst_arrides", "dst_divides", "dst_divide", "dst_arride", "dst_divided"], "height": ["Height", "ch", "slice", "build", "input", "thin", "bottom", "top", "id", "i", "level", "shape", "def", "row", "gap", "h", "boost", "kw", "size", "img", "data", "op", "length", "th", "padding", "resolution", "prev", "diff", "timeout", "block", "dim", "hd", "headers", "layout", "high", "window", "windows", "depth", "header", "y", "index"], "ver_offset": ["block_padding", "blocklenmask", "verprepadding", "blocklenno", "ver_padding", "verpremask", "verlenoffset", "verlenno", "ver_no", "verlenpadding", "blocklenoffset", "block_no", "verpreno", "block_mask", "ver_mask", "blocklenpadding", "verpreoffset", "block_offset", "verlenmask"], "loop_cnt": ["loop_acct", "loop_secount", "loop_lcct", "loop_cct", "loop_acnc", "loop_Cant", "loop_lcnt", "loop_secnd", "loop_CNT", "loop_ncnt", "loop_dcnt", "loop_secnt", "loop_lcno", "loop_ctrl", "loop_lcnc", "loop_ncant", "loop_cNT", "loop_cno", "loop_counttrl", "loop_Count", "loop_acno", "loop_acnt", "loop_acnd", "loop_nctrl", "loop_ncNT", "loop_Ctrl", "loop_dcct", "loop_acNT", "loop_countnt", "loop_cnc", "loop_acount", "loop_cnd", "loop_dcnc", "loop_Cnd", "loop_countNT", "loop_Cnt", "loop_cant", "loop_dcno", "loop_count", "loop_secNT", "loop_countant"], "src0": [" src60", "loc3", "rc2", "seq1", "loc0", "rc0", "src60", "src00", " src00", "source2", "source1", "rc00", "source0", "loc1", "seq0", "rc3", "rc4", "source4", "seq2", "rc60", "loc2", "seq60", "rc1", "loc00"], "src1": ["loc3", "inst0", "inst1", "rc2", "source3", "loc0", "rc0", "inst2", "loc4", "source1", "source0", "loc8", "loc1", "rc3", "rc4", "rc8", "source4", "inst8", "loc2", "rc1", "src8"], "src2": ["source02", "loc3", "source8", "rc2", "loc0", "rc0", "loc4", "source2", " src8", "source1", "loc1", "rc3", "rc4", "rc02", "source4", "rc8", "src02", "loc2", "rc1", " src02", "src8"], "src3": ["loc3", "source03", "src03", "loc03", "rc2", "sur3", "source3", "dist1", "g", "src23", "rc03", "source2", "sur4", "source1", "sur5", "dist03", "rc5", "s", "loc1", "dist3", "rc3", "rc4", "rc23", "dist23", "source4", "dist2", "sur1", "src5", "source23", "loc2", " src5", "rc1", "source5"], "src4": ["source8", "rc44", "src44", "rc40", "rc2", "source3", " src40", "dist8", "source40", "source2", "source44", " src8", "dist44", "src40", "rc5", "dest2", "dest3", "dist4", "rc3", "rc4", "source4", "rc8", "dist2", "dest4", "src5", " src5", "source5", "dest8", "src8"], "mask0": ["ask50", "ask00", "ph1", "fix0", "miss2", "ask0", "sum2", "ph0", "ask2", "ph5", " mask50", "mask00", "fix5", "weight0", "sum1", "fix1", " mask5", "miss1", "weight00", "mask50", "shape2", "ask1", " mask00", "shape1", "shape5", "shape0", "weight1", "miss0", "miss00", "fix2", "ph2", "ask5", "sum0", "weight50", "mask5"], "mask1": ["ask3", "miss2", "miss8", "mark3", "weight2", "ask0", "mark4", "mark0", "mask3", "ask2", "weight0", "mark1", "weight4", "ask4", " mask4", "miss1", "ask1", "mask4", "mark2", "ask8", "weight1", "miss0", " mask3", "mask8", "miss4", " mask8"], "mask2": ["ask3", "miss2", "sum2", "mask3", "ask2", "sum4", "sum3", "ask4", " mask4", "miss3", "pack2", "sum5", "sum1", "ask6", "miss1", " mask5", " mask6", "ask1", "mask4", "pack3", "mask6", " mask3", "pack6", "ask5", "pack4", "miss4", "mask5"], "hz_out0": ["hz_mask0", "hz_option3", "hz_OUT12", "hz_OUT19", "hz_in0", "hz_in1", "hz_sum0", "hz_sum8", "hz_sum10", "hz_no0", "hz_OUT2", "hz_in12", "hz_in10", "hz_out10", "hz_again1", "hz_no3", "hz_mask12", "hz_again3", "hz_out12", "hz_no8", "hz_in19", "hz_OUT3", "hz_again0", "hz_in8", "hz_option8", "hz_option1", "hz_out19", "hz_OUT0", "hz_again19", "hz_in3", "hz_sum1", "hz_OUT1", "hz_no1", "hz_in2", "hz_exp1", "hz_exp0", "hz_exp8", "hz_exp10", "hz_mask1", "hz_mask2", "hz_option0"], "hz_out1": ["hz_in1", "hz_OUT2", "hz_outOne", "hz_nin1", "hz_in7", "hz_exp7", "hz_option11", "hz_nin2", "hz_optionOne", "hz_inOne", "hz_option2", "hz_OUTOne", "hz_in8", "hz_nin8", "hz_OUT11", "hz_option1", "hz_nin7", "hz_exp2", "hz_OUT1", "hz_in2", "hz_exp1", "hz_in11", "hz_out11", "hz_exp8"], "hz_out2": ["hz_Out2", "hz_copy2", "hz_copy5", "hz_OUT2", "hz_nin5", "hz_name1", "hz_option2", "hz_in4", "hz_Out4", "hz_nin4", "hz_option7", "hz_Out3", "hz_in02", "hz_name02", "hz_off1", "hz_OUT82", "hz_in7", "hz_off2", "hz_nin2", "hz_nin82", "hz_inTwo", "hz_name7", "hz_out02", "hz_OUT5", "hz_name2", "hz_in0", "hz_OutTwo", "hz_out82", "hz_option02", "hz_outTwo", "hz_in3", "hz_OUTTwo", "hz_in2", "hz_copy82", "hz_in1", "hz_off0", "hz_copy4", "hz_Out1", "hz_off3", "hz_option1", "hz_OUT4", "hz_OUT1", "hz_Out0"], "hz_out3": ["hz_update6", "hz_again305", "hz_num3", "hz_Out3", "hz_index305", "hz_index6", "hz_Out2", "hz_in1", "hz_num2", "hz_Out1", "hz_num1", "hz_update5", "hz_num03", "hz_Out03", "hz_again3", "hz_out03", "hz_index3", "hz_again6", "hz_update3", "hz_out305", "hz_again5", "hz_in3", "hz_in2", "hz_update305", "hz_index5", "hz_in03"], "hz_out4": ["hz_sum4", "hz_sum12", "hz_sum3", "hz_sum8", "hz_sum2", "hz_again2", "hz_sum32", "hz_out32", "hz_again12", "hz_again3", "hz_out12", "hz_again32", "hz_in8", "hz_in4", "hz_in3", "hz_again8", "hz_in32", "hz_in2", "hz_in12", "hz_again4"], "hz_out5": ["hz_inL", "hz_in5", "hz_outerL", "hz_in1", "hz_outer1", "hz_again2", "hz_outer2", "hz_again1", "hz_outer5", "hz_outL", "hz_again5", "hz_in2", "hz_againL"], "hz_out6": ["hz_index6", "hz_over12", "hz_index7", "hz_in7", "hz_index12", "hz_over6", "hz_out12", "hz_in6", "hz_over7", "hz_in2", "hz_index2", "hz_over2", "hz_in12"], "hz_out7": ["hz_exp57", "hz_nin57", "hz_out57", "hz_in7", "hz_exp7", "hz_in17", "hz_exp27", "hz_in27", "hz_nin27", "hz_in57", "hz_nin7", "hz_out17", "hz_exp17", "hz_nin17", "hz_out27"], "hz_out8": ["hz_in5", "hz_in1", "hz_again2", "hz_OUT2", "hz_OUT8", "hz_again1", "hz_in8", "hz_again5", "hz_OUT1", "hz_again8", "hz_in2", "hz_OUT5"], "dst0": ["lest1", "lst4", "dost2", "dest0", "lest2", "dsc2", "lst1", "lst0", "dest1", "dost1", "dost4", "lst2", "dest2", "dsc1", "lest4", "lest0", "dost0", "dest4", "dsc0", "dsc4"], "dst1": [" dsc1", "dest0", "dsp1", "dsc2", "dest1", "dst01", " dsc2", "dest2", " dsc01", "dsc1", " dsc0", " dst01", "dest01", "dsc01", "dsp0", "dsp01", "dsp2", "dsc0"], "dst2": ["ddest4", " dest2", "ddest5", " dest4", " dest1", "dconst2", "dest1", "dest5", "dest2", "dconst4", "dest4", "ddest1", "dconst1", " dest5", "dconst5", "ddest2"], "dst3": ["ddest4", " dest2", " dest3", " dest4", "ddest3", " dest1", "dest1", "dgest1", "dgest2", "dgest4", "dest2", "dest3", "dgest3", "dest4", "ddest1", "ddest2"], "dst4": ["dST5", " dest2", "dST54", " dest4", "dST4", "dgest54", "dgest2", "dgest5", "dgest4", "dest5", "dest2", " dest54", "dest4", " dest5", "dST2", " dst54", "dest54", "dst54"], "dst5": [" dest2", " dest4", "dsts4", " dest55", "dgest2", "dgest5", "dgest4", "dest5", "dest2", "dsts55", "dsts5", " dst55", "dsts2", "dst55", "dest4", " dest5", "dest55", "dgest55"], "dst6": ["destSix", "ddestSix", " dest8", "ddest8", "dstage6", "dstSix", "dst8", " dstSix", " destSix", "dstage8", " dest7", " dest6", "dstageSix", "dest6", "ddest7", "ddest6", " dst8", "dest8", "dest7", "dstage7"], "dst7": [" ddest7", " ddest6", "dST6", "dST77", "ddest8", "dst77", " ddest77", "dst8", "dST7", "dST8", " ddest8", " dst77", "dest6", "ddest7", "ddest6", "dest77", "ddest77", " dst8", "dest8", "dest7"]}}
{"project": "qemu", "commit_id": "afcf905cff7971324c2706600ead35a1f41f417a", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140, "substitutes": {"data": ["func", "args", "map", "root", "input", "d", "array", "config", "memory", "style", "a", "def", "api", "ra", "image", "this", "missing", "module", "buffer", "writer", "script", "error", "alpha", "ad", "media", "resource", "buf", "base", "entry", "reader", "result", "parent", "dat", "parser", "arr", "Data", "attr", "DATA", "cache", "db", "window", "pad", "message"], "user_data": [" user_Data", " user_ad", "user_Data", "user_ad"], "var": ["func", "aver", "as", "val", "name", "er", "vari", "ref", "arg", "mod", "comment", "AR", "app", "av", "bar", "adr", "parse", "dev", "rec", "pack", "ver", "ars", "car", "reader", "Var", "spec", "arr", "cat", "par", "type", "attr", "param", "ar", "dr", "tag", "cur", "err"]}}
{"project": "qemu", "commit_id": "36b15c79aa1bef5fe7543f9f2629b6413720bbfb", "target": 0, "func": "static void virtio_scsi_handle_cmd(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    /* use non-QOM casts in the data path */\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n    VirtIOSCSICommon *vs = &s->parent_obj;\n\n\n\n    VirtIOSCSIReq *req;\n\n    int n;\n\n\n\n    while ((req = virtio_scsi_pop_req(s, vq))) {\n\n        SCSIDevice *d;\n\n        int out_size, in_size;\n\n        if (req->elem.out_num < 1 || req->elem.in_num < 1) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        out_size = req->elem.out_sg[0].iov_len;\n\n        in_size = req->elem.in_sg[0].iov_len;\n\n        if (out_size < sizeof(VirtIOSCSICmdReq) + vs->cdb_size ||\n\n            in_size < sizeof(VirtIOSCSICmdResp) + vs->sense_size) {\n\n            virtio_scsi_bad_req();\n\n        }\n\n\n\n        if (req->elem.out_num > 1 && req->elem.in_num > 1) {\n\n            virtio_scsi_fail_cmd_req(req);\n\n            continue;\n\n        }\n\n\n\n        d = virtio_scsi_device_find(s, req->req.cmd->lun);\n\n        if (!d) {\n\n            req->resp.cmd->response = VIRTIO_SCSI_S_BAD_TARGET;\n\n            virtio_scsi_complete_req(req);\n\n            continue;\n\n        }\n\n        req->sreq = scsi_req_new(d, req->req.cmd->tag,\n\n                                 virtio_scsi_get_lun(req->req.cmd->lun),\n\n                                 req->req.cmd->cdb, req);\n\n\n\n        if (req->sreq->cmd.mode != SCSI_XFER_NONE) {\n\n            int req_mode =\n\n                (req->elem.in_num > 1 ? SCSI_XFER_FROM_DEV : SCSI_XFER_TO_DEV);\n\n\n\n            if (req->sreq->cmd.mode != req_mode ||\n\n                req->sreq->cmd.xfer > req->qsgl.size) {\n\n                req->resp.cmd->response = VIRTIO_SCSI_S_OVERRUN;\n\n                virtio_scsi_complete_req(req);\n\n                continue;\n\n            }\n\n        }\n\n\n\n        n = scsi_req_enqueue(req->sreq);\n\n        if (n) {\n\n            scsi_req_continue(req->sreq);\n\n        }\n\n    }\n\n}\n", "idx": 13149, "substitutes": {"vdev": [" vnd", "Vconf", "vdef", " vconf", "wdev", "Vdev", "Vnd", "Vdef", "wdevice", "lnd", "ldef", "ldev", "vdevice", "wconf", "vnd", " vdevice", "Vdevice", "vconf", "ldevice", " vdef", "wdef"], "vq": ["Vq", "Vdq", "vmsq", "vqueue", "vsq", "vmq", "pw", "vdq", " vw", "vmqueue", "vue", "Vw", " vqueue", "vw", " vue", "Vue", "pue", "pq", " vdq", "Vsq", "vmdq", " vsq", "Vqueue", "pqueue"], "s": ["sys", "ses", "self", "m", "service", "t", "sg", "i", "rs", "a", "g", "cs", "S", "sp", "os", "sk", "si", "js", "session", "server", "v", "ps", "ss", "o", "w", "sid", "p", "e", "sec", "sb", "b", "j", "f", "gs", "spec", "c", "ns", "ssl", "sv", "q", "services", "ds", "r", "sa", "su", "sis"], "vs": ["args", "vers", "env", "vr", "bs", "fs", "vp", "rs", "utils", "forces", "g", "cs", "values", "qs", "os", "sk", "vm", "nav", "v", "ps", "flags", "ves", "grad", "views", "params", "VS", "dev", "alls", "eps", "obs", "http", "ums", "gs", "ns", "xs", "vg", "outs", "ov", "sv", "va", "ops", "ds", "vc", "vd", "ls", "vt", "ims", "vals", "ks"], "req": ["sem", "proc", "art", "cook", "def", "msg", "low", "str", "cmp", "ind", "rec", "rb", "ver", "requ", "spec", "serv", "cb", "md", "pro", "get", "ae", "ec", "dr", "call", "rev", "ru", "dq", "id", "ctr", "progress", "arg", "fr", "client", "grad", "loader", "resource", "require", "data", "ext", "result", "url", "iq", "urg", "r", "exec", "cache", "pr", "ev", "res", "reg", "rel", "rf", "release", "qi", "rr", "ch", "gr", "tr", "config", "task", "wx", "ref", "Request", "rh", "conn", "z", "sec", "ir", "desc", "rx", "http", "comp", "qt", "j", "f", "dep", "query", "inc", "wa", "load", "rt", "rep", "cur", "cl", "ctx", "err", "qa", "hr", "input", "jp", "required", "range", "row", "respond", "this", "mod", "sq", "conf", "quest", "request", "form", "p", "crit", "pull", "q", "cmd", "org", "resp", "qq", "src", "seq"], "n": ["m", "t", "l", "i", "nn", "N", "g", "nb", "nd", "v", "conn", "o", "w", "z", "p", "e", "nc", "k", "b", "f", "c", "ns", "ng", "nt", "r", "nr", "num", "in"], "d": ["dh", "D", "m", "dq", "fd", "t", "rd", "l", "i", "id", "da", "ded", "bd", "dl", "di", "nd", "ld", "v", "gd", "de", "pd", "dy", "dx", "cd", "z", "ind", "dev", "p", "e", "dB", "ad", "u", "data", "b", "driver", "j", "f", "xd", "dat", "c", "dt", "dc", "md", "r", "ds", "dd", "dn", "dr", "dos"], "out_size": [" out64sized", " out64size", "out_value", "outlexset", " out64set", "out64set", " out_scale", " out_sized", "outlexsized", "outlexsize", " out_count", "point_value", "outCvalue", "out64size", "outCsize", "out_sized", "out_set", "out_count", "out_bytes", "out_scale", "point_bytes", "outlexstream", " out_set", " out64stream", "out_stream", "out_capacity", "outCbytes", "out64sized", "out64stream", "point_ize", "out_ize", "outCize", " out_stream", "point_size", " out_capacity"], "in_size": ["in_length", "in\u00b7loc", " in_speed", "inACwidth", "inxize", "inc_sym", "inxwidth", "in_align", "in67align", "inACsym", "in_ize", "in_weight", "in67speed", "In_ize", "in\u00b7size", " in_loc", "inc_length", "inAClength", " in_align", "inc_width", "in_loc", "inxsize", "in_width", "in_speed", "in_sym", "in\u00b7speed", "inc_size", "in67loc", "inxweight", "In_weight", "In_size", "in67size", "in\u00b7align", "inACsize", "In_width"]}}
{"project": "qemu", "commit_id": "d82831dbc5471d72785c49b33710436af49bf9ca", "target": 0, "func": "CharDriverState *text_console_init(QemuOpts *opts)\n\n{\n\n    CharDriverState *chr;\n\n    QemuConsole *s;\n\n    unsigned width;\n\n    unsigned height;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n\n\n    width = qemu_opt_get_number(opts, \"width\", 0);\n\n    if (width == 0)\n\n        width = qemu_opt_get_number(opts, \"cols\", 0) * FONT_WIDTH;\n\n\n\n    height = qemu_opt_get_number(opts, \"height\", 0);\n\n    if (height == 0)\n\n        height = qemu_opt_get_number(opts, \"rows\", 0) * FONT_HEIGHT;\n\n\n\n    if (width == 0 || height == 0) {\n\n        s = new_console(NULL, TEXT_CONSOLE);\n\n    } else {\n\n        s = new_console(NULL, TEXT_CONSOLE_FIXED_SIZE);\n\n    }\n\n\n\n    if (!s) {\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n\n\n    s->chr = chr;\n\n    s->g_width = width;\n\n    s->g_height = height;\n\n    chr->opaque = s;\n\n    chr->chr_set_echo = text_console_set_echo;\n\n    return chr;\n\n}\n", "idx": 13154, "substitutes": {"opts": ["opments", "hopws", "optls", "opted", "optted", "opert", "lintics", "hopts", "hopsts", "operments", "OPs", "opouts", "okTS", "optops", "optics", "linments", "OPouts", "opops", "okops", "optTS", "optouts", "opertics", "operted", "optionts", "OPfs", " optics", "opers", "lints", "optsts", " opsts", "hoptics", "opws", "operls", "operTS", "OPt", "operops", "optws", "opfs", "opTS", "optiont", "optments", "OPts", "optionfs", "OPments", "optt", "optts", "opsts", "opttics", "linls", "okted", "ops", "optionouts", "okts", "opls", " opws", "opt", "optfs", "operts"], "chr": ["charrc", " chpr", "schran", "ichdr", "achrf", "clnr", " chp", "cher", "colr", "chrl", "Chcr", "achr", " chlr", "chrb", " chran", "charlr", "colru", "charpr", " chrw", "chpr", "Chpr", "corr", "charr", "charre", "cyr", "chre", "Chrl", "qrl", "chrw", "cordr", "ichrb", "ctr", "chsr", "ichro", "hlr", "chlr", "cylr", "colnr", "chran", "cyrb", "chrt", "hrf", "shro", "Chrw", "ichlr", " chrt", "ichr", "charar", " chrc", "schrt", "schr", " chcr", "shr", "chro", " chrl", "chnr", "ctrt", "chrc", "ctran", "ctrf", "qrb", "achru", "qrw", "colrf", " chru", "achre", "clrl", "Chr", "colrl", "charrf", "Chrb", "chrf", "shsr", "charru", "ichsr", "corsr", "ichrf", "clr", "schrf", "Chp", "chelr", "chru", "charp", "colre", " chrf", "hr", " chnr", "shdr", "cherc", " chrb", "charcr", "hrb", "chcr", "chdr", "qr", "chp", "corro", "cyrf", "clru", "chear"], "s": ["south", "sys", "ses", "m", "service", "t", "sync", "sg", "d", "fs", "l", "i", "rs", "sym", "g", "cs", "S", "hs", "settings", "os", "h", "its", "str", "si", "js", "es", "sq", "rows", "session", "server", "v", "scope", "ps", "ss", "storage", "client", "o", "secure", "w", "u", "params", "sid", "p", "e", "sign", "share", "socket", "http", "sf", "sb", "b", "n", "f", "lines", "gs", "spec", "c", "ns", "shell", "is", "stats", "ssl", "side", "sv", "sl", "ops", "r", "services", "ds", "better", "su", "ls", "ts"], "height": ["upper", "stroke", "head", "hip", "Height", "deep", "slice", "build", "thin", "bottom", "grow", "arrow", "id", "level", "density", "shape", "style", "shadow", "row", "gap", "ths", "weight", "h", "missing", "how", "gh", "crop", "square", "gain", "rh", "rank", "hang", "pass", "view", "size", "ady", "tight", "direction", "huge", "han", "length", "th", "padding", "gravity", "resolution", "inches", "above", "pull", "east", "hold", "angle", "layout", "volume", "work", "window", "ty", "y", "depth", "index"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t eepro100_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    EEPRO100State *s = opaque;\n\n\n\n    switch (size) {\n\n    case 1: return eepro100_read1(s, addr);\n\n    case 2: return eepro100_read2(s, addr);\n\n    case 4: return eepro100_read4(s, addr);\n\n    default: abort();\n\n    }\n\n}\n", "idx": 13155, "substitutes": {"opaque": ["OPec", "Opaque", " opctx", "opec", "oppaques", "Opctx", "oppacity", "opatile", "oppaque", "oppatile", "operacity", "ipopatile", "opaques", "ipopacity", "operaque", "ipopaque", "opacity", "OPacity", "operatile", "ipopaques", "Opec", " opacity", "OPctx", "Opacity", " opec", "OPaque", "opctx", "operaques"], "addr": ["ord", "args", "device", "port", "edge", "part", "adder", "amd", "config", "i", "oa", "a", "align", "image", "null", "x", "ref", "ace", "server", "error", "np", "index", "grad", "adr", "ad", "p", "e", "layer", "rx", "socket", "data", "pointer", "base", "byte", "mode", "point", "padding", "address", "ip", "type", "offset", "cmd", "host", "r", "src", "seq", "nr", "dr", "pos", "pad", "len", "ptr", "node", "xxx", "start"], "size": ["args", "en", "small", "sync", "enc", "sized", "code", "shape", "or", "g", "align", "Size", "bytes", "x", "capacity", "loc", "z", "ize", "e", "sec", "length", "n", "from", "mode", "address", "c", "timeout", "SIZE", "type", "offset", "sn", "scale", "empty", "fee", "len"], "s": ["secondary", "south", "ses", "m", "slice", "d", "service", "t", "sync", "fs", "sym", "a", "g", "S", "settings", "os", "status", "si", "es", "scope", "sq", "session", "server", "ss", "o", "request", "an", "u", "p", "e", "instance", "socket", "http", "sf", "sb", "b", "n", "f", "stat", "address", "spec", "c", "ns", "is", "ssl", "side", "sl", "r", "sie", "us", "aws"]}}
{"project": "qemu", "commit_id": "ef546f1275f6563e8934dd5e338d29d9f9909ca6", "target": 0, "func": "bool vring_should_notify(VirtIODevice *vdev, Vring *vring)\n\n{\n\n    uint16_t old, new;\n\n    bool v;\n\n    /* Flush out used index updates. This is paired\n\n     * with the barrier that the Guest executes when enabling\n\n     * interrupts. */\n\n    smp_mb();\n\n\n\n    if ((vdev->guest_features & (1 << VIRTIO_F_NOTIFY_ON_EMPTY)) &&\n\n        unlikely(!vring_more_avail(vdev, vring))) {\n\n        return true;\n\n    }\n\n\n\n    if (!(vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX))) {\n\n        return !(vring_get_avail_flags(vdev, vring) &\n\n                 VRING_AVAIL_F_NO_INTERRUPT);\n\n    }\n\n    old = vring->signalled_used;\n\n    v = vring->signalled_used_valid;\n\n    new = vring->signalled_used = vring->last_used_idx;\n\n    vring->signalled_used_valid = true;\n\n\n\n    if (unlikely(!v)) {\n\n        return true;\n\n    }\n\n\n\n    return vring_need_event(vring_used_event(&vring->vr), new, old);\n\n}\n", "idx": 13156, "substitutes": {"vdev": ["verdev", " vdiv", "vmid", "lmid", "vconn", "svconn", "svgen", "vcding", "svring", "ivdevice", "verring", "vcprof", "vding", "fgen", "fdev", "verdi", "vcdev", "vdiv", "nvgen", "vcapi", "vcring", " vgen", "vdi", "vapi", "evdev", "evring", "svmid", "fdiv", "lconn", "svdb", "evgen", "svding", "svdevice", "fdevice", " vding", "svprof", "nvdiv", " vdb", "nvdev", "ldev", "ivdev", "vgen", "vdevice", "vdb", "vprof", " vprof", " vapi", "svapi", " vdevice", "nvdevice", "vcdb", " vdi", "vergen", "ldevice", "ivconn", "ivmid", "vcgen", "svdev", "evdi"], "vring": ["pending", "vsding", "nvlic", "rstring", "svdi", "svring", "evding", " vending", "voltcalling", " vgen", " vstring", "svridge", " vdata", "vsing", " vding", "rdata", "bray", "vrig", "vlic", "voltding", "vvray", "lvray", "svdev", "ivring", "rgen", "svbinding", "ivcalling", "svsing", "varray", "svgen", "pding", "vsetting", "svdata", "svending", "bring", "vsridge", " vng", "svding", "voltring", "ivding", "varsing", "lvbinding", " vray", "lvsing", " vsetting", "vstring", " vdi", "vvtesting", "varbinding", "vsring", "varding", "varring", "avding", "rring", "rtesting", "vding", "ivray", " vrig", "vdi", "brig", "evping", "vtesting", "vcalling", "vsdev", "nvring", " vlic", "pring", "avng", " vridge", "svray", "evsetting", "blic", "vng", "vping", "svng", " vtesting", "avdi", "rray", "lvring", "avring", "vending", "evring", "svping", "nvrig", "vvring", " vping", "vbinding", "vgen", "varcalling", "vray", "svsetting", "voltray", "vdata", "vridge", "vvstring", "pray", "nvray"], "old": ["normal", "before", "after", "d", "id", "val", "l", "orig", "i", "or", "current", "pre", "range", "low", "event", "null", "OLD", "original", "other", "x", "update", "live", "ld", "valid", " Old", "o", "und", "ind", "p", "j", "from", "f", "diff", "end", "now", "lv", "md", "last", "Old", "num", "older", "prev"], "new": ["normal", "small", "self", "d", "with", "l", "again", "ew", "or", "current", "name", "g", "low", "final", "missing", "other", "raw", "update", "valid", "New", "value", "var", "o", "w", "view", "NEW", "version", "good", "where", "j", "n", "f", "result", "from", "add", "inc", "diff", "next", "c", "end", "now", "gen", "r", "el", "false"], "v": ["m", "rev", "d", "t", "vv", "l", "i", "val", "vp", "iv", "g", "conv", "ve", "h", "event", "x", "valid", "var", "o", "w", "u", "p", "e", "s", "k", "vs", "b", "j", "n", "f", "c", "function", "change", "sv", "nv", "uv", "r", "V", "ev", "lv"]}}
{"project": "FFmpeg", "commit_id": "2df0c32ea12ddfa72ba88309812bfb13b674130f", "target": 0, "func": "static int amr_nb_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                               const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n    int written, ret;\n\n    int16_t *flush_buf = NULL;\n\n    const int16_t *samples = frame ? (const int16_t *)frame->data[0] : NULL;\n\n\n\n    if (s->enc_bitrate != avctx->bit_rate) {\n\n        s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n        s->enc_bitrate = avctx->bit_rate;\n\n    }\n\n\n\n    if ((ret = ff_alloc_packet(avpkt, 32))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error getting output packet\\n\");\n\n        return ret;\n\n    }\n\n\n\n    if (frame) {\n\n        if (frame->nb_samples < avctx->frame_size) {\n\n            flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n            if (!flush_buf)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(flush_buf, samples, frame->nb_samples * sizeof(*flush_buf));\n\n            samples = flush_buf;\n\n            if (frame->nb_samples < avctx->frame_size - avctx->delay)\n\n                s->enc_last_frame = -1;\n\n        }\n\n        if ((ret = ff_af_queue_add(&s->afq, frame)) < 0) {\n\n            av_freep(&flush_buf);\n\n            return ret;\n\n        }\n\n    } else {\n\n        if (s->enc_last_frame < 0)\n\n            return 0;\n\n        flush_buf = av_mallocz(avctx->frame_size * sizeof(*flush_buf));\n\n        if (!flush_buf)\n\n            return AVERROR(ENOMEM);\n\n        samples = flush_buf;\n\n        s->enc_last_frame = -1;\n\n    }\n\n\n\n    written = Encoder_Interface_Encode(s->enc_state, s->enc_mode, samples,\n\n                                       avpkt->data, 0);\n\n    av_dlog(avctx, \"amr_nb_encode_frame encoded %u bytes, bitrate %u, first byte was %#02x\\n\",\n\n            written, s->enc_mode, frame[0]);\n\n\n\n    /* Get the next frame pts/duration */\n\n    ff_af_queue_remove(&s->afq, avctx->frame_size, &avpkt->pts,\n\n                       &avpkt->duration);\n\n\n\n    avpkt->size = written;\n\n    *got_packet_ptr = 1;\n\n    av_freep(&flush_buf);\n\n    return 0;\n\n}\n", "idx": 13163, "substitutes": {"avctx": ["avalloc", "ajloc", "abconn", "avlc", "aploc", "raftpkg", "aflc", "akcmp", "afxc", "avalcca", "evconn", "vercf", "avcu", "avallc", " avcontext", "avecmp", "ajcca", "avxc", "evcmp", "afcmd", "avecontext", "avctl", "abctx", "afconn", "abcontext", " avcca", "ajcontext", "abcmp", "apcontext", "afcit", "afcf", "avectx", "avcli", "ajkw", "afcu", "afcontext", "akctrl", "raftcli", "awpkg", "ajcit", "aplc", " avloc", "evcontext", "akctx", "avconn", "avloc", "avectrl", "ajcmp", "avctrl", "verxc", "akcontext", "evctx", "avkw", "avepkg", " avpkg", "avcf", "afkw", "avecu", "ajxc", "apconn", "vercontext", " avxc", "akcf", "ajctx", "apcu", "afloc", "verctx", "avecf", "abcmd", "afctx", "afctl", "raftcontext", "avalcf", "akxc", "ajcf", "afcli", "avalconn", "appkg", " avcit", "raftctx", "avcca", "afcca", "afpkg", "avalctl", " avcmd", "awctx", " avcf", "avcmp", "avekw", "apctl", "avcit", "avalpkg", "afcmp", "apctx", "avalcontext", "avcmd", "avalctx", "ajcmd", "avcontext", "awcli", "avalcmd", "avpkg", "afctrl", "awcontext"], "avpkt": ["avipnt", " avpqt", "avfck", "avjpkg", "avspkt", "avfkt", "avjpki", "avjpwk", "avtpwk", "avjpqt", " avipqt", "appkg", "avfacket", "apjpwk", " avpkg", " avipnt", "avpqt", "avjpnt", "avjpacket", "avjpck", "avtpkt", "avspkg", " avipkt", "avpacket", "avipqt", "avpki", "avtpacket", "avpck", "appwk", " avpacket", " avspacket", "avfnt", " avspkg", " avpck", "appkt", "appacket", "avfkg", "avfki", "avspki", " avspki", " avpki", "avpwk", "avfwk", "avtpkg", "apjpkg", "avipck", " avipck", "avspacket", " avspkt", "avjpkt", "avipkt", "avpkg", "apjpacket", " avpnt", "avfqt", "avpnt", "apjpkt"], "frame": [" Frame", "fl", "sample", "za", "flat", "image", "event", "module", "ace", "vol", "model", "rame", "raise", "flow", "frames", "line", "c", "cb", "fee", "cycle", "window", "dom", "message", "pse", "call", "m", "slice", "series", "fps", "progress", "sequence", "session", "fr", "fake", "fi", "data", "byte", "length", "feed", "function", "el", "header", "thread", "zip", "format", "Frame", "slot", "fram", "config", "iframe", "fb", "cpu", "game", "buffer", "scope", "element", "document", "view", "e", "j", "f", "none", "point", "feature", "state", "fe", "block", "ne", "cf", "que", "video", "node", "ze", "tick", "channel", "board", "code", "up", "object", "orig", "range", "position", "request", "set", "dy", "time", "component", "setup", "next", "file", "target", "process", "forward", "seq"], "got_packet_ptr": ["got_packacket2desc", "got_packacket2ptr", "got_packet2desc", "got_packet2pointer", "got_packet2ptr", "got_packacket_pointer", "got_packet6ptr", "got_packacket2pointer", "got_packet6pointer", "got_packet6desc", "got_packacket2data", "got_packacket_data", "got_packacket_ptr", "got_packet2data", "got_packet_pointer", "got_packet_data", "got_packet_desc", "got_packet6data", "got_packacket_desc"], "s": ["args", "sys", "ses", "m", "parts", "d", "service", "sync", "sg", "t", "fs", "i", "l", "sym", "rs", "a", "ins", "g", "cs", "qs", "S", "sp", "h", "os", "sets", "js", "si", "es", "sq", "scope", "session", "uns", "v", "conf", "ss", "storage", "ps", "o", "set", "ms", "p", "e", "se", "site", "data", "b", "sb", "j", "f", "gs", "spec", "state", "c", "ns", "xs", "is", "stats", "sc", "ssl", "side", "sl", "states", "ops", "ds", "services", "r", "ls", "ts", "us", "vs", "ks", "aws"], "written": ["wrote", "en", "called", "done", "edited", " rewritten", "fd", "printed", "ritten", "weight", "bytes", "unit", "generated", "checked", "writer", "writing", "locked", "created", "output", "ed", "w", "finished", "rawn", "updated", "writers", "mem", "temp", "wait", "data", "byte", "used", "read", "protected", "loaded", "reset", "writ", "wa", "started", "write", "sent", "Written", "ended", "seq", "changed", "run", "len", "won", "WR"], "ret": ["alt", "en", "ft", "rev", "format", "let", "reply", "art", "sat", "val", "code", "back", "bad", "def", "rets", "fun", "status", "ref", "pret", "det", "arg", "lit", "valid", "job", "value", "failed", "obj", "active", "mem", "temp", "fin", "success", "match", "Ret", "used", "result", "att", "reset", "arr", "cat", "nt", "re", "hard", "rt", "r", "resp", "repl", "rot", "real", "RET", "res", "reg", "flag", "run", "len", "red", "err"], "flush_buf": ["flush_vec", "flushPuf", "cleaninguf", "flush2callback", "flushPseq", "flusherpos", "update_pos", "flushingfunc", "fl_uf", "reset_fun", "push_vec", "flushacbuf", "flush_abs", "push_uf", "flushacbox", "flush_uf", "update_uf", "flusherqueue", "push_block", "reset64pool", "clean_br", "copy_brace", "push_buf", "flush_pos", "clean_buffer", "reset_pool", "flush_pool", "flush_fun", "flush64fun", "cleaningbuffer", "clean_cas", "flush_func", "flusheruf", "filter_buf", "filter_ff", "ushingbox", "flushetabs", "push_home", "flushacfunc", "flush_queue", "flush_buffer", "flush67buffer", "flush67bag", "push_wb", "update_queue", "flush_brace", "reset64cur", "reset64fun", "flush2bag", "flush67buf", "ush_loc", "flushingbrace", "flush_block", "fl_seq", "ush_buf", "flush67brace", "flush2buf", "flushinguf", "flush_cur", "flushetexc", "ushingloc", "flushetbuf", "filter_abs", "flush2loc", "push_box", "flushPbuf", "flushingbuffer", "flush_home", "flush_cas", "cleaningbrace", "flush64buf", "filteretbuf", "update_buf", "push_bag", "flush_cap", "flush_box", "flush67home", "flush67vec", "flush_ff", "flush2brace", "flush2vec", "flush_loc", "fl_box", "flushingbuf", "flush_bag", "flush64pool", "fl_buf", "flush_buff", "reset_cur", "filteretabs", "flush67loc", "ush_func", "ush_box", "push_cap", "copy_vec", "flush67cas", "flush67br", "flush2uf", "flushPbox", "flush64cur", "push_buff", "flush67uf", "flushingbox", "push_buffer", "copy_buf", "filter_exc", "filteretff", "clean_uf", "flusherbuf", "push_loc", "clean_brace", "flush67callback", "ushingfunc", "flush_seq", "clean_buf", "flush_callback", "flush67wb", "flush_wb", "filteretexc", "copy_callback", "ushingbuf", "flushetff", "flushingloc", "reset64buf", "flush_exc", "flush_br", "cleaningbuf", "reset_buf", "flushacloc"], "samples": ["Sockets", " sessions", "dplays", "Sipes", " smodels", " samps", "sample", "Splays", "Sessions", "Smodels", "Samples", "Samps", " sockets", "namps", "sockets", " sample", "smodels", "nmodels", "samps", "sesamples", "splays", "Sample", "namples", "sessions", "sesessions", "damples", "nipes", "sesample", " splays", " sipes", "dample", "sesamps", "sipes"]}}
{"project": "qemu", "commit_id": "97f90cbfe810bb153fc44bde732d9639610783bb", "target": 0, "func": "void do_unassigned_access(target_phys_addr_t addr, int is_write, int is_exec,\n\n                          int is_asi, int size)\n\n{\n\n    CPUState *saved_env;\n\n    /* XXX: hack to restore env in all cases, even if not called from\n\n       generated code */\n\n    saved_env = env;\n\n    env = cpu_single_env;\n\n    qemu_log(\"Unassigned \" TARGET_FMT_plx \" wr=%d exe=%d\\n\",\n\n             addr, is_write, is_exec);\n\n    if (!(env->sregs[SR_MSR] & MSR_EE)) {\n\n        return;\n\n    }\n\n\n\n    if (is_exec) {\n\n        if (!(env->pvr.regs[2] & PVR2_IOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_INSN_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    } else {\n\n        if (!(env->pvr.regs[2] & PVR2_DOPB_BUS_EXC_MASK)) {\n\n            env->sregs[SR_ESR] = ESR_EC_DATA_BUS;\n\n            helper_raise_exception(EXCP_HW_EXCP);\n\n        }\n\n    }\n\n}\n", "idx": 13172, "substitutes": {"addr": ["ord", "args", "device", "port", "Address", "asm", "slot", "amp", "rd", "rc", "amd", "pc", "name", "ace", " address", "br", "mx", "ad", "adr", "mt", "resource", "kt", "pointer", "data", "mode", "arp", "address", "ip", "type", "offset", "target", "md", "attr", "network", "rt", "host", "cp", "mac", "nr", "dr", "alias", "wd", "ptr", "filename", "node"], "is_write": ["isgwrite", "name_write", "isgread", "namegwrite", "isgexecute", " is_writer", "is_read", "isPuball", "namegexecute", " is_read", "is1read", "name_read", "isPubwrite", "is1writer", "is1all", "is_all", "is_execute", "is_writer", "name_execute", "namegread", "namegexec", "name_exec", "is1write", "isPubread", " is_all", "isgexec", "isPubwriter"], "is_exec": ["IS__exec", " is_ec", "IS_eval", "is_ec", "is__write", "IS__eval", "isPec", "is__exec", "isPclose", "is_close", " is_sync", " is_sec", "IS_write", "is_sync", "is_read", "isPwrite", "isPexec", "IS__read", "is_sec", "IS_read", "IS_exec", "is_eval", "IS__write", "is__read", " is_close", "is__eval"], "is_asi": [" is_open", " is_data", " is_sync", "is_sync", "is_fail", " is_fail", "is_open", "is_data"], "size": ["args", "enc", "extra", "name", "align", "Size", "capacity", "unit", "loc", "form", "ize", "sec", "count", "mode", "address", "timeout", "SIZE", "offset", "security", "scale", "empty", "len"], "saved_env": ["saved__dat", "save__environment", "save_environment", "saved__environment", "save__env", "saved___environment", "save_exc", "saved_environment", "saved__env", "save_dat", "save__dat", "saved___dat", "save_env", "saved_dat", "saved___env", "saved_exc", "saved_v", "save_v"]}}
{"project": "FFmpeg", "commit_id": "9340a99588c2bf6209b5c396df15b893c4b576b5", "target": 1, "func": "static int RENAME(swScale)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int chrSrcW= c->chrSrcW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int srcFormat= c->srcFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint32_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint32_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\tconst int chrSrcSliceY= srcSliceY >> c->chrSrcVSubSample;\n\n\tconst int chrSrcSliceH= -((-srcSliceH) >> c->chrSrcVSubSample);\n\n\tint lastDstY;\n\n        uint8_t *pal=NULL;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\t\n\n\tif(isPacked(c->srcFormat)){\n\n                pal= src[1];\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= src[0];\n\n\t\tsrcStride[0]=\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStride[0];\n\n\t}\n\n\tsrcStride[1]<<= c->vChrDrop;\n\n\tsrcStride[2]<<= c->vChrDrop;\n\n\n\n//\tprintf(\"swscale %X %X %X -> %X %X %X\\n\", (int)src[0], (int)src[1], (int)src[2],\n\n//\t\t(int)dst[0], (int)dst[1], (int)dst[2]);\n\n\n\n#if 0 //self test FIXME move to a vfilter or something\n\n{\n\nstatic volatile int i=0;\n\ni++;\n\nif(srcFormat==PIX_FMT_YUV420P && i==1 && srcSliceH>= c->srcH)\n\n\tselfTest(src, srcStride, c->srcW, c->srcH);\n\ni--;\n\n}\n\n#endif\n\n\n\n//printf(\"sws Strides:%d %d %d -> %d %d %d\\n\", srcStride[0],srcStride[1],srcStride[2],\n\n//dstStride[0],dstStride[1],dstStride[2]);\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tav_log(c, AV_LOG_WARNING, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tlastDstY= dstY;\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tconst int chrDstY= dstY>>c->chrDstVSubSample;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*chrDstY;\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*chrDstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n//printf(\"dstY:%d dstH:%d firstLumSrcY:%d lastInLumBuf:%d vLumBufSize: %d vChrBufSize: %d slice: %d %d vLumFilterSize: %d firstChrSrcY: %d vChrFilterSize: %d c->chrSrcVSubSample: %d\\n\",\n\n// dstY, dstH, firstLumSrcY, lastInLumBuf, vLumBufSize, vChrBufSize, srcSliceY, srcSliceH, vLumFilterSize, firstChrSrcY, vChrFilterSize,  c->chrSrcVSubSample);\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < -((-srcSliceY - srcSliceH)>>c->chrSrcVSubSample))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < (chrSrcSliceH))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);*/\n\n\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->lumMmx2Filter, c->lumMmx2FilterPos, pal);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < (chrSrcSliceY + chrSrcSliceH))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - chrSrcSliceY)*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY < chrSrcSliceH)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - chrSrcSliceY >= 0)\n\n\n\n\t\t\t\tif(!(isGray(srcFormat) || isGray(dstFormat)))\n\n\t\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, chrSrcW, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer, \n\n\t\t\t\t\t\tc->chrMmx2Filter, c->chrMmx2FilterPos, pal);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we can't output a dstY line so let's try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n#ifdef HAVE_MMX\n\n\t\tint i;\n\n            if(flags & SWS_ACCURATE_RND){\n\n                        for(i=0; i<vLumFilterSize; i+=2){\n\n                                lumMmxFilter[2*i+0]= (int32_t)lumSrcPtr[i  ];\n\n                                lumMmxFilter[2*i+1]= (int32_t)lumSrcPtr[i+(vLumFilterSize>1)];\n\n                                lumMmxFilter[2*i+2]=\n\n                                lumMmxFilter[2*i+3]= vLumFilter[dstY*vLumFilterSize + i    ]\n\n                                                + (vLumFilterSize>1 ? vLumFilter[dstY*vLumFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n                        for(i=0; i<vChrFilterSize; i+=2){\n\n                                chrMmxFilter[2*i+0]= (int32_t)chrSrcPtr[i  ];\n\n                                chrMmxFilter[2*i+1]= (int32_t)chrSrcPtr[i+(vChrFilterSize>1)];\n\n                                chrMmxFilter[2*i+2]=\n\n                                chrMmxFilter[2*i+3]= vChrFilter[chrDstY*vChrFilterSize + i    ]\n\n                                                + (vChrFilterSize>1 ? vChrFilter[chrDstY*vChrFilterSize + i + 1]<<16 : 0);\n\n                        }\n\n            }else{\n\n\t\tfor(i=0; i<vLumFilterSize; i++)\n\n\t\t{\n\n\t\t\tlumMmxFilter[4*i+0]= (int32_t)lumSrcPtr[i];\n\n\t\t\tlumMmxFilter[4*i+1]= (uint64_t)lumSrcPtr[i] >> 32;\n\n\t\t\tlumMmxFilter[4*i+2]= \n\n\t\t\tlumMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vLumFilter[dstY*vLumFilterSize + i])*0x10001;\n\n\t\t}\n\n\t\tfor(i=0; i<vChrFilterSize; i++)\n\n\t\t{\n\n\t\t\tchrMmxFilter[4*i+0]= (int32_t)chrSrcPtr[i];\n\n\n\t\t\tchrMmxFilter[4*i+2]= \n\n\t\t\tchrMmxFilter[4*i+3]= \n\n\t\t\t\t((uint16_t)vChrFilter[chrDstY*vChrFilterSize + i])*0x10001;\n\n\t\t}\n\n            }\n\n#endif\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tRENAME(yuv2nv12X)(c,\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2yuvX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\t\t\t\tRENAME(yuv2packed1)(c, *lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags, dstY);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n                                lumMmxFilter[2]=\n\n                                lumMmxFilter[3]= vLumFilter[2*dstY   ]*0x10001;\n\n                                chrMmxFilter[2]=\n\n                                chrMmxFilter[3]= vChrFilter[2*chrDstY]*0x10001;\n\n\t\t\t\tRENAME(yuv2packed2)(c, *lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstY);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2packedX)(c,\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstY);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we can't use MMX here without overwriting this array's tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21){\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif(dstY&chrSkipMask) uDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2nv12XinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, dstW, chrDstW, dstFormat);\n\n\t\t}\n\n\t\telse if(isPlanarYUV(dstFormat) || isGray(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tconst int chrSkipMask= (1<<c->chrDstVSubSample)-1;\n\n\t\t\tif((dstY&chrSkipMask) || isGray(dstFormat)) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize   , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+chrDstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW, chrDstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2packedXinC(c, \n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstY);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n\n\n\treturn dstY - lastDstY;\n\n}", "idx": 13204, "substitutes": {"c": ["m", "ch", "mc", "uc", "bc", "cm", "d", "t", "enc", "ca", "rc", "cc", "l", "config", "pc", "C", "lc", "ci", "cs", "g", "cit", "cn", "con", "ct", "conf", "cr", "client", "col", "u", "rec", "p", "e", "nc", "b", "co", "tc", "n", "f", "spec", "cu", "dc", "ac", "cb", "sc", "ce", "cont", "cf", "ic", "coll", "cp", "com", "vc", "xc", "cache", "ec", "cur", "y", "ctx", "in", "cl"], "src": ["sys", "cv", "sync", "rc", "source", "req", "conv", "sr", "sq", "loc", "rec", "rb", "share", "sb", "inst", "scl", "sc", "ssl", "transform", "sl", "sur", "host", "sub", "sel", "scene", "cur", "ctx"], "srcStride": ["srcSTerve", "rcStrip", "srcEstride", "rcShause", "srcStrip", "srcEstrip", "srcSTause", "rcShrip", "srcEstause", "rcSherve", "srcSTride", "srcSherve", "rcStride", "srcShride", "rcStause", "srcShrip", "srcSterve", "srcSTrip", "srcStause", "srcEsterve", "rcSterve", "rcShride", "srcShause"], "srcSliceY": ["srcPlueY", "srcSlueW", "srcPlueI", "srcSlashY", "srcSliceI", "srcSlashD", "srcPliceY", "srcSlueD", "srcSlideW", "srcSlideI", "srcSliceW", "srcPlueD", "srcSliceD", "srcSlideY", "srcSlashI", "srcSlueY", "srcPliceD", "srcPlueW", "srcPliceW", "srcPliceI", "srcSlideD", "srcSlueI", "srcSlashW"], "srcSliceH": ["srcFlashH", "srcSlashY", "srcFliceH", "srcSlashH", "srcSlaseRH", "srcSlaceW", "srcSlaseH", "srcSlaceH", "srcSliceW", "srcSlaceRH", "srcSlashRH", "srcSliceRH", "srcFlashW", "srcFliceW", "srcSlaseY", "srcFlashY", "srcSlaceY", "srcFlashRH", "srcFliceY", "srcSlaseW", "srcFliceRH", "srcSlashW"], "dst": [" dsrc", "idsc", " drc", "Dsc", "idrc", " dsc", "Dst", "dsc", "idsrc", "drc", "dsrc", "Drc", "idst", "Dsrc"], "dstStride": ["dstStide", "dstStrite", "dstScrite", "dscStride", "dscStause", "dstShause", "dstScride", "dstShride", "dstShide", "dstDestride", "dstShrite", "dscStide", "dscDestride", "dstDestause", "dstDestide", "dscDestause", "dstScause", "dscDestide", "dscStrite", "dstDestrite", "dstScide", "dstStause", "dscDestrite"], "vLumFilterPos": ["vLumFeatureLen", "vLumbFilePos", "vLumbFilterEx", "vLumLayerRef", "vLumLayerOff", "vLumMaskEx", "vLumHeaderEx", "vLumFilterLen", "vLumFeaturePosition", "vLumFilterOff", "vLumFeaturePos", "vLumListenerPosition", "vLumeFilterOff", "vLumFilterEx", "vLumeFilterEx", "vLumeFilterPos", "vLumbFilterLen", "vLumFilePos", "vLumbFileEx", "vLumFilterPosition", "vLumeHeaderEx", "vLumeHeaderOff", "vLumbFilePosition", "vLumeHeaderPos", "vLumbFilterPosition", "vLumMaskOff", "vLumMaskRef", "vLumHeaderOff", "vLumbFileLen", "vLumHeaderRef", "vLumListenerEx", "vLumeHeaderRef", "vLumLayerEx", "vLumeFilterRef", "vLumLayerPos", "vLumbFilterPos", "vLumMaskPos", "vLumFilePosition", "vLumFeatureEx", "vLumFilterRef", "vLumListenerLen", "vLumListenerPos", "vLumHeaderPos", "vLumFileEx", "vLumFileLen"], "vChrFilterPos": ["vChrFilPosition", "vChmFilterPosition", "vChrFilPos", "vChrLimitpos", "vChrFlowOffset", "vChrtFilterPosition", "vChmFilterOffset", "vChrLimitOffset", "vChmFPos", "vChrtFilterPref", "vChrFlowPosition", "vChrFilpos", "vChrFilterPref", "vChmFpos", "vChrtFeaturepos", "vChrtFilterPos", "vChrFlowPos", "vChrtFeaturePos", "vChrFOffset", "vChrFeaturePos", "vChrLimitPos", "vChmFilterPos", "vChrtFeaturePref", "vChrFilterPosition", "vChrtFilterpos", "vChrLimitPosition", "vChmFilterpos", "vChrFPosition", "vChrFeaturePref", "vChrtFeaturePosition", "vChrFPos", "vChrFilPref", "vChrFeaturepos", "vChrFilterpos", "vChrFeaturePosition", "vChrFlowpos", "vChmFPosition", "vChrFPref", "vChmFOffset", "vChrFilterOffset", "vChrFpos"], "hLumFilterPos": ["hLumFilepos", "hLmFilepos", "hLumFilePos", "hLumManagerPosition", "hLumLimitMin", "hLmFilePosition", "hLumReaderPos", "hLumContentPos", "hLumLimitSe", "hLumFilterpos", "hLumFilePosition", "hLmFileSe", "hLumLimitPosition", "hLumContentP", "hLmFileMin", "hLumManagerMin", "hLmFilterMin", "hLumManagerPos", "hLumFilterMin", "hLumContentpos", "hLumFileMin", "hLumReaderpos", "hLmFilterpos", "hLumLimitPos", "hLumFileP", "hLumFileSe", "hLumFilterSe", "hLumFilterP", "hLumReaderPosition", "hLumManagerSe", "hLumFilterPosition", "hLmFilterSe", "hLmFilePos", "hLmFilterPos", "hLumContentPosition", "hLmFilterPosition", "hLmFilterP", "hLumReaderP", "hLmFileP"], "hChrFilterPos": ["hChrFlowPos", "hChlFilterPo", "hChrMaskScan", "hChrMaskPos", "hChlMaskLoc", "hChrFilterScan", "hChrFlowpos", "hChrtFilterpos", "hChrMaskPo", "hChrFilterpos", "hChrFilterEx", "hChrtHandlerpos", "hChrHandlerEx", "hChrMaskLoc", "hChrtHandlerStart", "hChrFilterPo", "hChrFactorPos", "hChrSelectScan", "hChrFactorScan", "hChrtHandlerEx", "hChrtFilterEx", "hChrHandlerStart", "hChrFilterLoc", "hChrtFilterPos", "hChrFlowStart", "hChrControlPos", "hChrControlEx", "hChrControlStart", "hChlMaskPo", "hChrHandlerPos", "hChlMaskPos", "hChrFilterStart", "hChrFlowEx", "hChlFilterScan", "hChrtHandlerPos", "hChlFilterLoc", "hChrSelectPos", "hChrControlpos", "hChrSelectLoc", "hChlFilterPos", "hChrFactorLoc", "hChrFactorPo", "hChrHandlerpos", "hChlMaskScan", "hChrtFilterStart", "hChrSelectPo"], "vLumFilter": ["vLumbLimit", "vPlumbLimit", "vBlumFil", "vLumerLimit", "vLumbLayer", "vLumFil", "vPlumLayer", "vLumerName", "vBlumbFil", "vLUMHandler", "vPlumbName", "vLumName", "vBlumbFilter", "vLamLimit", "vLawLimit", "vBlumHandler", "vPlumbLayer", "vLumbName", "vLumbFil", "vLumHandler", "vLumLayer", "vLUMFil", "vPlumLimit", "vLamFilter", "vLawFilter", "vBlumFilter", "vBlumLimit", "vBlumbLimit", "vLumLimit", "vLamName", "vPlumName", "vLumerFilter", "vLawHandler", "vLUMFilter", "vLamLayer", "vLumbHandler", "vBlumbHandler", "vLumerLayer", "vLumbFilter", "vPlumbFilter", "vLUMLimit", "vPlumFilter", "vLawFil"], "vChrFilter": ["vChtSort", "vChnrFilter", "vChrFill", "vChtFilter", "vChrcFill", "vChrtMask", "vPhrMask", "vChrRule", "vChtMask", "vChnrFill", "vChnrResult", "vChrbResult", "vChrtRule", "vChnrSort", "vChrbFill", "vSchrbSort", "vPhrRule", "vChrcSort", "vChrcMask", "vChrtSort", "vPhrcRule", "vSchrbFilter", "vSchrFill", "vPhrcMask", "vChrSort", "vChrbFilter", "vSchrbResult", "vSchrFilter", "vSchrbFill", "vChtRule", "vSchrResult", "vChrResult", "vChrcResult", "vPhrSort", "vPhrFilter", "vPhrcFilter", "vChrcFilter", "vChrMask", "vChrtFilter", "vChrbSort", "vChrcRule", "vPhrcSort", "vSchrSort"], "hLumFilter": ["hLUMFl", "hLumaSelect", "hMumSort", "hClumiFl", "hMumaUrl", "hLmFilter", "hLmSort", "hClumFilter", "hMumaFilter", "hLumifilter", "hLmSelect", "hLrumUrl", "hLumSelect", "hClumifilter", "hMumSelect", "hLrumSort", "hLemFl", "hLumaFilter", "hMumaSort", "hLumSort", "hLrumSelect", "hMumaSelect", "hLemfilter", "hMumFilter", "hLumFl", "hLumaUrl", "hClumiFilter", "hLumaSort", "hMumUrl", "hLUMFilter", "hLumiFilter", "hLumfilter", "hLumUrl", "hLumiFl", "hLemFilter", "hClumFl", "hClumfilter", "hLUMfilter", "hLrumFilter", "hLmUrl"], "hChrFilter": ["hHrbControl", "hChruRequest", "hHrbRequest", "hchrcUser", "hChdUser", "hChdFilter", "hChrHandler", "hChsrControl", "hChruFilter", "hChrbRequest", "hChrRequest", "hchrFactor", "hChrbControl", "hChrUser", "hHrRequest", "hHrbFilter", "hChrbUser", "hChdFactor", "hchrFilter", "hChdSort", "hchrUser", "hChrbSort", "hchrcFactor", "hChsrRequest", "hchrcFilter", "hChrcFilter", "hChrcFactor", "hChrbHandler", "hHrbHandler", "hChruControl", "hHrHandler", "hChrbFactor", "hchrSort", "hChrcSort", "hChsrFilter", "hchrcSort", "hChrFactor", "hHrFilter", "hChrbFilter", "hChruHandler", "hChrcUser", "hChrSort", "hChsrHandler", "hChrControl", "hHrControl"], "lumMmxFilter": ["lumLgrLimit", "lumMmxSort", "lumPuxFile", "lumMmxHeader", "lumMuxFilter", "lumLmxSort", "lumMgrLimit", "lumMxLimit", "lumMmxF", "lumLmxF", "lumPmxFilter", "lumMxFilter", "lumMxSort", "lumMuxHeader", "lumMappingLimit", "lumMgrSort", "lumMexHeader", "lumPuxHeader", "lumMappingFilter", "lumMappingSort", "lumMexFilter", "lumMuxFile", "lumMappingF", "lumMexFile", "lumMaxHeader", "lumLmxLimit", "lumMaxFile", "lumLgrFilter", "lumLgrF", "lumPuxFilter", "lumLmxFilter", "lumMxF", "lumMaxFilter", "lumMmxFile", "lumPmxFile", "lumMgrF", "lumMgrFilter", "lumPmxHeader", "lumLgrSort", "lumMmxLimit"], "chrMmxFilter": ["chrLmxProfile", "chrMoverFilter", "chrMaxFilter", "chrMoverConfig", "chrMoverLayer", "chrMmxConfig", "chrMixFilter", "chrMexLayer", "chrMexProfile", "chrMappingConfig", "chrMixProfile", "chrLexF", "chrLexConfig", "chrMixConfig", "chrRmxF", "chrMmxLayer", "chrLexProfile", "chrRmxFilter", "chrMaxF", "chrMexFilter", "chrRexFilter", "chrRmxLayer", "chrRexConfig", "chrMexF", "chrRexF", "chrLmxFilter", "chrMaxConfig", "chrMaxLayer", "chrMappingProfile", "chrMmxF", "chrRexLayer", "chrMoverF", "chrLmxConfig", "chrMexConfig", "chrRmxConfig", "chrLexFilter", "chrMixF", "chrMappingFilter", "chrMappingF", "chrMmxProfile", "chrLmxF"], "lumPixBuf": ["lumPexBuff", "lumPixBuffuf", "lumPixCuf", "lumPixLlu", "lumPixBof", "lumPixCuff", "lumPexBmp", "lumPixAuf", "lumPixDof", "lumPixBuffuff", "lumPexCmp", "lumPexCuff", "lumPixLuf", "lumPngBlu", "lumPixBuff", "lumPngBum", "lumPixAum", "lumPexCuf", "lumPixDmp", "lumPixBmp", "lumPixDuf", "lumPixBuffmp", "lumPixLum", "lumPixBlu", "lumPixAuff", "lumPixAlu", "lumPexCof", "lumPixCof", "lumPngBuff", "lumPixDuff", "lumPixBum", "lumPixLuff", "lumPixCmp", "lumPngBuf", "lumPixBuffof", "lumPexBof", "lumPexBuf"], "chrPixBuf": ["chrPixAust", "chrPxBust", "chrPixLmp", "chrPxAmp", "chrPixBundle", "chrPixBmp", "chrPixMump", "chrPixelsMump", "chrPixMundle", "chrPixelsBundle", "chrPixelsBob", "chrPixelsMob", "chrPxBuf", "chrPixLuff", "chrPixAuf", "chrPixBuffob", "chrPixBomp", "chrPixMob", "chrPixMuf", "chrPixBuffuf", "chrPixLuf", "chrPxAuf", "chrPixAmp", "chrPixBuff", "chrPixBuffundle", "chrPixBuffump", "chrPixBob", "chrPxBuff", "chrPxBmp", "chrPixBump", "chrPixelsBuf", "chrPixAuff", "chrPixBouf", "chrPxAust", "chrPixBouff", "chrPixBoust", "chrPixelsMuf", "chrPixelsBump", "chrPixelsMundle", "chrPixLust", "chrPixBust", "chrPxAuff"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(bgr24ToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    RENAME(bgr24ToY_mmx)(dst, src, width, PIX_FMT_BGR24);\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        int b= src[i*3+0];\n\n        int g= src[i*3+1];\n\n        int r= src[i*3+2];\n\n\n\n        dst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)))>>RGB2YUV_SHIFT);\n\n    }\n\n#endif /* COMPILE_TEMPLATE_MMX */\n\n}\n", "idx": 13205, "substitutes": {"dst": [" dsts", "cdsrc", "bsc", "cdsts", "Dst", "Dsts", "sconst", "bsrc", "dsts", " dsrc", "dconst", " dsc", " dconst", " drc", "lconst", "lsts", "ssts", "dsrc", "sst", "lst", "cdsc", "cdst", "dsc", "Dconst", "lrc", "drc", "bsts", "bst", "Dsrc"], "src": ["rib", "proc", "sync", "fl", "dist", "rc", "config", "cv", "enc", "tmp", "supp", "iv", "ctr", "sup", "source", "conv", "sth", "sr", "sq", "dest", "secure", "loc", "storage", "gl", "lib", "impl", "img", "rb", "pack", "buf", "http", "sb", "reflect", "flash", "inst", "scl", "gb", "url", "cb", "sn", "sc", "ssl", "rob", "cont", "transform", "sl", "text", "sur", "rect", "SOURCE", "rest", "sub", "seq", "sel", "stack", "cur", "st", "support", "ctx"], "unused": ["nonferred", "Unuse", "Unchecked", "unchecked", "nonchecked", " unferred", "unuse", "nonused", " unuse", "Unferred", "unferred", "Unused", " unchecked", "nonuse"], "i": ["hi", "qi", "it", "ui", "m", "adi", "I", "d", "t", "ai", "ni", "xi", "id", "ini", "l", "gi", "iu", "oi", "io", "api", "g", "ci", "mu", "di", "x", "si", "ie", "ii", "v", "uri", "o", "u", "z", "iii", "p", "e", "s", "fi", "info", "cli", "li", "k", "b", "ix", "multi", "j", "phi", "n", "f", "ti", "at", "ip", "c", "is", "anti", "hei", "pi", "r", "bi", "ri", "ami", "zi", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "f78cd0c243b9149c7f604ecf1006d78e344aa6ca", "target": 1, "func": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n", "idx": 13230, "substitutes": {"block": ["condition", "blocks", "bin", "tx", "batch", "id", "object", "label", "name", "row", "Block", "image", "null", "x", "buffer", "unit", "error", "table", "frame", "limit", "chain", "set", "filter", "col", "group", "clean", "check", "pack", "data", "base", "box", "BL", "length", "none", "address", "ip", "number", "end", "type", "clock", "one", "lock", "off", "header", "cl", "node", "index", "start"], "i": ["hi", "qi", "it", "ui", "I", "d", "ai", "ni", "xi", "id", "l", "ini", "gi", "iu", "a", "io", "oi", "api", "mu", "ci", "my", "h", "x", "di", "si", "ii", "v", "uri", "vi", "u", "iii", "p", "e", "info", "fi", "mi", "li", "data", "b", "ix", "multi", "j", "phi", "f", "ti", "ip", "c", "eni", "pi", "r", "bi", "ri", "ami", "zi", "in", "index", "start"]}}
{"project": "qemu", "commit_id": "f53c398aa603cea135ee58fd15249aeff7b9c7ea", "target": 1, "func": "static void ohci_async_cancel_device(OHCIState *ohci, USBDevice *dev)\n\n{\n\n    if (ohci->async_td &&\n\n        ohci->usb_packet.owner != NULL &&\n\n        ohci->usb_packet.owner->dev == dev) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n}\n", "idx": 13236, "substitutes": {"ohci": ["ahcm", " ohco", "ehpi", "ahdi", "ovco", "ohcci", "ehlc", " ohcm", "ahlc", "odco", "ehdi", "ahsc", "odcci", "ehci", "ehcm", "ehc", "ohsi", "ohlc", "ihcci", " ohcu", "ohpi", "ahsi", "odcu", "ohco", " ohsi", "ohdi", "ehsi", "ihci", "ohcu", "ihcu", "ahci", "ovc", " ohsc", "ohcm", "ehsc", "ihco", "ovlc", "odci", "ohsc", " ohcci", " ohpi", "ehcci", "ehco", "ahpi", "ahc", " ohdi", "ahcci", "ovci", "ahco", "ohc"], "dev": ["device", "development", "kind", "v", "d", "dist", "private", "priv", "die", "orig", " device", "def", "rad", "home", "name", "iv", "user", "di", "Dev", "error", "app", "valid", "conf", "gu", "var", "der", "gd", "adv", "av", "group", "conn", "ad", "loader", "pub", "ver", "desc", "data", "reader", "inst", "diff", "develop", "block", "dem", " priv", "DEV", "md", "ov", "dd", "od", "ev", "prop", "wd", "hw", "brand", "ow"]}}
{"project": "FFmpeg", "commit_id": "fd0f45e58b010c0d7049914a392c3e96a2223107", "target": 1, "func": "static int av_encode(AVFormatContext **output_files,\n\n                     int nb_output_files,\n\n                     AVFormatContext **input_files,\n\n                     int nb_input_files,\n\n                     AVStreamMap *stream_maps, int nb_stream_maps)\n\n{\n\n    int ret, i, j, k, n, nb_istreams = 0, nb_ostreams = 0;\n\n    AVFormatContext *is, *os;\n\n    AVCodecContext *codec, *icodec;\n\n    AVOutputStream *ost, **ost_table = NULL;\n\n    AVInputStream *ist, **ist_table = NULL;\n\n    AVInputFile *file_table;\n\n    AVFormatContext *stream_no_data;\n\n    int key;\n\n\n\n    file_table= (AVInputFile*) av_mallocz(nb_input_files * sizeof(AVInputFile));\n\n    if (!file_table)\n\n        goto fail;\n\n\n\n    /* input stream init */\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        file_table[i].ist_index = j;\n\n        file_table[i].nb_streams = is->nb_streams;\n\n        j += is->nb_streams;\n\n    }\n\n    nb_istreams = j;\n\n\n\n    ist_table = av_mallocz(nb_istreams * sizeof(AVInputStream *));\n\n    if (!ist_table)\n\n        goto fail;\n\n    \n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = av_mallocz(sizeof(AVInputStream));\n\n        if (!ist)\n\n            goto fail;\n\n        ist_table[i] = ist;\n\n    }\n\n    j = 0;\n\n    for(i=0;i<nb_input_files;i++) {\n\n        is = input_files[i];\n\n        for(k=0;k<is->nb_streams;k++) {\n\n            ist = ist_table[j++];\n\n            ist->st = is->streams[k];\n\n            ist->file_index = i;\n\n            ist->index = k;\n\n            ist->discard = 1; /* the stream is discarded by default\n\n                                 (changed later) */\n\n\n\n            if (ist->st->codec.rate_emu) {\n\n                ist->start = av_gettime();\n\n                ist->frame = 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* output stream init */\n\n    nb_ostreams = 0;\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        nb_ostreams += os->nb_streams;\n\n    }\n\n    if (nb_stream_maps > 0 && nb_stream_maps != nb_ostreams) {\n\n        fprintf(stderr, \"Number of stream maps must match number of output streams\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check the mapping args -- do the input files & streams exist? */\n\n    for(i=0;i<nb_stream_maps;i++) {\n\n        int fi = stream_maps[i].file_index;\n\n        int si = stream_maps[i].stream_index;\n\n        \n\n        if (fi < 0 || fi > nb_input_files - 1 ||\n\n            si < 0 || si > file_table[fi].nb_streams - 1) {\n\n            fprintf(stderr,\"Could not find input stream #%d.%d\\n\", fi, si);\n\n            exit(1);\n\n        }\n\n    }\n\n    \n\n    ost_table = av_mallocz(sizeof(AVOutputStream *) * nb_ostreams);\n\n    if (!ost_table)\n\n        goto fail;\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = av_mallocz(sizeof(AVOutputStream));\n\n        if (!ost)\n\n            goto fail;\n\n        ost_table[i] = ost;\n\n    }\n\n    \n\n    n = 0;\n\n    for(k=0;k<nb_output_files;k++) {\n\n        os = output_files[k];\n\n        for(i=0;i<os->nb_streams;i++) {\n\n            int found;\n\n            ost = ost_table[n++];\n\n            ost->file_index = k;\n\n            ost->index = i;\n\n            ost->st = os->streams[i];\n\n            if (nb_stream_maps > 0) {\n\n                ost->source_index = file_table[stream_maps[n-1].file_index].ist_index + \n\n                    stream_maps[n-1].stream_index;\n\n                    \n\n                /* Sanity check that the stream types match */\n\n                if (ist_table[ost->source_index]->st->codec.codec_type != ost->st->codec.codec_type) {\n\n                    fprintf(stderr, \"Codec type mismatch for mapping #%d.%d -> #%d.%d\\n\",\n\n                        stream_maps[n-1].file_index, stream_maps[n-1].stream_index,\n\n                        ost->file_index, ost->index);\n\n                    exit(1);\n\n                }\n\n                \n\n            } else {\n\n                /* get corresponding input stream index : we select the first one with the right type */\n\n                found = 0;\n\n                for(j=0;j<nb_istreams;j++) {\n\n                    ist = ist_table[j];\n\n                    if (ist->discard && \n\n                        ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                        ost->source_index = j;\n\n                        found = 1;\n\n                    }\n\n                }\n\n                \n\n                if (!found) {\n\n                    /* try again and reuse existing stream */\n\n                    for(j=0;j<nb_istreams;j++) {\n\n                        ist = ist_table[j];\n\n                        if (ist->st->codec.codec_type == ost->st->codec.codec_type) {\n\n                            ost->source_index = j;\n\n                            found = 1;\n\n                        }\n\n                    }\n\n                    if (!found) {\n\n                        fprintf(stderr, \"Could not find input stream matching output stream #%d.%d\\n\",\n\n                                ost->file_index, ost->index);\n\n                        exit(1);\n\n                    }\n\n                }\n\n            }\n\n            ist = ist_table[ost->source_index];\n\n            ist->discard = 0;\n\n        }\n\n    }\n\n\n\n    /* for each output stream, we compute the right encoding parameters */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        ist = ist_table[ost->source_index];\n\n\n\n        codec = &ost->st->codec;\n\n        icodec = &ist->st->codec;\n\n\n\n        if (ost->st->stream_copy) {\n\n            /* if stream_copy is selected, no need to decode or encode */\n\n            codec->codec_id = icodec->codec_id;\n\n            codec->codec_type = icodec->codec_type;\n\n            codec->codec_tag = icodec->codec_tag;\n\n            codec->bit_rate = icodec->bit_rate;\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                codec->sample_rate = icodec->sample_rate;\n\n                codec->channels = icodec->channels;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                codec->frame_rate = icodec->frame_rate;\n\n                codec->frame_rate_base = icodec->frame_rate_base;\n\n                codec->width = icodec->width;\n\n                codec->height = icodec->height;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n        } else {\n\n            switch(codec->codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                if (fifo_init(&ost->fifo, 2 * MAX_AUDIO_PACKET_SIZE))\n\n                    goto fail;\n\n                \n\n                if (codec->channels == icodec->channels &&\n\n                    codec->sample_rate == icodec->sample_rate) {\n\n                    ost->audio_resample = 0;\n\n                } else {\n\n                    if (codec->channels != icodec->channels &&\n\n                        icodec->codec_id == CODEC_ID_AC3) {\n\n                        /* Special case for 5:1 AC3 input */\n\n                        /* and mono or stereo output      */\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                        if (codec->sample_rate == icodec->sample_rate)\n\n                            ost->audio_resample = 0;\n\n                        else {\n\n                            ost->audio_resample = 1;\n\n                            ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\t    if(!ost->resample)\n\n\t\t\t      {\n\n\t\t\t\tprintf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t\tav_abort();\n\n\t\t\t      }\n\n                        }\n\n                        /* Request specific number of channels */\n\n                        icodec->channels = codec->channels;\n\n                    } else {\n\n                        ost->audio_resample = 1; \n\n                        ost->resample = audio_resample_init(codec->channels, icodec->channels,\n\n                                                        codec->sample_rate, \n\n                                                        icodec->sample_rate);\n\n\t\t\tif(!ost->resample)\n\n\t\t\t  {\n\n\t\t\t    printf(\"Can't resample.  Aborting.\\n\");\n\n\t\t\t    av_abort();\n\n\t\t\t  }\n\n                    }\n\n                }\n\n                ist->decoding_needed = 1;\n\n                ost->encoding_needed = 1;\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                if (codec->width == icodec->width &&\n\n                    codec->height == icodec->height &&\n\n                    frame_topBand == 0 &&\n\n                    frame_bottomBand == 0 &&\n\n                    frame_leftBand == 0 &&\n\n                    frame_rightBand == 0)\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 0;\n\n                } else if ((codec->width == icodec->width -\n\n                                (frame_leftBand + frame_rightBand)) &&\n\n                        (codec->height == icodec->height -\n\n                                (frame_topBand  + frame_bottomBand)))\n\n                {\n\n                    ost->video_resample = 0;\n\n                    ost->video_crop = 1;\n\n                    ost->topBand = frame_topBand;\n\n                    ost->leftBand = frame_leftBand;\n\n                } else {\n\n                    uint8_t *buf;\n\n                    ost->video_resample = 1;\n\n                    ost->video_crop = 0; // cropping is handled as part of resample\n\n                    buf = av_malloc((codec->width * codec->height * 3) / 2);\n\n                    if (!buf)\n\n                        goto fail;\n\n                    ost->pict_tmp.data[0] = buf;\n\n                    ost->pict_tmp.data[1] = ost->pict_tmp.data[0] + (codec->width * codec->height);\n\n                    ost->pict_tmp.data[2] = ost->pict_tmp.data[1] + (codec->width * codec->height) / 4;\n\n                    ost->pict_tmp.linesize[0] = codec->width;\n\n                    ost->pict_tmp.linesize[1] = codec->width / 2;\n\n                    ost->pict_tmp.linesize[2] = codec->width / 2;\n\n\n\n                    ost->img_resample_ctx = img_resample_full_init( \n\n                                      ost->st->codec.width, ost->st->codec.height,\n\n                                      ist->st->codec.width, ist->st->codec.height,\n\n                                      frame_topBand, frame_bottomBand,\n\n                                      frame_leftBand, frame_rightBand);\n\n                }\n\n                ost->encoding_needed = 1;\n\n                ist->decoding_needed = 1;\n\n                break;\n\n            default:\n\n                av_abort();\n\n            }\n\n            /* two pass mode */\n\n            if (ost->encoding_needed && \n\n                (codec->flags & (CODEC_FLAG_PASS1 | CODEC_FLAG_PASS2))) {\n\n                char logfilename[1024];\n\n                FILE *f;\n\n                int size;\n\n                char *logbuffer;\n\n                \n\n                snprintf(logfilename, sizeof(logfilename), \"%s-%d.log\", \n\n                         pass_logfilename ? \n\n                         pass_logfilename : DEFAULT_PASS_LOGFILENAME, i);\n\n                if (codec->flags & CODEC_FLAG_PASS1) {\n\n                    f = fopen(logfilename, \"w\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    ost->logfile = f;\n\n                } else {\n\n                    /* read the log file */\n\n                    f = fopen(logfilename, \"r\");\n\n                    if (!f) {\n\n                        perror(logfilename);\n\n                        exit(1);\n\n                    }\n\n                    fseek(f, 0, SEEK_END);\n\n                    size = ftell(f);\n\n                    fseek(f, 0, SEEK_SET);\n\n                    logbuffer = av_malloc(size + 1);\n\n                    if (!logbuffer) {\n\n                        fprintf(stderr, \"Could not allocate log buffer\\n\");\n\n                        exit(1);\n\n                    }\n\n                    fread(logbuffer, 1, size, f);\n\n                    fclose(f);\n\n                    logbuffer[size] = '\\0';\n\n                    codec->stats_in = logbuffer;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    /* dump the file output parameters - cannot be done before in case\n\n       of stream copy */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        dump_format(output_files[i], i, output_files[i]->filename, 1);\n\n    }\n\n\n\n    /* dump the stream mapping */\n\n    fprintf(stderr, \"Stream mapping:\\n\");\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        fprintf(stderr, \"  Stream #%d.%d -> #%d.%d\\n\",\n\n                ist_table[ost->source_index]->file_index,\n\n                ist_table[ost->source_index]->index,\n\n                ost->file_index, \n\n                ost->index);\n\n    }\n\n\n\n    /* open each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_encoder(ost->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec for output stream #%d.%d\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ost->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for stream #%d.%d - maybe incorrect parameters such as bit_rate, rate, width or height\\n\", \n\n                        ost->file_index, ost->index);\n\n                exit(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* open each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            AVCodec *codec;\n\n            codec = avcodec_find_decoder(ist->st->codec.codec_id);\n\n            if (!codec) {\n\n                fprintf(stderr, \"Unsupported codec (id=%d) for input stream #%d.%d\\n\", \n\n                        ist->st->codec.codec_id, ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            if (avcodec_open(&ist->st->codec, codec) < 0) {\n\n                fprintf(stderr, \"Error while opening codec for input stream #%d.%d\\n\", \n\n                        ist->file_index, ist->index);\n\n                exit(1);\n\n            }\n\n            //if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO)\n\n            //    ist->st->codec.flags |= CODEC_FLAG_REPEAT_FIELD;\n\n            ist->frame_decoded = 1;\n\n        }\n\n    }\n\n\n\n    /* init pts */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n\tis = input_files[ist->file_index];\n\n        ist->pts = 0;\n\n        if (ist->decoding_needed) {\n\n            switch (ist->st->codec.codec_type) {\n\n            case CODEC_TYPE_AUDIO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.sample_rate);\n\n                break;\n\n            case CODEC_TYPE_VIDEO:\n\n                av_frac_init(&ist->next_pts, \n\n                             0, 0, is->pts_num * ist->st->codec.frame_rate);\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    \n\n    /* compute buffer size max (should use a complete heuristic) */\n\n    for(i=0;i<nb_input_files;i++) {\n\n        file_table[i].buffer_size_max = 2048;\n\n    }\n\n\n\n    /* open files and write file headers */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        if (av_write_header(os) < 0) {\n\n            fprintf(stderr, \"Could not write header for output file #%d (incorrect codec paramters ?)\\n\", i);\n\n            ret = -EINVAL;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n#ifndef CONFIG_WIN32\n\n    if ( !using_stdin )\n\n        fprintf(stderr, \"Press [q] to stop encoding\\n\");\n\n#endif\n\n    term_init();\n\n\n\n    stream_no_data = 0;\n\n    key = -1;\n\n\n\n    for(; received_sigterm == 0;) {\n\n        int file_index, ist_index;\n\n        AVPacket pkt;\n\n        uint8_t *ptr;\n\n        int len;\n\n        uint8_t *data_buf;\n\n        int data_size, got_picture;\n\n        AVPicture picture;\n\n        short samples[AVCODEC_MAX_AUDIO_FRAME_SIZE / 2];\n\n        void *buffer_to_free;\n\n        double pts_min;\n\n        \n\n    redo:\n\n        /* if 'q' pressed, exits */\n\n        if (!using_stdin) {\n\n            /* read_key() returns 0 on EOF */\n\n            key = read_key();\n\n            if (key == 'q')\n\n                break;\n\n        }\n\n\n\n        /* select the stream that we must read now by looking at the\n\n           smallest output pts */\n\n        file_index = -1;\n\n        pts_min = 1e10;\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            double pts;\n\n            ost = ost_table[i];\n\n            os = output_files[ost->file_index];\n\n            ist = ist_table[ost->source_index];\n\n            pts = (double)ost->st->pts.val * os->pts_num / os->pts_den;\n\n            if (!file_table[ist->file_index].eof_reached && \n\n                pts < pts_min) {\n\n                pts_min = pts;\n\n                file_index = ist->file_index;\n\n            }\n\n        }\n\n        /* if none, if is finished */\n\n        if (file_index < 0) {\n\n            break;\n\n        }\n\n\n\n        /* finish if recording time exhausted */\n\n        if (recording_time > 0 && pts_min >= (recording_time / 1000000.0))\n\n            break;\n\n\n\n        /* read a packet from it and output it in the fifo */\n\n        is = input_files[file_index];\n\n        if (av_read_packet(is, &pkt) < 0) {\n\n            file_table[file_index].eof_reached = 1;\n\n            continue;\n\n        }\n\n        if (!pkt.size) {\n\n            stream_no_data = is;\n\n        } else {\n\n            stream_no_data = 0;\n\n        }\n\n        if (do_hex_dump) {\n\n            printf(\"stream #%d, size=%d:\\n\", pkt.stream_index, pkt.size);\n\n            av_hex_dump(pkt.data, pkt.size);\n\n        }\n\n        /* the following test is needed in case new streams appear\n\n           dynamically in stream : we ignore them */\n\n        if (pkt.stream_index >= file_table[file_index].nb_streams)\n\n            goto discard_packet;\n\n        ist_index = file_table[file_index].ist_index + pkt.stream_index;\n\n        ist = ist_table[ist_index];\n\n        if (ist->discard)\n\n            goto discard_packet;\n\n\n\n        // printf(\"read #%d.%d size=%d\\n\", ist->file_index, ist->index, pkt.size);\n\n\n\n        len = pkt.size;\n\n        ptr = pkt.data;\n\n        while (len > 0) {\n\n            /* decode the packet if needed */\n\n            data_buf = NULL; /* fail safe */\n\n            data_size = 0;\n\n            if (ist->decoding_needed) {\n\n                /* NOTE1: we only take into account the PTS if a new\n\n                   frame has begun (MPEG semantics) */\n\n                /* NOTE2: even if the fraction is not initialized,\n\n                   av_frac_set can be used to set the integer part */\n\n                if (ist->frame_decoded) { \n\n                    /* If pts is unavailable -- we have to use synthetic one */\n\n                    if( pkt.pts != AV_NOPTS_VALUE )\n\n                    {\n\n                        ist->pts = ist->next_pts.val = pkt.pts;\n\n                    }\n\n                    else\n\n                    {\n\n                        ist->pts = ist->next_pts.val;\n\n                    }\n\n                    ist->frame_decoded = 0;\n\n                }\n\n\n\n                switch(ist->st->codec.codec_type) {\n\n                case CODEC_TYPE_AUDIO:\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                    ret = avcodec_decode_audio(&ist->st->codec, samples, &data_size,\n\n                                               ptr, len);\n\n                    if (ret < 0)\n\n                        goto fail_decode;\n\n                    /* Some bug in mpeg audio decoder gives */\n\n                    /* data_size < 0, it seems they are overflows */\n\n                    if (data_size <= 0) {\n\n                        /* no audio frame */\n\n                        ptr += ret;\n\n                        len -= ret;\n\n                        continue;\n\n                    }\n\n                    data_buf = (uint8_t *)samples;\n\n\t\t    av_frac_add(&ist->next_pts, \n\n\t\t\t        is->pts_den * data_size / (2 * ist->st->codec.channels));\n\n                    break;\n\n                case CODEC_TYPE_VIDEO:\n\n                    {\n\n                        AVFrame big_picture;\n\n\n\n                        data_size = (ist->st->codec.width * ist->st->codec.height * 3) / 2;\n\n                        ret = avcodec_decode_video(&ist->st->codec, \n\n                                                   &big_picture, &got_picture, ptr, len);\n\n                        picture= *(AVPicture*)&big_picture;\n\n                        ist->st->quality= big_picture.quality;\n\n                        if (ret < 0) {\n\n                        fail_decode:\n\n                            fprintf(stderr, \"Error while decoding stream #%d.%d\\n\",\n\n                                    ist->file_index, ist->index);\n\n                            av_free_packet(&pkt);\n\n                            goto redo;\n\n                        }\n\n                        if (!got_picture) {\n\n                            /* no picture yet */\n\n                            ptr += ret;\n\n                            len -= ret;\n\n                            continue;\n\n                        }\n\n                        av_frac_add(&ist->next_pts, \n\n\t\t\t            is->pts_den * ist->st->codec.frame_rate_base);          \n\n                    }\n\n                    break;\n\n                default:\n\n                    goto fail_decode;\n\n                }\n\n            } else {\n\n                data_buf = ptr;\n\n                data_size = len;\n\n                ret = len;\n\n            }\n\n            ptr += ret;\n\n            len -= ret;\n\n\n\n            buffer_to_free = 0;\n\n            if (ist->st->codec.codec_type == CODEC_TYPE_VIDEO) {\n\n                pre_process_video_frame(ist, &picture, &buffer_to_free);\n\n            }\n\n\n\n            ist->frame_decoded = 1;\n\n\n\n            /* frame rate emulation */\n\n            if (ist->st->codec.rate_emu) {\n\n                int64_t pts = av_rescale((int64_t) ist->frame * ist->st->codec.frame_rate_base, 1000000, ist->st->codec.frame_rate);\n\n                int64_t now = av_gettime() - ist->start;\n\n                if (pts > now)\n\n                    usleep(pts - now);\n\n\n\n                ist->frame++;\n\n            }\n\n\n\n#if 0\n\n            /* mpeg PTS deordering : if it is a P or I frame, the PTS\n\n               is the one of the next displayed one */\n\n            /* XXX: add mpeg4 too ? */\n\n            if (ist->st->codec.codec_id == CODEC_ID_MPEG1VIDEO) {\n\n                if (ist->st->codec.pict_type != B_TYPE) {\n\n                    int64_t tmp;\n\n                    tmp = ist->last_ip_pts;\n\n                    ist->last_ip_pts  = ist->frac_pts.val;\n\n                    ist->frac_pts.val = tmp;\n\n                }\n\n            }\n\n#endif\n\n            /* transcode raw format, encode packets and output them */\n\n\n\n            for(i=0;i<nb_ostreams;i++) {\n\n                int frame_size;\n\n\n\n                ost = ost_table[i];\n\n                if (ost->source_index == ist_index) {\n\n                    os = output_files[ost->file_index];\n\n\n\n#if 0\n\n                    printf(\"%d: got pts=%f %f\\n\", i, pkt.pts / 90000.0, \n\n                           (ist->pts - ost->st->pts.val) / 90000.0);\n\n#endif\n\n                    /* set the input output pts pairs */\n\n                    ost->sync_ipts = (double)ist->pts * is->pts_num / \n\n                        is->pts_den;\n\n                    /* XXX: take into account the various fifos,\n\n                       in particular for audio */\n\n                    ost->sync_opts = ost->st->pts.val;\n\n                    //printf(\"ipts=%lld sync_ipts=%f sync_opts=%lld pts.val=%lld pkt.pts=%lld\\n\", ist->pts, ost->sync_ipts, ost->sync_opts, ost->st->pts.val, pkt.pts); \n\n\n\n                    if (ost->encoding_needed) {\n\n                        switch(ost->st->codec.codec_type) {\n\n                        case CODEC_TYPE_AUDIO:\n\n                            do_audio_out(os, ost, ist, data_buf, data_size);\n\n                            break;\n\n                        case CODEC_TYPE_VIDEO:\n\n                            /* find an audio stream for synchro */\n\n                            {\n\n                                int i;\n\n                                AVOutputStream *audio_sync, *ost1;\n\n                                audio_sync = NULL;\n\n                                for(i=0;i<nb_ostreams;i++) {\n\n                                    ost1 = ost_table[i];\n\n                                    if (ost1->file_index == ost->file_index &&\n\n                                        ost1->st->codec.codec_type == CODEC_TYPE_AUDIO) {\n\n                                        audio_sync = ost1;\n\n                                        break;\n\n                                    }\n\n                                }\n\n\n\n                                do_video_out(os, ost, ist, &picture, &frame_size, audio_sync);\n\n                                if (do_vstats && frame_size)\n\n                                    do_video_stats(os, ost, frame_size);\n\n                            }\n\n                            break;\n\n                        default:\n\n                            av_abort();\n\n                        }\n\n                    } else {\n\n                        AVFrame avframe;\n\n                                                \n\n                        /* no reencoding needed : output the packet directly */\n\n                        /* force the input stream PTS */\n\n                        \n\n                        memset(&avframe, 0, sizeof(AVFrame));\n\n                        ost->st->codec.coded_frame= &avframe;\n\n\t\t\tavframe.key_frame = pkt.flags & PKT_FLAG_KEY; \n\n                        \n\n                        av_write_frame(os, ost->index, data_buf, data_size);\n\n\t\t\tost->st->codec.frame_number++;\n\n\t\t\tost->frame_number++;\n\n                    }\n\n                }\n\n            }\n\n            av_free(buffer_to_free);\n\n        }\n\n    discard_packet:\n\n        av_free_packet(&pkt);\n\n        \n\n        /* dump report by using the output first video and audio streams */\n\n        print_report(output_files, ost_table, nb_ostreams, 0);\n\n    }\n\n    term_exit();\n\n\n\n    /* dump report by using the first video and audio streams */\n\n    print_report(output_files, ost_table, nb_ostreams, 1);\n\n\n\n    /* close each encoder */\n\n    for(i=0;i<nb_ostreams;i++) {\n\n        ost = ost_table[i];\n\n        if (ost->encoding_needed) {\n\n            av_freep(&ost->st->codec.stats_in);\n\n            avcodec_close(&ost->st->codec);\n\n        }\n\n    }\n\n    \n\n    /* close each decoder */\n\n    for(i=0;i<nb_istreams;i++) {\n\n        ist = ist_table[i];\n\n        if (ist->decoding_needed) {\n\n            avcodec_close(&ist->st->codec);\n\n        }\n\n    }\n\n    \n\n\n\n    /* write the trailer if needed and close file */\n\n    for(i=0;i<nb_output_files;i++) {\n\n        os = output_files[i];\n\n        av_write_trailer(os);\n\n    }\n\n    /* finished ! */\n\n    \n\n    ret = 0;\n\n fail1:\n\n    av_free(file_table);\n\n\n\n    if (ist_table) {\n\n        for(i=0;i<nb_istreams;i++) {\n\n            ist = ist_table[i];\n\n            av_free(ist);\n\n        }\n\n        av_free(ist_table);\n\n    }\n\n    if (ost_table) {\n\n        for(i=0;i<nb_ostreams;i++) {\n\n            ost = ost_table[i];\n\n            if (ost) {\n\n                if (ost->logfile) {\n\n                    fclose(ost->logfile);\n\n                    ost->logfile = NULL;\n\n                }\n\n                fifo_free(&ost->fifo); /* works even if fifo is not\n\n                                          initialized but set to zero */\n\n                av_free(ost->pict_tmp.data[0]);\n\n                if (ost->video_resample)\n\n                    img_resample_close(ost->img_resample_ctx);\n\n                if (ost->audio_resample)\n\n                    audio_resample_close(ost->resample);\n\n                av_free(ost);\n\n            }\n\n        }\n\n        av_free(ost_table);\n\n    }\n\n    return ret;\n\n fail:\n\n    ret = -ENOMEM;\n\n    goto fail1;\n\n}\n", "idx": 13268, "substitutes": {"output_files": ["output_images", "output___maps", "output___images", "output___file", "input_images", "output___files", "input_file", "output_file", "input_maps", "output_maps"], "nb_output_files": ["nb_outputvmaps", "nb_output_groups", "nb_outputvfiles", "nb_output_maps", "nb_input_maps", "nb_input_file", "nb_input_groups", "nb_outputvfile", "nb_outputvgroups", "nb_output_file"], "input_files": ["file_uploads", "inputinggroups", "inputingitems", "inputingmodels", "fileinguploads", "fileinggroups", "fileingimages", "current_files", "inputinguploads", "current_images", "current_flows", "input_items", "fileingfiles", "input_models", "input_flows", "input_lines", "file_groups", "inputingimages", "inputsuploads", "current_lines", "output_models", "inputsimages", "inputsgroups", "output_items", "inputsfiles", "input_images", "file_images", "input_file", "input_groups", "output_file", "file_files", "inputingfiles", "input_uploads", "inputingfile"], "nb_input_files": ["nb_input_images", "nb_inputablechildren", "nb_input_models", "nb_inputschildren", "nb_inputsiles", "nb_outputsfile", "nb_input_thumbnails", "nb_inputingthumbnails", "nb_inputsfile", "nb_inputityfiles", "nb_input2files", "nb_output_children", "nb_input2images", "nb_input_iles", "nb_inputableiles", "nb_inputingmodels", "nb_input_file", "nb_output_models", "nb_input_children", "nb_input2models", "nb_inputsfiles", "nb_outputschildren", "nb_output_iles", "nb_inputingfile", "nb_input_steps", "nb_inputablemodels", "nb_inputityiles", "nb_inputitychildren", "nb_input_objects", "nb_inputablesteps", "nb_outputsfiles", "nb_output_thumbnails", "nb_inputablefiles", "nb_inputingfiles", "nb_outputsiles", "nb_inputityfile", "nb_output_file", "nb_input2objects", "nb_input2file", "nb_output_steps", "nb_output_objects", "nb_output_images", "nb_inputablefile", "nb_input2thumbnails"], "stream_maps": [" stream_map", " stream_devices", "stream_map", "stream_devices"], "nb_stream_maps": ["nb_channel_maps", "nb_streamsfiles", "nb_stream_files", "nb_channel_files", "nb_channel_map", "nb_streamsmap", "nb_stream_map", "nb_streamsmaps"], "ret": ["en", "ru", "rc", "val", "N", "fun", "status", "feat", "mem", "rec", "du", "match", "Ret", "result", " RET", " success", "all", "resp", "J", "RET", "res", "reg", "num", "bl"], "i": ["qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "id", "iu", "l", "ini", "my", "gi", "io", "a", "api", "lc", "ci", "ki", "x", "di", "si", "ie", "init", "ii", "uri", "v", "o", "yi", "u", "z", "p", "e", "s", "info", "fi", "mi", "li", "b", "ix", "phi", "ti", "ip", "c", "eni", "anti", "inner", "ji", "pi", "im", "bi", "ri", "ik", "ori", "zi", "y", "in", "index"], "j": ["jj", "adj", "uj", "jen", "it", "m", "ch", "aj", "kj", "d", "t", "ja", "jp", "l", "oj", "name", "g", "syn", "ci", "dj", "h", "x", "jet", "ie", "ii", "v", "job", "br", "jam", "o", "w", "obj", "z", "ind", "jit", "p", "e", "note", "li", "b", "json", "jo", "eni", "jl", "jc", "je", "ji", "q", "r", "J", "y", "ij", "index", "start"], "k": ["ke", "dk", "m", "ek", "ch", "ak", "in", "tk", "id", "l", "unk", "ko", "kn", "g", "ki", "kick", "uk", "sk", "h", "x", "kk", "v", "kh", "kw", "o", "w", "z", "u", "ka", "p", "ok", "ku", "ck", "b", "ask", "th", "mk", "c", "K", "q", "ik", "ky", "work", "y", "km", "ks"], "n": ["m", "nl", "d", "t", "ni", "l", "nn", "N", "g", "nb", "o", "np", "w", "z", "u", "p", "e", "nc", "b", "c", "ns", "pn", "sn", "nt", "nr", "num", "y"], "is": ["it", "ais", "ists", "ch", "as", "bis", "so", "ai", "core", "bs", "id", "ins", "has", "lis", "iv", "ish", "or", "a", "api", "l", "ci", "cs", "image", "its", "x", "inn", "IS", "es", "ie", "iris", "init", "ii", "js", "app", "uri", "ps", "isc", "ois", "isa", "ris", "ib", "info", "s", "ir", "se", "vs", "p", "isl", "list", "ip", "isi", "il", "ics", "pi", "iso", "ic", "im", "ri", "ar", "are", "us", "ils", "las", "iss", "kit", "in", "Is"], "os": ["oper", "sys", "osi", "as", "enc", "so", "pc", "oss", "oa", "io", "or", "o", "ois", "ms", "oc", "OS", "co", "op", "ocol", "ol", "ast", "ops", "od", "pos", "ot"], "codec": ["genef", "codpc", "cdpc", "pedEC", "codepc", "codeef", "codenc", "Coderer", "codef", "genenc", "pedec", "odef", "coderer", "cdef", "CodEC", "codEC", "cdenc", "genpc", "Codef", "oderer", "cdec", "codeec", "pederer", "odec", "odEC", "pedef", "Codec", "codeenc", "genec"], "icodec": ["acODel", "icodeec", "icodedesc", "acodel", "icodedel", "acodEC", "icODel", "icodedEC", "icodEC", "acODec", "icodeesc", "acodec", "icodedec", "acODEC", "icodesc", "icODec", "icodeEC", "icodel", "acodesc", "icODesc", "icodeel", "acODesc", "icODEC"], "ost": ["ess", "dist", "art", "oss", "pt", "tt", "ace", "ct", "irst", "alist", "ad", "ind", "oc", "op", "est", "inst", "ont", "nt", "ast", "host", "od", "rest", "src", "dr", "ot", "et"], "ost_table": ["ist__table", "ist__tab", "ist_cache", "ist__map", "ost_map", "ost_tab", "ist__cache", "ist_tab", "ist_map", "ost_cache"], "ist": ["ess", "istance", "gest", "it", "pse", "ists", "osi", "rss", "ft", "part", "edit", "adder", "dist", "art", "jp", "id", "back", "pt", "asi", "pick", "er", "act", "ust", "test", "tta", "std", "tt", "lp", "xt", "ace", "pect", "ld", "artist", "ict", "force", "exist", "iste", "mot", "irst", "feat", "alist", "set", "ad", "ind", "ant", "p", "kt", "IST", "data", "est", "dit", "inst", "list", "ort", "wp", "at", "state", "isi", "ans", "att", "point", "ht", "ast", "ism", "ert", "rest", "dr", "hop", "et"], "ist_table": ["ism_table", "ist_TABLE", "pickstable", "iststable", "dist_cache", "port_family", "ist_list", "picksdict", "istendict", "iststree", "port_table", "dist_list", "pick_tree", "istentree", "ist_tab", "ist_tree", "pick_dict", "ist_rule", "istsdict", "ism_tree", "istencache", "ist_family", "ism_count", "port_rule", "port_tab", "ism_TABLE", "ist_count", "dist_tab", "istentable", "dist_code", "pick_table", "ist_code", "ist_cache", "istscache", "ist_header", "dist_index", "dist_table", "ist_dict", "pickstree", "pickscache", "pick_cache", "dist_header"], "file_table": ["fileertemplate", "file_module", "wordingsession", "fileptable", " file_cache", "progressertree", "file_tree", "file_file", "progressertab", " file_file", "filepmodule", "input_file", "input_cache", "progressertemplate", "progress_tree", "word_tree", "file_template", "fileingsession", "word_session", "file_session", " file_list", "file_cache", "fileingbuffer", "wordingtable", "fileingtab", "filepfile", "fileertab", "wordingtree", "input_table", "fileingcache", "fileingindex", "fileertable", "fileertree", "input_tab", "input_buffer", "progress_tab", "progress_template", "progress_table", "progressertable", "file_tab", "word_table", "fileingtree", "file_buffer", "wordingindex", "file_list", "word_index", "fileingtable", "input_module", "filepcache"], "stream_no_data": ["stream_meta_length", "stream_no_media", "stream_no_cache", "stream_meta_data", "stream_meta_cache", "stream_meta_media", "stream_no_length"], "key": ["jj", "m", "ek", "ak", "jp", "val", "id", "row", "x", "Key", "sec", "ver", "base", "count", "ip", "loop", "q", "keys", "J", "seq", "res", "num", "order", "max", "start"], "file_index": ["file__offset", "file_offset", "file_type", "line__offset", "filevoffset", "line_offset", "line__index", "file_position", "line_type", "filevtype", "line_index", "line_position", "file__type", "line__position", "filevindex", "filevposition", "line__type", "file__position", "file__index"], "ist_index": ["ast_index", "ast_id", "ist_id", "ast_name", "ist_name"], "st": ["sta", "service", "leg", "ste", "std", "sth", "sw", "str", "ld", "ct", "fr", "ss", "cr", "irst", "bl", "stop", "stage", "be", "ST", "stand", "sd", "est", "inst", "St", "play", "fe", "stem", "end", "stim", "stress", "ast", "sl", "rest", "gest", "cl", "sts", "start"], "frame": ["transfer", "trace", "seed", "sample", "period", "fps", "weight", "cpu", "unit", "position", "error", "stage", "version", "base", "play", "frames", "speed", "block", "reset", "clock", "offset", "scale", "load", "rot", "cycle", "delay", "roll", "thread"]}}
{"project": "FFmpeg", "commit_id": "f37b2d5a6884c7bea87a6c7454239381449bd637", "target": 1, "func": "int avpriv_mpeg4audio_get_config(MPEG4AudioConfig *c, const uint8_t *buf,\n                                 int bit_size, int sync_extension)\n{\n    GetBitContext gb;\n    int specific_config_bitindex;\n    init_get_bits(&gb, buf, bit_size);\n    c->object_type = get_object_type(&gb);\n    c->sample_rate = get_sample_rate(&gb, &c->sampling_index);\n    c->chan_config = get_bits(&gb, 4);\n    if (c->chan_config < FF_ARRAY_ELEMS(ff_mpeg4audio_channels))\n        c->channels = ff_mpeg4audio_channels[c->chan_config];\n    c->sbr = -1;\n    c->ps  = -1;\n    if (c->object_type == AOT_SBR || (c->object_type == AOT_PS &&\n        // check for W6132 Annex YYYY draft MP3onMP4\n        !(show_bits(&gb, 3) & 0x03 && !(show_bits(&gb, 9) & 0x3F)))) {\n        if (c->object_type == AOT_PS)\n            c->ps = 1;\n        c->ext_object_type = AOT_SBR;\n        c->sbr = 1;\n        c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n        c->object_type = get_object_type(&gb);\n        if (c->object_type == AOT_ER_BSAC)\n            c->ext_chan_config = get_bits(&gb, 4);\n    } else {\n        c->ext_object_type = AOT_NULL;\n        c->ext_sample_rate = 0;\n    }\n    specific_config_bitindex = get_bits_count(&gb);\n    if (c->object_type == AOT_ALS) {\n        skip_bits(&gb, 5);\n        if (show_bits_long(&gb, 24) != MKBETAG('\\0','A','L','S'))\n            skip_bits_long(&gb, 24);\n        specific_config_bitindex = get_bits_count(&gb);\n        if (parse_config_ALS(&gb, c))\n            return -1;\n    }\n    if (c->ext_object_type != AOT_SBR && sync_extension) {\n        while (get_bits_left(&gb) > 15) {\n            if (show_bits(&gb, 11) == 0x2b7) { // sync extension\n                get_bits(&gb, 11);\n                c->ext_object_type = get_object_type(&gb);\n                if (c->ext_object_type == AOT_SBR && (c->sbr = get_bits1(&gb)) == 1)\n                    c->ext_sample_rate = get_sample_rate(&gb, &c->ext_sampling_index);\n                if (get_bits_left(&gb) > 11 && get_bits(&gb, 11) == 0x548)\n                    c->ps = get_bits1(&gb);\n                break;\n            } else\n                get_bits1(&gb); // skip 1 bit\n        }\n    }\n    //PS requires SBR\n    if (!c->sbr)\n        c->ps = 0;\n    //Limit implicit PS to the HE-AACv2 Profile\n    if ((c->ps == -1 && c->object_type != AOT_AAC_LC) || c->channels & ~0x01)\n        c->ps = 0;\n    return specific_config_bitindex;\n}", "idx": 13273, "substitutes": {"c": ["m", "ch", "mc", "cm", "bc", "uc", "d", "ca", "enc", "t", "rc", "config", "cc", "l", "pc", "C", "lc", "cs", "ci", "ctrl", "g", "cit", "cn", "h", "x", "cy", "con", "ct", "v", "conf", "cr", "w", "cd", "u", "z", "oc", "p", "e", "s", "nc", "k", "b", "co", "tc", "f", "arc", "cca", "cu", "dc", "ac", "cb", "sc", "ce", "cf", "ic", "coll", "icc", "cp", "r", "vc", "xc", "cache", "ec", "cur", "cl", "ctx"], "buf": ["vec", "port", "ff", "bc", "queue", "fd", "cv", "rc", "config", "batch", "fb", "uf", "nb", "buffer", "fp", "v", "br", "buff", "mem", " buffer", "rb", "bm", "fi", "pb", "b", "sb", "Buffer", "box", "Buff", "f", "cb", "loop", "cf", "src", "seq", "len", "ctx", "alloc"], "bit_size": [" bit_count", "bitqrate", "batch_weight", "bit_weight", "batch_rate", "bit_number", "bitCrate", "bitNsize", "bit_length", "batch_number", "batchqnumber", "bit_rate", "bitqnumber", "bitNnumber", "batchqweight", "bitqsize", " bit_length", "batchqsize", "bitCnumber", "bitqweight", "bitCweight", "batch_size", "bitCsize", " bit_number", "bitNlength", "batchqrate", "bitNcount", "bit_count"], "sync_extension": [" sync_extraction", " sync_xtraction", " sync_descraction", " sync_EXTension", " sync_EXTraction", " sync_EXTend", " sync_xtension", " sync_EXTensions", " sync_xtend", " sync_extensions", " sync_descension", " sync_xtensions", " sync_descensions", " sync_extend", " sync_descend"], "gb": ["bridge", "xb", "bc", "gio", "gt", "gin", "yg", "gru", "gd", "gg", "oga", "rb", "usb", "bf", " eg", "cb", "eb", "abb", "ga", " kb", "rc", "bb", "g", "tg", "gh", "cgi", "s", "bm", "b", "byte", " g", "gam", "gom", "kb", "vt", "git", "gow", "gz", "pc", "ci", "pg", "hub", "rg", "nb", "game", "gn", "sb", "cfg", "gpu", "bo", " rgb", " cc", "node", "gp", "ui", "cm", " db", "gae", "_", "bn", " rc", "Gb", "gy", " rg", "mb", "gu", "gl", "gm", "gs", " gcc", "bg", "cod", "all", "db", "GB", "gal"], "specific_config_bitindex": ["specific_config_longnum", "specific_config_blocksection", "specific_config_bitdepth", "specific_config_bitsdepth", "specific_config_bitnum", "specific_config_bytenumber", "specific_config_longindex", "specific_config_longdepth", "specific_config_bitsnum", "specific_config_microindex", "specific_config_bitsize", "specific_config_lockpos", "specific_config_bitsindex", "specific_config_backsize", "specific_config_longsize", "specific_config_microIndex", "specific_config_bootpos", "specific_config_bitssize", "specific_config_bootindex", "specific_config_backnum", "specific_config_micronumber", "specific_config_microsection", "specific_config_bytesection", "specific_config_lockindex", "specific_config_bitpointer", "specific_config_blocknumber", "specific_config_bitIndex", "specific_config_byteIndex", "specific_config_bitnumber", "specific_config_bitpos", "specific_config_blockindex", "specific_config_blockIndex", "specific_config_bootpointer", "specific_config_bitsection", "specific_config_lockpointer", "specific_config_backdepth", "specific_config_byteindex", "specific_config_backindex"]}}
{"project": "FFmpeg", "commit_id": "a52f443714b5c2a40ed272d8445f4c39220a4b69", "target": 1, "func": "static av_always_inline void vc1_apply_p_h_loop_filter(VC1Context *v, int block_num)\n\n{\n\n    MpegEncContext *s  = &v->s;\n\n    int mb_cbp         = v->cbp[s->mb_x - 1 - s->mb_stride],\n\n        block_cbp      = mb_cbp      >> (block_num * 4), right_cbp,\n\n        mb_is_intra    = v->is_intra[s->mb_x - 1 - s->mb_stride],\n\n        block_is_intra = mb_is_intra >> (block_num * 4), right_is_intra;\n\n    int idx, linesize  = block_num > 3 ? s->uvlinesize : s->linesize, ttblk;\n\n    uint8_t *dst;\n\n\n\n    if (block_num > 3) {\n\n        dst = s->dest[block_num - 3] - 8 * linesize;\n\n    } else {\n\n        dst = s->dest[0] + (block_num & 1) * 8 + ((block_num & 2) * 4 - 16) * linesize - 8;\n\n    }\n\n\n\n    if (s->mb_x != s->mb_width || !(block_num & 5)) {\n\n        int16_t (*mv)[2];\n\n\n\n        if (block_num > 3) {\n\n            right_cbp      = v->cbp[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            right_is_intra = v->is_intra[s->mb_x - s->mb_stride] >> (block_num * 4);\n\n            mv             = &v->luma_mv[s->mb_x - s->mb_stride - 1];\n\n        } else {\n\n            right_cbp      = (block_num & 1) ? (v->cbp[s->mb_x - s->mb_stride]      >> ((block_num - 1) * 4))\n\n                                             : (mb_cbp                              >> ((block_num + 1) * 4));\n\n            right_is_intra = (block_num & 1) ? (v->is_intra[s->mb_x - s->mb_stride] >> ((block_num - 1) * 4))\n\n                                             : (mb_is_intra                         >> ((block_num + 1) * 4));\n\n            mv             = &s->current_picture.motion_val[0][s->block_index[block_num] - s->b8_stride * 2 - 2];\n\n        }\n\n        if (block_is_intra & 1 || right_is_intra & 1 || mv[0][0] != mv[1][0] || mv[0][1] != mv[1][1]) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else {\n\n            idx = ((right_cbp >> 1) | block_cbp) & 5; // FIXME check\n\n            if (idx == 5) {\n\n                v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n            } else if (idx) {\n\n                if (idx == 1)\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst + 4 * linesize, linesize, v->pq);\n\n                else\n\n                    v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n            }\n\n        }\n\n    }\n\n\n\n    dst -= 4;\n\n    ttblk = (v->ttblk[s->mb_x - s->mb_stride - 1] >> (block_num * 4)) & 0xf;\n\n    if (ttblk == TT_4X4 || ttblk == TT_4X8) {\n\n        idx = (block_cbp | (block_cbp >> 1)) & 5;\n\n        if (idx == 5) {\n\n            v->vc1dsp.vc1_h_loop_filter8(dst, linesize, v->pq);\n\n        } else if (idx) {\n\n            if (idx == 1)\n\n                v->vc1dsp.vc1_h_loop_filter4(dst + linesize * 4, linesize, v->pq);\n\n            else\n\n                v->vc1dsp.vc1_h_loop_filter4(dst,                linesize, v->pq);\n\n        }\n\n    }\n\n}\n", "idx": 13311, "substitutes": {"v": ["m", "vim", "d", "t", "vv", "l", "i", "vp", "iv", "g", "vic", "conv", "h", "ve", "vm", "vol", "nav", "vi", "server", "tv", "var", "o", "av", "w", "vert", "view", "u", "z", "version", "p", "e", "ver", "k", "http", "b", "j", "n", "f", "c", "volt", "lv", "ov", "sv", "va", "nv", "q", "uv", "r", "vc", "V", "vu", "ev", "vd", "video", "vt", "vs", "y"], "block_num": ["bc", "blockernone", "Block_num", " block_dim", "blocksnum", "block_two", " block_Num", "image", "bytes", " block_label", "blockvalnum", "lock_num", "blockPnote", "block33num", " block_param", "Block_number", "line_number", "block_dim", "label_san", "objecternone", "lock_number", "block64nam", "block25number", " block_un", "line_num", "blockslabel", "block00san", "end", "blockerno", "blockacnum", " block_sum", "block5number", "block67common", "block2num", "blockqtwo", " block_no", "block_length", "block_four", "blockalNUM", "block33sem", "g", "blockslength", " block2dim", "blockPnum", "block_label", "block_NUM", "blockalnum", "label_num", "blockqnone", "Block_set", "lock_um", "blockernumber", "block_net", "objectertun", "block_un", "block2number", " block_NUM", "block2begin", " block2num", "r", "Block_four", " block_nam", "block64none", "blockernam", "blockPdiv", "block_nom", "block_common", "blockednum", "blockallabel", "label33num", "blockingmn", "label33sum", "blockingnum", "block33san", "blockednumber", "block64num", "block_param", "blockacnam", "blockednet", "block_com", "object_nam", "Block_sem", "block5four", "block_none", "blockernum", "blockacnumber", "blockPnumber", "object_none", "blockalnumber", "blockedmn", "blockjnum", "block_no", "block67sum", "block25num", "Block_nom", "block1number", "label33sem", "block67un", "label_sum", " block_two", " block_note", "block1no", "block_Num", "block_san", "line_net", " block_length", "blockjlabel", " block_none", "object_tun", "block25nom", "block5num", "block1four", "block_set", "blockjlength", "blockingnumber", "_", "block_sum", "blocksnumber", "block00sum", "block64tun", "block1num", "blockvalcommon", "block_begin", " block2number", "block_sem", "block67num", "block00sem", "label33san", "block25set", "line_mn", "objecternum", "label_sem", "blockertun", " block_div", " block_four", "blockaccommon", "blockqnumber", "block_um", " block_number", " block_com", " block2begin", "blockvalun", "block_mn", "block33sum", "objecternam", "block2dim", "lock_no", "block_tun", "blockjnumber", "blockerum", "blockvalsum", " block_common", "block_nam", "block00num", "all", " block_begin", "block5sem", "block_number", "block_div", "blockingnet", "block_note", "object_num", "src", "blockqnum"], "s": ["port", "en", "native", "i", "ish", "rs", "qs", "h", "x", "si", "js", "server", "ps", "share", "spec", "c", "serv", "is", "sv", "sl", "states", "ing", "sy", "south", "m", "self", "bis", "d", "t", "series", "sg", "sync", "fs", "sym", "sup", "g", "cs", "conv", "es", "full", "session", "w", "u", "b", "sf", "ns", "r", "ks", "secondary", "sys", "service", "style", "os", "o", "z", "e", "site", "http", "sb", "features", "j", "f", "less", "services", "sh", "comments", "ses", "input", "l", "a", "sites", "S", "settings", "this", "sq", "styles", "conf", "ss", "request", "ed", "p", "se", "time", "k", "n", "gs", "setup", "xs", "ssl", "side", "ds", "su", "ts", "us", "vs", "y"], "right_cbp": ["right_cbP", "right_cblp", "right_bbp", "right_rbps", "right_rbP", "right_ncpo", "right_cbpo", "right_cbc", "right_cuep", "right_ncP", "right_obbP", "right_crops", "right_rbr", "right_CBp", "right_obbpo", "right_cbpa", "right_CBr", "right_obbp", "right_cuer", "right_cbr", "right_CBps", "right_rbpo", "right_bbr", "right_rbpa", "right_cbps", "right_crop", "right_CBlp", "right_bbP", "right_ncp", "right_bbpa", "right_rbc", "right_cueP", "right_rbp", "right_rblp", "right_ncc", "right_obbc", "right_crolp", "right_cror", "right_cuepa"], "right_is_intra": ["right_is_ntra", "right_is_outra", "right_is_distro", "right_is_indras", "right_is_intla", "right_is_outran", "right_is_pitran", "right_is_pitRA", "right_is_integara", "right_is_outras", "right_is_intras", "right_is_ntro", "right_is_integra", "right_is_intro", "right_is_pitra", "right_is_indla", "right_is_distra", "right_is_indro", "right_is_pitras", "right_is_distla", "right_is_intRA", "right_is_ntran", "right_is_outRA", "right_is_intara", "right_is_integras", "right_is_indra", "right_is_ntRA", "right_is_ntara", "right_is_distras", "right_is_intran", "right_is_ntras", "right_is_pitara", "right_is_ntla", "right_is_integran"], "idx": ["endy", "idexs", "idex", "idv", "idey", " idy", "endv", " idv", "idev", "idy", "idxs", "endxs", "endx", " idxs"], "ttblk": ["mmblk", "mmblck", "mmplks", "ttflk", "mmplk", "ttflks", "ttblks", "ttplk", "ttplck", "ttplks", "mmblks", "mmplw", "mmblw", "ttblck", "ttplw", "mmplck", "ttflck", "ttflw", "ttblw"], "dst": [" dsts", "nsts", " dft", "fsts", " dST", "Dst", " ddest", "lbl", "Dsts", "dsts", "lsts", "nft", "dedST", "dedsts", "Dft", "lst", "fdest", "dbl", "Dbl", "dft", "dedst", "lST", "dST", "nst", "DST", "deddest", "fST", " dbl", "nbl", "fst", "ddest"], "mv": ["fv", "Mv", "mvp", "Mw", "fh", "fvt", "mvs", " mh", " mvs", " mw", "dmvs", "mh", "Mvt", "Mvs", " mvt", "dmw", " mvp", "fvp", "dmv", "Mvp", "mvt", "Mh", "dmh", "mw"]}}
{"project": "FFmpeg", "commit_id": "5afe1d27912be9b643ffb4ddc21f6d920260dbb0", "target": 1, "func": "static int read_packet(AVFormatContext *s, uint8_t *buf, int raw_packet_size, uint8_t **data)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    int len;\n\n\n\n    for(;;) {\n\n        len = ffio_read_indirect(pb, buf, TS_PACKET_SIZE, data);\n\n        if (len != TS_PACKET_SIZE)\n\n            return len < 0 ? len : AVERROR_EOF;\n\n        /* check packet sync byte */\n\n        if ((*data)[0] != 0x47) {\n\n            /* find a new packet start */\n\n            avio_seek(pb, -TS_PACKET_SIZE, SEEK_CUR);\n\n            if (mpegts_resync(s) < 0)\n\n                return AVERROR(EAGAIN);\n\n            else\n\n                continue;\n\n        } else {\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13316, "substitutes": {"s": ["south", "ses", "self", "service", "t", "sg", "bs", "fs", "rs", "a", "utils", "g", "cs", "qs", "settings", "os", "es", "si", "sq", "session", "server", "ps", "ss", "o", "p", "e", "sb", "sf", "b", "f", "gs", "spec", "ns", "c", "parser", "xs", "sc", "ssl", "sci", "sv", "sl", "services", "ds", "sie", "sa", "su", "src", "ls", "ts", "space", "tp", "ctx", "ks"], "buf": ["context", "uc", "bc", "queue", "fd", "cv", "tmp", "rc", "config", "fb", "uf", "buffer", "txt", "fp", "raf", "buff", "br", "bp", "rb", "sb", "tc", "b", "Buffer", "ptr", "bf", "bh", "ab", "cb", "db", "src", "seq", "window", "pad", "ctx"], "raw_packet_size": ["raw_packkt_size", "raw_packet___size", "raw_packet_timeout", "raw_packet_length", "raw_packet___id", "raw_packet_id", "raw_packet___length", "raw_packkt_timeout", "raw_packkt_id", "raw_packet___timeout", "raw_packkt_length"], "data": ["args", "map", "blocks", "format", "slice", "input", "d", "array", "response", "batch", "config", "i", "a", "api", "bytes", "new", "buffer", "raw", "package", "alpha", "size", "ad", "la", "p", "pack", "options", "reader", "length", "result", "parent", "dat", "next", "arr", "Data", "cb", "body", "text", "DATA", "ata", "cache", "empty", "pos", "window", "pad", "abi", "message"], "pb": ["xb", "typ", "bc", "tmp", "pc", "mp", "bb", "vp", "fb", "jp", "uf", "prot", "api", "ub", "pg", "hub", "lp", "pp", "buffer", "fp", "buff", "bp", "pd", "np", "p", "rb", "bm", "pa", "sb", "tc", "wb", "pl", "bf", "gb", "wp", "bh", "ab", "parser", "pm", "bps", "cb", "eb", "PB", "dp", "cp", "cpp", "abb", "db", "lb", "ppa", "tp", "ctx"], "len": ["ln", "en", "rev", "part", "lin", "fd", "_", "fl", "Len", "id", "val", "code", "l", "i", "name", " length", "lc", "dl", "h", "str", "lang", "full", "fn", "dy", "size", "ll", "z", "ind", "e", "fin", "li", "base", "j", "L", "length", "count", "n", "lf", "line", "f", "c", "offset", "nt", "body", "elt", "le", "pos", "no", "num", "el", "span", "in", "err"]}}
{"project": "FFmpeg", "commit_id": "4381bddc9f93da34a44e683bdc4c05c6f061244e", "target": 0, "func": "int ff_parse_sample_rate(unsigned *ret, const char *arg, void *log_ctx)\n\n{\n\n    char *tail;\n\n    double srate = av_strtod(arg, &tail);\n\n    if (*tail || srate < 1 || (int)srate != srate) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Invalid sample rate '%s'\\n\", arg);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    *ret = srate;\n\n    return 0;\n\n}\n", "idx": 13339, "substitutes": {"ret": ["alt", "ft", "rev", "reply", "val", "rs", "gt", "rets", "test", "sr", "status", "det", "lit", "feat", "mem", "fi", "rx", "success", "sb", "ext", "Ret", "result", "ann", "fit", "att", "arr", "re", "rt", "rep", "RET", "seq", "res", "vt", "reg", "len"], "arg": ["word", "args", "call", "amp", "input", "inter", "enc", "arm", "pc", "val", "orig", "name", "g", "ig", "ref", "str", "ace", "loc", "phrase", "var", "ad", "parse", "p", "ag", "match", "ext", "result", "arc", "ax", "inc", "item", "arr", "end", "ac", "argument", "target", "ary", "Arg", "exec", "param", "mac", "ar", "tag", "reg", "addr", "len", "bit", "tick", "err"], "log_ctx": ["log_config", " log_cmp", "logwlc", "logFtx", "log_scope", " log_lc", "log_lc", "logrtx", "logrscope", " log_scope", "logFcontext", " log_context", " log_tx", "logFscope", "logFctx", "log_tx", "logwctx", "log_context", "logrctx", " log_config", "logrcontext", "log_cmp", "logwconfig", "logwcmp"], "tail": ["word", "head", "t", "code", "letter", "gt", "lc", "tails", "align", "test", "weight", "beta", "lp", "tt", "unit", "fat", "limit", "nw", "col", "index", "term", "ll", "ad", "size", "temp", "lt", "ail", "ext", "nil", "tip", "tc", "length", "timeout", "stem", "pull", "offset", "target", "body", "iter", "lead", "tag", "lock", "prefix", "wl", "len", "thread", "tick"]}}
{"project": "qemu", "commit_id": "f678f671ba654d4610f0e43d175c8c1b2fad10df", "target": 1, "func": "static void decode_abs_store(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int32_t op2;\n\n    int32_t r1;\n\n    uint32_t address;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n    address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n    op2 = MASK_OP_ABS_OP2(ctx->opcode);\n\n\n\n    temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n    switch (op2) {\n\n    case OPC2_32_ABS_ST_A:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n    case OPC2_32_ABS_ST_D:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_DA:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        break;\n\n    case OPC2_32_ABS_ST_W:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LESL);\n\n        break;\n\n\n\n    }\n\n    tcg_temp_free(temp);\n\n}\n", "idx": 13347, "substitutes": {"env": ["proc", "en", "ch", "queue", "enc", "gr", "rc", "config", "eu", "def", "req", "conf", "conn", "obj", "loader", "dev", "viron", "exc", "info", "inst", "cb", "ep", "exec", "db", "ev", "ec", "environment", "err"], "ctx": [" context", "context", "ch", "tx", "cam", "pkg", "mc", "bc", "cv", "cm", "ca", "rc", "config", "jp", "pc", "qa", "cc", "sync", "utils", "Context", "cz", "kn", "ci", "cs", "lc", "ctrl", "conv", "sk", "cn", "progress", "cor", "wcs", "cpu", "cmp", "scope", "loc", "conn", "kw", "client", "console", "obj", "grad", "lib", "exc", "cli", "nc", "ck", "tc", "cus", "acl", "cfg", "connection", "c", "cca", "crit", "cu", "voc", "anc", "cas", "sci", "sc", "cmd", "cf", "coll", "cp", "exec", "kb", "vc", "que", "history"], "op2": ["OP1", "hop1", "op3", "oper2", "OP2", "oper1", "op02", "OP4", "hop3", "op1", "oper02", " op4", " op02", "oper4", " op1", "hop4", "OP02", "hop2", "oper3", " op3", "OP3", "op4"], "r1": ["rOne", " r2", "tr61", "rlip", "brOne", "prname", "r7", "err0", "R1", " rone", "r61", "range1", "sr7", "rrname", "rg1", "rangename", " r7", "strname", " rOne", "yrpart", "rup", "rl1", "r0", "err4", "yr7", "err1", "r15", "rgpart", "pr61", "yrone", "r4", "rone", "R0", "rip", "str0", "trname", "pr15", "rr15", "R5", "rlup", "prup", "br0", "rlone", "pr1", " r0", "R3", "ROne", "prip", "sr1", "rgup", "rr1", "rgip", "sr3", "dr4", "r2", "dr0", "str1", "tr15", "rr61", "rname", "rpart", "rg3", "R2", "yr1", "rgone", "sr5", "drOne", " r5", " rname", "errOne", "sr2", " r4", " rpart", "prone", "br1", "yr3", "r5", "r3", "br2", " r3", "range0", "tr1", "dr1"], "address": ["channel", "path", "port", "Address", "context", "location", "tx", "interface", "format", "trace", "array", "code", "memory", "shape", "account", "name", "reference", "buffer", "capacity", "ace", "position", "key", "uri", "value", "output", "element", "instance", "socket", "pointer", "length", "mode", "point", "parent", "padding", "pair", "ip", "number", "add", "route", "holder", "type", "offset", "attribute", "host", "ash", "cache", "prefix", "addr", "alias", "order", "ptr", "index", "message"], "temp": ["tx", "level", "memory", "local", "str", "ace", "model", "loc", "base", "cel", "timeout", "iter", "out", "get", "cp", "make", "stable", "index", "draw", "context", "slice", "mount", "lc", "circ", "storage", "w", "clean", "fake", "pack", "data", "cut", "length", "result", "cont", "exec", "cache", "layout", "stack", "thread", "ptr", "zip", "format", "fd", "config", "private", "current", "perature", "porary", "test", "null", "buffer", "valid", "output", "mix", "tc", "holder", "load", "handle", "font", "cm", "input", "tmp", "ctrl", "ex", "emp", "this", "v", "tem", "buff", "form", "p", "cli", "keep", "pointer", "cu", "write", "Temp", "wrap"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_readdir(void *opaque)\n\n{\n\n    int32_t fid;\n\n    V9fsFidState *fidp;\n\n    ssize_t retval = 0;\n\n    size_t offset = 7;\n\n    uint64_t initial_offset;\n\n    int32_t count;\n\n    uint32_t max_count;\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dqd\", &fid, &initial_offset, &max_count);\n\n\n\n    trace_v9fs_readdir(pdu->tag, pdu->id, fid, initial_offset, max_count);\n\n\n\n    fidp = get_fid(pdu, fid);\n\n    if (fidp == NULL) {\n\n        retval = -EINVAL;\n\n        goto out_nofid;\n\n    }\n\n    if (!fidp->fs.dir) {\n\n        retval = -EINVAL;\n\n        goto out;\n\n    }\n\n    if (initial_offset == 0) {\n\n        v9fs_co_rewinddir(pdu, fidp);\n\n    } else {\n\n        v9fs_co_seekdir(pdu, fidp, initial_offset);\n\n    }\n\n    count = v9fs_do_readdir(pdu, fidp, max_count);\n\n    if (count < 0) {\n\n        retval = count;\n\n        goto out;\n\n    }\n\n    retval = offset;\n\n    retval += pdu_marshal(pdu, offset, \"d\", count);\n\n    retval += count;\n\n    trace_v9fs_readdir_return(pdu->tag, pdu->id, count, retval);\n\nout:\n\n    put_fid(pdu, fidp);\n\nout_nofid:\n\n    complete_pdu(s, pdu, retval);\n\n}\n", "idx": 13357, "substitutes": {"opaque": ["ipaques", "ovonymous", "oppaques", "oppacity", "ovacity", "ipaco", "ovaques", "oponymous", "oppaque", "opac", "ipque", "opaco", "opaques", "OPaco", "ipac", "ipacity", "opacity", "ipaque", " opac", "OPac", " opaco", "OPque", " opque", "opque", "opponymous", "ovaque", "OPaque", "iponymous"], "fid": ["cfid", " fida", "tfids", "fida", "tfid", "affid", "sfids", "sfade", "fids", "cids", "affida", "cade", "rfoid", "fade", "eade", " fname", "fident", " fbid", "fpida", "fcname", "fite", "cfname", "fname", "fcident", "fcida", "fcid", "eite", "rfID", "cfida", "rfid", " fids", "fpid", "rfida", "affbid", " fident", "fpID", "foid", " fID", "tfbid", "fpoid", "fbid", "eids", "sfite", "eid", "tfida", "cite", " foid", "cid", "fID", "cfident", "affids", "sfid"], "fidp": ["fidenper", "faidp", "widr", "fidepe", "fidepa", "fidsp", "fidel", "piddc", "filpe", " fidep", "fridp", "fkeyp", "tfidpe", "fidenpa", "widpr", "widpa", "fidec", "fideP", "fidaP", "fridpa", "fidl", "fbidpi", "tfideper", "fIDp", "piddp", "fuidP", "fiddc", " fideping", "faidl", "fandpi", "tfidepa", "fbitapi", "piddl", "fidenv", "fkeypr", "tfidper", "fuidch", "fuidp", "fIdc", "fidpr", "fidap", "feridpa", "fandp", "fidev", "tfidpa", "fkeyr", "fbidper", " fidsp", " fidch", "filp", "fbitc", "tfidp", "fidu", "fidse", "fiddp", "fIDr", "fidee", "fuidping", "feidpi", "faxc", "fandper", "fsidapi", "fidsc", "fidech", "fidaping", "fidper", "fidc", "fidch", " fidech", " fidpi", "wIDpa", "fixp", " fideP", "fridper", "filpa", " fidapi", "fidpe", "fbidpa", "feridp", "faxp", "wIDr", "fsidp", "fidP", "pidu", "wIDp", "feidp", "fbitp", "feidpa", "fidach", "fidr", " fidP", "fiddl", "pidp", " fidping", "pidl", "feridpi", "filper", "wIDpr", "piddu", "fidpi", "fideping", "fkeypa", "fIde", "faxl", "fidping", " fidse", "fsidpi", "fIdl", "pidc", "fbitpi", "fIDpa", "feridv", "fidv", "fIdp", "widp", "faidc", "feridper", "fixpa", "fidapi", "fidenp", "fIDpr", "fandpa", "fidep", "fidsl", "fridv", " fide", " fidc", "feidper", " fidsl", "fideper", "fbidp", "fiddu", "fridpi", "fixpe", "fsidc", "fidpa", "tfidepe", "feidv", " fidl", "tfidep", "fixper", "faxu", "fide", " fidsc", "faidu"], "initial_offset": ["initial_pos", " initial_size", " initial_ptr", "initial_count", "initial_connection", "minimum_index", " initial_connection", "initialityindex", "initial_ptr", " initial_index", " initial_order", "minimum_offset", " initial_part", "initialityconnection", " initial_entry", "initial_part", "initial_address", "minimum_size", " initial_pos", "initial_entry", "minimum_address", "initialityoffset", " initial_count", "initial_order", "initial_index", "initial_size"], "count": ["call", "ch", "part", "complete", "allow", "cc", "id", "code", "val", "cast", "child", "label", "current", "name", "cond", "weight", "use", "err", "total", "sum", "key", "error", "limit", "col", "size", "ind", "Count", "time", "found", "max", "match", "base", "length", "read", "list", "parent", "skip", "n", "old", "c", "close", "number", "cat", "end", "type", "offset", "file", "now", "text", "process", "all", "write", "cache", "seq", "content", "num", "core", "len", "depth", "index", "start"], "max_count": ["max64length", "max64size", "max64count", "max24offset", "max_limit", "max_size", "max24limit", " max_limit", " max_name", "max_max", " max_length", "max_length", " max_max", "max54limit", "max54offset", " max_offset", "max24count", "max_depth", "max_offset", "max54count", "max64name", " max_size", " max_depth", "max_name"], "pdu": ["plsu", "ccu", "pde", "psu", "Pcu", "opcu", " puu", "fdu", "cdu", "arptu", "arpuu", "ppdu", "pcu", " pru", "opdu", "cpde", "vtu", " pcu", "psuna", "puc", "fru", "apru", "pssu", "cuu", "vdu", "vuu", "arpdu", "cpcu", " ptu", "pptu", "optu", "Pdi", "cde", "fuu", "dsu", "fsu", "funa", "puu", "ddu", "duc", "vde", "cpdi", "pluu", "puna", "cptu", "Ptu", "pluc", "opsu", "fcu", "apdu", " pde", "psru", "pru", "aptu", "apcu", "csu", "cpdu", "Pdu", "ctu", " pdi", "fdi", " puna", "arpde", "ppcu", "ptu", "Pde", "pdi", "duu", "opde", "fde", " psu", "ppru", "psdu", "pldu", "ftu", " puc", "opdi"], "s": ["secondary", "south", "sys", "m", "ses", "d", "sync", "t", "sg", "service", "i", "sym", "a", "g", "S", "settings", "submit", "h", "os", "status", "sets", "js", "si", "scope", "session", "server", "v", "storage", "o", "w", "u", "summary", "p", "e", "instance", "http", "b", "sb", "n", "f", "gs", "spec", "state", "c", "ns", "is", "stats", "ssl", "states", "services", "ops", "r", "us", "uploads", "in", "aws"]}}
{"project": "qemu", "commit_id": "e3e09d87c6e69c2da684d5aacabe3124ebcb6f8e", "target": 0, "func": "uint64_t HELPER(lra)(CPUS390XState *env, uint64_t addr)\n\n{\n\n    CPUState *cs = CPU(s390_env_get_cpu(env));\n\n    uint32_t cc = 0;\n\n    int old_exc = cs->exception_index;\n\n    uint64_t asc = env->psw.mask & PSW_MASK_ASC;\n\n    uint64_t ret;\n\n    int flags;\n\n\n\n    /* XXX incomplete - has more corner cases */\n\n    if (!(env->psw.mask & PSW_MASK_64) && (addr >> 32)) {\n\n        program_interrupt(env, PGM_SPECIAL_OP, 2);\n\n    }\n\n\n\n    cs->exception_index = old_exc;\n\n    if (mmu_translate(env, addr, 0, asc, &ret, &flags)) {\n\n        cc = 3;\n\n    }\n\n    if (cs->exception_index == EXCP_PGM) {\n\n        ret = env->int_pgm_code | 0x80000000;\n\n    } else {\n\n        ret |= addr & ~TARGET_PAGE_MASK;\n\n    }\n\n    cs->exception_index = old_exc;\n\n\n\n    env->cc_op = cc;\n\n    return ret;\n\n}\n", "idx": 13363, "substitutes": {"env": ["forge", "args", "proc", "en", "context", "esp", "bc", "enc", "ea", "cv", "config", "pec", "code", "eu", "eve", "oa", "ah", "utils", "ass", "er", "req", "kernel", "txt", "icer", "init", "scope", "server", "v", "conf", "conn", "np", "console", "obj", "loader", "energy", "e", "net", "viron", "exc", "engine", "exe", "vs", "site", "eng", "ext", "her", "qt", "nc", "Environment", "export", "c", "eni", "shell", "dt", "ne", "osc", "ep", "enos", "cal", "exec", "que", "cache", "ev", "db", "ec", "chal", "environment", "el", "core", "et", "ctx", "esi"], "addr": ["func", "ord", "alt", "proc", "sta", "amp", "amd", "rc", "id", "code", "rs", "oa", "ref", "arg", "ace", "xp", "cmp", "loc", "conn", "ad", "adr", "layer", "size", "arch", "nc", "data", "pointer", "arp", "lag", "result", "address", "ip", "route", "dc", "ac", "offset", "eth", "cmd", "rt", "host", "dd", "mac", "exec", "src", "seq", "dr", "ar", "coord", "pad", "alias", "len", "ptr", "asm"], "cs": ["args", "acs", "sys", "bc", "ys", "sync", "bs", "rc", "cc", "pc", "fs", "ca", "utils", "lc", "CS", "qs", "ci", "sk", "cn", "cms", "wcs", "js", "ace", "Cs", "ps", "conn", "cks", "ck", "ix", "cus", "co", "gs", "spec", "c", "ns", "ics", "cas", "sc", "cf", "ops", "cp", "ds", "vc", "ec", "css", "ls", "ces", "ils", "vs", "ctx", "ks"], "ret": ["func", "pet", "alt", "ft", "rev", "part", "bc", "reply", "rc", "val", "code", "rs", "def", "rets", "fun", "expected", "status", "ref", "arg", "det", "lit", "value", "feat", "pass", "mem", "fi", "match", "data", "ext", "Ret", "result", "lag", "att", "cat", "arr", "offset", "nt", "re", "rt", "get", "RET", "seq", "res", "reg", "cur", "flag", "len", "bit"], "flags": ["codes", "args", "bc", "nl", "rc", "cc", "fs", "rs", "rets", "fun", "fps", "status", "pass", "s", "alls", "f", "lag", "mask", "lf", "bits", "inc", "Flags", "ags", "ops", "seq", "ips", "ls", "mods", "reg", "fts", "rules", "flag", "CC", "len", "vals"]}}
{"project": "qemu", "commit_id": "46181129eac9a56d9a948667282dd03d5015f096", "target": 0, "func": "static int bdrv_check_update_perm(BlockDriverState *bs, uint64_t new_used_perm,\n\n                                  uint64_t new_shared_perm,\n\n                                  BdrvChild *ignore_child, Error **errp)\n\n{\n\n    BdrvChild *c;\n\n    uint64_t cumulative_perms = new_used_perm;\n\n    uint64_t cumulative_shared_perms = new_shared_perm;\n\n\n\n    /* There is no reason why anyone couldn't tolerate write_unchanged */\n\n    assert(new_shared_perm & BLK_PERM_WRITE_UNCHANGED);\n\n\n\n    QLIST_FOREACH(c, &bs->parents, next_parent) {\n\n        if (c == ignore_child) {\n\n            continue;\n\n        }\n\n\n\n        if ((new_used_perm & c->shared_perm) != new_used_perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(new_used_perm & ~c->shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which does not \"\n\n                             \"allow '%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        if ((c->perm & new_shared_perm) != c->perm) {\n\n            char *user = bdrv_child_user_desc(c);\n\n            char *perm_names = bdrv_perm_names(c->perm & ~new_shared_perm);\n\n            error_setg(errp, \"Conflicts with use by %s as '%s', which uses \"\n\n                             \"'%s' on %s\",\n\n                       user, c->name, perm_names, bdrv_get_node_name(c->bs));\n\n            g_free(user);\n\n            g_free(perm_names);\n\n            return -EPERM;\n\n        }\n\n\n\n        cumulative_perms |= c->perm;\n\n        cumulative_shared_perms &= c->shared_perm;\n\n    }\n\n\n\n    return bdrv_check_perm(bs, cumulative_perms, cumulative_shared_perms, errp);\n\n}\n", "idx": 13365, "substitutes": {"bs": ["sys", "blocks", "ses", "bid", "root", "bc", "as", "bin", "sync", "BS", "fs", "ins", "bb", "fb", "rs", "cs", "fps", "os", "bytes", "null", "js", "ps", "ss", "bp", "lib", "obj", "ms", "ba", "bot", "s", "pb", "vs", "b", "sb", "base", "banks", "cus", "gb", "gs", "bits", "ab", "ns", "url", "bps", "is", "ac", "cb", "bis", "eb", "loop", "bas", "bes", "bi", "ds", "db", "ls", "css", "bos", "lb", "res", "bl", "iss", "ctx"], "new_used_perm": ["new_usedlyper", "new_used_per", "new_used_req", "new_used__per", "new_used_mission", "new_used_mode", "new_use_ptr", "new_usedlymode", "new_use_admin", "new_shared_per", "new_usedlyperm", "new_use_mode", "new_use_perm", "new_used27spec", "new_used27per", "new_used_ptr", "new_used__perm", "new_used_spec", "new_shared_mission", "new_needed_priv", "new_usedalptr", "new_usedalperm", "new_usedlyadmin", "new_usedalreq", "new_used_mod", "new_used__mode", "new_usedamperm", "new_used27perm", "new_use_req", "new_used_admin", "new_use_spec", "new_usedamper", "new_usedammission", "new_needed_per", "new_used__admin", "new_used_priv", "new_use_per", "new_needed_mod", "new_needed_perm", "new_usedalper"], "new_shared_perm": ["new_used_per", "new_exclusive_attr", "new_shared1mission", "new_shared_priv", "new_exclusive_perm", "new_used_mission", "new_sharedthemask", "new_owned_mask", "new_shared1perm", "new_shared_per", "new_exclusive_per", "new_ared_priv", "new_shared_attr", "new_shared1per", "new_owned_per", "new_sharedtheper", "new_shared_mission", "new_share_per", "new_share_perm", "new_shared_acl", "new_ared_perm", "new_owned_perm", "new_ared_per", "new_shared1priv", "new_ared_acl", "new_sharedtheperm", "new_share_priv", "new_used_priv", "new_shared_mask"], "ignore_child": [" ignore_children", "ignore_children", " ignore_group", " ignore_parent", "ignore_parent", "ignore_group"], "errp": ["nerP", "errvp", "rrpc", "erfp", "rrfp", "erpre", "erpc", "errorp", " errc", "rrpre", " errpre", "rrp", "ervp", "errorfp", "errfp", "errc", "nerfp", "errP", "erc", " errfp", " errP", "erp", "nerp", "errpre", "nervp", "errorpc", "Erp", "errpc", " errpc", "errorc", "Erpre", "Erfp", " errvp", "erP", "Erpc"], "c": ["mc", "i", "C", "child", "h", "cmp", "ct", "rec", "sc", "cp", "ec", "fc", "in", "call", "m", "self", "d", "t", "rc", "cc", "or", "lc", "cs", "g", "cn", "con", "client", "w", "cd", "u", "s", "b", "anc", "ce", "r", "exec", "cache", "xc", "ch", "ca", "config", "pc", "current", "ci", "cy", "o", "e", "nc", "co", "tc", "f", "ac", "cf", "icc", "ctx", "cm", "uc", "enc", "l", "code", "ctrl", "v", "chain", "cr", "col", "oc", "p", "k", "n", "parent", "cu", "dc", "ic", "coll", "vc", "content"], "user": ["date", "word", "users", "path", "device", "bug", "root", "human", "id", "up", "object", "me", "home", "name", "manager", "public", "use", "uu", "module", "project", "person", "full", "sum", "by", "key", "member", "valid", "job", "client", "pass", "group", "role", "u", "plugin", "ee", "time", "resource", "ver", "match", "base", "used", "from", "usa", "line", "custom", "parent", "url", "USER", "type", "creator", "rule", "author", "field", "um", "User", "lock", "usr", "post", "username", "uid"], "perm_names": ["permSsettings", "perm9objects", "filfnames", "permNobjects", "mission_names", "missionPns", "per_names", "fil_names", "perm_ops", "fp_als", "permSops", "per_objects", "permSnames", "fil_ames", "filfdes", "fp_values", "mission_ns", "fp_params", "permPparents", "fil_keys", "perm_keys", "mission_parents", "perm_objects", "permFnames", "per_ops", "permNname", "mission_options", "fpNnames", "permPnames", "perm_parents", "permGns", "perm_options", "perm9roots", "permFname", "perm_als", "fpNname", "fil_des", "perm9name", "permxobjects", "permFobjects", "permxroots", "permPns", "perm_settings", "fpNparams", "per_name", "filfames", "per_roots", "permNnames", "permGparents", "permfnames", "permFparams", "perm_roots", "permxname", "permGoptions", "missionPoptions", "perm9names", "permFops", "perm_params", "permxnames", "missionPnames", "perm_locks", "perm_ns", "permGnames", "fp_names", "perm_des", "fp_locks", "permfames", "permfkeys", "perm_values", "fpNobjects", "permPoptions", "filfkeys", "missionPparents", "per_settings", "permFsettings", "perm_name", "permNparams", "permSname", "fp_objects", "perm_ames", "permfdes", "fp_name"]}}
{"project": "qemu", "commit_id": "810f49b56a5d0cd6848856af51d3093ae9adc7b1", "target": 0, "func": "static void monitor_protocol_emitter(Monitor *mon, QObject *data)\n\n{\n\n    QDict *qmp;\n\n\n\n    qmp = qdict_new();\n\n\n\n    if (!monitor_has_error(mon)) {\n\n        /* success response */\n\n        if (data) {\n\n            assert(qobject_type(data) == QTYPE_QDICT);\n\n            qobject_incref(data);\n\n            qdict_put_obj(qmp, \"return\", data);\n\n        } else {\n\n            /* return an empty QDict by default */\n\n            qdict_put(qmp, \"return\", qdict_new());\n\n        }\n\n    } else {\n\n        /* error response */\n\n        qdict_put(mon->error->error, \"desc\", qerror_human(mon->error));\n\n        qdict_put(qmp, \"error\", mon->error->error);\n\n        QINCREF(mon->error->error);\n\n        QDECREF(mon->error);\n\n        mon->error = NULL;\n\n    }\n\n\n\n    if (mon->mc->id) {\n\n        qdict_put_obj(qmp, \"id\", mon->mc->id);\n\n        mon->mc->id = NULL;\n\n    }\n\n\n\n    monitor_json_emitter(mon, QOBJECT(qmp));\n\n    QDECREF(qmp);\n\n}\n", "idx": 13366, "substitutes": {"mon": ["date", "channel", "m", "mc", "meter", "Mon", "po", "part", "wm", "on", "bean", "chron", "un", "month", "connection", "mail", "wan", "manager", "tom", "mn", "user", "module", "plan", "met", "con", "mm", "method", "unit", "pid", "master", "dog", "key", "member", "conn", "col", "an", "mem", "mer", "mun", "mor", "nan", "atom", "plugin", "http", "mi", "monitor", "stat", "mo", "ann", "pm", "block", "MON", "pin", "bo", "don", "mag", "kin", "man", "demon", "com", "den", "lock", "num", "run", "dom", "wat", "mand", "mu", "message"], "data": ["ada", "map", "database", "record", "partial", "done", "part", "complete", "input", "xml", "d", "response", "array", "config", "val", "object", "da", "a", "api", "money", "missing", "module", "model", "raw", "valid", "value", "package", "meta", "o", "obj", "metadata", "params", "media", "p", "ad", "dev", "resource", "info", "options", "dict", "base", "monitor", "result", "parent", "dat", "none", "json", "number", "Data", "type", "body", "results", "change", "DATA", "dd", "cache", "empty", "python", "message"], "qmp": ["workmm", "qproc", "qumb", "qaMP", " qcmp", "quemm", "quesup", " qproc", "quproc", "aymp", "qsup", "qump", "workmb", " qcp", "qufp", "Qcomp", " qsup", " qpp", "quph", "workep", "qfp", "qap", "queomp", "quepac", "sqph", "sqpac", " qMP", "qcop", "qep", "quecop", " qomp", "qumt", "Qmm", "qcomp", "sqmp", "workcp", "qupar", "ayph", "qmb", "qMP", "quomp", "qusup", "workomp", "chmp", "qcp", "qucop", "qacomp", "workmp", "aypar", "qucmp", "quemp", "qucp", "qpac", "QMP", "Qmp", "quemb", "qamm", "quefp", "sqmt", "workpp", "workap", " qap", " qfp", "qomp", " qcomp", "qumm", "workcmp", "aymt", "sqcop", "qpar", "quep", "qcmp", "qmt", " qmb", "sqomp", "qpp", "qph", "workproc", "sqpar", "chomp", "quap", " qmm", "qupp", "qupac", "chep", "qmm", "chmm", "qamp"]}}
{"project": "FFmpeg", "commit_id": "3176217c60ca7828712985092d9102d331ea4f3d", "target": 0, "func": "static inline int decode_vui_parameters(H264Context *h, SPS *sps)\n\n{\n\n    int aspect_ratio_info_present_flag;\n\n    unsigned int aspect_ratio_idc;\n\n\n\n    aspect_ratio_info_present_flag = get_bits1(&h->gb);\n\n\n\n    if (aspect_ratio_info_present_flag) {\n\n        aspect_ratio_idc = get_bits(&h->gb, 8);\n\n        if (aspect_ratio_idc == EXTENDED_SAR) {\n\n            sps->sar.num = get_bits(&h->gb, 16);\n\n            sps->sar.den = get_bits(&h->gb, 16);\n\n        } else if (aspect_ratio_idc < FF_ARRAY_ELEMS(pixel_aspect)) {\n\n            sps->sar = pixel_aspect[aspect_ratio_idc];\n\n        } else {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"illegal aspect ratio\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        sps->sar.num =\n\n        sps->sar.den = 0;\n\n    }\n\n\n\n    if (get_bits1(&h->gb))      /* overscan_info_present_flag */\n\n        get_bits1(&h->gb);      /* overscan_appropriate_flag */\n\n\n\n    sps->video_signal_type_present_flag = get_bits1(&h->gb);\n\n    if (sps->video_signal_type_present_flag) {\n\n        get_bits(&h->gb, 3);                 /* video_format */\n\n        sps->full_range = get_bits1(&h->gb); /* video_full_range_flag */\n\n\n\n        sps->colour_description_present_flag = get_bits1(&h->gb);\n\n        if (sps->colour_description_present_flag) {\n\n            sps->color_primaries = get_bits(&h->gb, 8); /* colour_primaries */\n\n            sps->color_trc       = get_bits(&h->gb, 8); /* transfer_characteristics */\n\n            sps->colorspace      = get_bits(&h->gb, 8); /* matrix_coefficients */\n\n            if (sps->color_primaries >= AVCOL_PRI_NB)\n\n                sps->color_primaries = AVCOL_PRI_UNSPECIFIED;\n\n            if (sps->color_trc >= AVCOL_TRC_NB)\n\n                sps->color_trc = AVCOL_TRC_UNSPECIFIED;\n\n            if (sps->colorspace >= AVCOL_SPC_NB)\n\n                sps->colorspace = AVCOL_SPC_UNSPECIFIED;\n\n        }\n\n    }\n\n\n\n    /* chroma_location_info_present_flag */\n\n    if (get_bits1(&h->gb)) {\n\n        /* chroma_sample_location_type_top_field */\n\n        h->avctx->chroma_sample_location = get_ue_golomb(&h->gb) + 1;\n\n        get_ue_golomb(&h->gb);  /* chroma_sample_location_type_bottom_field */\n\n    }\n\n\n\n    sps->timing_info_present_flag = get_bits1(&h->gb);\n\n    if (sps->timing_info_present_flag) {\n\n        sps->num_units_in_tick = get_bits_long(&h->gb, 32);\n\n        sps->time_scale        = get_bits_long(&h->gb, 32);\n\n        if (!sps->num_units_in_tick || !sps->time_scale) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"time_scale/num_units_in_tick invalid or unsupported (%\"PRIu32\"/%\"PRIu32\")\\n\",\n\n                   sps->time_scale, sps->num_units_in_tick);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sps->fixed_frame_rate_flag = get_bits1(&h->gb);\n\n    }\n\n\n\n    sps->nal_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->nal_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    sps->vcl_hrd_parameters_present_flag = get_bits1(&h->gb);\n\n    if (sps->vcl_hrd_parameters_present_flag)\n\n        if (decode_hrd_parameters(h, sps) < 0)\n\n            return AVERROR_INVALIDDATA;\n\n    if (sps->nal_hrd_parameters_present_flag ||\n\n        sps->vcl_hrd_parameters_present_flag)\n\n        get_bits1(&h->gb);     /* low_delay_hrd_flag */\n\n    sps->pic_struct_present_flag = get_bits1(&h->gb);\n\n\n\n    sps->bitstream_restriction_flag = get_bits1(&h->gb);\n\n    if (sps->bitstream_restriction_flag) {\n\n        get_bits1(&h->gb);     /* motion_vectors_over_pic_boundaries_flag */\n\n        get_ue_golomb(&h->gb); /* max_bytes_per_pic_denom */\n\n        get_ue_golomb(&h->gb); /* max_bits_per_mb_denom */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_horizontal */\n\n        get_ue_golomb(&h->gb); /* log2_max_mv_length_vertical */\n\n        sps->num_reorder_frames = get_ue_golomb(&h->gb);\n\n        get_ue_golomb(&h->gb); /*max_dec_frame_buffering*/\n\n\n\n        if (get_bits_left(&h->gb) < 0) {\n\n            sps->num_reorder_frames         = 0;\n\n            sps->bitstream_restriction_flag = 0;\n\n        }\n\n\n\n        if (sps->num_reorder_frames > 16U\n\n            /* max_dec_frame_buffering || max_dec_frame_buffering > 16 */) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Clipping illegal num_reorder_frames %d\\n\",\n\n                   sps->num_reorder_frames);\n\n            sps->num_reorder_frames = 16;\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n    if (get_bits_left(&h->gb) < 0) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"Overread VUI by %d bits\\n\", -get_bits_left(&h->gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13388, "substitutes": {"h": ["hi", "head", "m", "ch", "hp", "hl", "ha", "enh", "d", "FH", "t", "oh", "hr", "l", "i", "ah", "g", "hs", "x", "gh", "hash", "v", "rh", "kh", "uh", "o", "w", "hh", "ul", "u", "p", "e", "s", "he", "http", "k", "b", "f", "th", "hm", "bh", "c", "ph", "ht", "q", "hand", "r", "H", "sh", "hd", "host", "zh", "history", "him", "esh", "hist", "beh", "header", "hw", "ctx"], "sps": ["unsips", "egs", "scheples", "tsops", "dsops", " spe", "asops", "ansops", "ansips", "asips", "mseps", "tseps", "eps", "srs", "sops", "scheps", "dsps", "lps", "hpps", "sols", "sms", "wspe", "dspps", "ansrs", "lpe", "sinples", "gpps", "ksports", "spp", "eops", "esips", "scs", "pspps", "pseps", "spt", "lsips", "asports", "lspps", "psops", "sips", "anspps", " sms", " sapes", "osips", "msips", "Spp", "tspps", "ispt", " spt", "aspos", " sops", " srs", "jsips", "lseps", "isPS", "wseps", "sapes", "anscs", "jsps", "asrs", " scs", "psports", "lspe", "psips", "tsports", "eseps", "osps", "spe", "wsips", " spps", "sls", "lips", "fseps", "sports", " sbs", "setsples", "msps", "unspe", "tspos", "lports", "sks", "kspps", " spp", "sbs", "isps", "pspos", " sks", "setsols", "pops", "psls", "asps", " sPS", "sPS", "sss", "schepp", "pps", "ests", "unsps", "esps", "setsps", "gps", "ksps", "msts", "tsps", "sgs", "ospps", "dsms", "spos", "psgs", "seps", "gips", "wsps", "Sps", "hps", "lscs", "hgs", "unseps", "ppps", "Spt", " seps", "setspp", "sinps", "ansps", "epps", "fsps", " sports", "ispp", "aspps", " sss", "fsks", "osss", "SPS", "ksips", "peps", "psks", " sls", "fsls", "jspe", "scheols", "jsports", "spps", " sips", "asbs", "anseps", "hops", "sinpp", "aseps", "osapes", "lsps", "psps", "sples", "osports", "gports", "sinols", "sts"], "aspect_ratio_info_present_flag": ["aspect_ratio_info_presentingflag", "aspect_ratio_info_present_count", "aspect_ratio_info_valid_flag", "aspect_ratio_info_valid_count", "aspect_ratio_info_presentingflags", "aspect_ratio_info_present_band", "aspect_ratio_info_presentingcount", "aspect_ratio_info_valid_band", "aspect_ratio_info_show_flag", "aspect_ratio_info_present_bit", "aspect_ratio_info_present_flags", "aspect_ratio_info_show_flags", "aspect_ratio_info_valid_bit", "aspect_ratio_info_show_count"], "aspect_ratio_idc": ["aspect_ratio_idsn", "aspect_ratio_Idx", "aspect_ratio__idee", "aspect_ratio_deff", "aspect_ratio_idci", "aspect_ratio_cdcs", "aspect_ratio__idec", "aspect_ratio_idex", "aspect_ratio__ide", "aspect_ratio_idsx", "aspect_ratio_idn", "aspect_ratio_bidc", "aspect_ratio_cdx", "aspect_ratio_cdc", "aspect_ratio_idse", "aspect_ratio_idf", "aspect_ratio__idef", "aspect_ratio_idcs", "aspect_ratio__idci", "aspect_ratio_idef", "aspect_ratio_defc", "aspect_ratio_idscs", "aspect_ratio__ideci", "aspect_ratio__idf", "aspect_ratio_defn", "aspect_ratio_ider", "aspect_ratio_idsc", "aspect_ratio_ideci", "aspect_ratio_bidr", "aspect_ratio_idec", "aspect_ratio_idee", "aspect_ratio_idx", "aspect_ratio_bidx", "aspect_ratio_Idf", "aspect_ratio_idr", "aspect_ratio_ide", "aspect_ratio_defci", "aspect_ratio_bidci", "aspect_ratio_Idc", "aspect_ratio_cdf", "aspect_ratio_idsci", "aspect_ratio_idsf", "aspect_ratio_Idn", "aspect_ratio_Ide", "aspect_ratio__idc", "aspect_ratio_Idci"]}}
{"project": "qemu", "commit_id": "61007b316cd71ee7333ff7a0a749a8949527575f", "target": 0, "func": "int bdrv_write_compressed(BlockDriverState *bs, int64_t sector_num,\n\n                          const uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    int ret;\n\n\n\n    if (!drv) {\n\n        return -ENOMEDIUM;\n\n    }\n\n    if (!drv->bdrv_write_compressed) {\n\n        return -ENOTSUP;\n\n    }\n\n    ret = bdrv_check_request(bs, sector_num, nb_sectors);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    assert(QLIST_EMPTY(&bs->dirty_bitmaps));\n\n\n\n    return drv->bdrv_write_compressed(bs, sector_num, buf, nb_sectors);\n\n}\n", "idx": 13415, "substitutes": {"bs": ["bt", "ses", "blocks", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "sync", "bb", "fb", "rs", "cs", "fps", "os", "bytes", "bus", "js", "ras", "ps", "ss", "obj", "obs", "pb", "vs", "b", "sb", "base", "bing", "nas", "banks", "gs", "bits", "ab", "bh", "ns", "bu", "cb", "bes", "bas", "ds", "db", "cache", "ls", "css", "lb", "bos", "ubs", "las", "bl", "iss", "abi", "ks"], "sector_num": ["sector__number", " sector_id", "sector_name", "sector_number", " sector_count", " sector_number", " sector_name", "sector_count", " sector_Num", "sector__num", "sector_id", "sector_Num", "sector__count"], "buf": ["port", "vec", "bin", "uc", "bc", "queue", "fd", "array", "cv", "batch", "config", "fb", "uf", "ref", "buffer", "bus", "bag", "br", "buff", "rb", "pb", "data", "b", "base", "Buffer", "fab", "ab", "block", "offset", "cb", "cas", "que", "src", "seq", "num", "len", "ctx", "alloc"], "nb_sectors": ["nb_serctors", "nb_belements", "nb_secgments", "nb_seapters", "nb_tectors", "nb_serkers", "nb_segments", "nb_secs", "nb_teapters", "nb_sekers", "nb_secctors", "nb_veapters", "nb_sergments", "nb_seccs", "nb_bectors", "nb_serlements", "nb_vecs", "nb_begments", "nb_becs", "nb_tegments", "nb_velements", "nb_seclements", "nb_tekers", "nb_vectors", "nb_vekers", "nb_vegments", "nb_telements", "nb_selements", "nb_secapters"], "drv": [" drb", "drver", "prver", "DRc", "rrf", "Drp", "dric", "driV", "driv", "hrc", "rrb", "drV", "Drb", "Drf", " drc", " drver", "Drv", " drf", "rrv", "DRv", "drb", " drw", "DRV", "prp", "hrb", " drp", "drw", "DRf", "Drc", "drif", "hrw", "drf", "prf", "hrf", "hrv", "drc", "prv", "rrw", " drV", "drp", "Drver", "hrV", "DrV"], "ret": ["pet", "alt", "en", "ft", "let", "reply", "art", "rc", "tr", "val", "code", "back", "def", "rets", "fun", "req", "sr", "ref", "det", "arg", "lit", "valid", "error", "value", "obj", "mt", "fin", "rb", "success", "base", "Ret", "bf", "result", "fit", "att", "reset", "next", "cat", "ry", " Ret", "nt", "re", "rt", "fail", "rep", "pat", "RET", "al", "res", "reg", "flag", "len", "bit", "err"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int usb_host_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHostDevice *s = DO_UPCAST(USBHostDevice, dev, dev);\n\n    struct usbdevfs_urb *urb;\n\n    AsyncURB *aurb;\n\n    int ret;\n\n\n\n    /*\n\n     * Process certain standard device requests.\n\n     * These are infrequent and are processed synchronously.\n\n     */\n\n\n\n    /* Note request is (bRequestType << 8) | bRequest */\n\n    trace_usb_host_req_control(s->bus_num, s->addr, request, value, index);\n\n\n\n    switch (request) {\n\n    case DeviceOutRequest | USB_REQ_SET_ADDRESS:\n\n        return usb_host_set_address(s, value);\n\n\n\n    case DeviceOutRequest | USB_REQ_SET_CONFIGURATION:\n\n        return usb_host_set_config(s, value & 0xff);\n\n\n\n    case InterfaceOutRequest | USB_REQ_SET_INTERFACE:\n\n        return usb_host_set_interface(s, index, value);\n\n    }\n\n\n\n    /* The rest are asynchronous */\n\n\n\n    if (length > sizeof(dev->data_buf)) {\n\n        fprintf(stderr, \"husb: ctrl buffer too small (%d > %zu)\\n\",\n\n                length, sizeof(dev->data_buf));\n\n        return USB_RET_STALL;\n\n    }\n\n\n\n    aurb = async_alloc(s);\n\n    aurb->packet = p;\n\n\n\n    /*\n\n     * Setup ctrl transfer.\n\n     *\n\n     * s->ctrl is laid out such that data buffer immediately follows\n\n     * 'req' struct which is exactly what usbdevfs expects.\n\n     */\n\n    urb = &aurb->urb;\n\n\n\n    urb->type     = USBDEVFS_URB_TYPE_CONTROL;\n\n    urb->endpoint = p->devep;\n\n\n\n    urb->buffer        = &dev->setup_buf;\n\n    urb->buffer_length = length + 8;\n\n\n\n    urb->usercontext = s;\n\n\n\n    trace_usb_host_urb_submit(s->bus_num, s->addr, aurb,\n\n                              urb->buffer_length, aurb->more);\n\n    ret = ioctl(s->fd, USBDEVFS_SUBMITURB, urb);\n\n\n\n    DPRINTF(\"husb: submit ctrl. len %u aurb %p\\n\", urb->buffer_length, aurb);\n\n\n\n    if (ret < 0) {\n\n        DPRINTF(\"husb: submit failed. errno %d\\n\", errno);\n\n        async_free(aurb);\n\n\n\n        switch(errno) {\n\n        case ETIMEDOUT:\n\n            return USB_RET_NAK;\n\n        case EPIPE:\n\n        default:\n\n            return USB_RET_STALL;\n\n        }\n\n    }\n\n\n\n    return USB_RET_ASYNC;\n\n}\n", "idx": 13426, "substitutes": {"dev": ["plug", "bug", "device", "proc", "ch", "self", "d", "dist", "priv", "die", "home", " device", "def", "g", "req", "ve", "serial", "new", "di", "devices", "h", "user", "Dev", "mod", "bus", "comment", "valid", "v", "app", "conf", "pu", "error", "av", "gd", "de", "w", "pub", "temp", "pack", "info", "engine", "sd", "driver", "f", "dom", "diff", "block", "dem", "DEV", "md", "cmd", "pro", "ds", "dd", "ev", "dn", "debug", "dm", "hw"], "p": ["proc", "m", "d", "t", "pc", "i", "vp", "pre", "g", "sp", "h", "py", "pp", "fp", "v", "o", "np", "pd", "w", "u", "e", "plugin", "pb", "b", "j", "f", "ip", "c", "q", "dp", "r", "cp", "P", "tp", "gp"], "request": ["device", "path", "head", " Request", "insert", "complete", "input", "response", "art", "config", "id", "received", "object", "current", "name", "req", "hello", "event", "effect", "use", "buffer", "method", "Request", "frame", "access", "version", "instance", "time", "resource", "info", "rx", "ext", "mode", "f", "result", "address", "query", "pair", "first", "pull", "type", "attribute", "q", "forward", "command", "initial", "author", "param", "r", "rest", "push", "rf", "header", "message"], "value": ["device", "port", "input", "response", "config", "id", "val", "search", "current", "name", "range", "values", "section", "null", "description", "x", "buffer", "update", "position", "total", "key", "server", "v", "localhost", "valid", "set", "element", "view", "size", "version", "time", "Value", "info", "property", "flow", "store", "address", "json", "number", "start", "end", "type", "function", "change", "write", "command", "initial", "fee", "content", "off", "max", "message"], "index": ["Index", "connect", "slice", "input", "config", "id", "val", "i", "level", "name", "weight", "x", "position", "loc", "error", "key", "localhost", "access", "view", "size", "ind", "active", "info", "match", "base", "read", "point", "address", "query", "inc", "diff", "end", "type", "offset", "initial", "field", "pos", "tail", "len", "start"], "length": ["zip", "path", "slice", "thin", "val", "l", "level", "style", "shape", "name", "weight", "section", "buffer", "sequence", "full", "position", "total", "loc", "limit", "failed", "size", "time", "info", "max", "count", "Length", "f", "padding", "number", "block", "end", "type", "offset", "ph", "body", "text", "load", "angle", "duration", "empty", "off", "lock", "delay", "tail", "len"], "data": ["transfer", "input", "d", "response", "array", "config", "def", "send", "new", "raw", "frame", "buff", "info", "pack", "du", "base", "read", "result", "block", "feed", "Data", "DATA", "load", "command", "fee", "push", "message"], "s": ["device", "rs", "qs", "h", "new", "si", "js", "server", "ps", "sim", "spec", "c", "serv", "is", "sc", "sv", "sl", "states", "south", "m", "self", "bis", "d", "t", "sync", "sg", "ins", "sym", "g", "cs", "es", "session", "storage", "w", "an", "u", "b", "ns", "r", "ks", "sys", "service", "details", "sp", "hs", "os", "sets", "o", "e", "http", "sd", "sb", "j", "f", "services", "sh", "ls", "ses", "as", "l", "S", "its", "sq", "v", "conf", "ss", "se", "ions", "n", "gs", "ssl", "ds", "su", "us", "ts"], "urb": ["rib", "interface", "eur", "report", "aim", "br", "force", "rb", "verb", "fab", "usb", "flow", "ocr", "cb", "attr", "eb", "deb", "abb", "uff", "utter", "bb", "obb", "uf", "urban", "lc", "api", "air", "erg", "editor", "adr", "img", "b", "ann", "url", "feed", "ur", "uv", "um", "qi", "transfer", "ch", "config", "abuse", "uber", "fb", "account", "ub", "hub", "nb", "buffer", "raf", "rub", "abl", "element", "aff", "atom", "f", "gb", "address", "ulp", "udi", "rob", "aud", "arb", "ob", "orb", "uri", "buff", "cr", "plugin", "pb", "buf", "ab", "urt", "aur", "ell", "irm", "emb"], "aurb": ["iarf", "iarb", "turab", "aurd", "iarB", "urab", "turbs", "eurp", "rumb", "auc", "ervp", "turB", "urc", "hra", "rard", "iarbs", "urchab", "rarb", "igrB", "urchr", "aub", "aurib", "aurab", "eurc", "urr", "urchB", "ervB", "eurr", "urib", "iarp", "igrb", "urchb", "URb", "aup", "eurab", "erva", "ura", "ervb", "igrd", "URbs", "rumr", "URB", "eurb", "aurbs", "acerb", "URf", "hrab", "ervc", "iarab", "urd", "urB", "rumab", "turr", "aurr", "acerr", "iarr", "turb", "eura", "turp", "igrib", "acerB", "aua", "urp", "eurB", "aurf", "acerab", "aurB", "hrB", "turf", "aura", "hrb", "rumB", "ervr", "aurp", "aur", "aurc", "rarib", "igrab", "igra", "rara"], "ret": ["alt", "let", "rev", "reply", "sat", "rc", "id", "val", "code", "back", "orig", "rets", "fun", "ref", "arg", "det", "full", "lit", "hash", "valid", "obj", "pass", "fin", "match", "success", "Ret", "bit", "count", "result", " RET", "att", "url", "arr", "eth", "nt", "re", "rt", "resp", "pat", "RET", "res", "reg", "num", "no", "len", "opt", "red"]}}
{"project": "FFmpeg", "commit_id": "6abc56e892c2c2500d1fc2698fa6d580b72f721b", "target": 1, "func": "static int dshow_read_header(AVFormatContext *avctx)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IGraphBuilder *graph = NULL;\n\n    ICreateDevEnum *devenum = NULL;\n\n    IMediaControl *control = NULL;\n\n    IMediaEvent *media_event = NULL;\n\n    HANDLE media_event_handle;\n\n    HANDLE proc;\n\n    int ret = AVERROR(EIO);\n\n    int r;\n\n\n\n    CoInitialize(0);\n\n\n\n    if (!ctx->list_devices && !parse_device_name(avctx)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Malformed dshow input string.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ctx->video_codec_id = avctx->video_codec_id ? avctx->video_codec_id\n\n                                                : AV_CODEC_ID_RAWVIDEO;\n\n    if (ctx->pixel_format != AV_PIX_FMT_NONE) {\n\n        if (ctx->video_codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Pixel format may only be set when \"\n\n                              \"video codec is not set or set to rawvideo\\n\");\n\n            ret = AVERROR(EINVAL);\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->framerate) {\n\n        r = av_parse_video_rate(&ctx->requested_framerate, ctx->framerate);\n\n        if (r < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not parse framerate '%s'.\\n\", ctx->framerate);\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    r = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_IGraphBuilder, (void **) &graph);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create capture graph.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->graph = graph;\n\n\n\n    r = CoCreateInstance(&CLSID_SystemDeviceEnum, NULL, CLSCTX_INPROC_SERVER,\n\n                         &IID_ICreateDevEnum, (void **) &devenum);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate system devices.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->list_devices) {\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow video devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, VideoDevice, NULL);\n\n        av_log(avctx, AV_LOG_INFO, \"DirectShow audio devices\\n\");\n\n        dshow_cycle_devices(avctx, devenum, AudioDevice, NULL);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n    if (ctx->list_options) {\n\n        if (ctx->device_name[VideoDevice])\n\n            dshow_list_device_options(avctx, devenum, VideoDevice);\n\n        if (ctx->device_name[AudioDevice])\n\n            dshow_list_device_options(avctx, devenum, AudioDevice);\n\n        ret = AVERROR_EXIT;\n\n        goto error;\n\n    }\n\n\n\n    if (ctx->device_name[VideoDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, VideoDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, VideoDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n    if (ctx->device_name[AudioDevice]) {\n\n        if ((r = dshow_open_device(avctx, devenum, AudioDevice)) < 0 ||\n\n            (r = dshow_add_device(avctx, AudioDevice)) < 0) {\n\n            ret = r;\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    ctx->mutex = CreateMutex(NULL, 0, NULL);\n\n    if (!ctx->mutex) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Mutex\\n\");\n\n        goto error;\n\n    }\n\n    ctx->event[1] = CreateEvent(NULL, 1, 0, NULL);\n\n    if (!ctx->event[1]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not create Event\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaControl, (void **) &control);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media control.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->control = control;\n\n\n\n    r = IGraphBuilder_QueryInterface(graph, &IID_IMediaEvent, (void **) &media_event);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event.\\n\");\n\n        goto error;\n\n    }\n\n    ctx->media_event = media_event;\n\n\n\n    r = IMediaEvent_GetEventHandle(media_event, (void *) &media_event_handle);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not get media event handle.\\n\");\n\n        goto error;\n\n    }\n\n    proc = GetCurrentProcess();\n\n    r = DuplicateHandle(proc, media_event_handle, proc, &ctx->event[0],\n\n                        0, 0, DUPLICATE_SAME_ACCESS);\n\n    if (!r) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not duplicate media event handle.\\n\");\n\n        goto error;\n\n    }\n\n\n\n    r = IMediaControl_Run(control);\n\n    if (r == S_FALSE) {\n\n        OAFilterState pfs;\n\n        r = IMediaControl_GetState(control, 0, &pfs);\n\n    }\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not run filter\\n\");\n\n        goto error;\n\n    }\n\n\n\n    ret = 0;\n\n\n\nerror:\n\n\n\n    if (devenum)\n\n        ICreateDevEnum_Release(devenum);\n\n\n\n    if (ret < 0)\n\n        dshow_read_close(avctx);\n\n\n\n    return ret;\n\n}\n", "idx": 13429, "substitutes": {"avctx": ["Avctl", "airctx", "apcf", "avlc", "navcu", "avsci", " avvoc", "aflc", "apcb", "AVctl", "navcomponent", "navctx", "AVcf", "airsci", "aircfg", "avcu", " avcontext", "avecoll", "avecontext", "navcontext", "AVvoc", "avctl", "afconn", "apcontext", "avcfg", "AVcfg", "AVcontext", "avectx", "AVcoll", "AVconn", "AVlc", "afcontext", "avectl", "avcoll", "AVpkg", "akctx", "avconn", "afci", "airci", "akcontext", "avecb", "avesci", "AVcb", "avci", "avepkg", "avcf", "avvoc", "AVci", "aircu", "AVsci", "Avcb", "avecfg", "aveci", "avecf", "aircontext", "afctx", "appkg", " avcoll", "avcca", "afcca", "avcomponent", "Avcontext", "akctl", "avecca", "Avctx", "apsci", "airctl", "AVcomponent", "avelc", "avevoc", "AVcu", "Avcu", "apctx", "aircomponent", "AVcca", "akcu", "Avcf", "avcontext", "avcb", "aveconn", "AVctx", "avpkg"], "ctx": ["context", "tx", "cm", "bc", "cam", "pkg", "cv", "ca", "qa", "rc", "config", "cc", "sync", "utils", "gc", "connection", "ctrl", "ci", "cs", "lc", "Context", "conv", "hub", "cn", "cms", "wx", "wcs", "cmp", "scope", "loc", "conf", "conn", "client", "kw", "np", "cli", "ck", "nc", "tc", "component", "cus", "concept", "acl", "wp", "cfg", "c", "cca", "crit", "cu", "dc", "chan", "anc", "cb", "cas", "sc", "sci", "cmd", "cf", "coll", "cp", "cal", "kb", "vc", "xc", "exec", "ga", "css", "fc", "hw", "cl", "fw"], "graph": ["path", "draw", "edge", "context", "root", "m", "connect", "format", "config", "Graph", "id", "growth", "container", "shape", "connection", "g", "ctrl", "image", "h", "module", "method", "model", "scope", "comment", "tree", "client", "conn", "gd", "group", "document", "view", "media", "p", "data", "driver", "j", "f", "raph", "flow", "result", "query", "subject", "proxy", "block", "gpu", "chan", "feed", "gen", "plot", "function", "network", "host", "layout", "handle", "node", "index"], "devenum": ["deVENums", "devernnum", "DEvenUM", "devenUM", "DEzenum", "devenenum", "devinenum", "deuxenum", "DEvenum", "devinum", "devasam", "deuxnum", "deVENenum", "DEvinenum", "deuxum", "DEvenenum", "devernum", "deuxums", "DEvennum", "devernUM", "DEvinums", "dezenum", "devinums", "devernam", "deVENnum", "devasnum", "devasum", "devasUM", "DEzenUM", "devenums", "DEvenam", "devenam", "dezenUM", "DEvinum", "DEvinnum", "DEzennum", "devennum", "DEvenums", "deVENum", "dezenam", "devinnum", "DEzenam", "dezennum"], "control": ["channel", "card", "connect", "edit", "config", "ctrl", "method", "model", "comment", "form", "media", "trl", "Control", " controls", "rol", "flow", "crit", "feed", "attr", "change", "ack", "exec", "command", "layout", "controller", "support", "roll"], "media_event": ["media_image", "media_events", "video_image", "video_object", "video_event", "media_object", "video_events"], "media_event_handle": ["media_image_event", "media_event_object", "media_image_object", "media_event_event", "media_event_Handle", "media_image_handle", "media_image_Handle"], "proc": ["func", " exec", "PR", "config", "pc", " PROC", "PC", "ctrl", "script", " procedure", "frame", "lib", "console", "processor", "p", " prod", " prog", "Process", " PE", "cb", "loop", "process", "exec", "src", " processor", " process", "handle", "callback"], "r": ["rr", "ret", "m", "self", "R", "t", "d", "hr", "rc", "l", "i", "rs", "or", "kr", " sr", "rar", "er", " rc", "g", "rn", "h", "rg", "sr", "ner", "str", "x", " R", "error", "v", "br", "rh", "fr", "cr", "var", "o", " ret", " re", "mr", "p", "lr", "e", "rb", "s", "k", "b", "j", "n", "f", "result", "c", "arr", "ur", " res", "re", " p", "q", "rt", "pr", "nr", "ar", "dr", "res", "rf", "run", "err"]}}
{"project": "qemu", "commit_id": "274250c30158f60aefb46088a7bb0d711061226c", "target": 1, "func": "static inline void s390_machine_initfn(Object *obj)\n\n{\n\n    object_property_add_bool(obj, \"aes-key-wrap\",\n\n                             machine_get_aes_key_wrap,\n\n                             machine_set_aes_key_wrap, NULL);\n\n    object_property_set_description(obj, \"aes-key-wrap\",\n\n            \"enable/disable AES key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"aes-key-wrap\", NULL);\n\n\n\n    object_property_add_bool(obj, \"dea-key-wrap\",\n\n                             machine_get_dea_key_wrap,\n\n                             machine_set_dea_key_wrap, NULL);\n\n    object_property_set_description(obj, \"dea-key-wrap\",\n\n            \"enable/disable DEA key wrapping using the CPACF wrapping key\",\n\n\n    object_property_set_bool(obj, true, \"dea-key-wrap\", NULL);\n\n    object_property_add_str(obj, \"loadparm\",\n\n            machine_get_loadparm, machine_set_loadparm, NULL);\n\n    object_property_set_description(obj, \"loadparm\",\n\n            \"Up to 8 chars in set of [A-Za-z0-9. ] (lower case chars converted\"\n\n            \" to upper case) to pass to machine loader, boot manager,\"\n\n            \" and guest kernel\",\n\n\n\n\n\n\n\n\n\n}", "idx": 13437, "substitutes": {"obj": ["oid", "args", "alt", "m", "self", "po", "ob", "tmp", "t", "sync", "jp", "code", "id", "object", "oa", "false", "ass", "api", "g", "Object", "act", "ex", "os", "cn", "nb", "x", "module", "str", "js", "eff", "fn", "ct", "Obj", "o", "lib", "kw", "ad", "p", "bot", "rb", "bm", "boot", "ck", "sb", "b", "j", "op", "n", "old", "stat", "none", "result", "att", "bh", "parent", "cat", "bo", "cb", "objects", "az", "fail", "cp", "od", "empty", "class", "dr", "el", "y", "ctx", "node", "xxx"]}}
{"project": "FFmpeg", "commit_id": "d86d7b2486cd5c31db8e820d8a89554abf19567e", "target": 0, "func": "static int ljpeg_decode_rgb_scan(MJpegDecodeContext *s, int nb_components, int predictor, int point_transform)\n\n{\n\n    int i, mb_x, mb_y;\n\n    uint16_t (*buffer)[4];\n\n    int left[4], top[4], topleft[4];\n\n    const int linesize = s->linesize[0];\n\n    const int mask     = ((1 << s->bits) - 1) << point_transform;\n\n    int resync_mb_y = 0;\n\n    int resync_mb_x = 0;\n\n\n\n    if (s->nb_components != 3 && s->nb_components != 4)\n\n        return AVERROR_INVALIDDATA;\n\n    if (s->v_max != 1 || s->h_max != 1 || !s->lossless)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n\n    s->restart_count = s->restart_interval;\n\n\n\n    av_fast_malloc(&s->ljpeg_buffer, &s->ljpeg_buffer_size,\n\n                   (unsigned)s->mb_width * 4 * sizeof(s->ljpeg_buffer[0][0]));\n\n    buffer = s->ljpeg_buffer;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        buffer[0][i] = 1 << (s->bits - 1);\n\n\n\n    for (mb_y = 0; mb_y < s->mb_height; mb_y++) {\n\n        uint8_t *ptr = s->picture_ptr->data[0] + (linesize * mb_y);\n\n\n\n        if (s->interlaced && s->bottom_field)\n\n            ptr += linesize >> 1;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            top[i] = left[i] = topleft[i] = buffer[0][i];\n\n\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int modified_predictor = predictor;\n\n\n\n            if (s->restart_interval && !s->restart_count){\n\n                s->restart_count = s->restart_interval;\n\n                resync_mb_x = mb_x;\n\n                resync_mb_y = mb_y;\n\n                for(i=0; i<4; i++)\n\n                    top[i] = left[i]= topleft[i]= 1 << (s->bits - 1);\n\n            }\n\n            if (mb_y == resync_mb_y || mb_y == resync_mb_y+1 && mb_x < resync_mb_x || !mb_x)\n\n                modified_predictor = 1;\n\n\n\n            for (i=0;i<nb_components;i++) {\n\n                int pred, dc;\n\n\n\n                topleft[i] = top[i];\n\n                top[i]     = buffer[mb_x][i];\n\n\n\n                PREDICT(pred, topleft[i], top[i], left[i], modified_predictor);\n\n\n\n                dc = mjpeg_decode_dc(s, s->dc_index[i]);\n\n                if(dc == 0xFFFFF)\n\n                    return -1;\n\n\n\n                left[i] = buffer[mb_x][i] =\n\n                    mask & (pred + (dc << point_transform));\n\n            }\n\n\n\n            if (s->restart_interval && !--s->restart_count) {\n\n                align_get_bits(&s->gb);\n\n                skip_bits(&s->gb, 16); /* skip RSTn */\n\n            }\n\n        }\n\n        if (s->rct && s->nb_components == 4) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[4*mb_x + 2] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[4*mb_x + 1] = buffer[mb_x][1] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 3] = buffer[mb_x][2] + ptr[4*mb_x + 2];\n\n                ptr[4*mb_x + 0] = buffer[mb_x][3];\n\n            }\n\n        } else if (s->nb_components == 4) {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[4*mb_x+3-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[4*mb_x+c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        } else if (s->rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2] - 0x200) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else if (s->pegasus_rct) {\n\n            for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                ptr[3*mb_x + 1] = buffer[mb_x][0] - ((buffer[mb_x][1] + buffer[mb_x][2]) >> 2);\n\n                ptr[3*mb_x + 0] = buffer[mb_x][1] + ptr[3*mb_x + 1];\n\n                ptr[3*mb_x + 2] = buffer[mb_x][2] + ptr[3*mb_x + 1];\n\n            }\n\n        } else {\n\n            for(i=0; i<nb_components; i++) {\n\n                int c= s->comp_index[i];\n\n                if (s->bits <= 8) {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ptr[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                } else if(s->bits == 9) {\n\n                    return AVERROR_PATCHWELCOME;\n\n                } else {\n\n                    for(mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n                        ((uint16_t*)ptr)[3*mb_x+2-c] = buffer[mb_x][i];\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 13442, "substitutes": {"s": ["rs", "qs", "h", "new", "x", "js", "si", "ps", "params", "spec", "c", "is", "sv", "states", "m", "self", "bis", "d", "t", "sg", "sync", "fs", "series", "ins", "sym", "g", "cs", "es", "full", "session", "w", "u", "sf", "b", "ns", "ops", "space", "support", "ks", "secondary", "sys", "parts", "service", "your", "hs", "os", "sets", "ms", "e", "site", "sb", "features", "f", "services", "ls", "comments", "ses", "l", "rates", "a", "changes", "S", "settings", "this", "its", "sq", "styles", "v", "conf", "ss", "strings", "p", "se", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "ims", "y"], "nb_components": ["nb_componentonent", "nb_Compords", "nb_sclements", "nb_chonents", "nb_comords", "nb_complements", "nbofcomponentonent", "nb_compators", "nb_cators", "nbofcomponent", "nb_scords", "nb_counds", "nb_compords", "nb_componentonents", "nb_sconent", "nb_compounds", "nb_conents", "nb_distounds", "nb_comlements", "nbofcomponentonents", "nb_comonent", "nbofcompixels", "nb_sconents", "nb_comonents", "nb_componentixels", "nb_Complements", "nb_Component", "nb_comounds", "nbofcomponents", "nb_distonent", "nb_comators", "nb_chixels", "nb_compixels", "nb_distators", "nbofcomponentixels", "nb_component", "nb_comixels", "nb_Components", "nb_distonents", "nb_conent", "nb_chonent"], "predictor": ["pcriptitor", "pcredictistor", "pveyions", "compveyions", "pacheristor", "predictions", "pveyutor", "priptor", "compredictor", "pcredictator", "predictistor", "pacherator", "presentions", "pcessor", "ppriitor", "priptitor", "compveyor", "compveyator", "pprior", "compredictator", "pcriptator", "pcessions", "compredictions", "predictator", "pveyor", "ppriistor", "compveyutor", "priptator", "pacheror", "priptistor", "pcriptor", "pveyator", "presentor", "pcessutor", "pcessator", "presentutor", "compredictutor", "predictitor", "pcriptistor", "ppriator", "pcredictor", "predictutor", "pacheritor", "presentator", "pcredictitor"], "point_transform": [" point_trans", " point_scale", "int_shape", "point_mask", "point2scale", "point2mask", "int_size", "int_scale", "int_transform", "point2transform", " point_mask", "point2trans", "point_shape", "point_scale", "point_size", "point_trans"], "i": ["my", "image", "h", "x", "si", "ind", "base", "count", "phi", "c", "zi", "in", "index", "hi", "m", "slice", "d", "xi", "id", "iu", "io", "g", "ki", "di", "u", "fi", "data", "b", "ti", "ip", "eni", "bi", "qi", "ni", "ini", "ci", "ie", "init", "o", "z", "e", "info", "li", "ix", "multi", "j", "f", "type", "it", "ui", "I", "ai", "l", "gi", "name", "ii", "v", "uri", "yi", "size", "p", "mini", "mi", "k", "n", "pi", "chi", "q", "ri", "y", "start"], "mb_x": ["mbIdz", "mp_x", "embPy", "mb_sex", "emb_y", "amb_x", "mbFx", "embPw", "mp_t", "mb_z", "mp_ex", "emb_x", "mb_width", "mp_wy", "mbPx", "ambIdx", "emb_w", "mbUcross", "mbFex", "mp_xs", "mp_cross", "mb_name", "mbFt", "mb67name", "mp_z", "ambIdsex", "ambIdz", "mbUex", "mbUt", "mb67x", "amb_sex", "mbIdsex", "mb_ex", "mbIdrx", "mb_wy", "amb_z", "mbPw", "mb_w", "embPwidth", "embPx", "mb_xs", "mp_name", "mbIdx", "mbPy", "mb67y", "mbPwidth", "mbUx", "amb_rx", "mb67z", "mb_cross", "mbFcross", "mp_y", "ambIdrx", "emb_width", "mb_rx", "mb_t"], "mb_y": ["mb_zy", "mp_x", "embPy", "em_y", "em_zy", "emb_y", "emb_yl", "bg_ady", "mp_ey", "mb_ym", "mbPi", "embPvy", "mbPvy", "mbPx", "mbUny", "mb33cy", "mb_ady", "embPcy", "bg_y", "mb_ery", "mp_i", "mp_ya", "emb_vy", "em_ery", "mbPyl", "mp_ny", "mb_vy", "bg_ym", "mb_ya", "mbPcy", "emb_cy", "mb33yl", "mb_cy", "mb_ny", "mbUey", "mbPya", "mb33vy", "mb33y", "mbUy", "mbPy", "mbUx", "mb_ey", "em_ey", "embPyl", "mb_yl", "mb_i", "mp_y", "bg_x"], "buffer": ["channel", "transfer", "port", "context", "bin", "bc", "queue", "input", "cube", "slice", "memory", "source", "reference", "plane", "image", "border", "position", "writer", "comment", "server", "table", "buff", "pause", "clip", "console", "document", "layer", "surface", "resource", "buf", "data", "b", "flash", "Buffer", "byte", "length", "base", "shell", "block", "scroll", "feed", "uffer", "offset", "file", "iter", "command", "que", "cache", "header", "window", "texture", "material", "message"], "top": ["upper", "path", "bottom", "up", "front", "pop", "maximum", "master", "limit", "output", "platform", "super", "stop", "p", "bot", "Top", "min", "tip", "op", "parent", "best", "below", "first", "above", "per", "tops", "target", "TOP", "all", "ops", "tips", "last", "stack", "high", "pos", "space", "tail", "support"], "topleft": ["toplekt", "topleaft", "stroukt", "strouft", "toulft", " tourfts", "trieft", "triegent", "toplegent", "troukt", "tOPLEgent", " tourgent", "tOPLEaft", "stoplekt", "tylekt", "tourfts", "stopleft", "tourgent", " tourft", "tyleplet", "stoplevel", "toulvel", "tOPLEfts", "toulkt", "trouft", "topleplet", " toplefts", "toulplet", "trieaft", " topleaft", " toplegent", "tOPLEft", "touraft", "trouvel", "tyleft", "tylevel", "stopleplet", "toplevel", " touraft", "tourft", "strouvel", "toplefts", "trouplet", "triefts", "strouplet"], "ptr": ["map", "slice", "inter", "tr", "rc", "code", "iv", "pt", "ctr", "prot", "tile", "ref", "xp", "scope", "fp", "loc", "br", "fr", "peer", "obj", "ctx", "buf", "pointer", "ext", "nil", "j", "inst", "butt", "address", "fe", "arr", "offset", "attr", "pri", "Ptr", "src", "stack", "dr", "pos", "addr", "pad"], "restart_count": ["restartPoolcount", "restartFcount", "restarm_count", "restardPoolindex", "restard_count", "restard_index", "restardPoolcount", "restart64part", "restort_count", "restardPoolpart", "restart_code", "restartPoolindex", "restartPoolpart", "restarm_cache", "restart64index", "restartCtype", "restartClength", "restartCcode", "restartCcount", "restard_part", "restort_type", "restart_cache", "restart64count", "restartFcache", "restartFmultiple", "restart_index", "restart_length", "restort_code", "restort_length", "restart_type", "restart_part", "restarmFmultiple", "restarm_multiple", "restarmFcache", "restarmFcount", "restart_multiple"]}}
{"project": "qemu", "commit_id": "b5e751b51f14cffada6be647aa576b79f1755d7e", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448, "substitutes": {"con": ["func", "en", "mc", "connect", "bc", "uc", "ca", "inter", "core", "rc", "pc", "un", "container", "connection", "ain", "conv", "cn", "pool", "lang", "acon", "fn", "hel", "conf", "client", "conn", "win", " uncon", "cons", "ran", "CON", "aff", "ocon", "co", "can", "c", "Con", "cat", "dc", "contract", "ac", "pin", "run", "gate", "cf", "cell", "exec", "cache", "ec", "sub", "cur", "fac", "fc", "ln"], "ssd": ["ssda", "kssd", "assdk", "ksds", "yssd", "essdc", "cssdd", "ssdd", "psl", "hesssd", "assds", "ysdk", "dsds", "cssdc", "rssds", "psdc", "cssds", "ssds", "ssdc", "rssd", "ksd", "amsds", " ssda", "dsd", " ssdc", "SSD", "cssd", "SSsd", "csssd", "ssdl", "vsds", "essdl", "sshd", "esshd", "esssd", "psds", "ysda", "pssd", "cssdk", "SSd", "essda", "rssdk", "yshd", "hessd", " ssds", "hessdc", "rsssd", "cosds", "asssd", "hessds", "amsdd", "rssdc", "sssd", "hessl", "cossd", "hessD", " ssdl", "vsd", "essdd", "ysd", "rssdl", "cosd", "essds", "cssl", "essl", "amsdc", "vsdk", "ysds", "amsd", "cosdl", "ssD", "ssdk", "dssd", "psd", "cssD", "dsdk", "ksdl", "essd", " sshd", "vssd", "ssl", "SSdc", "assd"]}}
{"project": "FFmpeg", "commit_id": "fe7547d69e6721d064c8604d0a6375a2d24b35ca", "target": 0, "func": "int ff_index_search_timestamp(const AVIndexEntry *entries, int nb_entries,\n\n                              int64_t wanted_timestamp, int flags)\n\n{\n\n    int a, b, m;\n\n    int64_t timestamp;\n\n\n\n    a = -1;\n\n    b = nb_entries;\n\n\n\n    // Optimize appending index entries at the end.\n\n    if (b && entries[b - 1].timestamp < wanted_timestamp)\n\n        a = b - 1;\n\n\n\n    while (b - a > 1) {\n\n        m         = (a + b) >> 1;\n\n\n\n        // Search for the next non-discarded packet.\n\n        while ((entries[m].flags & AVINDEX_DISCARD_FRAME) && m < b) {\n\n            m++;\n\n            if (m == b && entries[m].timestamp >= wanted_timestamp) {\n\n                m = b - 1;\n\n                break;\n\n            }\n\n        }\n\n\n\n        timestamp = entries[m].timestamp;\n\n        if (timestamp >= wanted_timestamp)\n\n            b = m;\n\n        if (timestamp <= wanted_timestamp)\n\n            a = m;\n\n    }\n\n    m = (flags & AVSEEK_FLAG_BACKWARD) ? a : b;\n\n\n\n    if (!(flags & AVSEEK_FLAG_ANY))\n\n        while (m >= 0 && m < nb_entries &&\n\n               !(entries[m].flags & AVINDEX_KEYFRAME))\n\n            m += (flags & AVSEEK_FLAG_BACKWARD) ? -1 : 1;\n\n\n\n    if (m == nb_entries)\n\n        return -1;\n\n    return m;\n\n}\n", "idx": 13462, "substitutes": {"entries": ["entessions", "genturies", "settrows", "Entrys", "entlements", "entables", "tions", "integries", "settences", "meturies", "trants", "endessions", "turies", "contories", "settlements", "incries", "ntries", "Entries", "endions", "tessions", "tories", "contries", "incrows", "gentrants", "inclements", "estences", "entrants", "ENTies", "ties", "tries", "entories", "centrows", "ENTries", "Enturies", "enturies", "integuries", "ENTories", "Entrows", "entrows", "contrys", "tences", "settries", "contributes", "centries", "integrie", "integrows", "ientrie", "gentables", "entences", "enties", "entrys", "tables", "ntributes", "metables", "endries", "centences", "entions", "gentries", "ientries", "Entributes", "ientrows", "metrants", "Entrie", "entributes", "contrants", "estries", "conties", "endences", "ENTrants", "metries", "estions", "entrie", "ntrys", "estessions", "ienturies", "incences", "centlements"], "nb_entries": ["nb_endues", "nb_intry", "nb_exties", "nb_intrants", "nbofenties", "nb_ENTents", "nbofentries", "nb_intues", "nbofentrys", "nb_entrants", "nbofcentrys", "nb_centles", "nbofentry", "nb_centies", "nb_ntries", "nb_centries", "nb_enties", "nb_extrs", "nb_entles", "nb_endes", "nb_extrants", "nb_intes", "nb_intrs", "nb_entes", "nb_entents", "nb_endries", "nb_extents", "nb_entues", "nb_intles", "nb_centry", "nb_ENTies", "nb_extues", "nb_centrys", "nb_endrants", "nbofcentries", "nbofcentry", "nb_entrs", "nb_entry", "nb_ntles", "nb_centrs", "nb_centents", "nb_ntry", "nb_ENTrs", "nb_ntrys", "nb_intries", "nb_nties", "nb_entrys", "nbofcenties", "nb_ENTries", "nb_country", "nb_countries", "nb_extries", "nb_ntrs", "nb_countrys", "nb_counties", "nb_extes"], "wanted_timestamp": ["wanted_tmetime", "wanted_semency", "wanted_marketeter", "wanted_wateremark", "wanted_timeemark", "wanted_wateretime", "wanted_timest", "wanted_timeeter", "wanted_tmency", "wanted_tmeline", "wanted_timeestamp", "wanted_Timency", "wanted_timeline", "wanted_semest", "wanted_Timestamp", "wanted_shortetime", "wanted_Timeter", "wanted_timetime", "wanted_Timemark", "wanted_timemark", "wanted_marketestamp", "wanted_Timetime", "wanted_shortestamp", "wanted_tmestamp", "wanted_semetime", "wanted_timeeline", "wanted_shortest", "wanted_waterest", "wanted_timeter", "wanted_shorteter", "wanted_Timest", "wanted_tmest", "wanted_Timeline", "wanted_waterestamp", "wanted_timency", "wanted_timeest", "wanted_timeetime", "wanted_semestamp", "wanted_marketetime", "wanted_marketest"], "flags": ["codes", "types", "args", "planes", "cards", "pieces", "FLAG", "nl", "fd", "fl", "fs", "ins", "locks", "fields", "pins", "utils", "rets", "prot", "fun", "details", "settings", "bytes", "fo", "ants", "limits", "styles", "files", "checks", "lists", "dates", "ids", "strings", "alls", "plugins", "options", "allows", "faces", "sf", "features", "heads", "mask", "lag", "frames", "lf", "bits", "tests", "lines", "ages", "ats", "Flags", "afi", "ports", "stats", "atts", "ags", "ops", "links", "states", "ds", "fee", "requires", "mods", "rules", "fts", "flag", "vals"], "a": ["area", "as", "aj", "ak", "d", "ca", "ai", "l", "i", "da", "api", "na", "x", "ap", "aa", "o", "alpha", "w", "an", "ad", "ba", "p", "e", "A", "s", "la", "u", "aw", "pa", "af", "j", "n", "f", "aaa", "ma", "ab", "am", "c", "ac", "wa", "va", "r", "ae", "sa", "ga", "ar", "fa", "y"], "b": ["bis", "bc", "d", "reb", "ob", "bs", "ad", "ca", "l", "i", "bb", "fb", "bd", "binary", "bad", "h", "nb", "x", "aa", "machine", "v", "br", "mb", "job", "k", "o", "bp", "w", "bar", "u", "an", "ba", "p", "e", "be", "rb", "ib", "boot", "bot", "pb", "s", "sb", "wb", "j", "base", "n", "f", "bf", "bm", "ab", "bh", "c", "big", "am", "pa", "cb", "z", "body", "eb", "ok", "bas", "r", "abb", "bi", "ae", "B", "db", "emb", "lb", "y"], "m": ["mc", "cm", "wm", "d", "t", "l", "i", "me", "mid", "month", "fm", "g", "h", "mn", "x", "module", "mod", "mm", "ym", "model", "machine", "v", "tm", "em", "o", "w", "ms", "u", "an", "gm", "p", "e", "mr", "bm", "s", "z", "mi", "pa", "mini", "j", "mA", "n", "f", "mo", "hm", "ma", "am", "c", "pm", "M", "md", "man", "im", "r", "om", "um", "dim", "dm", "y", "sm", "mu"], "timestamp": ["timeetime", "timeline", "timetime", "tmetime", "scheestamp", "monthpoint", "timity", "ampedest", "metest", "simeter", "continestamp", "hometa", "simeline", "meteta", "Timity", "timeter", "monthest", "contineline", "tuneter", "continpoint", "scheeline", "timeeline", "tmeta", "timoffset", "scheplay", "contineport", "temestamp", "integest", "teneport", "metemark", "scheetime", "meteline", "ampedestamp", "ampedoffset", "hometime", "imemark", "mintpoint", "metetime", "tmeline", "Timpoint", "metency", "ampedemark", "timeta", "tmeter", "timemark", "Timest", "temeline", "tunestamp", "minteline", "tuneline", "simestamp", "imoffset", "timest", "templay", "impoint", "timpoint", "timment", "tenpoint", "timency", "integency", "imestamp", "metity", "timplay", "minteport", "Timment", "metoffset", "imest", "timette", "integity", "timeplay", "mintestamp", "imment", "monthment", "simette", "Timency", "temetime", "homeline", "teneline", "tmette", "integestamp", "tenestamp", "tunette", "Timestamp", "monthestamp", "tmestamp", "timeport", "metestamp", "homestamp", "timeestamp"]}}
{"project": "FFmpeg", "commit_id": "668494acd8b20f974c7722895d4a6a14c1005f1e", "target": 1, "func": "static int codec_get_buffer(AVCodecContext *s, AVFrame *frame)\n{\n    InputStream *ist = s->opaque;\n    FrameBuffer *buf;\n    int ret, i;\n    if (!ist->buffer_pool && (ret = alloc_buffer(s, ist, &ist->buffer_pool)) < 0)\n        return ret;\n    buf              = ist->buffer_pool;\n    ist->buffer_pool = buf->next;\n    buf->next        = NULL;\n    if (buf->w != s->width || buf->h != s->height || buf->pix_fmt != s->pix_fmt) {\n        av_freep(&buf->base[0]);\n        av_free(buf);\n        ist->dr1 = 0;\n        if ((ret = alloc_buffer(s, ist, &buf)) < 0)\n            return ret;\n    }\n    buf->refcount++;\n    frame->opaque        = buf;\n    frame->type          = FF_BUFFER_TYPE_USER;\n    frame->extended_data = frame->data;\n    frame->pkt_pts       = s->pkt ? s->pkt->pts : AV_NOPTS_VALUE;\n    for (i = 0; i < FF_ARRAY_ELEMS(buf->data); i++) {\n        frame->base[i]     = buf->base[i];  // XXX h264.c uses base though it shouldn't\n        frame->data[i]     = buf->data[i];\n        frame->linesize[i] = buf->linesize[i];\n    }\n    return 0;\n}", "idx": 13468, "substitutes": {"s": ["qs", "h", "js", "si", "ps", "sim", "frames", "spec", "c", "is", "sc", "sv", "sl", "com", "in", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "sup", "g", "cs", "es", "w", "u", "an", "sf", "b", "ns", "r", "sie", "sis", "ks", "sys", "service", "source", "os", "sets", "e", "sb", "f", "ans", "services", "ls", "ctx", "ses", "as", "bs", "a", "S", "this", "sq", "v", "conf", "ss", "p", "se", "op", "n", "gs", "xs", "sci", "ssl", "ds", "src", "su", "ts", "us", "vs", "sts"], "frame": ["fl", "za", "image", "module", "ace", "fp", "rame", "base", "driver", "play", "frames", "line", "flow", "c", "cb", "dr", "fc", "pse", "draw", "m", "part", "slice", "uf", "flower", "full", "session", "fr", "w", "fi", "kt", "data", "sf", "host", "layout", "header", "Frame", "fram", "config", "iframe", "fb", "framework", "cast", "style", "builder", "source", "plane", "fx", "fo", "game", "buffer", "element", "document", "layer", "e", "info", "f", "cfg", "feature", "fe", "state", "html", "block", "cf", "load", "ctx", "ze", "fw", "board", "code", "player", "object", "position", "buff", "p", "component", "setup", "file", "ov", "coll", "face", "seq"], "ist": ["ess", "it", "ais", "ists", "osi", "sys", "as", "part", "ft", "edit", "adder", "dist", "art", "oss", "pt", "er", "act", "st", "xt", "asp", "ace", "ie", "ide", "fp", "pect", "ld", "aim", "aunt", "ss", "iste", "mot", "irst", "feat", "alist", "obj", "ad", "ind", "oc", "p", "ant", "se", "kt", "IST", "ix", "ait", "est", "op", "inst", "dit", "at", "isd", "wp", "att", "isi", "ans", "store", "is", "ac", "nt", "ht", "ast", "ism", "rt", "ic", "ds", "ard", "dr", "wd", "iss", "et", "ctx", "ost"], "buf": ["bridge", "runner", "proc", "ff", "bc", "sov", "h", "pool", "fp", "br", "anim", "obj", "rb", "fab", "af", "Buffer", "box", "base", "bf", "cb", "cas", "aux", "func", "home", "uf", "loader", "img", "fi", "data", "b", "wb", "Buff", "feed", "gen", "lb", "fac", "header", "alloc", "queue", "fd", "cv", "config", "fb", "cast", "uber", "bd", "builder", "fx", "uno", "ref", "buffer", "fg", "bag", "raf", "grab", "f", "bu", "block", "cf", "que", "ctx", "fw", "vec", "board", "uc", "buff", "pb", "ov", "cmd", "coll", "fam", "src", "seq"], "ret": ["pet", "alt", "it", "let", "part", "reply", "art", "rc", "val", "code", "back", "bad", "bd", "disabled", "def", "rets", "fun", " def", "ref", "pret", "arg", "det", "str", "lit", "valid", "error", "job", "feat", "pass", "active", "ib", "fin", "fi", "success", "match", "af", "Ret", "bf", "f", "result", "att", "reset", "red", "arr", "nt", "re", "rt", "get", "resp", "fail", "pat", "RET", "res", "reg", "flag", "run", "len", "bit"], "i": ["hi", "qi", "it", "ui", "adi", "I", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "a", "api", "code", "ci", "di", "x", "si", "ie", "ii", "uri", "vi", "v", "o", "index", "yi", "u", "ind", "p", "e", "ir", "info", "fi", "mi", "li", "cli", "ix", "k", "multi", "j", "abi", "phi", "f", "n", "ti", "ip", "c", "eni", "inner", "ji", "type", "pi", "bi", "ri", "ori", "ami", "zi", "y", "in", "mu"], "refcount": ["rowlen", "poscount", "poslow", "rowlow", "rowCount", "posCount", "memlow", "rowcount", "memlen", "memcount", "refCount", "reflow", "memCount", "reflen", "poslen"]}}
{"project": "FFmpeg", "commit_id": "b8edf91657ad9fa2f0c5175c9ca8fbe3c8b0c624", "target": 0, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *inpic)\n\n{\n\n    AVFilterContext   *ctx     = inlink->dst;\n\n    HisteqContext     *histeq  = ctx->priv;\n\n    AVFilterLink      *outlink = ctx->outputs[0];\n\n    int strength  = histeq->strength  * 1000;\n\n    int intensity = histeq->intensity * 1000;\n\n    int x, y, i, luthi, lutlo, lut, luma, oluma, m;\n\n    AVFrame *outpic;\n\n    unsigned int r, g, b, jran;\n\n    uint8_t *src, *dst;\n\n\n\n    outpic = ff_get_video_buffer(outlink, outlink->w, outlink->h);\n\n    if (!outpic) {\n\n        av_frame_free(&inpic);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    av_frame_copy_props(outpic, inpic);\n\n\n\n    /* Seed random generator for antibanding. */\n\n    jran = LCG_SEED;\n\n\n\n    /* Calculate and store the luminance and calculate the global histogram\n\n       based on the luminance. */\n\n    memset(histeq->in_histogram, 0, sizeof(histeq->in_histogram));\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n            luma = (55 * r + 182 * g + 19 * b) >> 8;\n\n            dst[x + histeq->rgba_map[A]] = luma;\n\n            histeq->in_histogram[luma]++;\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"in[%d]: %u\\n\", x, histeq->in_histogram[x]);\n\n#endif\n\n\n\n    /* Calculate the lookup table. */\n\n    histeq->LUT[0] = histeq->in_histogram[0];\n\n    /* Accumulate */\n\n    for (x = 1; x < 256; x++)\n\n        histeq->LUT[x] = histeq->LUT[x-1] + histeq->in_histogram[x];\n\n\n\n    /* Normalize */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (histeq->LUT[x] * intensity) / (inlink->h * inlink->w);\n\n\n\n    /* Adjust the LUT based on the selected strength. This is an alpha\n\n       mix of the calculated LUT and a linear LUT with gain 1. */\n\n    for (x = 0; x < 256; x++)\n\n        histeq->LUT[x] = (strength * histeq->LUT[x]) / 255 +\n\n                         ((255 - strength) * x)      / 255;\n\n\n\n    /* Output the equalized frame. */\n\n    memset(histeq->out_histogram, 0, sizeof(histeq->out_histogram));\n\n\n\n    src = inpic->data[0];\n\n    dst = outpic->data[0];\n\n    for (y = 0; y < inlink->h; y++) {\n\n        for (x = 0; x < inlink->w * histeq->bpp; x += histeq->bpp) {\n\n            luma = dst[x + histeq->rgba_map[A]];\n\n            if (luma == 0) {\n\n                for (i = 0; i < histeq->bpp; ++i)\n\n                    dst[x + i] = 0;\n\n                histeq->out_histogram[0]++;\n\n            } else {\n\n                lut = histeq->LUT[luma];\n\n                if (histeq->antibanding != HISTEQ_ANTIBANDING_NONE) {\n\n                    if (luma > 0) {\n\n                        lutlo = histeq->antibanding == HISTEQ_ANTIBANDING_WEAK ?\n\n                                (histeq->LUT[luma] + histeq->LUT[luma - 1]) / 2 :\n\n                                 histeq->LUT[luma - 1];\n\n                    } else\n\n                        lutlo = lut;\n\n\n\n                    if (luma < 255) {\n\n                        luthi = (histeq->antibanding == HISTEQ_ANTIBANDING_WEAK) ?\n\n                            (histeq->LUT[luma] + histeq->LUT[luma + 1]) / 2 :\n\n                             histeq->LUT[luma + 1];\n\n                    } else\n\n                        luthi = lut;\n\n\n\n                    if (lutlo != luthi) {\n\n                        jran = LCG(jran);\n\n                        lut = lutlo + ((luthi - lutlo + 1) * jran) / LCG_M;\n\n                    }\n\n                }\n\n\n\n                GET_RGB_VALUES(r, g, b, src, histeq->rgba_map);\n\n                if (((m = FFMAX3(r, g, b)) * lut) / luma > 255) {\n\n                    r = (r * 255) / m;\n\n                    g = (g * 255) / m;\n\n                    b = (b * 255) / m;\n\n                } else {\n\n                    r = (r * lut) / luma;\n\n                    g = (g * lut) / luma;\n\n                    b = (b * lut) / luma;\n\n                }\n\n                dst[x + histeq->rgba_map[R]] = r;\n\n                dst[x + histeq->rgba_map[G]] = g;\n\n                dst[x + histeq->rgba_map[B]] = b;\n\n                oluma = (55 * r + 182 * g + 19 * b) >> 8;\n\n                histeq->out_histogram[oluma]++;\n\n            }\n\n        }\n\n        src += inpic->linesize[0];\n\n        dst += outpic->linesize[0];\n\n    }\n\n#ifdef DEBUG\n\n    for (x = 0; x < 256; x++)\n\n        av_dlog(ctx, \"out[%d]: %u\\n\", x, histeq->out_histogram[x]);\n\n#endif\n\n\n\n    av_frame_free(&inpic);\n\n    return ff_filter_frame(outlink, outpic);\n\n}\n", "idx": 13488, "substitutes": {"inlink": [" inframe", "outlock", "outfile", "inbug", " inlock", " inink", "outframe", "outink", "incLink", "inink", "inslock", "inlock", "incbug", " inplug", "outbug", "outplug", "outline", " inLink", "insline", "insLink", "incframe", "outLink", "incline", "inclink", "inframe", " infile", "incplug", " inbug", "inplug", "incfile", "infile", "incink", "inLink", "inslink"], "inpic": [" inpixel", "inpict", "inspic", "idpict", "outpict", "npixel", "INpic", "idframe", "outpixel", " inpins", "INpins", "npict", " inPic", "outpin", "outpins", "inspixel", "outframe", "INPic", "idpic", "inPic", " inpin", "npic", " outpict", "insPic", "idpin", "inpixel", "inpins", " inpict", "INpict", "inspict", "INlink", "npin", "inframe", " outpin", "INpixel", "inpin", "INpin", "outPic", " outframe"], "ctx": ["context", "tx", "pkg", "cm", "bc", "cam", "cv", "ca", "sync", "rc", "config", "cc", "utils", "Context", "ctrl", "cs", "ci", "conv", "hub", "cn", "cmp", "init", "sq", "loc", "conn", "client", "kw", "lib", "obj", "nc", "cli", "ck", "tc", "cus", "concept", "parent", "c", "cca", "voc", "anc", "cb", "cas", "sc", "sci", "cmd", "cf", "cp", "cpp", "kb", "mac", "xc", "vc", "util", "fc", "hw", "fw"], "histeq": ["histqq", "histequ", " histq", "batchqq", " histexp", "Histquant", "hyq", "hexeq", " historyeq", "histexp", " historyctx", "humsys", "histctx", "plotsys", "historyequ", " histnec", "hapne", "historyoise", "Histue", " histec", "hesscomment", "plotiq", "combequ", " histcomp", "histq", "hyne", "combcoe", "histiq", "histquant", "batchsys", "historyctx", "gitiq", "historyue", "histcomment", " historysys", "histec", "historyite", "hesscoe", "thcomp", "humeq", "ploteq", "combeq", " histch", " histcoe", " historyue", "histcomp", " historyite", " histne", " histctx", "historyquant", "regeq", "historyeq", "historyexp", " histite", "histch", " histequ", "thne", " historyexp", "hapequ", " historyq", "historynec", "historycomment", "regcoe", "histnec", "hessequ", "theq", "batchiq", "historyq", "histue", "hexcomment", "regcomp", "comboise", "histoise", "hesseq", "historyne", "plotequ", "historysys", "histcoe", " historycoe", " histsys", "histne", " histue", "histsys", "Histeq", "regsys", "hessoise", "batcheq", "giteq", "humqq", "hyeq", "historych", "hapeq", "humiq", "hapq", " historyec", "gitsys", "Histq", "historyec", "hyquant", "histite", "hessne", "historyqq", "hessnec", " historycomp", "historycoe", "thequ", "gitequ", "hexequ", "Histne", "regequ", " historych", "hexcoe", "historycomp", "historyiq"], "outlink": ["Outload", "Outlink", " outline", "inload", "upline", "outload", "Outline", "outlock", "offpic", "offlc", "downchat", "downlock", "outlc", "offlink", "outframe", " outlc", "offchat", "inlock", "outline", "inchat", " outLink", "downline", "downlink", "uplink", "outLink", "upframe", "inframe", "offline", "offlock", "inlc", "OutLink", "uppic", "outchat", "inLink", " outlock", " outframe", " outload"], "x": ["tx", "xe", "my", "h", "event", "xt", "ct", "dx", "ady", "pl", "c", "X", "work", "index", "d", "t", "on", "xi", "id", "full", "w", "u", "axis", "xx", "ax", "pe", "xc", "el", "wx", "fx", "sw", "xp", "px", "o", "z", "e", "rx", "ix", "j", "f", "sex", "wa", "ph", "cl", "xxx", "any", "l", "code", "ww", "name", "XX", "ex", "xa", "v", "yx", "col", "p", "time", "k", "n", "xs", "xes", "q", "xy"], "y": ["ny", "yt", "ch", "d", "t", "ys", "id", "l", "a", "ey", "h", "py", "cy", "ym", "ye", "o", "w", "dy", "yi", "z", "u", "yl", "p", "e", "s", "yr", "j", "n", "f", "xx", "yn", "oy", "c", "vy", "ay", "ry", "type", "Y", "ya", "ky", "xy", "yy", "zy", "sy"], "i": ["hi", "it", "I", "d", "t", "ai", "l", "h", "ii", "w", "z", "u", "p", "e", "s", "k", "j", "n", "f", "phi", "ip", "c", "pi"], "luthi": ["elustl", "lushli", "lustai", "lusti", "luhi", "eluthai", "eluthi", "luhli", "luthl", "elusti", "lushi", "lushai", "eluthli", "lushl", "luthli", "lustl", "luhai", "elustli", "elustai", "lustli", "luthai", "eluthl", "luhl"], "lutlo": [" lstlo", "lUTlo", "lutli", "lutla", " lutla", "lUTla", " lstli", " lstla", "lUTco", "lstco", "lstlo", "lUTli", "lustco", "lustlo", " lutli", "lstli", " lstco", "lustla", "lutco", " lutco", "lstla", "lustli"], "lut": ["olut", "sluti", "sluv", "oldu", " luv", "luv", " luti", "oluv", "luti", " ldu", "sldu", "oluti", "slut", "ldu"], "luma": [" luca", "olamin", " lappa", "Luma", "olappa", "elamin", "fluna", "oluv", " lamin", "floca", "luca", "eluna", "oluc", "eluv", "luc", "luto", "flappa", " luv", "luv", "eluma", "klma", "oluna", "eluto", " luna", "luna", "loma", " luc", "eluc", " loca", "kluma", "oluto", "kluna", "Lma", "oluca", "kloma", "lma", "lamin", "Luna", "oloca", "Loma", " lma", "fluma", " luto", "loca", "lappa", " loma", "eluca"], "oluma": ["moluma", "oloca", "moloca", "olut", "ioluma", "ioloca", "oluna", "loca", "molut", "iolut", "luna", "moluna", "ioluna"], "m": ["mc", "cm", "d", "l", "mean", "h", "mm", "v", "meta", "o", "gm", "u", "p", "e", "mi", "n", "f", "mode", "hm", "c", "M", "mass", "im", "volume", "dm", "mu"], "outpic": ["mainpin", "inpict", "OUTpin", "OutPic", "OUTproc", "inpicture", "outproc", "outpict", " outnic", "netpic", "againpin", "netpict", "offpic", " outpicture", "netpin", "againpicture", "outpin", "outpins", "offPic", "inPic", " outpict", "againpic", " outproc", "mainproc", "inpins", "againpict", "outpicture", "OUTnic", "againPic", "Outpic", "netpins", "Outpict", "mainpic", " outPic", "offpicture", " outpin", "outnic", "Outpin", "OUTpic", "inpin", "offpict", "outPic", "mainnic", " outpins"], "r": ["rr", "vr", "ru", "d", "R", "rc", "l", "rs", "a", "er", "h", "rg", "sr", "v", "br", "var", "cr", "w", "u", "mr", "z", "p", "e", "rb", "rx", "k", "n", "rw", "f", "rl", "c", "ur", "pr", "nr", "ar", "rf"], "g": ["gz", "d", "t", "sg", "l", "G", "gi", "a", "gt", "pg", "h", "rg", "gh", "v", "gn", "w", "group", "u", "p", "e", "s", "gg", "k", "n", "f", "gb", "c", "gen", "bg", "reg"], "b": ["bin", "d", "ob", "t", "bs", "l", "fb", "a", "h", "v", "mb", "o", "w", "u", "z", "p", "e", "s", "rb", "k", "sb", "wb", "j", "n", "f", "bh", "ab", "c", "B", "lb"], "jran": ["jsran", " jlan", "jpron", "jprun", "jra", "jrn", "jslan", " jrun", "jpran", "Jrn", "Jlan", "jlan", " jrn", "Jron", " jra", "jron", "Jrg", "Jran", "Jra", " jrg", "jsrg", "jrun", " jron", "jsrn", "Jrun", "jpra", "jrg"], "src": ["func", "RC", "sys", "rss", "gz", "uc", "hl", "hr", "dist", "rc", "config", "stream", "rs", "iv", "ug", "sup", "source", "image", "rg", "sr", "dest", "sq", "loc", "uri", "gl", "s", "rb", "img", "rx", "rin", "sb", "inst", "gb", "spec", "rl", "url", "cb", "ur", "sc", "ssl", "rob", "bg", "attr", "sl", "uv", "RGB", "sub", "sel", "ource", "href", "filename"], "dst": [" dsts", "rst", "fsrc", "fsts", "Dst", " dsth", " dST", "hST", "Dsts", "nconst", "sdsth", "dsts", " dsrc", "dconst", "Dste", " dest", " dput", "nsrc", "dest", "hst", "sdsts", "fost", "Dost", "dsrc", "ssts", "Dsth", "sst", "sest", "sdst", "rST", "hsrc", "dost", " dste", "dsth", "Dput", "dST", "nst", "dput", "DST", " dost", "hconst", "Dconst", "rste", "fst", "Dest", "sost", "dste", "sdput", "rsts", "Dsrc", "nST"], "in_histogram": ["in_logogram", "in_pastogram", "in_histrogram", "in_imageory", "in_Histor", "in_blogram", "in_Historical", "in_memicle", "in_blor", "in_imageogram", "in_Histograms", "in_blorical", "in_thogram", "in_imageogue", "in_memometry", "in_histograms", "in_histog", "in_Histicle", "in_pasticle", "in_logrogram", "in_throgram", "in_imageograms", "in_histicle", "in_histometry", "in_glory", "in_blograms", "in_histrice", "in_historyogram", "in_historical", "in_History", "in_logor", "in_glograms", "in_Histogue", "in_Histrogram", "in_thograms", "in_plograms", "in_plogram", "in_Histog", "in_historyograms", "in_glogue", "in_pastometry", "in_historyor", "in_thrice", "in_historyog", "in_pastograms", "in_plog", "in_historyorical", "in_historyrogram", "in_Histogram", "in_historyrice", "in_histor", "in_Histrice", "in_logograms", "in_memogram", "in_memograms", "in_glogram", "in_Histometry", "in_plrogram", "in_histogue", "in_history"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_in_native_list_int32(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    test_native_list_integer_helper(data, unused,\n\n                                    USER_DEF_NATIVE_LIST_UNION_KIND_S32);\n\n}\n", "idx": 13494, "substitutes": {"data": ["done", "input", "array", "batch", "object", "style", "da", "a", "api", "test", "image", "missing", "devices", "buffer", "writer", "valid", "value", "alpha", "index", "iterator", "ad", "media", "loader", "options", "buf", "entry", "reader", "used", "result", "parent", "dat", "next", "Data", "inner", "function", "rule", "DATA", "cache", "empty", "class", "window", "xxx"], "unused": ["unavailable", " unavailable", " unuse", " Unavailable", "unasigned", "unuse", " Unuse", " Unused", "unaavailable", "unause", "unaused", "Unused", "Unsigned", "Unuse"]}}
{"project": "qemu", "commit_id": "353ab969730742b7392414d62f4ba9632e8cf22c", "target": 0, "func": "static void nbd_trip(void *opaque)\n\n{\n\n    NBDClient *client = opaque;\n\n    NBDExport *exp = client->exp;\n\n    NBDRequest *req;\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n    uint32_t command;\n\n\n\n    TRACE(\"Reading request.\");\n\n    if (client->closing) {\n\n        return;\n\n    }\n\n\n\n    req = nbd_request_get(client);\n\n    ret = nbd_co_receive_request(req, &request);\n\n    if (ret == -EAGAIN) {\n\n        goto done;\n\n    }\n\n    if (ret == -EIO) {\n\n        goto out;\n\n    }\n\n\n\n    reply.handle = request.handle;\n\n    reply.error = 0;\n\n\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n        goto error_reply;\n\n    }\n\n    command = request.type & NBD_CMD_MASK_COMMAND;\n\n    if (command != NBD_CMD_DISC && (request.from + request.len) > exp->size) {\n\n            LOG(\"From: %\" PRIu64 \", Len: %u, Size: %\" PRIu64\n\n            \", Offset: %\" PRIu64 \"\\n\",\n\n                    request.from, request.len,\n\n                    (uint64_t)exp->size, (uint64_t)exp->dev_offset);\n\n        LOG(\"requested operation past EOF--bad client?\");\n\n        goto invalid_request;\n\n    }\n\n\n\n    if (client->closing) {\n\n        /*\n\n         * The client may be closed when we are blocked in\n\n         * nbd_co_receive_request()\n\n         */\n\n        goto done;\n\n    }\n\n\n\n    switch (command) {\n\n    case NBD_CMD_READ:\n\n        TRACE(\"Request type is READ\");\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        ret = blk_pread(exp->blk, request.from + exp->dev_offset,\n\n                        req->data, request.len);\n\n        if (ret < 0) {\n\n            LOG(\"reading from file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Read %u byte(s)\", request.len);\n\n        if (nbd_co_send_reply(req, &reply, request.len) < 0)\n\n            goto out;\n\n        break;\n\n    case NBD_CMD_WRITE:\n\n        TRACE(\"Request type is WRITE\");\n\n\n\n        if (exp->nbdflags & NBD_FLAG_READ_ONLY) {\n\n            TRACE(\"Server is read-only, return error\");\n\n            reply.error = EROFS;\n\n            goto error_reply;\n\n        }\n\n\n\n        TRACE(\"Writing to device\");\n\n\n\n        ret = blk_pwrite(exp->blk, request.from + exp->dev_offset,\n\n                         req->data, request.len, 0);\n\n        if (ret < 0) {\n\n            LOG(\"writing to file failed\");\n\n            reply.error = -ret;\n\n            goto error_reply;\n\n        }\n\n\n\n        if (request.type & NBD_CMD_FLAG_FUA) {\n\n            ret = blk_co_flush(exp->blk);\n\n            if (ret < 0) {\n\n                LOG(\"flush failed\");\n\n                reply.error = -ret;\n\n                goto error_reply;\n\n            }\n\n        }\n\n\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_DISC:\n\n        TRACE(\"Request type is DISCONNECT\");\n\n        errno = 0;\n\n        goto out;\n\n    case NBD_CMD_FLUSH:\n\n        TRACE(\"Request type is FLUSH\");\n\n\n\n        ret = blk_co_flush(exp->blk);\n\n        if (ret < 0) {\n\n            LOG(\"flush failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    case NBD_CMD_TRIM:\n\n        TRACE(\"Request type is TRIM\");\n\n        ret = blk_co_discard(exp->blk, (request.from + exp->dev_offset)\n\n                                       / BDRV_SECTOR_SIZE,\n\n                             request.len / BDRV_SECTOR_SIZE);\n\n        if (ret < 0) {\n\n            LOG(\"discard failed\");\n\n            reply.error = -ret;\n\n        }\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    default:\n\n        LOG(\"invalid request type (%u) received\", request.type);\n\n    invalid_request:\n\n        reply.error = EINVAL;\n\n    error_reply:\n\n        if (nbd_co_send_reply(req, &reply, 0) < 0) {\n\n            goto out;\n\n        }\n\n        break;\n\n    }\n\n\n\n    TRACE(\"Request/Reply complete\");\n\n\n\ndone:\n\n    nbd_request_put(req);\n\n    return;\n\n\n\nout:\n\n    nbd_request_put(req);\n\n    client_close(client);\n\n}\n", "idx": 13504, "substitutes": {"opaque": ["ospacity", "Opaque", "OPasso", "oppaques", "oppacity", "opac", "oppaque", "ospaques", "opaques", "OPaques", "opacity", "OPacity", "OPac", "ospaque", "ospac", "oppac", "ospasso", "OPaque", "Opacity", "Opac", "opasso", "Opasso"], "client": ["port", "remote", "call", "connect", "cm", "queue", "service", "input", "core", "config", "pc", "cdn", "Client", "local", "api", "connection", "manager", "public", "image", "project", "contact", "con", "session", "server", "patch", "conn", "open", "plugin", "net", "resource", "cli", "http", "socket", "co", "parent", "address", "export", "c", "ac", "ce", "cmd", "cod", "cell", "host", "cache", "gui", "pattern", "window", "prefix", "bird", "util", "contract", "cl", "ctx"], "req": ["transfer", "rr", "call", "proc", "dq", "queue", "art", "config", "jp", "def", "msg", "er", "fun", "respond", "progress", "user", "ref", "sq", "Request", "app", "patch", "conf", "fr", "quest", "conn", "form", "download", "rec", "grab", "resource", "info", "rb", "require", "rx", "http", "ext", "data", "qt", "reader", "requ", "tar", "query", "spec", "ry", "cb", "ur", "q", "cmd", "load", "rt", "pro", "resp", "exec", "r", "qq", "cache", "get", "seq", "dr", "res", "reg", "cur", "ctx", "err"], "request": ["remote", "child", "hello", "event", "project", "method", "model", "report", "server", "frame", "rec", "claim", "reader", "requ", "change", "order", "message", "call", "received", "reference", "lease", "writer", "QUEST", "session", "peer", "parse", "instance", "resource", "require", "data", "result", "item", "route", "create", "r", "header", "consumer", "transfer", "queue", "xml", "complete", "config", "current", "press", "task", "test", "buffer", "Request", "demand", "view", "subject", "query", "type", "re", "post", "record", "input", "response", "worker", "search", "enter", "object", "name", "er", "user", "job", "quest", "parent", "next", "rule", "q", "resp", "callback"], "reply": ["notice", "transfer", "remote", "rr", "record", "call", "part", "rev", "service", "sync", "response", "delete", "back", " replies", "child", "msg", "connection", "respond", "answer", "send", "status", "module", "buffer", "err", "comment", "report", "server", "Reply", "force", "frame", "parse", "rec", "bot", "info", "match", "base", "entry", "result", "store", "address", "query", "proxy", "route", "shell", "reason", "ry", "next", "maybe", "link", "write", "resp", "repl", "cache", "prefix", "order", "post", "apply", "replace", "message"], "ret": ["pet", "en", "art", "val", "def", "gt", "prot", "status", "str", "obj", "mem", "dev", "rb", "fin", "old", "bf", "att", "cat", "out", "fail", "RET", "ft", "rev", "part", "id", "rets", "arg", "det", "key", "error", "pass", "ut", "mt", "data", "result", "url", "arr", "res", "reg", "rf", "flag", "alt", "let", "format", "fun", "ref", "lit", "valid", "conn", "bot", "info", "Ret", "rl", "nt", "re", "rt", "rep", "aud", "no", "bit", "err", "response", "tmp", "code", "back", "pt", "feat", "lt", "match", "success", "resp", "db", "pat", "len", "opt"], "command": ["bug", "action", "format", "service", "response", "automatic", "code", "style", "sudo", "msg", "connection", "name", "directory", "send", "event", "operation", "project", "module", "buffer", "method", "sequence", "model", "comment", "commit", "script", "password", "clear", "version", "handler", "direction", "resource", "three", "Command", "callback", "component", "length", "mode", "magic", "query", "timeout", "route", "reason", "type", "attribute", "target", "md", "function", "cmd", "resp", "sent", "template", "pattern", "comm", "power", "delay", "communication", "git", "which", "message"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_register_reset(QEMUResetHandler *func, void *opaque)\n\n{\n\n    QEMUResetEntry *re = qemu_mallocz(sizeof(QEMUResetEntry));\n\n\n\n    re->func = func;\n\n    re->opaque = opaque;\n\n    TAILQ_INSERT_TAIL(&reset_handlers, re, entry);\n\n}\n", "idx": 13513, "substitutes": {"func": ["args", "proc", "pkg", "unc", "amd", "pc", "val", "code", "name", "fun", "fp", "fn", "job", "package", "conn", "obj", "super", "handler", "rb", "rx", "buf", "data", "entry", "f", "rl", "parser", "cb", "function", "attr", "rule", "cmd", "cf", "aux", "wrapper", "exec", "ack", "r", "src", "work", "wrap", "lambda", "addr", "apply", "ctx", "go", "callback"], "opaque": ["opace", " opaques", "oppaco", "ipesc", "opesc", "oppesc", "operaco", "ipaco", "oppacity", "oacity", "oaques", "oaque", "hopaques", "oppaque", "operacity", "opericit", "hopaque", "opaco", "opaques", "oicit", "operaque", " opicit", "ipacity", "hopace", "opacity", "ipaque", "operque", "operesc", " opque", "opque", " opacity", "oace", "hopacity", "oque", " opace", "opicit"], "re": ["record", "ret", "bre", "rev", "ru", "reply", "reb", "array", "response", "ere", "ren", "rs", "pre", "g", "rg", "ref", "cre", "fr", "parse", " rec", "rec", "e", "rew", "resource", "entry", "Rec", "rm", "reset", "arr", "ry", "per", "ro", "change", "rule", "rt", "r", "resp", "cache", "ae", "Re", "ar", "real", "dr", "res", "rel", "reg", "rem", "gre", "RE", "replace"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "void stl_phys_notdirty(hwaddr addr, uint32_t val)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n        io_mem_write(section->mr, addr, val, 4);\n\n    } else {\n\n        unsigned long addr1 = (memory_region_get_ram_addr(section->mr)\n\n                               & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        stl_p(ptr, val);\n\n\n\n        if (unlikely(in_migration)) {\n\n            if (!cpu_physical_memory_is_dirty(addr1)) {\n\n                /* invalidate code */\n\n                tb_invalidate_phys_page_range(addr1, addr1 + 4, 0);\n\n                /* set dirty bit */\n\n                cpu_physical_memory_set_dirty_flags(\n\n                    addr1, (0xff & ~CODE_DIRTY_FLAG));\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 13517, "substitutes": {"addr": ["ord", "Address", "rr", "pkg", "vr", "amp", "part", "ha", "work", "arm", "rc", "config", "pc", "amd", "art", "id", "oa", "name", "align", "rn", "x", "ref", "str", "module", "ace", "err", "node", "loc", "ld", "v", "uri", "ad", "adr", "mr", "layer", "info", "rx", "pointer", "data", "acl", "address", "rm", "pair", "url", "route", "arr", "offset", "attr", "md", "rt", "r", "dd", "host", "nr", "seq", "src", "pos", "dr", "ar", "usr", "alias", "len", "rage", "filename", "alloc", "index", "coord"], "val": ["ret", "tx", "slot", "inter", "pc", " value", "pt", "def", "VAL", "eval", "x", "ref", "unit", "buffer", "vol", "loc", "valid", "v", "value", "grad", "ind", "rx", "buf", "data", "ext", "byte", "base", "ault", "ay", "ol", "arr", "all", "ival", "Val", "seq", "al", "sel", "reg", "el", "pos", "len", "vals", "alloc", "index"], "ptr": ["port", "proc", "slice", "fd", "inter", "tr", "rc", "pc", "code", "id", "pt", "ref", "ace", "xp", "loc", "br", "adr", "ind", "p", "buf", "pointer", "data", "inst", "length", "pend", "point", "address", "pair", "offset", "attr", "eth", "r", "Ptr", "pr", "src", "dr", "pos", "pad", "rot", "alloc", "index"], "section": ["area", "port", "child", "image", "module", "loc", "server", "sections", "offset", "sc", "sub", "tag", "division", "vision", "part", "slice", "array", "container", "lc", "ment", "comment", "script", "session", "storage", "sector", "group", "version", "instance", "socket", "data", "entry", "route", "ion", "function", "layout", "core", "Section", "small", "service", "config", "account", "connection", "large", "option", "character", "fat", "member", "package", "element", "sec", "site", "address", "sel", "channel", "location", "root", "sect", "search", "shadow", "position", "patch", "job", "region", "size", "plugin", "se", "component", "parent", "pair", "definition", "esc", "environment"]}}
{"project": "FFmpeg", "commit_id": "6f1ec38ce2193d3d4cacd87edb452c6d7ba751ec", "target": 0, "func": "static void compute_antialias_float(MPADecodeContext *s,\n\n                              GranuleDef *g)\n\n{\n\n    float *ptr;\n\n    int n, i;\n\n\n\n    /* we antialias only \"long\" bands */\n\n    if (g->block_type == 2) {\n\n        if (!g->switch_point)\n\n            return;\n\n        /* XXX: check this for 8000Hz case */\n\n        n = 1;\n\n    } else {\n\n        n = SBLIMIT - 1;\n\n    }\n\n\n\n    ptr = g->sb_hybrid + 18;\n\n    for(i = n;i > 0;i--) {\n\n        float tmp0, tmp1;\n\n        float *csa = &csa_table_float[0][0];\n\n#define FLOAT_AA(j)\\\n\n        tmp0= ptr[-1-j];\\\n\n        tmp1= ptr[   j];\\\n\n        ptr[-1-j] = tmp0 * csa[0+4*j] - tmp1 * csa[1+4*j];\\\n\n        ptr[   j] = tmp0 * csa[1+4*j] + tmp1 * csa[0+4*j];\n\n\n\n        FLOAT_AA(0)\n\n        FLOAT_AA(1)\n\n        FLOAT_AA(2)\n\n        FLOAT_AA(3)\n\n        FLOAT_AA(4)\n\n        FLOAT_AA(5)\n\n        FLOAT_AA(6)\n\n        FLOAT_AA(7)\n\n\n\n        ptr += 18;\n\n    }\n\n}\n", "idx": 13524, "substitutes": {"s": ["sys", "ses", "m", "service", "sync", "sg", "fs", "rs", "cs", "S", "si", "sq", "ps", "ss", "p", "e", "sec", "gs", "c", "ns", "parser", "sc", "ssl", "services", "ds", "r", "css"], "g": ["ge", "m", "self", "bc", "d", "t", "sg", "l", "G", "ig", "h", "eg", "gh", "gas", "v", "gu", "gl", "w", "group", "u", "gm", "p", "e", "gg", "k", "b", "j", "f", "gs", "cfg", "c", "gam", "gen", "q", "ga", "gp"], "ptr": ["ff", "aj", "trace", "fd", "t", "tmp", "tr", "jp", "code", "shift", "pt", "ctr", "sp", "xt", "xp", "eger", "fp", "loc", "ii", "buff", "np", "dy", "z", "ind", "size", "p", "e", "pointer", "ext", "j", "length", "inst", "f", "rw", "pair", "fe", "arr", "xff", "ne", "offset", "attr", "nt", "r", "Ptr", "src", "dr", "pos", "addr", "len", "tp", "alloc", "index", "start"], "n": ["adj", "en", "m", "d", "t", "ni", "in", "l", "un", "N", "a", "nn", "nb", "x", "o", "w", "z", "u", "size", "p", "e", "an", "nc", "k", "b", "Ns", "min", "j", "f", "nu", "c", "ns", "ne", "nt", "network", "r", "nr", "num", "span", "len", "pn", "index"], "i": ["qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "l", "ini", "iu", "gi", "oi", "io", "api", "ci", "x", "di", "si", "ie", "ii", "v", "o", "yi", "u", "z", "ind", "p", "e", "mi", "li", "k", "b", "multi", "j", "f", "ti", "c", "eni", "ji", "pi", "bi", "ori", "zi", "y"], "tmp0": ["temp00", "ptr50", "temp4", " tmp2", " tmp50", "tmp50", "temp0", "cp00", "tmp00", "cp2", "ptr2", "ptr1", " tmp4", "temp1", "mp4", "temp2", "mp0", "ptr0", "tmp2", "mp2", "cp0", "mp1", "temp50", "mp00", "cp1", "tmp4"], "tmp1": ["testone", "txt1", "test2", "mpone", "test1", " tmp2", "temp0", "txtone", "ptr2", "ptrone", "txt0", "tempone", "test0", "ptr1", " tmpone", "tmpone", "temp1", "temp2", "mp0", "ptr0", "tmp2", "mp2", "txt2", "mp1"], "csa": [" css", "casva", "casa", "casas", "dsas", "csva", "dss", "cass", " csva", "css", "dsa", " csas", "dsva", "csas"]}}
{"project": "qemu", "commit_id": "97679527bf2f002225d08cfb93f840cef449ac0e", "target": 1, "func": "PCIBus *i440fx_init(PCII440FXState **pi440fx_state, int *piix3_devfn, qemu_irq *pic, int ram_size)\n\n{\n\n    DeviceState *dev;\n\n    PCIBus *b;\n\n    PCIDevice *d;\n\n    I440FXState *s;\n\n    PIIX3State *piix3;\n\n\n\n    dev = qdev_create(NULL, \"i440FX-pcihost\");\n\n    s = FROM_SYSBUS(I440FXState, sysbus_from_qdev(dev));\n\n    b = pci_bus_new(&s->busdev.qdev, NULL, 0);\n\n    s->bus = b;\n\n    qdev_init_nofail(dev);\n\n\n\n    d = pci_create_simple(b, 0, \"i440FX\");\n\n    *pi440fx_state = DO_UPCAST(PCII440FXState, dev, d);\n\n\n\n    piix3 = DO_UPCAST(PIIX3State, dev,\n\n                                 pci_create_simple(b, -1, \"PIIX3\"));\n\n    piix3->pic = pic;\n\n    pci_bus_irqs(b, piix3_set_irq, pci_slot_get_pirq, piix3, 4);\n\n    (*pi440fx_state)->piix3 = piix3;\n\n\n\n    *piix3_devfn = piix3->dev.devfn;\n\n\n\n    ram_size = ram_size / 8 / 1024 / 1024;\n\n    if (ram_size > 255)\n\n        ram_size = 255;\n\n    (*pi440fx_state)->dev.config[0x57]=ram_size;\n\n\n\n    return b;\n\n}\n", "idx": 13548, "substitutes": {"pi440fx_state": ["pi440FX_config", "pi440fxtstate", "pi440fx_size", "pi440f_states", "pi440fy_config", "pi440fw_state", "pi440fx_states", "pi440f_stat", "pi440fx_style", "pi440fx__parent", "pi440fxtstyle", "pi440fx__config", "pi440fxtdriver", "pi440fy_state", "pi440fx_driver", "pi440fw_stat", "pi440FX_parent", "pi440fx__state", "pi440f_config", "pi440fx_stat", "pi440FX_err", "pi440f_state", "pi440fx_config", "pi440fw_driver", "pi440fw_style", "pi440fx__err", "pi440fy_size", "pi440fx_parent", "pi440FX_state", "pi440fx_err", "pi440fxtstat"], "piix3_devfn": ["piix3__devfs", "piix3_devicefn", "piix3_diskfn", "piix3__divf", "piix3__divpath", "piix3_divpath", "piix3__devicefs", "piix3_devpath", "piix3__divfn", "piix3_evfs", "piix3__devfn", "piix3_devfs", "piix3_pubpath", "piix3_divf", "piix3_devicefs", "piix3_devf", "piix3__devicef", "piix3_pubf", "piix3_diskfs", "piix3__devf", "piix3_devicef", "piix3__devpath", "piix3_devicepath", "piix3__devicefn", "piix3_divfn", "piix3_evfn", "piix3_diskf", "piix3_evf", "piix3_pubfn"], "pic": ["sys", "bin", "wire", "bc", "cam", "sync", "config", "pc", "xi", "pins", "lic", "iv", "lc", "pick", "ig", "misc", "image", "di", "Pic", "biz", "bus", "fn", "pid", "feat", "lib", "quad", "doc", "ku", "fi", "mini", "sec", "du", "img", "picture", "fin", "dot", "feature", "pict", "pin", "pi", "ic", "bi", "miss", "cache", "mac", "prop", "nic", "dim", "fc"], "ram_size": ["gram_shape", "ramingize", "ram_scale", "gram_ize", "ram64data", "poolensized", "ram_SIZE", "RAM_size", "mem_size", "ramensized", "ram1width", "ram_shape", "ram_num", "poolendata", "memory_type", "mem_ize", "gram_scale", "gram_weight", "poolenize", "gram_size", "memoryentype", "memory_size", "memoryensize", "memory_strength", "ram64ize", "ramingweight", "ram_sized", "RAM_width", "ram64sized", "ram_ize", "ram1ize", "ram64size", "ramenize", "ram_weight", "ramingscale", "ramenstrength", "pool_size", "ram_rate", "ram_type", "ramentype", "memoryenrate", "RAM_ize", "mem_scale", "ramendata", "ramenrate", "ram64scale", "ramingsize", "pool_sized", "ram_width", "memoryenstrength", "ram_data", "mem_num", "memory_rate", "pool_ize", "poolensize", "RAM_SIZE", "gram_type", "ram1size", "ram_strength", "ramensize", "ram64num", "pool_data", "ram1SIZE"], "dev": ["device", "development", "i", "priv", "def", "rad", "ve", "gd", "pub", "mem", "ver", "driver", "spec", "c", "serv", "dem", "dd", "prop", "debug", "plug", "m", "cam", "g", "serial", "di", "bus", "comment", "error", "w", "u", "img", "du", "data", "dot", "r", "ev", "reg", "ch", "game", "init", "app", "conn", "der", "ad", "info", "sd", "f", "diff", "block", "DEV", "cur", "err", "bug", "da", "die", "user", "Dev", "mod", "v", "conf", "gu", "var", "av", "de", "p", "dc", "ds", "db"], "b": ["bug", "m", "bin", "bc", "t", "bs", "l", "bb", "i", "fb", "val", "a", "bd", "g", "hub", "h", "nb", "x", "bus", "v", "br", "o", "w", "obj", "u", "ad", "p", "e", "be", "boot", "rb", "pb", "k", "base", "sb", "wb", "bf", "f", "n", "gb", "bh", "ab", "c", "cb", "bg", "r", "db", "B", "lb", "bl", "y"], "d": ["dh", "D", "m", "t", "l", "i", "id", "g", "v", "o", "w", "dy", "u", "p", "e", "z", "ad", "dict", "k", "sd", "driver", "j", "n", "f", "c", "dt", "dc", "md", "ds", "dd", "db"], "s": ["sys", "m", "self", "t", "bs", "fs", "l", "i", "a", "g", "cs", "S", "os", "si", "js", "sq", "v", "ps", "ss", "o", "w", "u", "p", "e", "se", "sb", "sd", "n", "f", "gs", "state", "c", "ns", "is", "sc", "ssl", "sv", "sl", "r", "ds", "sa", "su"], "piix3": ["pix3", "piIX23", "piica23", "piox3", "xiox33", "xiix3", "pix03", "piIX1", "piix23", "piix15", "pox1", "piq03", "apiix3", "piius03", "piiusdiv", "piix03", "xiix03", "pifix03", "xiix2", "px3", "piq2", "piiskthird", "piox31", "xiox3", "paius3", "pix1", "pifixthird", "piius15", "piix31", "piIX31", "apiox3", "xiox03", "pIX03", "pi__33", "pifixdiv", "piius6", "piix2", "paixdiv", "pIX23", "apiix23", "paius03", "piixed23", "piIX2", "piiusthird", "piiskdiv", "apiox23", "piIX33", "piox15", "pox2", "paiusthird", "px2", "paix03", "piox1", "pifix15", "xiix33", "xiox2", "pi__3", "piixdiv", "paix3", "piica03", "piox23", "piq1", "paixthird", "piq3", "pix2", "pix23", "piisk03", "apiix15", "piox03", "pox15", "piixed03", "pIX31", "piix33", "piixthird", "piius3", "piIX03", "pix15", "piix6", "pox3", "apiox03", "piisk15", "pifix3", "pix6", "piox33", "piisk6", "pifix23", "px03", "apiox15", "piixed31", "piisk3", "piixed3", "piIX3", "pIX3", "piica15", "pi__2", "paiusdiv", "pox03", "piix1", "pox6", "piica3", "pix31", "piox2", "piox6", "pi__03", "apiix03"]}}
{"project": "qemu", "commit_id": "c24a8a0b6dad5a33d84f5fb846edb28c43312c71", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554, "substitutes": {"env": ["args", "en", "context", "enh", "esp", "enc", "ea", "cv", "config", "code", "priv", "iv", "eu", "ah", "scope", "estate", "v", "conn", "np", "loader", "stage", "e", "viron", "exc", "buf", "eng", "state", "next", "end", "esc", "ep", "here", "et", "ev", "db", "ec", "emb", "window", "environment", "ef", "err"], "a": ["area", "ada", "ua", "sta", "as", "ha", "ca", "ea", "ia", "i", "da", "oa", "ta", "api", "ama", "aa", "alpha", "an", "ba", "p", "e", "A", "pa", "data", "b", "f", "ma", "address", "asha", "c", "ac", "va", "aux", "ata", "ae", "sa", "ga", "ar"]}}
{"project": "FFmpeg", "commit_id": "73789b85a759f3874112618120194e1712d7adcd", "target": 0, "func": "int ff_dca_core_parse(DCACoreDecoder *s, uint8_t *data, int size)\n\n{\n\n    int ret;\n\n\n\n    s->ext_audio_mask = 0;\n\n    s->xch_pos = s->xxch_pos = s->x96_pos = 0;\n\n\n\n    if ((ret = init_get_bits8(&s->gb, data, size)) < 0)\n\n        return ret;\n\n    s->gb_in = s->gb;\n\n\n\n    if ((ret = parse_frame_header(s)) < 0)\n\n        return ret;\n\n    if ((ret = alloc_sample_buffer(s)) < 0)\n\n        return ret;\n\n    if ((ret = parse_frame_data(s, HEADER_CORE, 0)) < 0)\n\n        return ret;\n\n    if ((ret = parse_optional_info(s)) < 0)\n\n        return ret;\n\n\n\n    // Workaround for DTS in WAV\n\n    if (s->frame_size > size && s->frame_size < size + 4)\n\n        s->frame_size = size;\n\n\n\n    if (ff_dca_seek_bits(&s->gb, s->frame_size * 8)) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Read past end of core frame\\n\");\n\n        if (s->avctx->err_recognition & AV_EF_EXPLODE)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13555, "substitutes": {"s": ["i", "rs", "qs", "h", "js", "si", "server", "ps", "spec", "c", "is", "args", "m", "self", "bis", "d", "t", "sg", "sync", "fs", "ins", "sym", "or", "g", "cs", "es", "session", "w", "u", "b", "sf", "ns", "ops", "ks", "sys", "parts", "service", "hs", "os", "sets", "o", "ms", "e", "http", "sb", "features", "f", "services", "ls", "comments", "ses", "as", "l", "a", "er", "S", "settings", "its", "uns", "sq", "conf", "ss", "p", "se", "ions", "gs", "parser", "xs", "stats", "ssl", "ds", "su", "ts", "us", "ims", "vs"], "data": ["device", "draw", "ui", "bin", "as", "slice", "input", "d", "i", "memory", "da", "sample", "a", "binary", "source", "image", "x", "buffer", "raw", "o", "p", "buf", "base", "mode", "f", "dat", "address", "Data", "body", "scale", "DATA", "cache", "window", "len", "in", "start"], "size": ["ui", "en", "small", "cm", "sized", "code", "shape", "name", "Size", "use", "unit", "capacity", "sum", "loc", "form", "ize", "six", "sec", "time", "from", "mode", "n", "length", "address", "number", "SIZE", "offset", "general", "scale", "empty", "fee", "iz", "len"], "ret": ["reply", "art", "val", "def", "gt", "status", "obj", "active", "rb", "af", "base", "bf", "att", "cat", "cb", "out", "fail", "get", "RET", "off", "debug", "over", "ft", "rev", "part", "rc", "id", "gc", "rets", "arg", "det", "key", "error", "pass", "mt", "result", "url", "arr", "res", "reg", "flag", "run", "red", "alt", "let", "format", "fun", "ref", "pret", "lit", "valid", "value", "conn", "Ret", "f", "reset", "nt", "re", "rt", "rep", "usr", "replace", "back", "bad", "job", "success", "match", "op", "fit", "resp", "len", "opt"]}}
{"project": "qemu", "commit_id": "9745807191a81c45970f780166f44a7f93b18653", "target": 1, "func": "static void gen_mulu(DisasContext *dc, TCGv dest, TCGv srca, TCGv srcb)\n\n{\n\n    TCGv sr_cy = tcg_temp_new();\n\n\n\n    tcg_gen_muls2_tl(dest, sr_cy, srca, srcb);\n\n    tcg_gen_setcondi_tl(TCG_COND_NE, sr_cy, sr_cy, 0);\n\n\n\n    tcg_gen_deposit_tl(cpu_sr, cpu_sr, sr_cy, ctz32(SR_CY), 1);\n\n\n\n    gen_ove_cy(dc, sr_cy);\n\n    tcg_temp_free(sr_cy);\n\n}\n", "idx": 13556, "substitutes": {"dc": ["context", "mc", "cam", "bc", "uc", "d", "ca", "cow", "director", "rc", "cc", "pc", "config", "fd", "cdn", "cm", "da", "DC", "lc", "cci", "cr", "conn", "cd", "cot", "doc", "nc", "tc", "c", "cca", "df", "design", "dt", "jc", "fc", "ac", "sc", "cf", " DC", "icc", "vc", "db", "ec", "CC", "dm"], "dest": ["path", " Dest", "d", "dist", "core", "config", "cdn", "orig", "home", "ctr", "source", "di", "txt", "loc", "dir", "nw", "gd", "de", "dev", "desc", "du", "wb", "dep", "route", "cb", "target", "sc", "Dest", "src", "rest", "decl", "destroy", "nom", "wd", "usr", "coord", "comb"], "srca": ["destb", "srcA", "desta", "sourceA", " srcA", "destA", "sourceb", "sourcea"], "srcb": ["scb", "scv", "rcv", "rca", "destB", "rcb", " srcv", "scB", "destb", "srcB", "sca", "desta", " srcB", "srcv", "rcB"]}}
{"project": "FFmpeg", "commit_id": "5e53486545726987ab4482321d4dcf7e23e7652f", "target": 0, "func": "static int decode_init_mp3on4(AVCodecContext * avctx)\n\n{\n\n    MP3On4DecodeContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    if ((avctx->extradata_size < 2) || (avctx->extradata == NULL)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Codec extradata missing or too short.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    s->chan_cfg = (((unsigned char *)avctx->extradata)[1] >> 3) & 0x0f;\n\n    s->frames = mp3Frames[s->chan_cfg];\n\n    if(!s->frames) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid channel config number.\\n\");\n\n        return -1;\n\n    }\n\n    avctx->channels = mp3Channels[s->chan_cfg];\n\n\n\n    /* Init the first mp3 decoder in standard way, so that all tables get builded\n\n     * We replace avctx->priv_data with the context of the first decoder so that\n\n     * decode_init() does not have to be changed.\n\n     * Other decoders will be inited here copying data from the first context\n\n     */\n\n    // Allocate zeroed memory for the first decoder context\n\n    s->mp3decctx[0] = av_mallocz(sizeof(MPADecodeContext));\n\n    // Put decoder context in place to make init_decode() happy\n\n    avctx->priv_data = s->mp3decctx[0];\n\n    decode_init(avctx);\n\n    // Restore mp3on4 context pointer\n\n    avctx->priv_data = s;\n\n    s->mp3decctx[0]->adu_mode = 1; // Set adu mode\n\n\n\n    /* Create a separate codec/context for each frame (first is already ok).\n\n     * Each frame is 1 or 2 channels - up to 5 frames allowed\n\n     */\n\n    for (i = 1; i < s->frames; i++) {\n\n        s->mp3decctx[i] = av_mallocz(sizeof(MPADecodeContext));\n\n        s->mp3decctx[i]->compute_antialias = s->mp3decctx[0]->compute_antialias;\n\n        s->mp3decctx[i]->adu_mode = 1;\n\n        s->mp3decctx[i]->avctx = avctx;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 13571, "substitutes": {"avctx": ["mpcu", "afcms", "ajcu", "airctx", "avnc", "avsci", "avcas", "akcmp", "akci", "navctx", "apcmp", "akpkg", "afconfig", "ajbc", "avcu", " avcontext", "avecoll", "afbc", "avecontext", "navcontext", "mpconn", "avconfig", "abctx", "afcas", "afconn", "absci", "abcontext", "ajcontext", "abcmp", "apcontext", "afcf", "navcmp", "aftx", "afnc", "AVcontext", "avectx", "aktx", "abcu", "afcu", "awcu", "afcontext", "avcoll", "navsci", "avbc", "akctx", "avconn", "afci", "avenc", "amcontext", "ajcoll", "akcontext", "avetx", "afsci", " avkw", "awconfig", "aircas", "mpctx", "avkw", "afcb", "avesci", "avecb", "abpkg", "ajci", "avci", "avcf", "ajsci", "afkw", "avecu", "avtx", "mpcontext", "akcf", "AVsci", "ajctx", "apcu", "aveconfig", "aveci", "avcms", "avecf", "aircontext", "afctx", "abcb", "amcas", "Avconn", "afcoll", "ajnc", "avebc", "Avcontext", "afpkg", "AVcmp", "Avctx", "amctx", "awctx", "avcmp", "aircms", "AVcu", "afcmp", "apctx", "amcms", "avcontext", "avcb", "aveconn", "Avkw", " avconn", "AVctx", "awcontext", "avpkg"], "s": ["rs", "qs", "h", "js", "si", "ps", "params", "spec", "c", "is", "states", "aws", "args", "m", "self", "t", "sync", "sg", "fs", "ins", "sym", "sup", "g", "cs", "es", "full", "session", "w", "u", "members", "sf", "b", "ns", "ops", "r", "ks", "sys", "parts", "service", "your", "os", "sets", "o", "ms", "e", "sb", "f", "ans", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "S", "this", "its", "uns", "sq", "conf", "ss", "strings", "p", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "ims", "vs"], "i": ["hi", "qi", "it", "ui", "adi", "I", "d", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "a", "io", "oi", "iv", "api", "mu", "ci", "manager", "di", "x", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "ind", "p", "e", "mini", "fi", "info", "cli", "li", "k", "b", "mi", "ix", "j", "multi", "n", "f", "phi", "ti", "ip", "c", "anti", "ji", "pi", "chi", "im", "bi", "ri", "ori", "y", "index"]}}
{"project": "qemu", "commit_id": "1acae9f22380a03b468a29a3cc035b280610b5e4", "target": 0, "func": "_syscall4(int,sys_utimensat,int,dirfd,const char *,pathname,\n\n          const struct timespec *,tsp,int,flags)\n\n#endif\n\n#endif /* CONFIG_UTIMENSAT  */\n\n\n\n#ifdef CONFIG_INOTIFY\n\n#include <sys/inotify.h>\n\n\n\n#if defined(TARGET_NR_inotify_init) && defined(__NR_inotify_init)\n\nstatic int sys_inotify_init(void)\n\n{\n\n  return (inotify_init());\n\n}\n", "idx": 13589, "substitutes": {}}
{"project": "qemu", "commit_id": "8dc7a7725bd6db2aa7e3c09b49bc21a1a25f40cb", "target": 1, "func": "static void curl_readv_bh_cb(void *p)\n\n{\n\n    CURLState *state;\n\n    int running;\n\n\n\n    CURLAIOCB *acb = p;\n\n    BDRVCURLState *s = acb->common.bs->opaque;\n\n\n\n    qemu_bh_delete(acb->bh);\n\n    acb->bh = NULL;\n\n\n\n    size_t start = acb->sector_num * SECTOR_SIZE;\n\n    size_t end;\n\n\n\n    // In case we have the requested data already (e.g. read-ahead),\n\n    // we can just call the callback and be done.\n\n    switch (curl_find_buf(s, start, acb->nb_sectors * SECTOR_SIZE, acb)) {\n\n        case FIND_RET_OK:\n\n            qemu_aio_release(acb);\n\n            // fall through\n\n        case FIND_RET_WAIT:\n\n            return;\n\n        default:\n\n            break;\n\n    }\n\n\n\n    // No cache found, so let's start a new request\n\n    state = curl_init_state(s);\n\n    if (!state) {\n\n        acb->common.cb(acb->common.opaque, -EIO);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->start = 0;\n\n    acb->end = (acb->nb_sectors * SECTOR_SIZE);\n\n\n\n    state->buf_off = 0;\n\n    g_free(state->orig_buf);\n\n    state->buf_start = start;\n\n    state->buf_len = acb->end + s->readahead_size;\n\n    end = MIN(start + state->buf_len, s->len) - 1;\n\n    state->orig_buf = g_malloc(state->buf_len);\n\n    state->acb[0] = acb;\n\n\n\n    snprintf(state->range, 127, \"%zd-%zd\", start, end);\n\n    DPRINTF(\"CURL (AIO): Reading %d at %zd (%s)\\n\",\n\n            (acb->nb_sectors * SECTOR_SIZE), start, state->range);\n\n    curl_easy_setopt(state->curl, CURLOPT_RANGE, state->range);\n\n\n\n    curl_multi_add_handle(s->multi, state->curl);\n\n\n\n    /* Tell curl it needs to kick things off */\n\n    curl_multi_socket_action(s->multi, CURL_SOCKET_TIMEOUT, 0, &running);\n\n}\n", "idx": 13604, "substitutes": {"p": ["m", "pkg", "t", "pc", "jp", "i", "pre", "h", "pp", "ap", "fp", "pid", "patch", "ps", "o", "bp", "np", "pb", "pl", "pointer", "b", "pa", "op", "n", "f", "wp", "c", "pin", "pe", "per", "pi", "cp", "r", "param", "ar", "P", "tp"], "state": ["area", "port", "art", "event", "use", "new", "status", "str", "ace", "old", "stat", "list", "grade", "is", "change", "sl", "states", "work", "tag", "st", "message", "args", "self", "part", "slice", "t", "sync", "seed", "manager", "comment", "session", "key", "error", "check", "parse", "resource", "ose", "pe", "body", "ce", "cal", "cache", "al", "core", "service", "config", "private", "style", "source", "sp", "os", "State", "update", "scope", "output", "conn", "o", "view", "e", "info", "j", "address", "close", "STATE", "type", "the", "pos", "no", "post", "err", "date", "bug", "root", "l", "back", "name", "ass", "range", "settings", "user", "ss", "set", "open", "se", "k", "rate", "match", "parent", "rule", "last", "start"], "running": [" performing", "reading", "runner", "done", " sleeping", "using", " starting", "tmp", "id", "current", "name", "bound", "playing", "stable", "unit", "starting", "available", "live", "valid", " continuing", "testing", "finished", "active", "working", " remaining", "standing", "base", "connected", "mode", "Running", "result", "padding", "ending", "blocking", "type", "loop", " Running", "runs", " blocking", "cur", "run", "thread", "loading"], "acb": ["aka", "ACsb", " acB", "accbr", "acab", "icl", "acbe", "acbas", "acbr", "axb", "ackbb", " aca", "acn", "icf", "Acbb", "accn", "axmb", "ackmb", "ocbas", "accab", "accp", "ecab", "axbb", "aclf", "acbb", "Acl", "ACbe", "ecv", "icv", "acca", "ancf", " acbs", "aclp", "acssb", "ecf", "ancb", " acjob", "accbb", "acgb", "ACp", "ecp", "ocsb", "acv", "ancbb", "accl", "arcbb", "acsbb", "icgb", "ecn", " acbb", " acurl", "acfb", "acp", "ocbb", "accf", " acgb", "akbb", "acsb", "arcab", "ackb", "icbs", "ocl", "arcb", "acsbas", "Acb", "ecsb", "acB", " acl", "akbs", "ocb", "ocf", "akf", "ocp", "arcsb", "akb", "ocbr", "ancbs", "icbb", "icB", "accjob", "icb", "acmb", "aclbb", "acl", "Acf", "icsb", "ACf", "ocfb", "ancl", "ACbb", "AcB", " acf", " acsb", "ancbe", "acbs", "ACn", "ecB", "accb", "acurl", "ACl", "icp", " acbe", "ackfb", "ecl", "akbe", "ocB", "ecb", "aclurl", "acjob", "aca", "accsb", "accbe", "aclgb", "ocbs", "icbr", " acp", "ocv", "ACb", "ocmb", "acf", "Acp", "ecbb", "ecbs", "acll", "ACurl", "axfb", "accbas", "acljob", "aclb"], "s": ["secondary", "south", "args", "sys", "ses", "self", "bis", "service", "sync", "sg", "t", "fs", "bs", "d", "sym", "rs", "a", "g", "cs", "S", "settings", "os", "new", "its", "js", "si", "scope", "sq", "es", "session", "secure", "server", "ps", "ss", "conf", "o", "params", "e", "http", "site", "b", "sf", "sb", "n", "f", "stat", "gs", "spec", "c", "ns", "is", "stats", "ssl", "sl", "states", "services", "ds", "r", "sa", "ls", "us", "ts", "ks"], "end": ["head", "edge", "en", "ff", "after", "END", "id", "mid", "End", "range", "row", "event", "use", "post", "nd", "update", "append", "until", "v", "begin", "limit", "set", "open", "w", "size", "ind", "stop", "z", "enable", "e", "ad", "then", "ail", "b", "entry", "est", "old", "length", "ension", "add", "line", "ending", "address", "close", "inner", "offset", "change", "one", "all", "last", "ended", "rest", "off", "pos", "el", "run", "len", "max", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "3a83b2461e4ce9d48ad6ab037eb14569d0e53506", "target": 1, "func": "static int dnxhd_encode_rdo(AVCodecContext *avctx, DNXHDEncContext *ctx)\n\n{\n\n    int lambda, up_step, down_step;\n\n    int last_lower = INT_MAX, last_higher = 0;\n\n    int x, y, q;\n\n\n\n    for (q = 1; q < avctx->qmax; q++) {\n\n        ctx->qscale = q;\n\n        avctx->execute2(avctx, dnxhd_calc_bits_thread, NULL, NULL, ctx->m.mb_height);\n\n    }\n\n    up_step = down_step = 2<<LAMBDA_FRAC_BITS;\n\n    lambda = ctx->lambda;\n\n\n\n    for (;;) {\n\n        int bits = 0;\n\n        int end = 0;\n\n        if (lambda == last_higher) {\n\n            lambda++;\n\n            end = 1; // need to set final qscales/bits\n\n        }\n\n        for (y = 0; y < ctx->m.mb_height; y++) {\n\n            for (x = 0; x < ctx->m.mb_width; x++) {\n\n                unsigned min = UINT_MAX;\n\n                int qscale = 1;\n\n                int mb = y*ctx->m.mb_width+x;\n\n                for (q = 1; q < avctx->qmax; q++) {\n\n                    unsigned score = ctx->mb_rc[q][mb].bits*lambda+(ctx->mb_rc[q][mb].ssd<<LAMBDA_FRAC_BITS);\n\n                    if (score < min) {\n\n                        min = score;\n\n                        qscale = q;\n\n                    }\n\n                }\n\n                bits += ctx->mb_rc[qscale][mb].bits;\n\n                ctx->mb_qscale[mb] = qscale;\n\n                ctx->mb_bits[mb] = ctx->mb_rc[qscale][mb].bits;\n\n            }\n\n            bits = (bits+31)&~31; // padding\n\n            if (bits > ctx->frame_bits)\n\n                break;\n\n        }\n\n        //av_dlog(ctx->m.avctx, \"lambda %d, up %u, down %u, bits %d, frame %d\\n\",\n\n        //        lambda, last_higher, last_lower, bits, ctx->frame_bits);\n\n        if (end) {\n\n            if (bits > ctx->frame_bits)\n\n                return -1;\n\n            break;\n\n        }\n\n        if (bits < ctx->frame_bits) {\n\n            last_lower = FFMIN(lambda, last_lower);\n\n            if (last_higher != 0)\n\n                lambda = (lambda+last_higher)>>1;\n\n            else\n\n                lambda -= down_step;\n\n            down_step *= 5; // XXX tune ?\n\n            up_step = 1<<LAMBDA_FRAC_BITS;\n\n            lambda = FFMAX(1, lambda);\n\n            if (lambda == last_lower)\n\n                break;\n\n        } else {\n\n            last_higher = FFMAX(lambda, last_higher);\n\n            if (last_lower != INT_MAX)\n\n                lambda = (lambda+last_lower)>>1;\n\n            else if ((int64_t)lambda + up_step > INT_MAX)\n\n                return -1;\n\n            else\n\n                lambda += up_step;\n\n            up_step = FFMIN((int64_t)up_step*5, INT_MAX);\n\n            down_step = 1<<LAMBDA_FRAC_BITS;\n\n        }\n\n    }\n\n    //av_dlog(ctx->m.avctx, \"out lambda %d\\n\", lambda);\n\n    ctx->lambda = lambda;\n\n    return 0;\n\n}\n", "idx": 13635, "substitutes": {"avctx": ["ahcontext", "Avcontext", "aircli", "evctx", "afkb", "AVcmp", "averctrl", "Avctx", "airctx", "AVcli", "avcmp", "navcu", "avcas", "Avcmp", "AVcontext", "avcli", "navctx", "evctrl", "ahcas", "AVcu", "evconn", "ahctx", "AVconn", "averctx", "AVctrl", "evcu", "afcontext", "akctrl", "aircmp", "avcu", "evcontext", "avkb", "avcontext", "aircontext", "akctx", "avconn", "Avcli", "Avcas", "navconn", "afctx", "ahkb", "AVctx", "navcontext", "avercas", "akcas", "Avkb", "navctrl", "afctrl", "avctrl", "afcas", "akcontext", "avercontext"], "ctx": ["tx", "bc", "qs", "auc", "wcs", "cmp", "loc", "ck", "concept", "scl", "c", "cb", "cas", "sc", "cp", "context", "cam", "sync", "rc", "cc", "cdn", "gc", "lc", "cs", "conv", "cn", "cms", "client", "console", "instance", "kt", "anc", "ce", "exec", "kb", "mac", "xc", "history", "support", "git", "cv", "ca", "config", "connection", "ci", "wx", "scope", "conn", "kw", "nc", "co", "qt", "acl", "cf", "prefix", "hw", "pkg", "cm", "qa", "utils", "Context", "ctrl", "act", "sq", "cli", "component", "cus", "wp", "cca", "crit", "cu", "sci", "cmd", "vc", "qq", "css"], "lambda": ["aka", "area", "xb", "ja", "i", " beta", "loc", "boost", "params", "lo", "dB", "kl", "handler", " lam", "base", "phi", "expr", "aux", "ga", "func", "hi", "partial", "slice", "mas", "api", "ema", "lc", "sha", " delta", "closure", "appa", "data", "wb", "length", "ma", "function", "mega", "layout", "lam", "python", "mu", "elta", "LA", "ta", "variable", "aa", "alpha", "quad", "pha", "acl", " omega", "lu", "wa", "delay", "lim", "xxx", "qa", "l", "da", "binary", "a", " la", "beta", "xa", "abc", "phase", "la", "ba", "p", "cli", "aw", "pi", "scale", "xy", "abi", "always"], "up_step": ["up67scale", "down_scale", "up_phase", "up_diff", "up67step", "up67steps", "up_sync", "down_steps", "down_sync", "up_steps", "down_phase", "up67sync", "down_diff", "up_scale"], "down_step": ["down_scale", "downfscale", "up_weight", "downxstep", "downxsteps", "down_size", "downfSTEP", "down_steps", "downfstep", "downerstep", "up_steps", "up_sample", "downersample", "downersteps", "downxsample", "down_walk", "downxslice", "up_walk", "down_sample", "downerslice", "down_STEP", "down_weight", "up_size", "up_scale", "down_slice", "up_STEP", "downfsteps", "up_slice"], "x": ["m", "en", "tx", "qa", "d", "t", "xi", "id", "l", "i", "code", "ex", "ci", "h", "fx", "px", "v", "o", "w", "yx", "dx", "z", "ady", "u", "p", "e", "rx", "k", "max", "ix", "b", "j", "n", "f", "xx", "ax", "c", "pe", "X", "one", "r", "xc", "xy", "wy", "xxx", "ph", "index"], "y": ["ny", "yt", "m", "ch", "qa", "d", "t", "ys", "sky", "id", "i", "g", "ey", "h", "py", "gy", "cy", "ym", "ye", "o", "w", "dy", "yi", "z", "ady", "p", "e", "yr", "k", "b", "min", "yp", "j", "yo", "n", "f", "oy", "c", "vy", "ay", "ry", "Y", "ya", "ky", "xy", "yy", "wy", "ty", "zy", "sy"], "q": ["bug", "qi", "depth", "m", "ch", "qa", "dq", "d", "queue", "t", "id", "ue", "i", "quant", "row", "g", "qs", "req", "question", "h", "pg", "cy", "gh", "mm", "sq", "quick", "ct", "v", "mb", "quest", "w", "qu", "check", "view", "z", "u", "quad", "p", "time", "eq", "k", "ck", "ix", "qt", "j", "requ", "f", "count", "n", "query", "c", "end", "pe", "iq", "type", "ph", "r", "com", "sh", "qq", "que", "quality", "core", "Q", "max", "cl"]}}
{"project": "FFmpeg", "commit_id": "5a2645cafeca1c2207ac55cc831c3349572a82ed", "target": 1, "func": "static int find_and_decode_index(NUTContext *nut)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    uint64_t tmp, end;\n\n    int i, j, syncpoint_count;\n\n    int64_t filesize = avio_size(bc);\n\n    int64_t *syncpoints;\n\n    int8_t *has_keyframe;\n\n    int ret = AVERROR_INVALIDDATA;\n\n\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n\n        return ret;\n\n    }\n\n\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    ffio_read_varlen(bc); // max_pts\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n\n    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);\n\n    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));\n\n    if (!syncpoints || !has_keyframe)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < syncpoint_count; i++) {\n\n        syncpoints[i] = ffio_read_varlen(bc);\n\n        if (syncpoints[i] <= 0)\n\n            goto fail;\n\n        if (i)\n\n            syncpoints[i] += syncpoints[i - 1];\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        int64_t last_pts = -1;\n\n        for (j = 0; j < syncpoint_count;) {\n\n            uint64_t x = ffio_read_varlen(bc);\n\n            int type   = x & 1;\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n", "idx": 13636, "substitutes": {"nut": ["bt", "nat", "cart", "ft", "orn", "uts", "cm", "oven", "t", "art", "unc", "config", "cdn", "nit", "ctr", "bd", "orb", "cue", "cit", "cn", "txt", "ctor", "ct", "nuts", "cr", "feat", "ut", "annot", "adr", "cot", "rb", "boot", "kt", "qt", "n", "ocr", "dt", "gat", "anc", "cb", "nt", "UT", "cont", "nv", "rt", "org", "ou", "core", "rot", "ctx"], "s": ["sys", "ses", "service", "t", "d", "sg", "sat", "bs", "utils", "g", "cs", "settings", "os", "si", "sq", "session", "server", "storage", "ss", "conf", "o", "p", "e", "sb", "sf", "b", "n", "f", "gs", "spec", "c", "ns", "is", "sac", "sn", "sc", "stats", "ssl", "sv", "sl", "ops", "services", "ds", "sh", "r", "sa", "su", "soc", "ls", "sub", "ts", "space", "ctx"], "bc": ["bt", "clus", "mc", "uc", "cm", "ca", "bs", "rc", "cc", "pc", "config", "bb", "fb", "lic", "bn", "bd", "gc", "lc", "BC", "auc", "cms", "bus", "ct", "bitcoin", "cr", "lib", "cot", "oc", "gg", "ib", "rb", "pb", "nc", "sb", "tc", "cus", "wb", "bf", "acl", "gb", "c", "cca", "dc", "jc", "anc", "cb", "sc", "CBC", "cf", "org", "exec", "db", "soc", "ec", "fc", "cl", "ctx"], "tmp": ["zip", "proc", "ff", "stuff", "array", "dist", "batch", "config", "t", "mp", "fb", "api", "front", "test", "py", "st", "buffer", "fp", "v", "buff", "output", "client", "np", "obj", "stop", "temp", "rb", "pack", "buf", "data", "diff", "next", "dt", "offset", "cb", "nt", "elt", "uv", "duration", "cache", "pos", "vt", "pad", "len", "max", "start"], "end": ["edge", "en", "after", "END", "len", "enc", "fd", "t", "d", "id", "End", "send", "event", "h", "append", "v", "begin", "set", "open", "w", "ad", "size", "stop", "z", "e", "page", "f", "result", "ending", "close", "offset", "all", "r", "last", "ended", "rest", "pos", "num", "tail", "run", "post", "max", "index", "start"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "ai", "ni", "xi", "id", "iu", "ini", "gi", "l", "io", "my", "api", "g", "ci", "ki", "lc", "h", "di", "si", "ie", "init", "ii", "key", "v", "uri", "o", "yi", "z", "ind", "u", "p", "e", "fi", "info", "mini", "mi", "li", "b", "ix", "multi", "n", "f", "phi", "ti", "ip", "c", "eni", "is", "inner", "type", "ji", "pi", "im", "bi", "ri", "ik", "ami", "y", "abi", "index", "start"], "j": ["jj", "uj", "adj", "m", "ch", "aj", "d", "t", "sync", "ja", "jp", "l", "g", "syn", "dj", "h", "js", "ii", "v", "o", "w", "z", "ind", "u", "p", "e", "k", "li", "b", "n", "f", "c", "ji", "offset", "q", "r", "J", "pos", "num", "y", "ij", "index", "start"], "syncpoint_count": ["syncPoint_size", "syncpoint2cache", "syncpoints_size", "syncpointer_base", "syncpoint2size", "syncpoints_count", "syncpointer_list", "syncPoint_max", "syncpoint2sum", "syncblock_size", "syncpoints_sum", "syncpoints2sum", "syncpoint_code", "syncpoint_all", "syncpoints2size", "syncPoint_count", "syncblock_all", "syncpoint_max", "syncblock_count", "syncblock_Count", "syncPoint_Count", "syncpoint2count", "syncpointer_count", "syncPoint_cache", "syncpoint_sum", "syncpoints_cache", "syncpoint_size", "syncpointer_max", "syncpoints2cache", "syncpoint_Count", "syncpointer_length", "syncpoint_cache", "syncPoint_code", "syncpoints2count", "syncpoint_length", "syncpoint_list", "syncpoint_base", "syncPoint_length", "syncpointer_size"], "syncpoints": ["yncpointers", " syncobjects", "synports", " syncpointers", " syncframes", "ynclines", "sharepoints", " syncitems", "locklines", "sharepoint", "synitems", "sharePoints", "yncPoints", "fillpoints", "syncports", "synPoints", "synpoint", "syncobjects", "fillports", "syncpointers", "shareframes", "fillobjects", "lockPoints", "SyncPoints", "lockframes", "yncpoint", "yncports", " synclines", "yncpoints", "lockports", " syncports", "yncobjects", "syncPoints", " syncPoints", " syncpoint", "syncframes", "Syncitems", "lockpoints", "lockpoint", "Syncpoint", "syncitems", "syncpoint", "synlines", "synclines", "synframes", "fillpointers", "synpoints", "Syncpoints"], "has_keyframe": ["has_myframes", "has_keyframes", "has_mypoint", "has_skyframe", "has_keyfram", "has_anyframes", "has_skyframes", "has_anypoint", "has_anyframe", "has_Keyframe", "has_myframe", "has_skyfram", "has_Keyfram", "has_anyfram", "has_Keyframes", "has_keypoint"], "x": ["m", "tx", "d", "sync", "t", "xml", "batch", "xi", "id", "ww", "ex", "wx", "h", "fx", "xa", "xp", "v", "w", "dx", "z", "u", "p", "rx", "data", "ix", "b", "n", "f", "cross", "xx", "rax", "ax", "c", "xs", "xes", "type", "X", "sex", "lex", "xc", "work", "xy", "xxx", "y", "ctx", "bit", "index"]}}
{"project": "qemu", "commit_id": "b0f74c87a1dbd6b0c5e4de7f1c5cb40197e3fbe9", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667, "substitutes": {"s": ["south", "sys", "ses", "self", "m", "service", "sync", "sg", "fs", "i", "sym", "rs", "g", "cs", "qs", "S", "settings", "os", "h", "its", "sets", "si", "es", "js", "sq", "session", "ps", "ss", "conf", "w", "params", "p", "e", "sb", "b", "tests", "f", "gs", "c", "ns", "is", "stats", "ssl", "ops", "services", "ds", "sie", "states", "ls", "ts", "comments", "ks", "aws"]}}
{"project": "qemu", "commit_id": "8cf07dcbe7691dbe4f47563058659dba6ef66b05", "target": 1, "func": "int drive_init(struct drive_opt *arg, int snapshot, void *opaque)\n\n{\n\n    char buf[128];\n\n    char file[1024];\n\n    char devname[128];\n\n    char serial[21];\n\n    const char *mediastr = \"\";\n\n    BlockInterfaceType type;\n\n    enum { MEDIA_DISK, MEDIA_CDROM } media;\n\n    int bus_id, unit_id;\n\n    int cyls, heads, secs, translation;\n\n    BlockDriverState *bdrv;\n\n    BlockDriver *drv = NULL;\n\n    QEMUMachine *machine = opaque;\n\n    int max_devs;\n\n    int index;\n\n    int cache;\n\n    int bdrv_flags, onerror;\n\n    int drives_table_idx;\n\n    char *str = arg->opt;\n\n    static const char * const params[] = { \"bus\", \"unit\", \"if\", \"index\",\n\n                                           \"cyls\", \"heads\", \"secs\", \"trans\",\n\n                                           \"media\", \"snapshot\", \"file\",\n\n                                           \"cache\", \"format\", \"serial\", \"werror\",\n\n                                           NULL };\n\n\n\n    if (check_params(params, str) < 0) {\n\n         fprintf(stderr, \"qemu: unknown parameter '%s' in '%s'\\n\",\n\n                         buf, str);\n\n         return -1;\n\n    }\n\n\n\n    file[0] = 0;\n\n    cyls = heads = secs = 0;\n\n    bus_id = 0;\n\n    unit_id = -1;\n\n    translation = BIOS_ATA_TRANSLATION_AUTO;\n\n    index = -1;\n\n    cache = 3;\n\n\n\n    if (machine->use_scsi) {\n\n        type = IF_SCSI;\n\n        max_devs = MAX_SCSI_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"scsi\");\n\n    } else {\n\n        type = IF_IDE;\n\n        max_devs = MAX_IDE_DEVS;\n\n        pstrcpy(devname, sizeof(devname), \"ide\");\n\n    }\n\n    media = MEDIA_DISK;\n\n\n\n    /* extract parameters */\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"bus\", str)) {\n\n        bus_id = strtol(buf, NULL, 0);\n\n\tif (bus_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid bus id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"unit\", str)) {\n\n        unit_id = strtol(buf, NULL, 0);\n\n\tif (unit_id < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid unit id\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"if\", str)) {\n\n        pstrcpy(devname, sizeof(devname), buf);\n\n        if (!strcmp(buf, \"ide\")) {\n\n\t    type = IF_IDE;\n\n            max_devs = MAX_IDE_DEVS;\n\n        } else if (!strcmp(buf, \"scsi\")) {\n\n\t    type = IF_SCSI;\n\n            max_devs = MAX_SCSI_DEVS;\n\n        } else if (!strcmp(buf, \"floppy\")) {\n\n\t    type = IF_FLOPPY;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"pflash\")) {\n\n\t    type = IF_PFLASH;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"mtd\")) {\n\n\t    type = IF_MTD;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"sd\")) {\n\n\t    type = IF_SD;\n\n            max_devs = 0;\n\n        } else if (!strcmp(buf, \"virtio\")) {\n\n            type = IF_VIRTIO;\n\n            max_devs = 0;\n\n\t} else if (!strcmp(buf, \"xen\")) {\n\n\t    type = IF_XEN;\n\n            max_devs = 0;\n\n\t} else {\n\n            fprintf(stderr, \"qemu: '%s' unsupported bus type '%s'\\n\", str, buf);\n\n            return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"index\", str)) {\n\n        index = strtol(buf, NULL, 0);\n\n\tif (index < 0) {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid index\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cyls\", str)) {\n\n        cyls = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"heads\", str)) {\n\n        heads = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"secs\", str)) {\n\n        secs = strtol(buf, NULL, 0);\n\n    }\n\n\n\n    if (cyls || heads || secs) {\n\n        if (cyls < 1 || cyls > 16383) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical cyls number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (heads < 1 || heads > 16) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical heads number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n        if (secs < 1 || secs > 63) {\n\n            fprintf(stderr, \"qemu: '%s' invalid physical secs number\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"trans\", str)) {\n\n        if (!cyls) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' trans must be used with cyls,heads and secs\\n\",\n\n                    str);\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"none\"))\n\n            translation = BIOS_ATA_TRANSLATION_NONE;\n\n        else if (!strcmp(buf, \"lba\"))\n\n            translation = BIOS_ATA_TRANSLATION_LBA;\n\n        else if (!strcmp(buf, \"auto\"))\n\n            translation = BIOS_ATA_TRANSLATION_AUTO;\n\n\telse {\n\n            fprintf(stderr, \"qemu: '%s' invalid translation type\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"media\", str)) {\n\n        if (!strcmp(buf, \"disk\")) {\n\n\t    media = MEDIA_DISK;\n\n\t} else if (!strcmp(buf, \"cdrom\")) {\n\n            if (cyls || secs || heads) {\n\n                fprintf(stderr,\n\n                        \"qemu: '%s' invalid physical CHS format\\n\", str);\n\n\t        return -1;\n\n            }\n\n\t    media = MEDIA_CDROM;\n\n\t} else {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid media\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"snapshot\", str)) {\n\n        if (!strcmp(buf, \"on\"))\n\n\t    snapshot = 1;\n\n        else if (!strcmp(buf, \"off\"))\n\n\t    snapshot = 0;\n\n\telse {\n\n\t    fprintf(stderr, \"qemu: '%s' invalid snapshot option\\n\", str);\n\n\t    return -1;\n\n\t}\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"cache\", str)) {\n\n        if (!strcmp(buf, \"off\") || !strcmp(buf, \"none\"))\n\n            cache = 0;\n\n        else if (!strcmp(buf, \"writethrough\"))\n\n            cache = 1;\n\n        else if (!strcmp(buf, \"writeback\"))\n\n            cache = 2;\n\n        else {\n\n           fprintf(stderr, \"qemu: invalid cache option\\n\");\n\n           return -1;\n\n        }\n\n    }\n\n\n\n    if (get_param_value(buf, sizeof(buf), \"format\", str)) {\n\n       if (strcmp(buf, \"?\") == 0) {\n\n            fprintf(stderr, \"qemu: Supported formats:\");\n\n            bdrv_iterate_format(bdrv_format_print, NULL);\n\n            fprintf(stderr, \"\\n\");\n\n\t    return -1;\n\n        }\n\n        drv = bdrv_find_format(buf);\n\n        if (!drv) {\n\n            fprintf(stderr, \"qemu: '%s' invalid format\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (arg->file == NULL)\n\n        get_param_value(file, sizeof(file), \"file\", str);\n\n    else\n\n        pstrcpy(file, sizeof(file), arg->file);\n\n\n\n    if (!get_param_value(serial, sizeof(serial), \"serial\", str))\n\n\t    memset(serial, 0,  sizeof(serial));\n\n\n\n    onerror = BLOCK_ERR_STOP_ENOSPC;\n\n    if (get_param_value(buf, sizeof(serial), \"werror\", str)) {\n\n        if (type != IF_IDE && type != IF_SCSI && type != IF_VIRTIO) {\n\n            fprintf(stderr, \"werror is no supported by this format\\n\");\n\n            return -1;\n\n        }\n\n        if (!strcmp(buf, \"ignore\"))\n\n            onerror = BLOCK_ERR_IGNORE;\n\n        else if (!strcmp(buf, \"enospc\"))\n\n            onerror = BLOCK_ERR_STOP_ENOSPC;\n\n        else if (!strcmp(buf, \"stop\"))\n\n            onerror = BLOCK_ERR_STOP_ANY;\n\n        else if (!strcmp(buf, \"report\"))\n\n            onerror = BLOCK_ERR_REPORT;\n\n        else {\n\n            fprintf(stderr, \"qemu: '%s' invalid write error action\\n\", buf);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* compute bus and unit according index */\n\n\n\n    if (index != -1) {\n\n        if (bus_id != 0 || unit_id != -1) {\n\n            fprintf(stderr,\n\n                    \"qemu: '%s' index cannot be used with bus and unit\\n\", str);\n\n            return -1;\n\n        }\n\n        if (max_devs == 0)\n\n        {\n\n            unit_id = index;\n\n            bus_id = 0;\n\n        } else {\n\n            unit_id = index % max_devs;\n\n            bus_id = index / max_devs;\n\n        }\n\n    }\n\n\n\n    /* if user doesn't specify a unit_id,\n\n     * try to find the first free\n\n     */\n\n\n\n    if (unit_id == -1) {\n\n       unit_id = 0;\n\n       while (drive_get_index(type, bus_id, unit_id) != -1) {\n\n           unit_id++;\n\n           if (max_devs && unit_id >= max_devs) {\n\n               unit_id -= max_devs;\n\n               bus_id++;\n\n           }\n\n       }\n\n    }\n\n\n\n    /* check unit id */\n\n\n\n    if (max_devs && unit_id >= max_devs) {\n\n        fprintf(stderr, \"qemu: '%s' unit %d too big (max is %d)\\n\",\n\n                        str, unit_id, max_devs - 1);\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * ignore multiple definitions\n\n     */\n\n\n\n    if (drive_get_index(type, bus_id, unit_id) != -1)\n\n        return -2;\n\n\n\n    /* init */\n\n\n\n    if (type == IF_IDE || type == IF_SCSI)\n\n        mediastr = (media == MEDIA_CDROM) ? \"-cd\" : \"-hd\";\n\n    if (max_devs)\n\n        snprintf(buf, sizeof(buf), \"%s%i%s%i\",\n\n                 devname, bus_id, mediastr, unit_id);\n\n    else\n\n        snprintf(buf, sizeof(buf), \"%s%s%i\",\n\n                 devname, mediastr, unit_id);\n\n    bdrv = bdrv_new(buf);\n\n    drives_table_idx = drive_get_free_idx();\n\n    drives_table[drives_table_idx].bdrv = bdrv;\n\n    drives_table[drives_table_idx].type = type;\n\n    drives_table[drives_table_idx].bus = bus_id;\n\n    drives_table[drives_table_idx].unit = unit_id;\n\n    drives_table[drives_table_idx].onerror = onerror;\n\n    drives_table[drives_table_idx].drive_opt_idx = arg - drives_opt;\n\n    strncpy(drives_table[drives_table_idx].serial, serial, sizeof(serial));\n\n    nb_drives++;\n\n\n\n    switch(type) {\n\n    case IF_IDE:\n\n    case IF_SCSI:\n\n    case IF_XEN:\n\n        switch(media) {\n\n\tcase MEDIA_DISK:\n\n            if (cyls != 0) {\n\n                bdrv_set_geometry_hint(bdrv, cyls, heads, secs);\n\n                bdrv_set_translation_hint(bdrv, translation);\n\n            }\n\n\t    break;\n\n\tcase MEDIA_CDROM:\n\n            bdrv_set_type_hint(bdrv, BDRV_TYPE_CDROM);\n\n\t    break;\n\n\t}\n\n        break;\n\n    case IF_SD:\n\n        /* FIXME: This isn't really a floppy, but it's a reasonable\n\n           approximation.  */\n\n    case IF_FLOPPY:\n\n        bdrv_set_type_hint(bdrv, BDRV_TYPE_FLOPPY);\n\n        break;\n\n    case IF_PFLASH:\n\n    case IF_MTD:\n\n    case IF_VIRTIO:\n\n        break;\n\n    case IF_COUNT:\n\n        abort();\n\n    }\n\n    if (!file[0])\n\n        return -2;\n\n    bdrv_flags = 0;\n\n    if (snapshot) {\n\n        bdrv_flags |= BDRV_O_SNAPSHOT;\n\n        cache = 2; /* always use write-back with snapshot */\n\n    }\n\n    if (cache == 0) /* no caching */\n\n        bdrv_flags |= BDRV_O_NOCACHE;\n\n    else if (cache == 2) /* write-back */\n\n        bdrv_flags |= BDRV_O_CACHE_WB;\n\n    else if (cache == 3) /* not specified */\n\n        bdrv_flags |= BDRV_O_CACHE_DEF;\n\n    if (bdrv_open2(bdrv, file, bdrv_flags, drv) < 0) {\n\n        fprintf(stderr, \"qemu: could not open disk image %s\\n\",\n\n                        file);\n\n        return -1;\n\n    }\n\n    if (bdrv_key_required(bdrv))\n\n        autostart = 0;\n\n    return drives_table_idx;\n\n}\n", "idx": 13672, "substitutes": {"arg": ["args", "proc", "call", "slot", "amp", "input", "enc", "pc", "val", "g", "ig", "pg", "rg", "ref", "ace", "parse", "ad", "oc", "doc", "mor", "ang", "ag", "match", "op", "arc", "inc", "arr", "par", "ac", "argument", "gen", "Arg", "exec", "param", "mac", "ar", "tag", "reg", "flag"], "snapshot": ["capvision", "picshot", "captvision", "snapimage", "picimage", "captimage", "picformat", "capshot", "capformat", "captshot", "capimage", "snapvision", "snapformat", "picvision", "captformat"], "opaque": ["optonymous", "opbc", "mpacity", "mpaque", "operbc", "oponymous", "opac", "operacity", " opbc", "optaque", "mpac", "mpbc", "operaque", "optac", "opacity", "operonymous", " opac", " opacity", " oponymous", "operac", "optacity"], "buf": ["bridge", "runner", "proc", "bc", "batch", "uint", "msg", "pool", "cmp", "loc", "br", "begin", "rb", "box", "cb", "text", "num", "prop", "func", "context", "ru", "array", "rc", "home", "ctr", "uf", "conv", "bus", "doc", "img", "fi", "data", "wb", "b", "result", "arr", "cap", "header", "filename", "path", "queue", "fd", "cv", "config", "fb", "null", "ref", "buffer", "lit", "bag", "stage", "grab", "exc", "desc", "bh", "holder", "block", "cf", "cur", "ctx", "fw", "vec", "pkg", "uc", "code", "buff", "la", "car", "cmd", "src", "seq"], "file": ["channel", "path", "port", "queue", "input", "array", "id", "profile", "object", "binary", "name", "source", "image", "cpu", "pool", "buffer", "unit", "bus", "model", "dir", "files", "uri", "info", "family", "base", "byte", "mode", "f", "parent", "line", "block", "body", "book", "File", "db", "filename"], "devname": ["devnum", "defline", "evName", "diskno", "evkey", "camName", "devkey", "divnum", "diskName", "defno", "defName", "devicenum", "devicepath", "evid", "camno", "deviceName", "divName", "devicename", " devid", "diskname", "evline", "devName", "deviceno", "devline", " devkey", "camname", "devid", "evpath", "busname", "evname", "divname", "divno", "devpath", "busno", "camkey", "defname", " devno", "buspath", " devName", "deviceid", "evno", "defnum", "devno", "diskline"], "serial": ["toc", "device", "proc", " bus", "mount", "util", "extra", "status", "lang", "cmp", "model", "lit", "comment", "loc", "master", "uri", "pass", "dev", "pack", "mode", "mask", "parent", "spec", "command", "tag", "prefix", "controller"], "mediastr": ["medietrs", "mediustre", "datestl", "datastr", "mediestr", "mediestre", "datestrs", "mediustr", "datastrs", "datestr", "mediastrs", "mediastl", "datastre", "medietre", "mediustrs", "datestre", "mediustl", "datastl", "mediestrs", "medietl", "mediestl", "mediastre", "medietr"], "type": ["types", "Type", "port", "typ", "ype", "format", "part", "t", "config", "id", "code", "style", "name", "source", "image", "user", "unit", "method", "full", "TYPE", "comment", "position", "key", "like", "error", "model", "o", "role", "view", "size", "instance", "p", "time", " TYPE", "info", "resource", "pb", "family", "data", "parent", "state", "block", "pe", "rule", "link", "class", "tag", "off", "rel", "ty", "y"], "media": ["device", "port", "record", "m", "interface", "ype", "format", "medium", "i", "memory", "style", "connection", "source", "manager", "audio", "image", "vm", "java", "mod", "model", "method", "Media", "script", "package", "storage", "document", "resource", "data", "mode", "ma", "library", "music", "pi", "medi", "command", "language", "volume"], "bus_id": ["bus_name", "busElike", "unit_name", "unit_kid", "bus_like", "busEID", "busprelike", "bus_ids", " bus_like", "buspreID", " bus_ids", "unit_ids", " bus_ID", "unit_ip", " bus_name", "bus_ip", "bus_Id", "bus_sid", "busEname", "busEid", "unit_Id", "bus_ID", "bus_kid", "busprename", " bus_sid", "buspreid"], "unit_id": ["bus_name", "unit_Id", " unit_info", " unit_ident", "unitPkey", "unit_info", " unit_key", " unit_ids", "unit_ids", "unit_key", "unit_name", "unitPinfo", "unit_ident", " unit_name", "unitPname", "unitPid", "bus_Id"], "cyls": ["cedles", "tyles", "cfll", "cfls", "crl", "cedols", "cylas", "crls", "cyols", "cfols", "cyles", "tyls", "ryl", "rylas", "tyl", "cfles", " cyll", "tylas", "cyl", "cedls", "ryles", "cedll", "crles", " cyles", "ryls", " cyols", "crlas", "cyll"], "heads": ["types", "head", "blocks", "drivers", "workers", "docs", "locks", "loads", "pages", "tails", "devices", "opens", "sets", "rows", "stars", "checks", "files", "flags", "ids", "views", "jobs", "shots", "hook", "plugins", "sections", "tests", "lines", "frames", "offs", "outs", "links", "headers", "boards", "runs", "shows", "HEAD", "comments", "sticks"], "secs": ["secS", "secls", " Secsym", "execi", "secments", " Seci", "reqi", "SECs", "reqs", " secS", "reqments", "licls", "execs", "reqsym", "seci", " Secs", " secb", " secls", "licb", "execments", "SECS", " Secments", "secb", "execsym", "SECb", "licS", "secsym", "SECls", "lics"], "translation": ["port", "qa", "config", "val", "utils", "name", "settings", "border", "description", "option", "lang", "lit", "position", "loc", "conf", "late", "la", "version", "Translation", "info", "options", "resource", "base", "length", "trans", "ping", "offset", " translations", "text", "language", "layout", "pos", "prefix", "alias", "comments", "rot", "message"], "bdrv": ["bDrf", "bDrvs", "bstrf", "Bdrp", "Bdrvs", "bDrv", "BDrf", "BDrv", "Bdrv", "BDrvs", "bdrf", "bdrvs", "bstrvs", "bstrv", "Bdrf", "bDrp", "BDrp", "bdrp", "bstrp"], "drv": ["rdv", "srb", "Drb", "drva", "drb", "srp", "Drp", "rdb", "drp", "rdp", "srv", "srva", "Drv", "Drva", "rdva"], "machine": ["device", "bridge", "proc", "interface", "m", "mc", "service", "config", "mount", "memory", "container", "connection", "manager", "image", "vm", "unit", "bus", "model", "slave", "computer", "storage", "meta", "mem", "instance", "info", "engine", "Machine", "driver", "mode", "ma", "target", "process", "man", "mac", "template", "controller", "node"], "max_devs": ["max_evi", "max_diss", "max_devds", "max_avins", "max_reqds", "max_reqs", "max_compins", "max_devi", "max_devns", "max_devgroups", "max_deviceits", "max_avs", "max_disops", "max_avds", "max_evops", "max_disi", "max_mems", "max_compds", "max_evn", "max_memn", "max_evs", "max_evds", "max_reqn", "max_devits", "max_devices", "max_devicei", "max_disits", "max_evins", "max_evits", "max_evgroups", "max_devops", "max_comps", "max_devins", "max_reqgroups", "max_evns", "max_memds", "max_memgroups", "max_deviceops", "max_avns", "max_compns", "max_devn"], "index": ["toc", "Index", "bridge", "head", "action", "condition", "priority", "slice", "input", "config", "id", "level", "connection", "weight", "image", "unit", "buffer", "position", "loc", "error", "scan", "fix", "alpha", "view", "active", "version", "ticket", "info", "pointer", "axis", "flash", "length", "inc", "proxy", "offset", "loop", "miss", "pos", "num", "prefix", "len"], "cache": ["toc", "frac", "ignore", "slot", "sync", "batch", "config", "rc", "code", "child", "pre", "image", "Cache", "pool", "ref", "buffer", "cmp", "capacity", "comment", "session", "master", "conf", "race", "scan", "temp", "pack", "time", "pointer", "base", "count", "read", "acl", "parent", "global", "c", "timeout", "block", "cat", "ac", "ache", "tag", "lock", "prefix", "delay"], "bdrv_flags": ["bdrv_flag", "bdrv_bits", "bdrv2bits", "bdrva_flag", "bdrv2count", "bdrva_bits", "bdrv_count", "bdrva_flags", "bdrv2flags", "bdrv2flag", "bdrva_count"], "onerror": ["emererror", "errrr", "emerlock", "irror", "emerror", "onerrr", "irrr", "onerlock", "irerror", "errror", "emerrr", "errerror", "onererror", "errlock", "irlock"], "drives_table_idx": ["drives_table_idxs", "drives_table_Idz", "drives_table_idz", "drives_table_idxc", "drives_table_Idxs", "drives_table_sidx", "drives_table_sidz", "drives_table_Idx", "drives_table_sidxs", "drives_table_sidxc", "drives_table_Idxc"], "str": ["Str", "word", "vec", "proc", "format", "bc", "part", "enc", "tr", "config", "rs", "ctr", "msg", "name", "lc", "sp", "sr", "lit", "br", "fr", "var", "cr", "strings", "obj", "pass", "wr", "dict", "doc", "STR", "data", "car", "expr", "none", "ocr", "String", "spec", "url", "arr", "par", "cat", "text", "iter", "cf", "sl", "r", "exec", "empty", "dr", "usr", "st", "strip", "cl", "err"], "params": ["types", "args", "proc", "blocks", "parts", "array", "config", "extra", "rs", "req", "settings", "description", "ps", "conf", "obj", "names", "options", "info", "desc", "rb", "data", "base", "acl", "json", "parent", "url", "block", "par", "ams", "afi", "attr", "body", "ops", "param", "css", "pos", "prop", "vs", "opt", "ctx", "Parameters"]}}
{"project": "qemu", "commit_id": "217bfb445b54db618a30f3a39170bebd9fd9dbf2", "target": 1, "func": "static void gic_complete_irq(gic_state * s, int cpu, int irq)\n\n{\n\n    int update = 0;\n\n    int cm = 1 << cpu;\n\n    DPRINTF(\"EOI %d\\n\", irq);\n\n    if (s->running_irq[cpu] == 1023)\n\n        return; /* No active IRQ.  */\n\n    if (irq != 1023) {\n\n        /* Mark level triggered interrupts as pending if they are still\n\n           raised.  */\n\n        if (!GIC_TEST_TRIGGER(irq) && GIC_TEST_ENABLED(irq, cm)\n\n                && GIC_TEST_LEVEL(irq, cm) && (GIC_TARGET(irq) & cm) != 0) {\n\n            DPRINTF(\"Set %d pending mask %x\\n\", irq, cm);\n\n            GIC_SET_PENDING(irq, cm);\n\n            update = 1;\n\n        }\n\n    }\n\n    if (irq != s->running_irq[cpu]) {\n\n        /* Complete an IRQ that is not currently running.  */\n\n        int tmp = s->running_irq[cpu];\n\n        while (s->last_active[tmp][cpu] != 1023) {\n\n            if (s->last_active[tmp][cpu] == irq) {\n\n                s->last_active[tmp][cpu] = s->last_active[irq][cpu];\n\n                break;\n\n            }\n\n            tmp = s->last_active[tmp][cpu];\n\n        }\n\n        if (update) {\n\n            gic_update(s);\n\n        }\n\n    } else {\n\n        /* Complete the current running IRQ.  */\n\n        gic_set_running_irq(s, cpu, s->last_active[s->running_irq[cpu]][cpu]);\n\n    }\n\n}\n", "idx": 13706, "substitutes": {"s": ["i", "rs", "qs", "new", "si", "js", "times", "ps", "groups", "lines", "tests", "stat", "spec", "c", "is", "sv", "sl", "states", "m", "self", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "session", "u", "sf", "b", "ns", "ops", "r", "sie", "ks", "secondary", "sys", "parts", "service", "sets", "o", "e", "http", "site", "sb", "f", "state", "services", "ls", "comments", "ses", "l", "changes", "sites", "S", "settings", "this", "its", "uns", "sq", "v", "ss", "request", "p", "se", "plugins", "gs", "xs", "stats", "ssl", "ds", "su", "vs"], "cpu": ["proc", "mc", "course", "pixel", "module", "cmp", "fp", "screen", "gru", "server", "np", "count", "c", "cp", "num", "nic", "cpp", "chip", "gc", "lc", "cn", "vm", "uca", "campus", "loader", "GPU", " CPU", "lag", "clock", "cale", "cap", "cache", "xc", "mac", "lb", "core", "thread", "username", "consumer", "queue", "ilo", "config", "pc", "current", "connection", "ci", "uu", "unit", "px", "pid", "conn", "processor", "boot", "nc", "CPU", "site", "uci", "gpu", "lu", "loop", "net", "ctx", "node", "gp", "piece", "bench", "cm", "uc", "tmp", "worker", "name", "PC", "capacity", "performance", "computer", "rpm", "pu", "platform", "col", "cli", "component", "cu", "process", "network", "login", "pai", "css", "len"], "irq": ["ierqi", "ircle", "earquest", "irue", "hrqu", "irqa", "iriche", "IRquest", "irtq", "iriqa", "irtQ", "urqa", "airq", " irrc", "irtque", "irequal", "iriqu", "arinqu", "urqi", "ireQ", "ariqu", "irreq", "ariQ", "irinQ", "iriquest", "hrue", "irireq", "irinq", "irce", " irqu", "srue", "yrche", "arinqa", "arinquest", "ierq", "ierquest", "earQ", "rrque", "irrc", "earqu", "irtch", "srque", "irirc", "iriQ", "irqual", "ariq", "ironq", " irue", "airqa", "IRqi", "yrq", "irquest", "irch", "ierreq", "irique", "arique", "yrQ", "ironqu", "iraqu", " irqa", "irtcle", "irqi", "iraque", "yrque", "rrq", "irque", "srq", "ierqu", "IRche", "irQ", "earque", "irtqi", "irach", "airqu", "iraqual", "srqu", "ierQ", "urqu", "irtqa", "yrquest", "rrqa", "rrcle", " irQ", "urq", "airreq", "hrq", "irtqu", "iraqi", "iraqa", "iracle", "irtquest", "IRq", "irtqual", "irace", " irque", "irinqu", "irche", "irerc", "irache", " irquest", "ierqa", "irtche", "hrque", "IRque", "ireque", "earqa", "irece", "iraq", "ironch", "ireche", "IRQ", "irinque", "irtce", "arinq", "ireq", "earq", "ironque", "iriq", "irqu"]}}
{"project": "FFmpeg", "commit_id": "ca32f7f2083f9ededd1d9964ed065e0ad07a01e0", "target": 0, "func": "static void init_dequant8_coeff_table(H264Context *h){\n\n    int i,q,x;\n\n    const int transpose = (h->h264dsp.h264_idct8_add != ff_h264_idct8_add_c); //FIXME ugly\n\n    h->dequant8_coeff[0] = h->dequant8_buffer[0];\n\n    h->dequant8_coeff[1] = h->dequant8_buffer[1];\n\n\n\n    for(i=0; i<2; i++ ){\n\n        if(i && !memcmp(h->pps.scaling_matrix8[0], h->pps.scaling_matrix8[1], 64*sizeof(uint8_t))){\n\n            h->dequant8_coeff[1] = h->dequant8_buffer[0];\n\n            break;\n\n        }\n\n\n\n        for(q=0; q<52; q++){\n\n            int shift = div6[q];\n\n            int idx = rem6[q];\n\n            for(x=0; x<64; x++)\n\n                h->dequant8_coeff[i][q][transpose ? (x>>3)|((x&7)<<3) : x] =\n\n                    ((uint32_t)dequant8_coeff_init[idx][ dequant8_coeff_init_scan[((x>>1)&12) | (x&3)] ] *\n\n                    h->pps.scaling_matrix8[i][x]) << shift;\n\n        }\n\n    }\n\n}\n", "idx": 13712, "substitutes": {"h": ["hi", "m", "self", "hp", "hl", "context", "ha", "ih", "hr", "d", "oh", "t", "ssh", "l", "hhh", "home", "ah", "plus", "g", "hs", "this", "gh", "hash", "hu", "rh", "kh", "uh", "help", "hh", "u", "p", "he", "eh", "http", "b", "f", "th", "hm", "bh", "c", "end", "ch", "ht", "H", "sh", "host", "history", "cache", "work", "him", "ph", "hw", "ctx"], "i": ["qi", "ui", "I", "d", "t", "qa", "ai", "ni", "xi", "id", "iu", "l", "gi", "ini", "oi", "io", "a", "api", "g", "ci", "di", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "ind", "z", "p", "e", "fi", "mi", "li", "k", "ix", "b", "multi", "j", "count", "n", "f", "phi", "ti", "ip", "c", "chi", "pi", "bi", "ri", "zi", "y", "index"], "q": ["charge", "qi", "m", "ch", "qa", "d", "t", "dq", "id", "l", "shift", "quant", "g", "qs", "req", "question", "sq", "ii", "ct", "v", "patch", "force", "w", "qu", "check", "u", "z", "p", "e", "eq", "k", "ck", "b", "ix", "j", "qt", "f", "query", "ip", "c", "iq", "type", "r", "sh", "qq", "ph", "Q", "y"], "x": ["tx", "xe", "plus", "image", "dx", "c", "X", "lex", "work", "index", "m", "d", "t", "xi", "id", "g", "w", "u", "s", "data", "b", "xx", "ax", "pe", "r", "xc", "python", "wx", "fx", "sw", "xp", "px", "o", "qu", "z", "e", "rx", "ix", "j", "cross", "f", "sex", "wa", "ph", "Q", "xxx", "php", "qa", "any", "l", "code", "ww", "a", "name", "ex", "na", "v", "yx", "p", "k", "n", "xs", "xes", "qq", "ya", "xy", "zx", "y"]}}
{"project": "qemu", "commit_id": "9e0ff75e5158c7dbb65ee447382bbdf4cafbef8b", "target": 1, "func": "char *vnc_display_local_addr(const char *id)\n\n{\n\n    VncDisplay *vs = vnc_display_find(id);\n\n\n\n\n    return vnc_socket_local_addr(\"%s:%s\", vs->lsock);\n\n}", "idx": 13726, "substitutes": {"id": ["path", "bid", "d", "rid", "code", "i", "mid", "vid", "name", "Id", "image", "ident", "ref", "key", "pid", "ID", "ids", "ad", "sid", "p", "data", "address", "ip", "end", "type", "q", "aid", "addr", "kid", "index", "start"], "vs": ["vers", "env", "bs", "fs", "vp", "rs", "Vs", "vid", "forces", "verts", "cs", "qs", "values", "os", "sk", "vm", "es", "v", "ps", "ss", "views", "ves", "ms", "VS", "alls", "obs", "vis", "ums", "lines", "gs", "ns", "sv", "va", "als", "plays", "ds", "ls", "ils", "vals", "ks"]}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728, "substitutes": {}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_struct_nested(TestInputVisitorData *data,\n\n                                              const void *unused)\n\n{\n\n    UserDefTwo *udp = NULL;\n\n    Error *err = NULL;\n\n    Visitor *v;\n\n\n\n    v = validate_test_init(data, \"{ 'string0': 'string0', 'dict1': { 'string1': 'string1', 'dict2': { 'userdef1': { 'integer': 42, 'string': 'string', 'extra': [42, 23, {'foo':'bar'}] }, 'string2': 'string2'}}}\");\n\n\n\n    visit_type_UserDefTwo(v, NULL, &udp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefTwo(udp);\n\n}\n", "idx": 13734, "substitutes": {"data": ["database", "record", "m", "format", "input", "array", "d", "config", "i", "stream", "object", "style", "da", "a", "def", "api", "test", "writer", "error", "valid", "form", "o", "u", "rec", "p", "base", "reader", "f", "result", "parent", "dat", "c", "parser", "Data", "DATA", "empty", "post", "xxx", "message"], "unused": [" unbavailable", "Unuse", "unavailable", "Unchecked", "unchecked", " unbuse", "unuse", "Unavailable", " unavailable", " unuse", " unbused", "Unused", " unchecked", " unbchecked"], "udp": ["urps", "sdps", "urpi", "urp", "ubp", "sdpi", "ubP", "ugps", "odpi", "azpi", "sdb", "odps", "udb", "adb", "audpi", "ugp", "ubport", "audpc", "audp", "ubps", "udpc", "udsp", "udsps", "udsP", "odb", "sdp", "udport", "azpc", "urpc", "udpi", "udps", "adpi", "udP", "ugP", "udsport", "azps", "ugport", "azp", "odp", "adp", "adps", "audps"], "err": ["bug", "rr", "tx", "rev", "cer", "l", "i", "rs", "g", "er", "Error", "req", "aster", "error", "Er", "br", "conf", "fr", "rh", "der", "cr", "var", "mr", "ind", "p", "e", "ir", "fi", "exc", "ver", "lr", "ler", "n", "f", "spec", "c", "inc", "arr", "acer", "cb", "iter", "r", "resp", "pr", "ev", "ar", "rage", "dr", "order", "ise"], "v": ["m", "d", "t", "vv", "l", "i", "val", "vp", "iv", "api", "g", "test", "conv", "ve", "h", "vi", "inv", "o", "w", "u", "z", "p", "e", "s", "temp", "k", "vs", "b", "j", "n", "f", "c", "sv", "q", "uv", "r", "V", "vd", "vt", "lv"]}}
{"project": "qemu", "commit_id": "595ab64169be9063d64c3b1aa1c249fbe2662221", "target": 1, "func": "static int socket_get_buffer(void *opaque, uint8_t *buf, int64_t pos, int size)\n\n{\n\n    QEMUFileSocket *s = opaque;\n\n    ssize_t len;\n\n\n\n    do {\n\n        len = qemu_recv(s->fd, buf, size, 0);\n\n    } while (len == -1 && socket_error() == EINTR);\n\n\n\n    if (len == -1)\n\n        len = -socket_error();\n\n\n\n    return len;\n\n}\n", "idx": 13736, "substitutes": {"opaque": [" opaques", "opace", "oppaques", "oppity", "oppca", "opity", "oopca", "oppaque", "opaques", "iopace", "opca", " opicit", "oopaque", "iopaque", "phpace", " opque", "oopity", "opque", "iopque", "phpicit", "phpque", " opace", "phpaque", " opity", "oopaques", "opicit", " opca", "iopicit"], "buf": ["vec", "port", "context", "blocks", "bc", "queue", "fd", "cv", "fl", "batch", "config", "fb", "uf", "bound", "bytes", "pool", "buffer", "bag", "loc", "fp", "buff", "rb", "pb", "data", "b", "base", "Buffer", "box", "length", "wb", "f", "ab", "c", "cb", "cap", "que", "db", "cache", "src", "seq", "ctx", "lim", "alloc"], "pos": [" offset", "port", "val", " position", "os", "str", "position", "loc", "limit", "set", " index", "p", "pointer", "base", "from", "address", "block", "end", "offset", " positions", " start", "seq", "Pos", "off", "no", "addr", "start"], "size": ["args", "en", "small", "enc", "id", "code", "name", "Size", "bytes", "position", "loc", "limit", "z", "ize", "p", "e", "data", "length", "count", "n", "address", "c", "timeout", "end", "SIZE", "offset", "sn", "cache", "empty", "start"], "s": ["sys", "ses", "m", "service", "sync", "fs", "sym", "syn", "S", "os", "si", "es", "js", "sq", "session", "server", "o", "p", "e", "sec", "socket", "http", "sb", "f", "gs", "spec", "c", "ns", "is", "ssl", "sl", "ops", "ds", "sie", "sa", "ls", "ips", "ts"], "len": ["ln", "vec", "en", "rev", "hl", "_", "fl", "Len", "rc", " lang", "l", "val", "i", "code", "pre", " length", "lc", "fun", " el", "h", " lib", "bytes", "str", "ie", "js", "fn", "limit", "lib", " l", "dy", "ll", "z", "e", "fin", "lt", "li", "data", "length", "ler", "n", "count", "f", "line", "lf", "url", " err", "body", "nt", "all", "le", "sl", "elt", "db", "El", "ls", "num", "no", "el", "err"]}}
{"project": "qemu", "commit_id": "b71706d122838d9656e1a6dae80e22401babdf37", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739, "substitutes": {"c": ["channel", "m", "ch", "mc", "cm", "bc", "uc", "d", "ca", "t", "cc", "l", "config", "i", "container", "C", "lc", "cs", "ci", "ctrl", "h", "con", "ct", "cr", "conn", "cd", "p", "e", "k", "b", "f", "cu", "dc", "ac", "cb", "sc", "ce", "coll", "com", "cp", "exec", "vc", "xc", "cache", "ec", "cur", "fc", "cl", "ctx"], "buf": ["path", "port", "bc", "queue", "fd", "array", "cv", "fl", "batch", "rc", "fb", "uf", "bytes", "pool", "buffer", "fp", "buff", "rb", "data", "b", "base", "Buffer", "f", "feed", "cb", "cap", "file", "cf", "db", "cache", "src", "seq", "ctx", "handle", "alloc"], "size": ["en", "small", "done", "gz", "sync", "enc", "code", "name", "weight", "Size", "bytes", "sum", "storage", " sizes", "w", "ize", "sec", "time", "e", "used", "length", "address", "SIZE", "offset", "sn", "esc", "scale", "write", "sent", "empty", "fee", "len", "max"], "count": ["depth", "call", "part", "sync", "batch", "id", "code", "child", "current", "name", "connection", "cond", "weight", "total", "error", "force", "col", "p", "Count", "time", "found", "data", "base", "used", "length", "read", "stat", "old", "list", "state", "number", "counter", "file", "process", "all", "write", "last", "cache", "content", "seq", "work", "order", "flag", "len", "max", "start"], "status": ["bc", "successful", "msg", "final", "use", "str", "si", "server", "active", "temp", "wait", "base", "stat", "speed", "grade", "spec", "fail", "class", "debug", "stable", "message", "sync", "id", "gc", "progress", "comment", "error", "console", "version", "data", "result", "results", "flag", "score", "STAT", "complete", "service", "style", "current", "null", "unit", "update", "output", "step", "stage", "site", "sb", "state", "type", "Status", "err", "date", "response", "code", "standard", "act", "this", "job", "ss", "flags", "sign", "success", "stats", "security", "wrapper", "resp", "su", "content", "seq"], "ret": ["pet", "alt", "ft", "rev", "part", "reply", "RT", "art", "rc", "val", "back", "def", "rets", "gt", "Return", "fun", "req", "ref", "det", "lit", "valid", "conn", "obj", "ut", "pub", "stop", "rec", "fin", "success", "match", "ext", "Ret", "result", "ann", " RET", "rl", "ry", " Ret", " result", "nt", " success", "re", "rt", "fail", "resp", "RET", "res", "reg", "wrap", "flag", "run", "len", "bit", "replace"], "written": ["wrote", " write", "lost", "worked", "paid", "called", "done", "sized", "printed", "ENDED", "ritten", "added", "played", "weight", "owned", "rendered", "generated", " created", "checked", "writer", "writing", "seen", " wrote", "created", "output", "broken", "failed", "made", "finished", "w", "rawn", "updated", "temp", "found", "initialized", "filled", "data", "connected", "used", "flow", "loaded", "protected", "writ", "started", "write", "led", "sent", "Written", "ended", " output", "changed", "run", "len", "won", "WR"]}}
{"project": "FFmpeg", "commit_id": "8d0a2180582005e91d9f14ae3dd219a882277c23", "target": 1, "func": "int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n\n\n    AVBPrint bp;\n\n\n\n    char *name = NULL;\n\n    char *message = NULL;\n\n\n\n    jclass class_class = NULL;\n\n    jmethodID get_name_id = NULL;\n\n\n\n    jclass exception_class = NULL;\n\n    jmethodID get_message_id = NULL;\n\n\n\n    jstring string;\n\n\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    exception_class = (*env)->GetObjectClass(env, exception);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    class_class = (*env)->GetObjectClass(env, exception_class);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13740, "substitutes": {"env": ["en", "gov", "pec", "ah", "event", "h", "gear", "pect", "server", "loc", "np", "dev", "hell", "export", "ng", "here", "ec", "chal", "window", "fen", "forge", "args", "context", "done", "cdn", "eu", "iv", "eve", "api", "rn", "txt", "vm", "dir", "console", "impl", "equ", "img", "viron", "her", "ext", "inst", "eni", "dt", "ern", "het", "uv", "exec", "gui", "ev", "vt", "erv", "cv", "ea", "ench", "config", "style", "kn", "icer", "init", "app", "conn", "stage", "enable", "e", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "global", "ne", "osc", "que", "inet", "net", "ctx", "dh", "enc", "eye", "v", "nw", "inv", "ku", "chn", "eh", "cli", "dat", "shell", "ov", "org", "atten", "vel", "environment", "vs", "et", "esi", "essential"], "exception": ["exption", "xcess", "ExException", "execcess", "execception", "expect", "exException", "xption", "excException", "comcess", "comption", "compect", "Exception", "excess", "comception", "excception", "exceptions", "excceptions", "xpect", "execption", "xception", "xceptions", "Exceptions", "xException", "execpect"], "error": ["ror", "channel", "warning", "call", "array", "ERROR", "msg", "row", "Error", "event", "status", "comment", "patch", "resource", "result", "parent", "address", "parser", "ception", "reason", "attribute", "type", "function", "command", "errors", "param", "err"], "log_ctx": ["loplecmp", "logplespec", "log_stack", "config_ctx", "logCctx", "logvalbtn", "config_console", "logurecit", "log_btn", "log_console", "logwconsole", "lo_scope", "logCscope", "logwcor", "logplescope", "logCtx", "logwctx", "log_loc", "lex_ctx", "config_cit", "loplescope", "lo_spec", "logpleloc", "logCspec", "log_cor", "logCcontext", "write_btn", "write_console", "logenctx", "resource_ctx", "logplepkg", "write_loc", "config_cor", "lo_ctx", "logencor", "logPctx", "logPpkg", "resourceplectx", "call_ctx", "logvalctx", "log_cmp", "lo_cmp", "configencor", "resource_scope", "resourceplescope", "writevalctx", "loplectx", "lex_tx", "log_lc", "resourcepleloc", "log_cit", "logCcmp", "log_spec", "writevalbtn", "write_ctx", "logenconsole", "log_pkg", "logvalloc", "logurectx", "logPloc", "log_tx", "lex_lc", "logplecmp", "resource_pkg", "resourceplepkg", "configencit", "logPscope", "logplectx", "log_scope", "logencit", "loplespec", "resource_loc", "logwcit", "writevalloc", "call_context", "configenconsole", "call_tx", "logvalconsole", "logCstack", "lex_context", "writevalconsole", "logurecor", "configenctx", "log_context", "logureconsole", "call_stack"], "bp": [" pc", "hp", "bc", " PB", " lb", " np", "jp", "pc", "bb", "fb", " bar", "sp", " xp", "lp", "nb", " hp", "pp", " pp", " cp", "sth", " ap", "fp", "mb", "p", "rb", "pb", "sb", "bf", " BP", "wp", " gp", "gb", " ip", "bps", "cb", "bg", " p", "PB", "dp", "cp", "BP", "kb", " eb", "lb", "tp", "cpp", "gp"], "name": ["channel", "word", "path", "action", "call", "part", "id", "code", "object", "letter", "ident", "new", "description", "str", "comment", "key", "package", "Name", "NAME", "names", "size", "version", "time", "info", "temp", "desc", "resource", "data", "base", "old", "block", "type", "function", "file", "text", "class", "alias", "filename"], "message": ["email", "m", "response", "code", "object", "msg", "mail", "reference", "description", "method", "comment", "Message", "value", "document", "summary", "version", "result", "number", "reason", "function", "body", "mess", "command", "language", "content", "filename"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748, "substitutes": {"bus": ["plug", "bridge", "port", "proc", "board", "bc", "service", "sync", "bs", "mount", "config", "USB", "io", "def", "serial", "hub", "os", "session", "conf", "lib", "dev", "BUS", "boot", "http", "usb", "driver", "base", "serv", "feed", "cat", "gen", "Bus", "cache", "lock", "us", "util", "ux"], "reason": ["head", "record", "condition", "warning", "ASON", "response", "code", "un", "bad", "msg", "name", "g", "source", "why", "description", "status", "err", "method", "cmp", "comment", "issue", "session", "report", "error", "value", "unknown", "valid", "loc", "category", "request", " Reason", "group", "summary", "rec", "doc", "ticket", "sec", "exc", "desc", "comp", "match", "component", "Reason", "subject", "crit", "argument", "type", "re", "cause", "resp", "author", "param", "reg", "message"], "tag": ["date", "bug", "port", "tags", "rr", "tr", "config", "id", "code", "bad", "msg", "name", "Tag", "test", "event", "rg", "option", "module", "ref", "mod", "comment", "key", "loc", "error", "patch", "br", "var", "category", "feat", "col", "TAG", "ag", "match", "pl", "length", "block", "cat", "par", "attribute", "type", "target", "attr", "nick", "year", "param", "ar", "pos", "reg", "prop", "prefix", "bit"], "arg": ["date", "bug", "args", "call", "ret", "slot", "enc", "rc", "id", "val", "msg", "g", "ig", "use", "rg", "option", "ref", "issue", "loc", "flag", "ind", "doc", "ang", "exc", "ag", "match", "ext", "op", "count", "ax", "neg", "inc", "item", "arr", "cat", "par", "argument", "gen", "target", "attr", "nick", "Arg", "cmd", "mag", "ack", "param", "mac", "ar", "dr", "reg", "prop", "addr", "num", "in", "bit", "tick", "err"], "s": ["south", "spot", "sys", "ses", "m", "d", "t", "service", "sg", "sync", "fs", "i", "sym", "g", "cs", "S", "h", "os", "si", "js", "scope", "sq", "session", "server", "v", "storage", "conf", "ps", "o", "an", "z", "p", "e", "socket", "http", "sf", "b", "sb", "f", "gs", "state", "spec", "c", "ns", "serv", "is", "stats", "ssl", "sv", "sl", "ops", "services", "ds", "r", "su", "ts", "us", "ks", "aws"], "req": ["sem", "proc", "def", "str", "cmp", "mr", "rec", "rb", "ver", "tar", "requ", "spec", "cb", "plug", "call", "rev", "ru", "dq", "id", "fr", "client", "loader", "resource", "require", "data", "ext", " requ", "urg", "r", "exec", "cache", "comm", "ar", "res", "reg", "rf", "release", "rr", "queue", "config", "ref", "app", "war", "ir", "sec", "desc", "rx", "http", "comp", "qt", "j", "f", "query", "wa", "cf", "cur", "ctx", "err", "pkg", "qa", "input", "jp", "required", "er", " request", "sq", "conf", "request", "feat", "p", "op", "crit", "next", "per", "pull", "q", "cmd", "org", "resp", "param", "seq"], "sdev": ["wprof", " sde", "lsdes", "sdes", "sgd", "Sconn", "fdev", "Sdd", "psdevice", "csdevice", "cdevice", " sprof", "skydev", "cdev", "sDev", " spriv", "vDev", "cserror", "skygd", "csmod", "psdev", "gpriv", "lsdev", "gdevice", "lsgd", "sconn", "sdevice", "psmod", "skylim", "cde", " sdef", "sdiv", "wdiv", " sdd", "lsdiv", "gdev", "gdef", "vmod", " sDev", "vconn", "vdef", "wdev", "verror", "csdev", "Sdev", "vdev", "fdiv", "fconn", "smod", "spriv", "sprof", "sde", "Sdiv", "cserv", "pserror", "fdd", " svc", "serror", " sgd", "skydes", "wgd", " sdevice", " sconn", "vpriv", "slim", "vvc", " sserv", "lsprof", "sserv", "vdevice", "sdef", "sdd", " sdiv", "lslim", "svc"], "buf": ["func", "map", "vec", "port", "path", "ff", "uc", "bc", "queue", "ha", "cv", "tmp", "fd", "batch", "config", "val", "fb", "bd", "msg", "uf", "conv", "pool", "buffer", "dest", "bag", "loc", "fp", "br", "buff", "av", "feat", "bp", "mem", "ba", "agg", "img", "rb", "grab", "exc", "pb", "data", "b", "wb", "box", "page", "result", "bh", "ab", "block", "cat", "cb", "gen", "cas", "cap", "text", "cmd", "cf", "comb", "que", "cache", "src", "seq", "off", "num", "cur", "prop", "pad", "header", "ctx", "alloc"], "len": ["alt", "vec", "en", "bin", "rev", "lin", "bc", "fl", "Len", "rc", "lon", "val", "l", "lc", "fun", "lang", "ie", "lit", "loc", "conn", "win", "size", "ll", "la", "fin", "lt", "li", "data", "pl", "min", "length", "n", "lf", "count", "ann", "ler", "line", "span", "il", "gen", "cap", "sl", "resp", "seq", "pos", "num", "el", "bl", "ln", "lim", "err"]}}
{"project": "qemu", "commit_id": "7d6250e3d1a145e5427f21f5664995e0056b34a6", "target": 0, "func": "void helper_store_sdr1(CPUPPCState *env, target_ulong val)\n\n{\n\n    PowerPCCPU *cpu = ppc_env_get_cpu(env);\n\n\n\n    if (!env->external_htab) {\n\n        if (env->spr[SPR_SDR1] != val) {\n\n            ppc_store_sdr1(env, val);\n\n            tlb_flush(CPU(cpu));\n\n        }\n\n    }\n\n}\n", "idx": 13754, "substitutes": {"env": ["args", "erv", "en", "context", "enh", "enc", "ea", "ench", "config", "profile", "code", "extra", "eu", "eve", "ah", "style", "er", "settings", "gear", "server", "v", "em", "conf", "nw", "conn", "np", "obj", "loader", "energy", "dict", "e", "viron", "engine", "exe", "exc", "site", "her", "eng", "ext", "qt", "Environment", "f", "dat", "state", "export", "eni", "end", "ep", "here", "que", "gui", "db", "ev", "cache", "ec", "environment", "el", "fen", "core", "et", "ctx"], "val": ["tx", "slot", "config", "pt", "pre", "local", "VAL", "eval", "test", "x", "ref", "unit", "arg", "buffer", "vol", "pid", "valid", "v", "value", "lib", "dev", "p", "ee", "mem", "data", "base", "count", "stat", "state", "serv", "volt", "sl", "write", "fail", "Val", "cal", "db", "cache", "al", "pos", "num", "addr", "reg", "bl", "el", "len", "ctx", "vals", "index"], "cpu": ["proc", "bench", "bc", "ea", "config", "pc", "lc", "pit", "fps", "foo", "cn", "pool", "vm", "cmp", "unit", "px", "pid", "pu", "platform", "conn", "processor", "loader", "mem", "instance", "net", "boot", "pot", "nc", "CPU", "comp", "component", "gpu", "prem", "process", "cp", "cal", "cache", "lb", "core", "hw", "ctx", "node", "gp"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static bool fw_cfg_comb_valid(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size, bool is_write)\n\n{\n\n    return (size == 1) || (is_write && size == 2);\n\n}\n", "idx": 13768, "substitutes": {"opaque": ["opac", "ospacity", "ospque", "opacity", "OPaque", "OPacity", "OPac", "openque", "ospaque", "openacity", "openac", "ospac", "OPque", "openaque", "opque"], "addr": ["ord", "args", "Address", "config", "val", "oa", "name", "x", "ace", "ad", "pointer", "data", "base", "byte", "address", "block", "type", "cap", "md", "eth", "cp", "arity", "mac", "oint", "pos", "ptr", "ost"], "size": ["args", "en", "small", "izes", "sized", "any", "code", "external", "shape", "or", "g", "send", "Size", "bytes", "capacity", "es", "si", "loc", "member", "value", " sizes", "z", "ize", "e", "sec", "six", "length", "parent", "speed", "address", "number", "timeout", "SIZE", "esc", "needed", "scale", "empty", "fee", "content", "iz", "len"], "is_write": [" is_exclusive", "is_exclusive", "isNewexclusive", "isNewwriting", " is_writer", "is_written", "is_writing", " is_writing", "isNewwritten", "is_writer", "isNewwrite", " is_lex", "is_lex", " is_written"]}}
{"project": "qemu", "commit_id": "6a81dd172cd5d03fce593741629cb4c78fff10cb", "target": 0, "func": "sPAPRTCETable *spapr_tce_new_table(DeviceState *owner, uint32_t liobn,\n\n                                   uint64_t bus_offset,\n\n                                   uint32_t page_shift,\n\n                                   uint32_t nb_table,\n\n                                   bool vfio_accel)\n\n{\n\n    sPAPRTCETable *tcet;\n\n    char tmp[64];\n\n\n\n    if (spapr_tce_find_by_liobn(liobn)) {\n\n        fprintf(stderr, \"Attempted to create TCE table with duplicate\"\n\n                \" LIOBN 0x%x\\n\", liobn);\n\n        return NULL;\n\n    }\n\n\n\n    if (!nb_table) {\n\n        return NULL;\n\n    }\n\n\n\n    tcet = SPAPR_TCE_TABLE(object_new(TYPE_SPAPR_TCE_TABLE));\n\n    tcet->liobn = liobn;\n\n    tcet->bus_offset = bus_offset;\n\n    tcet->page_shift = page_shift;\n\n    tcet->nb_table = nb_table;\n\n    tcet->vfio_accel = vfio_accel;\n\n\n\n    snprintf(tmp, sizeof(tmp), \"tce-table-%x\", liobn);\n\n    object_property_add_child(OBJECT(owner), tmp, OBJECT(tcet), NULL);\n\n\n\n    object_property_set_bool(OBJECT(tcet), true, \"realized\", NULL);\n\n\n\n    return tcet;\n\n}\n", "idx": 13772, "substitutes": {"owner": ["device", "oid", "head", "proc", "root", "cow", "private", "name", "manager", "ock", "staff", "OWN", "owned", "ace", "slave", "oe", "office", "instance", "e", "own", "component", "driver", "reader", "mode", "property", "parent", "Owner", "state", "address", "target", "owners", "creator", "org", "host", "prop", "addr", "alias", "node"], "liobn": ["liobbl", "iloobbx", "liobno", "Liobbna", "luobni", "liabordn", "liologni", "liadown", "liObna", "liOBna", "liabn", "libn", "liobnt", "luobnt", "luobr", "Liobn", "liobbnt", "liabdn", "liabN", "liobbN", "liodx", "ciobdn", "liobni", "ciobbn", "liobbn", "liologn", "liubni", "liabornan", "liubnw", "liabornr", "Liobbl", "luabni", "liobr", "ciobbdn", "iloobbdn", "liadownt", "ciobbnr", "liibnt", "iloobn", "ciobnan", "lobn", "lobnt", "liObn", "liobdn", "liubn", "liobnr", "ciobbnan", "libnt", "liabr", "liadowni", "liocdn", "iloobno", "luobdn", "liadowdn", "liubnt", "liobbno", "liodno", "liObl", "Liobbn", "ciobn", "liabl", "Liobr", "iloobbno", "liibnw", "Liobbr", "liabni", "lobni", "liOBn", "liObr", "luobN", "liolognt", "liodynr", "lobnw", "luObl", "iloobx", "liobbr", "liobbnr", "liobx", "liodydn", "liocx", "liocno", "liobbdn", "liibn", "liodyn", "Liobna", "luobl", "liobnan", "liaborn", "liobbx", "liodn", "luObr", "liodynan", "liObN", "libni", "luObn", "luabdn", "liocn", "liOBr", "liobnw", "lioddn", "Liobl", "luobn", "ciobnr", "liobbna", "iloobdn", "liolognw", "iloobbn", "liobna", "liobl", "luabnt", "liobbni", "luabn", "liobN", "liOBl", "liabnt", "liibni", "libnw", "liobbnan", "luObN"], "bus_offset": ["BUS_shift", "BUS_field", "BUS_offset", "BUS_location", "bus_sort", "controller_size", "busamshift", "BUS_sort", "busalsize", "busalsort", "BUS_size", "busaloffset", "bus_location", "busamfield", "controller_offset", "bus_shift", "busamlocation", "busaltranslation", "BUS_translation", "busamoffset", "bus_translation", "bus_align", "bus_field", "bus_size", "controller_shift", "controller_align"], "page_shift": ["page\u00b7direction", "page_shape", "page_direction", " page_shape", "page\u00b7size", "page_space", " page_size", " page_space", "pagealshift", " page_direction", "page\u00b7space", "page_gap", "page_distance", "page_center", " page_gap", "page\u00b7shift", " page_distance", "pagealgap", "pagealsize", "pagealshape", " page_center", "page_size"], "nb_table": ["nbxtype", "sb_type", "nb2table", "api_table", "apiblockaddress", "nbaccache", "nbfmodule", "nbjsection", "nb2module", "nb_tab", "sbaccache", "nbblockaddress", "nbfcache", "nbjblock", "nbjtable", "apiblockmodule", "nbactree", "nbjtab", "nb_tree", "np_cache", "api_cache", "sbactype", "nbxtree", "sb_cache", "np_table", "nbftable", "nb_address", "nb_cache", "sbactree", "nb_section", "apiblockcache", "nbfaddress", "nb2address", "nbactype", "sbactable", "nbblockcache", "api_module", "nbblockmodule", "nb_type", "sb_table", "nbxtable", "nbxcache", "nbblocktable", "np_tab", "nb2cache", "nbactable", "np_section", "apiblocktable", "nb_block", "sb_tree", "api_address", "np_block", "nb_module"], "vfio_accel": ["vfio_acccl", "vfio_excel", "vfio_facceler", "vfio_maccel", "vfio_accquire", "vfio_acscl", "vfio_acquire", "vfio_exquire", "vfio_acccent", "vfio_acscel", "vfio_accl", "vfio_acceler", "vfio_maccer", "vfio_excl", "vfio_maccent", "vfio_acsquire", "vfio_accent", "vfio_faccel", "vfio_accce", "vfio_faccl", "vfio_acccer", "vfio_faccent", "vfio_acsceler", "vfio_exceler", "vfio_macceler", "vfio_acccel", "vfio_accer", "vfio_acce", "vfio_maccl", "vfio_accceler", "vfio_macce"], "tcet": ["fcat", "tcat", " TCpet", "bcit", "bcset", "ucit", "cfpet", "tg\u00e9t", "scet", " TCset", "tgets", "TCound", "tcET", " tcound", "wbat", " tcets", "TCet", " TCets", "fcet", "ucet", "ucett", "lcinet", "mcET", "scit", "ctrloint", " tcset", "TCat", "cfonet", "pcset", "ucot", "temponet", "mcet", "lcot", "tempoint", "tket", " tcET", "tcound", "tcets", " tc\u00e9t", "tkset", "tkpet", " tcat", "dcound", "lcant", "TCant", "tgat", "fcets", "wbet", "pcet", "scett", "fc\u00e9t", "ctrlpet", "tcit", "TCET", "bcett", "TCset", "tempet", "cfset", "fcant", "tgset", "dcET", "tc\u00e9t", "tcoint", "TCpet", "mcset", "bcet", "ucset", "fcset", "tconet", "pcets", "tcett", "lcset", "tkonet", "tcset", "wbset", "tcot", "tgpet", "tcinet", "mcinet", "lcet", "tget", "temppet", "ucET", "tkET", "tkinet", "cfet", "ctrlet", "lcat", "tempset", "ctrlset", "tcpet", " tcpet", "dcet", " TCet", "lcET", "dcpet", "tgant", "wbant", "tcant", "tgoint", "pcpet", "TCot", "scset"], "tmp": ["bt", "zip", "ctx", "proc", "appy", "done", "stuff", "slice", "pty", "ob", "mp", "bb", "fb", "binary", "msg", "sup", "tt", "nb", "buffer", "txt", "cmp", "dest", "fp", "append", "bag", "table", "loc", "buff", "storage", "np", "obj", "metadata", "temp", "rb", "img", "desc", "pb", "buf", "data", "sb", "wb", "tc", "ext", "ptr", "result", "rm", "address", "tab", "tf", "cb", "ucc", "elt", "cp", "cache", "db", "properties", "vt", "prop", "copy", "ppa", "tp", "cpp"]}}
{"project": "qemu", "commit_id": "192cf55cc02dc0838bbfa5ac17feb7f6c1651441", "target": 1, "func": "static void debug_print_fis(uint8_t *fis, int cmd_len)\n\n{\n\n#ifdef DEBUG_AHCI\n\n    int i;\n\n\n\n    fprintf(stderr, \"fis:\");\n\n    for (i = 0; i < cmd_len; i++) {\n\n        if ((i & 0xf) == 0) {\n\n            fprintf(stderr, \"\\n%02x:\",i);\n\n        }\n\n        fprintf(stderr, \"%02x \",fis[i]);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n#endif\n\n}\n", "idx": 13784, "substitutes": {"fis": ["Fis", " fi", "vids", "alfris", "fids", "Fris", " fris", " fils", "Fids", "vi", "alfi", "fi", "Fi", " fids", "fils", "vis", "alfils", "vils", "fris", "alfis", "Fils"], "cmd_len": ["cmd_Len", " cmd_count", "cmd_body", " cmd_length", "cmd_count", " cmd_body", "cmd4len", "cmd4count", "cmd4length", " cmd_Len", "cmd_length"], "i": ["hi", "qi", "it", "ui", "uni", "m", "part", "slice", "I", "d", "t", "ai", "ni", "xi", "id", "l", "iu", "gi", "split", "a", "oi", "io", "api", "mu", "ci", "di", "x", "si", "ii", "key", "v", "uri", "o", "u", "p", "e", "temp", "fi", "li", "k", "b", "ix", "multi", "j", "count", "n", "f", "phi", "ti", "length", "ip", "c", "eni", "ji", "pi", "r", "bi", "ri", "zi", "len", "in", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "be00ec832c519427cd92218abac77dafdc1d5487", "target": 0, "func": "static av_cold int svc_encode_init(AVCodecContext *avctx)\n\n{\n\n    SVCContext *s = avctx->priv_data;\n\n    SEncParamExt param = { 0 };\n\n    int err = AVERROR_UNKNOWN;\n\n    int log_level;\n\n    WelsTraceCallback callback_function;\n\n    AVCPBProperties *props;\n\n\n\n    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion\n\n    // function (for functions returning larger structs), thus skip the check in those\n\n    // configurations.\n\n#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)\n\n    OpenH264Version libver = WelsGetCodecVersion();\n\n    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Incorrect library version loaded\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n#endif\n\n\n\n    if (WelsCreateSVCEncoder(&s->encoder)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to create encoder\\n\");\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.\n\n    log_level = WELS_LOG_DETAIL;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);\n\n\n\n    // Set the logging callback function to one that uses av_log() (see implementation above).\n\n    callback_function = (WelsTraceCallback) libopenh264_trace_callback;\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);\n\n\n\n    // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().\n\n    (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);\n\n\n\n    (*s->encoder)->GetDefaultParams(s->encoder, &param);\n\n\n\n    param.fMaxFrameRate              = avctx->time_base.den / avctx->time_base.num;\n\n    param.iPicWidth                  = avctx->width;\n\n    param.iPicHeight                 = avctx->height;\n\n    param.iTargetBitrate             = avctx->bit_rate;\n\n    param.iMaxBitrate                = FFMAX(avctx->rc_max_rate, avctx->bit_rate);\n\n    param.iRCMode                    = RC_QUALITY_MODE;\n\n    param.iTemporalLayerNum          = 1;\n\n    param.iSpatialLayerNum           = 1;\n\n    param.bEnableDenoise             = 0;\n\n    param.bEnableBackgroundDetection = 1;\n\n    param.bEnableAdaptiveQuant       = 1;\n\n    param.bEnableFrameSkip           = s->skip_frames;\n\n    param.bEnableLongTermReference   = 0;\n\n    param.iLtrMarkPeriod             = 30;\n\n    param.uiIntraPeriod              = avctx->gop_size;\n\n#if OPENH264_VER_AT_LEAST(1, 4)\n\n    param.eSpsPpsIdStrategy          = CONSTANT_ID;\n\n#else\n\n    param.bEnableSpsPpsIdAddition    = 0;\n\n#endif\n\n    param.bPrefixNalAddingCtrl       = 0;\n\n    param.iLoopFilterDisableIdc      = !s->loopfilter;\n\n    param.iEntropyCodingModeFlag     = 0;\n\n    param.iMultipleThreadIdc         = avctx->thread_count;\n\n    if (s->profile && !strcmp(s->profile, \"main\"))\n\n        param.iEntropyCodingModeFlag = 1;\n\n    else if (!s->profile && avctx->coder_type == FF_CODER_TYPE_AC)\n\n        param.iEntropyCodingModeFlag = 1;\n\n\n\n    param.sSpatialLayers[0].iVideoWidth         = param.iPicWidth;\n\n    param.sSpatialLayers[0].iVideoHeight        = param.iPicHeight;\n\n    param.sSpatialLayers[0].fFrameRate          = param.fMaxFrameRate;\n\n    param.sSpatialLayers[0].iSpatialBitrate     = param.iTargetBitrate;\n\n    param.sSpatialLayers[0].iMaxSpatialBitrate  = param.iMaxBitrate;\n\n\n\n    if ((avctx->slices > 1) && (s->max_nal_size)){\n\n        av_log(avctx,AV_LOG_ERROR,\"Invalid combination -slices %d and -max_nal_size %d.\\n\",avctx->slices,s->max_nal_size);\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->slices > 1)\n\n        s->slice_mode = SM_FIXEDSLCNUM_SLICE;\n\n\n\n    if (s->max_nal_size)\n\n        s->slice_mode = SM_DYN_SLICE;\n\n\n\n    param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;\n\n    param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;\n\n\n\n    if (s->slice_mode == SM_DYN_SLICE) {\n\n        if (s->max_nal_size){\n\n            param.uiMaxNalSize = s->max_nal_size;\n\n            param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;\n\n        } else {\n\n            if (avctx->rtp_payload_size) {\n\n                av_log(avctx,AV_LOG_DEBUG,\"Using RTP Payload size for uiMaxNalSize\");\n\n                param.uiMaxNalSize = avctx->rtp_payload_size;\n\n                param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = avctx->rtp_payload_size;\n\n            } else {\n\n                av_log(avctx,AV_LOG_ERROR,\"Invalid -max_nal_size, specify a valid max_nal_size to use -slice_mode dyn\\n\");\n\n                goto fail;\n\n            }\n\n        }\n\n    }\n\n\n\n    if ((*s->encoder)->InitializeExt(s->encoder, &param) != cmResultSuccess) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Initialize failed\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_GLOBAL_HEADER) {\n\n        SFrameBSInfo fbi = { 0 };\n\n        int i, size = 0;\n\n        (*s->encoder)->EncodeParameterSets(s->encoder, &fbi);\n\n        for (i = 0; i < fbi.sLayerInfo[0].iNalCount; i++)\n\n            size += fbi.sLayerInfo[0].pNalLengthInByte[i];\n\n        avctx->extradata = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            err = AVERROR(ENOMEM);\n\n            goto fail;\n\n        }\n\n        avctx->extradata_size = size;\n\n        memcpy(avctx->extradata, fbi.sLayerInfo[0].pBsBuf, size);\n\n    }\n\n\n\n    props = ff_add_cpb_side_data(avctx);\n\n    if (!props) {\n\n        err = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    props->max_bitrate = param.iMaxBitrate;\n\n    props->avg_bitrate = param.iTargetBitrate;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    svc_encode_close(avctx);\n\n    return err;\n\n}\n", "idx": 13809, "substitutes": {"avctx": ["avalloc", "ajcu", "airctx", "avlc", "avcas", "aflc", "avalconf", "abtx", "afconfig", "avecci", "avcu", "vercomponent", "avallc", " avcontext", "AVkb", "avconf", "avecli", "AVcas", "avecontext", "avconfig", "abctx", "airconn", "afconn", "AVconfig", "abcontext", " avci", "AVconf", "ajcontext", "afcf", "AVloc", "aveconf", "ovctx", "AVcontext", "aircci", "avectx", "ajcomponent", "abcu", "avcli", "afcu", "abconfig", "AVconn", "abloc", "afcontext", " avkb", " avloc", "avkb", "avconn", "avloc", " avcas", " avcu", "afwcs", "avetx", "ajcas", "avci", "ajci", "ovconn", " avconv", "avcf", "AVci", "avecu", "vercontext", "avtx", "ovconv", "ajctx", "aveloc", "afloc", "verctx", "avecf", "aircontext", "afctx", "afcci", "avcci", "avalcf", "afcli", "AVconv", "avcomponent", "avewcs", "afkb", "avwcs", "avalwcs", "ovcontext", "avelc", "AVcu", "avalcli", "avalcontext", "avalctx", "avcontext", "aveconn", "avconv", " avconn", "AVctx", "vercu", "afcomponent", "AVtx"], "s": ["args", "sys", "m", "ses", "as", "service", "t", "sync", "fs", "d", "l", "native", "rs", "sym", "a", "g", "cs", "qs", "S", "os", "js", "es", "sq", "session", "v", "ss", "o", "u", "params", "p", "e", "sec", "se", "http", "k", "b", "sb", "site", "f", "gs", "spec", "c", "ns", "is", "ssl", "services", "r", "ds", "param", "su", "ls", "ts", "us", "y", "ctx", "ks", "aws"], "log_level": ["path_level", " log_log", "log_class", "pathvalvel", "loglenlevel", "error_message", "pathvalmode", "log_location", "loglogvel", "logloglog", " log_location", "log_mode", "error_class", "log_vel", "error_vel", "logvalmode", "loglenvel", "logloglocation", "pathvallvl", "log_log", "log_message", "loglenclass", "logvallvl", "error_level", "path_mode", "log_lvl", "logloglevel", "path_vel", "path_lvl", "logvallevel", " log_vel", "logvalvel", "loglenmessage", "pathvallevel"], "callback_function": ["callback2Function", "callback2command", "callback_error", "callback_resource", "log_command", "callback_func", "callbackalfunction", "callback_callback", "log_fn", "back_function", "callback_Function", "callback_fn", "callbackalfun", " callback_resource", "back_fun", "callback_command", "callbackalcallback", "callback2error", " callback_func", "callback2function", "callback2callback", "back_callback", "callback2fun", "log_Function", "callback2fn", "callbackalerror", "callback_fun", "back_error", "log_function", " callback_Function"], "props": ["Props", "prers", " prors", " progs", "progs", "pregs", "Progs", "prebs", "prors", "preps", "Probs", "Prors", " probs", "probs"]}}
{"project": "qemu", "commit_id": "6a2a5aae02b9a0b53807b9ad91f15cd4988781f9", "target": 0, "func": "static void sm501_disp_ctrl_write(void *opaque, hwaddr addr,\n\n                                  uint64_t value, unsigned size)\n\n{\n\n    SM501State *s = (SM501State *)opaque;\n\n    SM501_DPRINTF(\"sm501 disp ctrl regs : write addr=%x, val=%x\\n\",\n\n                  (unsigned)addr, (unsigned)value);\n\n\n\n    switch (addr) {\n\n    case SM501_DC_PANEL_CONTROL:\n\n        s->dc_panel_control = value & 0x0FFF73FF;\n\n        break;\n\n    case SM501_DC_PANEL_PANNING_CONTROL:\n\n        s->dc_panel_panning_control = value & 0xFF3FFF3F;\n\n        break;\n\n    case SM501_DC_PANEL_FB_ADDR:\n\n        s->dc_panel_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_OFFSET:\n\n        s->dc_panel_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_PANEL_FB_WIDTH:\n\n        s->dc_panel_fb_width = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_FB_HEIGHT:\n\n        s->dc_panel_fb_height = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_TL_LOC:\n\n        s->dc_panel_tl_location = value & 0x07FF07FF;\n\n        break;\n\n    case SM501_DC_PANEL_BR_LOC:\n\n        s->dc_panel_br_location = value & 0x07FF07FF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_H_TOT:\n\n        s->dc_panel_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_H_SYNC:\n\n        s->dc_panel_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_TOT:\n\n        s->dc_panel_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_V_SYNC:\n\n        s->dc_panel_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_HWC_ADDR:\n\n        s->dc_panel_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_LOC:\n\n        s->dc_panel_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_1_2:\n\n        s->dc_panel_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_PANEL_HWC_COLOR_3:\n\n        s->dc_panel_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_CONTROL:\n\n        s->dc_crt_control = value & 0x0003FFFF;\n\n        break;\n\n    case SM501_DC_CRT_FB_ADDR:\n\n        s->dc_crt_fb_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_FB_OFFSET:\n\n        s->dc_crt_fb_offset = value & 0x3FF03FF0;\n\n        break;\n\n    case SM501_DC_CRT_H_TOT:\n\n        s->dc_crt_h_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_H_SYNC:\n\n        s->dc_crt_h_sync = value & 0x00FF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_TOT:\n\n        s->dc_crt_v_total = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_V_SYNC:\n\n        s->dc_crt_v_sync = value & 0x003F0FFF;\n\n        break;\n\n\n\n    case SM501_DC_CRT_HWC_ADDR:\n\n        s->dc_crt_hwc_addr = value & 0x8FFFFFF0;\n\n        break;\n\n    case SM501_DC_CRT_HWC_LOC:\n\n        s->dc_crt_hwc_location = value & 0x0FFF0FFF;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_1_2:\n\n        s->dc_crt_hwc_color_1_2 = value;\n\n        break;\n\n    case SM501_DC_CRT_HWC_COLOR_3:\n\n        s->dc_crt_hwc_color_3 = value & 0x0000FFFF;\n\n        break;\n\n\n\n    case SM501_DC_PANEL_PALETTE ... SM501_DC_PANEL_PALETTE + 0x400 * 3 - 4:\n\n        sm501_palette_write(opaque, addr - SM501_DC_PANEL_PALETTE, value);\n\n        break;\n\n\n\n    default:\n\n        printf(\"sm501 disp ctrl : not implemented register write.\"\n\n               \" addr=%x, val=%x\\n\", (int)addr, (unsigned)value);\n\n        abort();\n\n    }\n\n}\n", "idx": 13829, "substitutes": {"opaque": ["opatile", "transaque", "transacity", "opac", "ipque", "transula", "operacity", "ipula", "operaque", "ipac", "ipacity", "opacity", "ipaque", "operque", "operatile", " opque", "opque", " opacity", "opula", "ipatile", "operula", "operac", " opatile", "transac"], "addr": ["func", "ord", "device", "alt", "port", "Address", "rc", "config", "val", "enter", "name", "align", "x", "ref", "buffer", "cmp", " address", "v", "ad", "p", "direction", "buf", "data", "pointer", "ext", "callback", "mode", "add", "address", "pair", "ip", "number", "padding", "block", "type", "offset", "cb", "eth", "attr", "cmd", "r", "host", "mac", "src", "off", "prefix", "pad", "len", "ptr", "node", "message"], "value": ["device", "native", "val", "memory", "sample", "VALUE", "image", "new", "ve", "hello", "total", "server", "begin", "media", "Value", "flow", "padding", "end", "single", "offset", "get", "command", "fee", "num", "index", "message", "termin", "bin", "done", "home", "reference", "sum", "comment", "key", "w", "resource", "data", "length", "json", "number", "create", "function", "selected", "archive", "alt", "format", "complete", "service", "style", "current", "large", "values", "source", "null", "description", "option", "buffer", "unit", "valid", "slave", "element", "document", "info", "max", "multi", "address", "feature", "type", "handle", "node", "name", "v", "uri", "buf", "component", "mode", "store", "attribute", "scale", "content", "join", "start"], "size": [" mode", " bytes", "val", "name", " length", "bytes", "buffer", "v", " values", " buffer", "buf", "data", "length", "mode", "state", "address", "SIZE", "type", "ptr"], "s": ["south", "sys", "m", "ses", "self", "service", "t", "d", "sg", "fs", "native", "l", "i", "sym", "rs", "g", "qs", "S", "hs", "manager", "os", "new", "status", "sets", "si", "js", "es", "session", "v", "conf", "ss", "storage", "client", "o", "ps", "w", "an", "u", "p", "e", "site", "b", "sb", "sf", "http", "n", "f", "stat", "gs", "spec", "state", "c", "ns", "single", "is", "ssl", "side", "sl", "states", "r", "ds", "sa", "ls", "ts", "us", "y", "aws"]}}
{"project": "FFmpeg", "commit_id": "9b2c28e6edbb43e00e0b2d99b95567189cd46e91", "target": 0, "func": "void rgb15to16(const uint8_t *src,uint8_t *dst,uint32_t src_size)\n\n{\n\n#ifdef HAVE_MMX\n\n  register const char* s=src+src_size;\n\n  register char* d=dst+src_size;\n\n  register int offs=-src_size;\n\n  __asm __volatile(PREFETCH\"\t%0\"::\"m\"(*(s+offs)):\"memory\");\n\n  __asm __volatile(\n\n\t\"movq\t%0, %%mm4\\n\\t\"\n\n\t\"movq\t%1, %%mm5\"\n\n\t::\"m\"(mask15b), \"m\"(mask15rg):\"memory\");\n\n  while(offs<0)\n\n  {\n\n\t__asm __volatile(\n\n\t\tPREFETCH\"\t32%1\\n\\t\"\n\n\t\t\"movq\t%1, %%mm0\\n\\t\"\n\n\t\t\"movq\t8%1, %%mm2\\n\\t\"\n\n\t\t\"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t\t\"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm0\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm1\\n\\t\"\n\n\t\t\"pand\t%%mm4, %%mm2\\n\\t\"\n\n\t\t\"pand\t%%mm5, %%mm3\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm1\\n\\t\"\n\n\t\t\"psllq\t$1, %%mm3\\n\\t\"\n\n\t\t\"por\t%%mm1, %%mm0\\n\\t\"\n\n\t\t\"por\t%%mm3, %%mm2\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 8%0\"\n\n\t\t:\"=m\"(*(d+offs))\n\n\t\t:\"m\"(*(s+offs))\n\n\t\t:\"memory\");\n\n\toffs+=16;\n\n  }\n\n  __asm __volatile(SFENCE:::\"memory\");\n\n  __asm __volatile(EMMS:::\"memory\");\n\n#else\n\n   const uint16_t *s1=( uint16_t * )src;\n\n   uint16_t *d1=( uint16_t * )dst;\n\n   uint16_t *e=((uint8_t *)s1)+src_size;\n\n   while( s1<e ){\n\n     register int x=*( s1++ );\n\n     /* rrrrrggggggbbbbb\n\n        0rrrrrgggggbbbbb\n\n        0111 1111 1110 0000=0x7FE0\n\n        00000000000001 1111=0x001F */\n\n     *( d1++ )=( x&0x001F )|( ( x&0x7FE0 )<<1 );\n\n   }\n\n#endif\n\n}\n", "idx": 13855, "substitutes": {"src": ["RC", "rib", "proc", "gz", "uc", "sync", "rc", "config", "ins", "stream", "rs", "supp", "ctr", "sup", "source", "req", "image", "sr", "dest", "sq", "loc", "secure", "impl", "rb", "img", "share", "pl", "sb", "b", "reflect", "inst", "scl", "url", "c", "cb", "ur", "sc", "ssl", "rob", "attr", "sur", "sub", "cur", "support", "filename"], "dst": ["dyst", " dsts", "datsts", "dyput", "Dst", "dysp", "datput", "Dsts", "adst", "dsts", "dysts", " dsp", "adsts", " drc", "datst", "idrc", "sdsts", "dsp", "idbl", "dbl", "Dbl", "sdst", "adsp", "adrc", "idst", "dput", "datsp", "idsts", "Dsp", "sdput", " dbl", "adbl", "drc", "sdsp"], "src_size": ["rc_address", "rc_size", "src64name", " src_scale", "rc_speed", "src_scale", "src_address", "src_day", "rc_name", "src64scale", "rc_scale", "src_name", " src_day", "src_speed", "src64size", " src_address"], "s": ["ses", "t", "ins", "l", "i", "a", "g", "S", "sp", "h", "os", "si", "v", "ps", "o", "w", "u", "z", "p", "b", "sb", "j", "n", "f", "gs", "c", "ns", "offs", "r", "ds", "su", "ls", "ts", "space", "ks"], "d": ["D", "dh", "t", "fd", "l", "i", "a", "g", "h", "x", "di", "v", "o", "w", "z", "ad", "u", "p", "ind", "b", "sd", "j", "n", "f", "dat", "c", "dt", "dc", "q", "dp", "r", "ds", "dn"], "m": ["mc", "cm", "t", "l", "i", "a", "fm", "g", "h", "x", "mm", "v", "tm", "o", "w", "ms", "gm", "media", "mt", "p", "bm", "u", "mi", "b", "multi", "n", "f", "mode", "hm", "c", "nm", "M", "r", "y", "sm"], "memory": ["true", "map", "record", "cm", "math", "medium", "i", "shape", "large", "name", "g", "reference", "manager", "image", "h", "use", "module", "buffer", "java", "vm", "mm", "performance", "session", "master", "size", "media", "mem", "p", "resource", "Memory", "data", "byte", "count", "length", "mask", "address", "complex", "gpu", "function", "application", "all", "cache", "program", "texture", "material", "asm", "message"], "s1": ["p2", "f8", "S1", "p81", " s2", "d81", "ds2", "s8", "S2", "dOne", "dsOne", "p1", "s81", "pOne", "s2", "n8", "nOne", "dsone", "S81", "SOne", "sone", "ds1", "sOne", "fOne", "n81", "n1", "f1", "S8", "pone", "d2", "f81", " sone"], "d1": ["c81", " d11", "done", "f8", "e81", "c1", " d81", "d81", "i3", "e11", "c8", "c11", "i1", "d11", "d3", "f3", "d8", "i8", "cone", "eone", " done", "c3", "f1", "e1"], "e": ["en", "E", "ea", "ue", "ey", "h", "ve", "x", "es", "ie", "error", "equal", "ed", "element", "de", "u", "z", "ee", "p", "eps", "be", "se", "f", "fe", "c", "end", "pe", "ne", "ele", "ce", "ae", "ev", "ei", "ec", "el", "ef", "y", "esi"]}}
{"project": "FFmpeg", "commit_id": "4749e074987d45cb98935a683a7ee8e1ee376d86", "target": 1, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n    int src_len, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    pd = dest;\n\n    if (src_len & 1)\n\n        *pd++ = *ps++;\n\n\n\n    src_len >>= 1;\n\n    i = 0;\n\n    do {\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_len);\n\n\n\n    return ps - src;\n\n}\n", "idx": 13859, "substitutes": {"src": ["func", "remote", "proc", "sort", "uc", "slice", "dist", "tmp", "sync", "rc", "config", "stream", "rs", "iv", "supp", "inf", "sup", "lc", "source", "req", "lower", "send", "front", "sr", "raw", "cmp", "lit", "sq", "loc", "view", "super", "size", "rec", "img", "rb", "pack", "desc", "rx", "comp", "pl", "sb", "b", "gb", "url", "cb", "reverse", "sc", "attr", "ssl", "bg", "load", "sl", "sur", "r", "rt", "repl", "sub", "rest", "sel", "upp", "cur", "st", "fc", "ptr", "start"], "dest": ["rib", "head", "remote", "proc", "done", "uc", "slice", "d", "dist", "tmp", " destination", "config", "delete", "orig", "home", "standard", "sup", "source", "later", "txt", "dir", "loc", "master", "buff", "de", "size", "temp", "desc", "wb", "trans", "dep", "route", "dc", "end", "target", "text", "cont", "iter", "Dest", "sub", "both", "pos", "prop", "destroy", "wd", "del", "ptr", "comb", "start"], "src_len": ["httpMln", "src64limit", "src2l", "sr__start", "dest_length", "src64len", "src64start", "src__limit", "http_ln", "http_line", "src_Len", "src_en", " src_l", "http_len", "src_l", "src_ln", "src64line", " src_en", "src2len", "sr__len", "srcMln", "src2length", "httpMlen", " src_Len", "sr_start", "sr__line", "sr_line", "src_length", "src__start", "dest_en", "src__len", "httpMline", "srcMlen", "src_line", "sr__limit", "src2en", "src_limit", "dest_l", "sr_len", "srcMline", "src_start", "src__line", "sr_limit"], "dest_len": ["rcParend", "destModlen", " dest_l", "destModurl", "destModfail", "dest_fail", "dest_line", "destParlen", "rc_url", "rcParfail", "destParurl", "destParend", " dest_line", "destModend", "dest_l", "rcParurl", "rc_end", "dest_name", " dest_name", "dest_url", "rcParlen", "rc_fail", "rc_len", "destParfail"], "ps": ["rs", "pre", "qs", "lp", "js", "files", "params", "eps", "pl", "lines", "list", "bps", "cp", "pers", "ips", "pse", "posts", "d", "ins", "ups", "lc", "cs", "es", "pass", "s", "pa", "amps", "ns", "pe", "als", "ops", "cases", "pr", "ppa", "ks", "parts", "po", "pins", "Ps", "les", "pg", "hs", "os", "points", "pps", "aps", "ms", "li", "ars", "powers", "ans", "proxy", "ls", "rules", "pos", "ph", "comments", " props", " pops", "PS", "as", "ys", "bs", "gi", "pt", "changes", "py", "its", "pp", "ss", "p", "pb", "gs", "ports", "pi", "ds", "css", "ts", "ims", "vs"], "pd": ["dL", "pse", "ped", "pkg", "python", "po", "d", "fd", "pard", "sync", "xi", "pc", "pt", "da", "api", "lc", "td", "pg", "od", "dl", "lp", "py", "sth", "pp", "pex", "pid", "ld", "raf", "pu", "cd", "u", "ll", "la", "p", "plugin", "kl", "pb", "pa", "pl", "sd", "li", "phi", "lf", "wp", "xd", "ctl", "rl", "pm", "parser", "dc", "pe", "pi", "dp", "cp", "ds", "dd", "PD", "hd", "pr", "ppo", "ls", "vd", "pos", "lb", "ppa", "ph", "lv", "ln", "tp", "wd", "php"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "a", "io", "api", "lc", "ci", "dl", "lp", "x", "di", "si", "ii", "pid", "v", "uri", "o", "yi", "u", "p", "e", "ir", "mi", "li", "pl", "b", "ix", "j", "L", "n", "f", "phi", "ip", "c", "is", "ji", "pi", "im", "bi", "ri", "ori", "ami", "y", "in", "index"], "l": ["m", "nl", "lin", "len", "d", "fl", "t", "lc", "dl", "lp", "loc", "v", "o", "ul", "u", "ll", "la", "p", "e", "kl", "z", "s", "li", "pl", "b", "j", "L", "n", "lf", "f", "length", "c", "il", "ol", "lu", "sl", "le", "r", "ls", "lb", "el", "lv", "ln"], "dest_end": ["destaclen", "dest_start", "destacEND", "destResstart", "dest_last", " dest_start", "src_limit", "src_end", "dest_END", " dest_range", " dest_last", "destacstart", "dest_limit", "src_start", "destResend", "destacend", "src_END", "destResrange", "dest_range", "destReslast"]}}
{"project": "FFmpeg", "commit_id": "1181d93231e9b807965724587d363c1cfd5a1d0d", "target": 0, "func": "void ff_avg_h264_qpel16_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_and_aver_dst_16x16_msa(src + stride - 2,\n\n                                           src - (stride * 2) +\n\n                                           sizeof(uint8_t), stride,\n\n                                           dst, stride);\n\n}\n", "idx": 13867, "substitutes": {"dst": ["ddst", " dsts", "cdsts", "Dst", "ddsts", "dedrc", "Dsts", "ddrc", "dsts", " dsrc", "dconst", " dconst", " drc", "dedsts", "dsrc", "dedconst", "cdconst", "cdrc", "cdst", "Drc", "dedst", "ddsrc", "drc", "Dsrc"], "src": ["gz", "uc", "sync", "dist", "cv", "rc", "config", "stream", "supp", "ctr", "sup", "source", "sr", "cmp", "dest", "sq", "lib", "grad", "size", "sec", "rb", "img", "comp", "buf", "sb", "inst", "gb", "url", "cb", "sc", "sl", "sur", "sub", "sel", "cur", "st"], "stride": ["striided", "stringider", "striride", "strider", "strride", "dride", "brider", "erride", "briden", "striiding", " striding", "striding", " strride", "Striding", "Stride", "Strride", "gestide", "intide", "Strider", "errider", "incide", "strince", "gestider", "strided", "errince", "gestided", "brided", "incIDE", "incided", "Strince", " strider", " strand", "drIDE", "stringide", "bride", "Strided", "intided", "gestince", "intider", "errided", "intiden", "stringided", "gestiden", "stripe", "incand", "strIDE", " strIDE", "drided", "strand", "drand", "Stripe", " stripe", "striden", "stringipe", "striide", " strided"]}}
{"project": "FFmpeg", "commit_id": "374c907fb35f8236547b24d792fbb9bed201e321", "target": 1, "func": "static int vorbis_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                        const uint8_t **poutbuf, int *poutbuf_size,\n\n                        const uint8_t *buf, int buf_size)\n\n{\n\n    VorbisParseContext *s = s1->priv_data;\n\n    int duration;\n\n\n\n    if (!s->vp && avctx->extradata && avctx->extradata_size) {\n\n        s->vp = av_vorbis_parse_init(avctx->extradata, avctx->extradata_size);\n\n        if (!s->vp)\n\n            goto end;\n\n    }\n\n\n\n    if ((duration = av_vorbis_parse_frame(s->vp, buf, buf_size)) >= 0)\n\n        s1->duration = duration;\n\n\n\nend:\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only packet analysis */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 13888, "substitutes": {"s1": ["p2", "sp0", "p0", "sp2", "p4", "c2", "qs01", "c1", " s2", "sp1", "p3", "p1", "qsone", "pOne", "qs2", "s2", "s4", "s3", "p01", "s01", "c01", " sOne", "qs1", "sone", "spOne", "cone", "sOne", "c4", "s0", "c3", " s0", "pone", " s4", " s3"], "avctx": ["afconn", "Avcontext", "AVcrit", "afpkg", "afconnection", "AVcmp", "aveconnection", "Avctx", "varcmp", "ajcontext", "varcb", "avcmp", "afcb", " avcf", "afcf", "avcf", "avcrit", "Avcmp", "AVcontext", "afcn", "akcn", "avectx", "vercontext", "afcrit", "avconnection", "afcmp", "vercb", "varctx", "akpkg", "verconn", "ajconn", "afcontext", "ajctx", "avcn", "ajcn", "vercn", "vercmp", "avcontext", "verctx", "avcb", "akctx", "avconn", "avecf", " avconnection", " avcontext", "afctx", "AVctx", "avecontext", "avpkg", "varcontext", "Avcrit", "akcontext", "ajpkg"], "poutbuf": ["pOutqueue", " pOutlog", "pagainlog", "Pinqueue", " poutlog", "poutbuffer", "Pinbuffer", "pinbuffer", " pOutbuffer", " poutbuffer", "Poutqueue", "pOutlog", "poutlog", " pOutbuf", "Poutbuf", "poutqueue", "pagainbuf", "pinbuf", "Pinbuf", "pOutbuffer", "pinlog", "pagainbuffer", "Poutbuffer", "pOutbuf", "pinqueue"], "poutbuf_size": ["poutbuf_capacity", "poutbag_size", "poutbuf_small", "poutbuffer_length", "poutbag_number", "poutbag_small", "poutbufslength", "poutbufssize", "poutbufscapacity", "poutbuffer_size", "poutbuffer_capacity", "poutbuf_number", "poutbuf_length"], "buf": ["vec", "port", "ff", "uc", "bc", "queue", "fd", "cv", "rc", "fb", "binary", "uf", "foo", "auc", "conv", "ref", "buffer", "fp", "bag", "v", "br", "buff", "rb", "pb", "data", "b", "wb", "Buffer", "bf", "f", "padding", "ab", "cb", "cas", "offset", "cmd", "cf", "aux", "src", "seq", "window", "prefix", "pad", "ctx", "alloc"], "buf_size": ["buf32len", "buf1ize", "buffer_size", "buf32sized", "buf32size", "batch_ize", "bufsname", "queue_size", "buffer_name", "buf_len", "buf_name", "buf_ize", "batch_sized", "buf1size", " buf_ize", "batch_size", "bufssized", "queue_len", "bufssize", "buffer_sized", "bufslen", "buf_sized", "buffer_len", " buf_len", "buf1len", "queue_sized"], "s": ["sys", "ses", "context", "m", "self", "as", "d", "sync", "sg", "fs", "vp", "i", "rs", "a", "g", "cs", "qs", "S", "hs", "js", "es", "uns", "sq", "session", "v", "ps", "ss", "ms", "an", "u", "p", "e", "sb", "n", "f", "gs", "c", "ns", "xs", "is", "stats", "sc", "ssl", "services", "ds", "sa", "su", "ls", "ts", "us", "vs", "y", "ctx", "ads", "ks", "aws"], "duration": ["date", "that", "repeat", "depth", "port", "vr", "videos", "property", "d", "series", "id", "vid", "period", "gap", "event", "description", "uu", "later", "vm", "ace", "episode", "until", "uri", "frame", "Duration", "pause", "cost", "during", "version", "doc", "pad", "time", "desc", "interrupted", "seconds", "driver", "length", "count", " dur", "timer", "runtime", "address", "grade", "library", "number", "dep", "timeout", "result", "end", "dt", "lag", "type", " Duration", "dp", "uv", "fee", "video", "nr", "window", "delay", "span", "len", "sleep", "start"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void xen_ram_init(PCMachineState *pcms,\n\n                         ram_addr_t ram_size, MemoryRegion **ram_memory_p)\n\n{\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    ram_addr_t block_len;\n\n    uint64_t user_lowmem = object_property_get_int(qdev_get_machine(),\n\n                                                   PC_MACHINE_MAX_RAM_BELOW_4G,\n\n                                                   &error_abort);\n\n\n\n    /* Handle the machine opt max-ram-below-4g.  It is basically doing\n\n     * min(xen limit, user limit).\n\n     */\n\n    if (HVM_BELOW_4G_RAM_END <= user_lowmem) {\n\n        user_lowmem = HVM_BELOW_4G_RAM_END;\n\n    }\n\n\n\n    if (ram_size >= user_lowmem) {\n\n        pcms->above_4g_mem_size = ram_size - user_lowmem;\n\n        pcms->below_4g_mem_size = user_lowmem;\n\n    } else {\n\n        pcms->above_4g_mem_size = 0;\n\n        pcms->below_4g_mem_size = ram_size;\n\n    }\n\n    if (!pcms->above_4g_mem_size) {\n\n        block_len = ram_size;\n\n    } else {\n\n        /*\n\n         * Xen does not allocate the memory continuously, it keeps a\n\n         * hole of the size computed above or passed in.\n\n         */\n\n        block_len = (1ULL << 32) + pcms->above_4g_mem_size;\n\n    }\n\n    memory_region_init_ram(&ram_memory, NULL, \"xen.ram\", block_len,\n\n                           &error_abort);\n\n    *ram_memory_p = &ram_memory;\n\n    vmstate_register_ram_global(&ram_memory);\n\n\n\n    memory_region_init_alias(&ram_640k, NULL, \"xen.ram.640k\",\n\n                             &ram_memory, 0, 0xa0000);\n\n    memory_region_add_subregion(sysmem, 0, &ram_640k);\n\n    /* Skip of the VGA IO memory space, it will be registered later by the VGA\n\n     * emulated device.\n\n     *\n\n     * The area between 0xc0000 and 0x100000 will be used by SeaBIOS to load\n\n     * the Options ROM, so it is registered here as RAM.\n\n     */\n\n    memory_region_init_alias(&ram_lo, NULL, \"xen.ram.lo\",\n\n                             &ram_memory, 0xc0000,\n\n                             pcms->below_4g_mem_size - 0xc0000);\n\n    memory_region_add_subregion(sysmem, 0xc0000, &ram_lo);\n\n    if (pcms->above_4g_mem_size > 0) {\n\n        memory_region_init_alias(&ram_hi, NULL, \"xen.ram.hi\",\n\n                                 &ram_memory, 0x100000000ULL,\n\n                                 pcms->above_4g_mem_size);\n\n        memory_region_add_subregion(sysmem, 0x100000000ULL, &ram_hi);\n\n    }\n\n}\n", "idx": 13890, "substitutes": {"pcms": ["encarms", "bcma", "arcps", "pcmm", "pcarms", "aucms", "pcros", "fcks", "pcids", "PCents", "pcmes", "tcmes", "mcm", "pcma", "bcs", "pccs", "ncids", "tcms", "acms", "pcps", "mcps", "arcns", "lcps", "pdms", "pcns", "fcms", "bcme", "pcme", "arcks", "acs", "mcml", "mcMS", "acme", "pcws", "lcms", "discents", "ncms", "arcma", "mcks", "bcns", "pcmd", "arcros", "fcMS", "pdma", "paccs", "PCks", "aucmd", "pacmn", "arcents", "arcmaps", "locmn", "PCros", "arcms", "pdns", "ancks", " pcents", "pacws", "discms", "bcarms", "pcm", "ancme", "aucmes", "mcms", " pcmb", "locmaps", "pcml", "arccs", "PCMS", "pcMS", "fcme", "arcmn", "pcands", "PCms", "fcm", " pcws", "arcands", "PCws", "PCps", "pacents", "pacands", "lcks", "pcks", "discps", "ncps", "encms", "arcmes", "tcma", "ncents", "locms", "lcml", "arcmm", "PCmb", "tcmd", "encs", "bcms", "ancms", "pcmb", "discids", "mcme", "aucma", "arcids", "bcmm", "pdmm", "PCm", "pacps", "pacmaps", "pcs", "pacmb", "ancMS", "pcmaps", "pacros", "pcmn", "encme", "arcmd", "loccs", "arcml", "acarms", "pacms", "PCands", "pcents"], "ram_size": ["ramlsize", "gram_end", "poolllen", "ram_scale", "sam_engine", "block_name", "ram\u00b7sum", "ram_capacity", "gram_scale", "sam_align", "pool_sum", "ramllen", "gram_size", "ram_name", "ram_len", "ramfend", "gram_handle", "block_mini", "gram_min", "ram_engine", "ram_grow", "ram\u00b7size", "gram_len", "ramfsize", "poollgrow", "ram_end", "ram_min", "ramlgrow", "poollsum", "pool_size", "ramfscale", "ram_mini", "ram_handle", "poollsize", "ramlsum", "sam_size", "pool_grow", "ram_align", "ramfhandle", "pool_len", "ram_sum", "sam_capacity", "block_size", "ram_address", "block_address", "ram\u00b7grow", "ram\u00b7len"], "ram_memory_p": ["ram_memory___pair", "ram_region_r", "ram_region_pair", "ram_mem_P", "ram_mem_t", "ram_memory_pair", "ram_mem_p", "ram_memory___P", "ram_region_p", "ram_memory_t", "ram_memory___p", "ram_memory___r", "ram_memory_r", "ram_memory_P", "ram_region_P"], "sysmem": ["syslim", "osema", "systemmm", "Sysram", "ysmem", "osmemory", "rammem", "systemmem", "osaccess", "sysdem", "sysmemory", "systemlim", "osram", " sysmemory", "sysvm", "ysaccess", "osmem", "Sysvm", "osdem", "sysema", " sysema", "Sysmm", "ramdem", "sysaccess", "Sysmemory", " sysdem", "sysmm", " syslim", " sysmm", "ysmemory", "rammemory", "ysram", "ramema", "Sysmem", "Sysaccess", "Syslim", " sysvm", "sysram", "systemvm"], "block_len": ["block_ln", "row_line", "block___size", "row_len", "block__long", "block_dim", "block__size", "blocketdim", "recordetdim", "block\u00b7lock", "block_line", " block_lock", "blockingno", "block_length", "block_lock", "block___val", "block\u00b7ln", "block_loc", "blockingline", "block67ln", "block__len", " block_val", "block67val", "recordetsize", "block___loc", "blockinglength", "block_no", "record_size", "block67len", "record_len", "block67lock", "block_val", "blocketlong", "block__dim", "block_long", " block_loc", "blocketsize", "block\u00b7val", "block_size", "recordetlen", " block_size", "record_long", " block_ln", "record_dim", "recordetlong", "block\u00b7len", "blockinglen", "row_length", "block___len", "blocketlen", "row_no"]}}
{"project": "qemu", "commit_id": "caae58cba07efec5f0616f568531c9dfaf1e9179", "target": 1, "func": "static void pci_spapr_set_irq(void *opaque, int irq_num, int level)\n\n{\n\n    /*\n\n     * Here we use the number returned by pci_spapr_map_irq to find a\n\n     * corresponding qemu_irq.\n\n     */\n\n    sPAPRPHBState *phb = opaque;\n\n\n\n    trace_spapr_pci_lsi_set(phb->busname, irq_num, phb->lsi_table[irq_num].irq);\n\n    qemu_set_irq(spapr_phb_lsi_qirq(phb, irq_num), level);\n\n}\n", "idx": 13897, "substitutes": {"opaque": ["oplaque", "litec", "opec", "opsacle", "opsec", " ophole", "opsacity", "oplacle", "litac", "opsac", "litaque", "opac", "obacity", "obaque", "oplacity", "opsaque", "opshole", " opacle", "opacity", "litacity", " opacity", "ophole", "oplhole", "opacle", "obec", "obac"], "irq_num": ["irp_number", "irp_num", "irc_number", "irq_begin", "irp_name", "irp_nu", "irc_off", "irq_nom", "irp_unit", "irq_nu", "irq_unit", "irq_number", "irc_nom", "irq_name", "irp_nom", "irc_num", "irp_begin", "irq_off"], "level": ["path", "location", "lvl", "levels", "style", "letter", "local", "unit", "method", "full", "scope", "key", "loc", "valid", "value", "limit", "clean", "layer", "stage", "lo", "sol", "where", "length", "mode", "point", "rol", "line", "inc", "url", "Level", "type", "file", "loop", "vel", "wl", "len", "depth", "index", "message"], "phb": ["phab", "phbu", " phcb", "shsb", "phbd", " phbu", "sha", "shb", "shcb", " phab", "aphb", "aphbb", "Phbd", " Pha", "Phb", "aphbu", " Phb", "phc", "Phsb", " Phbd", "pha", " phbd", "Phcb", "aphsb", "handb", "handbb", "handbu", "Pha", "phsb", "shbb", "aphab", " phbb", "handc", "aphc", " phc", "phcb", " Phsb", "phbb", "Phbb", "shab", " phsb", " pha"]}}
{"project": "FFmpeg", "commit_id": "2f6ec9fdd7808c8ed045ae0ca4134ab21fb785e6", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899, "substitutes": {"s": ["native", "rs", "qs", "x", "js", "si", "ps", "params", "spec", "c", "is", "sc", "sv", "states", "aws", "args", "m", "self", "d", "sync", "t", "sg", "fs", "ins", "sym", "sup", "g", "cs", "uses", "es", "session", "u", "b", "sf", "ns", "ops", "r", "ks", "secondary", "sys", "parts", "service", "os", "sets", "o", "e", "site", "sb", "features", "f", "ans", "services", "ls", "ses", "l", "a", "S", "settings", "its", "uns", "sq", "conf", "ss", "p", "se", "n", "gs", "xs", "ssl", "ds", "src", "su", "ts", "us", "vs", "y"], "i": ["ish", "oi", "image", "x", "si", "phi", "is", "ji", "zi", "in", "index", "hi", "m", "part", "d", "xi", "id", "iu", "iv", "io", "di", "u", "fi", "inst", "ti", "ski", "ip", "eni", "inner", "bi", "mu", "qi", "ni", "ini", "ci", "ie", "init", "o", "iii", "e", "info", "li", "ix", "multi", "j", "f", "ij", "it", "ui", "I", "input", "ai", "l", "gi", "ii", "v", "uri", "yi", "p", "mini", "cli", "mi", "n", "pi", "chi", "ic", "ri", "ik", "ei", "y", "esi", "start"], "w": ["m", "wh", "d", "t", "iw", "l", "ww", "ew", "g", "wan", "weight", "wx", "sw", "wt", "x", "how", "v", " W", "nw", "wn", "kw", "win", "u", "z", "wave", "p", "wal", "aw", "max", "b", "wb", "n", "f", "rw", "wp", "c", "W", "tw", "ow", "wa", "q", "wen", "r", "wall", "we", "hw", "work", "wrap", "wo", "wl", "wd", "y", "fw"], "h": ["hi", "m", "en", "wh", "ha", "d", "t", "hr", "oh", "l", "ah", "g", "hs", "sw", "x", "gh", "v", "rh", "o", "uh", "ul", "z", "u", "p", "e", "he", "max", "b", "n", "f", "padding", "hm", "bh", "c", "ht", "wa", "q", "r", "H", "sh", "hw", "ph", "y", "height"], "top_padding": ["TOP_adding", "TOP_margin", "Top_inning", "TOP__adding", " top_margin", "bottom_adding", "top_inning", "Top_pad", "Top_padding", "bottom_margin", "bottom_padding", "top__margin", " top_adding", "TOP_padding", "TOP__margin", "top_margin", "TOP_pad", "TOP__padding", "top_pad", "top_adding", "Top_margin", "top__adding", "top__pad", "bottom_pad", "top__padding", "TOP__pad", " top_pad"]}}
{"project": "FFmpeg", "commit_id": "bfeb83a8b7d3fcf09a54d8dbc9c521e10bb17530", "target": 1, "func": "static int hevc_handle_packet(AVFormatContext *ctx, PayloadContext *rtp_hevc_ctx,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    const uint8_t *rtp_pl = buf;\n\n    int tid, lid, nal_type;\n\n    int first_fragment, last_fragment, fu_type;\n\n    uint8_t new_nal_header[2];\n\n    int res = 0;\n\n\n\n    /* sanity check for size of input packet: 1 byte payload at least */\n\n    if (len < RTP_HEVC_PAYLOAD_HEADER_SIZE + 1) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Too short RTP/HEVC packet, got %d bytes\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /*\n\n     * decode the HEVC payload header according to section 4 of draft version 6:\n\n     *\n\n     *    0                   1\n\n     *    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n\n     *   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n     *   |F|   Type    |  LayerId  | TID |\n\n     *   +-------------+-----------------+\n\n     *\n\n     *      Forbidden zero (F): 1 bit\n\n     *      NAL unit type (Type): 6 bits\n\n     *      NUH layer ID (LayerId): 6 bits\n\n     *      NUH temporal ID plus 1 (TID): 3 bits\n\n     */\n\n    nal_type =  (buf[0] >> 1) & 0x3f;\n\n    lid  = ((buf[0] << 5) & 0x20) | ((buf[1] >> 3) & 0x1f);\n\n    tid  =   buf[1] & 0x07;\n\n\n\n    /* sanity check for correct layer ID */\n\n    if (lid) {\n\n        /* future scalable or 3D video coding extensions */\n\n        avpriv_report_missing_feature(ctx, \"Multi-layer HEVC coding\\n\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    /* sanity check for correct temporal ID */\n\n    if (!tid) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Illegal temporal ID in RTP/HEVC packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* sanity check for correct NAL unit type */\n\n    if (nal_type > 50) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Unsupported (HEVC) NAL type (%d)\\n\", nal_type);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch (nal_type) {\n\n    /* video parameter set (VPS) */\n\n    case 32:\n\n    /* sequence parameter set (SPS) */\n\n    case 33:\n\n    /* picture parameter set (PPS) */\n\n    case 34:\n\n    /*  supplemental enhancement information (SEI) */\n\n    case 39:\n\n    /* single NAL unit packet */\n\n    default:\n\n        /* sanity check for size of input packet: 1 byte payload at least */\n\n        if (len < 1) {\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        /* create A/V packet */\n\n        if ((res = av_new_packet(pkt, sizeof(start_sequence) + len)) < 0)\n\n            return res;\n\n        /* A/V packet: copy start sequence */\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        /* A/V packet: copy NAL unit data */\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n\n\n        break;\n\n    /* aggregated packet (AP) - with two or more NAL units */\n\n    case 48:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        res = ff_h264_handle_aggregated_packet(ctx, pkt, buf, len,\n\n                                               rtp_hevc_ctx->using_donl_field ?\n\n                                               RTP_HEVC_DOND_FIELD_SIZE : 0,\n\n                                               NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        break;\n\n    /* fragmentation unit (FU) */\n\n    case 49:\n\n        /* pass the HEVC payload header */\n\n        buf += RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n        len -= RTP_HEVC_PAYLOAD_HEADER_SIZE;\n\n\n\n        /*\n\n         *    decode the FU header\n\n         *\n\n         *     0 1 2 3 4 5 6 7\n\n         *    +-+-+-+-+-+-+-+-+\n\n         *    |S|E|  FuType   |\n\n         *    +---------------+\n\n         *\n\n         *       Start fragment (S): 1 bit\n\n         *       End fragment (E): 1 bit\n\n         *       FuType: 6 bits\n\n         */\n\n        first_fragment = buf[0] & 0x80;\n\n        last_fragment  = buf[0] & 0x40;\n\n        fu_type        = buf[0] & 0x3f;\n\n\n\n        /* pass the HEVC FU header */\n\n        buf += RTP_HEVC_FU_HEADER_SIZE;\n\n        len -= RTP_HEVC_FU_HEADER_SIZE;\n\n\n\n        /* pass the HEVC DONL field */\n\n        if (rtp_hevc_ctx->using_donl_field) {\n\n            buf += RTP_HEVC_DONL_FIELD_SIZE;\n\n            len -= RTP_HEVC_DONL_FIELD_SIZE;\n\n        }\n\n\n\n        av_dlog(ctx, \" FU type %d with %d bytes\\n\", fu_type, len);\n\n\n\n        if (len <= 0) {\n\n            /* sanity check for size of input packet: 1 byte payload at least */\n\n            av_log(ctx, AV_LOG_ERROR,\n\n                   \"Too short RTP/HEVC packet, got %d bytes of NAL unit type %d\\n\",\n\n                   len, nal_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (first_fragment && last_fragment) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Illegal combination of S and E bit in RTP/HEVC packet\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        new_nal_header[0] = (rtp_pl[0] & 0x81) | (fu_type << 1);\n\n        new_nal_header[1] = rtp_pl[1];\n\n\n\n        res = ff_h264_handle_frag_packet(pkt, buf, len, first_fragment,\n\n                                         new_nal_header, sizeof(new_nal_header));\n\n\n\n        break;\n\n    /* PACI packet */\n\n    case 50:\n\n        /* Temporal scalability control information (TSCI) */\n\n        avpriv_report_missing_feature(ctx, \"PACI packets for RTP/HEVC\\n\");\n\n        res = AVERROR_PATCHWELCOME;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return res;\n\n}\n", "idx": 13905, "substitutes": {"ctx": ["context", "tx", "pkg", "cm", "qa", "bc", "cv", "sync", "cam", "rc", "config", "jp", "cc", "ha", "utils", "Context", "connection", "lc", "ci", "ctrl", "cor", "conv", "auc", "cn", "progress", "wcs", "txt", "cmp", "fp", "loc", "ct", "conn", "client", "kw", "grad", "la", "uc", "nc", "kt", "cli", "ck", "ocr", "c", "cca", "crit", "anc", "cb", "cas", "nt", "sci", "sc", "cmd", "cf", "coll", "ack", "lex", "kb", "vc", "xc", "mac", "hw", "exec", "util", "cci", "cl", "ux"], "rtp_hevc_ctx": ["rtp_heic_ctx", "rtp_hevc_context", "rtp_hevc__context", "rtp_heic_context", "rtp_hevc__cas", "rtp_hevc__ctx", "rtp_hevc__tx", "rtp_hevc_tx", "rtp_heic_tx", "rtp_hevc_cas", "rtp_heic_cas"], "st": ["sta", "art", "sp", "ste", "std", "sw", "sth", "str", "ace", "nd", "ct", "ss", "ut", "mt", "stage", "se", "ST", "sb", "St", "inst", "sc", "nt", "ast", "sa", "rest", "src", "cur", "sts"], "pkt": ["pelt", "pet", " packet", "pct", "bkt", "hmt", "cpke", "nkt", "bck", "nmt", "facket", "Packet", " pqt", "nke", "fnt", "cpkt", "Pet", " pck", "Pnt", "fqt", "Pelt", "Pqt", "packet", " pct", "fet", "backet", "Pct", "pk", "belt", "pck", "Pk", "cpmt", "cpet", " pelt", "pqt", "fkt", "Pkt", "fk", "pke", "fct", "Pck", "het", "pnt", "hke", "hkt", " pet", " pk", "pmt", " pnt", "net"], "timestamp": ["temest", "tmeline", "rametime", "temestamp", "timest", "tmetime", "ramestamp", "temeline", "rameline", "temetime", "timeline", "ramest", "timetime", "tmestamp", "tmest"], "buf": ["func", "vec", "port", "proc", "context", "ff", "uc", "bc", "queue", "fd", "cv", "array", "ru", "batch", "config", "rc", "bb", "fb", "bn", "msg", "uf", "req", "conv", "bytes", "auc", "pool", "ref", "buffer", "txt", "bus", "bag", "fp", "loc", "fn", "br", "buff", "bp", "feat", "mem", "brace", "img", "rb", "exc", "fi", "pb", "data", "b", "wb", "Buff", "bf", "gb", "bh", "cb", "cas", "text", "cap", "bg", "cmd", "cf", "uv", "aux", "src", "window", "num", "cur", "pad", "header"], "len": ["en", "rev", "hl", "lin", "part", "fd", "enc", "Len", "fl", "lvl", "val", "lon", "lan", "l", "split", "lc", "fun", "dl", "lp", "bytes", "lang", "lit", "fn", "ld", "loc", "limit", "lib", "size", "ll", "bl", "la", "layer", "fin", "lt", "li", "data", "pl", "length", "count", "n", "lf", "list", "line", "end", "lu", "gen", "offset", "nt", "body", "elt", "pos", "lock", "num", "el", "span", "ln", "lim"], "seq": ["vec", "ret", "format", "queue", "val", "code", " resp", "sequence", "frame", " count", "version", "sec", "ver", "count", " sequence", "cb", "gen", "q", "pos", "num", "res", "flag", "cl", "vals", "ux"], "flags": ["ret", "ff", "ffff", "fd", "fs", "fields", "bytes", "ants", "rows", "fn", "files", "frame", "options", "features", "mask", "lag", "frames", "bits", "Flags", "offset", "ents", "rep", "ts", "flag", "vals"], "rtp_pl": ["rtpo__lang", "rtpo__prot", "rtp__pl", "rtp__ctx", "rtp__prot", "rtp_ctx", "rtpo_pl", "rtpo__ctx", "rtp_prot", "rtpo_ctx", "rtpo_prot", "rtp__lang", "rtpo_lang", "rtp_lang", "rtpo__pl"], "tid": ["lname", "fip", "tname", "tfid", "tiID", "fids", "tids", "tfkid", "nkid", "tkid", "tfok", "pid", "nide", "fname", "tiip", "nids", "pID", " tok", "tiide", " tkid", "pide", "nip", "tip", "tfID", "lip", "nID", "lids", "nname", "nid", "pip", "fid", "tID", "tiid", "tok", "nok", " tID", "tide"], "lid": ["paid", " lq", "pids", "llkid", " lkid", "tids", "tbid", "tkid", "elaid", "pid", " laid", "lq", "tend", "llid", "pend", "lbid", "lids", "llq", "taid", " lend", "llaid", "elkid", " lbid", "elbid", "lend", "tq", "lkid", "elid", " lids", "laid"], "nal_type": ["naler_name", "nal_types", "nal67type", "nstal_id", "nal_list", "nstal_style", "nal67ype", "naling_style", "nal___list", "nal67key", "nstal_name", "nbal_types", "nbal_type", "naling_level", "nbal_set", "nmal_key", "nal___type", "nal_style", "nbal_style", "nmal_ype", "nstal_types", "nal_Type", "nalpype", "nal_set", "nal_id", "nmal_Type", "nal___style", "nalpType", "nal67Type", "nal___types", "naler_id", "nalpkey", "nal_key", "nalptype", "nstal_type", "nal_ype", "nstal_list", "naling_type", "nmal_type", "nal_name", "naler_Type", "naler_type", "nal_level"], "first_fragment": ["first_frangement", "first_dragments", "first_frainment", "first_frigement", "first_dragement", "first_fragments", "first_draggment", "first_franggment", "first_frangments", "first_frainement", "first_fragement", "first_frigments", "first_drigments", "first_friggment", "first_fraggment", "first_dragment", "first_fraingment", "first_drigment", "first_frigment", "first_drigement", "first_driggment", "first_frangment", "first_frainments"], "last_fragment": ["last_fraggement", "last_figgment", "last_friggment", "last_frangment", "last_fraggments", "last_frigement", "last_fragggment", "last_fagments", "last_fagment", "last_figments", "last_frangments", "last_fraggment", "last_figement", "last_faggment", "last_frigments", "last_fragement", "last_figment", "last_frigment", "last_frangement", "last_fagement", "last_fragments", "last_franggment"], "fu_type": ["fucloffset", "uniqueclstate", "unique_key", "fuenstate", "unique_state", "fu_state", "fu_key", "fucltype", "fuentype", "fuclkey", "fuclstate", "uniqueclkey", "fuenkey", "unique_offset", "fu_offset", "uniquecloffset", "unique_type", "fuenoffset", "uniquecltype"], "new_nal_header": ["new_nul_num", "new_nal1entry", "new_nal1header", "new_nal_layer", "new_nal1layer", "new_nal_entry", "new_nul_header", "new_nal_num", "new_nalennum", "new_nul_entry", "new_nal1num", "new_nul_layer", "new_nalenentry", "new_nalenlayer", "new_nalenheader"]}}
{"project": "FFmpeg", "commit_id": "a04c2c707de2ce850f79870e84ac9d7ec7aa9143", "target": 1, "func": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13906, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "220b24c7c97dc033ceab1510549f66d0e7b52ef1", "target": 1, "func": "static int libschroedinger_encode_close(AVCodecContext *avctx)\n\n{\n\n    SchroEncoderParams *p_schro_params = avctx->priv_data;\n\n\n\n    /* Close the encoder. */\n\n    schro_encoder_free(p_schro_params->encoder);\n\n\n\n    /* Free data in the output frame queue. */\n\n    ff_schro_queue_free(&p_schro_params->enc_frame_queue,\n\n                        libschroedinger_free_frame);\n\n\n\n\n\n    /* Free the encoder buffer. */\n\n    if (p_schro_params->enc_buf_size)\n\n        av_freep(&p_schro_params->enc_buf);\n\n\n\n    /* Free the video format structure. */\n\n    av_freep(&p_schro_params->format);\n\n\n\n    return 0;\n\n}\n", "idx": 13915, "substitutes": {"avctx": ["AVconfig", "AVcmd", "AVcmp", "apconfig", "avcmp", "afcb", "AVcb", "apcontext", "AVcontext", "akcb", "apcmp", "afcmp", "apctx", "afconfig", "afcontext", "akcmd", "avcmd", "avcontext", "avcb", "akctx", "afctx", "afcmd", "AVctx", "avconfig", "akcontext"], "p_schro_params": ["p_schlo_manager", "p_schlo_params", "p_schro__channel", "p_schlo_ams", "p_schlo_param", "p_schro_ams", "p_schrosparams", "p_schro_manager", "p_schro__parser", "p_schroedparams", "p_schro__manager", "p_schro_data", "p_schro_master", "p_schro__param", "p_schros_param", "p_schrob_data", "p_schrosparam", "p_schro__params", "p_schrob_param", "p_schros_params", "p_schro_processor", "p_schrosmanager", "p_schrob_processor", "p_schroedmanager", "p_schrob_manager", "p_schroedparam", "p_schros_master", "p_schrob_parser", "p_schroedprocessor", "p_schrob_channel", "p_schro_channel", "p_schro_parser", "p_schro_param", "p_schros_manager", "p_schrob_params", "p_schrosams"]}}
{"project": "FFmpeg", "commit_id": "121be310607879841d19a34d9f16d4fe9ba7f18c", "target": 0, "func": "static int cinepak_decode_frame(AVCodecContext *avctx,\n\n                                void *data, int *got_frame,\n\n                                AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int ret = 0, buf_size = avpkt->size;\n\n    CinepakContext *s = avctx->priv_data;\n\n\n\n    s->data = buf;\n\n    s->size = buf_size;\n\n\n\n    if ((ret = ff_reget_buffer(avctx, s->frame)) < 0)\n\n        return ret;\n\n\n\n    if (s->palette_video) {\n\n        const uint8_t *pal = av_packet_get_side_data(avpkt, AV_PKT_DATA_PALETTE, NULL);\n\n        if (pal) {\n\n            s->frame->palette_has_changed = 1;\n\n            memcpy(s->pal, pal, AVPALETTE_SIZE);\n\n        }\n\n    }\n\n\n\n    if ((ret = cinepak_decode(s)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"cinepak_decode failed\\n\");\n\n    }\n\n\n\n    if (s->palette_video)\n\n        memcpy (s->frame->data[1], s->pal, AVPALETTE_SIZE);\n\n\n\n    if ((ret = av_frame_ref(data, s->frame)) < 0)\n\n        return ret;\n\n\n\n    *got_frame = 1;\n\n\n\n    /* report that the buffer was completely consumed */\n\n    return buf_size;\n\n}\n", "idx": 13943, "substitutes": {"avctx": ["abcontext", "afpkg", "AVcmp", "afcv", "ajcu", "airctx", "ajcontext", "avcmp", "avcv", "aircv", "abcmp", "apcontext", "ajcv", "AVcontext", "avectx", "akcmp", "afcu", "afcmp", "avecv", "abcv", "apctx", "akpkg", "avnp", "afcontext", "ajctx", "avectl", "apcu", "avcu", "aircmp", "apnp", "AVpkg", "avcontext", "akctx", "aircontext", "ajnp", "afctx", "afctl", "AVctx", "avecontext", "avpkg", "afnp", "ajctl", "avctl", "abctx", "akcontext"], "data": ["device", "map", "val", "memory", "image", "new", "module", "raw", "frame", "media", "rec", "base", "reader", "flow", "window", "message", "func", "args", "actions", "call", "bin", "slice", "d", "id", "req", "resource", "length", "result", "feed", "body", "results", "cache", "empty", "res", "ada", "after", "queue", "connection", "buffer", "package", "value", "o", "alpha", "ad", "family", "info", "f", "block", "DATA", "load", "ata", "video", "pos", "delay", "channel", "board", "input", "response", "code", "da", "a", "name", "buff", "open", "size", "la", "p", "parent", "dat", "next", "Data", "file", "content", "start"], "got_frame": ["gotacframe", "got_fram", "get_thread", "gotacfram", "get_frames", "get_size", "get_fram", "got_Frame", "get_Frame", "got_thread", "got_size", "get_frame", "gotacthread", "got_frames", "gotacFrame"], "avpkt": ["avfelt", "avppkt", " avwpkt", "avfpacket", "awpqt", "avcpkt", "avpaelt", "avpakh", "AVpacket", "avfcht", "avwpcht", "avplelt", "avcpqt", "avfpet", "avfwk", "avcpacket", "awpkt", "avpct", "avcett", "avcct", "avcpcht", "avfkh", "avnpkt", "avcpet", "avpqt", "avplkh", "avcpett", "awnpct", "avpacket", "affacket", " avpwk", "affelt", "avpcht", " avpcht", "avcpct", "afpkt", "avpelt", " avwpcht", "avplacket", "avfkt", "afpelt", "avpett", "avwpwk", "afpkh", "avfpkt", "awpct", "AVcpacket", "afpacket", "avpakt", "avppacket", "avwpkt", "awnpqt", "AVpkt", "avppcht", "AVcpkt", "affkh", "avwpacket", "avfacket", "avpwk", "avpaacket", "avnpqt", "avnpett", "AVcpcht", "affkt", " avwpwk", "AVcpet", "AVpcht", "AVpet", "awpett", " avwpacket", " avpacket", "avcqt", "awnpkt", "avpet", "avppwk", "avckt", "awnpett", "avplkt", "avnpct", "avfet", "avfpcht", "avpkh"], "buf": ["port", "vec", "ff", "uc", "bc", "queue", "fd", "array", "cv", "tmp", "config", "val", "fb", "bd", "uf", "pool", "ref", "buffer", "raw", "bag", "fp", "v", "raf", "buff", "obj", "p", "pack", "fi", "rb", "pb", "b", "base", "Buffer", "box", "Buff", "f", "block", "cb", "cache", "pad", "ctx", "alloc"], "s": ["i", "rs", "qs", "h", "new", "si", "js", "server", "ps", "obj", "spec", "c", "is", "sc", "aws", "m", "self", "bis", "d", "t", "sync", "sg", "ins", "fs", "sym", "g", "cs", "es", "full", "session", "b", "ns", "ops", "sports", "ks", "sys", "parts", "service", "hs", "os", "o", "ms", "e", "site", "sb", "f", "ans", "services", "ls", "comments", "ctx", "ses", "as", "bs", "l", "a", "S", "its", "uns", "sq", "ss", "p", "n", "gs", "xs", "ssl", "ds", "su", "us", "ts", "vs", "y"], "pal": ["plug", "area", "channel", "phil", "bin", "nl", "ale", "lan", "pixel", "label", "local", "wan", "align", "pel", "py", "panel", "sk", "stal", "plan", "pp", "skin", "pid", "nav", "sal", "Pal", "ali", "pill", "ascal", "pol", "app", "ill", "v", "bl", "p", "pod", "wal", "pack", "pl", "pa", "li", "cel", "bil", "opal", "il", "par", "pe", "ne", "ell", "isal", "scale", "fal", "le", "cal", "cell", "vale", "chal", "al", "pocket", "theme", "rel", "el", "ph", "alias", "gal", "bel"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void taihu_405ep_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    char *filename;\n\n    qemu_irq *pic;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n    MemoryRegion *bios;\n\n    MemoryRegion *ram_memories = g_malloc(2 * sizeof(*ram_memories));\n\n    MemoryRegion *ram = g_malloc0(sizeof(*ram));\n\n    hwaddr ram_bases[2], ram_sizes[2];\n\n    long bios_size;\n\n    target_ulong kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    int linux_boot;\n\n    int fl_idx, fl_sectors;\n\n    DriveInfo *dinfo;\n\n\n\n    /* RAM is soldered to the board so the size cannot be changed */\n\n    ram_size = 0x08000000;\n\n    memory_region_allocate_system_memory(ram, NULL, \"taihu_405ep.ram\",\n\n                                         ram_size);\n\n\n\n    ram_bases[0] = 0;\n\n    ram_sizes[0] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[0], NULL,\n\n                             \"taihu_405ep.ram-0\", ram, ram_bases[0],\n\n                             ram_sizes[0]);\n\n    ram_bases[1] = 0x04000000;\n\n    ram_sizes[1] = 0x04000000;\n\n    memory_region_init_alias(&ram_memories[1], NULL,\n\n                             \"taihu_405ep.ram-1\", ram, ram_bases[1],\n\n                             ram_sizes[1]);\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register cpu\\n\", __func__);\n\n#endif\n\n    ppc405ep_init(sysmem, ram_memories, ram_bases, ram_sizes,\n\n                  33333333, &pic, kernel_filename == NULL ? 0 : 1);\n\n    /* allocate and load BIOS */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register BIOS\\n\", __func__);\n\n#endif\n\n    fl_idx = 0;\n\n#if defined(USE_FLASH_BIOS)\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 2MB */\n\n        //        bios_size = 2 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr %lx '%s' %d\\n\",\n\n               fl_idx, bios_size, -bios_size,\n\n               bdrv_get_device_name(bs), fl_sectors);\n\n#endif\n\n        pflash_cfi02_register((uint32_t)(-bios_size),\n\n                              NULL, \"taihu_405ep.bios\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    } else\n\n#endif\n\n    {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Load BIOS from file\\n\");\n\n#endif\n\n        if (bios_name == NULL)\n\n            bios_name = BIOS_FILENAME;\n\n        bios = g_new(MemoryRegion, 1);\n\n        memory_region_init_ram(bios, NULL, \"taihu_405ep.bios\", BIOS_SIZE,\n\n                               &error_abort);\n\n        vmstate_register_ram_global(bios);\n\n        filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n        if (filename) {\n\n            bios_size = load_image(filename, memory_region_get_ram_ptr(bios));\n\n            g_free(filename);\n\n            if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n                error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n                exit(1);\n\n            }\n\n            bios_size = (bios_size + 0xfff) & ~0xfff;\n\n            memory_region_add_subregion(sysmem, (uint32_t)(-bios_size), bios);\n\n        } else if (!qtest_enabled()) {\n\n            error_report(\"Could not load PowerPC BIOS '%s'\", bios_name);\n\n            exit(1);\n\n        }\n\n        memory_region_set_readonly(bios, true);\n\n    }\n\n    /* Register Linux flash */\n\n    dinfo = drive_get(IF_PFLASH, 0, fl_idx);\n\n    if (dinfo) {\n\n        BlockDriverState *bs = blk_bs(blk_by_legacy_dinfo(dinfo));\n\n\n\n        bios_size = bdrv_getlength(bs);\n\n        /* XXX: should check that size is 32MB */\n\n        bios_size = 32 * 1024 * 1024;\n\n        fl_sectors = (bios_size + 65535) >> 16;\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"Register parallel flash %d size %lx\"\n\n               \" at addr \" TARGET_FMT_lx \" '%s'\\n\",\n\n               fl_idx, bios_size, (target_ulong)0xfc000000,\n\n               bdrv_get_device_name(bs));\n\n#endif\n\n        pflash_cfi02_register(0xfc000000, NULL, \"taihu_405ep.flash\", bios_size,\n\n                              bs, 65536, fl_sectors, 1,\n\n                              4, 0x0001, 0x22DA, 0x0000, 0x0000, 0x555, 0x2AA,\n\n                              1);\n\n        fl_idx++;\n\n    }\n\n    /* Register CLPD & LCD display */\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: register CPLD\\n\", __func__);\n\n#endif\n\n    taihu_cpld_init(sysmem, 0x50100000);\n\n    /* Load kernel */\n\n    linux_boot = (kernel_filename != NULL);\n\n    if (linux_boot) {\n\n#ifdef DEBUG_BOARD_INIT\n\n        printf(\"%s: load kernel\\n\", __func__);\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                fprintf(stderr,\n\n                        \"qemu: could not load initial ram disk '%s'\\n\",\n\n                        initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n    }\n\n#ifdef DEBUG_BOARD_INIT\n\n    printf(\"%s: Done\\n\", __func__);\n\n#endif\n\n}\n", "idx": 13951, "substitutes": {"machine": ["device", "database", "m", "mc", "part", "service", "config", "mount", "memory", "object", "motion", "connection", "manager", "image", "cpu", "module", "vm", "model", "linux", "session", "computer", "storage", "loader", "mem", "instance", "mini", "boot", "mobile", "Machine", "data", "base", "mode", "address", "state", "M", "process", "hard", "mac", "cache", "db", "template", "space", "program", "controller", "sm", "node", "message"], "kernel_filename": ["kernelboardsize", "kernelboarddirectory", "kernel_theme", "kernel_Filename", "kernel_information", "kernelpubtheme", "loader_directory", "ernel_name", "kernel_label", "loader_information", " kernel_file", " kernel_Filename", "kernelboardinformation", "kernel_name", "kernelpubfilename", "loader_filename", "loader_size", "kernelpubFilename", " kernel_theme", "kernelpubfile", "ernel_label", "kernel_file", "ernel_filename", "kernel_directory", "kernelboardfilename"], "initrd_filename": ["initrd__memory", "initrd__binary", "initrd_memory", "initrd67filename", "initrd67username", "initrt_memory", "initrd_username", "initrt_username", "initrd__filename", "initrd67binary", "initrt_description", "initrd_binary", "initrd67memory", "initrd_description", "initrd__username", "initrd___description", "initrt_binary", "initrd_width", "initrd___filename", "initrt_width", "initrt_filename", "initrd___username", "initrd___width"], "filename": ["path", "pixel", "binary", "name", "image", "original", "writer", "fp", "fn", "uri", "files", "Filename", "password", "document", "processor", "kl", "picture", "acl", "fil", "url", "file", "login", "File", "prefix", "tty", "username"], "pic": ["sys", "bin", "cam", "sync", "xi", "pc", "fs", "pins", "pixel", "lc", "ig", "misc", "image", "Pic", "bus", "writer", "fn", "script", "lib", "temp", "mini", "fi", "mic", "picture", "pict", "pin", "ac", "pi", "sci", "file", "ic", "gui", "cache", "mac", "nic", "fc"], "sysmem": ["syslim", "ysmem", "smem", "osmemory", "systemmem", "systemmemory", "sysmemory", "systemlim", "osram", " sysram", " sysmemory", "svm", "sysvm", "sram", "osvm", "osmem", " syslim", "ysmemory", "ysram", "systemram", "yslim", "smemory", "sysram", "systemvm"], "bios": ["bii", "nbio", "Bias", "bio", "Bio", "nbii", "nbios", "Bios", "rbios", "bias", "Bii", "nbias", "rbias", "rbio", "rbii"], "ram_memories": ["ram_factories", "ram_combories", "ram_memoryories", "ram_factrollers", "ram_combrices", "ram_memores", "ram_tomorers", "ram_regores", "ram_memoryors", "ram_processores", "ram_tomories", "ram_memrollers", "ram_accesseters", "ram_combives", "ram_memors", "ram_accessrollers", "ram_accessory", "ram_processories", "ram_tomives", "ram_memeters", "ram_accessories", "ram_processrices", "ram_factory", "ram_regors", "ram_temores", "ram_regories", "ram_comborers", "ram_temories", "ram_memrices", "ram_memoryory", "ram_processives", "ram_temrollers", "ram_processipes", "ram_regory", "ram_memives", "ram_memory", "ram_regeters", "ram_processory", "ram_processors", "ram_factores", "ram_memoryipes", "ram_tomrices", "ram_temors", "ram_memipes", "ram_memorers", "ram_regipes", "ram_accessores", "ram_temeters", "ram_temory", "ram_processorers", "ram_accessors"], "ram": ["channel", "device", "micro", "mc", "cam", "cm", "array", "nam", "mount", "pc", "memory", "container", "pixel", "amd", "row", "ra", "image", "kernel", "cpu", "user", "module", "vm", "mm", "grain", "jam", "sim", "region", "win", "access", "RAM", "password", "loader", "mem", "mor", "sam", "resource", "folder", "pack", "dam", "iam", "mode", "rw", "gb", "am", "gam", "gram", "sc", "process", "man", "mac", "disk", "Ram", "rage", "program", "space", "dim", "ruby", "hw"], "ram_bases": ["ram_bubabilities", "ram_soots", "ram_bices", "ram_buffasing", "ram_bubasing", "ram_abasing", "ram_ambamps", "ram_bashes", "ram_babilities", "ram_Boots", "ram_lases", "ram_boots", "ram_ambizes", "ram_lasing", "ram_batches", "ram_Bases", "ram_bamps", "ram_sasing", "ram_buffase", "ram_ambabilities", "ram_labilities", "ram_dices", "ram_backusters", "ram_buses", "ram_buffases", "ram_mases", "ram_Bizes", "ram_ambasing", "ram_latches", "ram_abores", "ram_wbamps", "ram_backoots", "ram_sases", "ram_ambashes", "ram_dasing", "ram_brasing", "ram_brices", "ram_Base", "ram_Bamps", "ram_Basing", "ram_bubases", "ram_wbasing", "ram_Batches", "ram_backasing", "ram_masing", "ram_basing", "ram_brases", "ram_buffores", "ram_bores", "ram_base", "ram_Busters", "ram_wbizes", "ram_bubices", "ram_abase", "ram_abases", "ram_duses", "ram_busters", "ram_wbases", "ram_lashes", "ram_lase", "ram_susters", "ram_bubuses", "ram_backases", "ram_matches", "ram_bubashes", "ram_ambases", "ram_lores", "ram_mase", "ram_bruses", "ram_dases", "ram_bizes"], "ram_sizes": ["ram_sizations", "ram_insensing", "ram_statizing", "ram_sizers", "ram_syiques", "ram_samples", "ram_isizes", "ram_pizations", "ram_setsizes", "ram_syizes", "ram_sises", "ram_setsenses", "ram_statesizing", "ram_sizing", "ram_sesessions", "ram_setsomes", "ram_sixels", "ram_cizers", "ram_statesises", "ram_syomes", "ram_pises", "ram_statesizes", "ram_insases", "ram_insizing", "ram_ciques", "ram_senses", "ram_camples", "ram_isizable", "ram_isizers", "ram_statesizations", "ram_insixels", "ram_insamples", "ram_asizations", "ram_asizes", "ram_cessions", "ram_sizable", "ram_setsamples", "ram_syenses", "ram_sases", "ram_setsensing", "ram_ensize", "ram_asises", "ram_esizing", "ram_cizable", "ram_esizes", "ram_cizing", "ram_sesizes", "ram_sesizing", "ram_isizing", "ram_somes", "ram_censes", "ram_siques", "ram_size", "ram_statizes", "ram_censing", "ram_sessions", "ram_setsixels", "ram_sesize", "ram_esases", "ram_esensing", "ram_cizes", "ram_cixels", "ram_asizing", "ram_sensing", "ram_ensizing", "ram_cize", "ram_pizes", "ram_comes", "ram_pizing", "ram_statizers", "ram_insizes", "ram_setsiques", "ram_ensessions", "ram_statizable", "ram_cases", "ram_ensizes"], "bios_size": ["bits_width", "bits_size", "bios_width", "bios_capacity", "bits_capacity"], "kernel_base": ["ram_scale", "kernel_scale", "ram_size", "ram_area", "kernel_area", "ram_base"], "initrd_base": ["initrs_buffer", "initrd_buffer", "initrs_width", "initrd_width", "initrs_base", "initrs_size"], "kernel_size": ["ernel_base", "ernel_capacity", "kernel_width", "ernel_width", "kernel_capacity", "ernel_size"], "initrd_size": ["initrs_capacity", "initrd_capacity", "initrs_base", "initrs_size"], "linux_boot": ["sys_size", "linux_mount", "sys_boot", "linux86mount", "linux86boot", "linux86size", "sys_setup", "sys_mount", "linux86setup", "linux_setup", "linux_size"], "fl_idx": ["fl__idx", "fl_idex", "fl_sidx", "fl_ideX", "fl_idxe", "fl_Idy", "fl_pidxes", "fl_idxes", "fl__Idb", "fl_idf", "fl_Idf", "fl_sidxe", "fl_Idb", "fl_sidf", "fl_idb", "fl_pidxs", "fl_idX", "fl__Idxs", "fl_Idxe", "fl__Idx", "fl__idxs", "fl__idxes", "fl_Idz", "fl_sidX", "fl_idez", "fl__idb", "fl_Idx", "fl_idxs", "fl_Idxs", "fl_idy", "fl_idz", "fl_pidb", "fl_idef", "fl_IdX", "fl_Idxes", "fl_pidx", "fl_idey", "fl__Idxes", "fl_idexe"], "fl_sectors": ["fl_sex", "fl_clegment", "fl_clex", "fl_segment", "fl_idlic", "fl_idctors", "fl_vectors", "fl_idgment", "fl_velic", "fl_selic", "fl_clelic", "fl_vex", "fl_vegment", "fl_clectors"], "dinfo": ["dstate", "dnInfo", "dbtype", " daction", "dnINFO", "bstate", "dminfo", "lstate", "linfo", "Daction", "dlaction", "dmInfo", "binfo", "lindex", " dindex", "dInfo", "DINFO", "dtype", "dINFO", "bInfo", "dindex", "dbinfo", "dninfo", "dmaction", "dbaction", "lInfo", "DInfo", " dInfo", "Dinfo", "dnaction", "dmINFO", " dtype", "bindex", "daction", "dbInfo", "dlInfo", " dstate", "dlinfo", "dltype"], "bs": ["ses", "bis", "bid", "bc", "BS", "fs", "ins", "rs", "bd", "fps", "ps", "ss", "ba", "pb", "gs", "gb", "ns", "bps", "bas", "ds", "bi", "sa", "ls", "ts", "ils", "bl", "iss", "BT"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static void *ff_avio_child_next(void *obj, void *prev)\n\n{\n\n    AVIOContext *s = obj;\n\n    AVIOInternal *internal = s->opaque;\n\n    return prev ? NULL : internal->h;\n\n}\n", "idx": 13969, "substitutes": {"obj": ["self", "pkg", "tmp", "sync", "jp", "i", "object", "inf", "api", "os", "ref", "init", "js", "scope", "Obj", "o", "lib", "open", "p", "rb", "img", "sb", "b", "op", "inst", "att", "ns", "cb", "nt", "objects", "attr", "ops", "coll", "cpp", "src", "opt", "ctx", "node"], "prev": ["upper", "proc", "before", "self", "rev", "root", "after", "inter", "winner", "back", "orig", "pre", "original", "pres", "pred", "var", "request", "super", "rec", "Prev", "p", "info", "desc", "op", "result", "parent", "wp", "skip", "vious", "pper", "inc", "next", "first", "above", "counter", "reverse", "iter", "ep", "initial", "rel", "prefix", "cur", "post", "node"], "s": ["south", "sys", "ses", "self", "sg", "fs", "native", "private", "external", "object", "a", "api", "g", "S", "os", "h", "sr", "sq", "v", "storage", "ss", "o", "p", "sf", "sb", "n", "f", "c", "ns", "single", "inner", "sn", "ssl", "sv", "sl", "ops", "r", "ds"]}}
{"project": "qemu", "commit_id": "2886be1b01c274570fa139748a402207482405bd", "target": 1, "func": "static void pm_ioport_read(IORange *ioport, uint64_t addr, unsigned width,\n\n                            uint64_t *data)\n\n{\n\n    PIIX4PMState *s = container_of(ioport, PIIX4PMState, ioport);\n\n    uint32_t val;\n\n\n\n    switch(addr) {\n\n    case 0x00:\n\n        val = acpi_pm1_evt_get_sts(&s->ar, s->ar.tmr.overflow_time);\n\n        break;\n\n    case 0x02:\n\n        val = s->ar.pm1.evt.en;\n\n        break;\n\n    case 0x04:\n\n        val = s->ar.pm1.cnt.cnt;\n\n        break;\n\n    case 0x08:\n\n        val = acpi_pm_tmr_get(&s->ar);\n\n        break;\n\n    default:\n\n        val = 0;\n\n        break;\n\n    }\n\n    PIIX4_DPRINTF(\"PM readw port=0x%04x val=0x%04x\\n\", (unsigned int)addr, val);\n\n    *data = val;\n\n}\n", "idx": 13988, "substitutes": {"ioport": ["imetorter", "iport", "coporter", "iporter", "oporn", "oport", "ioorter", "ioported", "iprt", "ioporter", "coported", "imetorn", "coport", "ioorn", "ioporn", "ioort", "ipore", "ioorted", "imetort", "oporter", "iported", "coprt", "oported", "imetorted", "iopore", "opore", "ioprt", "ioore", "imetrt"], "addr": ["ord", "device", "proc", "context", "amp", "enc", "arm", "rc", "config", "amd", "id", "align", "x", "ref", "ace", "xp", "frame", "conn", "grad", "ad", "adr", "layer", "rx", "socket", "pointer", "ext", "kt", "mode", "address", "state", "ip", "url", "proxy", "route", "arr", "offset", "cb", "eth", "attr", "cmd", "rt", "ack", "host", "mac", "aud", "src", "seq", "inet", "dr", "pos", "prefix", "delay", "pad", "header", "len", "ptr", "index", "start"], "data": ["action", "d", "array", "response", "input", "config", "i", "da", "def", "align", "new", "di", "status", "buffer", "update", "aa", "valid", "v", "value", "alpha", "size", "la", "p", "buf", "result", "parent", "dat", "address", "state", "block", "arr", "Data", "feed", "body", "attr", "wa", "DATA", "write", "ata", "cache", "fee", "al", "len", "index"], "s": ["south", "sys", "m", "ses", "self", "as", "service", "t", "d", "sync", "fs", "your", "i", "rs", "sym", "a", "g", "cs", "qs", "S", "os", "es", "si", "js", "sq", "uns", "session", "ps", "ss", "conf", "o", "an", "p", "e", "sb", "b", "n", "f", "gs", "c", "ns", "is", "ssl", "sl", "states", "r", "services", "ds", "su", "ls", "ts", "us", "aws"], "val": ["bc", "pre", "def", "local", "eval", "x", "status", "vol", "ind", "dev", "mem", "base", "stat", "serv", "sl", "fail", "fee", "index", "call", "part", "key", "error", "pass", "grad", "doc", "b", "min", "result", "ann", "il", "arr", "cal", "exec", "al", "rel", "el", "vals", "alt", "slot", "VAL", "ref", "unit", "update", "live", "pid", "valid", "value", "fe", "rl", "Val", "sel", "pos", "bl", "err", "ret", "split", "pt", "cond", "v", "p", "ee", "ol", "all", "aval", "db", "len"]}}
{"project": "FFmpeg", "commit_id": "4d87001096ff1d4e3ee6f88f8caddbd8ccb2c816", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014, "substitutes": {"s": ["i", "rs", "qs", "h", "new", "si", "js", "ps", "params", "spec", "c", "is", "ics", "states", "aws", "args", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "w", "cons", "u", "sf", "b", "ns", "ops", "r", "sis", "ks", "sys", "parts", "service", "your", "has", "hs", "os", "sets", "o", "ms", "e", "http", "site", "sb", "f", "less", "services", "ls", "ses", "as", "ys", "l", "a", "sites", "S", "its", "uns", "sq", "conf", "ss", "p", "n", "ments", "gs", "xs", "stats", "ssl", "ic", "ds", "su", "ts", "us", "y"], "height": ["stroke", "device", "Height", "deep", "input", "thin", "bottom", "id", "level", "density", "style", "shape", "container", "api", "row", "gap", "image", "hub", "h", "missing", "buffer", "gh", "crop", "rows", "rh", "rank", "alpha", "w", "view", "size", "tight", "img", "direction", "gallery", "huge", "max", "driver", "length", "read", "th", "padding", "resolution", "gpu", "inches", "above", "hold", "dim", "layout", "volume", "high", "window", "ty", "lat", "y", "depth", "fw"]}}
{"project": "qemu", "commit_id": "01b05c66a3616d5a4adc39fc90962e9efaf791d1", "target": 1, "func": "int nbd_receive_reply(QIOChannel *ioc, NBDReply *reply, Error **errp)\n\n{\n\n    int ret;\n\n    const char *type;\n\n\n\n    ret = nbd_read_eof(ioc, &reply->magic, sizeof(reply->magic), errp);\n\n    if (ret <= 0) {\n\n        return ret;\n\n    }\n\n\n\n    be32_to_cpus(&reply->magic);\n\n\n\n    switch (reply->magic) {\n\n    case NBD_SIMPLE_REPLY_MAGIC:\n\n        ret = nbd_receive_simple_reply(ioc, &reply->simple, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n\n\n        trace_nbd_receive_simple_reply(reply->simple.error,\n\n                                       nbd_err_lookup(reply->simple.error),\n\n                                       reply->handle);\n\n        if (reply->simple.error == NBD_ESHUTDOWN) {\n\n            /* This works even on mingw which lacks a native ESHUTDOWN */\n\n            error_setg(errp, \"server shutting down\");\n\n            return -EINVAL;\n\n        }\n\n        break;\n\n    case NBD_STRUCTURED_REPLY_MAGIC:\n\n        ret = nbd_receive_structured_reply_chunk(ioc, &reply->structured, errp);\n\n        if (ret < 0) {\n\n            break;\n\n        }\n\n        type = nbd_reply_type_lookup(reply->structured.type);\n\n        trace_nbd_receive_structured_reply_chunk(reply->structured.flags,\n\n                                                 reply->structured.type, type,\n\n                                                 reply->structured.handle,\n\n                                                 reply->structured.length);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"invalid magic (got 0x%\" PRIx32 \")\", reply->magic);\n\n        return -EINVAL;\n\n    }\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 14022, "substitutes": {"ioc": ["iocy", "xioci", "uiocl", "aioci", "uoc", "ioocl", "aiocl", "uiOC", "uocon", "tioc", "iiocon", "iiocl", "iioc", "iroc", "ioocent", "iooc", "ioocon", "tioci", "uOC", "ioci", "iOC", " iocy", " iocl", "aioc", "pioc", "iocon", "piocl", "uocl", "iocent", "uocent", "iooci", "ioroc", "uoci", "xiocl", "tiocy", "uioc", " ioci", "iiocent", "iocl", "pioci", "uioci", "piocy", "xiroc", "airoc", "xioc", "tiocl", "ioOC"], "reply": ["notice", "bug", "transfer", "database", "record", "rr", "repair", "remote", "call", "queue", "sync", "response", "service", "jp", "back", "connection", "respond", "reference", "answer", "send", "image", "py", "module", "buffer", "model", "update", "comment", "report", "server", "Reply", "frame", "error", "patch", "job", "request", "same", "parse", "plugin", "bot", "related", "info", "resource", "http", "match", "entry", "address", "query", "ping", "feature", "proxy", "route", "next", "reason", "ry", "diff", "re", "link", "write", "resp", "command", "repl", "template", "prefix", "order", "flag", "post", "join", "replace", "message"], "errp": ["acec", "errpy", "asterp", " errf", "asterf", "asterfp", "erfp", "acep", "errf", "errorp", " errc", "inerc", "erlp", " erp", "irpp", " errcp", "errorfp", "errfp", " erping", "errc", "ercp", " erc", "erc", "errorpy", "erping", " errfp", "inerf", "erpp", "erp", "acefp", " erfp", "errpp", " erlp", " errpy", " errlp", "acepo", "irp", "errpo", "errorf", "errlp", " erpp", "errcp", " errpo", "erf", "errorc", "inerp", "errorcp", "irlp", "irfp", "asterlp", "inerpy", " errping", "erpo", "errping"], "ret": ["pet", "en", "art", "val", "gt", "str", "obj", "active", "mem", "rb", "base", "bf", " RET", "att", "cat", "out", "RET", "off", "order", "ft", "rev", "part", "rc", "id", "rets", "det", "arg", "error", "pass", "mt", "data", "ext", "result", "url", "arr", "try", "repl", "al", "res", "reg", "rf", "flag", "run", "alt", "let", "format", "fun", "ref", "pret", "lit", "valid", "bot", "Ret", "reset", "nt", "re", "rt", "rep", "bit", "code", "back", "pt", "feat", "success", "match", "fit", "resp", "last", "db", "pat", "len", "opt"], "type": ["types", "alt", "Type", "kind", "port", "ype", "format", "part", "id", "code", "owner", "level", "val", "style", "pre", "name", "weight", "image", "py", "null", "status", "ref", "unit", "lang", "method", "TYPE", "comment", "key", "error", "like", "value", "patch", "loc", "var", "col", "group", "size", "version", "p", "time", "info", "match", "where", "op", "length", "mode", "count", "parent", "address", "state", "ping", "url", "block", "offset", "target", "attr", "rule", "year", "field", "class", "tag", "lock", "rel", "ty", "copy", "order", "y", "handle", "index"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static void ne2000_receive(void *opaque, const uint8_t *buf, int size)\n\n{\n\n    NE2000State *s = opaque;\n\n    uint8_t *p;\n\n    int total_len, next, avail, len, index, mcast_idx;\n\n    uint8_t buf1[60];\n\n    static const uint8_t broadcast_macaddr[6] = \n\n        { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n\n    \n\n#if defined(DEBUG_NE2000)\n\n    printf(\"NE2000: received len=%d\\n\", size);\n\n#endif\n\n\n\n    if (!ne2000_can_receive(s))\n\n        return;\n\n    \n\n    /* XXX: check this */\n\n    if (s->rxcr & 0x10) {\n\n        /* promiscuous: receive all */\n\n    } else {\n\n        if (!memcmp(buf,  broadcast_macaddr, 6)) {\n\n            /* broadcast address */\n\n            if (!(s->rxcr & 0x04))\n\n                return;\n\n        } else if (buf[0] & 0x01) {\n\n            /* multicast */\n\n            if (!(s->rxcr & 0x08))\n\n                return;\n\n            mcast_idx = compute_mcast_idx(buf);\n\n            if (!(s->mult[mcast_idx >> 3] & (1 << (mcast_idx & 7))))\n\n                return;\n\n        } else if (s->mem[0] == buf[0] &&\n\n                   s->mem[2] == buf[1] &&                   \n\n                   s->mem[4] == buf[2] &&            \n\n                   s->mem[6] == buf[3] &&            \n\n                   s->mem[8] == buf[4] &&            \n\n                   s->mem[10] == buf[5]) {\n\n            /* match */\n\n        } else {\n\n            return;\n\n        }\n\n    }\n\n\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    index = s->curpag << 8;\n\n    /* 4 bytes for header */\n\n    total_len = size + 4;\n\n    /* address for next packet (4 bytes for CRC) */\n\n    next = index + ((total_len + 4 + 255) & ~0xff);\n\n    if (next >= s->stop)\n\n        next -= (s->stop - s->start);\n\n    /* prepare packet header */\n\n    p = s->mem + index;\n\n    s->rsr = ENRSR_RXOK; /* receive status */\n\n    /* XXX: check this */\n\n    if (buf[0] & 0x01)\n\n        s->rsr |= ENRSR_PHY;\n\n    p[0] = s->rsr;\n\n    p[1] = next >> 8;\n\n    p[2] = total_len;\n\n    p[3] = total_len >> 8;\n\n    index += 4;\n\n\n\n    /* write packet data */\n\n    while (size > 0) {\n\n        avail = s->stop - index;\n\n        len = size;\n\n        if (len > avail)\n\n            len = avail;\n\n        memcpy(s->mem + index, buf, len);\n\n        buf += len;\n\n        index += len;\n\n        if (index == s->stop)\n\n            index = s->start;\n\n        size -= len;\n\n    }\n\n    s->curpag = next >> 8;\n\n\n\n    /* now we can signal we have receive something */\n\n    s->isr |= ENISR_RX;\n\n    ne2000_update_irq(s);\n\n}\n", "idx": 14023, "substitutes": {"opaque": ["opace", "copacity", "operaco", "opatile", "iopatile", "obatile", "coac", "opac", "obacity", "opaco", "ospaco", "obaque", "iopace", "operaque", "obace", "opacity", "iopaque", "ospaque", "ospac", "iopacity", "copaque", "coaque", "coaco", "copace", "operac", "copatile"], "buf": ["aka", "map", "port", "proc", "ff", "ha", "bc", "msg", "pool", "fp", "loc", "br", "mem", "rb", "fab", "box", "Buffer", "c", "cat", "cb", "cas", "text", "aux", "window", "num", "prop", "comb", "func", "context", "bin", "rc", "home", "uf", "conv", "img", "fi", "data", "b", "wb", "page", "Buff", "result", "cap", "uv", "cache", "header", "ptr", "alloc", "queue", "fd", "cv", "config", "fb", "uber", "bd", "buffer", "bag", "grab", "f", "gb", "bh", "bu", "block", "bo", "cf", "que", "cur", "ph", "ctx", "lim", "vec", "uc", "tmp", "code", "dest", "v", "buff", "av", "pb", "ab", "cmd", "src", "seq", "coord"], "size": ["en", "i", "shape", "bytes", "si", "loc", "count", "speed", "export", "c", "timeout", "end", "offset", "fee", "num", "args", "g", "weight", "Size", "sum", "storage", "six", "data", "length", "cache", "empty", "core", "small", "sized", "large", "unit", "z", "e", "sec", "li", "address", "SIZE", "sh", "pos", "zero", "enc", "code", "name", "capacity", "ize", "time", "mini", "n", "now", "scale", "max"], "s": ["i", "qs", "new", "si", "js", "server", "ps", "spec", "c", "serv", "is", "sl", "states", "aws", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "g", "cs", "es", "session", "w", "u", "socket", "b", "sf", "ns", "r", "sie", "ks", "secondary", "sys", "service", "your", "private", "hs", "os", "sets", "o", "e", "sec", "site", "http", "sb", "f", "state", "services", "ls", "ses", "l", "a", "S", "settings", "this", "its", "sq", "conf", "ss", "se", "ions", "n", "gs", "stats", "ssl", "ds", "su", "ts", "us", "y"], "p": ["port", "proc", "m", "po", "d", "t", "pc", "jp", "i", "a", "pre", "press", "g", "sp", "h", "fp", "ps", "o", "np", "bp", "w", "z", "e", "pointer", "b", "op", "j", "n", "f", "ping", "c", "span", "q", "r", "cp", "pos", "pad", "P", "tp"], "total_len": ["total_en", "total_pos", "total_lon", "Total_lon", "total_rev", " total_Len", " total_pos", "Total_mem", "sum_fin", "Total_len", "total_fin", " total_rev", "sum_en", "total_mem", "Total_Len", "sum_len", "total_Len", "sum_pos"], "next": ["zip", "adj", "bridge", "future", "head", "done", "bis", "reply", "response", "code", "latest", "second", "Next", "current", "front", "new", "this", "later", "sequence", "error", "valid", "frame", "conn", "step", "open", "doc", "sec", "li", "pointer", "data", "min", "j", "count", "length", "result", "skip", "state", "big", "close", "eni", "first", "end", "now", "offset", "link", "forward", "last", "seq", "pos", "prefix", "prev", "priority", "max", "start"], "avail": ["abil", "averil", "ovari", "oval", "aval", "abail", "abari", "abal", "avil", "averail", "averal", "ovil", "averari", "avari", "ovail"], "len": ["en", "slice", "val", "l", "low", "weight", "loc", "ind", "mem", "fin", "li", "data", "min", "length", "n", "count", "line", "offset", "iter", "seq", "pos", "el", "tail", "ln"], "index": ["Index", "path", "action", "slice", "id", "ini", "i", "val", "shift", "current", "weight", "new", "x", "si", "update", "position", "append", "loc", "error", "key", "value", "alpha", "open", "ind", "version", "online", "match", "page", "length", "count", "skip", "address", "inc", "block", "end", "offset", "loop", "iter", "forward", "initial", "xxxx", "pos", "num", "start"], "mcast_idx": ["mcast_pidx", "mcast_idz", "mcast_pidxs", "mcast_ridv", "mcast_idele", "mcast_Idn", "mcast_ridz", "mcast_ridxs", "mcast_midxs", "mcast_idy", "mcast_ridn", "mcast_midx", "mcast__ridxe", "mcast_argle", "mcast_idxe", "mcast_idsct", "mcast_ridct", "mcast_argb", "mcast_idv", "mcast_nameb", "mcast_ideb", "mcast__idx", "mcast__ridz", "mcast_ridy", "mcast__idz", "mcast_idec", "mcast_ridxe", "mcast2idx", "mcast_idct", "mcast2ideb", "mcast_sidz", "mcast_idex", "mcast2idex", "mcast_idsz", "mcast_idsxe", "mcast__idxe", "mcast_idle", "mcast_midct", "mcast_Idv", "mcast_pidy", "mcast2idele", "mcast_ridx", "mcast_sidn", "mcast_idsx", "mcast_namele", "mcast_namex", "mcast_namec", "mcast__ridct", "mcast_idn", "mcast_idc", "mcast_sidx", "mcast2idc", "mcast_idb", "mcast_Idz", "mcast_midy", "mcast2idec", "mcast_argx", "mcast__idct", "mcast_idxs", "mcast_argc", "mcast2idle", "mcast_sidv", "mcast_pidct", "mcast__ridx", "mcast2idb", "mcast_Idx"], "buf1": ["buff1", "uf2", "buffone", "buf2", "buffer2", "uf0", "buf0", "buff0", "buff2", "queueone", "uf1", "queue0", "ufone", "buffer1", "bufone", "buffer0", "bufferone", "queue1", "queue2"], "broadcast_macaddr": ["broadcast_acptr", "broadcast2acaddr", "broadcast_Macaddr", "broadcast_compaddr", "broadcast2macptr", "broadcast_macdr", "broadcast_micaddress", "broadcast_macptr", "broadcast_micaddr", "broadcast_macaddress", "broadcast2acaddress", "broadcast_Macptr", "broadcast2macaddr", "broadcast_compr", "broadcast_compaddress", "broadcast_acdr", "broadcast_micr", "broadcast_macr", "broadcast_micptr", "broadcast2acptr", "broadcast2macaddress", "broadcast_compptr", "broadcast_acaddr", "broadcast_Macr", "broadcast_micdr", "broadcast_acaddress", "broadcast_Macaddress", "broadcast2acdr", "broadcast2macdr", "broadcast_Macdr"]}}
{"project": "FFmpeg", "commit_id": "f264d336fe61c12ce9607c3060aa5d3dca947c61", "target": 1, "func": "static void truespeech_apply_twopoint_filter(TSContext *dec, int quart)\n\n{\n\n    int16_t tmp[146 + 60], *ptr0, *ptr1;\n\n    const int16_t *filter;\n\n    int i, t, off;\n\n\n\n    t = dec->offset2[quart];\n\n    if(t == 127){\n\n        memset(dec->newvec, 0, 60 * sizeof(*dec->newvec));\n\n        return;\n\n    }\n\n    for(i = 0; i < 146; i++)\n\n        tmp[i] = dec->filtbuf[i];\n\n    off = (t / 25) + dec->offset1[quart >> 1] + 18;\n\n\n    ptr0 = tmp + 145 - off;\n\n    ptr1 = tmp + 146;\n\n    filter = (const int16_t*)ts_order2_coeffs + (t % 25) * 2;\n\n    for(i = 0; i < 60; i++){\n\n        t = (ptr0[0] * filter[0] + ptr0[1] * filter[1] + 0x2000) >> 14;\n\n        ptr0++;\n\n        dec->newvec[i] = t;\n\n        ptr1[i] = t;\n\n    }\n\n}", "idx": 14024, "substitutes": {"quart": ["pet", " quint", "piece", "ft", "part", "amp", "qa", "art", "pt", "quant", "letter", "period", "bass", "gap", "question", "cit", "jet", "sq", "fat", "ct", "quick", "qu", "quad", "ant", "cot", "temp", "boot", "pot", "mint", "component", "qt", "pound", " Quart", "iot", "cat", "quarter", "nt", "minute", "tube", "cup", "rot", "upt"], "tmp": ["bt", "MP", "proc", "appy", "amp", "vv", "mp", "code", "seed", "fb", "bb", "sup", "front", "tt", "fake", "buffer", "cmp", "txt", "kk", "dest", "fp", "buff", "output", "meta", "np", "obj", "params", "p", "temp", "rb", "img", "boot", "pb", "buf", "data", "pointer", "base", "sb", "page", "wb", "arr", "dc", "tw", "tf", "cb", "offset", "nt", "now", "cp", "db", "cache", "src", "pad", "tp"], "ptr0": ["p2", "p0", "pointer1", "Ptr0", "pointer2", "pointer19", "pt2", "Ptr8", "ptr6", "pt6", "Ptr6", "ptr2", "ptr8", "Ptr2", "tip0", "pointer8", "p1", "tr2", "pointer00", "pt1", "tip2", "tip1", "ptr00", "Ptr00", "pt8", "ptr19", "pointer6", "pt19", "tr0", "pointer0", "Ptr1", "tr00", "tip19", "tr1", "pt0"], "ptr1": ["dr2", "offsetone", "pointer1", "Ptr0", "pointer2", "pointersone", "pointerone", "ptr2", "ptrone", "Ptr2", "tr2", "Ptrone", "offset1", "dr0", "tr0", "trone", "pointers1", "pointer0", "pointers2", "offset0", "Ptr1", "pointers0", "tr1", "dr1", "offset2"], "filter": ["alt", "call", "sort", "ft", "format", "part", "amp", "fl", "config", "shift", "search", "g", "flat", "test", "ref", "Filter", "buffer", "fat", "fp", "force", "v", "limit", "w", "term", "stop", "p", "version", "select", "match", "page", "ext", "count", "f", "mask", "th", "control", "fil", "cover", "url", "number", "block", "il", "ac", "tf", "offset", "type", "attribute", "transform", "q", "ilt", "tail", "support", "opt"], "i": ["qi", "it", "ui", "m", "I", "d", "ni", "ai", "xi", "id", "iu", "l", "gi", "ini", "oi", "io", "mu", "ci", "g", "x", "di", "si", "ie", "ii", "v", "uri", "o", "w", "u", "ind", "z", "p", "e", "s", "info", "fi", "mini", "mi", "li", "k", "b", "ix", "slice", "j", "multi", "n", "f", "phi", "ti", "at", "ip", "c", "eni", "pi", "q", "y", "in", "index", "start"], "t": ["T", "it", "m", "part", "d", "art", "l", "pt", "a", "ta", "g", "test", "tt", "wt", "st", "x", "to", "ct", "v", "tm", "o", "w", "ut", "u", "z", "ant", "p", "e", "temp", "bot", "b", "qt", "j", "n", "f", "tip", "at", "ti", "token", "c", "dt", "type", "offset", "tf", "nt", "tz", "unt", "tool", "ts", "ot", "tp", "y"], "off": ["alt", "oat", "ff", "non", "after", "amp", "on", "art", "shift", "orig", "pt", "front", "foo", "Off", "new", "ref", "OFF", "set", "o", "w", "dev", "own", "af", "ext", "j", "old", "length", "flow", "at", "ip", "diff", "block", "end", "offs", "down", "type", "offset", "now", "out", "load", "pos", "no", "order", "len", "opt", "start"]}}
{"project": "qemu", "commit_id": "ad2d30f79d3b0812f02c741be2189796b788d6d7", "target": 1, "func": "static void scsi_disk_purge_requests(SCSIDiskState *s)\n\n{\n\n    SCSIDiskReq *r;\n\n\n\n    while (!QTAILQ_EMPTY(&s->qdev.requests)) {\n\n        r = DO_UPCAST(SCSIDiskReq, req, QTAILQ_FIRST(&s->qdev.requests));\n\n        if (r->req.aiocb) {\n\n            bdrv_aio_cancel(r->req.aiocb);\n\n        }\n\n        scsi_remove_request(r);\n\n    }\n\n}\n", "idx": 14025, "substitutes": {"s": ["sys", "m", "ses", "self", "d", "t", "sync", "sg", "service", "fs", "rs", "sym", "a", "cs", "S", "h", "si", "es", "js", "sq", "session", "v", "ps", "ss", "conf", "w", "p", "e", "se", "sf", "sb", "b", "j", "n", "f", "gs", "state", "spec", "c", "ns", "ssl", "states", "ds", "services", "su", "ts", "y", "aws"], "r": ["rr", "ru", "R", "rd", "hr", "gr", "rc", "d", "tr", "l", "rs", "kr", "g", "er", "req", "rg", "sr", "str", "br", "rh", "fr", "cr", "request", "mr", "p", "e", "ir", "rb", "lr", "rx", "b", "j", "requ", "f", "result", "c", "arr", "ur", "q", "re", "rt", "pr", "nr", "ar", "dr", "res", "rf", "usr", "err"]}}
{"project": "qemu", "commit_id": "d861b05ea30e6ac177de9b679da96194ebe21afc", "target": 1, "func": "static int net_slirp_init(VLANState *vlan)\n\n{\n\n    if (!slirp_inited) {\n\n        slirp_inited = 1;\n\n        slirp_init();\n\n    }\n\n    slirp_vc = qemu_new_vlan_client(vlan, \n\n                                    slirp_receive, NULL);\n\n    snprintf(slirp_vc->info_str, sizeof(slirp_vc->info_str), \"user redirector\");\n\n    return 0;\n\n}\n", "idx": 14031, "substitutes": {"vlan": [" vara", "virtualara", "lla", " vnic", "qla", "llan", "jnic", "Vlas", "virtualnic", "vda", "jla", " vlas", "lda", "Vnic", "jlan", "vara", "virtuallas", "virtuallan", "qlan", "vnic", "qda", "lnic", "qnic", "vlas", "Vlan", "jda", "Vara", "vla"]}}
{"project": "FFmpeg", "commit_id": "0ecca7a49f8e254c12a3a1de048d738bfbb614c6", "target": 1, "func": "static int pnm_decode_header(AVCodecContext *avctx, PNMContext * const s){\n\n    char buf1[32], tuple_type[32];\n\n    int h, w, depth, maxval;;\n\n\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    if (!strcmp(buf1, \"P4\")) {\n\n        avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n    } else if (!strcmp(buf1, \"P5\")) {\n\n        if (avctx->codec_id == CODEC_ID_PGMYUV) \n\n            avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        else\n\n            avctx->pix_fmt = PIX_FMT_GRAY8;\n\n    } else if (!strcmp(buf1, \"P6\")) {\n\n        avctx->pix_fmt = PIX_FMT_RGB24;\n\n    } else if (!strcmp(buf1, \"P7\")) {\n\n        w = -1;\n\n        h = -1;\n\n        maxval = -1;\n\n        depth = -1;\n\n        tuple_type[0] = '\\0';\n\n        for(;;) {\n\n            pnm_get(s, buf1, sizeof(buf1));\n\n            if (!strcmp(buf1, \"WIDTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                w = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"HEIGHT\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                h = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"DEPTH\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                depth = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"MAXVAL\")) {\n\n                pnm_get(s, buf1, sizeof(buf1));\n\n                maxval = strtol(buf1, NULL, 10);\n\n            } else if (!strcmp(buf1, \"TUPLETYPE\")) {\n\n                pnm_get(s, tuple_type, sizeof(tuple_type));\n\n            } else if (!strcmp(buf1, \"ENDHDR\")) {\n\n                break;\n\n            } else {\n\n                return -1;\n\n            }\n\n        }\n\n        /* check that all tags are present */\n\n        if (w <= 0 || h <= 0 || maxval <= 0 || depth <= 0 || tuple_type[0] == '\\0')\n\n            return -1;\n\n        avctx->width = w;\n\n        avctx->height = h;\n\n        if (depth == 1) {\n\n            if (maxval == 1)\n\n                avctx->pix_fmt = PIX_FMT_MONOWHITE;\n\n            else \n\n                avctx->pix_fmt = PIX_FMT_GRAY8;\n\n        } else if (depth == 3) {\n\n            avctx->pix_fmt = PIX_FMT_RGB24;\n\n        } else if (depth == 4) {\n\n            avctx->pix_fmt = PIX_FMT_RGBA32;\n\n        } else {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    } else {\n\n        return -1;\n\n    }\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->width = atoi(buf1);\n\n    if (avctx->width <= 0)\n\n        return -1;\n\n    pnm_get(s, buf1, sizeof(buf1));\n\n    avctx->height = atoi(buf1);\n\n    if (avctx->height <= 0)\n\n        return -1;\n\n    if (avctx->pix_fmt != PIX_FMT_MONOWHITE) {\n\n        pnm_get(s, buf1, sizeof(buf1));\n\n    }\n\n\n\n    /* more check if YUV420 */\n\n    if (avctx->pix_fmt == PIX_FMT_YUV420P) {\n\n        if ((avctx->width & 1) != 0)\n\n            return -1;\n\n        h = (avctx->height * 2);\n\n        if ((h % 3) != 0)\n\n            return -1;\n\n        h /= 3;\n\n        avctx->height = h;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14056, "substitutes": {"avctx": ["afcca", "aucdn", "Avconf", "afconn", "navcca", "Avcontext", "afpkg", "aucontext", "AVcmp", "afconf", "Avctx", "avcmp", "avlc", "cvctx", " avpkg", "navcu", "auconn", "afcdn", "cvcmp", "aflc", "AVcontext", "vercontext", "afxc", "avalconf", "navctx", "afcu", "afcmp", " avxc", "AVlc", "avalcontext", "avalctrl", "avcdn", "verconn", "afcontext", " avcmp", "AVxc", "vercdn", "auctx", "avalctx", "appcca", "avcu", "appctx", " avcontext", "avcontext", "verctx", "avconn", "avxc", "avconf", "afctx", "Avctrl", "navconn", " avconn", "cvlc", "navcontext", "cvcontext", "AVctx", "appcu", "avpkg", "appcontext", "afctrl", "avctrl", "navpkg", "avcca"], "s": ["args", "path", "south", "sys", "ses", "m", "bis", "self", "d", "service", "t", "sg", "sync", "fs", "native", "i", "sym", "rs", "a", "current", "sup", "g", "cs", "details", "settings", "cms", "comments", "sets", "js", "es", "scope", "sq", "session", "server", "secure", "conf", "ss", "o", "params", "p", "e", "info", "ions", "site", "http", "sf", "sb", "b", "scl", "n", "f", "gs", "gb", "spec", "stat", "ns", "c", "serv", "is", "stats", "sc", "ssl", "ops", "r", "ds", "services", "support", "in"], "buf1": ["bufOnce", "uber1", "bu0", "buff01", "buffer2", "cmdone", "buf51", "buffs", "uf31", " bufone", "buf9", "buf100", "ufnum", "buffn", "uf01", "bu1", "Buff1", "uf64", "vecpre", "buff2", "bu51", "buL", "rafOne", "cfone", "bu91", "vec61", "uber9", "buf61", "buf91", "buff51", " bufnum", "buffL", "Buff0", "bufone", "bg1", "buffer81", "bg2", "cf2", "buf64", "cmd0", "uf0", "nob2", "nob1", "bufnum", "cv2", " buf0", "bus", "bufs", "vec1", "buffpre", "vecone", "ufback", "cfOne", "bag81", "cvback", "vec100", "cmd1", "cv1", " buffer1", "bufferull", "cmdpre", "buffOne", "rub2", "ufOne", "bufferone", "cvone", "ufs", "bu2", "nob31", "bc2", " bufOne", "bufull", "vecn", "bagone", "uf91", "cmd64", "buff1", "bag2", "buf01", "rub1", "cmd2", "cmdONE", "buffone", "ufn", "bufn", "buf0", "uf61", "raf2", " buf81", "cvn", "buf81", "buff64", "vec2", "bufpre", "ufpre", " buffer2", "bag1", "raf1", "bufOne", "vec0", "buffer1", "bgone", "bu9", "rub100", "cf1", "ufL", "bufback", "uf100", "buffONE", " bufOnce", "uf51", "uf2", "bu31", "buf2", "buff61", "bcONE", " buf2", "bufL", "buff0", "uf9", "buff91", "uber91", "uber0", "uf1", "ufONE", "bgull", "vecback", "ufOnce", "ufone", "raf0", "vec01", "bufONE", " buffernum", "ufull", "BuffOne", "bc1", "buf31", "BuffOnce"], "tuple_type": ["tuple_key", "tuple_t", "tple_type", "tune_size", "tple_key", "c", "end", "text", "tple_block", "tple_unit", "tple_t", "d", "g", "tune_length", "r", "tune2type", "tuple2size", "format", "tune_type", "tune2size", "tune2length", "tuple2length", "tuple_size", "_", "tuple_unit", "tuple_length", "tuple_block", "all", "tuple2type"], "h": ["hi", "m", "en", " H", "hl", "d", "t", "ih", "hr", "l", "i", "g", "hs", "x", "gh", "v", "rh", "o", "hh", "u", "z", "p", "b", "count", "n", "f", "length", "th", "padding", "bh", "c", "ph", "ht", "q", "sl", "H", "sh", "hw", "y", "height"], "w": ["m", "wh", "d", "t", "l", "row", "g", "weight", "wx", "sw", "wt", "x", "how", "v", " W", "kw", "win", "u", "z", "wave", "p", "n", "f", "c", "W", "wd", "ow", "wa", "q", "r", "sh", "we", "work", "window", "wl", "y", "max", "height", "fw"], "depth": ["path", "m", "deep", "root", "dq", "d", "dist", "fl", "id", "level", "style", "weight", "progress", "x", "lang", "rh", "der", "layer", "z", "dev", "p", "time", "count", "length", "n", "phi", "parent", "padding", "th", "Depth", "reverse", "sn", "q", "scale", "debug", "sl", "r", "cache", "pr", "stack", "dr", "quality", "color", "push", "order", "dim", "len", "y", "max", "height"], "maxval": ["maxvalue", "MaxVal", " maxVal", " maxVAL", "axvals", "MAXVAL", "maxVal", "minval", "maxvals", "axval", "minVal", "minvalue", "MaxVAL", "Maxvalue", " maxvals", "maxVAL", "MAXVal", "Maxval", "MAXval", "Maxvals", " maxvalue", "MAXvals", "minvals", "axvalue", "axVal"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void cpu_physical_memory_rw(target_phys_addr_t addr, uint8_t *buf,\n\n                            int len, int is_write)\n\n{\n\n    return address_space_rw(&address_space_memory, addr, buf, len, is_write);\n\n}\n", "idx": 14076, "substitutes": {"addr": ["func", "device", "port", "Address", "proc", "pkg", "inter", "config", "align", "ref", "ace", " address", "loc", "conn", "ad", "p", "ctx", "pointer", "data", "kt", "base", "address", "ip", "eni", "alloc", "offset", "target", "attr", "eth", "cb", "host", "mac", "src", "nr", "ar", "pos", "pad", "ptr", "node"], "buf": ["queue", "fd", "cv", "batch", "fb", "bd", "uf", "bytes", "pool", "ref", "buffer", "fp", "loc", "buff", "mem", "ctx", "fi", "pb", "data", "b", "base", "byte", "length", "bh", "ab", "cb", "cap", "cmd", "src", "seq", "lb", "ptr", "lim", "alloc"], "len": ["alt", "en", "bin", "part", "lin", "fl", "enc", "Len", "val", "l", "lon", "lan", " length", "ref", "lang", "lit", "loc", "limit", "size", "la", "mem", "li", "data", "base", "length", "count", "lf", "ann", "line", "offset", "cap", "seq", "pos", "el", "bl", "ln", "lim"], "is_write": [" is_writer", "is_written", "is_read", " is_read", "is_writer", " is_written"]}}
{"project": "qemu", "commit_id": "ddca7f86ac022289840e0200fd4050b2b58e9176", "target": 0, "func": "static void v9fs_link(void *opaque)\n\n{\n\n    V9fsPDU *pdu = opaque;\n\n    V9fsState *s = pdu->s;\n\n    int32_t dfid, oldfid;\n\n    V9fsFidState *dfidp, *oldfidp;\n\n    V9fsString name;\n\n    size_t offset = 7;\n\n    int err = 0;\n\n\n\n    pdu_unmarshal(pdu, offset, \"dds\", &dfid, &oldfid, &name);\n\n    trace_v9fs_link(pdu->tag, pdu->id, dfid, oldfid, name.data);\n\n\n\n    dfidp = get_fid(pdu, dfid);\n\n    if (dfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out_nofid;\n\n    }\n\n\n\n    oldfidp = get_fid(pdu, oldfid);\n\n    if (oldfidp == NULL) {\n\n        err = -ENOENT;\n\n        goto out;\n\n    }\n\n    err = v9fs_co_link(pdu, oldfidp, dfidp, &name);\n\n    if (!err) {\n\n        err = offset;\n\n    }\n\nout:\n\n    put_fid(pdu, dfidp);\n\nout_nofid:\n\n    v9fs_string_free(&name);\n\n    complete_pdu(s, pdu, err);\n\n}\n", "idx": 14090, "substitutes": {"opaque": ["opsaqu", "operaqu", "opsacity", "oaques", "opsaques", "oaque", "opac", "operacity", "opaques", "opsaque", "operaque", "OPaques", "copaques", "apaqu", "apacity", "opacity", "apaque", "apaques", "OPac", "OPque", "copac", "copaque", "opque", "OPaque", "opaqu", "operaques", "oac", "oque", "copque"], "pdu": ["ccu", "vpuu", "pde", "bdu", "opuu", "psu", "Pcu", "opcu", " puu", "percu", "fdu", "cdu", "ppdu", "pcu", " pru", "opdu", "cpde", "lpdu", " pcu", "cpdf", " pud", "pssu", "vptu", "cpci", "Pdf", " pci", "cpcu", " ptu", "pptu", "optu", "hcu", "fuu", "pud", "ppsu", "fsu", "htu", "opda", "btu", "vpud", "vpdu", "puu", "pci", "hdu", "pda", "cptu", "Ptu", "lpdf", "cuts", "fud", "opsu", "pscu", "cpuu", " pda", "fcu", "perci", "persu", "perru", "pru", "huu", "Pud", "csu", "buu", "opci", "cpdu", "Pdu", "lpcu", "ptu", "Pde", "bcu", " psu", "ppuu", "ppru", "psdu", "ftu", "fda", "ppud", "pdf", "Pci", "lpde", "perdu", "peruu", "psuts"], "s": ["secondary", "south", "sys", "m", "ses", "location", "d", "t", "sync", "private", "sym", "g", "S", "settings", "h", "os", "description", "status", "sets", "si", "scope", "session", "server", "slave", "storage", "ss", "conf", "o", "w", "u", "p", "e", "instance", "http", "b", "sb", "n", "f", "gs", "state", "spec", "c", "ns", "setup", "stats", "ssl", "side", "states", "services", "ops", "r", "save", "ts"], "dfid": [" dfkid", "dfkid", "dfID", "ufaid", "tfid", "sfids", "dfmid", "ufiden", "tfend", "xfkid", " dfident", "dfids", " dfID", "DFID", "DFiden", "dfident", "ufID", "DFid", "lfide", "dfiden", "fdident", "lfid", " dfide", "lfID", " dfmid", "fdkid", "fpid", "xfmid", "tfide", "tfID", "dfaid", "lfend", "fpID", "DFids", "dfide", "dfend", " dfend", "fpaid", " dfq", "fdid", "ufid", "ufids", "dfq", " dfaid", "sfiden", "xfident", "fdmid", "ufq", "fpq", "sfID", "xfid", "sfid"], "oldfid": ["longfip", "oldcid", "newcids", "oldfacid", "oldfaid", " oldfip", "oldfsId", "olddfkid", "oldFids", "oldfacrid", "olderdfit", "newfid", "oldFit", "olderfit", "oldcit", "oldfsip", "olddfaid", "longfid", " oldlids", "newfids", "oldfids", "oldcfaid", "oldcids", "oldfit", "oldtfId", "oldfsaid", "newfrid", "oldfip", "longtfid", "longfId", "oldfId", "olddfid", "oldFaid", "oldlids", "oldtfip", " oldlip", "olddfId", "olddfids", "olderdfids", " oldlaid", "oldckid", "oldfacids", "olddfrid", "newckid", "newcid", "newfkid", "olderfid", "longtfaid", " oldlid", "oldfrid", "oldtfaid", "olderfaid", "oldlaid", "oldfackid", "oldcip", "olddfip", "oldfkid", "olderdfaid", "oldfsid", "oldFid", "oldcaid", "longfaid", "oldlid", "oldtfid", "olderdfid", "olddfit", "longtfId", "longtfip", "oldcfid", "newcrid", "oldcfids", " oldfaid", "olderfids", "oldcfip", "oldlip", " oldfids", "oldcrid"], "dfidp": ["dfIdpc", "dfodp", "dfstrc", "dfidpoint", "fdidpc", "dfmidP", "dfkeypc", "dfidi", "dfIdp", "dfIdpr", " dfidpoint", "fdidp", "dfidP", "dfmidc", "dfdm", "fIdP", "dfmidpc", "dfIDP", "dfIdr", "dfkeyp", "fdmidp", "dfidm", "dfiddpc", "dfIdpi", "dfitm", "dfmidp", "dfidpr", "dfidentp", "fidp", "dfidper", "fdidP", "fdmidP", "dfidlp", "dfidr", "dfIdP", "dfdpoint", "dfmidpr", "dfodpc", "dfidentpc", "dfitc", "fdidpr", "dfidpi", "dfbitp", "dfitpoint", "cmdidpc", "dfodpr", "dfmidpi", "dfdp", "dfstrpi", "dfIDr", "fdmidpr", "fdmidc", "dfstrpr", "cmdiddlp", "cmdidper", "fidP", " dfbitm", "fdmidpi", "dfbitc", "fidr", " dfidm", " dfbitc", "dfIdc", "dfitp", "dfodP", "cmdiddper", "fidi", "cmdiddp", "dfidentlp", "dfidpc", "fIdi", "dfbitm", "fdidpi", "dfdc", "fIdp", "dfkeylp", " dfbitp", "fdmidpc", "dfiddp", "dfIDp", "dfidc", "dfiddlp", "dfstrp", "dfIDi", "dfIdi", " dfbitpoint", "cmdidlp", "dfbitpoint", "dfidentper", "dfiddper", "fIdr", "cmdiddpc", "fdidc", "cmdidp", "dfkeyper", " dfidc"], "oldfidp": ["oldfarkl", "oldfaidl", "oldfoidpe", "oldfidpe", "oldfidpi", "oldfadi", "oldfoidc", "oldfiddc", "oldfidsg", "oldfidl", "oldfidspe", "oldfIdu", "oldtfidv", "oldfadp", "oldfiddv", "oldfbitv", "oldfidsr", "oldtfiddv", "oldfsidp", "oldtfidp", "oldfidm", "oldfiddpe", "oldfarku", "oldfsidsr", "oldfsidsl", "oldfarkpi", "oldfidsp", "oldfidg", "oldfidsb", "oldfiddi", "oldfoidp", "oldfidc", "oldfidb", "oldfsidsp", "oldfaidr", "oldtfiddi", "oldfadv", "oldfaidp", "oldfarkp", "oldfsidsg", "oldfidr", "oldfiddl", "oldfIdp", "oldfitedu", "oldfbitm", "oldtfiddm", "oldfIdl", "oldfidu", "oldfitedpi", "oldfiddr", "oldtfidi", "oldfidsc", "oldfidsl", "oldfsidg", "oldfiddb", "oldfitedl", "oldfiddg", "oldfaidg", "oldfIdpi", "oldfidi", "oldfoidb", "oldtfidm", "oldfitedp", "oldfiddp", "oldfiddm", "oldfsidr", "oldfidv", "oldfbiti", "oldfsidl", "oldfbitp", "oldfadm", "oldtfiddp"], "name": ["word", "path", "call", "self", "part", "nam", "id", "object", "memory", "child", "label", "def", "connection", "new", "x", "str", "buffer", "missing", "comment", "key", "error", "member", "Name", "NAME", "w", "obj", "names", "size", "mem", "ame", "time", "named", "resource", "desc", "info", "version", "data", "ext", "base", "n", "f", "none", "parent", "block", "type", "anc", " Name", "attr", "out", " prefix", "no", "filename", "alias", "prefix", "in"]}}
{"project": "FFmpeg", "commit_id": "70143a3954e1c4412efb2bf1a3a818adea2d3abf", "target": 0, "func": "int dxva2_init(AVCodecContext *s)\n\n{\n\n    InputStream *ist = s->opaque;\n\n    int loglevel = (ist->hwaccel_id == HWACCEL_AUTO) ? AV_LOG_VERBOSE : AV_LOG_ERROR;\n\n    DXVA2Context *ctx;\n\n    int ret;\n\n\n\n    if (!ist->hwaccel_ctx) {\n\n        ret = dxva2_alloc(s);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n    ctx = ist->hwaccel_ctx;\n\n\n\n    if (s->codec_id == AV_CODEC_ID_H264 &&\n\n        (s->profile & ~FF_PROFILE_H264_CONSTRAINED) > FF_PROFILE_H264_HIGH) {\n\n        av_log(NULL, loglevel, \"Unsupported H.264 profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (s->codec_id == AV_CODEC_ID_HEVC &&\n\n        s->profile != FF_PROFILE_HEVC_MAIN && s->profile != FF_PROFILE_HEVC_MAIN_10) {\n\n        av_log(NULL, loglevel, \"Unsupported HEVC profile for DXVA2 HWAccel: %d\\n\", s->profile);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    av_buffer_unref(&ctx->hw_frames_ctx);\n\n\n\n    ret = dxva2_create_decoder(s);\n\n    if (ret < 0) {\n\n        av_log(NULL, loglevel, \"Error creating the DXVA2 decoder\\n\");\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14108, "substitutes": {"s": ["i", "qs", "si", "js", "params", "spec", "c", "is", "sc", "sv", "sl", "aws", "args", "self", "bis", "d", "t", "sg", "sync", "ins", "fs", "sym", "g", "cs", "es", "session", "storage", "w", "an", "sf", "b", "ns", "r", "sa", "sis", "support", "ks", "sys", "service", "your", "os", "sets", "ms", "e", "site", "http", "sb", "features", "f", "less", "des", "services", "ls", "comments", "ess", "ses", "as", "l", "a", "S", "settings", "this", "its", "sq", "conf", "ss", "p", "se", "ions", "plugins", "gs", "xs", "sci", "ssl", "ds", "su", "css", "ts", "us"], "ist": ["ess", "ais", "ists", "osi", "isu", "ista", "dist", "art", "ift", "pt", "asi", "tt", "st", "ati", "xt", "asp", "ace", "pect", "ld", "ict", "iste", "isc", "irst", "ird", "alist", "feat", "ant", "ind", "ad", "kt", "IST", "sd", "dit", "est", "inst", "ont", "att", "isi", "ht", "nt", "ast", "ism", "sa", "dr", "wd", "iss", "et", "irc", "ost"], "ctx": ["acs", "context", "tx", "cm", "bc", "mc", "pkg", "ca", "sync", "cv", "rc", "cc", "pc", "config", "ctr", "lc", "ci", "cs", "ctrl", "cn", "wcs", "cy", "cmp", "sq", "loc", "ct", "conn", "kw", "obj", "fi", "ck", "c", "cu", "anc", "cb", "cas", "sci", "cmd", "cf", "cp", "exec", "vc", "xc", "ec", "css", "hw"], "ret": ["pet", "reply", "art", "val", "def", "gt", "str", "obj", "active", "mem", "fin", "rb", "fab", "base", "bf", "att", "cat", "fail", "RET", "ft", "rev", "rc", "id", "rets", "req", "sr", "det", "arg", "error", "lib", "pass", "data", "ext", "result", "url", "repl", "res", "reg", "rf", "flag", "run", "alt", "let", "disabled", "fun", "ref", "pret", "lit", "info", "desc", "Ret", "f", "nt", "re", "rt", "rep", "no", "usr", "bit", "err", "code", "back", "py", "feat", "success", "resp", "pat", "len"]}}
{"project": "qemu", "commit_id": "d4cd45028898a37afb45fb449954115b4960d4e9", "target": 0, "func": "static XenPTBarFlag xen_pt_bar_reg_parse(XenPCIPassthroughState *s,\n\n                                         XenPTRegInfo *reg)\n\n{\n\n    PCIDevice *d = &s->dev;\n\n    XenPTRegion *region = NULL;\n\n    PCIIORegion *r;\n\n    int index = 0;\n\n\n\n    /* check 64bit BAR */\n\n    index = xen_pt_bar_offset_to_index(reg->offset);\n\n    if ((0 < index) && (index < PCI_ROM_SLOT)) {\n\n        int type = s->real_device.io_regions[index - 1].type;\n\n\n\n        if ((type & XEN_HOST_PCI_REGION_TYPE_MEM)\n\n            && (type & XEN_HOST_PCI_REGION_TYPE_MEM_64)) {\n\n            region = &s->bases[index - 1];\n\n            if (region->bar_flag != XEN_PT_BAR_FLAG_UPPER) {\n\n                return XEN_PT_BAR_FLAG_UPPER;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* check unused BAR */\n\n    r = &d->io_regions[index];\n\n    if (!xen_pt_get_bar_size(r)) {\n\n        return XEN_PT_BAR_FLAG_UNUSED;\n\n    }\n\n\n\n    /* for ExpROM BAR */\n\n    if (index == PCI_ROM_SLOT) {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n\n\n    /* check BAR I/O indicator */\n\n    if (s->real_device.io_regions[index].type & XEN_HOST_PCI_REGION_TYPE_IO) {\n\n        return XEN_PT_BAR_FLAG_IO;\n\n    } else {\n\n        return XEN_PT_BAR_FLAG_MEM;\n\n    }\n\n}\n", "idx": 14126, "substitutes": {"s": ["device", "args", "south", "sys", "ses", "m", "self", "t", "sync", "service", "fs", "sed", "rs", "a", "g", "cs", "S", "settings", "os", "this", "status", "devices", "es", "js", "si", "sq", "session", "server", "v", "ss", "sim", "o", "w", "dev", "p", "se", "data", "sd", "sb", "sf", "b", "n", "f", "stat", "gs", "state", "spec", "c", "ns", "sc", "ssl", "side", "sv", "sl", "states", "ds", "services", "sa", "su", "ts", "ks"], "reg": ["record", "arm", "rc", "config", "ram", "gr", "ray", "rad", "rg", "eg", "ref", "acc", "arg", "mod", "loc", "conn", "scan", "rec", "mem", "sec", "eng", "stat", "Reg", "ann", "spec", "ab", "arr", "ro", "re", "cmd", "REG", "param", "db", "tag", "res", "arb", "rem", "red"], "d": ["D", "dh", "device", "m", "t", "dist", "da", "def", "di", "dir", "gd", "de", "w", "cd", "dy", "grad", "ad", "ind", "dev", "p", "sd", "driver", "f", "dat", "c", "dt", "dc", "md", "ds", "dd", "db", "dn", "dr", "dim", "dm"], "region": ["area", "record", "remote", "location", "vision", "Region", "slice", "array", "dist", "rc", "config", "native", "texture", "memory", "account", "range", "connection", "g", "gap", "section", "rg", "description", "option", "module", "progress", "scope", "loc", "role", "zone", "p", "instance", "resource", "dimension", "component", "radius", "feature", "state", "parser", "route", "ion", "re", "REG", "tag", "dim", "contract", "division", "country"], "r": ["rr", "m", "ru", "rus", "R", "rd", "rc", "rs", "range", "g", "er", "rn", "h", "rg", "sr", "str", "v", "br", "rh", "fr", "cr", "o", "role", "adr", "u", "rec", "p", "e", "lr", "rb", "resource", "b", "j", "radius", "n", "rw", "result", "pair", "rl", "c", "attr", "re", "rt", "ri", "pr", "nr", "ar", "dr", "res", "arb", "rf", "err"]}}
{"project": "FFmpeg", "commit_id": "50c466d609ec60a324a7a776dfdb57c8d38faa11", "target": 1, "func": "static av_cold int g726_encode_init(AVCodecContext *avctx)\n\n{\n\n    G726Context* c = avctx->priv_data;\n\n\n\n    if (avctx->strict_std_compliance > FF_COMPLIANCE_UNOFFICIAL &&\n\n        avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Sample rates other than 8kHz are not \"\n\n               \"allowed when the compliance level is higher than unofficial. \"\n\n               \"Resample or reduce the compliance level.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if (avctx->sample_rate <= 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Samplerate is invalid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(avctx->channels != 1){\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono is supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (avctx->bit_rate % avctx->sample_rate) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Bitrate - Samplerate combination is invalid\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    c->code_size = (avctx->bit_rate + avctx->sample_rate/2) / avctx->sample_rate;\n\n    if (c->code_size < 2 || c->code_size > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid number of bits %d\\n\", c->code_size);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    avctx->bits_per_coded_sample = c->code_size;\n\n\n\n    g726_reset(c, c->code_size - 2);\n\n\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame)\n\n        return AVERROR(ENOMEM);\n\n    avctx->coded_frame->key_frame = 1;\n\n\n\n    /* select a frame size that will end on a byte boundary and have a size of\n\n       approximately 1024 bytes */\n\n    avctx->frame_size = ((int[]){ 4096, 2736, 2048, 1640 })[c->code_size - 2];\n\n\n\n    return 0;\n\n}\n", "idx": 14141, "substitutes": {"avctx": ["ajloc", " avscope", "avctr", "avlc", "avsci", "aflc", "aklc", "afconfig", "vercf", "avcu", " avcontext", "avecmp", "avecoll", "avecli", "avecontext", "avconfig", "avcp", "afconn", "vercit", "aupkg", "aucontext", "ajcontext", "vercp", "afcf", "afcit", " avconfig", "AVcontext", "avectx", "afctr", "verloc", "avcli", "afcu", "AVcoll", "AVconn", "AVlc", "averctx", "afcontext", "avcoll", "ajcit", "akctx", "avconn", "avloc", "avectrl", "ajcmp", " avcu", "avctrl", "akcontext", "afsci", "avscope", "avecm", " avctr", "ajcli", "avcm", " avpkg", "avcf", "ajsci", "avecu", "vercontext", "auctr", " avcm", "averconn", "avecit", "akcf", "vercli", "ajctx", "aveconfig", "aveloc", " avcli", "afloc", "verctx", "avecf", "afctx", "ajcf", "afcoll", "afcli", "avcca", "afcca", "afpkg", "ajcp", " avsci", "AVcmp", "averctrl", "avcmp", "avescope", "avercca", "avcit", "avelc", "AVcu", "afcmp", "afcp", "verconn", "auctx", "afcm", "avcontext", "avercit", "aveconn", "afscope", " avconn", "AVctx", "avpkg", "afctrl", "verlc", "vercca", "avercontext"], "c": ["context", "ch", "mc", "cm", "m", "uc", "d", "ca", "enc", "t", "unc", "config", "cc", "l", "code", "i", "pc", "C", "a", "gc", "g", "cs", "ctrl", "lc", "ci", "h", "cy", "cmp", "con", "ct", "v", "conn", "cr", "w", "col", "u", "oc", "p", "e", "s", "sec", "nc", "k", "b", "co", "tc", "n", "f", "arc", "cu", "dc", "ac", "anc", "sc", "ce", "cf", "ic", "coll", "cp", "exec", "vc", "xc", "cache", "ec", "cur", "fc", "cl", "ctx"]}}
{"project": "FFmpeg", "commit_id": "8332321c5737cf24ebad504bf10a03818424718d", "target": 1, "func": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n", "idx": 14144, "substitutes": {"s": ["sys", "ses", "context", "self", "d", "sync", "service", "sg", "fs", "rs", "cs", "qs", "S", "settings", "os", "sr", "sets", "si", "es", "sq", "server", "storage", "ss", "ps", "u", "p", "e", "sec", "se", "sf", "sb", "b", "n", "f", "gs", "spec", "ns", "xs", "sc", "ssl", "sv", "services", "ds", "sa", "su", "src", "ls", "ts", "us", "ks"], "stream_index": ["stream_ind", "stream_alias", "streamnameconnection", "Stream_index", "streamnameindex", "Stream_connection", "streamnameind", "Stream_alias", "stream_connection", "streamnamealias", "Stream_ind"], "timestamp": ["Timetime", "parameline", "timeline", "paramestamp", "timetz", "timetime", "nameline", "timed", "typed", "Timency", "nametz", "longed", "typetime", "longetime", "parametz", "namency", "Timestamp", "typestamp", "longestamp", "Timetz", "Timeline", "Timed", "timency", "namestamp", "paramency"], "flags": ["args", "FLAG", "fd", "fs", "fields", "forces", "fps", "settings", "bytes", "linux", "files", "reads", "options", "faces", "seconds", "data", "sf", "features", "mask", "lag", "frames", "lf", "bits", "Flags", "offs", "stats", "ops", "orts", "errors", "fee", "ints", "ips", "properties", "ts", "windows", "flag", "vals"], "r": ["rr", "m", "rss", "as", "ru", "rus", "R", "d", "t", "rc", "rs", "or", "kr", "ra", "g", "er", "rar", "rg", "sr", "fr", "rh", "cr", "w", "u", "mr", "rec", "p", "e", "ir", "rb", "b", "re", "rt", "ar", "dr", "res", "rf", "err"], "c": ["m", "self", "mc", "cm", "bc", "uc", "d", "ca", "t", "enc", "rc", "unc", "pc", "config", "cc", "l", "i", "C", "lc", "ci", "cs", "cy", "ct", "v", "cr", "o", "u", "p", "e", "nc", "k", "tc", "b", "n", "f", "cu", "dc", "ac", "sc", "ce", "cf", "vc", "xc", "ec", "cur", "ctx"]}}
{"project": "qemu", "commit_id": "788d2599def0e26d92802593b07ec76e8701ccce", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162, "substitutes": {"plug_handler": ["plugingcontroller", " plug_handle", "plugalconfig", " plug_config", "plug_info", "plugin_handle", "plugalhandle", "pluginghand", "plugin_handler", "plugfhandler", " plug_info", "plug_handle", "plugalhandler", "pluginghandle", "plug_config", "plugalinfo", "plugin_hand", "plugin_controller", "plugfinfo", "plug_controller", "pluginghandler", "plug_hand", "plugfhandle", "plugfconfig"], "plugged_dev": ["plugled_di", "plugged__dev", "plugging__dev", "plugging__def", "plugged_Dev", "plugged__device", "plugded_tag", "plugging_ev", "plugded_priv", "plugged__def", "plugded_Dev", "pluggedPdevice", "plugged_di", "plugger_device", "plugger_di", "plugded_dev", "plugging__ev", "plugged__di", "plugged_device", "plugger_dev", "plugled_device", "plugging_dev", "plugging_def", "plugled_ev", "pluggedPdi", "pluggedPdev", "pluggedPev", "plugged__ev", "plugged_ev", "plugled_dev", "plugged_def", "plugged_priv", "plugged_tag"], "errp": ["riskr", " errr", "strP", " errpe", "erpre", "erpe", "errr", "rrpre", " errpre", "errpe", "rrp", "errP", " errP", "strr", "erp", "riskpe", "rrP", " errl", "strl", "errpre", "errl", "riskp", "erl", "strp", "erP", "rrr", "err"], "phb": ["hyc", "phba", "phw", "Phbs", "Phd", "hp", "thp", "chb", "PHb", "ophd", "hylb", "chbs", "PHa", "hyp", " phbs", "chB", "thb", "hB", "PHba", "phbs", " phba", "hb", " phd", " phB", "phlb", "thw", "Phb", "hbs", "opha", "phc", "thbb", "PHsb", "Phsb", "phd", "pha", "herp", " php", "Phba", "ophbs", "ophb", " phw", "Pha", "phsb", "hyb", " phbb", "herc", " phc", "phB", "herb", "herlb", "phbb", "chp", "Php", "Phbb", " phlb", " phsb", "Phw", " pha", "php"], "pdev": ["tdev", "tprof", "tname", "Pdev", "spprof", "Pdevice", "ddev", " pdevice", " pname", "pdiv", "fdev", "Pdiv", "pname", "fname", " pdiv", " pdc", " pprof", "fdiv", "pod", "ddevice", "fdevice", "tdevice", "pprof", "dod", "spdiv", "tdiv", "tdc", "pdevice", "Pod", "spdev", "ddiv", " pod", "pdc", "spdc"], "drc": ["tsc", "cdsrc", "ndci", "fsrc", "cdci", " drec", "brc", "frec", "bRC", "ddrc", " dsc", "bsrc", " dsrc", "ddisc", "drec", "fsc", "ndru", "ndsrc", "dsrc", "dru", "ddrec", "ndrc", " dRC", "mdsrc", "dRC", "mdrec", "mdisc", "cdru", "cdrc", "dsc", "mdrc", "tRC", "frc", "trc", " dci", "dci", "ddsrc", " disc", "disc", "trec", "fRC", " dru"], "local_err": ["local_error", "local_er", " local_order", "localxfinder", "local_finder", "Local_rage", "local_rage", " local_error", "local_order", " local_er", "Local_orr", "Local_rr", "localxerr", "Local_err", "local_orr", "local_rr", " local_finder", "localxerror"]}}
{"project": "FFmpeg", "commit_id": "70d54392f5015b9c6594fcae558f59f952501e3b", "target": 0, "func": "av_cold int ff_dvvideo_init(AVCodecContext *avctx)\n\n{\n\n    DVVideoContext *s = avctx->priv_data;\n\n    DSPContext dsp;\n\n    static int done = 0;\n\n    int i, j;\n\n\n\n    if (!done) {\n\n        VLC dv_vlc;\n\n        uint16_t new_dv_vlc_bits[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_len[NB_DV_VLC*2];\n\n        uint8_t  new_dv_vlc_run[NB_DV_VLC*2];\n\n        int16_t  new_dv_vlc_level[NB_DV_VLC*2];\n\n\n\n        done = 1;\n\n\n\n        /* it's faster to include sign bit in a generic VLC parsing scheme */\n\n        for (i = 0, j = 0; i < NB_DV_VLC; i++, j++) {\n\n            new_dv_vlc_bits[j]  = dv_vlc_bits[i];\n\n            new_dv_vlc_len[j]   = dv_vlc_len[i];\n\n            new_dv_vlc_run[j]   = dv_vlc_run[i];\n\n            new_dv_vlc_level[j] = dv_vlc_level[i];\n\n\n\n            if (dv_vlc_level[i]) {\n\n                new_dv_vlc_bits[j] <<= 1;\n\n                new_dv_vlc_len[j]++;\n\n\n\n                j++;\n\n                new_dv_vlc_bits[j]  = (dv_vlc_bits[i] << 1) | 1;\n\n                new_dv_vlc_len[j]   =  dv_vlc_len[i] + 1;\n\n                new_dv_vlc_run[j]   =  dv_vlc_run[i];\n\n                new_dv_vlc_level[j] = -dv_vlc_level[i];\n\n            }\n\n        }\n\n\n\n        /* NOTE: as a trick, we use the fact the no codes are unused\n\n           to accelerate the parsing of partial codes */\n\n        init_vlc(&dv_vlc, TEX_VLC_BITS, j,\n\n                 new_dv_vlc_len, 1, 1, new_dv_vlc_bits, 2, 2, 0);\n\n        assert(dv_vlc.table_size == 1184);\n\n\n\n        for (i = 0; i < dv_vlc.table_size; i++){\n\n            int code = dv_vlc.table[i][0];\n\n            int len  = dv_vlc.table[i][1];\n\n            int level, run;\n\n\n\n            if (len < 0){ //more bits needed\n\n                run   = 0;\n\n                level = code;\n\n            } else {\n\n                run   = new_dv_vlc_run  [code] + 1;\n\n                level = new_dv_vlc_level[code];\n\n            }\n\n            ff_dv_rl_vlc[i].len   = len;\n\n            ff_dv_rl_vlc[i].level = level;\n\n            ff_dv_rl_vlc[i].run   = run;\n\n        }\n\n        ff_free_vlc(&dv_vlc);\n\n    }\n\n\n\n    /* Generic DSP setup */\n\n    ff_dsputil_init(&dsp, avctx);\n\n    ff_set_cmp(&dsp, dsp.ildct_cmp, avctx->ildct_cmp);\n\n    s->get_pixels = dsp.get_pixels;\n\n    s->ildct_cmp = dsp.ildct_cmp[5];\n\n\n\n    /* 88DCT setup */\n\n    s->fdct[0]     = dsp.fdct;\n\n    s->idct_put[0] = dsp.idct_put;\n\n    for (i = 0; i < 64; i++)\n\n       s->dv_zigzag[0][i] = dsp.idct_permutation[ff_zigzag_direct[i]];\n\n\n\n    /* 248DCT setup */\n\n    s->fdct[1]     = dsp.fdct248;\n\n    s->idct_put[1] = ff_simple_idct248_put;  // FIXME: need to add it to DSP\n\n    memcpy(s->dv_zigzag[1], ff_zigzag248_direct, 64);\n\n\n\n    avctx->coded_frame = &s->picture;\n\n    s->avctx = avctx;\n\n    avctx->chroma_sample_location = AVCHROMA_LOC_TOPLEFT;\n\n\n\n    return 0;\n\n}\n", "idx": 14168, "substitutes": {"avctx": ["Avcontext", "AVcmp", "avca", "Avctx", "avcmp", "avalconnection", "AVcontext", "Avcmp", "AVca", "avconnection", "Avca", "avalcontext", "avalca", " avca", " avcmp", "AVconnection", "avalctx", " avcontext", " avconnection", "avcontext", "AVctx"], "s": ["args", "m", "ses", "d", "service", "t", "sync", "a", "g", "cs", "S", "js", "sq", "session", "v", "o", "w", "p", "e", "sec", "b", "n", "f", "c", "sc", "ssl", "services", "space"], "dsp": [" dspe", " cdpp", "udspe", " dtp", " cdspe", "vdspe", "udpp", "udsp", "vdtp", " cdsp", " dpp", " cdtp", "vdsp", "udtp", "vdpp"], "i": ["qi", "it", "ui", "I", "d", "ni", "ai", "xi", "jp", "iu", "l", "id", "ini", "oi", "io", "gi", "current", "api", "ci", "ki", "x", "di", "si", "ie", "ii", "v", "vi", "uri", "yi", "u", "z", "ind", "p", "e", "fi", "info", "mi", "li", "k", "b", "ix", "cli", "n", "f", "phi", "ti", "ip", "c", "eni", "jl", "ji", "pi", "chi", "r", "bi", "ri", "ik", "ei", "ori", "zi", "y", "ij"], "j": ["jj", "adj", "qi", "uj", "jen", "it", "m", "ui", "aj", "kj", "d", "ni", "ja", "jp", "l", "io", "jon", "g", "dj", "x", "jet", "js", "ie", "ii", "bj", "v", "job", "fr", "br", "o", "obj", "z", "u", "jit", "p", "e", "ind", "size", "info", "k", "li", "b", "n", "f", "jo", "jl", "end", "jc", "je", "ji", "q", "bi", "J", "pos", "el", "y", "ij", "index"], "dv_vlc": ["dv_svt", "dv_wlci", "dv_svci", "dv_tllc", "dv_vlci", "dv_llc", "dv_dlci", "dv_llci", "dv_wlc", "dv_dlk", "dv_vlt", "dv_wlk", "dv_llcs", "dv_elcs", "dv_wlb", "dv_dlc", "dv_wlt", "dv_llk", "dv_elb", "dv_vlk", "dv_tlc", "dv_vllc", "dv_tlcs", "dv_svcs", "dv_wllc", "dv_tlb", "dv_llt", "dv_svc", "dv_ellc", "dv_dlcs", "dv_vlb", "dv_elc", "dv_vlcs", "dv_wlcs"], "new_dv_vlc_bits": ["new_dv_vlc_vals", "new_dv_vllc_bytes", "new_dv_vlc4bits", "new_dv_vlc__runs", "new_dv_vllc_bit", "new_dv_vlci_runs", "new_dv_vlci_bit", "new_dv_vlc4bit", "new_dv_vlc64bytes", "new_dv_vlc4level", "new_dv_vllc_vals", "new_dv_vlc4len", "new_dv_vlc64bits", "new_dv_vlc__bit", "new_dv_vlci_len", "new_dv_vlc_bit", "new_dv_vlc64bit", "new_dv_vlc64vals", "new_dv_vlci_bytes", "new_dv_vlc__bytes", "new_dv_vlc_runs", "new_dv_vlc_bytes", "new_dv_vlci_level", "new_dv_vlci_bits", "new_dv_vlc__bits", "new_dv_vllc_bits"], "new_dv_vlc_len": ["new_dv_vlci_length", "new_dv_vlcs_len", "new_dv_vlci_line", "new_dv_vlci_pos", "new_dv_vlc__len", "new_dv_vlc_la", "new_dv_vlc__length", "new_dv_vlci_log", "new_dv_vlc__run", "new_dv_vlc__log", "new_dv_vlcs_la", "new_dv_vlc_pos", "new_dv_vlcs_line", "new_dv_vlc__pos", "new_dv_vlc_length", "new_dv_vlcs_pos", "new_dv_vlcs_log", "new_dv_vlci_len", "new_dv_vlci_run", "new_dv_vlc_layer", "new_dv_vlcs_run", "new_dv_vlc_log", "new_dv_vlc_line", "new_dv_vlc__line", "new_dv_vlci_layer"], "new_dv_vlc_run": ["new_dv_vlcs_len", "new_dv_vlci_runs", "new_dv_vlci_use", "new_dv_vlc_reg", "new_dv_vlc_use", "new_dv_vlci_len", "new_dv_vlcs_reg", "new_dv_vlci_run", "new_dv_vlcs_run", "new_dv_vlci_name", "new_dv_vlc_runs", "new_dv_vlcs_runs", "new_dv_vlc_name"], "new_dv_vlc_level": ["new_dv_vlcs_len", "new_dv_vlci_line", "new_dv_vlc__len", "new_dv_vlc___log", "new_dv_vlcs_lock", "new_dv_vlc__run", "new_dv_vlc__log", "new_dv_vlc_vel", "new_dv_vlcs_vel", "new_dv_vlc___vel", "new_dv_vlcs_log", "new_dv_vlcs_level", "new_dv_vlci_len", "new_dv_vlc__level", "new_dv_vlc__vel", "new_dv_vlc___run", "new_dv_vlci_run", "new_dv_vlc_lock", "new_dv_vlcs_run", "new_dv_vlcs__vel", "new_dv_vlc_log", "new_dv_vlcs__run", "new_dv_vlcs__log", "new_dv_vlci_level", "new_dv_vlc_line", "new_dv_vlc__line", "new_dv_vlcs__level", "new_dv_vlc___level"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int libquvi_read_header(AVFormatContext *s)\n\n{\n\n    int i, ret;\n\n    quvi_t q;\n\n    quvi_media_t m;\n\n    QUVIcode rc;\n\n    LibQuviContext *qc = s->priv_data;\n\n    char *media_url, *pagetitle;\n\n\n\n    rc = quvi_init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n", "idx": 14199, "substitutes": {"s": ["args", "sys", "ses", "parts", "self", "d", "t", "service", "sg", "sync", "your", "l", "sym", "rs", "a", "g", "cs", "qs", "S", "settings", "os", "h", "sr", "js", "si", "es", "sq", "scope", "session", "server", "v", "conf", "ss", "storage", "o", "w", "u", "params", "p", "e", "sec", "b", "sb", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "sn", "sc", "ssl", "sl", "ops", "r", "services", "ds", "sa", "su", "ls", "ts", "comments", "ctx", "in", "ks"], "i": ["hi", "qi", "it", "ui", "adi", "I", "d", "ai", "ni", "xi", "id", "ini", "iu", "gi", "l", "a", "io", "oi", "mu", "ci", "ki", "x", "di", "ie", "si", "ii", "v", "uri", "gu", "yi", "u", "jit", "p", "ib", "info", "fi", "mi", "k", "li", "b", "ix", "multi", "j", "count", "n", "f", "phi", "ti", "ip", "c", "eni", "end", "is", "ji", "pi", "r", "bi", "ri", "ik", "zi", "y", "index", "start"], "ret": ["alt", "RC", "ft", "let", "rev", "ru", "reply", "val", "code", "back", "rs", "def", "rets", "fun", "status", "ref", "arg", "det", "lit", "feat", "ut", "fin", "rx", "match", "success", "ext", "Ret", "result", "ann", "att", "rl", "arr", "ry", "cat", "ur", "nt", "re", "rt", "sur", "RET", "res", "reg", "cur", "usr", "flag", "len", "bit"], "q": ["qi", "self", "ch", "qa", "queue", "ca", "dq", "t", "input", "config", "d", "ue", "l", "g", "qs", "req", "question", "h", "x", "sq", "ct", "v", "quest", "o", "client", "w", "qu", "z", "u", "p", "e", "ck", "k", "qt", "play", "f", "requ", "n", "query", "c", "iq", "ac", "r", "que", "qq", "cache", "Q", "cl", "ract"], "m": ["mc", "cm", "d", "t", "pc", "l", "fm", "g", "source", "h", "x", "module", "mod", "mm", "v", "tm", "meta", "o", "w", "ms", "gm", "media", "mt", "p", "e", "u", "bm", "metadata", "mi", "k", "b", "n", "f", "mode", "hm", "ma", "c", "M", "md", "sm", "r", "param", "dm", "y", "nm", "mu"], "rc": ["ror", "RC", "rr", "uc", "hl", "bc", "ru", "rd", "cc", "pc", "rs", "roc", "ra", "lc", "ctrl", "rn", "auc", "wx", "rg", "ref", "lang", " r", "loc", "error", "ras", "rh", "feat", "rec", "ok", "rb", "rx", "ck", "rin", "co", "success", "Ret", " RC", "result", "ann", "arc", "rl", "inc", "c", "ry", "dc", "ac", "anc", "cb", "ro", "nt", "sc", "ur", "rt", "ack", "r", "sur", "src", "ec", "irm", "dr", "reg", "cur", "usr", "fc", "irc", "err"], "qc": [" qsc", "sqmc", "sqd", "qud", "qup", "sqr", "qxc", "reqc", " qf", "quc", "Qci", " qxc", "qucs", "qf", "ckc", " qpc", "ipd", "sqpc", "caldc", "ckpc", "sqp", "sqsc", "qupc", "calf", "qdc", " qd", " qmc", "reqcu", "quv", "qcs", "quci", "qulc", " qdc", "qsc", " qlc", "qv", "iplc", "sqcs", "sqv", " qcu", "qmc", "Qdc", "qd", "calc", "quxc", "qudc", "qcu", "Qxc", "sqdc", " qci", "calp", "Qc", "ipc", " qv", "ckcs", "reqp", " qp", "qpc", "reqr", "qur", "qci", "qumc", "qp", " qcs", "ckcu", "qlc", "sqlc", "sqc", "qucu", "sqf", "qr", "sqcu", "qusc", " qr", "ippc"], "media_url": ["image_URL", "mediaadurl", "mediaadURL", "image_url", "image_name", "image_path", "mediaadaddress", "media_address", "media_string", "image_address", "mediaadname", "media_URL", "image_string", "media_path", "media_uri", "image_uri", "media_name"], "pagetitle": ["pagedetyail", "pagedetitles", "pagettail", "pagestotal", "pagetyle", "pagatotal", "paguEType", "pagentrue", "pagestitle", "pagETyle", "pagedetotal", "pagettime", "pagatrue", "pagetime", "pagedetyitle", "pagEType", "pagetyime", "pagedentrue", "pagentitles", "pagedetitle", "paguetitles", "pagedentitle", "pagetype", "pagotyle", "pagETitles", "pagedetail", "pagentail", "pagetyail", "pagetyitle", "pagedetyitles", "pagestrue", "pagentitle", "pagedetyime", "pagentyle", "pagetail", "pagatail", "pagETail", "pagedetime", "pagentotal", "pagatitle", "paguETitles", "pagentype", "pagotitles", "pagetrue", "pagotitle", "pagedetrue", "paguETitle", "pagetitles", "pagETitle", "paguetyle", "pagedentail", "pagETime", "pagettitle", "paguETyle", "pagetotal", "pagotype", "pagedentotal", "pagestail", "paguetype", "pagetyitles", "paguetitle", "pagettitles"], "st": ["ess", "sta", "d", "t", "tmp", "dist", "stream", "pt", "spect", "td", "sp", "ust", "ste", "std", "sth", "sw", "str", "nd", "fr", "obj", "bl", "stop", "p", "se", "ST", "stage", "kt", "sd", "sb", "St", "est", "inst", "store", "sty", "sn", "sc", "sl", "ast", "stress", "ds", "sh", "sa", "rest", "src", "dr", "et", "sts", "ost", "start"], "ist": ["ess", "it", "ists", "ft", "sta", "part", "ista", "edit", "dist", "art", "id", "ia", "pt", "ift", "aint", "asi", "std", "lp", "xt", "pop", "nd", "ld", "pect", "ict", "iste", "irst", "feat", "alist", "gd", "ad", "ind", "IST", "sd", "est", "inst", "isd", "isi", "is", "ast", "ism", "ic", "dd", "rest", "dr", "wd", "iss", "et", "tta", "ost"]}}
{"project": "qemu", "commit_id": "6750e795b167e3defab36502e61b8c57ede119eb", "target": 0, "func": "static int add_old_style_options(const char *fmt, QemuOpts *opts,\n\n                                 const char *base_filename,\n\n                                 const char *base_fmt)\n\n{\n\n    if (base_filename) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename)) {\n\n            error_report(\"Backing file not supported for file format '%s'\",\n\n                         fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    if (base_fmt) {\n\n        if (qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt)) {\n\n            error_report(\"Backing file format not supported for file \"\n\n                         \"format '%s'\", fmt);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 14220, "substitutes": {"fmt": ["sfmt", "bwt", "fwt", "tflt", "Fformat", "tfm", "sftt", " fm", "FMT", "sfformat", "tfformat", "fnt", "fm", "Ftt", " fformat", "fformat", " fnt", "Fmt", "tfwt", "tfmt", "flt", " fwt", "tftt", "ftt", "tfMT", "bmt", "bformat", " flt", "sfMT", "tfnt", "Fnt", "fMT", "Fm", "blt"], "opts": ["otps", "alt", "opcs", "optches", "iopt", "prets", "opert", "precs", "alps", "OPTS", "OPches", "optTS", "alpt", "OPpt", "preps", "iopches", "opters", "OPps", "preters", "otts", "OPt", "opTS", "oppt", "otters", "iopts", "OPts", "opches", "optt", "optts", "operpt", "opps", "optters", "iopTS", "otcs", "optps", "alts", "opt", "optcs", "operps", "operts"], "base_filename": ["baseingfilename", "build_filename", "build_layer", " base_file", " base_string", "base_language", "baseingfile", "basefullfiles", "build_language", "basefullfile", "baseingtxt", "basefullstring", "base_file", " base_txt", "base_layer", "baseinglanguage", " base_family", "build_file", "base_string", "baseingfamily", "baseinglayer", "base_family", "basefullfilename", "base_files", " base_files", "base_txt"], "base_fmt": ["base_tflass", "base_blt", "base2fatter", "base_tflt", "base_formmt", "base__btml", "base__fmt", "base2formmt", "base_flt", "base_flass", "base_filemt", "base_tfwd", "base__fwd", "base_frameworkmt", "base_tfmt", "base_frmt", "base_batter", "base2fformat", "base2formformat", "base2flt", "base_fmmt", "base_formatter", "base_fmlt", "base_btml", "base_frformat", "base_filelass", "base2fmt", "base_formformat", "base_bformat", "base_frlass", "base_frlt", "base2formatter", "base_formlt", "base_fformat", "base_fwd", "base_tfformat", "base_fmatter", "base_frameworkwd", "base__bmt", "base2formlt", "base_frameworkformat", "base_frameworktml", "base__bformat", "base_fatter", "base_filelt", "base_ftml", "base_tftml", "base__ftml", "base_bwd", "base_bmt", "base_fileformat", "base__fformat", "base_fmformat", "base__bwd"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void qemu_flush_queued_packets(VLANClientState *vc)\n\n{\n\n    while (!TAILQ_EMPTY(&vc->vlan->send_queue)) {\n\n        VLANPacket *packet;\n\n        int ret;\n\n\n\n        packet = TAILQ_FIRST(&vc->vlan->send_queue);\n\n        TAILQ_REMOVE(&vc->vlan->send_queue, packet, entry);\n\n\n\n        ret = qemu_deliver_packet(packet->sender, packet->data, packet->size);\n\n        if (ret == 0 && packet->sent_cb != NULL) {\n\n            TAILQ_INSERT_HEAD(&vc->vlan->send_queue, packet, entry);\n\n            break;\n\n        }\n\n\n\n        if (packet->sent_cb)\n\n            packet->sent_cb(packet->sender, ret);\n\n\n\n        qemu_free(packet);\n\n    }\n\n}\n", "idx": 14228, "substitutes": {"vc": ["asu", "acs", "sys", "bc", "service", "cv", "input", "vv", "cc", "iw", "config", "cdn", "VC", "gc", "api", "lc", "cs", "ci", "req", "qs", "ctrl", "this", "vm", "cy", "sq", "ct", "server", "v", "conn", "client", "ant", "ll", "vine", "ku", "nc", "cli", "data", "entry", "qt", "c", "dc", "cu", "ac", "lv", "cb", "q", "cf", "ic", "rt", "nec", "xc", "db", "vd", "vt", "wl", "wd", "fc", "ctx"], "packet": ["packel", "packec", "plugET", " packett", "plugacket", "octetting", "packageon", "packette", "packageett", "packET", "packsen", "packat", " packetting", "octacket", "plugat", "compen", "packetter", "compett", "pacacket", "compet", "PackET", "hooketer", "formel", "packageect", "packset", "compacket", "Packeto", "pacen", " packon", "Packel", "packsetter", "octet", "packett", "hooken", "paceter", "packon", "packeter", " packetter", "compon", "packageec", " packinet", " packacket", " packET", "Packect", "hooket", " packkt", "ppet", "compel", "plugset", "packsinet", "Packette", "packen", "packageel", " packec", "plugen", "packsacket", "packseter", "ppeto", "hookacket", "ppET", "compec", "pluget", "packageetting", "compkt", "packseto", "packageET", " packeter", "formet", "packagekt", "packinet", "packageeto", "pacset", "packacket", "packetting", "packeto", "formET", "packkt", "compat", "pacet", "packageacket", " packeto", "compET", "Packet", "packageette", "Packat", "packect", " packette", "formeto", "Packacket", "ppel", "compset", "competting", "packageeter", "packageet", "octetter", " packel", "packageetter", "Packinet", " packect"], "ret": [" fun", "alt", "pet", "ft", "rev", "reply", "_", "art", "rc", "id", "val", " resp", "pt", "rets", "fun", "req", "sr", "ref", "det", "lit", "ct", "job", "mt", "rb", "ver", "fin", "success", "match", "data", "Ret", "bf", "f", "result", " RET", "att", "ry", "cat", "cb", "nt", "re", "rt", "resp", "repl", "db", "pat", "RET", "seq", "res", "no", "reg", "num", "flag", "rf", "len"]}}
{"project": "FFmpeg", "commit_id": "c0bc8b9afb7e4f39d84080870b9feedcd23ab5c9", "target": 1, "func": "LF_FUNC (h,  luma,         sse2)\n\nLF_IFUNC(h,  luma_intra,   sse2)\n\nLF_FUNC (v,  luma,         sse2)\n\nLF_IFUNC(v,  luma_intra,   sse2)\n\n\n\n/***********************************/\n\n/* weighted prediction */\n\n\n\n#define H264_WEIGHT(W, H, OPT) \\\n\nvoid ff_h264_weight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    int stride, int log2_denom, int weight, int offset);\n\n\n\n#define H264_BIWEIGHT(W, H, OPT) \\\n\nvoid ff_h264_biweight_ ## W ## x ## H ## _ ## OPT(uint8_t *dst, \\\n\n    uint8_t *src, int stride, int log2_denom, int weightd, \\\n\n    int weights, int offset);\n\n\n\n#define H264_BIWEIGHT_MMX(W,H) \\\n\nH264_WEIGHT  (W, H, mmx2) \\\n\nH264_BIWEIGHT(W, H, mmx2)\n\n\n\n#define H264_BIWEIGHT_MMX_SSE(W,H) \\\n\nH264_BIWEIGHT_MMX(W, H) \\\n\nH264_WEIGHT      (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, sse2) \\\n\nH264_BIWEIGHT    (W, H, ssse3)\n\n\n\nH264_BIWEIGHT_MMX_SSE(16, 16)\n\nH264_BIWEIGHT_MMX_SSE(16,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8, 16)\n\nH264_BIWEIGHT_MMX_SSE( 8,  8)\n\nH264_BIWEIGHT_MMX_SSE( 8,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  8)\n\nH264_BIWEIGHT_MMX    ( 4,  4)\n\nH264_BIWEIGHT_MMX    ( 4,  2)\n\n\n\nvoid ff_h264dsp_init_x86(H264DSPContext *c)\n\n{\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n        c->h264_loop_filter_strength= h264_loop_filter_strength_mmx2;\n\n    }\n\n#if HAVE_YASM\n\n    if (mm_flags & AV_CPU_FLAG_MMX) {\n\n        c->h264_idct_dc_add=\n\n        c->h264_idct_add= ff_h264_idct_add_mmx;\n\n        c->h264_idct8_dc_add=\n\n        c->h264_idct8_add= ff_h264_idct8_add_mmx;\n\n\n\n        c->h264_idct_add16     = ff_h264_idct_add16_mmx;\n\n        c->h264_idct8_add4     = ff_h264_idct8_add4_mmx;\n\n        c->h264_idct_add8      = ff_h264_idct_add8_mmx;\n\n        c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx;\n\n\n\n        if (mm_flags & AV_CPU_FLAG_MMX2) {\n\n            c->h264_idct_dc_add= ff_h264_idct_dc_add_mmx2;\n\n            c->h264_idct8_dc_add= ff_h264_idct8_dc_add_mmx2;\n\n            c->h264_idct_add16     = ff_h264_idct_add16_mmx2;\n\n            c->h264_idct8_add4     = ff_h264_idct8_add4_mmx2;\n\n            c->h264_idct_add8      = ff_h264_idct_add8_mmx2;\n\n            c->h264_idct_add16intra= ff_h264_idct_add16intra_mmx2;\n\n\n\n            c->h264_v_loop_filter_chroma= ff_x264_deblock_v_chroma_mmxext;\n\n            c->h264_h_loop_filter_chroma= ff_x264_deblock_h_chroma_mmxext;\n\n            c->h264_v_loop_filter_chroma_intra= ff_x264_deblock_v_chroma_intra_mmxext;\n\n            c->h264_h_loop_filter_chroma_intra= ff_x264_deblock_h_chroma_intra_mmxext;\n\n#if ARCH_X86_32\n\n            c->h264_v_loop_filter_luma= ff_x264_deblock_v_luma_mmxext;\n\n            c->h264_h_loop_filter_luma= ff_x264_deblock_h_luma_mmxext;\n\n            c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_mmxext;\n\n            c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_mmxext;\n\n\n            c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_mmx2;\n\n            c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_mmx2;\n\n            c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_mmx2;\n\n            c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_mmx2;\n\n            c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_mmx2;\n\n            c->weight_h264_pixels_tab[5]= ff_h264_weight_4x8_mmx2;\n\n            c->weight_h264_pixels_tab[6]= ff_h264_weight_4x4_mmx2;\n\n            c->weight_h264_pixels_tab[7]= ff_h264_weight_4x2_mmx2;\n\n\n\n            c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_mmx2;\n\n            c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_mmx2;\n\n            c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_mmx2;\n\n            c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_mmx2;\n\n            c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_mmx2;\n\n            c->biweight_h264_pixels_tab[5]= ff_h264_biweight_4x8_mmx2;\n\n            c->biweight_h264_pixels_tab[6]= ff_h264_biweight_4x4_mmx2;\n\n            c->biweight_h264_pixels_tab[7]= ff_h264_biweight_4x2_mmx2;\n\n\n\n            if (mm_flags&AV_CPU_FLAG_SSE2) {\n\n                c->h264_idct8_add = ff_h264_idct8_add_sse2;\n\n                c->h264_idct8_add4= ff_h264_idct8_add4_sse2;\n\n\n\n                c->weight_h264_pixels_tab[0]= ff_h264_weight_16x16_sse2;\n\n                c->weight_h264_pixels_tab[1]= ff_h264_weight_16x8_sse2;\n\n                c->weight_h264_pixels_tab[2]= ff_h264_weight_8x16_sse2;\n\n                c->weight_h264_pixels_tab[3]= ff_h264_weight_8x8_sse2;\n\n                c->weight_h264_pixels_tab[4]= ff_h264_weight_8x4_sse2;\n\n\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_sse2;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_sse2;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_sse2;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_sse2;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_sse2;\n\n\n\n\n                c->h264_v_loop_filter_luma = ff_x264_deblock_v_luma_sse2;\n\n                c->h264_h_loop_filter_luma = ff_x264_deblock_h_luma_sse2;\n\n                c->h264_v_loop_filter_luma_intra = ff_x264_deblock_v_luma_intra_sse2;\n\n                c->h264_h_loop_filter_luma_intra = ff_x264_deblock_h_luma_intra_sse2;\n\n\n\n\n                c->h264_idct_add16 = ff_h264_idct_add16_sse2;\n\n                c->h264_idct_add8  = ff_h264_idct_add8_sse2;\n\n                c->h264_idct_add16intra = ff_h264_idct_add16intra_sse2;\n\n            }\n\n            if (mm_flags&AV_CPU_FLAG_SSSE3) {\n\n                c->biweight_h264_pixels_tab[0]= ff_h264_biweight_16x16_ssse3;\n\n                c->biweight_h264_pixels_tab[1]= ff_h264_biweight_16x8_ssse3;\n\n                c->biweight_h264_pixels_tab[2]= ff_h264_biweight_8x16_ssse3;\n\n                c->biweight_h264_pixels_tab[3]= ff_h264_biweight_8x8_ssse3;\n\n                c->biweight_h264_pixels_tab[4]= ff_h264_biweight_8x4_ssse3;\n\n            }\n\n        }\n\n    }\n\n\n}", "idx": 14248, "substitutes": {"c": ["m", "ch", "mc", "cm", "bc", "ca", "cv", "cc", "l", "config", "C", "gc", "g", "lc", "cs", "v", "p", "e", "b", "f", "dc", "ac", "icc", "vc", "xc", "cache", "ec", "fc"]}}
{"project": "FFmpeg", "commit_id": "6202e2fede75df92cbc374a3f7d6893d0c5ac721", "target": 0, "func": "static int decode_band_hdr(IVI45DecContext *ctx, IVIBandDesc *band,\n\n                           AVCodecContext *avctx)\n\n{\n\n    int plane, band_num, indx, transform_id, scan_indx;\n\n    int i;\n\n\n\n    plane    = get_bits(&ctx->gb, 2);\n\n    band_num = get_bits(&ctx->gb, 4);\n\n    if (band->plane != plane || band->band_num != band_num) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid band header sequence!\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    band->is_empty = get_bits1(&ctx->gb);\n\n    if (!band->is_empty) {\n\n        int old_blk_size = band->blk_size;\n\n        /* skip header size\n\n         * If header size is not given, header size is 4 bytes. */\n\n        if (get_bits1(&ctx->gb))\n\n            skip_bits(&ctx->gb, 16);\n\n\n\n        band->is_halfpel = get_bits(&ctx->gb, 2);\n\n        if (band->is_halfpel >= 2) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid/unsupported mv resolution: %d!\\n\",\n\n                   band->is_halfpel);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n#if IVI4_STREAM_ANALYSER\n\n        if (!band->is_halfpel)\n\n            ctx->uses_fullpel = 1;\n\n#endif\n\n\n\n        band->checksum_present = get_bits1(&ctx->gb);\n\n        if (band->checksum_present)\n\n            band->checksum = get_bits(&ctx->gb, 16);\n\n\n\n        indx = get_bits(&ctx->gb, 2);\n\n        if (indx == 3) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid block size!\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        band->mb_size  = 16 >> indx;\n\n        band->blk_size = 8 >> (indx >> 1);\n\n\n\n        band->inherit_mv     = get_bits1(&ctx->gb);\n\n        band->inherit_qdelta = get_bits1(&ctx->gb);\n\n\n\n        band->glob_quant = get_bits(&ctx->gb, 5);\n\n\n\n        if (!get_bits1(&ctx->gb) || ctx->frame_type == IVI4_FRAMETYPE_INTRA) {\n\n            transform_id = get_bits(&ctx->gb, 5);\n\n            if (transform_id >= FF_ARRAY_ELEMS(transforms) ||\n\n                !transforms[transform_id].inv_trans) {\n\n                avpriv_request_sample(avctx, \"Transform %d\", transform_id);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((transform_id >= 7 && transform_id <= 9) ||\n\n                 transform_id == 17) {\n\n                avpriv_request_sample(avctx, \"DCT transform\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n#if IVI4_STREAM_ANALYSER\n\n            if ((transform_id >= 0 && transform_id <= 2) || transform_id == 10)\n\n                ctx->uses_haar = 1;\n\n#endif\n\n\n\n            band->inv_transform = transforms[transform_id].inv_trans;\n\n            band->dc_transform  = transforms[transform_id].dc_trans;\n\n            band->is_2d_trans   = transforms[transform_id].is_2d_trans;\n\n            if (transform_id < 10)\n\n                band->transform_size = 8;\n\n            else\n\n                band->transform_size = 4;\n\n\n\n            if (band->blk_size != band->transform_size)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            scan_indx = get_bits(&ctx->gb, 4);\n\n            if (scan_indx == 15) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Custom scan pattern encountered!\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (scan_indx > 4 && scan_indx < 10) {\n\n                if (band->blk_size != 4)\n\n                    return AVERROR_INVALIDDATA;\n\n            } else if (band->blk_size != 8)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            band->scan = scan_index_to_tab[scan_indx];\n\n\n\n            band->quant_mat = get_bits(&ctx->gb, 5);\n\n            if (band->quant_mat >= FF_ARRAY_ELEMS(quant_index_to_tab)) {\n\n\n\n                if (band->quant_mat == 31)\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"Custom quant matrix encountered!\\n\");\n\n                else\n\n                    avpriv_request_sample(avctx, \"Quantization matrix %d\",\n\n                                          band->quant_mat);\n\n                band->quant_mat = -1;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            if (old_blk_size != band->blk_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"The band block size does not match the configuration \"\n\n                       \"inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (band->quant_mat < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Invalid quant_mat inherited\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n\n\n        /* decode block huffman codebook */\n\n        if (!get_bits1(&ctx->gb))\n\n            band->blk_vlc.tab = ctx->blk_vlc.tab;\n\n        else\n\n            if (ff_ivi_dec_huff_desc(&ctx->gb, 1, IVI_BLK_HUFF,\n\n                                     &band->blk_vlc, avctx))\n\n                return AVERROR_INVALIDDATA;\n\n\n\n        /* select appropriate rvmap table for this band */\n\n        band->rvmap_sel = get_bits1(&ctx->gb) ? get_bits(&ctx->gb, 3) : 8;\n\n\n\n        /* decode rvmap probability corrections if any */\n\n        band->num_corr = 0; /* there is no corrections */\n\n        if (get_bits1(&ctx->gb)) {\n\n            band->num_corr = get_bits(&ctx->gb, 8); /* get number of correction pairs */\n\n            if (band->num_corr > 61) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Too many corrections: %d\\n\",\n\n                       band->num_corr);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* read correction pairs */\n\n            for (i = 0; i < band->num_corr * 2; i++)\n\n                band->corr[i] = get_bits(&ctx->gb, 8);\n\n        }\n\n    }\n\n\n\n    if (band->blk_size == 8) {\n\n        band->intra_base = &ivi4_quant_8x8_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_8x8_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    } else {\n\n        band->intra_base = &ivi4_quant_4x4_intra[quant_index_to_tab[band->quant_mat]][0];\n\n        band->inter_base = &ivi4_quant_4x4_inter[quant_index_to_tab[band->quant_mat]][0];\n\n    }\n\n\n\n    /* Indeo 4 doesn't use scale tables */\n\n    band->intra_scale = NULL;\n\n    band->inter_scale = NULL;\n\n\n\n    align_get_bits(&ctx->gb);\n\n\n\n    return 0;\n\n}\n", "idx": 14263, "substitutes": {"ctx": ["sys", "context", "tx", "cam", "cm", "bc", "pkg", "cv", "ca", "qa", "rc", "cc", "config", "sync", "utils", "gc", "connection", "lc", "ctrl", "cs", "ci", "na", "conv", "req", "cn", "kernel", "hub", "wcs", "act", "cmp", "bus", "Context", "scope", "loc", "conf", "conn", "client", "np", "la", "plugin", "git", "cli", "nc", "component", "cus", "gb", "library", "c", "cca", "crit", "cu", "voc", "dc", "fc", "anc", "cb", "cas", "sci", "sc", "cmd", "cf", "coll", "cp", "cpp", "kb", "vc", "xc", "ga", "mac", "qs", "support", "cci", "hw", "fw"], "band": ["word", "bridge", "device", "port", "amp", "batch", "unk", "bound", "low", "audio", "project", "model", "filter", "dB", "base", "usb", "list", "flow", "line", "broad", "book", "station", "cell", "class", "work", "tag", "off", "bart", "card", "part", "slice", "d", "ground", "bb", "bank", "product", "bus", "session", "client", "lib", "group", "Band", "b", "byte", "length", "bolt", "library", "feed", "gen", "BB", "host", "flag", "support", "header", "brand", "service", "and", "cast", "bd", "connection", "hub", "app", "output", "layer", "stage", "boot", "point", "gb", "feature", "block", "bo", "load", "field", "bit", "bug", "board", "back", "range", "bass", "kernel", "patch", "plugin", "match", "component", "but", "now", "cmd", "db", "tool"], "avctx": ["AVconv", "avchan", "afsci", "afconv", "abconn", "awchan", " avsci", "airctx", "awctx", "versci", "airloc", "avecrit", "AVloc", "vercrit", "avsci", "avcrit", "AVcontext", "awsci", "versync", "avectx", "vercontext", "airconv", "afcu", "abcrit", "aircu", "avsync", "AVsci", "verconn", "afcontext", "airsci", "avesync", "avcu", " avcontext", "afloc", "verctx", "avcontext", "aircontext", "avconn", "aveconn", "avloc", "avconv", "afctx", "AVctx", "vercu", "absync", "AVchan", "awcontext", "abctx", " avchan"], "plane": ["charge", "card", "ge", "port", "planes", "board", "nat", "slice", "qa", "fl", "cop", "flo", "fle", "source", "flat", "weight", "pose", "plan", "unit", "flight", "position", "force", "frame", "category", "clip", "group", "phase", "ane", "zone", "orient", "se", "engine", "direction", "axis", "component", "base", "mode", "mask", "fly", "flow", "route", "pe", "type", "plot", "drop", "gate", "scale", "lane", "den", "rot", "age", "sea", "space", "core", "plate"], "band_num": ["band_nor", "bug___nr", "band_sum", "band___nr", "flow_offset", "band_label", "band0nr", "flow_num", "bandaclabel", "band_nr", "band_na", "band6num", "flow_type", "band_range", "band_offset", "band1num", "bandactype", "band0size", "flowactype", "band__nr", "band__size", "band0range", "band0num", "bug___size", "Band_num", "flowacnum", "band0label", "band1nor", "Band_number", "bug___range", "bandacnum", "band0offset", "flowaclabel", "bug_nr", "band6offset", "Band_na", "bug_num", "band___range", "band_uni", "flow_label", " band_sum", "band1sum", "band_number", "band_size", "band___num", "bug_range", "band__num", "Band_uni", "bug_size", "bandacoffset", " band_nor", "bug___num", "flowacoffset", "band_type", "band6label", "band__range", "band___size", "band0type", "band6type"], "indx": ["pidx", "Index", "indj", "idxp", "incy", "idex", " idx", "INDice", "INDX", "idice", "indX", " idm", "indy", "IndX", "INDw", "incx", " indm", "idw", " indice", "Indw", " idj", "incxp", " indj", "Indx", "indw", "pidX", "Indxp", "pidj", "idX", "indice", "Indy", " indy", " idX", " indX", "INDy", "idx", "Indz", "indz", "pidm", "idy", "INDex", "idz", "indxp", "incz", "indm", "index", "INDx"], "transform_id": ["trans_ids", "transformOids", "transformblockid", "transformblockids", "transformblockrid", "transform_rid", "trans_id", "transformblockkey", "transformOkey", "transformOid", "trans_rid", "trans_key", "transform_key", "transformOrid", "transform_ids"], "scan_indx": ["scan_indb", "scan2indx", "scan2indxe", "scan_sidb", "scan_idb", "scan_ridb", "scan_sidxe", "scan2idb", "scan2indb", "scan_idx", "scan_indy", "scan2indy", "scan_ridy", "scan2idxe", "scan_sidy", "scan2idx", "scan_ridx", "scan_ridxe", "scan_idy", "scan_sidx", "scan_indxe", "scan2idy", "scan_idxe"], "i": ["qi", "ui", "slice", "I", "d", "ai", "xi", "iu", "split", "pixel", "a", "ci", "ii", "u", "p", "e", "fi", "li", "axis", "b", "j", "n", "f", "phi", "ip", "c", "pi", "bi"]}}
{"project": "qemu", "commit_id": "1a9353d258aba69afd8a389bf5fb705caab12ce0", "target": 0, "func": "long do_syscall(void *cpu_env, int num, long arg1, long arg2, long arg3, \n\n                long arg4, long arg5, long arg6)\n\n{\n\n    long ret;\n\n    struct stat st;\n\n    struct kernel_statfs *stfs;\n\n    \n\n#ifdef DEBUG\n\n    gemu_log(\"syscall %d\\n\", num);\n\n#endif\n\n    switch(num) {\n\n    case TARGET_NR_exit:\n\n#ifdef HAVE_GPROF\n\n        _mcleanup();\n\n#endif\n\n        _exit(arg1);\n\n        ret = 0; /* avoid warning */\n\n        break;\n\n    case TARGET_NR_read:\n\n        ret = get_errno(read(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_write:\n\n        ret = get_errno(write(arg1, (void *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_open:\n\n        ret = get_errno(open((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_close:\n\n        ret = get_errno(close(arg1));\n\n        break;\n\n    case TARGET_NR_brk:\n\n        ret = do_brk((char *)arg1);\n\n        break;\n\n    case TARGET_NR_fork:\n\n        ret = get_errno(fork());\n\n        break;\n\n    case TARGET_NR_waitpid:\n\n        {\n\n            int *status = (int *)arg2;\n\n            ret = get_errno(waitpid(arg1, status, arg3));\n\n            if (!is_error(ret) && status)\n\n                tswapls((long *)&status);\n\n        }\n\n        break;\n\n    case TARGET_NR_creat:\n\n        ret = get_errno(creat((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_link:\n\n        ret = get_errno(link((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_unlink:\n\n        ret = get_errno(unlink((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_execve:\n\n        ret = get_errno(execve((const char *)arg1, (void *)arg2, (void *)arg3));\n\n        break;\n\n    case TARGET_NR_chdir:\n\n        ret = get_errno(chdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_time:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            ret = get_errno(time((time_t *)time_ptr));\n\n            if (!is_error(ret) && time_ptr)\n\n                tswap32s(time_ptr);\n\n        }\n\n        break;\n\n    case TARGET_NR_mknod:\n\n        ret = get_errno(mknod((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_chmod:\n\n        ret = get_errno(chmod((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lchown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_break:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_lseek:\n\n        ret = get_errno(lseek(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpid:\n\n        ret = get_errno(getpid());\n\n        break;\n\n    case TARGET_NR_mount:\n\n        /* need to look at the data field */\n\n        goto unimplemented;\n\n    case TARGET_NR_umount:\n\n        ret = get_errno(umount((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_setuid:\n\n        ret = get_errno(setuid(arg1));\n\n        break;\n\n    case TARGET_NR_getuid:\n\n        ret = get_errno(getuid());\n\n        break;\n\n    case TARGET_NR_stime:\n\n        {\n\n            int *time_ptr = (int *)arg1;\n\n            if (time_ptr)\n\n                tswap32s(time_ptr);\n\n            ret = get_errno(stime((time_t *)time_ptr));\n\n        }\n\n        break;\n\n    case TARGET_NR_ptrace:\n\n        goto unimplemented;\n\n    case TARGET_NR_alarm:\n\n        ret = alarm(arg1);\n\n        break;\n\n    case TARGET_NR_oldfstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_pause:\n\n        ret = get_errno(pause());\n\n        break;\n\n    case TARGET_NR_utime:\n\n        goto unimplemented;\n\n    case TARGET_NR_stty:\n\n        goto unimplemented;\n\n    case TARGET_NR_gtty:\n\n        goto unimplemented;\n\n    case TARGET_NR_access:\n\n        ret = get_errno(access((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_nice:\n\n        ret = get_errno(nice(arg1));\n\n        break;\n\n    case TARGET_NR_ftime:\n\n        goto unimplemented;\n\n    case TARGET_NR_sync:\n\n        ret = get_errno(sync());\n\n        break;\n\n    case TARGET_NR_kill:\n\n        ret = get_errno(kill(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rename:\n\n        ret = get_errno(rename((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_mkdir:\n\n        ret = get_errno(mkdir((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_rmdir:\n\n        ret = get_errno(rmdir((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_dup:\n\n        ret = get_errno(dup(arg1));\n\n        break;\n\n    case TARGET_NR_pipe:\n\n        {\n\n            int *pipe_ptr = (int *)arg1;\n\n            ret = get_errno(pipe(pipe_ptr));\n\n            if (!is_error(ret)) {\n\n                tswap32s(&pipe_ptr[0]);\n\n                tswap32s(&pipe_ptr[1]);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_times:\n\n        goto unimplemented;\n\n    case TARGET_NR_prof:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgid:\n\n        ret = get_errno(setgid(arg1));\n\n        break;\n\n    case TARGET_NR_getgid:\n\n        ret = get_errno(getgid());\n\n        break;\n\n    case TARGET_NR_signal:\n\n        goto unimplemented;\n\n    case TARGET_NR_geteuid:\n\n        ret = get_errno(geteuid());\n\n        break;\n\n    case TARGET_NR_getegid:\n\n        ret = get_errno(getegid());\n\n        break;\n\n    case TARGET_NR_acct:\n\n        goto unimplemented;\n\n    case TARGET_NR_umount2:\n\n        ret = get_errno(umount2((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_lock:\n\n        goto unimplemented;\n\n    case TARGET_NR_ioctl:\n\n        ret = do_ioctl(arg1, arg2, arg3);\n\n        break;\n\n    case TARGET_NR_fcntl:\n\n        switch(arg2) {\n\n        case F_GETLK:\n\n        case F_SETLK:\n\n        case F_SETLKW:\n\n            goto unimplemented;\n\n        default:\n\n            ret = get_errno(fcntl(arg1, arg2, arg3));\n\n            break;\n\n        }\n\n        break;\n\n    case TARGET_NR_mpx:\n\n        goto unimplemented;\n\n    case TARGET_NR_setpgid:\n\n        ret = get_errno(setpgid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ulimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_oldolduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_umask:\n\n        ret = get_errno(umask(arg1));\n\n        break;\n\n    case TARGET_NR_chroot:\n\n        ret = get_errno(chroot((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_ustat:\n\n        goto unimplemented;\n\n    case TARGET_NR_dup2:\n\n        ret = get_errno(dup2(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_getppid:\n\n        ret = get_errno(getppid());\n\n        break;\n\n    case TARGET_NR_getpgrp:\n\n        ret = get_errno(getpgrp());\n\n        break;\n\n    case TARGET_NR_setsid:\n\n        ret = get_errno(setsid());\n\n        break;\n\n    case TARGET_NR_sigaction:\n\n#if 0\n\n        {\n\n            int signum = arg1;\n\n            struct target_old_sigaction *tact = arg2, *toldact = arg3;\n\n            ret = get_errno(setsid());\n\n            \n\n\n\n        }\n\n        break;\n\n#else\n\n        goto unimplemented;\n\n#endif\n\n    case TARGET_NR_sgetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_ssetmask:\n\n        goto unimplemented;\n\n    case TARGET_NR_setreuid:\n\n        ret = get_errno(setreuid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setregid:\n\n        ret = get_errno(setregid(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_sigsuspend:\n\n        goto unimplemented;\n\n    case TARGET_NR_sigpending:\n\n        goto unimplemented;\n\n    case TARGET_NR_sethostname:\n\n        ret = get_errno(sethostname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrlimit:\n\n        goto unimplemented;\n\n    case TARGET_NR_getrusage:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            ret = get_errno(gettimeofday(&tv, NULL));\n\n            if (!is_error(ret)) {\n\n                target_tv->tv_sec = tswapl(tv.tv_sec);\n\n                target_tv->tv_usec = tswapl(tv.tv_usec);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_settimeofday:\n\n        {\n\n            struct target_timeval *target_tv = (void *)arg1;\n\n            struct timeval tv;\n\n            tv.tv_sec = tswapl(target_tv->tv_sec);\n\n            tv.tv_usec = tswapl(target_tv->tv_usec);\n\n            ret = get_errno(settimeofday(&tv, NULL));\n\n        }\n\n        break;\n\n    case TARGET_NR_getgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_setgroups:\n\n        goto unimplemented;\n\n    case TARGET_NR_select:\n\n        goto unimplemented;\n\n    case TARGET_NR_symlink:\n\n        ret = get_errno(symlink((const char *)arg1, (const char *)arg2));\n\n        break;\n\n    case TARGET_NR_oldlstat:\n\n        goto unimplemented;\n\n    case TARGET_NR_readlink:\n\n        ret = get_errno(readlink((const char *)arg1, (char *)arg2, arg3));\n\n        break;\n\n    case TARGET_NR_uselib:\n\n        goto unimplemented;\n\n    case TARGET_NR_swapon:\n\n        ret = get_errno(swapon((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_reboot:\n\n        goto unimplemented;\n\n    case TARGET_NR_readdir:\n\n        goto unimplemented;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap:\n\n        {\n\n            uint32_t v1, v2, v3, v4, v5, v6, *vptr;\n\n            vptr = (uint32_t *)arg1;\n\n            v1 = tswap32(vptr[0]);\n\n            v2 = tswap32(vptr[1]);\n\n            v3 = tswap32(vptr[2]);\n\n            v4 = tswap32(vptr[3]);\n\n            v5 = tswap32(vptr[4]);\n\n            v6 = tswap32(vptr[5]);\n\n            ret = get_errno((long)mmap((void *)v1, v2, v3, v4, v5, v6));\n\n        }\n\n        break;\n\n#endif\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_mmap2:\n\n#else\n\n    case TARGET_NR_mmap:\n\n#endif\n\n        ret = get_errno((long)mmap((void *)arg1, arg2, arg3, arg4, arg5, arg6));\n\n        break;\n\n    case TARGET_NR_munmap:\n\n        ret = get_errno(munmap((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_truncate:\n\n        ret = get_errno(truncate((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_ftruncate:\n\n        ret = get_errno(ftruncate(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchmod:\n\n        ret = get_errno(fchmod(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_fchown:\n\n        ret = get_errno(fchown(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getpriority:\n\n        ret = get_errno(getpriority(arg1, arg2));\n\n        break;\n\n    case TARGET_NR_setpriority:\n\n        ret = get_errno(setpriority(arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_profil:\n\n        goto unimplemented;\n\n    case TARGET_NR_statfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_statfs((const char *)arg1, stfs));\n\n    convert_statfs:\n\n        if (!is_error(ret)) {\n\n            tswap32s(&stfs->f_type);\n\n            tswap32s(&stfs->f_bsize);\n\n            tswap32s(&stfs->f_blocks);\n\n            tswap32s(&stfs->f_bfree);\n\n            tswap32s(&stfs->f_bavail);\n\n            tswap32s(&stfs->f_files);\n\n            tswap32s(&stfs->f_ffree);\n\n            tswap32s(&stfs->f_fsid.val[0]);\n\n            tswap32s(&stfs->f_fsid.val[1]);\n\n            tswap32s(&stfs->f_namelen);\n\n        }\n\n        break;\n\n    case TARGET_NR_fstatfs:\n\n        stfs = (void *)arg2;\n\n        ret = get_errno(sys_fstatfs(arg1, stfs));\n\n        goto convert_statfs;\n\n    case TARGET_NR_ioperm:\n\n        goto unimplemented;\n\n    case TARGET_NR_socketcall:\n\n        ret = do_socketcall(arg1, (long *)arg2);\n\n        break;\n\n    case TARGET_NR_syslog:\n\n        goto unimplemented;\n\n    case TARGET_NR_setitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_getitimer:\n\n        goto unimplemented;\n\n    case TARGET_NR_stat:\n\n        ret = get_errno(stat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_lstat:\n\n        ret = get_errno(lstat((const char *)arg1, &st));\n\n        goto do_stat;\n\n    case TARGET_NR_fstat:\n\n        {\n\n            ret = get_errno(fstat(arg1, &st));\n\n        do_stat:\n\n            if (!is_error(ret)) {\n\n                struct target_stat *target_st = (void *)arg2;\n\n                target_st->st_dev = tswap16(st.st_dev);\n\n                target_st->st_ino = tswapl(st.st_ino);\n\n                target_st->st_mode = tswap16(st.st_mode);\n\n                target_st->st_nlink = tswap16(st.st_nlink);\n\n                target_st->st_uid = tswap16(st.st_uid);\n\n                target_st->st_gid = tswap16(st.st_gid);\n\n                target_st->st_rdev = tswap16(st.st_rdev);\n\n                target_st->st_size = tswapl(st.st_size);\n\n                target_st->st_blksize = tswapl(st.st_blksize);\n\n                target_st->st_blocks = tswapl(st.st_blocks);\n\n                target_st->st_atime = tswapl(st.st_atime);\n\n                target_st->st_mtime = tswapl(st.st_mtime);\n\n                target_st->st_ctime = tswapl(st.st_ctime);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_olduname:\n\n        goto unimplemented;\n\n    case TARGET_NR_iopl:\n\n        goto unimplemented;\n\n    case TARGET_NR_vhangup:\n\n        ret = get_errno(vhangup());\n\n        break;\n\n    case TARGET_NR_idle:\n\n        goto unimplemented;\n\n    case TARGET_NR_vm86old:\n\n        goto unimplemented;\n\n    case TARGET_NR_wait4:\n\n        {\n\n            int status;\n\n            target_long *status_ptr = (void *)arg2;\n\n            struct rusage rusage, *rusage_ptr;\n\n            struct target_rusage *target_rusage = (void *)arg4;\n\n            if (target_rusage)\n\n                rusage_ptr = &rusage;\n\n            else\n\n                rusage_ptr = NULL;\n\n            ret = get_errno(wait4(arg1, &status, arg3, rusage_ptr));\n\n            if (!is_error(ret)) {\n\n                if (status_ptr)\n\n                    *status_ptr = tswap32(status);\n\n                if (target_rusage) {\n\n                    target_rusage->ru_utime.tv_sec = tswapl(rusage.ru_utime.tv_sec);\n\n                    target_rusage->ru_utime.tv_usec = tswapl(rusage.ru_utime.tv_usec);\n\n                    target_rusage->ru_stime.tv_sec = tswapl(rusage.ru_stime.tv_sec);\n\n                    target_rusage->ru_stime.tv_usec = tswapl(rusage.ru_stime.tv_usec);\n\n                    target_rusage->ru_maxrss = tswapl(rusage.ru_maxrss);\n\n                    target_rusage->ru_ixrss = tswapl(rusage.ru_ixrss);\n\n                    target_rusage->ru_idrss = tswapl(rusage.ru_idrss);\n\n                    target_rusage->ru_isrss = tswapl(rusage.ru_isrss);\n\n                    target_rusage->ru_minflt = tswapl(rusage.ru_minflt);\n\n                    target_rusage->ru_majflt = tswapl(rusage.ru_majflt);\n\n                    target_rusage->ru_nswap = tswapl(rusage.ru_nswap);\n\n                    target_rusage->ru_inblock = tswapl(rusage.ru_inblock);\n\n                    target_rusage->ru_oublock = tswapl(rusage.ru_oublock);\n\n                    target_rusage->ru_msgsnd = tswapl(rusage.ru_msgsnd);\n\n                    target_rusage->ru_msgrcv = tswapl(rusage.ru_msgrcv);\n\n                    target_rusage->ru_nsignals = tswapl(rusage.ru_nsignals);\n\n                    target_rusage->ru_nvcsw = tswapl(rusage.ru_nvcsw);\n\n                    target_rusage->ru_nivcsw = tswapl(rusage.ru_nivcsw);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_swapoff:\n\n        ret = get_errno(swapoff((const char *)arg1));\n\n        break;\n\n    case TARGET_NR_sysinfo:\n\n        goto unimplemented;\n\n    case TARGET_NR_ipc:\n\n        goto unimplemented;\n\n    case TARGET_NR_fsync:\n\n        ret = get_errno(fsync(arg1));\n\n        break;\n\n    case TARGET_NR_sigreturn:\n\n        goto unimplemented;\n\n    case TARGET_NR_clone:\n\n        goto unimplemented;\n\n    case TARGET_NR_setdomainname:\n\n        ret = get_errno(setdomainname((const char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_uname:\n\n        /* no need to transcode because we use the linux syscall */\n\n        ret = get_errno(sys_uname((struct new_utsname *)arg1));\n\n        break;\n\n#ifdef TARGET_I386\n\n    case TARGET_NR_modify_ldt:\n\n        ret = get_errno(gemu_modify_ldt(cpu_env, arg1, (void *)arg2, arg3));\n\n        break;\n\n#endif\n\n    case TARGET_NR_adjtimex:\n\n        goto unimplemented;\n\n    case TARGET_NR_mprotect:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_sigprocmask:\n\n        {\n\n            int how = arg1;\n\n            sigset_t set, oldset, *set_ptr;\n\n            target_ulong *pset = (void *)arg2, *poldset = (void *)arg3;\n\n            \n\n            switch(how) {\n\n            case TARGET_SIG_BLOCK:\n\n                how = SIG_BLOCK;\n\n                break;\n\n            case TARGET_SIG_UNBLOCK:\n\n                how = SIG_UNBLOCK;\n\n                break;\n\n            case TARGET_SIG_SETMASK:\n\n                how = SIG_SETMASK;\n\n                break;\n\n            default:\n\n                ret = -EINVAL;\n\n                goto fail;\n\n            }\n\n            \n\n            if (pset) {\n\n                target_to_host_old_sigset(&set, pset);\n\n                set_ptr = &set;\n\n            } else {\n\n                set_ptr = NULL;\n\n            }\n\n            ret = get_errno(sigprocmask(arg1, set_ptr, &oldset));\n\n            if (!is_error(ret) && poldset) {\n\n                host_to_target_old_sigset(poldset, &oldset);\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR_create_module:\n\n    case TARGET_NR_init_module:\n\n    case TARGET_NR_delete_module:\n\n    case TARGET_NR_get_kernel_syms:\n\n        goto unimplemented;\n\n    case TARGET_NR_quotactl:\n\n        goto unimplemented;\n\n    case TARGET_NR_getpgid:\n\n        ret = get_errno(getpgid(arg1));\n\n        break;\n\n    case TARGET_NR_fchdir:\n\n        ret = get_errno(fchdir(arg1));\n\n        break;\n\n    case TARGET_NR_bdflush:\n\n        goto unimplemented;\n\n    case TARGET_NR_sysfs:\n\n        goto unimplemented;\n\n    case TARGET_NR_personality:\n\n        ret = get_errno(mprotect((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_afs_syscall:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsuid:\n\n        goto unimplemented;\n\n    case TARGET_NR_setfsgid:\n\n        goto unimplemented;\n\n    case TARGET_NR__llseek:\n\n        {\n\n            int64_t res;\n\n            ret = get_errno(_llseek(arg1, arg2, arg3, &res, arg5));\n\n            *(int64_t *)arg4 = tswap64(res);\n\n        }\n\n        break;\n\n    case TARGET_NR_getdents:\n\n#if TARGET_LONG_SIZE != 4\n\n#error not supported\n\n#endif\n\n        {\n\n            struct dirent *dirp = (void *)arg2;\n\n            long count = arg3;\n\n            ret = get_errno(sys_getdents(arg1, dirp, count));\n\n            if (!is_error(ret)) {\n\n                struct dirent *de;\n\n                int len = ret;\n\n                int reclen;\n\n                de = dirp;\n\n                while (len > 0) {\n\n                    reclen = tswap16(de->d_reclen);\n\n                    if (reclen > len)\n\n                        break;\n\n                    de->d_reclen = reclen;\n\n                    tswapls(&de->d_ino);\n\n                    tswapls(&de->d_off);\n\n                    de = (struct dirent *)((char *)de + reclen);\n\n                    len -= reclen;\n\n                }\n\n            }\n\n        }\n\n        break;\n\n    case TARGET_NR__newselect:\n\n        ret = do_select(arg1, (void *)arg2, (void *)arg3, (void *)arg4, \n\n                        (void *)arg5);\n\n        break;\n\n    case TARGET_NR_flock:\n\n        goto unimplemented;\n\n    case TARGET_NR_msync:\n\n        ret = get_errno(msync((void *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_readv:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(readv(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_writev:\n\n        {\n\n            int count = arg3;\n\n            int i;\n\n            struct iovec *vec;\n\n            struct target_iovec *target_vec = (void *)arg2;\n\n\n\n            vec = alloca(count * sizeof(struct iovec));\n\n            for(i = 0;i < count; i++) {\n\n                vec[i].iov_base = (void *)tswapl(target_vec[i].iov_base);\n\n                vec[i].iov_len = tswapl(target_vec[i].iov_len);\n\n            }\n\n            ret = get_errno(writev(arg1, vec, count));\n\n        }\n\n        break;\n\n    case TARGET_NR_getsid:\n\n        ret = get_errno(getsid(arg1));\n\n        break;\n\n    case TARGET_NR_fdatasync:\n\n        goto unimplemented;\n\n    case TARGET_NR__sysctl:\n\n        goto unimplemented;\n\n    case TARGET_NR_mlock:\n\n        ret = get_errno(mlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_munlock:\n\n        ret = get_errno(munlock((void *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_mlockall:\n\n        ret = get_errno(mlockall(arg1));\n\n        break;\n\n    case TARGET_NR_munlockall:\n\n        ret = get_errno(munlockall());\n\n        break;\n\n    case TARGET_NR_sched_setparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getparam:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_setscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_getscheduler:\n\n        goto unimplemented;\n\n    case TARGET_NR_sched_yield:\n\n        ret = get_errno(sched_yield());\n\n        break;\n\n    case TARGET_NR_sched_get_priority_max:\n\n    case TARGET_NR_sched_get_priority_min:\n\n    case TARGET_NR_sched_rr_get_interval:\n\n    case TARGET_NR_nanosleep:\n\n    case TARGET_NR_mremap:\n\n    case TARGET_NR_setresuid:\n\n    case TARGET_NR_getresuid:\n\n    case TARGET_NR_vm86:\n\n    case TARGET_NR_query_module:\n\n    case TARGET_NR_poll:\n\n    case TARGET_NR_nfsservctl:\n\n    case TARGET_NR_setresgid:\n\n    case TARGET_NR_getresgid:\n\n    case TARGET_NR_prctl:\n\n    case TARGET_NR_rt_sigreturn:\n\n    case TARGET_NR_rt_sigaction:\n\n    case TARGET_NR_rt_sigprocmask:\n\n    case TARGET_NR_rt_sigpending:\n\n    case TARGET_NR_rt_sigtimedwait:\n\n    case TARGET_NR_rt_sigqueueinfo:\n\n    case TARGET_NR_rt_sigsuspend:\n\n    case TARGET_NR_pread:\n\n    case TARGET_NR_pwrite:\n\n        goto unimplemented;\n\n    case TARGET_NR_chown:\n\n        ret = get_errno(chown((const char *)arg1, arg2, arg3));\n\n        break;\n\n    case TARGET_NR_getcwd:\n\n        ret = get_errno(sys_getcwd1((char *)arg1, arg2));\n\n        break;\n\n    case TARGET_NR_capget:\n\n    case TARGET_NR_capset:\n\n    case TARGET_NR_sigaltstack:\n\n    case TARGET_NR_sendfile:\n\n    case TARGET_NR_getpmsg:\n\n    case TARGET_NR_putpmsg:\n\n    case TARGET_NR_vfork:\n\n        ret = get_errno(vfork());\n\n        break;\n\n    case TARGET_NR_ugetrlimit:\n\n    case TARGET_NR_truncate64:\n\n    case TARGET_NR_ftruncate64:\n\n    case TARGET_NR_stat64:\n\n    case TARGET_NR_lstat64:\n\n    case TARGET_NR_fstat64:\n\n    case TARGET_NR_lchown32:\n\n    case TARGET_NR_getuid32:\n\n    case TARGET_NR_getgid32:\n\n    case TARGET_NR_geteuid32:\n\n    case TARGET_NR_getegid32:\n\n    case TARGET_NR_setreuid32:\n\n    case TARGET_NR_setregid32:\n\n    case TARGET_NR_getgroups32:\n\n    case TARGET_NR_setgroups32:\n\n    case TARGET_NR_fchown32:\n\n    case TARGET_NR_setresuid32:\n\n    case TARGET_NR_getresuid32:\n\n    case TARGET_NR_setresgid32:\n\n    case TARGET_NR_getresgid32:\n\n    case TARGET_NR_chown32:\n\n    case TARGET_NR_setuid32:\n\n    case TARGET_NR_setgid32:\n\n    case TARGET_NR_setfsuid32:\n\n    case TARGET_NR_setfsgid32:\n\n    case TARGET_NR_pivot_root:\n\n    case TARGET_NR_mincore:\n\n    case TARGET_NR_madvise:\n\n    case TARGET_NR_getdents64:\n\n    case TARGET_NR_fcntl64:\n\n    case TARGET_NR_security:\n\n        goto unimplemented;\n\n    case TARGET_NR_gettid:\n\n        ret = get_errno(gettid());\n\n        break;\n\n    case TARGET_NR_readahead:\n\n    case TARGET_NR_setxattr:\n\n    case TARGET_NR_lsetxattr:\n\n    case TARGET_NR_fsetxattr:\n\n    case TARGET_NR_getxattr:\n\n    case TARGET_NR_lgetxattr:\n\n    case TARGET_NR_fgetxattr:\n\n    case TARGET_NR_listxattr:\n\n    case TARGET_NR_llistxattr:\n\n    case TARGET_NR_flistxattr:\n\n    case TARGET_NR_removexattr:\n\n    case TARGET_NR_lremovexattr:\n\n    case TARGET_NR_fremovexattr:\n\n        goto unimplemented;\n\n    default:\n\n    unimplemented:\n\n        gemu_log(\"Unsupported syscall: %d\\n\", num);\n\n        ret = -ENOSYS;\n\n        break;\n\n    }\n\n fail:\n\n    return ret;\n\n}\n", "idx": 14289, "substitutes": {"cpu_env": ["cpu_ext", "cpu2info", "cpu_path", "cpu2path", "cpu2ext", "cpu_info", "pu_ext", "pu_info", "cpu2env", "pu_path", "pu_env"], "num": ["proc", "NUM", "sync", "nam", "integ", "code", "current", "name", "msg", "fun", "test", "nb", "unit", "method", "con", "init", "sum", "gnu", "loc", "valid", "fn", "begin", "np", "temp", "multi", "count", "n", "nu", "number", "timeout", "block", "nm", "counter", "Num", "type", "gen", "loop", "cmd", "out", "command", "um", "param", "off", "no", "reg", "dim", "len", "thread", "node"], "arg1": ["erg2", "arg10", "ig2", "ar2", "Arg91", "ax1", "args6", "argument1", "args2", "argumentone", "arg31", "argone", "arg91", "arg01", "ar1", "Argn", "Arg01", " arg0", "ag2", "ig1", "Arg4", "ag6", "mag2", " arg31", "args3", "argumentn", " arg01", "ax6", "ar4", " argone", "args1", " arg91", "erg31", "mag91", "inc2", "Arg5", "ag0", "ar3", "argument3", "Arg31", "mag1", "Arg0", "inc1", "ax2", "args0", "arg0", "Arg10", "Arg2", "argument01", "Arg3", " arg10", "Arg1", "ar0", "argument6", "erg1", "argn", "ig3", "inc3", "ax5", "axone", "ag1", "ig10", "args4", "inc4", "argument2", " argn"], "arg2": ["Arg5", "Arg6", "Arg52", " arg52", "ar3", "Arg4", "argument42", "ark4", "ar2", "arg02", "ax4", "ax1", "Arg42", "argument52", "item42", "argument4", "arg52", "ark1", "ax2", "item4", "ax6", "ar4", "item5", "argument1", "Arg2", "arg42", "Arg3", "Arg02", "Arg1", "ar1", " arg02", "ark2", "ark02", "argument2", "item2", "argument5"], "arg3": ["Arg5", "Arg6", "argument6", "ar3", "Arg4", "argument3", "ar2", "argument4", "ar4", "argument1", "Arg2", "Arg3", "Arg1", "ar1", "argument2", "argument5", "ar6"], "arg4": ["args4", "args3", "argument2", "args5", "args2", "argument3", "argument4", "argument5"], "arg5": ["args4", "ar4", "ar2", "args3", "ar3", "args5", "ar5", "args2"], "arg6": ["args6", "doc5", "ax7", "doc6", "doc7", "ax6", "args8", "arg7", "ax5", "arg8", "doc8", "args5", "args7", "ax8"], "ret": ["alt", "let", "en", "rev", "format", "ft", "reply", "sg", "rc", "id", "val", "back", "def", "rets", "gt", "fun", "rg", "std", "str", "ref", "det", "arg", "lit", "error", "value", "job", "conn", "obj", "pass", "ut", "mt", "ll", "mem", "success", "data", "match", "ext", "Ret", "result", "expr", "att", "rl", "url", "red", "cat", " result", "nt", "re", "rt", "get", "resp", "repl", "db", "r", "RET", "reg", "flag", "lv", "len", "bit", "err"], "st": ["t", "ust", "std", "x", "vm", "istic", "ss", "mt", "bl", "ST", "sf", "sb", "est", "inst", "St", "store", "sn", "nt", "sc", "sl", "ast", "stack", "ist", "rest", "sts", "ost"], "stfs": ["sthfs", "stfn", "snFS", "ostfd", "snfd", "snfs", "snfn", "stfd", "ostfs", "sthFS", "sthfn", "ostFS", "ostfn", "stFS", "sthfd"], "status": ["date", "warning", "STAT", "complete", "service", "d", "id", "code", "msg", "name", "ex", "fps", "sp", "source", "progress", "uses", "str", "si", "update", "comment", "error", "job", "step", "flags", "size", "stage", "version", "active", "s", "info", "sec", "temp", "wait", "success", "data", "stat", "result", "speed", "state", "spec", "serv", "type", "stats", "security", "class", "flag", "y", "Status", "index", "start"]}}
{"project": "qemu", "commit_id": "f80ac75d0e6e6e7481d61cdb86e5a741a442f100", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300, "substitutes": {"bs": ["ses", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "iss", "bb", "ob", "cs", "fps", "os", "bytes", "js", "ps", "ss", "rb", "obs", "plugins", "pb", "b", "sb", "base", "banks", "gb", "gs", "bits", "bh", "ns", "bps", "bes", "bas", "ds", "bi", "db", "sa", "src", "ls", "css", "lb", "bos", "ubs", "bl", "vs", "ts", "abi", "ks"], "res": ["ons", "rez", "proc", "ret", "rss", "sys", "rev", "rus", "Res", "response", "gr", "fs", "rs", "ray", "ex", "cs", "req", "os", "js", "rows", "RES", "ros", "pres", "ras", "ps", "mr", "result", "resolution", "des", "results", "re", "r", "resp", "ress", "pers", "reg", "rem", "vals", "err"], "refcount_table": ["refall_window", "refcount_tree", "refCount_total", "refcountPsequence", "refcount_session", "refcount_window", "refcountttable", "refcounterTABLE", "refcount_sequence", "refcountsheader", "refcountscache", "refcount__table", "refcount_cache", "refCount2total", "refall_tree", "refcount__session", "refallPwindow", "refallPsequence", "refcountPwindow", "refcountstable", "refcount_TABLE", "refall_sequence", "refCount2table", "refcount_header", "refCount_session", "refcountercache", "refall_table", "refcounterheader", "refcountertable", "refallPtable", "refcountsTABLE", "refallPtree", "refcount__total", "refcount2table", "refCount2session", "refcount_total", "refcount2session", "refcountttree", "refcountPtable", "refcounttsequence", "refCount_table", "refcountPtree", "refcounttwindow", "refcount2total"], "nb_clusters": ["nb_pliques", "nb_plonents", "nb_clicas", "nb_plients", "nb_cluster", "nb_Clayers", "nb_blusters", "nb_blashes", "nb_cliques", "nb_scliques", "nb_clients", "nb_blients", "nb_sclonents", "nb_licas", "nb_lusters", "nb_plashes", "nb_Clicas", "nb_lients", "nb_codes", "nb_blodes", "nb_bliques", "nb_plusters", "nb_clayers", "nb_clashes", "nb_players", "nb_pluster", "nb_custer", "nb_clonents", "nb_clodes", "nb_custers", "nb_plodes", "nb_sclusters", "nb_blonents", "nb_layers", "nb_cashes", "nb_sclients", "nb_Clients", "nb_bluster", "nb_Clusters", "nb_plicas"], "s": ["ess", "secondary", "args", "sys", "ses", "self", "bis", "parts", "service", "sync", "sg", "fs", "ins", "rs", "sym", "cs", "details", "S", "settings", "hs", "os", "qs", "words", "sites", "sets", "js", "si", "es", "session", "server", "ps", "ss", "p", "http", "site", "b", "features", "lines", "tests", "gs", "state", "spec", "c", "ns", "xs", "is", "stats", "outs", "ssl", "sv", "sl", "states", "services", "ds", "sie", "r", "sa", "ops", "ls", "ts", "space", "ims", "iss", "aws"], "refblock_offset": ["refoff_error", "refoff_index", "refblocks_set", "refrow_start", "refblock8alpha", "refblock_addr", "refblock2addr", "refblock00padding", "refblock2offset", "refblock0error", "refcol8offset", "refblock_padding", "refcol_offset", "refoff_size", "refoff0error", "refcol8padding", "refblock00alpha", "refoff0offset", "refblock_alpha", "refblocks_offset", "refblocks_index", "refblock00location", "refcol8location", "refblock_error", "refcol_padding", "refblock8location", "refcol8alpha", "refblock_set", "refblock2set", "refcol_location", "refcol_alpha", "refrow_Offset", "refblock8padding", "refrow_offset", "refblock8offset", "refblock0size", "refblock0index", "refblock2index", "refoff_offset", "refblock00offset", "refblock_Offset", "refoff0size", "refblock0offset", "refoff0index", "refblock_location", "refblock_size", "refblocks_addr"], "refblock_start": ["refblockCstart", "refblock__start", "refblock67origin", "refblock00align", "refBlock_address", "refblock_align", "refBlock_offset", "refblockingstart", "refblock00start", "refblock00origin", "refblock67index", "refblock__index", "refblock_pad", "refblockingorigin", "refBlock_origin", "refblock_origin", "refBlock_start", "refblock67start", "refblock_id", "refblock_get", "refblock__align", "refblockingindex", "refblockAend", "refblock_address", "refblock__offset", "refblockCid", "refblockAstart", "refblock__get", "refblockAoffset", "refblock_end", "refblock67address", "refblockApad", "refblock00offset", "refblock__id", "refBlock_end", "refblockingaddress", "refblock__origin", "refblockCindex", "refBlock_pad", "refBlock_index", "refblockCget"], "refblock_index": ["refoff_index", "refblock__start", "refsection_index", "reflock0index", "refblock2offset", "reflock0start", "refoff_end", "reflock_offset", "refblock_number", "refblockerindex", "refblock__ind", "refsectionerindex", "reflock0size", "refblock__index", "refsection_start", "refoff_ind", "reflock_start", "refsectionerinc", "reflock_number", "refblockerinc", "refoff__start", "refsectionerstart", "refblock0start", "refblock_ind", "refblockCnumber", "refblockCoffset", "refblockCrange", "refblock2size", "refoff__index", "refblock2ind", "reflock_size", "refsection_inc", "refblock__end", "refoff__ind", "reflock_index", "refblock0size", "refblock0index", "refblock_end", "refblock2index", "refsection_end", "refblockerstart", "refblockCindex", "refoff_start", "refsectionerend", "refblockerend", "refblock_size", "refblock_range", "refblock_inc", "refoff__end", "reflock_range"], "on_disk_reftable": ["on_disk_recoverible", "on_disk_recoveror", "on_disk_breveree", "on_disk_reftor", "on_disk_reveree", "on_disk_breftable", "on_disk_rectible", "on_disk_reverible", "on_disk_reftible", "on_disk_reverable", "on_disk_recoverable", "on_disk_breveror", "on_disk_reveror", "on_disk_breftible", "on_disk_rector", "on_disk_breverable", "on_disk_rectable", "on_disk_reftee", "on_disk_breverible", "on_disk_breftor", "on_disk_recoveree", "on_disk_breftee", "on_disk_rectee"], "on_disk_refblock": ["on_disk_relblock", "on_disk_relcache", "on_disk_relcount", "on_disk_referencecount", "on_disk_refcache", "on_disk_refcount", "on_disk_referencecache", "on_disk_referenceblock"], "QEMU_PACKED": ["QEMU_Packeded", "QEMU_PackedES", "QEMU_POWERED", "QEMU_PADDED", "QEMU_PUACKES", "QEMU_POWERed", "QEMU_PUADDES", "QEMU_PUACKED", "QEMU_PACKES", "QEMU_PACK32", "QEMU_PACKed", "QEMU_POWERES", "QEMU_PackedED", "QEMU_PUADD32", "QEMU_PADD32", "QEMU_POWER32", "QEMU_PUADDED", "QEMU_PUADDed", "QEMU_Packed32", "QEMU_PADDed", "QEMU_PUACKed", "QEMU_PADDES", "QEMU_PUACK32"], "cluster": ["sclust", "compause", "clocate", "slause", "CLause", "clusters", "blause", "chuster", "slust", "sclause", "slocate", "clore", "CLuster", "custer", " claco", "slard", "compuster", "blore", " clard", " cluration", "scluster", "slore", "clancer", "slaco", "sluration", "slusters", "cancer", "blaco", "blust", "bloser", "blard", "coser", "blusters", "CLusters", "compust", "choser", "slancer", "clard", "blocate", "bluster", "clause", "chancer", "sluster", "clust", "scloser", " clause", " clust", "closer", "cluration", "composer", "bluration", "CLocate", "chause", "cause", "claco", "sloser", " clore"], "check_errors": ["checkingruns", "checkingerrors", "block_error", "checkallerror", "checkingfailed", "check_error", "check_runs", "checkingerror", "checkallerrors", "check_failed", "block_errors", "block_failed", "checkallruns", "block_runs", "checkallfailed"], "new_on_disk_reftable": ["new_on_disk_precoverabe", "new_on_disk_preftabe", "new_on_disk_preftable", "new_on_disk_reffing", "new_on_disk_breffing", "new_on_disk_precovertable", "new_on_disk_breftible", "new_on_disk_breftor", "new_on_disk_reafting", "new_on_disk_breffor", "new_on_disk_reftor", "new_on_disk_reverable", "new_on_disk_reafttable", "new_on_disk_recoverabe", "new_on_disk_prefting", "new_on_disk_reaftable", "new_on_disk_precovering", "new_on_disk_recovertable", "new_on_disk_revering", "new_on_disk_breftable", "new_on_disk_recoverable", "new_on_disk_rector", "new_on_disk_rectable", "new_on_disk_reffor", "new_on_disk_reffible", "new_on_disk_reveror", "new_on_disk_refting", "new_on_disk_prefttable", "new_on_disk_reftabe", "new_on_disk_precoverable", "new_on_disk_reaftabe", "new_on_disk_refttable", "new_on_disk_revertable", "new_on_disk_recovering", "new_on_disk_recting", "new_on_disk_rectible", "new_on_disk_breffible", "new_on_disk_breffable", "new_on_disk_reverible", "new_on_disk_reffable", "new_on_disk_brefting", "new_on_disk_reftible", "new_on_disk_reverabe"], "reftable_clusters": ["reftable_plos", "reftable_sclusters", "reftable_plicas", "reftable_licas", "reftable_clicas", "reftable_sclicas", "reftable_lusters", "reftable_los", "reftable_plores", "reftable_sclos", "reftable_lores", "reftable_clos", "reftable_clores", "reftable_sclores", "reftable_plusters"]}}
{"project": "FFmpeg", "commit_id": "f1ffb01ee9fd3a15c395c3cf6ff362ac5cd668d0", "target": 0, "func": "static int synchronize_audio(VideoState *is, short *samples,\n\n                             int samples_size1, double pts)\n\n{\n\n    int n, samples_size;\n\n    double ref_clock;\n\n\n\n    n = 2 * is->audio_st->codec->channels;\n\n    samples_size = samples_size1;\n\n\n\n    /* if not master, then we try to remove or add samples to correct the clock */\n\n    if (((is->av_sync_type == AV_SYNC_VIDEO_MASTER && is->video_st) ||\n\n         is->av_sync_type == AV_SYNC_EXTERNAL_CLOCK)) {\n\n        double diff, avg_diff;\n\n        int wanted_size, min_size, max_size, nb_samples;\n\n\n\n        ref_clock = get_master_clock(is);\n\n        diff = get_audio_clock(is) - ref_clock;\n\n\n\n        if (diff < AV_NOSYNC_THRESHOLD) {\n\n            is->audio_diff_cum = diff + is->audio_diff_avg_coef * is->audio_diff_cum;\n\n            if (is->audio_diff_avg_count < AUDIO_DIFF_AVG_NB) {\n\n                /* not enough measures to have a correct estimate */\n\n                is->audio_diff_avg_count++;\n\n            } else {\n\n                /* estimate the A-V difference */\n\n                avg_diff = is->audio_diff_cum * (1.0 - is->audio_diff_avg_coef);\n\n\n\n                if (fabs(avg_diff) >= is->audio_diff_threshold) {\n\n                    wanted_size = samples_size + ((int)(diff * is->audio_st->codec->sample_rate) * n);\n\n                    nb_samples = samples_size / n;\n\n\n\n                    min_size = ((nb_samples * (100 - SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    max_size = ((nb_samples * (100 + SAMPLE_CORRECTION_PERCENT_MAX)) / 100) * n;\n\n                    if (wanted_size < min_size)\n\n                        wanted_size = min_size;\n\n                    else if (wanted_size > max_size)\n\n                        wanted_size = max_size;\n\n\n\n                    /* add or remove samples to correction the synchro */\n\n                    if (wanted_size < samples_size) {\n\n                        /* remove samples */\n\n                        samples_size = wanted_size;\n\n                    } else if (wanted_size > samples_size) {\n\n                        uint8_t *samples_end, *q;\n\n                        int nb;\n\n\n\n                        /* add samples */\n\n                        nb = (samples_size - wanted_size);\n\n                        samples_end = (uint8_t *)samples + samples_size - n;\n\n                        q = samples_end + n;\n\n                        while (nb > 0) {\n\n                            memcpy(q, samples_end, n);\n\n                            q += n;\n\n                            nb -= n;\n\n                        }\n\n                        samples_size = wanted_size;\n\n                    }\n\n                }\n\n                av_dlog(NULL, \"diff=%f adiff=%f sample_diff=%d apts=%0.3f vpts=%0.3f %f\\n\",\n\n                        diff, avg_diff, samples_size - samples_size1,\n\n                        is->audio_clock, is->video_clock, is->audio_diff_threshold);\n\n            }\n\n        } else {\n\n            /* too big difference : may be initial PTS errors, so\n\n               reset A-V filter */\n\n            is->audio_diff_avg_count = 0;\n\n            is->audio_diff_cum       = 0;\n\n        }\n\n    }\n\n\n\n    return samples_size;\n\n}\n", "idx": 14306, "substitutes": {"is": ["mis", "nis", "i", "ish", "js", "si", "play", "isi", "serv", "ics", "im", "get", "ist", "are", "kit", "in", "ais", "bis", "series", "fs", "id", "oss", "iv", "or", "cms", "es", "ois", "isa", "s", "inst", "bits", "ip", "ops", "sie", "sis", "iss", "Is", "osi", "parts", "does", "has", "ci", "os", "IS", "ie", "iris", "init", "ms", "obs", "info", "state", "ls", "it", "isu", "ists", "ses", "ui", "as", "isin", "bs", "ai", "lis", "its", "ii", "sil", "isc", "ris", "isl", "op", "iso", "ic", "ri", "css", "ori", "us", "ils", "esi", "irc"], "samples": ["Samps", "Sannels", "samps", "sesamples", "sannels", " sannels", " samps", "sesips", "sesannels", "Sips", " sips", "sips", "sesamps", "Samples"], "samples_size1": ["samples_mode01", "samples_scale01", "samples_scale1", "samples_form01", "samples_scale2", "samples_mode2", "samples_form2", "samples_size01", "samples_unit1", "samples_size2", "samples_form1", "samples_mode1"], "pts": ["ptsi", "mindsi", "indsf", "putsf", "inds", "mindsf", "mindS", "putsi", "minds", "putS", "ptS", "indS", "indsi", "ptsf"], "n": ["adj", "m", "en", "nl", "d", "t", "ni", "l", "i", "un", "nn", "N", "name", "g", "cn", "x", "fn", "v", "nw", "conn", " N", "np", "o", "w", "z", "size", "u", "p", "y", "s", "an", "e", "nc", "k", "b", "min", "j", "count", "f", "nu", "c", "ns", "ne", "norm", "sn", "network", "dn", "num", "span", "len", "pn", "net"], "samples_size": ["sourses_sized", "summiesallscale", "summies_edge", "samples__ize", "samples___scale", "samplesetsized", "sourses_type", "sourses0size", "samples_weight", "samples128sized", "samples___sized", "samples___capacity", "samplesalledge", "sample_ize", "samplesetarea", "summiesallsize", "samples__size", "samples_center", "samples___weight", "samplesallscale", "samples0center", "samples__member", "sourses0type", "samplesallsize", "samples128center", "summiesallcount", "sampleetsized", "samples0type", "sourses_center", "sourses_size", "samplesallcount", "samples_width", "summiesalledge", "summies_size", "summies_count", "samplesetize", "sampleslexize", "summies_scale", "samples_member", "samples_capacity", "samplesetsize", "sample_area", "samples_area", "samples128type", "samples0sized", "samples_sized", "samples__width", "samples___size", "samples_scale", "sampleslexsize", "samples_sum", "sourses0center", "sampleslexmember", "sampleslexwidth", "samples_edge", "samples_ize", "sourses0sized", "sampleetsize", "samples128size", "sampleetize", "samples_count", "sample_size", "samples___sum", "sample_sized", "sampleetarea", "samples0size", "samples_type", "samples_length"], "ref_clock": ["ref_lock", " referencexbalance", " ref_error", "ref01clock", "refureround", "ref_Clock", "ref01lock", "ref67charge", "ref01error", " ref_Clock", "ref_round", "refureclock", "ref_balance", "refxbalance", " referencexclock", "refxclock", "ref67clock", "ref67Clock", " reference_clock", " referencexround", "ref_charge", "ref67lock", " ref_lock", " reference_round", "refurebalance", "ref01Clock", "ref_error", " ref_charge", " reference_balance", "refxround"], "diff": ["bug", "transfer", "part", "frac", "d", "dist", "shift", "l", "i", "def", "range", "low", "test", "progress", "ref", "cmp", "update", "sum", "comment", "dir", "error", "conf", " delta", "alpha", "dust", "mix", "cd", "iff", "dev", " difference", "version", "info", "desc", "comp", "distance", "data", "min", "length", "count", "f", "none", "flow", "fe", "df", "message", "md", "change", "scale", "fail", "Diff", "between", "changed", " differences", "different", "err"], "avg_diff": ["avgen_comp", "avgin67message", "avgin67length", "avgen_diff", "avg67message", "avrg_cmp", "avgen_field", "avg_message", "avrg_diff", "avgin67scale", "avg67scale", "avg_different", "avg_length", "avg67length", "avrg_different", "avg_cmp", "avg_comp", "avg67comp", "avg_dist", "avg67diff", "avgin67diff", "avgin_scale", "avg67field", "avg_field", "avgin_diff", "avgin_length", "avg67dist", "avgen_dist", "avg_scale", "avrg_comp", "avgin_message"], "wanted_size": ["wanted_num", "wanted64scale", "wanted_ize", "want_mode", "wanted67size", "wanted_mode", "want_lane", "want_size", "wanted_code", "want_ize", "wanted_capacity", "wanted_sized", "wanted64ize", "wanted_name", "wanted_lane", "wanted64sized", "wanting_size", "woded_num", "watched_size", "wanted_speed", "want_sized", "watched_speed", "wanting_scale", "wanted_left", "woded_size", "woded_scale", "wanted67ize", "wanting_left", "watched_capacity", "wanted67mode", "wanted67scale", "want_speed", "wanting_ize", "wanted64length", "want_name", "wanted_length", "wanted64speed", "wanting_code", "wanted64size", "watched_ize", "want_Size", "want_time", "wanted64num", "wanted_time", "woded_length", "want_scale", "wanted_scale", "wanted_Size", "wanting_capacity"], "min_size": ["minallrate", "min_large", " min_length", " min_course", "min\u00b7rate", "minqsize", "minimum\u00b7size", "min\u00b7area", "minallsize", "min_speed", "minimum_area", "min_length", "min48size", "min64speed", "minqgrow", "min64size", "min_rate", "min48course", "int_large", "min_area", "minfsmall", "min_course", "min_mini", " min_mini", "min_core", "min64source", "min_small", "int_core", "minimum_grow", "min_source", "minflarge", "min_grow", "min\u00b7size", "minimum\u00b7rate", "min48length", " min_source", "min64mini", "int_small", "min48speed", "minimum_rate", "minimum\u00b7area", "minimum_size", "minimum\u00b7grow", "int_size", "minallarea", "minfsize", "minqarea", "minallgrow", "minqrate", "minfcore", "min\u00b7grow", " min_speed"], "max_size": ["maxacsource", "maxenshape", "maxfullstrength", "maxacsize", "max\u00b7strength", "breakfullshape", "max_shape", "max_score", "max00large", "maxingsize", " max_handle", "breakfullsize", "maxfulldepth", "maxfullshape", "maxensize", "max00size", "maxfullscore", "max00cache", "maxenscore", "max\u00b7shape", "break_strength", " max_large", "maxingscale", "max_handle", "az_source", "maxfullscale", " max_depth", "max\u00b7score", "maxingcache", " max_scale", "max_large", "max_scale", "az_uri", "max_cache", "maxinglarge", "maxmsize", "max_source", "max\u00b7size", "break_size", "max_depth", "maxfullhandle", "max_strength", "breakfullscore", "maxenstrength", "max00scale", "maxmscale", " max_cache", "maxmdepth", "break_shape", "maxacuri", "break_score", "maxfullsize", "max_uri", "breakfullstrength", "maxmhandle", "az_size"], "nb_samples": ["nb_namples", "nb_banguages", "nb_sesamples", "nb_tamples", "nb67sacters", "nb_testsamps", "nb_servicesiments", "nb_filesannels", "nb_stamples", "nb_gample", "nb_servicesacters", "nb_stides", "nb_tesamples", "nb_bides", "nb_tesiments", "nb_siments", "nb_sviments", "nb_svamples", "nb_bamples", "nb_servicesamples", "nb_sesources", "nb_sources", "nb_filesimens", "nb_bources", "nb_filesamples", "nb_tesacters", "nb67tesacters", "nb_sidamples", "nb_sacters", "nb_tamps", "nb67splings", "nb_sample", "nb_sidamps", "nb67tesiments", "nb_simens", "nb_nannels", "nb_stources", "nb_sores", "nb_sesides", "nb_sanguages", "nb_splings", "nb_tesplings", "nb_testsamples", "nb_namps", "nb_testsannels", "nb_sesanguages", "nb_gamps", "nb_tores", "nb_stanguages", "nb_sidores", "nb_gores", "nb67tesplings", "nb_testsimens", "nb_svacters", "nb67tesamples", "nb_svplings", "nb_sides", "nb_gamples", "nb_samps", "nb_sannels", "nb67siments", "nb_tample", "nb_nimens", "nb67samples", "nb_filesamps", "nb_sidample", "nb_servicesplings"], "audio_diff_avg_count": ["audio_diff_avG_sum", "audio_diff_avg_sum", "audio_diff_avg_c", "audio_diff_avg_cache", "audio_diff_avG_diff", "audio_diff_avG_c", "audio_diff_avG_cache", "audio_diff_avG_count", "audio_diff_avg_diff"]}}
{"project": "FFmpeg", "commit_id": "a82468514048fb87d9bf38689866bc3b9aaccd02", "target": 1, "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n\n                               int is_indeo4)\n\n{\n\n    int p, b;\n\n    uint32_t b_width, b_height, align_fac, width_aligned,\n\n             height_aligned, buf_size;\n\n    IVIBandDesc *band;\n\n\n\n    ivi_free_buffers(planes);\n\n\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* fill in the descriptor of the luminance plane */\n\n    planes[0].width     = cfg->pic_width;\n\n    planes[0].height    = cfg->pic_height;\n\n    planes[0].num_bands = cfg->luma_bands;\n\n\n\n    /* fill in the descriptors of the chrominance planes */\n\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n\n        if (!planes[p].bands)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* select band dimensions: if there is only one band then it\n\n         *  has the full size, if there are several bands each of them\n\n         *  has only half size */\n\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n\n                                            : (planes[p].width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14308, "substitutes": {"planes": ["codes", "types", "users", "cards", "cats", "bands", "pieces", "parts", "drivers", "thumbnails", "cycles", "scenes", "workers", "balls", "config", "docs", "levels", "pins", "rates", "photos", "pages", "plates", "qs", "models", "plane", "settings", "cuts", "classes", "flat", "words", "limits", "devices", "birds", "works", "rows", "files", "weights", "ps", "lists", "flags", "views", "groups", "plugins", "images", "features", "banks", "lines", "tests", "frames", "bits", "flows", "liners", "powers", "cells", "maps", "bags", "ports", "stats", "players", "forms", "reports", "cases", "services", "links", "states", "ops", "rules", "lights"], "cfg": ["mc", "cm", "bc", "gov", "ca", "ea", "ni", "sg", "config", "ini", "iana", "cdn", "gi", "alg", "fle", "gc", "msg", "g", "lc", "ig", "ci", "settings", "plane", "rg", "ugi", "cy", "init", "fg", "umi", "gin", "ii", "cgi", "fine", "conf", "gn", "storage", "conn", "gd", "np", "cons", "loader", "oga", "img", "fi", "gg", "cli", "nc", "ext", "fab", "eng", "lag", "gs", "gb", "cca", "dc", "ng", "gen", "cb", "gate", "sci", "sc", "cmd", "mag", "cf", "org", "gui", "ga", "comm", "css", "core", "git", "ctx", "gp"], "is_indeo4": ["is_indeos256", "is_inded0", "is_indee0", "is_indee256", "is_indio4", "is_indeo0", "is_indie0", "is_inded4", "is_inded256", "is_indio0", "is_indio256", "is_indeos4", "is_indie4", "is_indeo256", "is_indee4", "is_indeos0", "is_indie256"], "p": ["port", "i", "pre", "h", "lp", "x", "fp", "br", "ps", "np", "pl", "base", "c", "cp", "tp", "m", "part", "d", "t", "or", "api", "g", "bp", "w", "u", "s", "pa", "page", "length", "ip", "pe", "r", "pr", "po", "pc", "pid", "o", "z", "e", "j", "f", "point", "pm", "power", "pos", "ph", "post", "pn", "jp", "l", "up", "back", "pt", "a", "er", "py", "pp", "ap", "v", "patch", "pu", "k", "op", "n", "wp", "per", "pi", "q", "pad", "P", "y"], "b": ["bin", "part", "bc", "d", "ob", "bs", "l", "i", "bb", "fb", "a", "bd", "g", "h", "nb", "x", "v", "br", "mb", "o", "bp", "w", "lib", "bar", "u", "ba", "e", "s", "bot", "boot", "ib", "rb", "k", "be", "base", "sb", "j", "wb", "n", "f", "bf", "gb", "ab", "c", "body", "eb", "r", "bi", "db", "B", "emb", "lb", "bl", "y"], "b_width": ["b_shape", "b_direction", "nb_w", "bvheight", "b_filename", "bacdirection", "boot_width", "bf_strength", "bacshape", "bacwidth", "bf_filename", "bvwidth", "b_strength", "bacweight", "boot_weight", "b_w", "nb_wm", "bvwm", "b_weight", "nb_width", "boot_shape", "bf_gender", "bf_width", "b_wm", "boot_direction", "nb_height", "b_gender", "bvw"], "b_height": ["l_dash", "b_shape", "l_width", "b___width", "b___height", "b_rank", "b__height", " b_depth", "b__volume", " b_volume", "b_dash", "b_depth", "l_height", "l_rank", "lb_pass", "b__shape", "lb_alpha", " b_shape", "b___rank", "b_pass", "b___dash", "lb_height", "b_volume", "b__depth", "b_alpha"], "align_fac": ["quality_format", "align___frac", "qualityityformat", "align___factor", "align67lat", "aligned_fac", "alignityeff", "align___rac", "aligned_fam", "qualityityfac", " alignment_frac", "alignityformat", "quality_eff", " align_factor", "align___fac", "align_lat", "alignerfam", "quality_Fac", "align_frac", "alignerlat", "alignkeff", "aligned_lat", "align_factor", "align2fac", "align___fam", "align_vol", "alignityFac", "alignkFac", "align_format", "align_fam", "qualityityeff", "quality_fac", "align_rac", "align2frac", " alignment_vol", "align2vol", "align2fi", "alignederfam", "align_Fac", "align_eff", "align67fac", "alignederfac", "align67frac", "alignityfac", "align67fam", "alignerfac", "alignkfac", "alignederfrac", "aligned_frac", "alignerfrac", " alignment_fi", "qualityityFac", "alignkformat", " align_rac", "alignederlat", "align___lat", " alignment_fac", "align_fi"], "width_aligned": ["h___aligned", "h___filled", "widthingaligned", "widthingjoined", "width___centered", "url_available", "width_available", "width67filled", " width_signed", "h_centered", "width___signed", "widthingidentified", "h_signed", "width___aligned", "url_aligned", "width67signed", "width_identified", "h___signed", " width_ranged", "h_aligned", "url_joined", "width67centered", "width_ranged", "width_signed", "width_centered", "width_filled", "url_identified", "h_filled", "width67aligned", "h___centered", " width_joined", "width___filled", "widthingavailable", "width_joined"], "height_aligned": ["gapallcentered", "height_ranged", "height64aligned", "gap_aligned", "height_sat", "height_required", "gap_centered", "height_centered", "height_igned", "height64required", "heightallaligned", "gapallrequired", "height_adjusted", "height64sat", " height_igned", "height_joined", "gap_required", "height64centered", "heightallcentered", "heightallsat", " height_ranged", " height_joined", "gap_sat", "heightallrequired", "gapallsat", "gapallaligned", " height_adjusted"], "buf_size": ["buf_count", "img_length", " buf_count", "buflexize", "buflexmember", "buf64count", "buf64scale", "buf_ize", "img_ize", " buf_scale", "buf64range", "img_member", "img_size", "buf_scale", "buf_member", " buf_range", "buflexlength", "buf_range", "buf_length", "buflexsize", "buf64size"], "band": ["channel", "word", "device", "bridge", "card", "piece", "board", "port", "bands", "bin", "part", "service", "d", "batch", "config", "ground", "object", "back", "style", "child", "bd", "io", "connection", "letter", "bass", "plane", "weight", "product", "unit", "bus", "character", "force", "v", "output", "filter", "group", "layer", "plugin", "Band", "boot", "direction", "match", "page", "co", "component", "mode", "gb", "line", "flow", "ann", "brand", "block", "bind", "cap", "book", "cell", "disk", "work", "dr", "tag", "prop", "flag", "header", "bit"]}}
{"project": "FFmpeg", "commit_id": "ce551a3925a1cf9c7824e26a246b99b6773bda4b", "target": 1, "func": "static av_cold int seqvideo_decode_init(AVCodecContext *avctx)\n{\n    SeqVideoContext *seq = avctx->priv_data;\n    seq->avctx = avctx;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    seq->frame = av_frame_alloc();\n    if (!seq->frame)\n        return AVERROR(ENOMEM);\n    return 0;\n}", "idx": 14309, "substitutes": {"avctx": ["afcc", "afpkg", "afcv", "afconf", "ajcas", "ajcontext", "avcv", "avepkg", "akconfig", " avsrc", " avcv", "avcas", "avecu", "avectx", "afsrc", "afcu", "avsrc", "ajsrc", "avecv", "ajconf", "akpkg", "afconfig", " avcc", "afcontext", "ajctx", "ajcc", "avcu", "aveconfig", " avcontext", "avcc", "avcontext", "akctx", "avconf", "afctx", " avcas", "avecontext", "avconfig", " avconf", " avcu", "avpkg", "afcas", "akcontext"], "seq": ["zip", "sem", "vec", "pse", "context", "pkg", "cam", "slice", "queue", "qa", "uc", "config", "cc", "code", "shape", "sup", "ctrl", "lc", "req", "uu", "acc", "sequence", "cmp", "txt", "sq", "frame", "feat", "pub", "wave", "sec", "fi", "desc", "comp", "data", "parent", "feed", "iq", "Sequ", "cas", "sci", "iter", "q", "coll", "aux", "que", "fam", "cache", "ec", "sub", "sel", "sequ", "ctx", "xxx"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324, "substitutes": {"child": ["path", "root", "ch", "self", "queue", "build", "ca", "cow", "id", "code", "pc", "local", "current", "connection", "row", "h", "pool", "boy", "kid", "server", "job", "hel", "client", "lib", "anch", "leaf", "entry", "bit", "count", "parent", "add", "oy", "c", "block", "fe", "Child", "inner", "children", "ell", "create", "q", "baby", "cell", "exec", "cache", "fee", "sub", "lock", "cur", "bl", "round", "in", "node", "cl"], "sector_num": ["sectoringnum", "sector___coord", "sector_name", "sector_number", "section_coord", "section_span", "sectoringnumber", "sector_coord", "sector_span", "sector_info", "sector___number", "sectoringspan", "section_number", "sector___num", "section_name", "section_info", "section_num", "sectoringinfo", "sector___name"], "qiov": ["sqoyer", "quantiov", "quiov", "qoyer", "quoyer", "qrolet", "qiw", "Qiov", " qwy", "quimeters", "qunom", "quantoyer", " qoyer", "Qwy", "Qnom", "quicho", " qimeters", "quantimeters", "eqiw", "quantliv", "sqiw", "qliv", "quliv", "qicho", "sqiov", " qiw", "sqrolet", "eqrolet", "quwy", "eqiov", " qliv", "qnom", "eqoyer", " qnom", " qicho", "qwy", "Qicho", " qrolet", "qimeters"], "nb_sectors": ["nb_serctors", "nb_sixctors", "nb_vevers", "nb_spectors", "nb_segments", "nb_vegment", "nb_severs", "nb_veivers", "nb_sergments", "nb_pegments", "nb_segment", "nb_sixivers", "nb_cegments", "nb_spegments", "nb_seivers", "nb_pegment", "nb_peivers", "nb_serivers", "nb_sixvers", "nb_vectors", "nb_pections", "nb_servers", "nb_cectors", "nb_vegments", "nb_cections", "nb_speivers", "nb_sixgments", "nb_cegment", "nb_vections", "nb_pectors", "nb_spections", "nb_sections"], "flags": ["types", "args", "relations", "FLAG", "fd", "fs", "locks", "fields", "utils", "def", "forces", "grades", "caps", "fun", "fps", "settings", "details", "fx", "bytes", "weight", "status", "limits", "ants", "iffs", "interest", "files", "weights", "fixes", "feat", "groups", "options", "plugins", "sf", "features", "f", "lag", "mask", "bits", "fe", "Flags", "stats", "ags", "bugs", " Flags", "reports", "ops", "errors", "fee", "ints", "properties", "rules", "mods", "ils", "flag", "fc", "vals"], "cb": ["func", "xb", "bc", "zb", "ob", "cv", "pc", "bb", "fb", "obb", "ctrl", "orb", "cmp", "abc", "fp", "cgi", "fn", "cd", "CB", "rb", "pb", "wb", "sb", "b", "bf", "gb", "c", "function", "eb", "rob", "cf", "cod", "cp", "abb", "fc", "ctx", "callback"], "opaque": ["Opaque", "opatile", " ophole", "hopque", "opsacity", "opac", "opushole", "Opacent", "hopaque", "opsaque", "opsatile", " opacent", "opacity", "hopatile", " opac", "Ophole", "opsque", " opque", "opusacent", "opque", "ophole", " opacity", "opusac", "hopacity", "opusaque", "opacent", " opatile", "Opac"], "is_write": ["is_dirty", "is__write", "is_flush", "isPflow", "as_read", "is_create", " is_writer", "isPwritten", "is__sync", "is_written", "is_sync", "is_read", "isPwrite", " is_dirty", "isPcreate", "isableflush", " is_create", "isablesync", " is_flow", "is_writer", "isablewrite", "isableread", "as_flush", " is_written", "is_flow", "as_write", "is__read", "is__flush", "is_lock", "as_sync", " is_lock"], "co": ["che", "call", "aco", "mc", "po", "ca", "so", "coe", "flo", "cc", "pc", "code", "ob", "ko", "ctrl", "ci", "Co", "lc", "fo", "cmp", "con", "loc", "oe", "client", "o", "isco", "cost", "lo", "can", "oo", "ico", "cus", "mo", "c", "cca", "bo", "ce", "coll", "cell", "cache", "xc", "company", "go", "CO"], "acb": [" acB", "accbr", "acu", "acbe", "acbr", "ackn", "acn", "ackbb", " acd", "accu", " acc", "accn", "ackmb", "ackbe", "rcsb", "macp", "aitb", "accbase", "accp", "acbb", "rcf", " acfb", "ecfb", "ACbe", "aitbase", "ecf", "accbb", "ecp", "ocsb", "accl", "acc", "acbase", "achb", " acbb", "acd", "ecd", "acfb", "acp", "ocbb", "accf", "acsb", "macn", "ackb", "achbe", "ocl", "accc", "Acb", "accd", "ecsb", "acB", " acl", "accmb", "aitf", "acba", "ocb", "macfb", "ocf", "ecu", "ocp", "macd", "ocbr", " acba", " acn", "acmb", "macmb", "rcb", "Acf", "acl", "achn", "accba", "ACd", "ackl", "ACf", "ACbb", "AcB", " acf", "ACn", "acksb", "accb", "ACl", " acbe", "achba", "ecl", "acku", "ecb", "ecbase", "ecbr", "accsb", "macbb", "rcbb", "accbe", "accB", "ecc", " acp", "ACb", "acf", "Acp", "ecbb", "ecbe", "macb", "accfb", "aitfb"]}}
{"project": "FFmpeg", "commit_id": "7cc84d241ba6ef8e27e4d057176a4ad385ad3d59", "target": 1, "func": "static int standard_decode_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status = 0, index;\n\n\n\n    switch (v->s.pict_type)\n\n    {\n\n    case P_TYPE: status = decode_p_picture_secondary_header(v); break;\n\n    case B_TYPE: status = decode_b_picture_secondary_header(v); break;\n\n    case BI_TYPE:\n\n    case I_TYPE: break; //Nothing needed as it's done in the epilog\n\n    }\n\n    if (status < 0) return FRAME_SKIPED;\n\n\n\n    /* AC Syntax */\n\n    v->ac_table_level = decode012(gb);\n\n    if (v->s.pict_type == I_TYPE || v->s.pict_type == BI_TYPE)\n\n    {\n\n        v->ac2_table_level = decode012(gb);\n\n    }\n\n    /* DC Syntax */\n\n    index = decode012(gb);\n\n    v->luma_dc_vlc = &ff_msmp4_dc_luma_vlc[index];\n\n    v->chroma_dc_vlc = &ff_msmp4_dc_chroma_vlc[index];\n\n   \n\n    return 0;\n\n}\n", "idx": 14350, "substitutes": {"v": ["vers", "m", "rev", "vim", "t", "vv", "l", "i", "vp", "vin", "iv", "g", "conv", "ve", "vm", "vol", "server", "value", "vi", "gu", "tv", "av", "var", "w", "vert", "u", "dev", "p", "e", "s", "ver", "k", "b", "j", "n", "f", "c", "volt", "serv", "vg", "lv", "ov", "sv", "va", "nv", "uv", "vc", "V", "video", "ev", "vd", "vt", "vs"], "gb": ["ui", "gz", "bc", "pc", "bb", "gc", "gt", "g", "ci", "range", "pg", "Gb", "hub", "rg", "nb", "beta", "gy", "buffer", "gin", "tm", "mb", "gu", "buff", "storage", "gd", "lib", "gm", "gg", "gal", "bm", "rb", "sb", "usb", "b", "bf", "cfg", "gs", "pm", "gam", "gpu", "vg", "cb", "gom", "bg", "eb", "cod", "kb", "db", "GB", "vc", "gui", "vd", "ga", "git", "ctx", "phy", "gp"], "index": ["Index", "action", "condition", "bis", "part", "slice", "edit", "input", "sync", "config", "ini", "i", "level", "connection", "row", "weight", "section", "status", "x", "unit", "si", "update", "position", "key", "loc", "value", "output", "element", "document", "active", "ind", "version", "size", "office", "info", "match", "axis", "ix", "j", "length", "count", "f", "point", "address", "inc", "item", "url", "number", "type", "offset", "xxxx", "xxx", "pos", "num", "column", "len"]}}
{"project": "qemu", "commit_id": "0280b3eb7c0519b43452c05cf51f8777d9e38975", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356, "substitutes": {"oc": ["toc", "oid", "aco", "uc", "bc", "ob", "rc", "cc", "pc", "config", "object", "roc", "os", "cms", "og", "loc", "OC", "mot", "isc", "o", "oco", "ok", "mic", "co", "cus", "oo", "ocr", "c", "dc", "voc", "ac", "anc", "ucc", "org", "coll", "mac", "oci", "ec", "soc", "fc", "oca", "alloc"], "data": ["func", "record", "d", "config", "object", "da", "def", "os", "di", "module", "raw", "output", "meta", "o", "obj", "doc", "desc", "co", "parent", " dc", "Data", "DATA", "load", "ds", "dd", "cache", "mac"], "mc": ["m", "aco", "cm", "bc", "uc", "ca", "rc", "cc", "pc", "mp", "config", "container", "DC", "roc", "VC", "gc", "lc", "PC", "mn", "cms", "ml", "WC", "module", "di", "mm", "model", "loc", "mx", "mot", "conn", "chain", "meta", "col", "ms", "mr", "doc", "Mc", "mic", "mi", "tc", "co", "cus", "cli", "acl", "cfg", "ma", "spec", "c", "cca", "inc", "NC", "mk", "dc", "fc", "ac", "md", "cf", "coll", "disc", "mac", "ec", "cycle", "core", "cci", "MC"], "nc": ["uc", "bc", "enc", "rc", "cc", "pc", "unc", "cdn", "nn", "roc", "gc", "lc", "ci", "mn", "cn", "conn", "tc", "cca", "c", "inc", "dc", "jc", "ac", "anc", "ucc", "cb", "nt", "fc", "nv", "disc", "nec", "xc", "ec", "nic", "NC", "cci"], "hc": [" hvc", "shc", "hmpc", "Hrc", " hk", "hmc", "hk", "hrc", "shpc", "hmrc", "hvc", " hci", " hpc", "hercs", " hac", "hmci", "hcs", "phc", "phcs", "Hc", "Hci", "hac", "Hpc", " hrc", "herc", "shk", "hpc", "phk", " hcs", "phvc", "hci", "phac", "shac", "hervc", "phpc", "herpc"], "s390mc": ["s40mc", " s40mac", "s90cc", " s40pc", "s40pc", "S390pc", "s370mac", "s90tc", "s90MC", "s390nc", "s90mac", "s620pc", "s370pc", " s90pc", " s390cm", "S90mc", " s170MC", "s90pc", "S90cc", " s40mot", "S370pc", "s40tc", "s380cm", "S370mc", " s170c", "s390c", "s170cc", "S370cm", " s390c", "saferpc", "S390mac", " s90c", "s90mc", "s390mac", "s620mac", "S90tc", " s390pc", "s390tc", "s170MC", "safermc", "safernc", "s90cm", "s370c", "s090mc", "S90mac", "s370nc", "s380c", "s40cc", "s620mot", " s90mc", "S390tc", " s170cc", "s40mot", "s380pc", "s170c", "s090cc", " s390mot", "safercm", "s390pc", "S390cm", "s370mot", "S390mc", "S370nc", "s370cm", "S390cc", "s40c", "s090tc", "s490mc", " s170mc", "s390cm", " s390mac", "s380mc", "s40MC", "s490nc", "s370mc", "s490cm", "s90c", "s170mc", "S390nc", "s390mot", "s390cc", "s090mac", " s90cm", "s620mc", " s390MC", " s390cc", " s40mc", "s490pc", "s40mac", "s390MC"]}}
{"project": "FFmpeg", "commit_id": "7da9f4523159670d577a2808d4481e64008a8894", "target": 1, "func": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n", "idx": 14359, "substitutes": {"s": ["south", "ses", "m", "self", "service", "sync", "sg", "t", "fs", "i", "a", "sup", "caps", "g", "cs", "S", "h", "sets", "opens", "js", "si", "sq", "session", "server", "v", "ss", "client", "w", "u", "p", "data", "sb", "b", "f", "gb", "gs", "spec", "c", "ns", "serv", "stats", "ssl", "sv", "sl", "ops", "services", "events", "sa", "src", "space", "cur", "ctx", "sports", "aws"], "buf": ["func", "vec", "port", "font", "ff", "context", "uc", "bc", "queue", "fd", "array", "cv", "batch", "fb", "bd", "uf", "conv", "h", "pool", "buffer", "bag", "loc", "br", "buff", "output", "begin", "av", "brace", "img", "rb", "fi", "ver", "pb", "data", "b", "wb", "Buffer", "fab", "Buff", "f", "result", "ab", "feed", "cb", "cap", "cmd", "cf", "aux", "uv", "db", "src", "seq", "emb", "cur", "fac", "agg", "usr", "opt", "ctx", "comb"], "num_strips": ["num_wraples", "num_traples", "num_striples", "num_wrappers", "num_strappings", "num_triples", "num_straples", "num_traps", "num_wraps", "num_strappers", "num_strippped", "num_trippers", "num_triips", "num_straps", "num_stripples", "num_trapped", "num_strippers", "num_striips", "num_stripps", "num_wrappings", "num_trippings", "num_traips", "num_tripped", "num_stripped", "num_trips", "num_stripips", "num_strippings"], "data_size": ["data1speed", "dataacsize", "data_speed", "dataacsized", "data_capacity", "window_size", "data_SIZE", "data_sized", "data1sized", " data_SIZE", "window_num", " data_sized", "window_capacity", "data1SIZE", "window_SIZE", "dataacSIZE", " data_speed", "data_num", "dataacspeed", "data1size"]}}
{"project": "FFmpeg", "commit_id": "f907615f0813e8499f06a7eebccf1c63fce87c8e", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362, "substitutes": {"s": ["sys", "ses", "self", "m", "as", "sg", "fs", "rs", "cs", "hs", "si", "js", "sq", "v", "ps", "ss", "ms", "p", "e", "sb", "sf", "gs", "c", "parser", "xs", "sac", "sc", "sv", "services", "ds", "sa", "soc", "ls", "ks"], "pc": ["mc", "cam", "bc", "amp", "uc", "ca", "enc", "rc", "cc", "pac", "cz", "lc", "PC", "cs", "auc", "lp", "cms", "px", "cr", "pd", "oc", "p", "pb", "nc", "pa", "tc", "cus", "co", "ck", "gb", "arc", "c", "pm", "cca", "FC", "cu", "dc", "ac", "anc", "sc", "cp", "vc", "sa", "xc", "ec", "fc", "pic", "ctx"]}}
{"project": "FFmpeg", "commit_id": "a6d6b8a20072a5919d38258dd48cc612e2372f81", "target": 1, "func": "const AVOption *av_opt_next(void *obj, const AVOption *last)\n\n{\n\n    AVClass *class = *(AVClass**)obj;\n\n    if (!last && class->option[0].name) return class->option;\n\n    if (last && last[1].name)           return ++last;\n\n    return NULL;\n\n}\n", "idx": 14366, "substitutes": {"obj": ["ord", "alt", "self", "po", "ob", "art", "tmp", "jp", "val", "object", "ass", "act", "os", "nb", "init", "aut", "Obj", "o", "lib", "bot", "instance", "rb", "lt", "pl", "data", "ext", "b", "op", "inst", "j", "parent", "next", "nt", "clone", "src", "pos", "opt", "node", "cl"], "last": ["self", "after", "build", "sync", "bottom", "id", "code", "latest", "private", "object", "style", "child", "or", "eval", "final", "option", "later", "str", "pop", "nd", "full", "scope", "value", "closure", "size", "cost", "li", "j", "old", "est", "count", "list", "Last", "parent", "best", "global", "close", "next", "first", "end", "cle", "one", "cache", "empty", "cycle", "prev", "cl", "max", "worst", "node", "always"], "class": ["future", "Class", "self", "service", "config", "code", "private", "object", "latest", "style", "or", "current", "name", "ass", "classes", "section", "final", "option", "user", "new", "str", "scope", "opt", "ss", "lib", "super", "instance", "s", "b", "op", "parent", "line", "c", "cat", "first", "pe", "function", "CLASS", "rule", "out", "book", "cache", "css", "prev", "cl", "lass"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static void do_audio_out(AVFormatContext *s, OutputStream *ost,\n\n                         InputStream *ist, AVFrame *decoded_frame)\n\n{\n\n    uint8_t *buftmp;\n\n\n\n    int size_out, frame_bytes, resample_changed, ret;\n\n    AVCodecContext *enc = ost->st->codec;\n\n    AVCodecContext *dec = ist->st->codec;\n\n    int osize = av_get_bytes_per_sample(enc->sample_fmt);\n\n    int isize = av_get_bytes_per_sample(dec->sample_fmt);\n\n    uint8_t *buf = decoded_frame->data[0];\n\n    int size     = decoded_frame->nb_samples * dec->channels * isize;\n\n    int out_linesize = 0;\n\n    int buf_linesize = decoded_frame->linesize[0];\n\n\n\n    get_default_channel_layouts(ost, ist);\n\n\n\n    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples, &out_linesize) < 0) {\n\n        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n        exit_program(1);\n\n    }\n\n\n\n    if (audio_sync_method > 1                      ||\n\n        enc->channels       != dec->channels       ||\n\n        enc->channel_layout != dec->channel_layout ||\n\n        enc->sample_rate    != dec->sample_rate    ||\n\n        dec->sample_fmt     != enc->sample_fmt)\n\n        ost->audio_resample = 1;\n\n\n\n    resample_changed = ost->resample_sample_fmt  != dec->sample_fmt ||\n\n                       ost->resample_channels    != dec->channels   ||\n\n                       ost->resample_channel_layout != dec->channel_layout ||\n\n                       ost->resample_sample_rate != dec->sample_rate;\n\n\n\n    if ((ost->audio_resample && !ost->avr) || resample_changed) {\n\n        if (resample_changed) {\n\n            av_log(NULL, AV_LOG_INFO, \"Input stream #%d:%d frame changed from rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\" to rate:%d fmt:%s ch:%d chl:0x%\"PRIx64\"\\n\",\n\n                   ist->file_index, ist->st->index,\n\n                   ost->resample_sample_rate, av_get_sample_fmt_name(ost->resample_sample_fmt),\n\n                   ost->resample_channels, ost->resample_channel_layout,\n\n                   dec->sample_rate, av_get_sample_fmt_name(dec->sample_fmt),\n\n                   dec->channels, dec->channel_layout);\n\n            ost->resample_sample_fmt  = dec->sample_fmt;\n\n            ost->resample_channels    = dec->channels;\n\n            ost->resample_channel_layout = dec->channel_layout;\n\n            ost->resample_sample_rate = dec->sample_rate;\n\n            if (ost->avr)\n\n                avresample_close(ost->avr);\n\n        }\n\n        /* if audio_sync_method is >1 the resampler is needed for audio drift compensation */\n\n        if (audio_sync_method <= 1 &&\n\n            ost->resample_sample_fmt  == enc->sample_fmt &&\n\n            ost->resample_channels    == enc->channels   &&\n\n            ost->resample_channel_layout == enc->channel_layout &&\n\n            ost->resample_sample_rate == enc->sample_rate) {\n\n            ost->audio_resample = 0;\n\n        } else if (ost->audio_resample) {\n\n            if (!ost->avr) {\n\n                ost->avr = avresample_alloc_context();\n\n                if (!ost->avr) {\n\n                    av_log(NULL, AV_LOG_FATAL, \"Error allocating context for libavresample\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n\n\n            av_opt_set_int(ost->avr, \"in_channel_layout\",  dec->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"in_sample_fmt\",      dec->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"in_sample_rate\",     dec->sample_rate,    0);\n\n            av_opt_set_int(ost->avr, \"out_channel_layout\", enc->channel_layout, 0);\n\n            av_opt_set_int(ost->avr, \"out_sample_fmt\",     enc->sample_fmt,     0);\n\n            av_opt_set_int(ost->avr, \"out_sample_rate\",    enc->sample_rate,    0);\n\n            if (audio_sync_method > 1)\n\n                av_opt_set_int(ost->avr, \"force_resampling\", 1, 0);\n\n\n\n            /* if both the input and output formats are s16 or u8, use s16 as\n\n               the internal sample format */\n\n            if (av_get_bytes_per_sample(dec->sample_fmt) <= 2 &&\n\n                av_get_bytes_per_sample(enc->sample_fmt) <= 2) {\n\n                av_opt_set_int(ost->avr, \"internal_sample_fmt\", AV_SAMPLE_FMT_S16P, 0);\n\n            }\n\n\n\n            ret = avresample_open(ost->avr);\n\n            if (ret < 0) {\n\n                av_log(NULL, AV_LOG_FATAL, \"Error opening libavresample\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (audio_sync_method > 0) {\n\n        double delta = get_sync_ipts(ost, ist->last_dts) * enc->sample_rate - ost->sync_opts -\n\n                       av_fifo_size(ost->fifo) / (enc->channels * osize);\n\n        int idelta = delta * dec->sample_rate / enc->sample_rate;\n\n        int byte_delta = idelta * isize * dec->channels;\n\n\n\n        // FIXME resample delay\n\n        if (fabs(delta) > 50) {\n\n            if (ist->is_start || fabs(delta) > audio_drift_threshold*enc->sample_rate) {\n\n                if (byte_delta < 0) {\n\n                    byte_delta = FFMAX(byte_delta, -size);\n\n                    size += byte_delta;\n\n                    buf  -= byte_delta;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"discarding %d audio samples\\n\",\n\n                           -byte_delta / (isize * dec->channels));\n\n                    if (!size)\n\n                        return;\n\n                    ist->is_start = 0;\n\n                } else {\n\n                    av_fast_malloc(&async_buf, &allocated_async_buf_size,\n\n                                   byte_delta + size);\n\n                    if (!async_buf) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Out of memory in do_audio_out\\n\");\n\n                        exit_program(1);\n\n                    }\n\n\n\n                    if (alloc_audio_output_buf(dec, enc, decoded_frame->nb_samples + idelta, &out_linesize) < 0) {\n\n                        av_log(NULL, AV_LOG_FATAL, \"Error allocating audio buffer\\n\");\n\n                        exit_program(1);\n\n                    }\n\n                    ist->is_start = 0;\n\n\n\n                    generate_silence(async_buf, dec->sample_fmt, byte_delta);\n\n                    memcpy(async_buf + byte_delta, buf, size);\n\n                    buf = async_buf;\n\n                    size += byte_delta;\n\n                    buf_linesize = allocated_async_buf_size;\n\n                    av_log(NULL, AV_LOG_VERBOSE, \"adding %d audio samples of silence\\n\", idelta);\n\n                }\n\n            } else if (audio_sync_method > 1) {\n\n                int comp = av_clip(delta, -audio_sync_method, audio_sync_method);\n\n                av_log(NULL, AV_LOG_VERBOSE, \"compensating audio timestamp drift:%f compensation:%d in:%d\\n\",\n\n                       delta, comp, enc->sample_rate);\n\n//                fprintf(stderr, \"drift:%f len:%d opts:%\"PRId64\" ipts:%\"PRId64\" fifo:%d\\n\", delta, -1, ost->sync_opts, (int64_t)(get_sync_ipts(ost) * enc->sample_rate), av_fifo_size(ost->fifo)/(ost->st->codec->channels * 2));\n\n                avresample_set_compensation(ost->avr, comp, enc->sample_rate);\n\n            }\n\n        }\n\n    } else if (audio_sync_method == 0)\n\n        ost->sync_opts = lrintf(get_sync_ipts(ost, ist->last_dts) * enc->sample_rate) -\n\n                                av_fifo_size(ost->fifo) / (enc->channels * osize); // FIXME wrong\n\n\n\n    if (ost->audio_resample) {\n\n        buftmp = audio_buf;\n\n        size_out = avresample_convert(ost->avr, (void **)&buftmp,\n\n                                      allocated_audio_buf_size, out_linesize,\n\n                                      (void **)&buf, buf_linesize,\n\n                                      size / (dec->channels * isize));\n\n        size_out = size_out * enc->channels * osize;\n\n    } else {\n\n        buftmp = buf;\n\n        size_out = size;\n\n    }\n\n\n\n    /* now encode as many frames as possible */\n\n    if (!(enc->codec->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE)) {\n\n        /* output resampled raw samples */\n\n        if (av_fifo_realloc2(ost->fifo, av_fifo_size(ost->fifo) + size_out) < 0) {\n\n            av_log(NULL, AV_LOG_FATAL, \"av_fifo_realloc2() failed\\n\");\n\n            exit_program(1);\n\n        }\n\n        av_fifo_generic_write(ost->fifo, buftmp, size_out, NULL);\n\n\n\n        frame_bytes = enc->frame_size * osize * enc->channels;\n\n\n\n        while (av_fifo_size(ost->fifo) >= frame_bytes) {\n\n            av_fifo_generic_read(ost->fifo, audio_buf, frame_bytes, NULL);\n\n            encode_audio_frame(s, ost, audio_buf, frame_bytes);\n\n        }\n\n    } else {\n\n        encode_audio_frame(s, ost, buftmp, size_out);\n\n    }\n\n}\n", "idx": 14372, "substitutes": {"s": ["acs", "sys", "ses", "d", "a", "g", "cs", "h", "os", "sq", "ss", "o", "w", "oc", "e", "sec", "sf", "sb", "f", "spec", "c", "ac", "sac", "sc", "sv", "lex", "soc"], "ost": ["word", "sta", "\u00f3", "rod", "oh", "art", "roc", "sth", "nd", "loc", "obj", "ods", "ST", "old", "ocr", "orest", "rost", "od", "ot", "st", "oster", "osta", "rss", "ott", "oss", "ld", "oe", "mot", "irst", "kt", "omp", "inst", "oy", "ood", "omm", "ast", "host", "oint", "oper", "oid", "osi", "iol", "so", "\u0435", "os", "tt", "o", "tto", "ad", "obs", "http", "est", "opp", "ont", "osc", "nt", "rob", "om", "hop", "pos", "odi", "post", "oder", "ord", "ob", "ust", "ud", "og", "ober", "isc", "OST", "oc", "not", "op", "org", "src", "rest", "wo", "et", "opt"], "ist": ["ess", "ilst", "isu", "ists", "osi", "sta", "ft", "ista", "edit", "adder", "dist", "art", "ia", "pt", "aint", "asi", "pit", "sth", "std", "erd", "xt", "post", "ace", "nd", "pect", "ld", "ict", "iste", "mot", "irst", "set", "alist", "ad", "ind", "ctx", "kt", "IST", "dit", "inst", "est", "ont", "wp", "isd", "isi", "ette", "is", "ht", "nt", "ast", "ism", "ds", "dd", "od", "imet", "src", "idd", "dr", "rest", "st", "et", "wd", "irc"], "decoded_frame": ["decrypted_stream", "decaned_Frame", "decodedingsource", "decoded_source", "decodedingFrame", "decanced_frame", "decadedingdef", "decadedinggame", "decodedingframe", "decoded_Frame", "decodedadframe", "decoded_element", "decaded_game", "decrypted_frames", "decoded_frames", "decodedingfr", "decaded_frame", "decodedingscene", "decodedadframes", "decrypted_image", "decoded_stream", "decadedingframe", "decodedinggame", "decadedingscene", "decodedadelement", "decoded_game", "decaded_scene", "decodedingdef", "decodedJframe", "decoded_image", "decrypted_source", "decodedadcoll", "decrypted_frame", "decaded_def", "decoded_fr", "decoded_sample", "decaned_sample", "decoded_coll", "decanced_element", "decodedJfr", "decodedJFrame", "decodedJsource", "decanced_coll", "decoded_def", "decaned_step", "decoded_scene", "decrypted_fr", "decrypted_Frame", "decanced_frames", "decoded_step", "decaned_frame"], "buftmp": ["buktamp", "bufdamp", "buftok", "buffok", "bufdok", "buftip", "puffamp", "buktmp", "puftip", "bufdip", "puffip", "bufdmp", "puftamp", "puftok", "buffip", "buktok", "puftmp", "puffmp", "buftamp", "puffok", "buffmp", "buffamp", "buktip"], "size_out": ["size_output", " size_in", " size_output", "size_diff", " size_diff", "size_in"], "frame_bytes": ["frames_seq", "frame6bits", "frames_base", "frame6base", "frames_bits", "frame_seq", "frame6seq", "frame6bytes", "frame_base", "frame_bits", "frames_bytes"], "resample_changed": ["resamp_changed", "resanceJadded", "resance_changing", "resample__added", "resampleJadded", "resample__changed", "rescale_changes", "rescale_updated", "resplay_changed", "resampleJchanged", "resampleJchange", "resampleJchanging", "resplay_change", "resamp_updated", "resample_edited", "resamp_edited", "resample_change", "resplay_changes", "resample_error", "resanceJchange", "rescale_modified", "resance_changed", "resample_modified", "resplay_error", "resample__changing", "resamp_change", "resance_added", "resance_change", "resample_changing", "rescale_changed", "resanceJchanged", "resample_updated", "resanceJchanging", "resample_added", "resample_changes", "resample__change"], "ret": ["alt", "capt", "rc", "val", "orig", "msg", "def", "fun", "status", "flags", "mem", "temp", "info", "success", "Ret", "result", "nt", "resp", "empty", "RET", "seq", "res", "reg", "no", "flag"], "enc": ["vec", "env", "sys", "en", "ch", "uc", "bc", "cv", "rc", "unc", "code", "eu", "iv", "bn", "ew", "oa", "lc", "cy", "con", "loc", "ent", "rh", "conn", "de", "ant", "adr", "rec", "Enc", "equ", "oc", "img", "ang", "ens", "nc", "desc", "dev", "eng", "ext", "sec", "cel", "oy", "c", "inc", "cat", "dc", "ac", "anc", "cb", "nt", "cod", "sl", "nec", "exec", "od", "vc", "ec", "decl", "emb", "ENC", "ou", "cur", "sel", "fc", "et", "oder", "anon"], "buf": ["vec", "uc", "bc", "queue", "cv", "tmp", "rc", "orig", "uf", "buffer", "fp", "br", "buff", "wave", "img", "rb", "data", "box", "block", "cb", "cmd", "cf", "aux", "src", "seq", "num", "pad", "ctx", "alloc"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376, "substitutes": {"var": ["shape", "x", "str", "raw", "star", "loc", "opt", "br", "vert", "dev", "ver", "base", "reader", "spec", "c", "cat", "sv", "cp", "dr", "func", "card", "self", "slice", "array", "rc", "bb", "rar", "sr", "error", "fr", "rank", "adr", "parse", "pack", "data", "cover", "arr", "r", "host", "mir", "mac", "stack", "ar", "oper", "rr", "vr", "gr", "variable", "null", "buffer", "valid", "war", "arch", "comp", "ars", "Var", "feature", "gar", "par", "type", "cf", "man", "rt", "ser", "cur", "usr", "ph", "prev", "err", "as", "tmp", "orig", "endor", "name", "er", "sk", "this", "vari", "mod", "vard", "v", "av", "bar", "col", "wave", "p", "keep", "car", "op", "parent", "pair", "vc", "pad", "vs", "y", "start"], "shiftop": ["shiftbit", "pullOP", "sizeOP", "hiftOP", " shiftops", "pullbit", "shiftOP", "pullOp", " shiftOp", "sizeops", " shiftbit", "sizeop", "hiftops", "hiftbit", "sizeOp", "hiftOp", " shiftOP", "pullop", "hiftop", "shiftops", "shiftOp"], "shift": ["ice", "just", "dist", "shape", "sample", "kick", "align", "use", "pop", "hack", "append", "force", "count", "skip", "end", "offset", "reverse", "transform", "save", "half", "off", "copy", "order", "cart", "slice", "hide", "seed", "ctr", "sup", "pick", "front", "lower", "rank", "parse", "pack", "length", "ip", "drop", "cap", "ress", "stack", "space", "sort", "small", "carry", "shr", "adjust", "square", "slave", "hift", "mix", "ix", "address", "shock", "close", "Shift", " shifts", "center", "sh", "field", "power", "pos", "push", "range", "gap", "send", "effect", "crop", "sq", "patch", "set", "cost", "size", "sign", "p", "keep", "move", "tip", "pair", "pull", "margin", "scale", "pad", "sleep", "start"], "flags": ["types", "args", "kind", "FLAG", "nl", "needs", "fl", "fd", "fs", "locks", "fields", "utils", "rets", "caps", "fun", "weight", "settings", "ifts", "ants", "opens", "limits", " flag", "linux", "styles", "files", "weights", "ss", "lists", "feat", "strings", "reads", "wave", "cost", "groups", "alls", "options", "plugins", "fi", "allows", "includes", "vs", "sf", "features", "lines", "mask", "f", "lf", "lag", "bits", "lins", "yrs", "Flags", " shifts", "stats", "atts", "ags", "bugs", "results", "ops", "links", "orts", "states", "ips", "rules", "requires", "mods", "fts", "ils", "flag", "comments", "len", "books", "vals"]}}
{"project": "qemu", "commit_id": "c508277335e3b6b20cf18e6ea3a35c1fa835c64a", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379, "substitutes": {"s": ["args", "south", "sys", "ses", "m", "parts", "service", "t", "sync", "in", "ins", "your", "bs", "rs", "sym", "a", "cs", "qs", "S", "settings", "sites", "new", "details", "its", "status", "sets", "js", "es", "si", "sq", "session", "ps", "ss", "o", "strings", "u", "params", "p", "e", "plugins", "data", "http", "features", "tests", "gs", "less", "state", "c", "ns", "xs", "is", "stats", "ssl", "states", "services", "ds", "ops", "ls", "ts", "us", "sports", "ks"], "i": ["hi", "qi", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "l", "ini", "gi", "a", "io", "oi", "api", "mu", "ci", "lc", "h", "data", "di", "x", "si", "ie", "init", "ii", "v", "uri", "o", "yi", "u", "z", "p", "e", "info", "fi", "mi", "li", "k", "b", "ix", "abi", "j", "length", "phi", "f", "multi", "ti", "n", "ip", "c", "eni", "pi", "bi", "ri", "zi", "y", "in", "index"]}}
{"project": "qemu", "commit_id": "a9cf98d939c4f6539fad7e7d812ea16d96ba3dc9", "target": 0, "func": "static void arm_timer_recalibrate(arm_timer_state *s, int reload)\n\n{\n\n    uint32_t limit;\n\n\n\n    if ((s->control & TIMER_CTRL_PERIODIC) == 0) {\n\n        /* Free running.  */\n\n        if (s->control & TIMER_CTRL_32BIT)\n\n            limit = 0xffffffff;\n\n        else\n\n            limit = 0xffff;\n\n    } else {\n\n          /* Periodic.  */\n\n          limit = s->limit;\n\n    }\n\n    ptimer_set_limit(s->timer, limit, reload);\n\n}\n", "idx": 14387, "substitutes": {"s": ["sys", "ses", "self", "service", "sync", "t", "sg", "input", "fs", "l", "i", "sym", "rs", "a", "cs", "qs", "S", "settings", "new", "os", "status", "sets", "js", "si", "scope", "es", "session", "ps", "ss", "conf", "o", "request", "w", "p", "e", "options", "info", "plugins", "http", "sf", "sb", "f", "stat", "gs", "spec", "state", "c", "serv", "ns", "xs", "is", "stats", "ssl", "side", "sl", "services", "ds", "sie", "su", "ls", "ts", "aws"], "reload": ["refill", "Reloads", "foreloads", "Refill", "recharge", "Reloader", "foreloader", "breloader", "brefill", "REplay", "refplay", "refload", "replay", "breload", "reloads", "refloader", "refcharge", "rowloader", "rowcharge", "REload", "Reload", "forefill", "REloader", "rowplay", "REcharge", "rowload", "foreload", "breloads", "reloader"], "limit": ["release", "it", "priority", "repeat", "location", "ure", "ignore", "config", "l", "i", "level", "inf", "io", "large", "limited", "source", "use", "limits", "unit", "status", "capacity", "ite", "position", "buffer", "model", "force", "filter", "view", "size", "version", "info", "match", "page", "base", "length", "count", "mode", "line", "skip", "control", "ip", "url", "timeout", "route", "block", "pin", "offset", "target", "Limit", "iter", "cache", "lock", "pos", "len", "lim", "index", "start"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_down_char(void)\n\n{\n\n    if (term_hist_entry == TERM_MAX_CMDS - 1 || term_hist_entry == -1)\n\n\treturn;\n\n    if (term_history[++term_hist_entry] != NULL) {\n\n\tpstrcpy(term_cmd_buf, sizeof(term_cmd_buf),\n\n                term_history[term_hist_entry]);\n\n    } else {\n\n\tterm_hist_entry = -1;\n\n    }\n\n    term_cmd_buf_index = term_cmd_buf_size = strlen(term_cmd_buf);\n\n}\n", "idx": 14388, "substitutes": {"term_hist_entry": ["term_hist_count", "term_histprelast", "term_histpentry", "term_hist_last", "term_histpindex", "term_history_ry", "term_hist_part", "term_histpreEntry", "term_histprepart", "term_history_part", "term_hist23element", "term_history_count", "term_hist_Entry", "term_history_enter", "term_histpcount", "term_history_index", "term_histpreentry", "term_hist23ry", "term_histxentry", "term_hist_enter", "term_history_entry", "term_history_Entry", "term_history_element", "term_hist_index", "term_histxpart", "term_hist23entry", "term_hist_element", "term_history_last", "term_hist_ry", "term_hist23index", "term_histxenter"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "int kvm_log_start(target_phys_addr_t phys_addr, ram_addr_t size)\n\n{\n\n        return kvm_dirty_pages_log_change(phys_addr, size,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES,\n\n                                          KVM_MEM_LOG_DIRTY_PAGES);\n\n}\n", "idx": 14393, "substitutes": {"phys_addr": ["physxaddress", "physxace", "mem_addr", "phys_ace", "phys__address", "phys__ord", "mem_address", " phys_ace", "phys__addr", "phys__coord", "phys_address", "phys_coord", "mem_ord", " phys_loc", "physxloc", " phys_address", "phys_ord", "phys_loc", "mem_coord", "physxaddr"], "size": ["args", "small", "sized", "shape", "name", "g", "send", "Size", "bytes", "use", "capacity", "unit", "si", "sum", "storage", " sizes", "password", "ize", "six", "sec", "eng", "base", "length", "count", "speed", "address", "block", "timeout", "SIZE", "esc", "offset", "security", "scale", "empty", "fee", "iz", "len", "alloc"]}}
{"project": "qemu", "commit_id": "9307c4c1d93939db9b04117b654253af5113dc21", "target": 0, "func": "static void do_log(int argc, const char **argv)\n\n{\n\n    int mask;\n\n    \n\n    if (argc != 2)\n\n        goto help;\n\n    if (!strcmp(argv[1], \"none\")) {\n\n        mask = 0;\n\n    } else {\n\n        mask = cpu_str_to_log_mask(argv[1]);\n\n        if (!mask) {\n\n        help:\n\n            help_cmd(argv[0]);\n\n            return;\n\n        }\n\n    }\n\n    cpu_set_log(mask);\n\n}\n", "idx": 14413, "substitutes": {"argc": ["argsc", "Argrc", "Argc", "Argsc", "argrc", "tagc", "igxc", " argrc", "Argpc", " argxc", "igc", "tagsc", "agpc", "argpc", "iglc", "igrc", "Argxc", "Arglc", " arglc", "tagfc", "agfc", "argxc", "argfc", "arglc", "agsc", "Argfc", "agc", "tagpc"], "argv": ["argsc", "argsf", "Argv", "Argc", "argval", "opc", " argp", "tagc", "Argf", "opv", "tagv", "Argp", "arval", "arf", "tagp", "tagsv", "argsv", "opsv", "argsp", " argval", "opp", "arp", "argp", "argf", "argssv", "arv", " argf", "argsval", " argsv"], "mask": ["zip", "bug", "map", "qa", "array", "allow", "id", "code", "unk", "style", "pixel", "weight", "image", "sk", "mark", "hack", "ace", "sum", "comment", "key", "like", "patch", "Mask", "scan", "fix", "filter", "check", "group", "clean", "cost", "sign", "info", "match", "data", "ck", "ask", "count", "result", "parent", "cover", "black", "block", "iq", "offset", "broad", "scale", "ack", "cache", "work", "lock", "ban", "delay", "flag", "strip", "bit", "cloud"]}}
{"project": "FFmpeg", "commit_id": "1a3ed056c523b4670e192301be15dbc521ec8353", "target": 0, "func": "static int hls_decode_entry(AVCodecContext *avctxt, void *isFilterThread)\n\n{\n\n    HEVCContext *s  = avctxt->priv_data;\n\n    int ctb_size    = 1 << s->sps->log2_ctb_size;\n\n    int more_data   = 1;\n\n    int x_ctb       = 0;\n\n    int y_ctb       = 0;\n\n    int ctb_addr_ts = s->pps->ctb_addr_rs_to_ts[s->sh.slice_ctb_addr_rs];\n\n\n\n    if (!ctb_addr_ts && s->sh.dependent_slice_segment_flag) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Impossible initial tile.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (s->sh.dependent_slice_segment_flag) {\n\n        int prev_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts - 1];\n\n        if (s->tab_slice_address[prev_rs] == -1) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"Previous slice segment missing\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    while (more_data && ctb_addr_ts < s->sps->ctb_size) {\n\n        int ctb_addr_rs = s->pps->ctb_addr_ts_to_rs[ctb_addr_ts];\n\n\n\n        x_ctb = (ctb_addr_rs % ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        y_ctb = (ctb_addr_rs / ((s->sps->width + ctb_size - 1) >> s->sps->log2_ctb_size)) << s->sps->log2_ctb_size;\n\n        hls_decode_neighbour(s, x_ctb, y_ctb, ctb_addr_ts);\n\n\n\n        ff_hevc_cabac_init(s, ctb_addr_ts);\n\n\n\n        hls_sao_param(s, x_ctb >> s->sps->log2_ctb_size, y_ctb >> s->sps->log2_ctb_size);\n\n\n\n        s->deblock[ctb_addr_rs].beta_offset = s->sh.beta_offset;\n\n        s->deblock[ctb_addr_rs].tc_offset   = s->sh.tc_offset;\n\n        s->filter_slice_edges[ctb_addr_rs]  = s->sh.slice_loop_filter_across_slices_enabled_flag;\n\n\n\n        more_data = hls_coding_quadtree(s, x_ctb, y_ctb, s->sps->log2_ctb_size, 0);\n\n        if (more_data < 0) {\n\n            s->tab_slice_address[ctb_addr_rs] = -1;\n\n            return more_data;\n\n        }\n\n\n\n\n\n        ctb_addr_ts++;\n\n        ff_hevc_save_states(s, ctb_addr_ts);\n\n        ff_hevc_hls_filters(s, x_ctb, y_ctb, ctb_size);\n\n    }\n\n\n\n    if (x_ctb + ctb_size >= s->sps->width &&\n\n        y_ctb + ctb_size >= s->sps->height)\n\n        ff_hevc_hls_filter(s, x_ctb, y_ctb);\n\n\n\n    return ctb_addr_ts;\n\n}\n", "idx": 14442, "substitutes": {"avctxt": ["AVnttxt", " avctkt", "avsecext", "avctXT", "avftxt", "avCTkt", "avntert", "avptxt", "avctert", "AVntxt", "avcxt", " avftXT", "AVctext", "avptkt", " avcttxt", "AVcttxt", "avcttxt", "avsecert", " avftxt", "avCTXT", "avcext", "AVctert", "avpttxt", "AVctxt", "AVntert", "avCTxt", "avCTtxt", "AVntext", " avfttxt", " avftkt", "avcert", "avfttxt", "avnttxt", "avftkt", " avctXT", "avsectxt", "avsecxt", "avctext", "avntext", "avftXT", "avctkt", "avntxt", "avptXT"], "isFilterThread": ["isCallThread", "isFilterLock", "isCallLock", "asMainthread", "asMainLock", "isFilterPool", "asFilterLock", "asMainThread", "asFilterPool", "isFilterthread", "isMainPool", "asMainPool", "isCatThread", "isMainLock", "isCatPool", "asFilterthread", "isCatthread", "isCallthread", "isMainthread", "isMainThread", "isCallPool", "isCatLock", "asFilterThread"], "s": ["i", "qs", "words", "js", "si", "server", "ps", "groups", "lines", "tests", "spec", "c", "is", "sc", "sv", "sl", "states", "ing", "aws", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "ches", "sup", "g", "cs", "es", "full", "session", "storage", "w", "an", "data", "sf", "b", "ns", "ops", "r", "ks", "secondary", "sys", "parts", "service", "details", "os", "sets", "opens", "o", "e", "sec", "site", "http", "sb", "f", "less", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "sites", "S", "settings", "uns", "sq", "conf", "ss", "request", "p", "se", "plugins", "k", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us"], "ctb_addr_ts": ["ctb_dr_ns", "ctb_addr_ns", "ctb_vr_rs", "ctb_addr_ents", "ctb_addr2ts", "ctb_addrPcs", "ctb_ord_ps", "ctb_addr6tt", "ctb_dr_ats", "ctb_addrMrs", "ctb_addr6rs", "ctb_addr__ts", "ctb_addr2rs", "ctb_vr6ts", "ctb_addrJcs", "ctb_dr_Ts", "ctb_addr__TS", "ctb_dr_rs", "ctb_addr6ss", "ctb_addr__tt", "ctb_ord_ms", "ctb_addr_ms", "ctb_ord_ents", "ctb_addrPrs", "ctb_dr_tt", "ctb_addr_ps", "ctb_addr_ss", "ctb_addr35TS", "ctb_addrJms", "ctb_ord_fs", "ctb_addr2tt", "ctb_addrPms", "ctb_addr_tt", "ctb_dr_TS", "ctb_addrMts", "ctb_addr2TS", "ctb_vr6ss", "ctb_addr_fs", "ctb_addr35ents", "ctb_ord_cs", "ctb_addrJrs", "ctb_ord_rs", "ctb_addr_Ts", "ctb_addrJts", "ctb_dr_ts", "ctb_addr_cs", "ctb_vr_ss", "ctb_addr6ts", "ctb_addr35ts", "ctb_vr_ts", "ctb_addr_TS", "ctb_vr_tt", "ctb_addr_rs", "ctb_addrPts", "ctb_ord_ts", "ctb_addr_ats", "ctb_addrMns", "ctb_addr__rs", "ctb_vr6rs", "ctb_addr35ps", "ctb_addrMTS", "ctb_ord_TS", "ctb_vr6tt"]}}
{"project": "FFmpeg", "commit_id": "8155233413540c63e53a620ff5734fb4b0635611", "target": 1, "func": "static int decode_header(MPADecodeContext *s, UINT32 header)\n\n{\n\n    int sample_rate, frame_size, mpeg25, padding;\n\n    int sample_rate_index, bitrate_index;\n\n    if (header & (1<<20)) {\n\n        s->lsf = (header & (1<<19)) ? 0 : 1;\n\n        mpeg25 = 0;\n\n    } else {\n\n        s->lsf = 1;\n\n        mpeg25 = 1;\n\n    }\n\n    \n\n    s->layer = 4 - ((header >> 17) & 3);\n\n    /* extract frequency */\n\n    sample_rate_index = (header >> 10) & 3;\n\n    sample_rate = mpa_freq_tab[sample_rate_index] >> (s->lsf + mpeg25);\n\n    if (sample_rate == 0)\n\n        return 1;\n\n    sample_rate_index += 3 * (s->lsf + mpeg25);\n\n    s->sample_rate_index = sample_rate_index;\n\n    s->error_protection = ((header >> 16) & 1) ^ 1;\n\n\n\n    bitrate_index = (header >> 12) & 0xf;\n\n    padding = (header >> 9) & 1;\n\n    //extension = (header >> 8) & 1;\n\n    s->mode = (header >> 6) & 3;\n\n    s->mode_ext = (header >> 4) & 3;\n\n    //copyright = (header >> 3) & 1;\n\n    //original = (header >> 2) & 1;\n\n    //emphasis = header & 3;\n\n\n\n    if (s->mode == MPA_MONO)\n\n        s->nb_channels = 1;\n\n    else\n\n        s->nb_channels = 2;\n\n    \n\n    if (bitrate_index != 0) {\n\n        frame_size = mpa_bitrate_tab[s->lsf][s->layer - 1][bitrate_index];\n\n        s->bit_rate = frame_size * 1000;\n\n        switch(s->layer) {\n\n        case 1:\n\n            frame_size = (frame_size * 12000) / sample_rate;\n\n            frame_size = (frame_size + padding) * 4;\n\n            break;\n\n        case 2:\n\n            frame_size = (frame_size * 144000) / sample_rate;\n\n            frame_size += padding;\n\n            break;\n\n        default:\n\n        case 3:\n\n            frame_size = (frame_size * 144000) / (sample_rate << s->lsf);\n\n            frame_size += padding;\n\n            break;\n\n        }\n\n        s->frame_size = frame_size;\n\n    } else {\n\n        /* if no frame size computed, signal it */\n\n        if (!s->free_format_frame_size)\n\n            return 1;\n\n        /* free format: compute bitrate and real frame size from the\n\n           frame size we extracted by reading the bitstream */\n\n        s->frame_size = s->free_format_frame_size;\n\n        switch(s->layer) {\n\n        case 1:\n\n            s->frame_size += padding  * 4;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 48000;\n\n            break;\n\n        case 2:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * sample_rate) / 144000;\n\n            break;\n\n        default:\n\n        case 3:\n\n            s->frame_size += padding;\n\n            s->bit_rate = (s->frame_size * (sample_rate << s->lsf)) / 144000;\n\n            break;\n\n        }\n\n    }\n\n    s->sample_rate = sample_rate;\n\n    \n\n#if defined(DEBUG)\n\n    printf(\"layer%d, %d Hz, %d kbits/s, \",\n\n           s->layer, s->sample_rate, s->bit_rate);\n\n    if (s->nb_channels == 2) {\n\n        if (s->layer == 3) {\n\n            if (s->mode_ext & MODE_EXT_MS_STEREO)\n\n                printf(\"ms-\");\n\n            if (s->mode_ext & MODE_EXT_I_STEREO)\n\n                printf(\"i-\");\n\n        }\n\n        printf(\"stereo\");\n\n    } else {\n\n        printf(\"mono\");\n\n    }\n\n    printf(\"\\n\");\n\n#endif\n\n    return 0;\n\n}\n", "idx": 14459, "substitutes": {"s": ["ings", "native", "i", "rs", "qs", "h", "new", "status", "js", "si", "server", "ps", "spec", "c", "is", "states", "aws", "m", "self", "bis", "d", "sync", "sg", "t", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "client", "b", "ns", "ops", "r", "sports", "ks", "sys", "parts", "service", "details", "hs", "os", "sets", "o", "e", "obs", "http", "site", "sb", "features", "f", "services", "ls", "comments", "ses", "bs", "l", "rates", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "ts", "us"], "header": ["bridge", "prot", "image", "h", "event", "status", "gender", "server", "frame", "filter", "handler", "ver", "driver", "reader", "liner", "line", "magic", "c", "counter", "offset", "text", "iter", "dr", "num", "message", "head", "numbered", "border", "writer", "key", "version", "her", "data", "page", "cover", "number", "pper", "inner", "body", "cookie", "headers", "queue", "config", "source", "null", "buffer", "master", "document", "layer", "metadata", "e", "feature", "block", "first", "hidden", "prev", "channel", "date", "input", "response", "code", "stream", "player", "er", "later", "hash", "v", "meta", "request", "size", "definition", "outer", "ssl", "forward", "content", "Header"], "sample_rate": ["sampleAcprice", "scale_score", "sample_speed", "sample_grade", "sample64rate", "scale_grade", "sample_rates", "Sample_speed", " sample2rate", " sample_rates", "sample2rate", "sample_width", "sample_rated", " sample_width", "sampleAccharge", "Sampleaccharge", "sample64rating", "Sample_term", " sample_rating", "Sample_charge", "sampleacprice", "samplealrate", " sample2rating", " sample_name", " sample2number", "samplealrates", "sample64name", "sample2number", "sample_number", "Sampleacrate", "Sample_size", " sample_price", "sample_charge", "scale_size", "samplealprice", "sample2rating", "sample_name", "sample_rating", "Sample_rate", "sample_score", "sampleacspeed", "sampleAcspeed", "sample2width", "scale_rate", " sample_rated", "sample64size", "sample64number", "sample_price", "sampleacrate", "sample64width", "Sampleacspeed", "samplealrated", "sampleAcrate", "sample_term", "sample_size", "Sample_price", "sample64grade", " sample2width", "sampleaccharge", " sample_number", "Sampleacprice", " sample_size", "sample64score"], "frame_size": ["byte64offset", "frame_member", " frame_strength", " frame_gap", "byte_size", "byte64sized", "view_size", "frame64size", "frame_rate", "framealoffset", "frame_Size", "frame_color", "frame64style", " frame_shape", "frame_content", "sample_ize", "frame64ize", "sequence_fee", "frame_memory", "frame64scale", "game_color", "frame_style", "sequence_size", "module64content", "fram_rate", "framexsize", "byte_memory", "frameacrate", "frameacmemory", "framexsized", "frameacscale", "frame_cost", "frame_body", "game_size", "view_sized", "byte64memory", "frame_fee", "sequence_length", "frame67size", " frame_use", " frame_rate", "byte64size", "module_content", "module_size", "game_term", "game_function", "slice_source", "frame64sized", "frame_sized", "frame_scale", "frame64content", " frame_offset", " frame_content", "frame_offset", "frameingoffset", "frameingsize", "module64source", "framealmember", " frame_member", "frame_source", "frame67scale", "framexscale", "frameacoffset", "framealsize", "view_strength", "frame_strength", "frame_function", "byte_offset", "fram_body", "module64size", "frame67function", "view_Size", "byte_sized", " frame_scale", "module_source", "module64style", "frame64source", " frame_cost", "frame_gap", "frameacsize", "frame64offset", "module_style", "game_sized", "sample_strength", "frameacsized", " frame_ize", "frame_length", "fram_size", "game_scale", "framexgap", " frame_sized", "frame_storage", "frame_address", "frameacfunction", "slice_size", "sample_size", "frame_use", "frameingmemory", "frameacshape", "frame_ize", " frame_address", "frame64memory", "slice_storage", "frameingsized", "frame_term", "frame67sized", "frameaccost", "frame_shape"], "mpeg25": ["mp25", "ogg125", "wav23", "ogg75", "video125", "gg125", "mp35", "ogg15", "camera35", "mpeg24", "peg35", "ogg25", "gg25", "mp50", "peg20", "mp24", "mpeg50", "mpeg23", "peg23", "peg125", "camera25", "camera50", "peg15", "mpeg75", "gg75", "peg50", "peg25", "mp75", "camera20", "mpeg125", "wav125", "mp23", "mpeg15", "peg24", "video25", "wav24", "wav25", "video75", "mpeg35", "mp125", "wav75", "peg75", "mpeg20", "mp20", "video50", "gg15"], "padding": ["trace", "pixel", "large", "gap", "align", "border", "buffer", "pressure", "position", "performance", "crop", "binding", "value", "alpha", "np", "password", "adding", "size", "layer", "p", "protection", "temp", "pointer", "packing", "length", "radius", "skip", "ping", "ip", "parser", "timeout", "tracking", "margin", "offset", "scale", "wrapper", "duration", "power", "prefix", "space", "ppa", "pad", "height"], "sample_rate_index": ["sample_wave_length", "sample_size_slice", "sample_rate_pointer", "sample_size_pointer", "sample_status_offset", "sample_rate2slice", "sample_rate_offset", "sample_rate_inc", "sample_size_size", "sample_rate_length", "sample_rate2ini", "sample_size_index", "sample_scale_index", "sample_status_number", "sample_status_index", "sample_wave_ini", "sample_rate_point", "sample_size_position", "sample_rate2position", "sample_rate2size", "sample_size_point", "sample_rate_ind", "sample_status_position", "sample_rate_number", "sample_rate_ini", "sample_wave_ind", "sample_rate2index", "sample_rate_position", "sample_scale_point", "sample_rate2pointer", "sample_rate_x", "sample_rate_slice", "sample_size_ini", "sample_wave_index", "sample_rate_size", "sample_scale_length", "sample_rate2point", "sample_scale_position"], "bitrate_index": ["bitration_index", "bitration_number", "bitrating_index", "bitrate_ind", "bitrate__field", "bitrating_field", "bitrating_Index", "bitrate_field", "bitrate__index", "bitration_ind", "bitrate__left", "bitrate_left", "bitrate_number", "bitration_size", "bitrate__Index", "bitrate_size", "bitrate_Index", "bitrate_address", "bitrating_left"]}}
{"project": "FFmpeg", "commit_id": "2d66fc543b01995d6146fc132a778d3e722ca665", "target": 1, "func": "static av_cold int init(AVFilterContext *ctx, const char *args)\n\n{\n\n    GradFunContext *gf = ctx->priv;\n\n    float thresh = 1.2;\n\n    int radius = 16;\n\n\n\n    if (args)\n\n        sscanf(args, \"%f:%d\", &thresh, &radius);\n\n\n\n    thresh = av_clipf(thresh, 0.51, 255);\n\n    gf->thresh = (1 << 15) / thresh;\n\n    gf->radius = av_clip((radius + 1) & ~1, 4, 32);\n\n\n\n    gf->blur_line = ff_gradfun_blur_line_c;\n\n    gf->filter_line = ff_gradfun_filter_line_c;\n\n\n\n    if (ARCH_X86)\n\n        ff_gradfun_init_x86(gf);\n\n\n\n    av_log(ctx, AV_LOG_VERBOSE, \"threshold:%.2f radius:%d\\n\", thresh, gf->radius);\n\n\n\n    return 0;\n\n}\n", "idx": 14469, "substitutes": {"ctx": ["context", "tx", "cam", "cm", "bc", "pkg", "cv", "ca", "mc", "rc", "config", "cc", "jp", "qa", "Context", "ctrl", "ci", "cs", "lc", "conv", "cms", "cmp", "init", "linux", "loc", "conn", "kw", "obj", "uc", "cli", "ck", "nc", "tc", "component", "c", "cca", "crit", "anc", "cb", "cas", "sc", "sci", "cmd", "cf", "cp", "exec", "kb", "vc", "xc", "core"], "args": ["friends", "actions", "call", "context", "parts", "series", "array", "arm", "config", "arms", "fields", "extra", "a", "range", "api", "g", "cs", "err", "limits", "arg", "init", "ras", "flags", "np", "obj", "size", "params", "p", "s", "includes", "data", "axis", "ars", "Args", "gs", "arc", "magic", "spec", "inc", "c", "arr", "argument", "cb", "atts", "afi", "objects", "all", "empty", "ar", "icks", "alloc", "ks", "aws"], "gf": ["gbfac", "gbf", " gb", "gufs", " gfe", "ogfe", " gfs", "guf", "gasf", "Gc", "grainf", "genfs", "gndf", " gdf", "gfac", "genf", "egf", "qf", "qfs", "gendf", "gnf", "gif", "qfo", "egif", "agfs", "gufac", "gc", "argfs", " gc", "agff", "gff", "sgfs", "argff", " gfc", "gnfs", "argf", "kif", "gnfe", "sgf", "genfe", "Gcf", "ogdf", "Gfs", "ogcf", "ogf", "egfc", "guc", "gencf", " gfac", "arginf", "gdf", "gfe", "graf", "Gfe", "gfc", "Gf", "gasfs", "gb", "ginf", "gcf", "gfo", "gfs", "qb", "Gdf", "agf", "sgc", " gif", "gbfs", "gasb", " gfo", "grafs", "kf", "kfc", "gasfo", "graff", "aginf", "gbc"]}}
{"project": "qemu", "commit_id": "a426e122173f36f05ea2cb72dcff77b7408546ce", "target": 0, "func": "static int kvm_client_migration_log(struct CPUPhysMemoryClient *client,\n\n\t\t\t\t    int enable)\n\n{\n\n\treturn kvm_set_migration_log(enable);\n\n}\n", "idx": 14476, "substitutes": {"client": ["path", "port", "remote", "config", "pc", "child", "local", "Client", "connection", "public", "image", "project", "con", "server", "conf", "conn", "clean", "cli", "http", "parent", "custom", "global", "man", "command", "cell", "cache", "prefix", "node"], "enable": ["show", "pire", "enabled", "en", "enh", "ure", "ignore", "allow", "core", "hide", "style", "execute", "send", "use", "update", "like", "force", "valid", "open", "active", "online", "mode", "add", "line", "activate", "address", "pin", "end", "debug", "write", "Enable", "run", "apply", "disable", "start"]}}
{"project": "FFmpeg", "commit_id": "fc8fa007fb6099643a1f742a162e5e5eda760fd6", "target": 0, "func": "static int64_t rtmp_read_seek(URLContext *s, int stream_index,\n\n                              int64_t timestamp, int flags)\n\n{\n\n    RTMP *r = s->priv_data;\n\n\n\n    if (flags & AVSEEK_FLAG_BYTE)\n\n        return AVERROR(ENOSYS);\n\n\n\n    /* seeks are in milliseconds */\n\n    timestamp = av_rescale(timestamp, AV_TIME_BASE, 1000);\n\n    if (!RTMP_SendSeek(r, timestamp))\n\n        return -1;\n\n    return timestamp;\n\n}\n", "idx": 14499, "substitutes": {"s": ["ses", "m", "service", "t", "fs", "rs", "https", "cs", "S", "os", "es", "js", "si", "sq", "secure", "server", "ss", "client", "w", "p", "e", "sec", "socket", "sf", "sb", "b", "f", "gs", "c", "ns", "sc", "ssl", "sv", "sl", "ds", "services", "src", "ls", "support", "ctx"], "stream_index": ["stream_offset", "ream_position", "ream_index", "stream_position", "ream_offset"], "timestamp": ["lifemark", "timeest", "stimestamp", "Timest", "timemark", "Timera", "timeetime", "timempt", "imeline", "Timetime", "mintest", "timeline", "stimest", "lifest", "stimera", "timetz", "timetime", "mintestamp", "nulletz", "threadetz", "mintetz", "tmetime", "timest", "stimeline", "teneline", "stimetz", "tenestamp", "Timemark", "threadest", "impoint", "timpoint", "Timestamp", "Timetz", "timera", "tenetime", "Timeline", "lifetime", "imetime", "nullestamp", "timeemark", "tenempt", "imempt", "threadestamp", "tmestamp", "tmempt", "imestamp", "stimpoint", "lifestamp", "Timpoint", "tmeline", "mintera", "timeestamp", "imest", "nullest"], "flags": ["types", "args", "planes", "parts", "FLAG", "format", "relations", "fl", "fs", "fields", "forces", "prot", "fps", "settings", "bytes", "status", "ants", "files", "times", "reads", "options", "plugins", "data", "seconds", "features", "mask", "lag", "frames", "f", "bits", "Flags", "stats", "ags", "bugs", "ops", "links", "fee", "ints", "properties", "ts", "flag", "vals"], "r": ["rr", "m", "ru", "R", "d", "hr", "t", "rc", "l", "rs", "rar", "g", "er", "ra", "req", "rg", "sr", "v", "rh", "fr", "o", "w", "u", "mr", "p", "e", "lr", "rb", "b", "reader", "f", "rl", "c", "re", "nr", "ar", "dr"]}}
{"project": "FFmpeg", "commit_id": "6df1cfa7e4d488051d7b5033c0c69df970db9f82", "target": 0, "func": "static av_cold int mace_decode_init(AVCodecContext * avctx)\n\n{\n\n    MACEContext *ctx = avctx->priv_data;\n\n\n\n    if (avctx->channels > 2)\n\n        return -1;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    avcodec_get_frame_defaults(&ctx->frame);\n\n    avctx->coded_frame = &ctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 14508, "substitutes": {"avctx": ["afcca", "afpkg", "aucmp", "avecca", "aucontext", "AVcmp", "avca", "awctx", "avcmp", "avlc", "avepkg", "auctrl", "AVcontext", "aflc", "AVca", "avectx", "avelc", "awlc", "aveca", "afcmp", "AVctrl", "afcontext", "auctx", "awpkg", "AVcca", "avecmp", "avcontext", "afca", "afctx", "AVctx", "avecontext", "avpkg", "awcontext", "afctrl", "avctrl", "avcca"], "ctx": ["context", "tx", "cam", "cm", "pkg", "qa", "ca", "cv", "cc", "config", "lc", "ctrl", "cs", "ci", "cn", "cms", "wcs", "cmp", "loc", "conf", "conn", "kw", "obj", "cli", "pa", "tc", "component", "cfg", "c", "cca", "cu", "voc", "dc", "cb", "cas", "sc", "cmd", "cf", "coll", "cp", "aux", "vc", "xc", "soc", "fc", "cci", "alloc", "fw"]}}
{"project": "qemu", "commit_id": "1bf6beec8a012cae4bb6fbc89c465127e9650c92", "target": 1, "func": "float16 float32_to_float16(float32 a, flag ieee STATUS_PARAM)\n\n{\n\n    flag aSign;\n\n    int_fast16_t aExp;\n\n    uint32_t aSig;\n\n    uint32_t mask;\n\n    uint32_t increment;\n\n    int8 roundingMode;\n\n    a = float32_squash_input_denormal(a STATUS_VAR);\n\n\n\n    aSig = extractFloat32Frac( a );\n\n    aExp = extractFloat32Exp( a );\n\n    aSign = extractFloat32Sign( a );\n\n    if ( aExp == 0xFF ) {\n\n        if (aSig) {\n\n            /* Input is a NaN */\n\n            float16 r = commonNaNToFloat16( float32ToCommonNaN( a STATUS_VAR ) STATUS_VAR );\n\n            if (!ieee) {\n\n                return packFloat16(aSign, 0, 0);\n\n            }\n\n            return r;\n\n        }\n\n        /* Infinity */\n\n        if (!ieee) {\n\n            float_raise(float_flag_invalid STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n        return packFloat16(aSign, 0x1f, 0);\n\n    }\n\n    if (aExp == 0 && aSig == 0) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    /* Decimal point between bits 22 and 23.  */\n\n    aSig |= 0x00800000;\n\n    aExp -= 0x7f;\n\n    if (aExp < -14) {\n\n        mask = 0x00ffffff;\n\n        if (aExp >= -24) {\n\n            mask >>= 25 + aExp;\n\n        }\n\n    } else {\n\n        mask = 0x00001fff;\n\n    }\n\n    if (aSig & mask) {\n\n        float_raise( float_flag_underflow STATUS_VAR );\n\n        roundingMode = STATUS(float_rounding_mode);\n\n        switch (roundingMode) {\n\n        case float_round_nearest_even:\n\n            increment = (mask + 1) >> 1;\n\n            if ((aSig & mask) == increment) {\n\n                increment = aSig & (increment << 1);\n\n            }\n\n            break;\n\n        case float_round_up:\n\n            increment = aSign ? 0 : mask;\n\n            break;\n\n        case float_round_down:\n\n            increment = aSign ? mask : 0;\n\n            break;\n\n        default: /* round_to_zero */\n\n            increment = 0;\n\n            break;\n\n        }\n\n        aSig += increment;\n\n        if (aSig >= 0x01000000) {\n\n            aSig >>= 1;\n\n            aExp++;\n\n        }\n\n    } else if (aExp < -14\n\n          && STATUS(float_detect_tininess) == float_tininess_before_rounding) {\n\n        float_raise( float_flag_underflow STATUS_VAR);\n\n    }\n\n\n\n    if (ieee) {\n\n        if (aExp > 15) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0);\n\n        }\n\n    } else {\n\n        if (aExp > 16) {\n\n            float_raise(float_flag_invalid | float_flag_inexact STATUS_VAR);\n\n            return packFloat16(aSign, 0x1f, 0x3ff);\n\n        }\n\n    }\n\n    if (aExp < -24) {\n\n        return packFloat16(aSign, 0, 0);\n\n    }\n\n    if (aExp < -14) {\n\n        aSig >>= -14 - aExp;\n\n        aExp = -14;\n\n    }\n\n    return packFloat16(aSign, aExp + 14, aSig >> 13);\n\n}\n", "idx": 14521, "substitutes": {"a": ["args", "m", "sta", "as", "d", "ca", "ea", "array", "ai", "input", "any", "l", "i", "active", "da", "g", "source", "audio", "image", "new", "parse", "missing", "abc", "ama", "aa", "access", "alpha", "password", "o", "z", "an", "ad", "p", "e", "A", "s", "ba", "la", "aw", "img", "b", "u", "f", "aaa", "au", "address", "ab", "am", "c", "ac", "ao", "wa", "va", "aux", "ata", "ae", "sa", "aaaa", "ar", "ga", "mac", "window", "y", "in"], "STATUS_PARAM": ["STATUS_VAR", "STATUS_ARAR", "STATUS_VA", "STATUS_STRAMS", "STATUS_ARAM", "STATUS_STRAM", "STATUS_PARAR", "STATUS_STRAR", "STATUS_VAMS", "STATUS_PARA", "STATUS_PARAMS", "STATUS_VAM", "STATUS_ARAMS", "STATUS_STRA", "STATUS_ARA"], "aSign": ["areaSign", "aSc", " aNeg", "anaPen", "saNeg", "anPay", "saSign", "areaDig", " aPen", "saSc", "anaExp", "saPay", "anClose", "saShift", " aShift", "bSign", " aPass", "anExp", "saPass", "areaNeg", "saExp", " aDig", "iPull", "iClose", "areaPay", "alphaSign", "saDig", " aSize", " aPay", "aPull", "bExp", "ASign", "aClose", "aShift", "bSc", "bSize", "aPass", "anSc", "anaSign", " aClose", "aPay", "eaClose", "iSc", "aSize", "anShift", "iSign", "aNeg", " aPull", "saClose", "aPen", "alphaShift", "aDig", "anPass", "AExp", "eaPay", " aSc", "anaSc", "ASize", "alphaDig", "eaSign", "saPen", "eaExp", "anSign", "alphaExp", "bDig", "anPull"], "aExp": ["saEx", "AEnc", "aOp", " aExt", "saExt", "aaImp", "anCl", "maExp", "aaCl", "alphaComp", "AEXP", "aaExp", "aEXP", "saSign", "pEXP", " aCl", "aImp", "aaSec", "pEx", "alphaEx", " aOp", "saCl", "alphaExt", "eSec", "maEx", "eCl", " aComp", "AEx", "anExp", "aSec", "saExp", "alphaexp", "saOp", " aEx", " aEXP", "pEnc", "ASign", " aexp", " aSec", "anExt", " aImp", "aExt", "anEXP", "anSec", "anOp", "maSign", "aCl", "maExt", "anexp", "aexp", "saSec", "eExp", "AExp", "aComp", "anComp", "AExt", "pExp", " aEnc", "aEnc", "aEx", "anEx", "eImp", "anSign", "alphaExp", "saEXP", "alphaEXP"], "aSig": ["aIsigs", " aAsig", "aSlIG", "aSock", "aUsig", "aSigs", "aEsigned", "ASIG", "aSlign", " aAsigm", "aAsigma", " aSuIG", " aAsign", "aSigh", "aSuIG", "aAsigs", "aSIG", "aDesIG", "aSeigs", "aUsIG", " aSick", "aPsIG", " aAsIG", "aUsess", "aInsigs", "aEsigs", "aEsign", "AUsig", "aSligh", "aAsig", "aAsigh", " aSigm", "aSigm", "aEsigm", " aSuigs", "aUsigs", " aSIG", " aSigs", "aSeign", "aDesigma", " aAsigs", "aAsigm", "aSick", "AUsIG", "aSigniz", "aSlig", " aSigma", "aInsick", "aSiz", "aDesock", "aPsig", "aSignigm", "aIsigned", " aAsigh", " aAsick", "aAsess", "aPsigs", " aSuign", " aAsigned", " aAsiz", "aSuig", "aEsig", "ASig", "ASigma", "aSuign", "AUsock", "AUsigma", " aSiz", " aSess", " aAsess", "aSligs", "aSeig", "aAsIG", " aSuigma", "aAsign", "aEsigh", "aEsIG", "ASock", " aSuig", "aAsiz", "aDesig", "aSuigma", "aUsigma", "aAsick", " aSigh", "aSuigh", "aUsock", "aSignig", "aIsIG", "aSeIG", "aSigned", "aSigma", " aSigned", "aEsiz", "aSignigs", "aInsIG", "aSess", "aIsig", "aAsigned", "aPsess", "aInsig", "aSuigs"], "mask": ["bug", "map", "ch", "carry", "cm", "qa", "allow", "hide", "shift", "batch", "shadow", "shape", "pixel", "weight", "image", "sk", "mark", "hash", "mm", "sum", "comment", "key", "error", "patch", "gain", "conf", "Mask", "scan", "fix", "filter", "pass", "group", "sign", "pack", "max", "match", "keep", "ix", "ask", "count", "result", "skip", "feature", "cover", "inc", "black", "block", "reason", "iq", "pull", "offset", "scale", "q", "ack", "miss", "qq", "pattern", "lock", "ban", "delay", "flag", "strip", "depth", "bit"], "increment": ["incmented", "operement", "ironment", "Increral", "Decreament", "generement", "fillment", "incmentation", "creMENT", "operments", "generment", " increasement", "fillmentation", "incral", "Increement", "increral", "intmentation", "incremented", "improvementation", "Decrementation", "increMENT", "opermentation", " increaseral", "IncreMENT", "crement", "fillmented", "incmental", "penmentation", " increasemented", "Decrement", "incMENT", "improveement", "intment", "improveament", "improvemented", "genermentation", "improveension", "ironmentation", "incments", "crementation", "increension", "ironement", "ironmented", "intmental", "incremental", "operment", "penment", "Decreement", "penement", " increasementation", "incrementation", "increation", "Incremental", "incment", "Increment", "increament", "incation", "Increation", "Incrementation", "incement", "generension", "improvement", "Incremented", "increement", "fillation", "generments", "genermented", "Increension", "penament", "improvements", "crements", "intmented", "increments", "Increments"], "roundingMode": ["roundgingMod", "hardingMODE", "rollinggingmode", "roundgingMode", "hardningSetting", "rollingingMod", "Roundingmode", "roundtingMode", "roundeningMODE", "RoundgingOrder", "roundINGOrder", "roundingmode", "rollingingMode", "roundningKind", "RoundingMode", "roundtingOrder", "roundgingMODE", "roundingKind", "hardingSetting", "RoundingOrder", "roundeningmode", "roundgingOrder", "roundningSetting", "roundgingmode", "rounddingMode", "roundingMODE", "rollingingMODE", "rollinggingMode", "roundeningMode", "hardningMODE", "roundisingmode", "rounddingSetting", "Roundgingmode", "rollinggingMODE", "RoundgingMode", "roundINGMode", "roundisingMod", "roundningMODE", "roundingSetting", "rollinggingMod", "rounddingKind", "roundINGmode", "hardingMode", "hardingKind", "roundtingmode", "roundingOrder", "rounddingMODE", "roundeningKind", "roundingMod", "hardningKind", "roundisingMODE", "roundisingMode", "roundeningMod", "roundningMode", "roundeningSetting", "hardningMode", "rollingingmode"]}}
{"project": "qemu", "commit_id": "0d8d7690850eb0cf2b2b60933cf47669a6b6f18f", "target": 0, "func": "int virtqueue_avail_bytes(VirtQueue *vq, int in_bytes, int out_bytes)\n\n{\n\n    unsigned int idx;\n\n    unsigned int total_bufs, in_total, out_total;\n\n\n\n    idx = vq->last_avail_idx;\n\n\n\n    total_bufs = in_total = out_total = 0;\n\n    while (virtqueue_num_heads(vq, idx)) {\n\n        unsigned int max, num_bufs, indirect = 0;\n\n        target_phys_addr_t desc_pa;\n\n        int i;\n\n\n\n        max = vq->vring.num;\n\n        num_bufs = total_bufs;\n\n        i = virtqueue_get_head(vq, idx++);\n\n        desc_pa = vq->vring.desc;\n\n\n\n        if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_INDIRECT) {\n\n            if (vring_desc_len(desc_pa, i) % sizeof(VRingDesc)) {\n\n                error_report(\"Invalid size for indirect buffer table\");\n\n                exit(1);\n\n            }\n\n\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (num_bufs >= max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            /* loop over the indirect descriptor table */\n\n            indirect = 1;\n\n            max = vring_desc_len(desc_pa, i) / sizeof(VRingDesc);\n\n            num_bufs = i = 0;\n\n            desc_pa = vring_desc_addr(desc_pa, i);\n\n        }\n\n\n\n        do {\n\n            /* If we've got too many, that implies a descriptor loop. */\n\n            if (++num_bufs > max) {\n\n                error_report(\"Looped descriptor\");\n\n                exit(1);\n\n            }\n\n\n\n            if (vring_desc_flags(desc_pa, i) & VRING_DESC_F_WRITE) {\n\n                if (in_bytes > 0 &&\n\n                    (in_total += vring_desc_len(desc_pa, i)) >= in_bytes)\n\n                    return 1;\n\n            } else {\n\n                if (out_bytes > 0 &&\n\n                    (out_total += vring_desc_len(desc_pa, i)) >= out_bytes)\n\n                    return 1;\n\n            }\n\n        } while ((i = virtqueue_next_desc(desc_pa, i, max)) != max);\n\n\n\n        if (!indirect)\n\n            total_bufs = num_bufs;\n\n        else\n\n            total_bufs++;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14531, "substitutes": {"vq": ["svqa", " vck", "wq", "dk", "svqu", "vqueue", "vqq", "vf", "nqueue", " vque", "dq", " vb", "wdq", "kqu", "svp", "flq", "svk", "vp", "flque", "bb", "bq", "vb", "vqu", "lc", "vqa", "lp", " vp", "bque", "vdq", "vck", "kk", "vquery", "dqu", " vqa", " vqq", "lqa", "flf", " vf", "nq", "lq", "svck", "svb", "svf", "dque", "svq", "wck", "vque", "flquery", "svquery", "vk", " vqueue", " vc", "bf", "nque", "wque", " vquery", "svqueue", " vdq", "svdq", "vc", "kq", "svque", "svqq", "nqq", "svc", "kque"], "in_bytes": ["in_windows", "in24loads", "in_lines", "inxpages", "out_lines", "in24lines", "in00total", " in_windows", "in24total", " in__windows", "inxlines", "in00windows", "inxnet", "in00bytes", "in__bytes", " in__total", "in__windows", " in__lines", "in_net", "in_pages", "out_loads", "out_net", "in_loads", "in24bytes", "out_pages", " in_lines", " in__bytes", "in00lines", "inxbytes", "in__lines", "in__total"], "out_bytes": ["out_events", "outMpieces", "outxdes", "outxsteps", "in_lines", "outxgroups", "outinggroups", "inc_steps", "out_lines", "out_pieces", "out67bytes", "out_steps", " out_groups", "outingdes", " out_events", "out_blocks", "outingbytes", "inc_groups", " out_lines", "outMlines", "out67groups", "out67events", "outMblocks", "out_des", "outingsteps", "inc_bytes", "out67lines", "inc_des", "in_blocks", "in_pieces", "out_groups", "outxbytes", "outMbytes"], "idx": ["adz", "idex", "kidz", "Idx", "indy", "midf", "indxs", "midx", "midxc", "Idxs", "idexs", "Idy", "idf", " idxc", " idz", "idez", "indxc", "ideX", "adxes", "idef", " idy", "idX", "idxs", "kidxes", " idX", "Idxc", "IdX", " idxs", "idxc", "midz", "kidxc", "indx", " idf", "adx", "idy", "idxes", "idz", "kidx", "idexc", " idxes", "adxc"], "total_bufs": ["total_buffals", "total_ufn", "total_bufn", "total_seqals", "total_bufals", "total_ufds", "total_reqi", "total_pooli", "total_ufes", "total_buffd", "total_reqd", "total_bufses", "total_seqds", "total_pathses", "total_poolls", "total_seqd", "total_bufds", "total_caps", "total_reqes", "total_pools", "total_bufes", "total_poold", "total_pathd", "total_ufses", "total_seqn", "total_pooln", "total_capis", "total_bufd", "total_bufis", "total_buffs", "total_ufi", "total_ufals", "total_seqs", "total_bufits", "total_reqls", "total_bufi", "total_reqs", "total_pooles", "total_seqis", "total_ufis", "total_capds", "total_reqn", "total_paths", "total_pathits", "total_bufls", "total_capd", "total_ufits", "total_buffn", "total_ufd", "total_ufs", "total_ufls"], "in_total": [" in_stable", "inPbytes", "inPstable", "in_base", "in67bytes", " in_sum", "out_gross", "in_normal", "inLgross", "in__normal", "in_sum", "out_normal", "inPtotal", "in67total", "inLtotal", "inc_meta", "inPsum", "inLnormal", "in__gross", "inc_bytes", "inc_base", "in_stable", "in67meta", "in_meta", "in_gross", "in67base", "in__total", "inc_total"], "out_total": ["total_gross", "out_errors", "out_full", "output_errors", "output_token", "out_gross", "out67errors", "out67full", "output_full", "output_total", "num_available", "totalalltotal", "outallgross", "num_total", "out_max", "out_available", "out_token", "out67token", "totalallsize", "totalallgross", "num_max", "outalltotal", "out_size", "outallsize", "total_total", "out_global", "out67total", "totalallglobal", "outallglobal", "total_size", "total_global"], "max": ["final", "x", "total", "limit", "active", "rec", "temp", "can", "count", "c", "cat", "end", "ng", "out", "cp", "cycle", "num", "in", "height", "index", "self", "id", "key", "error", "client", "w", "parse", "huge", "min", "Max", "ax", "ip", "cache", "ca", "current", "ci", "init", "step", "info", "co", "none", "diff", "inc", "load", "no", "cl", "orig", "name", "act", "MAX", "mod", "conf", "chain", "cr", "size", "k", "n", "parent", "cu", "scale", "all", "last", "rest", "wrap", "start"], "num_bufs": ["num_ufc", "num_bufses", "num_bufsets", "num_poolds", "num_bufd", "num_refs", "num_refsets", "num__ucs", "num_ufm", "num_buffses", "num_ufns", "num_bufds", "num_ufts", "num_ufps", "num_ufp", "num_ufds", "num_brc", "num_pools", "num_ufd", "num__ucds", "num_bufm", "num_buffm", "num_ucm", "num_buffs", "num__bufts", "num_ucs", "num_brds", "num__bufd", "num_ufses", "num_limd", "num_bufts", "num_limses", "num_ucts", "num_outputps", "num_bufps", "num_refp", "num_ufsets", "num_brd", "num_bufns", "num_ufs", "num_poolm", "num_poolsets", "num_lims", "num_ucc", "num_brs", "num_limns", "num_ucds", "num_ucns", "num_buffd", "num__ucts", "num_poolts", "num__bufs", "num__bufds", "num_poold", "num_ucd", "num_outputm", "num_poolps", "num_poolp", "num_bufp", "num_bufc", "num_refd", "num_buffns", "num__ucd", "num_outputd", "num_outputs"], "desc_pa": ["recPapa", "descCapa", "description_opa", "comp_apa", "descalba", "desc_p", "descCpi", "sec_pa", "description_pa", "descKpas", "desc_lia", "descriptionkba", "asc_ba", "description_pse", "descriptionLpa", "descKpi", "compCpb", "descCba", "descLlia", "desCp", "compCapa", "des_pa", "desckpai", "specLpa", " desc_p", " desc_ca", "descriptionkpa", "compCpa", "sec_ppa", "descLsea", "des_p", "descriptionkpai", "desc__pa", "spec_PA", "descJpai", "des_lia", "spec_pas", "desc_par", "desc_ba", "recPppa", "descCp", "descPppa", "des_base", "ascPpar", "desckpse", "descCpb", "descppi", "descdpa", "descPpse", "specLlia", "descOba", "descppa", "descCpas", "descalpa", "description_pe", "descppas", "recPpa", "desCba", "ascPba", "descPapa", "description_pas", "description_pai", "desc_base", "descCca", "descLp", "descLpas", "descOpa", "desc__apa", "desKpi", "desc__p", "desKpas", "spec_lia", "descCppa", "comp_pb", "desc_pb", "description_p", "desc_pas", "comp_pai", "descalpai", "recPca", "descJpb", "descPpar", "descpbase", "descJapa", "descPpai", "rec_ppa", "des_pi", "desc_opa", "descPpa", "descalpar", "desckpe", "ascPpai", "des_ba", "desCpa", "desc_ca", "descCbase", "descJpa", "desKpa", "desckppa", "descriptionLpas", "desckba", "descClia", "desc_pe", "desc_pse", "asc_par", "asc_pai", "descOpse", "des_pas", "specLpas", "rec_pa", "compCpai", "descPca", "spec_pa", "ascPpa", "descdsea", "desckopa", "asc_pa", "descPba", "desc_sea", "descriptionLp", "desc_pi", "description_sea", "descCpa", "desc_PA", "descLPA", "desKbase", "descriptionLsea", "desClia", "descdp", "comp_pa", "descdpas", "description_ba", "sec_opa", "descKbase", "sec_pe", "rec_apa", "descOpai", "descCpai", "desckpa", "desc_ppa", "specLPA", "descKpa", "description_ppa", " desc_apa", "descLpa", "desc__ca", "rec_ca", "desc_apa", "desc_pai", "descriptionkpse"], "i": ["hi", "qi", "it", "ui", "m", "part", "I", "d", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "io", "api", "mu", "ci", "di", "x", "si", "ie", "ii", "key", "uri", "v", "yi", "u", "z", "ind", "p", "e", "fi", "mini", "info", "li", "ix", "b", "multi", "j", "phi", "f", "n", "ti", "ip", "c", "eni", "is", "pi", "chi", "zi", "y", "index", "start"]}}
{"project": "qemu", "commit_id": "bd5c51ee6c4f1c79cae5ad2516d711a27b4ea8ec", "target": 0, "func": "static CharDriverState *qemu_chr_open_fd(int fd_in, int fd_out)\n\n{\n\n    CharDriverState *chr;\n\n    FDCharDriver *s;\n\n\n\n    chr = g_malloc0(sizeof(CharDriverState));\n\n    s = g_malloc0(sizeof(FDCharDriver));\n\n    s->fd_in = io_channel_from_fd(fd_in);\n\n    s->fd_out = io_channel_from_fd(fd_out);\n\n    fcntl(fd_out, F_SETFL, O_NONBLOCK);\n\n    s->chr = chr;\n\n    chr->opaque = s;\n\n    chr->chr_add_watch = fd_chr_add_watch;\n\n    chr->chr_write = fd_chr_write;\n\n    chr->chr_update_read_handler = fd_chr_update_read_handler;\n\n    chr->chr_close = fd_chr_close;\n\n\n\n    qemu_chr_be_generic_open(chr);\n\n\n\n    return chr;\n\n}\n", "idx": 14557, "substitutes": {"fd_in": ["FD_out", "fd___ini", "fdalldown", "dir_in", "FD_IN", "fdPout", "fd___in", "dir___down", "dir___out", "fdallin", "fdallslice", "fdPini", "FD_in", "fd___slice", "fd_inner", "dir_ini", "dir___ini", "dir_down", "fdPin", "FD_slice", "dir___in", "fd_slice", "fd___down", "fd___out", "fd_ini", "fd_down", "fd_IN", "dir_out", "fdPdown", "FD_inner", "fdallout", "FD_down"], "fd_out": ["draft_off", " fid_out", "cond_out", "fd_inner", "fd___out", " fid_source", " fid_write", "fd_p", " fid_for", "fd_again", "draft_again", "fd_output", "fdxout", "cond_outs", "fd_outs", "FD_out", "fd_off", "fdxsource", "FD_in", "fd___source", "fdxwrite", "fd_write", "fdxfor", "draft_out", "fd_source", "FD_p", "fd___for", "cond_output", "cond_in", "fd___write", "draft_inner", "fd_for"], "chr": ["achrf", "echr", "chenr", "corerr", "cherru", "CHrr", "qrt", "qrar", "cher", "whra", "colr", "chrr", "achr", "countr", " chlr", "hra", "ichra", "qra", "gyrer", "chrb", "kyrr", "qnr", "chert", "charr", "cherr", "cyr", "chre", "hrar", "ichrar", "qrr", " chre", "colrr", "chsr", " chsr", " chrr", "chrn", "chlr", "gyrn", "kyr", "cyru", "CHr", "chrer", "chra", "CHrar", "ichrc", "cyrb", "chrar", "achrer", "chrt", "kyrer", "macrr", "echlr", "charnr", "CHnr", " chrt", "ichr", "macrb", " chrc", "countrb", " chrn", "cherf", "shr", "chnr", "chrc", "echrr", "whru", "achrn", "echrt", "corerb", "gyrr", "qar", "cherrb", "gyrb", "chrf", "shsr", "corerer", "shre", "ichsr", "collr", "ichrf", "cyre", "gyrt", "chru", " chrf", "charrar", "chere", "hr", "cherb", "gyr", "hrc", "cherre", "cheru", " chnr", "macr", "kyrb", "cherc", "colrt", "macrt", "whr", " chrb", "ichnr", "corer", "chesr", "cherer", "qrc", "qr", "gyrf", " chrer", "shrb", "countru", "whrb", "chera", "countra", "charrr", "chear"], "s": ["south", "sys", "ses", "self", "rss", "m", "d", "sync", "service", "sg", "fs", "t", "l", "i", "sym", "rs", "a", "g", "cs", "S", "settings", "os", "h", "sr", "status", "js", "si", "scope", "sq", "session", "server", "v", "ps", "conf", "ss", "storage", "o", "w", "u", "p", "e", "resource", "share", "socket", "http", "b", "sb", "sf", "n", "f", "stat", "gs", "spec", "c", "ns", "is", "ssl", "sv", "sl", "r", "ds", "su", "ls", "in"]}}
{"project": "FFmpeg", "commit_id": "bcaf64b605442e1622d16da89d4ec0e7730b8a8c", "target": 0, "func": "static int g722_encode_frame(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             const AVFrame *frame, int *got_packet_ptr)\n\n{\n\n    G722Context *c = avctx->priv_data;\n\n    const int16_t *samples = (const int16_t *)frame->data[0];\n\n    int nb_samples, out_size, ret;\n\n\n\n    out_size = (frame->nb_samples + 1) / 2;\n\n    if ((ret = ff_alloc_packet2(avctx, avpkt, out_size)))\n\n        return ret;\n\n\n\n    nb_samples = frame->nb_samples - (frame->nb_samples & 1);\n\n\n\n    if (avctx->trellis)\n\n        g722_encode_trellis(c, avctx->trellis, avpkt->data, nb_samples, samples);\n\n    else\n\n        g722_encode_no_trellis(c, avpkt->data, nb_samples, samples);\n\n\n\n    /* handle last frame with odd frame_size */\n\n    if (nb_samples < frame->nb_samples) {\n\n        int16_t last_samples[2] = { samples[nb_samples], samples[nb_samples] };\n\n        encode_byte(c, &avpkt->data[nb_samples >> 1], last_samples);\n\n    }\n\n\n\n    if (frame->pts != AV_NOPTS_VALUE)\n\n        avpkt->pts = frame->pts - ff_samples_to_time_base(avctx, avctx->delay);\n\n    *got_packet_ptr = 1;\n\n    return 0;\n\n}\n", "idx": 14566, "substitutes": {"avctx": ["afcca", "AVconfig", "afconn", "afpkg", "airxc", "aucontext", "evctx", "AVcmp", "afkb", "avekb", "airctx", "avcmp", "avepkg", "akconfig", "AVcontext", "avectx", "aucca", "akcmp", "afxc", "afcmp", "evconn", "akcca", "avqa", "akpkg", "afconfig", "afcontext", "AVxc", "akkb", "auctx", "aircmp", "aveconfig", "afqa", "aveqa", "evcontext", "avecmp", "avkb", "AVpkg", "avcontext", "akctx", "aircontext", "avxc", "avconn", "aveconn", "evcmp", "afctx", " avconn", "AVctx", "avecontext", "avconfig", " avcontext", " avqa", "avpkg", "auconfig", "akcontext", "avcca"], "avpkt": ["avpbke", "avfett", "AVpqt", "avfelt", "avpke", "appnpke", "avpreett", "avtpilot", "avprekit", "avcpkt", "avtelt", "avmkt", "afpett", "AVpacket", "avbpkt", "avfct", "avPacket", "avpbdc", "avcpqt", "avbpacket", " avtpqt", "avcpacket", "avpkit", "afpct", "avmyth", "avpct", "affct", "apppdc", "avnpdc", "avnpkt", "avcpet", "afpkit", "avpyth", "avpqt", "avcpett", " avpet", "appnpkt", "avpacket", "avpreacket", "affacket", "apppkt", "affelt", "avcet", " avpilot", "avcpilot", "AVcpqt", "avbpyth", "avcpct", "afpkt", "avpilot", "avmet", "avpelt", " avtpkt", "avnpelt", "avmett", "avfkt", "AVbpyth", "afpelt", "avpett", "avcilot", "avbpett", "avtkt", "avnpke", "avpbkt", "avPkt", "AVcpacket", "afpacket", "avPett", "AVbpacket", " avtpilot", "avPelt", "AVpkt", "avtpet", "avtct", "avmacket", "AVcpkt", "avcpyth", "apppke", "avfacket", "appnpelt", " avpqt", "AVbpett", "avtacket", "affett", " avtpet", "avprekt", "avPdc", "avtpqt", "affkt", "avpbelt", "avmqt", "AVcpet", "avPkit", "AVbpkt", "affkit", "avtpkt", "AVpet", "appnpdc", "avPke", "AVpett", "avcqt", "avpdc", "avpet", "avcpelt", "AVpyth", "avckt", "avfkit", "avfet", "avfqt", "apppelt"], "frame": ["date", "word", "zip", "Frame", "slice", "fram", "core", "code", "iframe", "object", "fb", "framework", "style", "cast", "def", "name", "range", "za", "plane", "image", "event", "module", "game", "sequence", "ace", "model", "position", "package", "fr", "element", "zone", "document", "parse", "e", "time", "fi", "fake", "note", "data", "component", "play", "f", "point", "flow", "line", "frames", "state", "feature", "setup", "block", "cfg", "file", "function", "ce", "process", "cf", "scale", "host", "video", "cycle", "header", "thread", "ze", "message"], "got_packet_ptr": ["got_packacket_ctr", "got_packet_pty", "got_packet_offset", "got_packacket_offset", "got_packacket_pointer", "got_packet__offset", "got_packet__ctr", "got_packet__ptr", "got_packet__pointer", "got_packet_tr", "got_packetallptr", "got_packet_ctr", "got_packacket_ptr", "got_packacket_pty", "got_packet_pointer", "got_packetallpointer", "got_packetallpty", "got_packetalltr", "got_packacket_tr"], "c": ["m", "context", "mc", "ch", "bc", "uc", "d", "t", "cv", "cm", "self", "config", "code", "l", "cc", "pc", "C", "a", "g", "lc", "ci", "cs", "cit", "h", "cy", "ct", "v", "cr", "o", "cd", "u", "oc", "p", "e", "s", "nc", "k", "b", "co", "tc", "f", "arc", "cu", "dc", "ac", "anc", "ce", "cf", "coll", "r", "cache", "xc", "vc", "ec", "core", "ctx"], "samples": ["lamples", "ssamples", "assages", "ssamps", " samps", "bisamples", "pample", "psamples", "sample", "asales", " schanges", "pamples", "passamples", "asamples", "pamps", "lamps", "scamps", " sonents", "namps", " sample", "bisages", "psample", "lales", "asamps", " sims", "bisims", "schanges", "asources", "samps", "sesamples", "assamples", "scizes", "passizes", "psonents", "sources", "nample", "ponents", "assims", "namples", "sizes", "scamples", "bischanges", "asschanges", "sales", "sonents", "scample", "sesizes", "sesample", "psamps", "ssample", "sages", " sages", "passample", "passamps", "lources", "sims", "sesamps"], "nb_samples": ["nb_namples", "nb_sesamples", "nb_testsounds", "nb_testsources", "nb_tamples", "nb_sesourses", "nb_Sills", "nb_devicesamps", "nb_testsamps", "nb_servicesimens", "nb_asamples", "nb_aseeds", "nb_statesonents", "nb_sipes", "nb_sespaces", "nb_Samples", "nb_esapes", "nb_testsores", "nb_timesamples", "nb___timesamples", "nb_suffizes", "nb_Sapes", "nb_testsipes", "nb_nessions", "nb_tannels", "nb_offsims", "nb_Samps", "nb_Spaces", "nb_timesimens", "nb_testsims", "nb_sizes", "nb_insamps", "nb_lessamps", "nb_ssims", "nb_insizes", "nb_servicesessions", "nb_devicesounds", "nb_suffamples", "nb64sims", "nb_psamps", "nb_specamples", "nb_bamples", "nb_esamps", "nb_inseeds", "nb_servicesamples", "nb_asiffs", "nb_devicesamples", "nb_sesources", "nb_sources", "nb_testsites", "nb_tessions", "nb_songs", "nb_sidites", "nb_offsources", "nb64psipes", "nb_servicesamps", "nb_specamps", "nb_bims", "nb64samples", "nb_sidamples", "nb_pspaces", "nb_sounds", "nb_sims", "nb64psores", "nb_tites", "nb_offsamps", "nb_timesources", "nb_testseeds", "nb_devicesizes", "nb_tamps", "nb_esamples", "nb___timesonents", "nb_sourses", "nb_bores", "nb_lessapes", "nb_seeds", "nb_sidamps", "nb_speconents", "nb_simens", "nb_ssimens", "nb_nannels", "nb_ssources", "nb_spaces", "nb_sores", "nb_statesamps", "nb___samples", "nb_testsonents", "nb64sores", "nb_testsamples", "nb_namps", "nb_sapes", "nb_testsannels", "nb_lessills", "nb_timesourses", "nb___sizes", "nb_siffs", "nb_psources", "nb_lessamples", "nb64sipes", "nb_sites", "nb_Songs", "nb_sonents", "nb_esills", "nb_psongs", "nb_psamples", "nb_sesongs", "nb_timesessions", "nb_Sizes", "nb_testsourses", "nb_sills", "nb_insamples", "nb_offsamples", "nb_ssamps", "nb_ssessions", "nb_timesizes", "nb___timesizes", "nb64psims", "nb_samps", "nb_sannels", "nb_psipes", "nb_psores", "nb___sonents", "nb_sidonents", "nb_timesonents", "nb_ssamples", "nb_statesamples", "nb_psims", "nb_testsizes", "nb_sesamps", "nb_asamps", "nb_insounds", "nb64psamples", "nb_tonents", "nb_bipes", "nb_testsiffs", "nb_insiffs", "nb_suffonents", "nb_sessions", "nb_Sonents", "nb_testsessions", "nb_timesamps"], "out_size": ["Out_time", "out__Size", "out_form", "byte_size", "bytelexscale", "out2scale", " out_scale", "outlexsize", "outlexlength", "out2ize", "outlexform", "bytelexlength", "out_time", "out__size", "bytelexsize", "out2size", " out_ize", "byte_length", "Out_Size", "out_scale", "out2Size", "out_length", "bytelexform", "out_Size", "Out_size", "byte_form", "Out__size", "out_ize", "Out__time", " out_Size", "Out__Size", "out__time", "outlexscale", "byte_scale"], "ret": ["alt", "ft", "reply", "t", "rc", "val", "def", "rets", "fun", "ref", "det", "arg", "valid", "value", "obj", "mt", "mem", "fin", "rb", "desc", "match", "success", "Ret", "bf", "result", "att", "reset", "ry", " Ret", "nt", "re", "out", "rt", "r", "rep", "repl", "RET", "al", "res", "reg", "no", "flag", "run", "len", "bit", "ner"], "last_samples": ["last_usizes", "last_shores", "last_Samps", "last_Sores", "last_ussample", "last_namps", "last_nizes", "last_ssample", "last_Ssample", "last_Samples", "last_usamps", "last_psores", "last_Sims", "last_sores", "last_samps", "last_psamples", "last_namples", "last_psims", "last_shims", "last_usamples", "last_sims", "last_sizes", "last_shamples", "last_psamps", "last_nsample", "last_shamps", "last_Sizes"]}}
{"project": "FFmpeg", "commit_id": "03d83ba34b2070878909eae18dfac0f519503777", "target": 0, "func": "static int gif_image_write_image(AVCodecContext *avctx,\n\n                                 uint8_t **bytestream, uint8_t *end,\n\n                                 const uint32_t *palette,\n\n                                 const uint8_t *buf, const int linesize,\n\n                                 AVPacket *pkt)\n\n{\n\n    GIFContext *s = avctx->priv_data;\n\n    int len = 0, height = avctx->height, width = avctx->width, x, y;\n\n    int x_start = 0, y_start = 0, trans = s->transparent_index;\n\n    int honor_transparency = (s->flags & GF_TRANSDIFF) && s->last_frame;\n\n    const uint8_t *ptr;\n\n\n\n    /* Crop image */\n\n    if ((s->flags & GF_OFFSETTING) && s->last_frame && !palette) {\n\n        const uint8_t *ref = s->last_frame->data[0];\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        int x_end = avctx->width  - 1,\n\n            y_end = avctx->height - 1;\n\n\n\n        /* skip common lines */\n\n        while (y_start < y_end) {\n\n            if (memcmp(ref + y_start*ref_linesize, buf + y_start*linesize, width))\n\n                break;\n\n            y_start++;\n\n        }\n\n        while (y_end > y_start) {\n\n            if (memcmp(ref + y_end*ref_linesize, buf + y_end*linesize, width))\n\n                break;\n\n            y_end--;\n\n        }\n\n        height = y_end + 1 - y_start;\n\n\n\n        /* skip common columns */\n\n        while (x_start < x_end) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_start] != buf[y*linesize + x_start]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_start++;\n\n        }\n\n        while (x_end > x_start) {\n\n            int same_column = 1;\n\n            for (y = y_start; y <= y_end; y++) {\n\n                if (ref[y*ref_linesize + x_end] != buf[y*linesize + x_end]) {\n\n                    same_column = 0;\n\n                    break;\n\n                }\n\n            }\n\n            if (!same_column)\n\n                break;\n\n            x_end--;\n\n        }\n\n        width = x_end + 1 - x_start;\n\n\n\n        av_log(avctx, AV_LOG_DEBUG,\"%dx%d image at pos (%d;%d) [area:%dx%d]\\n\",\n\n               width, height, x_start, y_start, avctx->width, avctx->height);\n\n    }\n\n\n\n    /* image block */\n\n    bytestream_put_byte(bytestream, GIF_IMAGE_SEPARATOR);\n\n    bytestream_put_le16(bytestream, x_start);\n\n    bytestream_put_le16(bytestream, y_start);\n\n    bytestream_put_le16(bytestream, width);\n\n    bytestream_put_le16(bytestream, height);\n\n\n\n    if (!palette) {\n\n        bytestream_put_byte(bytestream, 0x00); /* flags */\n\n    } else {\n\n        unsigned i;\n\n        bytestream_put_byte(bytestream, 1<<7 | 0x7); /* flags */\n\n        for (i = 0; i < AVPALETTE_COUNT; i++) {\n\n            const uint32_t v = palette[i];\n\n            bytestream_put_be24(bytestream, v);\n\n        }\n\n    }\n\n\n\n    if (honor_transparency && trans < 0) {\n\n        trans = pick_palette_entry(buf + y_start*linesize + x_start,\n\n                                   linesize, width, height);\n\n        if (trans < 0) { // TODO, patch welcome\n\n            av_log(avctx, AV_LOG_DEBUG, \"No available color, can not use transparency\\n\");\n\n        } else {\n\n            uint8_t *pal_exdata = s->pal_exdata;\n\n            if (!pal_exdata)\n\n                pal_exdata = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE, AVPALETTE_SIZE);\n\n            if (!pal_exdata)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pal_exdata, s->palette, AVPALETTE_SIZE);\n\n            pal_exdata[trans*4 + 3*!HAVE_BIGENDIAN] = 0x00;\n\n        }\n\n    }\n\n    if (trans < 0)\n\n        honor_transparency = 0;\n\n\n\n    bytestream_put_byte(bytestream, 0x08);\n\n\n\n    ff_lzw_encode_init(s->lzw, s->buf, 2 * width * height,\n\n                       12, FF_LZW_GIF, put_bits);\n\n\n\n    ptr = buf + y_start*linesize + x_start;\n\n    if (honor_transparency) {\n\n        const int ref_linesize = s->last_frame->linesize[0];\n\n        const uint8_t *ref = s->last_frame->data[0] + y_start*ref_linesize + x_start;\n\n\n\n        for (y = 0; y < height; y++) {\n\n            memcpy(s->tmpl, ptr, width);\n\n            for (x = 0; x < width; x++)\n\n                if (ref[x] == ptr[x])\n\n                    s->tmpl[x] = trans;\n\n            len += ff_lzw_encode(s->lzw, s->tmpl, width);\n\n            ptr += linesize;\n\n            ref += ref_linesize;\n\n        }\n\n    } else {\n\n        for (y = 0; y < height; y++) {\n\n            len += ff_lzw_encode(s->lzw, ptr, width);\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    len += ff_lzw_encode_flush(s->lzw, flush_put_bits);\n\n\n\n    ptr = s->buf;\n\n    while (len > 0) {\n\n        int size = FFMIN(255, len);\n\n        bytestream_put_byte(bytestream, size);\n\n        if (end - *bytestream < size)\n\n            return -1;\n\n        bytestream_put_buffer(bytestream, ptr, size);\n\n        ptr += size;\n\n        len -= size;\n\n    }\n\n    bytestream_put_byte(bytestream, 0x00); /* end of image block */\n\n    return 0;\n\n}\n", "idx": 14588, "substitutes": {"avctx": ["afcca", "AVconfig", "afconn", "abcontext", "afconnection", " avcb", "avecca", "afkb", "AVcmp", "akcdn", "afcms", "airctx", "navctl", "afcb", "avcmp", "navkb", "abcmp", "akconnection", " avconfig", "afcdn", "aircms", "AVcontext", "avectx", "abcu", "AVcu", "navctx", "afcu", "avconnection", "afcmp", "AVcms", "navcb", "antkb", "AVconn", "antctx", "avcdn", "apscdn", "afconfig", "apsconnection", "afcontext", "airconfig", "navconfig", "avcu", "antcontext", "AVcca", "avkb", " avcontext", "avcms", "avcontext", "antctl", "avcb", "akctx", "avconn", "aveconn", "aircontext", "afctx", "afctl", "AVctx", "navcontext", "apsctx", "avecontext", "avconfig", "avctl", "apscontext", "abctx", "akcontext", "avcca"], "bytestream": ["byderore", "bytvram", "bytrib", "bytore", "bytestrib", "byderram", "bytvream", "astvream", "bytestore", "astestram", "bytvore", "astvrib", "astestore", "bytestram", "astvram", "astvore", "bytvrib", "byderrib", "bytream", "bytram", "byderream", "astestream", "astestrib"], "end": ["device", "port", "edge", "en", "END", "enc", "id", "code", "mid", "event", "nd", "append", "begin", "client", "open", "stop", "e", "length", "ending", "feed", "text", "ended", "pos", "post", "max", "index", "start"], "palette": ["Palettes", "isalettes", "mallette", "isalette", "Palette", "malettes", "pallette", "palettes", "malotation", "isallette", "Palotation", "glettes", "gllette", "glignment", "palignment", "malette", "Palignment", " pallette", " palignment", "palotation", "Pallette", "glette", " palettes", "isalotation"], "buf": ["func", "map", "port", "proc", "vec", "context", "uc", "bc", "queue", "cv", "rc", "config", "fb", "home", "uf", "border", "conv", "pool", "buffer", "bag", "br", "buff", "console", "pub", "grab", "img", "rb", "pb", "wb", "fab", "box", "Buff", "gb", "ab", "cb", "cas", "text", "cap", "cmd", "cf", "aux", "cp", "que", "fam", "uv", "src", "seq", "prop", "cur", "coord", "ctx", "filename", "alloc"], "linesize": [" linesizer", " linessize", "lightssize", "inessize", "linsiz", "imagessize", "codesizable", "linersize", "pinsenge", " linesIZE", "linksize", "linesizer", "linsize", "inesiz", "linesiz", "codesiz", "linesIZE", "inesize", "linersization", "facesizing", "linesization", "linksization", "inesIZE", "imagesize", "vertsiz", "pinsization", "linessize", "facesize", "codessize", "linesizable", "facesiz", " linesizable", " linesiz", " linesenge", "lightsiz", "pinsize", "lightsIZE", "linersenge", "lightsization", "imagesiz", "codesizes", "linsization", "codesize", "lightsizer", "vertsization", "linsizing", "linersiz", "linesizing", "linksizer", " linesizes", "lightsize", "linesizes", "inesization", "linksiz", "facesization", " linesization", "vertsize", "vertsizing", "pinsiz", "linesenge", "imagesizable", "inesizes"], "pkt": ["placket", "pct", "punt", "packet", "Punt", "Pkt", "Packet", " pct", " punt", "plunt", "Pct", "plkt", " packet", "plct"], "s": ["sys", "ses", "bis", "parts", "d", "sync", "service", "sg", "t", "fs", "sym", "rs", "a", "g", "cs", "qs", "S", "h", "sk", "si", "js", "sq", "session", "v", "server", "conf", "ss", "storage", "ps", "p", "e", "data", "sb", "sf", "b", "n", "f", "stat", "gs", "spec", "c", "ns", "xs", "is", "ssl", "sv", "sl", "ops", "services", "ds", "events", "sa", "comm", "su", "ls", "ts", "ctx", "ks", "aws"], "x": ["m", "d", "l", "ex", "g", "image", "h", "px", "v", "w", "dx", "z", "size", "p", "e", "rx", "data", "b", "n", "f", "c", "X", "xy", "height", "index"], "y": ["hi", "ny", "yt", "m", "ch", "hy", "d", "t", "ys", "sky", "id", "l", "iy", "ish", "lon", "ey", "h", "py", "cy", "gy", "ym", "ye", "key", "o", "yer", "w", "dy", "yi", "z", "yl", "ady", "p", "e", "yr", "b", "yo", "j", "n", "f", "yn", "oy", "c", "vy", "ay", "yan", "ry", "type", "sy", "q", "year", "Y", "ya", "ky", "yy", "zy", "height", "start"], "ptr": ["port", "slice", "trace", "fd", "tmp", "rc", "tr", "pt", "ctr", "buffer", "dest", "loc", "buff", "obj", "bl", "img", "pointer", "trans", "fe", "cb", "attr", "dim", "src", "addr", "pad", "rot", "alloc"], "ref": ["alt", "rib", "ff", "part", "ha", "ob", "rc", "config", "val", "bb", "back", "Ref", "pre", "def", "uf", "source", "reference", "req", "buffer", "cmp", "comment", "fat", "loc", "br", "fr", "buff", "conf", "lib", "col", "rec", "p", "aff", "info", "rb", "pb", "REF", "pointer", "data", "af", "fab", "count", "bf", "f", "lf", "parent", "b", "ab", "url", "diff", "block", "c", "offset", "cb", "re", "cal", "db", "cache", "pos", "rel", "reg", "el", "ef"], "y_start": ["ny00start", "y__start", "y_range", "yy_end", "ey_end", "y_count", "yy_start", "y___end", "ey_Start", "y00max", "y001mid", "y001range", "ny00range", "x_begin", "x_count", "y00end", "y__space", "yamcount", "y___middle", "y_id", "y0start", "y_space", "y00mid", "oy_stop", "x_center", "yamstart", "y_address", "y1count", "y_min", "ny_start", "y200id", "oy_first", "y_mid", "x_started", "y001start", "y200center", "yacbegin", "ey_start", "y00range", "y___start", " y_started", "y001address", "yacend", "y_started", "yy_source", " y_min", "x_middle", "y00start", "ny_address", "y_Start", "y1end", "y00source", "ny_range", "yamend", "yacspace", "y_middle", "y_stop", "y_first", "y200end", "y200start", "y1range", "y_begin", "y__end", "y0center", "x_range", "y00address", "y_center", "y_max", "y_source", "y__begin", "x_space", "y0id", "oy_start", "yacstart", "y1start", "ny_mid", "oy_max", "y67start", "x_id", "ey_add", "yy_max", "y67max", "y67first", "y0end", "y67stop", "y_add", "ny00address", "ny00mid", "yamrange", "y___started"], "y_end": ["x_END", "yalllast", "y_ends", "ey00clean", "y00send", "y_clean", "ey_end", "dyallstart", "dy_start", "sy_ending", "x_ended", "y___end", "yallending", "y0ension", "ey0start", "sy00send", "y00ends", "y25end", "ry_edge", " y_ends", "ry_est", "sy00start", "ey_clean", "y00end", "y64end", "y_last", "dy_ending", "ry___est", "ey_open", "ry_ended", "dyalllast", "y0start", "sy00end", "ey00ends", "dy_nd", "ey0ension", "y0ended", "y64clean", "sy00ending", "y_nd", "y25open", "ry___start", "y_END", "dy_end", "ry_end", "y00ending", "ry___begin", " y_ension", "ey_start", "y_open", "y___start", "y___est", "y0edge", "yacend", "ey_ends", "ey0end", "y00start", "y_ension", "yacending", "sy_send", "ey_ension", "dy_ends", "y_stop", "sy_start", "y64open", "ey0size", "y_send", "y_begin", "y25ends", "y25clean", "ey00open", "ry_start", "y_edge", "y_ended", "ry_stop", "y_ending", "y_size", "y_est", "y___begin", "ey00end", "dyallending", "y64ends", "yacstart", "ry___end", "y0stop", "y00open", "sy_end", " y_nd", "ry_begin", "yacsend", "y0end", "yallstart", "dy_last", "dyallend", "ey_size", "y0size", "yallend", "y00clean"], "x_start": ["x_mean", "y_count", "by00mean", "lex00size", "lex_starting", "by00begin", "x00pos", "x_begin", "x_count", "by_begin", "xMStart", "x00size", "x00count", "xMstart", "xFstart", "xMstarting", "by00add", "x00end", "xFmean", "lex_set", "xMmiddle", "x00mean", "x_set", "x_starting", "x_middle", "x_size", " x_middle", "x_stop", "x00set", "by00start", "by_mean", "y_stop", " x_starting", "xMset", "x00Start", " x_Start", "x00begin", "x_Start", "x00add", "x_add", "x00starting", "y_pos", "x00start", "lex00starting", "x_pos", "xFadd", "lex_start", "by_add", "by_start", "lex_size", "lex00start", "xMsize", "lex00set", "xMend", "xFbegin"], "x_end": ["x_END", "wx_end", "x_index", "x_ended", "x_edge", "x64end", "x67end", "wx_END", "y_id", "wx_start", "x00enter", "x64start", "y_index", "wx_ending", "x00end", "x_enter", "x0end", "x00stop", "x67ended", "x0start", "x0ended", "x_stop", "y_stop", "y_enter", "x_ending", "y_edge", "y_ended", "x_est", "x64stop", "y_est", "x67start", "x00start", "x64enter", "x_id", "x67stop", "x0stop"]}}
{"project": "qemu", "commit_id": "9c4bab2668e6b5a9b69f77e3533380b6fd79034e", "target": 0, "func": "static int openfile(char *name, int flags)\n\n{\n\n\tif (bs) {\n\n\t\tfprintf(stderr, \"file open already, try 'help close'\\n\");\n\n\t\treturn 1;\n\n\t}\n\n\n\n\tbs = bdrv_new(\"hda\");\n\n\tif (!bs)\n\n\t\treturn 1;\n\n\n\n\tif (bdrv_open(bs, name, flags) == -1) {\n\n\t\tfprintf(stderr, \"%s: can't open device %s\\n\", progname, name);\n\n\t\tbs = NULL;\n\n\t\treturn 1;\n\n\t}\n\n\n\n\treturn 0;\n\n}\n", "idx": 14589, "substitutes": {"name": ["word", "path", "self", "part", "fd", "id", "code", "home", "a", "image", "new", "x", "fat", "key", "Name", "NAME", "o", "names", "size", "version", "ame", "time", "temp", "data", "ix", "base", "ext", "b", "old", "n", "f", "parent", "am", "c", "url", "type", "file", "cap", "no", "prefix", "filename"], "flags": ["types", "args", "kind", "ff", "ffff", "FLAG", "fs", "ins", "locks", "fields", "cs", "fun", "fps", "settings", "fx", "ants", "opens", "files", "alls", "options", "faces", "features", "count", "mask", "lf", "lag", "bits", "Flags", "ports", "stats", " Flags", "ents", "orts", "ops", "fee", "ints", "flag", "vals"]}}
{"project": "qemu", "commit_id": "67113c03423a23e60915574275aed7d60e9f85e1", "target": 0, "func": "static void e500_pcihost_bridge_realize(PCIDevice *d, Error **errp)\n\n{\n\n    PPCE500PCIBridgeState *b = PPC_E500_PCI_BRIDGE(d);\n\n    PPCE500CCSRState *ccsr = CCSR(container_get(qdev_get_machine(),\n\n                                  \"/e500-ccsr\"));\n\n\n\n    pci_config_set_class(d->config, PCI_CLASS_BRIDGE_PCI);\n\n    d->config[PCI_HEADER_TYPE] =\n\n        (d->config[PCI_HEADER_TYPE] & PCI_HEADER_TYPE_MULTI_FUNCTION) |\n\n        PCI_HEADER_TYPE_BRIDGE;\n\n\n\n    memory_region_init_alias(&b->bar0, OBJECT(ccsr), \"e500-pci-bar0\", &ccsr->ccsr_space,\n\n                             0, int128_get64(ccsr->ccsr_space.size));\n\n    pci_register_bar(d, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &b->bar0);\n\n}\n", "idx": 14591, "substitutes": {"d": ["D", "dh", "m", "self", "done", "fd", "t", "config", "l", "i", "id", "ded", "da", "bd", "die", "g", "dl", "this", "di", "x", "ld", "gd", "o", "pd", "dy", "cd", "de", "z", "ind", "ad", "p", "e", "dB", "u", "data", "n", "f", "dom", "gb", "dat", "c", "dt", "dc", "md", "dp", "r", "ds", "dd", "db", "dn", "dr", "dm", "dos"], "errp": ["erp", "rerror", " errerror", "errP", "rp", "erP", "ererror", "errerror", " errP", "rP"], "b": ["xb", "m", "t", "ob", "bs", "l", "bb", "i", "fb", "a", "bd", "g", "orb", "nb", "v", "mb", "w", "ad", "ba", "p", "e", "dB", "rb", "ib", "pb", "sb", "usb", "j", "n", "f", "gb", "ab", "c", "bg", "eb", "r", "abb", "db", "B", "emb", "lb", "y"], "ccsr": ["accradius", "ccasr", "rctr", "ccmr", " ccrf", "accnr", "cctr", "uctr", "cfnr", "ucsr", "accsr", "cfr", "cnr", "csr", "rcsr", "ctr", "cftr", "rcrf", "cfrg", "scrf", "cfrf", "scmr", "accrg", "cr", "ccanr", "crf", "ccarg", "rcnr", "cfmr", "cfsr", " ccmr", " ccnr", "ccradius", "ccrg", "scnr", "cfradius", "ucnr", "ccrf", "ccr", "ucr", "ccnr", "ccaradius", "scsr"]}}
{"project": "FFmpeg", "commit_id": "290e7eb77bee5a54182fb3d5fb122c1e117190da", "target": 1, "func": "void ff_clear_fixed_vector(float *out, const AMRFixed *in, int size)\n\n{\n\n    int i;\n\n\n\n    for (i=0; i < in->n; i++) {\n\n        int x  = in->x[i], repeats = !((in->no_repeat_mask >> i) & 1);\n\n\n\n\n        do {\n\n            out[x] = 0.0;\n\n            x += in->pitch_lag;\n\n        } while (x < size && repeats);\n\n    }\n\n}", "idx": 14599, "substitutes": {"out": ["IN", "bin", "array", "sync", "up", "extra", "again", "io", "new", "null", "init", "v", "output", "conn", "o", "obj", "p", "ext", "base", "co", "dot", "point", "parent", "at", "line", "inc", "arr", "OUT", "outs", "In", "Out", "exec", "work", "prefix", "copy", "window", "err"], "in": ["IN", "bin", "isin", "lin", "slice", "input", "ins", "id", "ini", "vin", "again", "a", "or", "connection", "ci", "source", "image", "new", "this", "x", "inn", "str", "con", "gin", "update", "init", "inas", "conn", "win", "pass", "rec", "tin", "rin", "data", "reader", "old", "query", "token", "inc", "diff", "inner", "nin", "In", "ic", "login", "exec", "err"], "size": ["ice", "en", "small", "cm", "sized", "grow", "shift", "code", "shape", "io", "name", "g", "Size", "capacity", "si", "ii", "loc", "white", "form", "z", "ize", "e", "six", "time", "ix", "length", "n", "address", "c", "number", "SIZE", "scale", "empty", "iz", "len"], "i": ["hi", "qi", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "l", "ini", "gi", "iu", "a", "io", "mu", "ci", "h", "x", "di", "si", "ii", "v", "uri", "o", "w", "yi", "u", "z", "ind", "p", "e", "mi", "li", "k", "b", "min", "ix", "j", "multi", "n", "f", "ti", "ip", "c", "is", "pi", "r", "bi", "zi", "y", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "c58d45e00489e07fd4606b64ad4095660494185b", "target": 1, "func": "static int film_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    FilmDemuxContext *film = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char scratch[256];\n\n    int i;\n\n    unsigned int data_offset;\n\n    unsigned int audio_frame_counter;\n\n\n\n    film->sample_table = NULL;\n\n    film->stereo_buffer = NULL;\n\n    film->stereo_buffer_size = 0;\n\n\n\n    /* load the main FILM header */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    data_offset = AV_RB32(&scratch[4]);\n\n    film->version = AV_RB32(&scratch[8]);\n\n\n\n    /* load the FDSC chunk */\n\n    if (film->version == 0) {\n\n        /* special case for Lemmings .film files; 20-byte header */\n\n        if (avio_read(pb, scratch, 20) != 20)\n\n            return AVERROR(EIO);\n\n        /* make some assumptions about the audio parameters */\n\n        film->audio_type = CODEC_ID_PCM_S8;\n\n        film->audio_samplerate = 22050;\n\n        film->audio_channels = 1;\n\n        film->audio_bits = 8;\n\n    } else {\n\n        /* normal Saturn .cpk files; 32-byte header */\n\n        if (avio_read(pb, scratch, 32) != 32)\n\n            return AVERROR(EIO);\n\n        film->audio_samplerate = AV_RB16(&scratch[24]);\n\n        film->audio_channels = scratch[21];\n\n        film->audio_bits = scratch[22];\n\n        if (scratch[23] == 2)\n\n            film->audio_type = CODEC_ID_ADPCM_ADX;\n\n        else if (film->audio_bits == 8)\n\n            film->audio_type = CODEC_ID_PCM_S8;\n\n        else if (film->audio_bits == 16)\n\n            film->audio_type = CODEC_ID_PCM_S16BE;\n\n        else\n\n            film->audio_type = CODEC_ID_NONE;\n\n    }\n\n\n\n    if (AV_RB32(&scratch[0]) != FDSC_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (AV_RB32(&scratch[8]) == CVID_TAG) {\n\n        film->video_type = CODEC_ID_CINEPAK;\n\n    } else\n\n        film->video_type = CODEC_ID_NONE;\n\n\n\n    /* initialize the decoder streams */\n\n    if (film->video_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->video_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->codec->codec_id = film->video_type;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->width = AV_RB32(&scratch[16]);\n\n        st->codec->height = AV_RB32(&scratch[12]);\n\n    }\n\n\n\n    if (film->audio_type) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        film->audio_stream_index = st->index;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = film->audio_type;\n\n        st->codec->codec_tag = 1;\n\n        st->codec->channels = film->audio_channels;\n\n        st->codec->sample_rate = film->audio_samplerate;\n\n\n\n        if (film->audio_type == CODEC_ID_ADPCM_ADX) {\n\n            st->codec->bits_per_coded_sample = 18 * 8 / 32;\n\n            st->codec->block_align = st->codec->channels * 18;\n\n        } else {\n\n            st->codec->bits_per_coded_sample = film->audio_bits;\n\n            st->codec->block_align = st->codec->channels *\n\n                st->codec->bits_per_coded_sample / 8;\n\n        }\n\n\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample;\n\n    }\n\n\n\n    /* load the sample table */\n\n    if (avio_read(pb, scratch, 16) != 16)\n\n        return AVERROR(EIO);\n\n    if (AV_RB32(&scratch[0]) != STAB_TAG)\n\n        return AVERROR_INVALIDDATA;\n\n    film->base_clock = AV_RB32(&scratch[8]);\n\n    film->sample_count = AV_RB32(&scratch[12]);\n\n    if(film->sample_count >= UINT_MAX / sizeof(film_sample))\n\n        return -1;\n\n    film->sample_table = av_malloc(film->sample_count * sizeof(film_sample));\n\n    if (!film->sample_table)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for(i=0; i<s->nb_streams; i++)\n\n        av_set_pts_info(s->streams[i], 33, 1, film->base_clock);\n\n\n\n    audio_frame_counter = 0;\n\n    for (i = 0; i < film->sample_count; i++) {\n\n        /* load the next sample record and transfer it to an internal struct */\n\n        if (avio_read(pb, scratch, 16) != 16) {\n\n            av_free(film->sample_table);\n\n            return AVERROR(EIO);\n\n        }\n\n        film->sample_table[i].sample_offset =\n\n            data_offset + AV_RB32(&scratch[0]);\n\n        film->sample_table[i].sample_size = AV_RB32(&scratch[4]);\n\n        if (AV_RB32(&scratch[8]) == 0xFFFFFFFF) {\n\n            film->sample_table[i].stream = film->audio_stream_index;\n\n            film->sample_table[i].pts = audio_frame_counter;\n\n            film->sample_table[i].pts *= film->base_clock;\n\n            film->sample_table[i].pts /= film->audio_samplerate;\n\n\n\n            if (film->audio_type == CODEC_ID_ADPCM_ADX)\n\n                audio_frame_counter += (film->sample_table[i].sample_size * 32 /\n\n                    (18 * film->audio_channels));\n\n            else\n\n                audio_frame_counter += (film->sample_table[i].sample_size /\n\n                    (film->audio_channels * film->audio_bits / 8));\n\n        } else {\n\n            film->sample_table[i].stream = film->video_stream_index;\n\n            film->sample_table[i].pts = AV_RB32(&scratch[8]) & 0x7FFFFFFF;\n\n            film->sample_table[i].keyframe = (scratch[8] & 0x80) ? 0 : 1;\n\n        }\n\n    }\n\n\n\n    film->current_sample = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 14612, "substitutes": {"s": ["sys", "ses", "m", "series", "t", "service", "sg", "ins", "fs", "l", "sed", "a", "g", "cs", "S", "os", "si", "js", "sq", "sit", "v", "ss", "sim", "p", "e", "se", "http", "sf", "sb", "f", "spec", "c", "setup", "sc", "sci", "sv", "sl", "services", "ds", "sie", "sa", "su", "ls", "sis", "ts", "support", "sav", "sports"], "ap": ["aram", "hp", "amp", "ai", "pac", "api", "pak", "sp", "app", "aps", "bp", "pa", "arp", "au", "wp", "att", "ab", "am", "ac", "ams", "cap", "attr", "pi", " p", "ar", "al", "ppa", "tp"], "film": ["software", "fl", "conference", "inf", "fiction", "audio", "image", "food", "international", "kel", "fp", "avi", "drive", "web", "media", "kl", "temp", "pl", "cel", "play", "list", "starter", "life", "control", "spec", "cell", "coat", "fen", "plug", "fuel", "iv", "lc", "front", "movie", "tv", "lib", "crew", "fi", "ideo", "length", "cover", "production", "design", "lamm", "izzle", "el", "lv", "material", "oper", "iva", "iol", "edit", "config", "fb", "vic", "tt", "document", "ll", "http", "inyl", "flash", "internet", "f", "feature", "diff", "league", "music", "load", "icc", "sell", "video", "bug", "videos", "director", "liv", "l", "player", "die", "fact", "azine", "v", "sil", "Film", "rol", "redd", "technology", "ell", "sci", "ogg", "coll", "vc", "voice"], "pb": ["xb", "bc", "amp", "pc", "jp", "bb", "mp", "fb", "vp", "pt", "api", "prot", "ub", "lc", "pg", "audio", "hub", "lp", "buffer", "txt", "kk", "fp", "platform", "bp", "pd", "np", "summary", "params", "plugin", "p", "ctx", "rb", "pa", "pl", "sb", "wb", "verb", "gb", "bh", "ab", "pm", "bps", "afi", "cb", "sc", "eb", "rob", "PB", "dp", "cp", "abb", "db", "lb", "prop", "ppa", "fc", "tp", "cpp", "asm"], "st": ["sta", "amp", "put", "pt", "sp", "ste", "std", "sw", "sth", "ct", "ss", "cr", "bl", "ST", "sb", "est", "inst", "St", "sn", "stim", "sc", "sl", "ast", "sa", "rest", "src", "sts", "ost"], "scratch": ["shraper", "shratch", " Schematic", "scraper", " scenario", "eschematic", "bcatter", " scattering", "cratter", " scenge", "straper", " scrraw", "ucash", "descreenshot", " scattered", "oscraped", "crratch", "ucrub", "shash", "cleraped", " scatter", "scenario", "cradle", "chhematic", "cleratch", "scattering", "clresh", "scenge", "chenge", "SCratch", "scheatter", "SCraped", "descrub", "cleattered", "stattered", "scresh", "shraped", "scrub", " scraped", "chresh", " screenshot", "deschematic", " schematic", "escatter", " scraper", " scrratch", "clratch", " scresh", "escreenshot", "straw", "escattered", "oscratch", " scash", "escratch", "bcratch", "scheratch", "escrub", "scadle", " Scresh", "scraped", "scheash", "crreenshot", " unscenario", "oscraw", "clrub", "descratch", "escresh", " unscattering", "cleraper", "schereenshot", "scattered", "scraw", "scash", "shrub", " scrub", "bcash", "clreenshot", "screenshot", "clash", "shattered", "schematic", "ucratch", " scrresh", "escadle", " scrraper", "scopeenario", "scatter", " Scenge", "scoperatch", " unscratch", "escash", "ucraped", " scadle", "stratch", " Scratch", "SCrub", "straped", "oscattered", "scopeattering", "oscraper", "stresh", "chratch", "oscresh", "bcreenshot", "SCash"], "i": ["ui", "m", "I", "d", "ai", "batch", "id", "iu", "a", "ci", "ii", "v", "z", "p", "e", "info", "li", "b", "j", "n", "f", "ti", "ip", "c", "is", "pi", "abi", "index"], "data_offset": ["data_count", "data_pos", "data_position", "sample_count", " data_length", "data_address", "sample_size", "sample_pos", "data_size", " data_address", "sample_offset", " data_position", "data_length"], "audio_frame_counter": ["audio_frames_offset", "audio_frame_count", "audio_frames_counter", "audio_frame_offset", "audio_frames_num", "audio_frames_count", "audio_frame_num"]}}
{"project": "FFmpeg", "commit_id": "d9051f8f3e60768f68867c3e3116e980d855215a", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639, "substitutes": {"ctx": ["support", " context", "context", "tx", "cam", "bc", "cm", "qa", "pkg", "cv", "ca", "sync", "config", "pc", "cc", "utils", "Context", "connection", "ctrl", "ci", "cs", "lc", "conv", "kernel", "cn", "cms", "wcs", "cmp", "sq", "fp", "loc", "ct", "conf", "conn", "client", "kw", "cli", "nc", "ck", "tc", "cus", "concept", "rx", "gb", "cfg", "c", "cca", "crit", "cu", "anc", "cb", "cas", "sci", "sc", "cmd", "cf", "cp", "que", "kb", "exec", "xc", "cache", "css", "prefix", "fc", "hw", "cpp"], "num_coeffs": ["num_coefficientp", "num_COeffp", "num_coefficients", "num_coeffi", "num_coefficientss", "num_coefficientsi", "num_coeffp", "num_COeffd", "num_coeffes", "num_coffd", "num_coefficientsp", "num_coefes", "num_coefficientses", "num_coefp", "num_coffs", "num_coffp", "num_coffi", "num_coeffd", "num_coffes", "num_COffes", "num_COffp", "num_COffd", "num_coefficientes", "num_COeffs", "num_coefficientsd", "num_coefi", "num_COeffes", "num_coefficientd", "num_coefs", "num_COffs"], "qscale": [" qcale", " qScale", "bitnorm", "bitcale", "qScale", "kScale", "bitdata", "qudata", " qnorm", "quscale", " qdata", "qnorm", "Qscale", "qcale", "qucale", "kcale", "qdata", "kscale", "QScale", "Qcale", "bitscale", "qunorm"], "block": ["channel", "map", "record", "board", "blocks", "bin", "tx", "bc", "slice", "batch", "bb", "object", "label", "pre", "range", "row", "Block", "image", "section", "panel", "pool", "ref", "buffer", "unit", "position", "comment", "session", "error", "table", "frame", "job", "chain", "bar", "group", "clean", "dict", "pack", "buf", "b", "byte", "base", "bit", "length", "box", "list", "point", "line", "address", "flow", "number", "type", "bo", "layout", "cache", "work", "lock", "bl", "node"], "pos": ["port", "part", "slot", "po", "slice", "pc", "val", "i", "pt", "style", "def", "ass", "cond", "nos", " position", "sp", "pose", "os", "x", "ref", "unit", "post", "position", "loc", "pres", "POS", "pid", "conf", "limit", "col", "obj", "pass", "size", "p", "comp", "pointer", "axis", "base", "min", "j", "length", "opp", "n", "f", "padding", "spec", "neg", "diff", "type", "offset", "pro", "rot", "Pos", "prop", "no", "num", "rel", "len", "index", "start"], "vlc": ["vlci", "lipc", "llcs", "wlp", "vllc", "klcs", "lvcs", "nlc", "wlf", "nlcs", "nlce", "kllc", "lvcu", "lvlc", "liplc", "velci", "wlac", "lvf", "llci", "svci", "klce", "vlrc", "velc", "vlf", "svc", "wlci", "lvci", "lllc", "vlcs", "velf", "lvp", "vlcu", "llce", "wllc", "llc", "lipcs", "velcs", "lipcu", "llrc", "lvrc", "vlct", "wlcs", "nlct", "llf", "klct", "klc", "velp", "llcu", "llct", "svcs", "vlce", "vlp", "llac", "lvac", "vlac", "svrc", "klf", "wlc", "llp", "lvc"], "num_bits": ["max_details", " num_bit", "num_flags", "num_locks", " num_points", "num_points", "numlogbit", "max_parts", "numloglocks", " num_flags", "num_parts", "num__bits", "num__locks", " num_locks", "num_bs", " num_bs", "numlogbits", "num_bytes", "numlogpoints", "numLhours", "num_details", "numLflags", "numLbits", "num_hours", "numLbit", "num_bit", "max_bits", " num_hours", " num_bytes", "num__bit", "num__points", "max_bit"], "value": ["port", "val", "object", "child", "current", "range", "name", "values", "VALUE", "image", "weight", "null", "unit", "position", "total", "comment", "key", "valid", "v", "limit", "wave", "size", "dev", "version", "cost", "Value", "sec", "data", "length", "flow", "address", "number", "start", "type", "offset", "function", "scale", "field", "num", "len", "max", "index", "message"], "coeff": ["microefficient", "COef", "noefficient", "colleffect", "coff", "collef", "COefficient", " coff", "Coff", "opeffect", "corort", "cef", "coref", "opeff", "collefficient", "Coef", "noef", "coefficient", "coef", "COff", "microeffect", "microef", "Coort", "coeffect", "ceff", "noff", "opef", "coort", "opefficient", "microeff", "noeff", "colleff", "cff", "Coeffect", "coreffect", "Coefficient", " coefficient", " coeffect", "Coeff", "COeff", "coreff", " coef", "cefficient", " coort"]}}
{"project": "FFmpeg", "commit_id": "87e302bfd8ffbc6cdb20920029013956b10ace63", "target": 0, "func": "static int svq3_decode_frame(AVCodecContext *avctx,\n\n                             void *data, int *data_size,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MpegEncContext *const s = avctx->priv_data;\n\n    H264Context *const h = avctx->priv_data;\n\n    int m, mb_type;\n\n\n\n    /* special case for last picture */\n\n    if (buf_size == 0) {\n\n        if (s->next_picture_ptr && !s->low_delay) {\n\n            *(AVFrame *) data = *(AVFrame *) &s->next_picture;\n\n            s->next_picture_ptr = NULL;\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    init_get_bits (&s->gb, buf, 8*buf_size);\n\n\n\n    s->mb_x = s->mb_y = h->mb_xy = 0;\n\n\n\n    if (svq3_decode_slice_header(h))\n\n        return -1;\n\n\n\n    s->pict_type = h->slice_type;\n\n    s->picture_number = h->slice_num;\n\n\n\n    if (avctx->debug&FF_DEBUG_PICT_INFO){\n\n        av_log(h->s.avctx, AV_LOG_DEBUG, \"%c hpel:%d, tpel:%d aqp:%d qp:%d, slice_num:%02X\\n\",\n\n               av_get_pict_type_char(s->pict_type), h->halfpel_flag, h->thirdpel_flag,\n\n               s->adaptive_quant, s->qscale, h->slice_num);\n\n    }\n\n\n\n    /* for hurry_up == 5 */\n\n    s->current_picture.pict_type = s->pict_type;\n\n    s->current_picture.key_frame = (s->pict_type == FF_I_TYPE);\n\n\n\n    /* Skip B-frames if we do not have reference frames. */\n\n    if (s->last_picture_ptr == NULL && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip B-frames if we are in a hurry. */\n\n    if (avctx->hurry_up && s->pict_type == FF_B_TYPE)\n\n        return 0;\n\n    /* Skip everything if we are in a hurry >= 5. */\n\n    if (avctx->hurry_up >= 5)\n\n        return 0;\n\n    if (  (avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == FF_B_TYPE)\n\n        ||(avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != FF_I_TYPE)\n\n        || avctx->skip_frame >= AVDISCARD_ALL)\n\n        return 0;\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == FF_B_TYPE)\n\n            return 0;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (frame_start(h) < 0)\n\n        return -1;\n\n\n\n    if (s->pict_type == FF_B_TYPE) {\n\n        h->frame_num_offset = (h->slice_num - h->prev_frame_num);\n\n\n\n        if (h->frame_num_offset < 0) {\n\n            h->frame_num_offset += 256;\n\n        }\n\n        if (h->frame_num_offset == 0 || h->frame_num_offset >= h->prev_frame_num_offset) {\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"error in B-frame picture id\\n\");\n\n            return -1;\n\n        }\n\n    } else {\n\n        h->prev_frame_num = h->frame_num;\n\n        h->frame_num = h->slice_num;\n\n        h->prev_frame_num_offset = (h->frame_num - h->prev_frame_num);\n\n\n\n        if (h->prev_frame_num_offset < 0) {\n\n            h->prev_frame_num_offset += 256;\n\n        }\n\n    }\n\n\n\n    for (m = 0; m < 2; m++){\n\n        int i;\n\n        for (i = 0; i < 4; i++){\n\n            int j;\n\n            for (j = -1; j < 4; j++)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= 1;\n\n            if (i < 3)\n\n                h->ref_cache[m][scan8[0] + 8*i + j]= PART_NOT_AVAILABLE;\n\n        }\n\n    }\n\n\n\n    for (s->mb_y = 0; s->mb_y < s->mb_height; s->mb_y++) {\n\n        for (s->mb_x = 0; s->mb_x < s->mb_width; s->mb_x++) {\n\n            h->mb_xy = s->mb_x + s->mb_y*s->mb_stride;\n\n\n\n            if ( (get_bits_count(&s->gb) + 7) >= s->gb.size_in_bits &&\n\n                ((get_bits_count(&s->gb) & 7) == 0 || show_bits(&s->gb, (-get_bits_count(&s->gb) & 7)) == 0)) {\n\n\n\n                skip_bits(&s->gb, h->next_slice_index - get_bits_count(&s->gb));\n\n                s->gb.size_in_bits = 8*buf_size;\n\n\n\n                if (svq3_decode_slice_header(h))\n\n                    return -1;\n\n\n\n                /* TODO: support s->mb_skip_run */\n\n            }\n\n\n\n            mb_type = svq3_get_ue_golomb(&s->gb);\n\n\n\n            if (s->pict_type == FF_I_TYPE) {\n\n                mb_type += 8;\n\n            } else if (s->pict_type == FF_B_TYPE && mb_type >= 4) {\n\n                mb_type += 4;\n\n            }\n\n            if (mb_type > 33 || svq3_decode_mb(h, mb_type)) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"error while decoding MB %d %d\\n\", s->mb_x, s->mb_y);\n\n                return -1;\n\n            }\n\n\n\n            if (mb_type != 0) {\n\n                hl_decode_mb (h);\n\n            }\n\n\n\n            if (s->pict_type != FF_B_TYPE && !s->low_delay) {\n\n                s->current_picture.mb_type[s->mb_x + s->mb_y*s->mb_stride] =\n\n                    (s->pict_type == FF_P_TYPE && mb_type < 8) ? (mb_type - 1) : -1;\n\n            }\n\n        }\n\n\n\n        ff_draw_horiz_band(s, 16*s->mb_y, 16);\n\n    }\n\n\n\n    MPV_frame_end(s);\n\n\n\n    if (s->pict_type == FF_B_TYPE || s->low_delay) {\n\n        *(AVFrame *) data = *(AVFrame *) &s->current_picture;\n\n    } else {\n\n        *(AVFrame *) data = *(AVFrame *) &s->last_picture;\n\n    }\n\n\n\n    avctx->frame_number = s->picture_number - 1;\n\n\n\n    /* Do not output the last pic after seeking. */\n\n    if (s->last_picture_ptr || s->low_delay) {\n\n        *data_size = sizeof(AVFrame);\n\n    }\n\n\n\n    return buf_size;\n\n}\n", "idx": 14654, "substitutes": {"avctx": ["ausync", "afcv", "ajcu", "avlc", "aflc", "avhw", "navctx", "afsc", "AVcf", "afconfig", "avcam", "navcoll", "avesync", "avcu", "avecoll", "avesc", "avecontext", "navcontext", "avconfig", "avctl", "AVconfig", "afconn", "aucontext", "ajcontext", "avcv", "aphctx", "apcontext", "afcam", "afcf", "AVcontext", "avectx", "avsc", "afcu", "afsync", "AVconn", "afcontext", "avcoll", "avcn", "aphlc", "aplc", "avconn", "avloc", "aucn", "auloc", "avcf", "vercoll", "avecu", "vercontext", "AVsc", "aphctl", "avsync", "AVlib", "ajctx", "aveconfig", "aveloc", "afloc", "verctx", "avecf", "navcf", "afctx", "afctl", "afcoll", "avlib", "aphcontext", "navhw", "AVhw", "apctl", "afcn", "aflib", "avecv", "afhw", "apctx", "verconn", "avelib", "ajcam", "avecam", "auctx", "aucv", "avcontext", "aveconn", "navconn", "AVctx", "avecn"], "data": ["slice", "queue", "d", "input", "batch", "config", "rc", "val", "code", "memory", "da", "uf", "audio", "image", "bytes", "buffer", "v", "frame", "buff", "value", "meta", "w", "size", "media", "la", "p", "img", "info", "picture", "base", "reader", "length", "f", "result", "read", "dat", "frames", "block", "next", "feed", "Data", "body", "DATA", "cache", "video", "content", "window", "pad", "start"], "data_size": ["buffer_scale", "data_time", "buffer_speed", "buffer_size", "buf_size", "data__scale", "buf_capacity", "data_speed", "data_scale", "data__size", "data__speed", "data_capacity", "buf_name", "buffer_time", "data__time", "data_name"], "avpkt": ["afpct", "avpfx", "afpkg", "avpKT", "avvpk", " avpKT", "afpkl", "avcpKT", "avlpkl", "avpkl", "avpct", " avvpkg", "avprct", "avfkt", "avlpkg", "afcpct", "avfkl", "avcpfx", " avvpk", "avfacket", "affkg", "afcpkt", "affkt", " avpkg", "avcKT", "avcpkg", "avPkt", "affkl", "avvpkg", " avpk", "avlpkt", "afpacket", "avlpacket", " avvpkt", "afcpfx", " avvpKT", "afcpacket", "avpacket", "avprkt", "avcpkt", "avcpk", "avckg", "affacket", "avprfx", "avfkg", "avck", "avvpkt", "avfct", "avckt", "avPacket", "avpracket", "avPkl", "avffx", "avPkg", "avcpct", "avpk", "afpfx", "avpkg", "afpkt", "avvpKT", "avcpacket"], "buf": ["map", "vec", "port", "ff", "uc", "bc", "queue", "fd", "array", "cv", "tmp", "batch", "config", "fb", "uf", "buffer", "bag", "v", "br", "buff", "p", " buffer", "img", "rb", "fi", "b", "f", "block", "cb", "cap", "cas", "aux", "cache", "src", "seq", "num", "prop", "pad", "len", "ctx", "alloc"], "s": ["hes", "rs", "qs", "new", "words", "si", "js", "ps", "share", "spec", "c", "is", "sv", "sl", "aws", "args", "self", "d", "sync", "t", "sg", "fs", "ins", "sym", "g", "cs", "uses", "es", "full", "sum", "session", "w", "u", "b", "ns", "ops", "r", "sa", "ks", "sys", "parts", "service", "has", "hs", "os", "sets", "o", "ms", "e", "options", "sb", "features", "f", "ans", "services", "sh", "ls", "comments", "ctx", "ses", "as", "ys", "l", "a", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "request", "p", "n", "gs", "xs", "ssl", "ds", "su", "css", "ts", "us", "vs", "y"], "h": ["dh", "hi", "ch", "hp", "ha", "hl", "d", "oh", "ih", "hr", "l", "home", "ah", "g", "hs", "gh", "hash", "v", "rh", "kh", "o", "uh", "w", "hh", "u", "z", "p", "e", "y", "he", "eh", "http", "k", "b", "han", "n", "f", "th", "hm", "bh", "c", "ht", "q", "r", "H", "sh", "hd", "zh", "history", "host", "his", "him", "hist", "ph", "header", "hw"], "m": [" cm", " f", " mode", "slot", "d", "id", "code", " c", " d", "g", " dim", "p", "img", "b", "mode", "f", "n", "c", " chunk", " w", "type", " u", " p", "r", "src", " bi"], "mb_type": ["photo_name", "photo_types", "mb_name", "mb_types", "photo_size", "photo_type", "mb_size"], "mb_y": ["mbJy", "mbJya", "mb_ya", "mbJx", "MB_x", "MB_ye", "mbJye", "mb_ye", "MB_y", "MB_ya"], "mb_x": ["mb_xy", "mbIdx", "emb_y", "mbIdxy", "mbIdsize", "emb_xy", "emb_size", "mbIdy", "emb_x", "mb_size"]}}
{"project": "FFmpeg", "commit_id": "b12d92efd6c0d48665383a9baecc13e7ebbd8a22", "target": 1, "func": "static av_cold int rl2_decode_init(AVCodecContext *avctx)\n\n{\n\n    Rl2Context *s = avctx->priv_data;\n\n    int back_size;\n\n    int i;\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n    avcodec_get_frame_defaults(&s->frame);\n\n\n\n    /** parse extra data */\n\n    if(!avctx->extradata || avctx->extradata_size < EXTRADATA1_SIZE){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid extradata size\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** get frame_offset */\n\n    s->video_base = AV_RL16(&avctx->extradata[0]);\n\n    s->clr_count = AV_RL32(&avctx->extradata[2]);\n\n\n\n    if(s->video_base >= avctx->width * avctx->height){\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid video_base\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /** initialize palette */\n\n    for(i=0;i<AVPALETTE_COUNT;i++)\n\n        s->palette[i] = 0xFF << 24 | AV_RB24(&avctx->extradata[6 + i * 3]);\n\n\n\n    /** decode background frame if present */\n\n    back_size = avctx->extradata_size - EXTRADATA1_SIZE;\n\n\n\n    if(back_size > 0){\n\n        unsigned char* back_frame = av_mallocz(avctx->width*avctx->height);\n\n        if(!back_frame)\n\n            return -1;\n\n        rl2_rle_decode(s,avctx->extradata + EXTRADATA1_SIZE,back_size,\n\n                           back_frame,avctx->width,0);\n\n        s->back_frame = back_frame;\n\n    }\n\n    return 0;\n\n}\n", "idx": 14658, "substitutes": {"avctx": ["AVkw", "ajcu", "ajclient", "avlc", "verca", "ajscope", "vertx", "avcas", "aflc", "avhw", "verscope", "navctx", "avalctrl", "afconfig", "AVcf", "vercf", "avcam", "afclient", "avecci", "avesync", "avcu", "ajcn", " avcontext", "vercn", "avecmp", "ajtx", " avcci", "avecontext", "ajlib", "navcontext", "avconfig", "avalci", "avctl", "alpkg", "afcas", "afconn", " avlc", "avca", "ajcontext", "afcf", "alcam", " avconfig", "AVcontext", "avecup", "avectx", "ajkw", "afcu", "afsync", "AVconn", "afcontext", "avecas", "avectl", "avehw", "avcn", "navloc", "afqa", "AVpkg", "avconn", "avloc", "afci", "ajcmp", " avcas", " avcu", "avctrl", "avscope", "avkw", "avci", "avcf", "avalqa", "avecu", "vercontext", "aveca", "afcup", "avtx", "avsync", "ajctx", "ajctrl", "aveconfig", "aveci", "aveloc", "afloc", "verctx", "avecf", "avcup", "afctx", "afctl", "afcci", "avcci", "alcontext", "ajcf", "avlib", "avalconn", "avalcup", "avalctl", "avclient", "ajqa", "AVcmp", "avcmp", "AVhw", "avekw", "avalcu", "avelc", "afcn", "ajsync", "AVcu", "aflib", "afcmp", "avqa", "aveclient", "avalcontext", "ajconn", "verconn", "AVscope", "ajcam", "avelib", "avalctx", "navconfig", "avcontext", " avhw", "aveconn", "afca", "AVcam", " avconn", "AVctx", "alctx", "avpkg", "afctrl", "ajpkg", "AVtx"], "s": ["sys", "ses", "self", "m", "service", "t", "d", "sync", "sg", "fs", "l", "rs", "sym", "a", "g", "cs", "qs", "S", "hs", "sk", "os", "h", "sets", "js", "si", "es", "sq", "session", "server", "v", "ps", "ss", "conf", "client", "o", "w", "u", "p", "e", "sec", "se", "b", "sb", "nas", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "ssl", "sv", "sl", "ops", "services", "ds", "r", "sa", "su", "ls", "ts", "us", "ctx", "ks", "aws"], "back_size": ["back_storage", "back__code", "back_code", " back_storage", "backFcode", "back_capacity", " back__address", " back_name", "right_size", " back__code", " back_scale", "back_use", "back_scale", "right_capacity", " back_address", " back_ize", "back_small", " back_use", "back_key", " back__name", "right_small", " back_code", "back__name", "backFname", " back_key", "back_address", " back__size", "backFaddress", "back__size", "back__address", "back_fee", "back_ize", "right_fee", "back_name", "backFsize"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "mu", "ci", "h", "x", "di", "si", "ii", "v", "uri", "yi", "u", "z", "p", "e", "fi", "cli", "li", "k", "b", "ix", "multi", "j", "count", "phi", "n", "ti", "ip", "c", "ji", "pi", "bi", "ri", "zi", "y", "index"], "back_frame": ["back__slice", " back_zip", "back_slice", "back_sector", "backingdata", " back__frame", "backboardsector", "forwardlogframe", "front_size", "back__zip", "backlogdata", "forwardlogsequence", " back_scale", "forward_frame", "forward_sector", "back_zip", " back__slice", " back_slice", "back_scale", "backingsector", "back_data", "back__scale", "front_line", "backacelement", " back_hole", "backacsize", "back_line", " back__scale", "backacframe", "back_element", "backlogsequence", " back_element", "backxframe", "backxsize", "backingsequence", "back__frame", "forwardlogdata", "backxhole", "back_hole", "backingframe", "backboardframe", "backxscale", "backboarddata", "front_frame", " back__zip", "backlogsector", "backlogframe", "forward_sequence", "forwardlogsector", "back_sequence", "backboardsequence", "forward_data"]}}
{"project": "FFmpeg", "commit_id": "01a33b835f7a9e135eb8c7b7dd98c8b89f15dea1", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 14665, "substitutes": {"s": ["sys", "ses", "m", "bis", "parts", "series", "self", "service", "sync", "sg", "ins", "your", "fs", "l", "t", "rs", "sym", "i", "g", "cs", "qs", "S", "settings", "os", "sets", "js", "es", "scope", "sq", "si", "ps", "conf", "ss", "sim", "u", "p", "se", "e", "share", "cli", "site", "f", "sche", "frames", "gs", "gb", "spec", "c", "ns", "setup", "is", "sc", "ssl", "sv", "ops", "services", "ds", "ls", "ts", "space", "vs", "cpp"], "frame": ["pse", "draw", "m", "Frame", "slice", "fram", "series", "fl", "iframe", "object", "framework", "motion", "image", "panel", "game", "sequence", "flower", "rame", "o", "element", "dy", "document", "p", "e", "fi", "data", "f", "flow", "line", "frames", "state", "feature", "fe", "setup", "file", "ov", "scale", "cf", "coll", "figure", "window", "scene"], "value": ["action", "m", "after", "shift", "val", "object", "range", "values", "weight", "image", "VALUE", "update", "position", "total", "v", "limit", "w", "view", "wave", "size", "version", "media", "cost", "z", "Value", "p", "data", "rate", "b", "mask", "result", "flow", "feature", "parent", "number", "start", "end", "offset", "function", "change", "one", "scale", "write", "age", "window", "num", "depth", "message"], "run": ["repeat", "head", "day", "sync", "trial", "config", "id", "un", "orig", "spin", "ride", "row", "Run", "image", "use", "unit", "con", "limit", "race", "step", "win", "pass", "version", "keep", "max", "rate", "k", "min", "running", "n", "f", "c", "block", "plot", "loop", "q", "scale", "write", "man", "r", "cycle", "runs", "lock", "num", "depth", "len", "round", "thread", "bit", "index"], "x": ["m", "t", "l", "i", "pixel", "a", "ex", "image", "h", "px", "v", "w", "dy", "dx", "size", "z", "u", "p", "e", "time", "data", "ix", "axis", "b", "page", "n", "f", "xx", "line", "ax", "c", "X", "q", "xc", "xy", "pos", "bit", "index"], "y": ["ny", "m", "t", "sky", "xi", "l", "i", "iy", "ey", "g", "h", "py", "cy", "gy", "ye", "v", "o", "col", "dy", "w", "yi", "z", "u", "p", "e", "k", "b", "yo", "n", "f", "oy", "c", "vy", "ay", "type", "pi", "Y", "ya", "ky", "xy", "yy", "ty", "zy", "sy"], "plane": ["charge", "port", "planes", "board", "m", "pen", "day", "slice", "fl", "xi", "level", "row", "g", "flat", "image", "weight", "plan", "unit", "module", "position", "key", "force", "limit", "o", "clip", "orient", "group", "zone", "ane", "z", "p", "u", "e", "size", "direction", "se", "k", "axis", "page", "rate", "mode", "mask", "f", "flow", "line", "fly", "pin", "pe", "plot", "drop", "scale", "q", "lane", "den", "age", "order", "core", "rot"], "bits_per_plane": ["bits_per_lane", "bits_per_plan", "bits_per\u00b7month", "bits_PER_plate", "bits_per\u00b7line", "bits_per_line", "bits_per_month", "bits_per_space", "bits_PER_line", "bits_per_fly", "bits_per_planes", "bits_per\u00b7plane", "bits_PER_plane", "bits_PER_lane", "bits_per_flight", "bits_per_plate", "bits_pervplane", "bits_per_band", "bits_pervfly", "bits_pervspace", "bits_pervlane", "bits_per\u00b7flight"], "d": ["D", "dh", "m", "fd", "t", "l", "i", "g", "dl", "h", "di", "v", "o", "w", "dy", "dx", "z", "u", "ad", "p", "e", "dict", "k", "data", "b", "sd", "n", "f", "dat", "diff", "c", "df", "dt", "dc", "md", "q", "dp", "ds", "dd", "dn", "dim"], "j": ["jj", "adj", "uj", "m", "ch", "aj", "part", "t", "ni", "xi", "jp", "ja", "i", "l", "io", "g", "dj", "section", "h", "jet", "ie", "js", "v", "job", "fr", "o", "dy", "obj", "z", "ind", "jit", "p", "u", "e", "li", "k", "b", "n", "f", "ip", "jo", "jl", "ne", "ji", " i", "q", "J", "xy", "lock", "el", "dim", "ij", "start"]}}
{"project": "FFmpeg", "commit_id": "f61d44b74aaae1d306d8a0d38b7b3d4292c89ced", "target": 0, "func": "static inline void silk_stabilize_lsf(int16_t nlsf[16], int order, const uint16_t min_delta[17])\n\n{\n\n    int pass, i;\n\n    for (pass = 0; pass < 20; pass++) {\n\n        int k, min_diff = 0;\n\n        for (i = 0; i < order+1; i++) {\n\n            int low  = i != 0     ? nlsf[i-1] : 0;\n\n            int high = i != order ? nlsf[i]   : 32768;\n\n            int diff = (high - low) - (min_delta[i]);\n\n\n\n            if (diff < min_diff) {\n\n                min_diff = diff;\n\n                k = i;\n\n\n\n                if (pass == 20)\n\n                    break;\n\n            }\n\n        }\n\n        if (min_diff == 0) /* no issues; stabilized */\n\n            return;\n\n\n\n        /* wiggle one or two LSFs */\n\n        if (k == 0) {\n\n            /* repel away from lower bound */\n\n            nlsf[0] = min_delta[0];\n\n        } else if (k == order) {\n\n            /* repel away from higher bound */\n\n            nlsf[order-1] = 32768 - min_delta[order];\n\n        } else {\n\n            /* repel away from current position */\n\n            int min_center = 0, max_center = 32768, center_val;\n\n\n\n            /* lower extent */\n\n            for (i = 0; i < k; i++)\n\n                min_center += min_delta[i];\n\n            min_center += min_delta[k] >> 1;\n\n\n\n            /* upper extent */\n\n            for (i = order; i > k; i--)\n\n                max_center -= min_delta[k];\n\n            max_center -= min_delta[k] >> 1;\n\n\n\n            /* move apart */\n\n            center_val = nlsf[k - 1] + nlsf[k];\n\n            center_val = (center_val >> 1) + (center_val & 1); // rounded divide by 2\n\n            center_val = FFMIN(max_center, FFMAX(min_center, center_val));\n\n\n\n            nlsf[k - 1] = center_val - (min_delta[k] >> 1);\n\n            nlsf[k]     = nlsf[k - 1] + min_delta[k];\n\n        }\n\n    }\n\n\n\n    /* resort to the fall-back method, the standard method for LSF stabilization */\n\n\n\n    /* sort; as the LSFs should be nearly sorted, use insertion sort */\n\n    for (i = 1; i < order; i++) {\n\n        int j, value = nlsf[i];\n\n        for (j = i - 1; j >= 0 && nlsf[j] > value; j--)\n\n            nlsf[j + 1] = nlsf[j];\n\n        nlsf[j + 1] = value;\n\n    }\n\n\n\n    /* push forwards to increase distance */\n\n    if (nlsf[0] < min_delta[0])\n\n        nlsf[0] = min_delta[0];\n\n    for (i = 1; i < order; i++)\n\n        if (nlsf[i] < nlsf[i - 1] + min_delta[i])\n\n            nlsf[i] = nlsf[i - 1] + min_delta[i];\n\n\n\n    /* push backwards to increase distance */\n\n    if (nlsf[order-1] > 32768 - min_delta[order])\n\n        nlsf[order-1] = 32768 - min_delta[order];\n\n    for (i = order-2; i >= 0; i--)\n\n        if (nlsf[i] > nlsf[i + 1] - min_delta[i+1])\n\n            nlsf[i] = nlsf[i + 1] - min_delta[i+1];\n\n\n\n    return;\n\n}\n", "idx": 14673, "substitutes": {"nlsf": ["unlesc", "nnsc", " nnsf", "nlsform", "ncsp", "nlesb", "npsb", "nbsfs", "nfsf", "llsfs", "nlsif", "unlesif", " nlsp", "ncsb", "nnsb", "nlsfb", "nailsc", "unlesf", " ncsfe", "nolsfa", "NLSv", "nLSv", "ncsif", " ncsf", "nlesv", "numsp", "lnsp", "nfsfb", "Nlsfs", "solsfa", "nnsfa", "ynlsv", "ynlsb", "nLSfb", "NLSform", "solsfs", " nfsf", "NLSc", "ncsv", "nrsf", "nmesfc", "nbsf", "nlsconf", " nfsfb", "nlasfs", "NLSf", " ncsp", "nailsfx", "nLSp", "nlasconf", "nmesf", "llsp", "unlsif", "nolsc", "NLSfs", "nolsfs", "nLSc", "nLSfs", "unlesb", "nlsb", "numsfe", "npsfb", " nailsf", "nrsb", "llsf", " nfsfs", "ncsfs", "ncsfc", "solsf", "llsv", "nLSform", "nnsp", "nlsfa", "nbsconf", "ynlesb", "solsp", "nlsfo", "slsp", "lnsf", "nfsfa", "Nlsc", " nnsfe", " nlsfc", "nailsfs", "nLSfe", "nrsfs", "ncsform", " nlsfx", "nlsc", "nrsc", "ncsfe", " ncsfc", "nbsb", " nailsfx", "nlsp", "nLSfx", "slsfs", "lnsfs", "nailsp", " nlsv", "npsf", " nlsfb", "NLSb", "nailsform", "ynlesf", " nlsfe", "Nlsform", "nlesif", "Nlsconf", "nlsfc", " nailsc", "nLSfc", "nLSif", "nnsv", "ngsfo", " nlsb", "nnsfs", "ncsc", "nLSfo", "nolsf", "nolsfx", "nrsv", "Nlsf", "nlsv", "nailsf", "lnsv", "nailsb", "Nlsfo", " ncsv", "nlsfe", "nLSb", "nnsfe", "lnsc", "nLSf", "NLSfo", "numsf", "nlesc", "llsc", "nfsb", "nlasb", "nailsv", "nfsfs", " ncsb", "nlasf", " nlsc", "nlesf", " nnsb", "nlasc", " nnsc", "nmesv", "Nlsv", "npsfs", "nmesb", "unlsc", "unlsf", "ngsf", "unlsb", "nLSconf", " nailsb", "nlsfx", "ngsb", "numsv", "nlsfs", " nlsfs", "slsfa", "nolsp", "ynlsc", "slsf", "nailsfo", "nolsb", "Nlsb", "nnsf", "ynlsf", " nfsb", "NLSconf", "nfsp", "ynlesc", "ncsf", "nlasfe", "ynlesv"], "order": ["level", "shape", "pre", "ko", "use", "x", "asc", "limit", "ok", "grade", "spec", "end", "offset", "iter", "here", "work", "index", "Order", "m", "ordering", "id", "seed", "acc", "dir", "error", "key", "rank", "page", "axis", "length", "inner", "ordered", "r", "round", "sort", "after", "xml", "random", "tr", "step", "element", "o", "layer", "e", "info", "block", "hop", "err", "ord", "orders", "record", "root", "ai", "code", "orig", "name", "row", "er", "sk", "user", "position", "direction", "keep", "n", "now", "rule", "scale", "all", "last", "max"], "min_delta": ["min2dDelta", "min_doiesta", "min_dselta", "min_sdota", "min_sdelta", "min_datiff", "min_adota", "min_dlux", "min_dica", "min_Dota", "min_indesh", "min_sdesh", "min_datlux", "min_datetime", "min\u00b7telta", "min\u00b7tiff", "min_sdica", "min_melt", "min_adelt", "min_melta", "min_telta", "min_dslux", "min\u00b7dota", "min_ddota", "min_Diesta", "min_data", "min2delta", "min_datata", "min_tota", "min\u00b7dta", "min_ddiff", "min_dota", "min_datota", "min_detime", "min_indynamic", "min_diff", "min_dsetime", "min_indelt", "min_Detime", "min_dielt", "min_ddelta", "min_desh", "min_delt", "min_diesta", "min_adelta", "min_Delt", "min_tiff", "min2delt", "min2sdelt", "min\u00b7delta", "min2sdelta", "min\u00b7tota", "min_dDelta", "min_sdata", "min_Dica", "min_dta", "min\u00b7diff", "min_dielta", "min_Delta", "min_diota", "min_doetime", "min_adDelta", "min_dynamic", "min_indelta", "min_mesh", "min_doelta", "min_sdelt", "min_sdynamic", "min_ddta", "min_diata", "min_datelta", "min\u00b7tta", "min_diica", "min_datDelta", "min_datta", "min_mynamic", "min_datelt", "min_DDelta", "min_adetime", "min2sdDelta", "min_sdDelta", "min_tta", "min_adiesta", "min_doota", "min_dsota"], "pass": ["path", "slice", "sync", "batch", "id", "code", "level", "PASS", "ride", "row", "lc", "act", "test", "Pass", "use", "x", "password", "acc", "key", "ss", "scan", "step", "rank", "w", "strip", "check", "parse", "stage", "p", "ok", "layer", "keep", "ck", "ask", "mode", "cross", "flow", "skip", "grade", "inc", "c", "feed", "sc", "loop", "all", "fail", "ack", "r", "pos", "push", "run", "post", "round", "index"], "i": ["my", "oi", "x", "si", "phi", "c", "is", "ji", "ami", "index", "ani", "hi", "m", "slice", "d", "xi", "id", "iu", "me", "io", "api", "lc", "g", "ki", "di", "key", "u", "jit", "fi", "b", "ti", "ip", "eni", "inner", "bi", "mu", "qi", "ni", "ini", "ci", "ie", "init", "o", "z", "e", "info", "li", "ix", "multi", "f", "diff", "ij", "it", "ui", "adi", "I", "ai", "l", "gi", "a", "ii", "uri", "v", "p", "mini", "mi", "cli", "pi", "q", "ik", "ri", "ori", "y", "start"], "k": ["ak", "cook", "level", "ko", "kick", "h", "x", "kh", "ok", "ck", "ask", "spec", "c", "end", "work", "in", "km", "ke", "dk", "kat", "kind", "m", "ek", "self", "d", "id", "g", "ki", "uk", "gh", "key", "w", "u", "s", "b", "mk", "K", "ack", "r", "ks", "ijk", "kn", "kk", "kw", "o", "scan", "element", "z", "e", "f", "block", "ph", "code", "l", "sk", "v", "p", "ku", "n", "q", "ik", "y", "max"], "center_val": ["enter_vals", " center_eval", "center_real", " center_v", "center__value", "context_val", "centerenvals", "center_bal", "centerPlen", "contextPVal", "center_v", "center_base", " center_valid", "enter_eval", "centerProt", "center_buf", "center_len", "contextProt", "centerPval", "context_rot", "context_len", "center2bal", "center___VAL", "center_eval", " center_real", "center_value", " center_buf", "centerPVal", "center_Val", " center_aval", "center_valid", "centerenVal", "contextPval", "center___valid", "center_aval", "core_value", "enter_value", "context_Val", "centerenbase", "centerjVAL", " center_value", "center_rot", "core_valid", "center___real", "center_vals", "center2val", "core_bal", "center__eval", "center_VAL", "center___bal", "centerenval", "center___rot", " center_vals", "contextPlen", "centerjVal", " center_bal", " center_Val", "center2valid", "center__val", "core_val", "centerjval", " center_VAL", "center2aval", " center_base", "center___Val", "center___len", "enter_val", "center__valid", "centerjreal", "center___aval", "center___val", "center___value"], "j": ["jj", "uj", "adj", "it", "jen", "m", "rev", "aj", "part", "d", "ja", "jp", "val", "l", "child", "a", "g", "syn", "dj", "h", "x", "other", "jet", "js", "ie", "si", "ii", "key", "v", "job", "fr", "value", "br", "o", "obj", "z", "u", "jit", "p", "e", "ind", "size", "note", "li", "b", "ix", "n", "f", "jan", "jo", "item", "next", "jl", "jc", "ji", "body", "q", "r", "J", "pos", "num", "y", "ij", "index"]}}
{"project": "qemu", "commit_id": "2e29bd04786003561303dcad940b38afe790fb9b", "target": 1, "func": "static void pci_unin_main_config_writel (void *opaque, target_phys_addr_t addr,\n\n                                         uint32_t val)\n\n{\n\n    UNINState *s = opaque;\n\n\n\n    UNIN_DPRINTF(\"config_writel addr \" TARGET_FMT_plx \" val %x\\n\", addr, val);\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    val = bswap32(val);\n\n#endif\n\n\n\n    s->config_reg = val;\n\n}\n", "idx": 14679, "substitutes": {"opaque": [" opaques", "copacity", "OPhole", "opatile", " ophole", "obatile", "OPatile", "obacity", "operacity", "opaques", "obaque", "operaque", "copaques", "opacity", "OPacity", "obhole", "operatile", "copaque", " opacity", "ophole", "OPaque", "operaques", " opatile", "copatile"], "addr": ["ord", "port", "tx", "slot", "adder", "fd", "amd", "config", "def", "prot", "align", "x", "ref", "arg", "xp", "ace", "ld", "loc", "grad", "ad", "adr", "sid", "mt", "pointer", "data", "base", "ptr", "mode", "point", "address", "offset", "attr", "rt", "host", "dd", "mac", "src", "hop", "pos", "prefix", "alias", "pad", "ctx"], "val": ["ret", "bin", "tx", "d", "enc", "config", "l", "vl", "pt", "a", "def", "VAL", "eval", "test", "py", "null", "x", "ref", "unit", "arg", "vol", "loc", "valid", "v", "value", "key", " Val", "pid", "grad", "p", "fi", "buf", "data", "b", "base", "byte", "count", "f", "arr", "end", "type", "sl", "all", "ival", "Val", "aval", "r", "al", "sel", "reg", "el", "bl", "num", "len", "ctx", "vals"], "s": ["args", "m", "ses", "fs", "ins", "l", "rs", "sym", "a", "g", "cs", "S", "os", "si", "es", "sq", "session", "ps", "ss", "o", "flags", "an", "p", "e", "b", "sb", "n", "gs", "c", "ns", "ssl", "sl", "states", "r", "services", "ops", "sa", "ips", "ls", "ts"]}}
{"project": "qemu", "commit_id": "523b018dde3b7650fe5401d0499b30cf2f117515", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680, "substitutes": {"vra": ["varea", "lara", "vru", "vartra", "wra", "svara", "ivra", "vRA", "libra", " vras", "svira", "hra", " vaga", "hran", "vran", "lira", "fru", "Vara", "ivtra", "haga", " vma", "nvran", "fra", " vca", "vira", "vrera", " vta", "Vra", "libran", "nvtra", "vca", "varra", "lvru", "vara", "vcran", "vcra", "libru", "vaga", "vararea", "bara", "wara", "svras", " vru", "bra", " vran", "varha", "lra", "vma", "upra", "vha", " vara", "nvra", "lvara", "fma", "varran", "Vta", "vtra", "svra", "upran", "upru", "lvra", "Vtra", "vcRA", "frera", "baga", " vira", "lvran", "varara", "lvRA", "ivarea", " vrera", "fras", "libara", "farea", " vRA", "fran", "lru", "hara", "bha", "Vran", "wta", "wran", "varaga", "vta", "Vma", "vras", "svrera", "vcru", "ftra", "fara", "lran", "svran", "ivran", "nvara", "lvca", "Vca", " vha"], "vq": ["verqs", "valque", "varquest", "invQ", "varql", " vque", "convq", " viq", "svQ", "invix", "convw", "enqu", "invque", " vw", "volw", "valw", "fiq", "avque", "valqu", "encc", "fq", "varcc", "fqa", "convql", "volq", "svdq", "volqu", "ovQ", "invq", "avq", "valq", "varqu", "Vq", "vcc", "svqu", "fra", "volance", "uvQ", "uvql", "vvquest", "vQ", "vqa", "invw", "viq", "vquest", "verque", " vance", "ovquest", " vix", "svq", "alqu", " vrc", "vvque", "verq", "jqu", "aliq", "svqa", "alQ", "invqu", "ovcc", "varqa", "verqu", "vqu", "Viq", "fqu", "avql", "convance", "vvqs", "volql", "jrc", "Vqu", "vance", "vvq", "enquest", "vque", "viewql", "vql", "viewance", "sviq", " vdq", "vix", "alq", "verql", "uvque", " vql", "viewq", "viewqu", "jra", "ovq", "verquest", "vdq", "invquest", "varq", " vqa", "ovix", " vQ", "avQ", "svql", "fque", "avqa", " vqs", "ovqu", "vw", "vrc", "vardq", "aviq", "frc", "vqs", "VQ", "uvq", " vquest", "verance", "jq", "enq", " vqu"]}}
{"project": "FFmpeg", "commit_id": "e7843db3df0224cafcc1af9da103a3a7286ae2ba", "target": 1, "func": "void ff_get_unscaled_swscale(SwsContext *c)\n\n{\n\n    const enum PixelFormat srcFormat = c->srcFormat;\n\n    const enum PixelFormat dstFormat = c->dstFormat;\n\n    const int flags = c->flags;\n\n    const int dstH = c->dstH;\n\n    int needsDither;\n\n\n\n    needsDither = isAnyRGB(dstFormat) &&\n\n            c->dstFormatBpp < 24 &&\n\n           (c->dstFormatBpp < c->srcFormatBpp || (!isAnyRGB(srcFormat)));\n\n\n\n    /* yv12_to_nv12 */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) &&\n\n        (dstFormat == PIX_FMT_NV12 || dstFormat == PIX_FMT_NV21)) {\n\n        c->swScale = planarToNv12Wrapper;\n\n    }\n\n    /* yuv2bgr */\n\n    if ((srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUV422P ||\n\n         srcFormat == PIX_FMT_YUVA420P) && isAnyRGB(dstFormat) &&\n\n        !(flags & SWS_ACCURATE_RND) && !(dstH & 1)) {\n\n        c->swScale = ff_yuv2rgb_get_func_ptr(c);\n\n    }\n\n\n\n    if (srcFormat == PIX_FMT_YUV410P &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_BITEXACT)) {\n\n        c->swScale = yvu9ToYv12Wrapper;\n\n    }\n\n\n\n    /* bgr24toYV12 */\n\n    if (srcFormat == PIX_FMT_BGR24 &&\n\n        (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P) &&\n\n        !(flags & SWS_ACCURATE_RND))\n\n        c->swScale = bgr24ToYv12Wrapper;\n\n\n\n    /* RGB/BGR -> RGB/BGR (no dither needed forms) */\n\n    if (   isAnyRGB(srcFormat)\n\n        && isAnyRGB(dstFormat)\n\n        && srcFormat != PIX_FMT_BGR8      && dstFormat != PIX_FMT_BGR8\n\n        && srcFormat != PIX_FMT_RGB8      && dstFormat != PIX_FMT_RGB8\n\n        && srcFormat != PIX_FMT_BGR4      && dstFormat != PIX_FMT_BGR4\n\n        && srcFormat != PIX_FMT_RGB4      && dstFormat != PIX_FMT_RGB4\n\n        && srcFormat != PIX_FMT_BGR4_BYTE && dstFormat != PIX_FMT_BGR4_BYTE\n\n        && srcFormat != PIX_FMT_RGB4_BYTE && dstFormat != PIX_FMT_RGB4_BYTE\n\n        && srcFormat != PIX_FMT_MONOBLACK && dstFormat != PIX_FMT_MONOBLACK\n\n        && srcFormat != PIX_FMT_MONOWHITE && dstFormat != PIX_FMT_MONOWHITE\n\n        && srcFormat != PIX_FMT_RGB48LE   && dstFormat != PIX_FMT_RGB48LE\n\n        && srcFormat != PIX_FMT_RGB48BE   && dstFormat != PIX_FMT_RGB48BE\n\n        && srcFormat != PIX_FMT_BGR48LE   && dstFormat != PIX_FMT_BGR48LE\n\n        && srcFormat != PIX_FMT_BGR48BE   && dstFormat != PIX_FMT_BGR48BE\n\n        && (!needsDither || (c->flags&(SWS_FAST_BILINEAR|SWS_POINT))))\n\n        c->swScale= rgbToRgbWrapper;\n\n\n\n    /* bswap 16 bits per pixel/component packed formats */\n\n    if (IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_BGR565) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_GRAY16) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB444) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB48)  ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB555) ||\n\n        IS_DIFFERENT_ENDIANESS(srcFormat, dstFormat, PIX_FMT_RGB565))\n\n        c->swScale = packed_16bpc_bswap;\n\n\n\n    if ((usePal(srcFormat) && (\n\n        dstFormat == PIX_FMT_RGB32   ||\n\n        dstFormat == PIX_FMT_RGB32_1 ||\n\n        dstFormat == PIX_FMT_RGB24   ||\n\n        dstFormat == PIX_FMT_BGR32   ||\n\n        dstFormat == PIX_FMT_BGR32_1 ||\n\n        dstFormat == PIX_FMT_BGR24)))\n\n        c->swScale = palToRgbWrapper;\n\n\n\n    if (srcFormat == PIX_FMT_YUV422P) {\n\n        if (dstFormat == PIX_FMT_YUYV422)\n\n            c->swScale = yuv422pToYuy2Wrapper;\n\n        else if (dstFormat == PIX_FMT_UYVY422)\n\n            c->swScale = yuv422pToUyvyWrapper;\n\n    }\n\n\n\n    /* LQ converters if -sws 0 or -sws 4*/\n\n    if (c->flags&(SWS_FAST_BILINEAR|SWS_POINT)) {\n\n        /* yv12_to_yuy2 */\n\n        if (srcFormat == PIX_FMT_YUV420P || srcFormat == PIX_FMT_YUVA420P) {\n\n            if (dstFormat == PIX_FMT_YUYV422)\n\n                c->swScale = planarToYuy2Wrapper;\n\n            else if (dstFormat == PIX_FMT_UYVY422)\n\n                c->swScale = planarToUyvyWrapper;\n\n        }\n\n    }\n\n    if (srcFormat == PIX_FMT_YUYV422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = yuyvToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 &&\n\n       (dstFormat == PIX_FMT_YUV420P || dstFormat == PIX_FMT_YUVA420P))\n\n        c->swScale = uyvyToYuv420Wrapper;\n\n    if (srcFormat == PIX_FMT_YUYV422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = yuyvToYuv422Wrapper;\n\n    if (srcFormat == PIX_FMT_UYVY422 && dstFormat == PIX_FMT_YUV422P)\n\n        c->swScale = uyvyToYuv422Wrapper;\n\n\n\n    /* simple copy */\n\n    if ( srcFormat == dstFormat ||\n\n        (srcFormat == PIX_FMT_YUVA420P && dstFormat == PIX_FMT_YUV420P) ||\n\n        (srcFormat == PIX_FMT_YUV420P && dstFormat == PIX_FMT_YUVA420P) ||\n\n        (isPlanarYUV(srcFormat) && isGray(dstFormat)) ||\n\n        (isPlanarYUV(dstFormat) && isGray(srcFormat)) ||\n\n        (isGray(dstFormat) && isGray(srcFormat)) ||\n\n        (isPlanarYUV(srcFormat) && isPlanarYUV(dstFormat) &&\n\n         c->chrDstHSubSample == c->chrSrcHSubSample &&\n\n         c->chrDstVSubSample == c->chrSrcVSubSample &&\n\n         dstFormat != PIX_FMT_NV12 && dstFormat != PIX_FMT_NV21 &&\n\n         srcFormat != PIX_FMT_NV12 && srcFormat != PIX_FMT_NV21))\n\n    {\n\n        if (isPacked(c->srcFormat))\n\n            c->swScale = packedCopyWrapper;\n\n        else /* Planar YUV or gray */\n\n            c->swScale = planarCopyWrapper;\n\n    }\n\n\n\n    if (ARCH_BFIN)\n\n        ff_bfin_get_unscaled_swscale(c);\n\n    if (HAVE_ALTIVEC)\n\n        ff_swscale_get_unscaled_altivec(c);\n\n}\n", "idx": 14694, "substitutes": {"c": ["call", "m", "ch", "mc", "uc", "cm", "self", "d", "cv", "t", "ca", "rc", "cc", "pc", "l", "enc", "config", "i", "C", "lc", "ci", "cs", "ctrl", "g", "cit", "this", "cy", "cmp", "con", "ct", "v", "conf", "cr", "u", "oc", "p", "e", "ctx", "s", "nc", "k", "b", "tc", "co", "n", "f", "dc", "cu", "ac", "cb", "sc", "ce", "cont", "cf", "ic", "coll", "cp", "r", "vc", "cache", "xc", "ec", "cur", "cl", "cpp"], "needsDither": ["needsDualth", "needsLithering", "needsDDither", "forcesLithering", "needsDsuth", "needsDsithering", "needsDuith", "needsIithering", "needsDiring", "needsDith", "needsDuithering", "needsDsiring", "needsLalth", "needsIalth", "forcesDith", "needsLith", " needsDithering", "forcesLalth", "needsLither", "needsDDuth", "needsDDiring", "needsDalth", "needsdither", "forcesLither", "needsDDithering", "needsduth", "forcesDithering", "needsDsither", " needsdithering", " needsDiring", "needsdithering", "needsDuither", " needsDuth", "forcesDalth", "needsDithering", " needsdither", "needsdiring", " needsduth", "forcesLith", "needsIither", "forcesDither", " needsdiring", "needsIith", "needsDuth"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static PCIBridgeWindows *pci_bridge_region_init(PCIBridge *br)\n\n{\n\n    PCIDevice *pd = PCI_DEVICE(br);\n\n    PCIBus *parent = pd->bus;\n\n    PCIBridgeWindows *w = g_new(PCIBridgeWindows, 1);\n\n    uint16_t cmd = pci_get_word(pd->config + PCI_COMMAND);\n\n\n\n    pci_bridge_init_alias(br, &w->alias_pref_mem,\n\n                          PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                          \"pci_bridge_pref_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_mem,\n\n                          PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                          \"pci_bridge_mem\",\n\n                          &br->address_space_mem,\n\n                          parent->address_space_mem,\n\n                          cmd & PCI_COMMAND_MEMORY);\n\n    pci_bridge_init_alias(br, &w->alias_io,\n\n                          PCI_BASE_ADDRESS_SPACE_IO,\n\n                          \"pci_bridge_io\",\n\n                          &br->address_space_io,\n\n                          parent->address_space_io,\n\n                          cmd & PCI_COMMAND_IO);\n\n\n\n    pci_bridge_init_vga_aliases(br, parent, w->alias_vga);\n\n\n\n    return w;\n\n}\n", "idx": 14716, "substitutes": {"br": ["plug", "bridge", "bre", "ch", "bc", "hr", "ger", "gr", "tr", "jp", "fb", "BR", "bd", "kr", "or", "ctr", "current", "er", "fore", "sw", "browser", "ref", "module", "str", "sr", "fr", "var", "cr", "bp", "bar", "obj", "adr", "mr", "p", "lr", "img", "bm", "rb", "ver", "pb", "pl", "buf", "b", "driver", "base", "j", "ler", "bf", "bal", "bh", "ab", "block", "brid", "bro", "arr", "bo", "Br", "coll", "r", "org", "db", "pr", "dr", "el", "bl", "ber", "wr", "err"], "pd": ["dh", "po", "d", "fd", "pc", "cdn", "da", "bd", "td", "pg", "dl", "lp", "py", "pp", "pid", "ld", "raf", "client", "gd", "cd", "ad", "p", "pad", "pb", "pa", "sd", "xd", "pm", "df", "dt", "dc", "pi", "md", "dp", "cp", "ds", "od", "PD", "hd", "db", "dd", "vd", "ppa", "wd", "fc", "tp", "ctx"], "parent": ["bridge", "path", "port", "remote", "m", "self", "root", "part", "uc", "bc", "pc", "any", "pt", "child", "home", "large", "current", "row", "g", "source", "wan", "public", "image", "new", "null", "pool", "other", "unit", "full", "writer", "node", "pid", "master", "server", "known", "client", "p", "instance", "resource", "pa", "base", "f", "global", "c", "parser", "parents", "block", "inner", "Parent", "r", "host", "author", "cache", "pos", "ph", "prev", "post", "ctx", "father"], "w": ["word", "wer", "way", "wk", "wh", "wm", "d", "t", "iw", "l", "ww", "ew", "g", "wan", "wx", "h", "sw", "wt", "x", "writer", "wig", "v", " W", "web", "kw", "win", "war", "u", "p", "e", "wal", "aw", "b", "wb", "wu", "f", "rw", "wp", "c", "W", "tw", "ow", "wa", "r", "wall", "widget", "we", "wi", "work", "window", "wo", "wl", "wd", "hw", "fw"]}}
{"project": "FFmpeg", "commit_id": "e22ebd04bcab7f86548794556c28ecca46d9c2ac", "target": 0, "func": "static void hls_transform_tree(HEVCContext *s, int x0, int y0,\n\n                               int xBase, int yBase, int cb_xBase, int cb_yBase,\n\n                               int log2_cb_size, int log2_trafo_size,\n\n                               int trafo_depth, int blk_idx)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    uint8_t split_transform_flag;\n\n\n\n    if (trafo_depth > 0 && log2_trafo_size == 2) {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase);\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase);\n\n    } else {\n\n        SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n        SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) = 0;\n\n    }\n\n\n\n    if (lc->cu.intra_split_flag) {\n\n        if (trafo_depth == 1)\n\n            lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[blk_idx];\n\n    } else {\n\n        lc->tu.cur_intra_pred_mode = lc->pu.intra_pred_mode[0];\n\n    }\n\n\n\n    lc->tt.cbf_luma = 1;\n\n\n\n    lc->tt.inter_split_flag = s->sps->max_transform_hierarchy_depth_inter == 0 &&\n\n                              lc->cu.pred_mode == MODE_INTER &&\n\n                              lc->cu.part_mode != PART_2Nx2N &&\n\n                              trafo_depth == 0;\n\n\n\n    if (log2_trafo_size <= s->sps->log2_max_trafo_size &&\n\n        log2_trafo_size >  s->sps->log2_min_tb_size    &&\n\n        trafo_depth     < lc->cu.max_trafo_depth       &&\n\n        !(lc->cu.intra_split_flag && trafo_depth == 0)) {\n\n        split_transform_flag = ff_hevc_split_transform_flag_decode(s, log2_trafo_size);\n\n    } else {\n\n        split_transform_flag = log2_trafo_size > s->sps->log2_max_trafo_size ||\n\n                               (lc->cu.intra_split_flag && trafo_depth == 0) ||\n\n                               lc->tt.inter_split_flag;\n\n    }\n\n\n\n    if (log2_trafo_size > 2) {\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n\n\n        if (trafo_depth == 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth - 1], xBase, yBase)) {\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0) =\n\n                ff_hevc_cbf_cb_cr_decode(s, trafo_depth);\n\n        }\n\n    }\n\n\n\n    if (split_transform_flag) {\n\n        int x1 = x0 + ((1 << log2_trafo_size) >> 1);\n\n        int y1 = y0 + ((1 << log2_trafo_size) >> 1);\n\n\n\n        hls_transform_tree(s, x0, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 0);\n\n        hls_transform_tree(s, x1, y0, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 1);\n\n        hls_transform_tree(s, x0, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 2);\n\n        hls_transform_tree(s, x1, y1, x0, y0, cb_xBase, cb_yBase, log2_cb_size,\n\n                           log2_trafo_size - 1, trafo_depth + 1, 3);\n\n    } else {\n\n        int min_tu_size      = 1 << s->sps->log2_min_tb_size;\n\n        int log2_min_tu_size = s->sps->log2_min_tb_size;\n\n        int min_tu_width     = s->sps->min_tb_width;\n\n\n\n        if (lc->cu.pred_mode == MODE_INTRA || trafo_depth != 0 ||\n\n            SAMPLE_CBF(lc->tt.cbf_cb[trafo_depth], x0, y0) ||\n\n            SAMPLE_CBF(lc->tt.cbf_cr[trafo_depth], x0, y0)) {\n\n            lc->tt.cbf_luma = ff_hevc_cbf_luma_decode(s, trafo_depth);\n\n        }\n\n\n\n        hls_transform_unit(s, x0, y0, xBase, yBase, cb_xBase, cb_yBase,\n\n                           log2_cb_size, log2_trafo_size, trafo_depth, blk_idx);\n\n\n\n        // TODO: store cbf_luma somewhere else\n\n        if (lc->tt.cbf_luma) {\n\n            int i, j;\n\n            for (i = 0; i < (1 << log2_trafo_size); i += min_tu_size)\n\n                for (j = 0; j < (1 << log2_trafo_size); j += min_tu_size) {\n\n                    int x_tu = (x0 + j) >> log2_min_tu_size;\n\n                    int y_tu = (y0 + i) >> log2_min_tu_size;\n\n                    s->cbf_luma[y_tu * min_tu_width + x_tu] = 1;\n\n                }\n\n        }\n\n        if (!s->sh.disable_deblocking_filter_flag) {\n\n            ff_hevc_deblocking_boundary_strengths(s, x0, y0, log2_trafo_size,\n\n                                                  lc->slice_or_tiles_up_boundary,\n\n                                                  lc->slice_or_tiles_left_boundary);\n\n            if (s->pps->transquant_bypass_enable_flag &&\n\n                lc->cu.cu_transquant_bypass_flag)\n\n                set_deblocking_bypass(s, x0, y0, log2_trafo_size);\n\n        }\n\n    }\n\n}\n", "idx": 14723, "substitutes": {"s": ["acs", "sys", "ses", "context", "self", "service", "t", "sync", "sg", "l", "rs", "g", "cs", "qs", "S", "settings", "h", "sk", "os", "si", "js", "sq", "session", "ps", "ss", "storage", "o", "u", "p", "e", "sec", "site", "sb", "sf", "f", "gs", "spec", "c", "ns", "xs", "sc", "ssl", "sv", "sl", "r", "ds", "sie", "services", "sa", "su", "ls", "ts", "space", "us", "ctx"], "x0": ["xx1", "y4", "xp1", " x1", " x10", "X1", " xee", "xx0", "xSource", "xy1", "xee", " x4", "rx0", "xxee", "axZero", "y250", "xy0", "ax1", "yNo", "xxNo", "ax10", "yZero", " xZero", " xStart", "rxBase", "x250", "xNo", "xStart", "ax0", "y1", "xp4", "xySource", "xyBase", "y10", "rx1", "rxStart", "XStart", "xZero", " xNo", "x10", "xp250", "x4", "X0", "xp0", "ySource", "x1", "XBase", "yee", " x250", " xSource"], "y0": ["eyElement", "asyItem", "YOrigin", "YSource", "Y3", " y3", "YElement", " y50", "Y1", " y1", "yItem", "ryBase", "yEl", "vy1", " ySource", "Y50", "y50", "y3", " yEl", "YBase", "YEl", "rySource", "yyOrigin", "Y00", "vyBase", " yOrigin", "yy1", "ry1", "asy1", "y1", "y00", "eyItem", "ry0", "Y0", "ry50", "YItem", "yy00", "yElement", " y00", "ey0", "yOrigin", "asyElement", "vy0", "asy0", "ySource", "ey1", "ryEl", "vy3", "yy0"], "xBase": ["ix0", "XSize", "xMax", " xbase", "Xbase", " xMax", "xbase", "yZero", " xZero", " xSize", "ixZero", "ybase", "ySize", "xSize", "xZero", "ixbase", "ixBase", "X0", "yMax", "XBase", "XMax"], "yBase": ["yaByte", " yBack", "YSource", "YBased", " ybase", "eyBuffer", "eybase", "yBased", " ySource", "yaBase", "vyBased", " yBuffer", " yBased", "eyBack", "YBase", "eyBase", "xbase", "yBack", "vyBase", "YByte", "yBuffer", "ybase", "yByte", "YBuffer", "YBack", " yByte", "Ybase", "vy0", "yaSource", "yaBased", "ySource", "vybase", "xBased"], "cb_xBase": ["cb_xUnit", "cb_wUnit", "cb_xEnd", "cb_wEnd", "cb_yUnit", "cb_x0", "cb_yEnd", "cb_eyUnit", "cb_wBase", "cb_eyBase", "cb_y0", "cb_w0", "cb_eyEnd", "cb_ey0"], "cb_yBase": ["cb_xRest", "cb_yScale", "cb_cyRest", "cb_zyRest", "cb_x0", "cb_yRest", "cb_zy0", "cb_cy0", "cb_zyBase", "cb_cyScale", "cb_y0", "cb_cyBase", "cb_zyScale", "cb_xScale"], "log2_cb_size": ["log2_cb_capacity", "log2_bb_capacity", "log2_cb_count", "log2_cb2count", "log2_bb_size", "log2_cb2small", "log2_bb_small", "log2_cb2size", "log2_cb2capacity", "log2_cb_small", "log2_bb_count"], "log2_trafo_size": ["log2_traf_depth", "log2_trafo_depth", "log2_trafi_go", "log2_traf_size", "log2_trafo_weight", "log2_traco_depth", "log2_traf_len", "log2_traf_weight", "log2_trafo_width", "log2_trafo_go", "log2_traf_scale", "log2_traco_width", "log2_trafo_len", "log2_trafo_scale", "log2_traco_size", "log2_trafi_size", "log2_trafi_depth"], "trafo_depth": ["traf_size", "traf_depth", " tra\n", "trafo_size", "trafo_rank", "tratto_scale", "traph_root", "trafi_root", "tra\n", "traph_deep", "trafo_weight", "traf_weight", "traph_size", "tratto_depth", "trafo_deep", "trafo_strength", "traverse_depth", "traverse_height", "traf_distance", "traverse_strength", "traph_uri", "trafo_color", "tratto_size", "tratto_deep", "traf_length", "trafi_size", "trafi_deep", "trafo_count", "trafi_depth", "trafo_scale", "trafo_length", "tratto_rank", "trafo_distance", "traph_color", "traf_root", "trafo_level", "trafo_mode", "trafi_count", "traverse_level", "tratto_level", "tre\n", "trafo_root", "trafo_uri", "traf_mode", "traph_depth", "trafo_height", "ra\n", "traf_deep"], "blk_idx": ["blk1idw", "blk_idsw", "blk_catxs", "blk_pidv", "blk_Idx", "blk1idew", "blk_idev", "blk_Idxs", "blk_idew", "blk_Idw", "blk_idec", "blk_idv", "blk1idec", "blk_catv", "blk_pidw", "blk_idsv", "blk_Idv", "blk_pidx", "blk_idex", "blk_catw", "blk1idv", "blk_idw", "blk_idc", "blk1idex", "blk_pidc", "blk_catx", "blk_idsx", "blk1idev", "blk_idxs", "blk1idx", "blk_Idc", "blk1idc", "blk_idsxs"], "lc": ["mc", "cm", "bc", "hl", "uc", "lin", "rc", "cc", "pc", "l", "lic", "ci", "cs", "ctrl", "dl", "lp", "cci", "cn", "ml", "lang", "si", "ii", "ld", "loc", "conn", "lib", "ll", "la", "lr", "kl", "ku", "nc", "li", "cli", "tc", "lt", "cus", "sb", "lf", "acl", "gb", "spec", "rl", "c", "uci", "cu", "dc", "fc", "lu", "jc", "cas", "sci", "sc", "cf", "ic", "coll", "icc", "lex", "cell", "vc", "CI", "cache", "ga", "ls", "lb", "wl", "lv", "ln", "cl", "ctx", "LC"], "split_transform_flag": ["split_transform\u00b7flag", "split_transfer_flag", "split_transform_only", "split_transfer_only", "split_transform\u00b7bit", "split_transform\u00b7count", "split_transfer_bit", "split_transform_bit", "split_transfer_count", "split_transform_count", "split_transform\u00b7only"]}}
{"project": "FFmpeg", "commit_id": "ba3f07d0611d9a6c10eaa90b3c058ecdffe76676", "target": 1, "func": "static void aw_pulse_set2(WMAVoiceContext *s, GetBitContext *gb,\n\n                          int block_idx, AMRFixed *fcb)\n\n{\n\n    uint16_t use_mask_mem[9]; // only 5 are used, rest is padding\n\n    uint16_t *use_mask = use_mask_mem + 2;\n\n    /* in this function, idx is the index in the 80-bit (+ padding) use_mask\n\n     * bit-array. Since use_mask consists of 16-bit values, the lower 4 bits\n\n     * of idx are the position of the bit within a particular item in the\n\n     * array (0 being the most significant bit, and 15 being the least\n\n     * significant bit), and the remainder (>> 4) is the index in the\n\n     * use_mask[]-array. This is faster and uses less memory than using a\n\n     * 80-byte/80-int array. */\n\n    int pulse_off = s->aw_first_pulse_off[block_idx],\n\n        pulse_start, n, idx, range, aidx, start_off = 0;\n\n\n\n    /* set offset of first pulse to within this block */\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        while (pulse_off + s->aw_pulse_range < 1)\n\n            pulse_off += fcb->pitch_lag;\n\n\n\n    /* find range per pulse */\n\n    if (s->aw_n_pulses[0] > 0) {\n\n        if (block_idx == 0) {\n\n            range = 32;\n\n        } else /* block_idx = 1 */ {\n\n            range = 8;\n\n            if (s->aw_n_pulses[block_idx] > 0)\n\n                pulse_off = s->aw_next_pulse_off_cache;\n\n        }\n\n    } else\n\n        range = 16;\n\n    pulse_start = s->aw_n_pulses[block_idx] > 0 ? pulse_off - range / 2 : 0;\n\n\n\n    /* aw_pulse_set1() already applies pulses around pulse_off (to be exactly,\n\n     * in the range of [pulse_off, pulse_off + s->aw_pulse_range], and thus\n\n     * we exclude that range from being pulsed again in this function. */\n\n    memset(&use_mask[-2], 0, 2 * sizeof(use_mask[0]));\n\n    memset( use_mask,   -1, 5 * sizeof(use_mask[0]));\n\n    memset(&use_mask[5], 0, 2 * sizeof(use_mask[0]));\n\n    if (s->aw_n_pulses[block_idx] > 0)\n\n        for (idx = pulse_off; idx < MAX_FRAMESIZE / 2; idx += fcb->pitch_lag) {\n\n            int excl_range         = s->aw_pulse_range; // always 16 or 24\n\n            uint16_t *use_mask_ptr = &use_mask[idx >> 4];\n\n            int first_sh           = 16 - (idx & 15);\n\n            *use_mask_ptr++       &= 0xFFFF << first_sh;\n\n            excl_range            -= first_sh;\n\n            if (excl_range >= 16) {\n\n                *use_mask_ptr++    = 0;\n\n                *use_mask_ptr     &= 0xFFFF >> (excl_range - 16);\n\n            } else\n\n                *use_mask_ptr     &= 0xFFFF >> excl_range;\n\n        }\n\n\n\n    /* find the 'aidx'th offset that is not excluded */\n\n    aidx = get_bits(gb, s->aw_n_pulses[0] > 0 ? 5 - 2 * block_idx : 4);\n\n    for (n = 0; n <= aidx; pulse_start++) {\n\n        for (idx = pulse_start; idx < 0; idx += fcb->pitch_lag) ;\n\n        if (idx >= MAX_FRAMESIZE / 2) { // find from zero\n\n            if (use_mask[0])      idx = 0x0F;\n\n            else if (use_mask[1]) idx = 0x1F;\n\n            else if (use_mask[2]) idx = 0x2F;\n\n            else if (use_mask[3]) idx = 0x3F;\n\n            else if (use_mask[4]) idx = 0x4F;\n\n            else                  return;\n\n            idx -= av_log2_16bit(use_mask[idx >> 4]);\n\n        }\n\n        if (use_mask[idx >> 4] & (0x8000 >> (idx & 15))) {\n\n            use_mask[idx >> 4] &= ~(0x8000 >> (idx & 15));\n\n            n++;\n\n            start_off = idx;\n\n        }\n\n    }\n\n\n\n    fcb->x[fcb->n] = start_off;\n\n    fcb->y[fcb->n] = get_bits1(gb) ? -1.0 : 1.0;\n\n    fcb->n++;\n\n\n\n    /* set offset for next block, relative to start of that block */\n\n    n = (MAX_FRAMESIZE / 2 - start_off) % fcb->pitch_lag;\n\n    s->aw_next_pulse_off_cache = n ? fcb->pitch_lag - n : 0;\n\n}\n", "idx": 14741, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "service", "sync", "t", "sg", "your", "l", "rs", "sym", "utils", "g", "cs", "qs", "S", "settings", "os", "this", "sets", "es", "si", "js", "sq", "session", "conf", "ss", "storage", "sim", "o", "w", "u", "p", "e", "se", "site", "b", "sb", "sf", "f", "gs", "spec", "less", "c", "ns", "is", "stats", "sc", "ssl", "sv", "sl", "states", "services", "ds", "r", "sie", "su", "ls", "ts", "us", "space", "support", "ctx", "ks"], "gb": ["bridge", " bc", "ui", "wm", "mc", "bc", "sg", "gc", "g", "buff", "conf", "gd", "gm", "gg", "bm", "rb", "sb", "usb", "gs", "cfg", "gam", "cb", "gate", "bg", "cmd", "mac", "ga", "src", "gp"], "block_idx": ["block_namexx", "blockObeginxes", "block_lengthx", "block_lengthcent", "block_idw", "blockOindexx", "block_idX", "block_indz", "block__itexx", "blockOindexxs", "blockEidentx", "block_itest", "block_Idxx", "block_modecent", "block_idst", "block_iteng", "block__iteX", "block_identcent", "block_endxes", "block_idsxes", "block_beginz", "block_ridz", "block00idx", "block__idxx", "block_beginx", "blockOindexw", "block_Idx", "block_endX", "blockEidst", "block_lengths", "block_itx", "block00idom", "block_idom", "blockOidx", "block_Idc", "block_identst", "blockOidxx", "block_identom", "block_itex", "block_endw", "block_indexw", "block_defxes", "block00idents", "block_lengthom", "block_identng", "block__idX", "block_Idz", "blockEidx", "blockObeginx", "block_indexxs", "block_idc", "block_idxx", "blockOidxs", "block_endx", "blockOidng", "blockEidentst", "blockEidentxx", "block_indexxes", "block_idents", "block_idxes", "block_itz", "block_ridy", "blockEidxx", "block_Idw", "blockOindexxes", "block_idcent", "block_idsx", "block_itexx", "block00identcent", "block_indxes", "blockEidentng", "block00identx", "block00idcent", "block_endxs", "block_ids", "block_iddxx", "block_namest", "block_Idy", "block__itex", "block_idxs", "blockObeginng", "block_modeom", "block_idz", "block_identx", "block_identxx", "block_endxx", "block_idng", "block_iddng", "block_itxes", "block_beginxes", "block_ridc", "block_indng", "block_namex", "blockEidng", "block_defx", "block_iddx", "block_indexx", "block_modex", "block_beginxx", "block__idx", "block00ids", "block_modes", "block_indx", "block_IdX", "block_beginng", "block_nameng", "block__idw", "blockObeginxx", "block_idy", "blockOidxes", "block00identom", "block__itew", "block_defng", "blockOidw", "block_idsxs", "block_iteX", "block_idsw", "block_defxx", "block_itew", "block_itng", "block_iddxes", "block_ridx"], "fcb": ["fcl", "fcd", "dcl", "FCm", "FCb", "FCl", "fxbs", "fbs", "fcsb", "fb", "dcd", "fec", "fcm", "lcl", "rcn", "fB", "dcb", "FCd", "fnn", "fsb", "fcbs", "fnb", "feb", "fxB", "fcc", "lcd", "rcb", "fnc", "rcc", "fem", "fcn", "rcm", "fxb", "fxsb", "lcm", "fcB", "FCbs", "lcb", "fnm", "FCB", "fen", "dcm", "FCsb"], "use_mask_mem": ["use_mask_all", "use_map_mem", "use_mask_memory", "use_map_ram", "use_mask_ram", "use_map_Mem", "use_ask_ram", "use_mask_Mem", "use_ask_mem", "use_map_all", "use_ask_memory"], "use_mask": [" use_filter", "usePmiss", "match_filter", " use_group", "rule_gap", "use_group", "usePmask", "seePcost", "rule_black", "seePmiss", " use_sum", "usealcount", "seePmask", "match_count", "usePcost", "use\u00b7margin", "use_map", "ride_mask", "usealsign", " use2group", "uselogshape", " use2mask", "match_shape", "uselylock", "see_margin", "matchlogfilter", " use2sum", "use2group", "use_lock", "use_shape", "ridealask", "ride_ask", "use_count", "rule_cache", "apply_window", "usage_cost", "use_window", "use__cache", "usealmask", "use\u00b7cost", "ridealmask", "usexmiss", "use_ask", "use_miss", "usePmargin", "usexmargin", "matchlogshape", "use2lock", "usexmask", "usage_cache", "uselymask", "use\u00b7miss", "use_cache", "use_sign", "seePmargin", "usexcost", "matchlogcount", "uselygap", "ride_cloud", "usealask", "usealshape", "use_margin", "apply_ask", "uselywindow", "rulelymask", "rule_mask", "rulelyblack", "rulelygap", "use2map", "use__mask", "match_mask", "use_cost", "use__cost", "ride_sign", "usealcloud", "use_filter", "ridealcloud", "apply_lock", "use_gap", "use2filter", "uselyblack", "ridealsign", "use_cloud", "use_sum", "see_mask", "use2mask", "rulelycache", "uselogfilter", " use_lock", "see_miss", "usage_sum", " use2map", "use__sum", " use_map", "uselogmask", "matchlogmask", "see_cost", "uselyask", "use\u00b7mask", "use_black", "usage_mask", "usealfilter", "apply_mask", "uselycache", "use2sum", "uselogcount"], "pulse_start": ["pulse_len", "pulse_end", "pitch_start", "pitch_set", "pulse_set", "pitch_len", "pitch_off", "pitch_stop", "pitch_end", "pulse_off", "pulse_stop"], "n": ["m", "d", "ni", "l", "i", "N", "g", "nb", "o", "np", "w", "z", "u", "p", "e", "nc", "b", "f", "c", "ns", "sn", "network", "r", "num", "len", "y", "node"], "idx": ["aidxs", "idex", "aidxc", "midxs", " idw", "aidy", "ridx", "indX", "Idx", "indy", "idec", "indxs", "aidz", "midx", "idw", "sidxs", "Idxs", "ridX", "aidxes", "sidX", " idxc", "indc", "partix", " idz", "ridw", "sidxc", "sidx", "idc", "midX", "idey", " idix", "idX", "idxs", "idz", " idX", "indxes", "partxs", "idix", " idxs", "idxc", "IdX", "Idxc", "indix", "ridxs", "indz", "idexes", "aidc", "aidX", "indx", "partx", "idy", "idxes", "midw", " idxes", "partX"], "range": ["channel", "area", "repeat", "ge", "spread", "domain", "slice", "array", "random", "l", "binary", "row", "gap", "low", "use", "ranged", "ace", "Range", "loc", "error", "frame", "limit", "chain", "fr", "role", "view", "size", "ange", "version", "e", "resource", "ver", "rate", "length", "mode", "none", "lag", "line", "feature", "grade", "nor", "state", "route", "block", "start", "end", "ne", "offset", "from", "rule", "scale", "r", "f", "last", "cache", "nr", "num", "span", "max", "lim", "err"], "aidx": [" idc", "idc", "adc", "aidc", "idr", "aidy", " idy", "adx", "idy", " idr", "aidr", "adr", "ady"], "use_mask_ptr": ["use_mask_ctr", "use_mask__ctr", "use_mask__addr", "use_ask_addr", "use_ask_pointer", "use_mask__tr", "use_mask_pos", "use_ask_ctr", "use_mask_pointer", "use_ask_tr", "use_mask_tr", "use_mask__ptr", "use_mask_addr", "use_ask_ptr"]}}
{"project": "FFmpeg", "commit_id": "0ebb523f072322972ea446616676fff32e9603c6", "target": 1, "func": "static void asf_build_simple_index(AVFormatContext *s, int stream_index)\n\n{\n\n    ff_asf_guid g;\n\n    ASFContext *asf     = s->priv_data;\n\n    int64_t current_pos = avio_tell(s->pb);\n\n    int i;\n\n\n\n    avio_seek(s->pb, asf->data_object_offset + asf->data_object_size, SEEK_SET);\n\n    ff_get_guid(s->pb, &g);\n\n\n\n    /* the data object can be followed by other top-level objects,\n\n     * skip them until the simple index object is reached */\n\n    while (ff_guidcmp(&g, &index_guid)) {\n\n        int64_t gsize = avio_rl64(s->pb);\n\n        if (gsize < 24 || s->pb->eof_reached) {\n\n            avio_seek(s->pb, current_pos, SEEK_SET);\n\n            return;\n\n        }\n\n        avio_skip(s->pb, gsize - 24);\n\n        ff_get_guid(s->pb, &g);\n\n    }\n\n\n\n    {\n\n        int64_t itime, last_pos = -1;\n\n        int pct, ict;\n\n        int64_t av_unused gsize = avio_rl64(s->pb);\n\n        ff_get_guid(s->pb, &g);\n\n        itime = avio_rl64(s->pb);\n\n        pct   = avio_rl32(s->pb);\n\n        ict   = avio_rl32(s->pb);\n\n        av_log(s, AV_LOG_DEBUG,\n\n               \"itime:0x%\"PRIx64\", pct:%d, ict:%d\\n\", itime, pct, ict);\n\n\n\n        for (i = 0; i < ict; i++) {\n\n            int pktnum        = avio_rl32(s->pb);\n\n            int pktct         = avio_rl16(s->pb);\n\n            int64_t pos       = s->data_offset + s->packet_size * (int64_t)pktnum;\n\n            int64_t index_pts = FFMAX(av_rescale(itime, i, 10000) - asf->hdr.preroll, 0);\n\n\n\n            if (pos != last_pos) {\n\n                av_log(s, AV_LOG_DEBUG, \"pktnum:%d, pktct:%d  pts: %\"PRId64\"\\n\",\n\n                       pktnum, pktct, index_pts);\n\n                av_add_index_entry(s->streams[stream_index], pos, index_pts,\n\n                                   s->packet_size, 0, AVINDEX_KEYFRAME);\n\n                last_pos = pos;\n\n            }\n\n        }\n\n        asf->index_read = ict > 0;\n\n    }\n\n    avio_seek(s->pb, current_pos, SEEK_SET);\n\n}\n", "idx": 14745, "substitutes": {"s": ["native", "rs", "qs", "new", "js", "server", "ps", "tests", "spec", "c", "single", "is", "sc", "sv", "states", "in", "south", "self", "d", "t", "sync", "sg", "ins", "fs", "sym", "sup", "cs", "es", "full", "session", "storage", "u", "data", "b", "sf", "ns", "ops", "r", "ks", "secondary", "sys", "service", "your", "os", "sets", "ms", "e", "http", "site", "sb", "features", "f", "less", "services", "ls", "comments", "ses", "bs", "l", "a", "sites", "S", "settings", "its", "uns", "sq", "conf", "ss", "p", "se", "ions", "plugins", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us"], "stream_index": [" stream_ctx", " stream_input", " stream_ref"], "g": ["ge", "m", "d", "sg", "l", "G", "gi", "msg", "gc", "ig", "pg", "h", "rg", "x", "eg", "game", "arg", "gh", " G", "guide", "gu", "gl", "erg", "gd", "w", "group", "u", "gm", "p", "e", "b", "mg", "j", "n", "f", " eg", "gb", "gs", "cfg", "c", "greg", "gar", "gam", "vg", "gen", "bg", "general", "ga", "num", "reg", "debug", "go", "gp"], "asf": ["assl", " asfo", "ASfs", "asl", "masc", "Asf", "Asfs", "rasc", "Asc", "rasv", "asv", " asfc", " asfp", "arsf", "asc", "asp", "rasfs", "arsfp", "ASf", "asfs", "assfo", "Asfc", "masv", "ASc", "assfp", "assf", "atsc", "masfs", "Asfo", "atsfc", "asfp", "atsf", "rasf", "atsfo", "masf", "Asp", " asc", "arsl", " asl", "asfc", "asfo", "arsfo", " asfs", "ASp", " asv", "rasp"], "i": ["hi", "ani", "qi", "ge", "ui", "it", "m", "adi", "I", "d", "t", "ai", "ni", "xi", "id", "l", "G", "gi", "iu", "ini", "oi", "idi", "api", "ci", "ki", "h", "di", "x", "ati", "si", "ii", "uri", "gu", "gl", "yi", "group", "z", "u", "gm", "p", "fi", "info", "mini", "cli", "li", "ix", "multi", "j", "n", "ti", "ski", "c", "eni", "ip", "anti", "ji", "inner", "pi", "bg", "udi", "uli", "chi", "ic", "bi", "gui", "ik", "ami", "zi", "aci", "in", "index", "start"], "itime": ["oni", "mis", "uni", "ige", "rice", "phil", "nir", "ih", "uti", "uture", "iv", "ine", "nit", "asi", "mie", "groupon", "mine", "ngth", "cit", "agency", "ime", "txt", "umi", "ide", "ie", "ii", "ship", "interest", "uri", "loc", "riage", "quad", "duty", "metadata", "iman", "ib", "mi", "cli", "nil", "ski", "isd", "eni", "industrial", "ne", "udi", "ele", "lane", "igure", "pir", "ila", "imet", "inet", "imi", "ahi", "imei", "qq", "xxx", "iti"], "pct": ["lpnt", "jpcr", "vpcent", " pnt", "tpkt", "PCT", "pkt", "Pnt", "lpcy", "gcy", " pkt", "lpct", " pcr", " pcy", "Pct", " pdc", "jpct", "vpkt", "vpcr", "jpCT", "lpdc", " pCT", "pcent", "tpcent", "pCT", "Pcr", " pcent", "pnt", "gnt", "pcy", "gct", "tpcr", "pcr", "tpct", "pdc", "vpct", "jpnt", "gdc"], "ict": ["gt", "cit", "ants", "ct", "limit", "gd", "dict", "oga", "FFFF", "ect", "dd", "oci", "dr", "ot", "ICT", "sg", "cc", "di", "txt", "gh", "mot", "icts", "anta", "ich", "omm", "xc", "iot", "cci", "ci", "pg", "tt", "vag", "ant", "qt", "acl", "ont", "voc", "ac", "nt", "aud", "ffff", "uc", "qa", "iw", "pt", "unch", "uct", "catch", "cli", "icit", "dc", "atts", "ht", "ogg", "ic", "et", "max", "irc"]}}
{"project": "qemu", "commit_id": "1f3ddfcb258e6e0562467a9644daad3f28597da8", "target": 1, "func": "static void bdrv_qed_drain(BlockDriverState *bs)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n\n\n    /* Cancel timer and start doing I/O that were meant to happen as if it\n\n     * fired, that way we get bdrv_drain() taking care of the ongoing requests\n\n     * correctly. */\n\n    qed_cancel_need_check_timer(s);\n\n    qed_plug_allocating_write_reqs(s);\n\n    bdrv_aio_flush(s->bs, qed_clear_need_check, s);\n\n}\n", "idx": 14750, "substitutes": {"bs": ["ses", "blocks", "bid", "bis", "bc", "lbs", "BS", "fs", "ins", "bb", "fb", "rs", "cs", "os", "bytes", "es", "aps", "ps", "ss", "ba", "rb", "obs", "pb", "vs", "b", "sb", "base", "gb", "gs", "bits", "ab", "bh", "ns", "state", "bps", "bes", "bas", "bi", "ds", "sa", "ls", "bos", "lb", "ubs", "iss", "ks", "aws"], "s": ["args", "south", "sys", "ses", "rss", "service", "sync", "t", "i", "rs", "sym", "a", "g", "cs", "S", "submit", "os", "status", "si", "es", "js", "sq", "session", "server", "ps", "ss", "o", "p", "e", "socket", "http", "b", "sb", "n", "f", "gs", "state", "spec", "c", "ns", "is", "stats", "ssl", "sl", "states", "services", "ds", "sie", "sa", "ls", "ts", "aws"]}}
{"project": "qemu", "commit_id": "47d4be12c3997343e436c6cca89aefbbbeb70863", "target": 1, "func": "static void test_qemu_strtol_invalid(void)\n\n{\n\n    const char *str = \"   xxxx  \\t abc\";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtol(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 14774, "substitutes": {"str": ["Str", "vec", "rr", "stri", "frac", "hr", "enc", "tr", "in", "id", "rs", "orig", "ctr", "kr", "lc", "er", "cs", "sp", "req", "std", "sr", "txt", "br", "fr", "cr", "obj", "temp", "STR", "nc", "ext", "old", "f", "spec", "ns", "c", "arr", "start", "inner", "text", "iter", "r", "pr", "dr", "res", "cur", "st", "ptr"], "endptr": ["pendtr", "endedproc", "Endpointer", "endpointer", "endPtr", "pendptr", "endctr", " endPtr", " endpointer", " endtr", "endproc", "pendproc", "adctr", "EndPtr", "endedptr", "adpointer", " endproc", "adproc", "Endptr", "endedtr", " endctr", "Endctr", "adPtr", "endtr", "endedPtr", "Endproc", "adptr", "pendPtr"], "err": ["rr", "gr", "rc", "code", "i", "ctr", "msg", "kr", "range", "Error", "er", "req", "test", "ner", "aster", "error", "Er", "rh", "fr", "var", "der", "cr", "ind", "mr", "e", "ir", "good", "ver", "ler", "result", "arr", "try", "iter", "resp", "r", "pr", "nr", "ar", "dr", "res", "order", "ise"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static int check_bind(const char *hostname, bool *has_proto)\n\n{\n\n    int fd = -1;\n\n    struct addrinfo ai, *res = NULL;\n\n    int rc;\n\n    int ret = -1;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = AF_UNSPEC;\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(hostname, NULL, &ai, &res);\n\n    if (rc != 0) {\n\n        if (rc == EAI_ADDRFAMILY ||\n\n            rc == EAI_FAMILY) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    fd = qemu_socket(res->ai_family, res->ai_socktype, res->ai_protocol);\n\n    if (fd < 0) {\n\n        goto cleanup;\n\n    }\n\n\n\n    if (bind(fd, res->ai_addr, res->ai_addrlen) < 0) {\n\n        if (errno == EADDRNOTAVAIL) {\n\n            *has_proto = false;\n\n            goto done;\n\n        }\n\n        goto cleanup;\n\n    }\n\n\n\n    *has_proto = true;\n\n done:\n\n    ret = 0;\n\n\n\n cleanup:\n\n    if (fd != -1) {\n\n        close(fd);\n\n    }\n\n    if (res) {\n\n        freeaddrinfo(res);\n\n    }\n\n    return ret;\n\n}\n", "idx": 14775, "substitutes": {"hostname": ["addresscode", " hostnames", "hostcode", "portpath", "Hostnames", "hostnum", "portnames", "hostpath", "ipname", "HostName", "ipnum", "Hostpath", "portnum", "portname", "hostnames", "addressnum", "portcode", " hostName", "ipcode", "Hostname", "hostName", "portName", " hostpath", "addressname"], "has_proto": ["has_prebe", "has_propco", "has_propbe", "has_peocol", "has_peto", "has_prob", "has_proocol", "has_perto", "has_prodo", "has_pbe", "has_protb", "has_propb", "has_progo", "has_pocol", "has_propto", "has_perbe", "has_protdo", "has_protocol", "has_perocol", "has_Probe", "has_Prodo", "has_perpo", "has_pego", "has_prof", "has_proco", "has_Progo", "has_pto", "has_protbe", "has_propo", "has_protco", "has_protpo", "has_Prob", "has_Proto", "has_Proocol", "has_Proco", "has_pf", "has_pedo", "has_preto", "has_probe", "has_prepo", "has_preocol", "has_protto", "has_protgo", "has_protf", "has_Prof"], "ai": ["ani", "qi", "ais", "ui", "adi", " ar", "ha", "ru", " info", "qa", "ca", "ni", "config", "ia", "i", "ini", "a", "api", "ra", "ci", "na", " mi", " acc", "AI", "aii", "ati", "air", "iri", "si", " ac", "aa", "uri", "conn", "apache", "an", "rec", "ee", "hai", "ir", "info", " api", "mi", "pa", "af", "ait", "AU", "au", "aaa", "ann", "address", " ca", " li", "ay", "eni", "agi", "ac", "afi", "aur", "attr", " ja", "wa", "bi", "ae", "sa", "pai", "ar", "oci", "aud", "iat", "ami", "fa", "abi"], "res": ["func", "args", "rez", "remote", "ret", "sys", "rr", "self", "rev", "rss", "rus", "Res", "reply", "response", "gr", "core", "complete", "ru", "rs", "ray", "pre", "resources", "ra", "rar", "ass", "respond", "req", "ex", "os", "sr", "rows", "RES", "pres", "ras", "rh", "cr", "obj", "rec", "ris", "resource", "rx", "result", "rm", "resolution", "des", "reset", "arr", "results", "re", "rt", "r", "resp", "ress", "rep", "cache", "rest", "real", "vre", "reg", "rem", "run", "rap", "err"], "rc": ["ror", "RC", "rr", "ret", "rev", "uc", "bc", "rd", "sync", "core", "cc", "pc", "code", "id", "lc", "fun", "rn", "req", "auc", "rg", "ref", " src", "cmp", "ct", "error", "loc", "rh", "conn", "cr", "rank", "rec", "rb", "nc", "ck", "success", "rx", "co", "rin", "result", "ann", "rl", "inc", "c", "dc", "ac", "anc", "cb", "sc", "rt", "ack", "r", "src", "irm", "cur", "fc", "len", "round", "irc", "err"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool run_poll_handlers(AioContext *ctx, int64_t max_ns)\n\n{\n\n    bool progress = false;\n\n    int64_t end_time;\n\n\n\n    assert(ctx->notify_me);\n\n    assert(ctx->walking_handlers > 0);\n\n    assert(ctx->poll_disable_cnt == 0);\n\n\n\n    trace_run_poll_handlers_begin(ctx, max_ns);\n\n\n\n    end_time = qemu_clock_get_ns(QEMU_CLOCK_REALTIME) + max_ns;\n\n\n\n    do {\n\n        AioHandler *node;\n\n\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->io_poll &&\n\n                node->io_poll(node->opaque)) {\n\n                progress = true;\n\n            }\n\n\n\n            /* Caller handles freeing deleted nodes.  Don't do it here. */\n\n        }\n\n    } while (!progress && qemu_clock_get_ns(QEMU_CLOCK_REALTIME) < end_time);\n\n\n\n    trace_run_poll_handlers_end(ctx, progress);\n\n\n\n    return progress;\n\n}\n", "idx": 14777, "substitutes": {"ctx": ["context", "ch", "tx", "cam", "cm", "bc", "pkg", "cv", "ca", "qa", "queue", "cc", "pc", "config", "jp", "ctr", "Context", "gc", "lc", "cs", "ctrl", "ci", "conv", "cn", "cmp", "loc", "ct", "gru", "cgi", "nw", "conn", "cr", "grad", "cot", "nc", "cli", "kt", "tc", "cus", "component", "ck", "ocr", "cfg", "c", "cca", "crit", "cu", "anc", "cb", "cas", "sc", "sci", "ce", "cmd", "cf", "cp", "exec", "que", "vc", "xc", "ga", "cache", "css", "git", "hw", "fw"], "max_ns": ["max_seconds", " max_sync", "max_rs", "end_names", "max__names", "maxacsize", "max__ms", "max__lines", "maxacns", "max__ns", "max_size", "max0000ns", "end_lines", "max0000sync", "maxacsync", "max_sync", " max_nc", "max0000nc", "max_ms", "end_ns", " max_seconds", "max_lines", "max_names", "max_nc", "max0000seconds", "maxacrs", " max_rs", " max_size", "end_ms"], "end_time": ["end_cost", "endxtime", "max_clock", "end_call", "begin_time", "end_clock", "begin_length", "end_length", "end_timer", "max_weight", "beginmvalue", "endentimes", "endencall", "beginmlength", "endmtime", "beginmtime", "begin_value", "endenclock", "end_weight", "endentime", "max_timer", "endxlength", "max_call", "begin_cost", "endmvalue", "endxvalue", "endiantime", "endmcost", "end_times", "beginmcost", "max_times", "endiantimer", "max_time", "endiantimes", "endmlength", "endianweight", "endxcost", "end_value"], "node": ["ode", "consumer", "path", "remote", "edge", "context", "root", "self", "worker", "native", "config", "id", "cdn", "object", "child", "nn", "name", "connection", "source", "event", "null", "ref", "raw", "live", "dest", "fn", "slave", "master", "server", "key", "nw", "tree", "peer", "package", "client", "view", "parse", "stage", "document", "instance", "handler", "resource", "leaf", "component", "op", "n", "none", "parent", "ready", "query", "holder", "global", "route", "ridge", "load", "host", "graph", "od", "Node", "content", "hop", "num", "core", "post", "index"]}}
{"project": "FFmpeg", "commit_id": "3c5cf2a31b4b29a8e4282cbe6a3f0617c14698b8", "target": 0, "func": "static int screenpresso_decode_frame(AVCodecContext *avctx, void *data,\n\n                                     int *got_frame, AVPacket *avpkt)\n\n{\n\n    ScreenpressoContext *ctx = avctx->priv_data;\n\n    AVFrame *frame = data;\n\n    int keyframe;\n\n    int ret;\n\n\n\n    /* Size check */\n\n    if (avpkt->size < 3) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small (%d)\\n\", avpkt->size);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* Basic sanity check, but not really harmful */\n\n    if ((avpkt->data[0] != 0x73 && avpkt->data[0] != 0x72) ||\n\n        avpkt->data[1] != 8) { // bpp probably\n\n        av_log(avctx, AV_LOG_WARNING, \"Unknown header 0x%02X%02X\\n\",\n\n               avpkt->data[0], avpkt->data[1]);\n\n    }\n\n    keyframe = (avpkt->data[0] == 0x73);\n\n\n\n    /* Resize deflate buffer and frame on resolution change */\n\n    if (ctx->inflated_size != avctx->width * avctx->height * 3) {\n\n        av_frame_unref(ctx->current);\n\n        ret = ff_get_buffer(avctx, ctx->current, AV_GET_BUFFER_FLAG_REF);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        /* If malloc fails, reset len to avoid preserving an invalid value */\n\n        ctx->inflated_size = avctx->width * avctx->height * 3;\n\n        ret = av_reallocp(&ctx->inflated_buf, ctx->inflated_size);\n\n        if (ret < 0) {\n\n            ctx->inflated_size = 0;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* Inflate the frame after the 2 byte header */\n\n    ret = uncompress(ctx->inflated_buf, &ctx->inflated_size,\n\n                     avpkt->data + 2, avpkt->size - 2);\n\n    if (ret) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Deflate error %d.\\n\", ret);\n\n        return AVERROR_UNKNOWN;\n\n    }\n\n\n\n    /* When a keyframe is found, copy it (flipped) */\n\n    if (keyframe)\n\n        av_image_copy_plane(ctx->current->data[0] +\n\n                            ctx->current->linesize[0] * (avctx->height - 1),\n\n                            -1 * ctx->current->linesize[0],\n\n                            ctx->inflated_buf, avctx->width * 3,\n\n                            avctx->width * 3, avctx->height);\n\n    /* Otherwise sum the delta on top of the current frame */\n\n    else\n\n        sum_delta_flipped(ctx->current->data[0], ctx->current->linesize[0],\n\n                          ctx->inflated_buf, avctx->width * 3,\n\n                          avctx->width * 3, avctx->height);\n\n\n\n    /* Frame is ready to be output */\n\n    ret = av_frame_ref(frame, ctx->current);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Usual properties */\n\n    if (keyframe) {\n\n        frame->pict_type = AV_PICTURE_TYPE_I;\n\n        frame->key_frame = 1;\n\n    } else {\n\n        frame->pict_type = AV_PICTURE_TYPE_P;\n\n    }\n\n    *got_frame = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14813, "substitutes": {"avctx": ["verkb", "abconn", "versci", "avlc", "avsci", "aflc", "versync", "akcmp", "afxc", "navctx", "apcmp", "AVcf", "afconfig", "vercf", "avesync", "avcu", " avcontext", "avecmp", "avxc", "navcontext", "avecontext", "avconfig", "avenp", "avctl", "avcp", "Avconfig", "afnp", "abctx", "navpkg", "AVconfig", "afconn", "abcontext", "avekb", "avecp", "abcmp", "apcontext", "afcf", " avconfig", "AVcontext", "avectx", "abxc", "abcu", "AVnp", "afcu", "afsync", "AVconn", "AVlc", "avnp", "afcontext", "avkb", "AVpkg", "akctx", "avconn", "avectrl", " avcu", "avctrl", "akcontext", "afsci", "AVsync", "avesci", "avepkg", "avcf", "vercontext", "navsync", "avsync", "aveconfig", "vercmp", "verctx", "avecf", "navcf", "afctx", "afctl", "Avcontext", "afpkg", "akctl", "afkb", "AVcmp", "Avctx", "avcmp", "apctl", "AVcp", "avelc", "verctrl", "AVcu", "afcmp", "Avcu", "apctx", "afcp", "AVctrl", "avcontext", "aveconn", "AVctx", "avexc", "avpkg", "afctrl"], "data": ["area", "device", "batch", "val", "i", "memory", "shape", "sample", "align", "image", "new", "bytes", "x", "raw", "ul", "media", "base", "reader", "count", "lines", "end", "offset", "fail", "get", "window", "in", "index", "message", "actions", "draw", "call", "head", "bin", "part", "slice", "d", "id", "api", "weight", "missing", "to", "script", "key", "client", "instance", "byte", "length", "result", "number", "feed", "body", "results", "ack", "cache", "empty", "addr", "header", "depth", "complete", "style", "connection", "buffer", "valid", "value", "alpha", "ad", "pipe", "block", "first", "DATA", "load", "video", "pos", "delay", "channel", "it", "record", "ui", "as", "input", "response", "shift", "code", "split", "a", "name", "gap", "capacity", "present", "size", "wave", "p", "buf", "read", "parent", "dat", "next", "Data", "file", "scale", "last", "content", "pad", "start"], "got_frame": ["get2frame", "gotoutbuffer", "got_buffer", "gotoutframe", "got_image", "get_frames", "got2frames", "get_buffer", "get2buffer", "got2frame", "get_image", "get2image", "got2buffer", "get2frames", "gotoutframes", "got_frames", "gotoutimage", "get_frame", "got2image"], "avpkt": ["avperet", "avfdr", "avPcht", "affnt", "affcht", "avpud", "avfelt", "AVPdr", "avcpdt", "avpoleter", "avpruth", " avdacket", " avfpcht", "avdkt", "avppkt", "avperkt", "AVpdr", "avPdr", "avprnt", "akpud", "avfpacket", "avfpsth", "akpck", "avPck", "avkkt", "avcpkt", "affft", "avmkt", "afffx", "avpaelt", "AVpacket", "avbpka", "avbpkt", "avpraga", "afpacker", "avwpdat", "avfcht", "avPacket", "avpwd", "avprwd", "avebwd", "avepeter", "avpolwd", " avpnt", "avcpdat", "avcpacket", "avpfx", "avdnt", "avspkt", "avpacker", " avbpka", "avdacket", "avnpkt", "avbpelt", "avkacket", "afpcht", "avdud", "avmfx", "avpsth", "avpaga", " avfpkt", "avbeter", "affuth", "afpdt", "avpeuth", "avpacket", "avppacker", "avpck", "avfdt", "avvpck", "avpekt", "avepkt", "affacket", "akpkt", "avcputh", "affdat", "akprud", "avpace", "affelt", "akpruth", "avvkt", "avperacket", "avpcht", "avspacket", "avfft", " avpcht", "avputh", "avnpce", "afpkt", " avpsth", "avpnt", "avpolaga", "avmet", "avpelt", " avpelt", "avfck", "akprck", "avnpelt", "avspsth", "avfkt", "afpelt", "avbacket", "avebaga", "avfpkt", "avbwd", "AVPacket", "avvpdr", "avpeelt", "afpdat", " avfpacket", "affet", "AVPkt", "avfacker", "avPkt", "avvcht", "akputh", "avpka", "avepwd", "afpacket", "avpakt", "avppacket", "avpdat", "avwpkt", " avdud", "avprkt", "avprud", " avfpsth", " avpka", "avpce", "AVpkt", "avfdat", "avPud", " avbpce", "avkuth", "avfud", "avpeter", "avebkt", "avppft", "avvnt", "avmacket", "avcpck", "avpracket", "avPuth", "avpdt", " avbpkt", "avffx", "akprkt", "afpfx", "avwpacket", "avfacket", "AVPck", "avbcht", "affacker", "avpaka", "avnpka", " avpud", " avbpelt", "avbkt", "affdt", " avpce", "avspcht", "AVpck", "avpreter", "afpft", "avcpacker", "avcpft", "affkt", "afpnt", "avvpacket", "afpet", "avbnt", " avpacket", "avwpdt", "avfnt", "avPsth", "avpeacket", "avbaga", "avvacket", "avpet", "avpolkt", "avprck", "avpft", "avkelt", "avvpkt", "avfuth", "avcpud", "avperfx", " avdkt", "avebeter", "avpdr", "avfpcht", "afputh", "avfet", " avdnt", "avepaga", "avbpce"], "ctx": [" context", "sys", "context", "tx", "cam", "cm", "pkg", "qa", "cv", "ca", "bc", "sync", "cc", "config", "pc", "cdn", "utils", "Context", "ctrl", "lc", "ci", "act", "cs", "conv", "wx", "cn", "cms", "wcs", "cmp", "sq", "loc", " cx", "conn", "client", "np", "kw", "uc", "comp", "ck", "tc", "co", "component", "nc", "cli", "cus", "acl", "cfg", "c", "cca", "crit", "cu", "anc", "cb", "cas", "sci", "cmd", "cf", "coll", "cp", "exec", "kb", "vc", "xc", "qq", "css", "support", "hw", "fw"], "frame": ["board", "context", "part", "Frame", "slice", "code", "iframe", "object", "shot", "row", "image", "event", "buffer", "session", "value", "element", "document", "view", "instance", "component", "result", "flow", "parent", "block", "seq", "window", "node"], "keyframe": ["KEYFrame", " keyfram", "KEYflow", "matchline", "keyblock", "switchhole", "keyfram", " keyword", "linkframe", "keyword", "KeyFrame", "linksequence", "linkfram", "matchhole", "switchline", "Keyframe", "switchFrame", "matchframe", "Keyword", "KEYsequence", "keyFrame", "KEYword", "keysequence", "KEYfram", " keyflow", "switchframe", "KEYframe", " keyblock", "linkblock", " keysequence", "keyline", "matchFrame", "KEYblock", "Keyflow", "keyflow", " keyhole", " keyline", " keyFrame", "keyhole"], "ret": ["en", "reply", "art", "val", "def", "gt", "status", "ct", "obj", "active", "rb", "bf", "att", "cat", "fail", "RET", "num", "debug", "ft", "rev", "done", "rc", "rets", "sr", "arg", "det", "error", "pass", "detail", "mt", "ext", "result", "url", "try", "al", "res", "reg", "rf", "flag", "run", "alt", "let", "format", "fun", "ref", "lit", "info", "Ret", "rl", "reset", "nt", "re", "rt", "rep", "no", "usr", "post", "bit", "replace", "err", "code", "back", "bad", "hash", "feat", "success", "match", "resp", "db", "len"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814, "substitutes": {"reg": ["port", "proc", " REG", "un", "bad", "name", "req", "eg", "arg", "mod", "registered", "loc", "pred", "region", "conn", "feat", "win", "aug", "rec", "mem", "sec", "ang", "eng", "min", "rol", "Reg", "stat", " Reg", "re", "REG", "param", "tag", "res", "addr", "num", "rel", "index"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816, "substitutes": {"env": ["erv", "en", "enc", "ea", "eye", "config", "ni", "ini", "priv", "eu", "iv", "anne", "sr", "ie", "si", "scope", "init", "server", "v", "conf", "conn", "obj", "ind", "e", "equ", "inst", "state", "eni", "ridge", "ov", "ev", "inet", "ec", "environment", "iss", "err"], "rip": ["oper", "stri", "ru", "rid", "jp", "rs", "iv", "ra", "rn", "riv", "sr", "ick", "iri", "rio", "uri", "raf", "rh", "rub", "tri", "trip", "ris", "rx", "rin", "op", "RI", "rw", "rou", "ip", "serv", "route", "pin", "ro", "cap", "rt", "strip", "rap", "raped"], "value": ["port", "format", "service", "response", "val", "i", "object", "iv", "child", "name", "values", "VALUE", "image", "null", "vector", "si", "key", "server", "v", "uri", "valid", "vi", "set", "VI", "Value", "resource", "data", "entry", "RI", "property", "result", "ip", "end", "rule", "sv", "write", "prefix", "reg", "index"], "ri": ["ani", "stri", "rid", "ni", "ai", "xi", "ini", "i", "gi", "iv", "io", "ra", "ci", "ki", "di", "sr", "iri", "si", "rio", "uri", "vi", "tri", "ris", "mi", "rx", "rin", "li", "RI", "ti", "rm", "ip", "ry", "pin", "ro", "pi", "rt", "pri", "ori", "nic", "abi"]}}
{"project": "qemu", "commit_id": "0e22a2d18998fd183c8181663981eb681ca977e9", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822, "substitutes": {"s": ["args", "south", "sys", "ses", "m", "self", "service", "sync", "d", "sg", "t", "fs", "i", "rs", "sym", "a", "g", "cs", "S", "settings", "os", "new", "es", "js", "sq", "secure", "server", "v", "session", "storage", "ss", "ps", "conf", "o", "u", "params", "p", "e", "instance", "sf", "b", "sb", "f", "tests", "gs", "less", "spec", "ns", "serv", "c", "is", "ssl", "services", "r", "ds", "su", "ls", "ts", "us", "ks", "aws"], "vdev": ["qdev", " vserial", "fpub", "qdist", " vdiv", "qhost", "qserial", "qdi", "tvtech", "vrhost", "vserial", "ftech", "svdi", " vpub", " vde", "svserial", "vrdev", "fdev", " vdist", "vdiv", "qdevice", "vdi", "fde", "svbus", "vrdevice", "fdiv", "svdevice", "fdevice", "tvpub", "vhost", "vdevice", " vtech", "tvdevice", "svdiv", " vdevice", "vbus", "vdist", " vdi", "tvdev", "vrdist", " vbus", "vpub", " vhost", "vtech", "svde", "vde", "svdev"], "qbus": [" qb", "qubuild", "qhub", "Qb", "quhub", "qb", "qproc", "sqbuild", "Qbus", "qubus", "quickbus", "pproc", "quda", "Qcase", "qbs", "Qproc", "sqda", "pboot", "qucase", "Qbs", "qboot", "Qboot", "qcase", "quproc", "quickbuild", "sqbus", "qubs", "pbus", "quboot", "pbs", "qda", "qbuild", "quickhub", " qboot", "quickda", " qcase", "sqhub", "qub"], "k": ["ke", "dk", "kind", "wk", "ijk", "ak", "tk", "unk", "ko", "g", "kick", " K", "ki", "uk", "sk", "kernel", "key", "kw", "o", "p", "ku", "ok", "ck", "spec", "mk", "c", "K", "q", "kin", "ack", "get", "kb", "ik", "ky", "work", "kid", "ks"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823, "substitutes": {"d": ["D", "dh", "draw", "m", "done", "fd", "t", "id", "l", "da", "bd", "g", "dl", "di", "nd", "ld", "gd", "pd", "grad", "ad", "ind", "dev", "p", "e", "dict", "plugin", "z", "data", "sd", "b", "n", "f", "xd", "dat", "c", "dad", "df", "dt", "dc", "md", "ds", "dd", "db", "od", "dn", "dr", "dom"], "val": ["alt", "slot", "_", "put", "fl", "split", "pt", "pre", "VAL", "eval", "py", "x", "unit", "vol", "loc", "valid", "v", "value", "key", "pol", "ind", "dev", "p", "ee", "fi", "data", "b", "base", "count", "bal", "f", "ann", "ay", "il", "ol", "elt", "all", "sl", "Val", "aval", "cal", "pr", "rot", "al", "sel", "el", "ot", "len", "max", "vals", "index"]}}
{"project": "qemu", "commit_id": "1931076077254a2886daa7c830c7838ebd1f81ef", "target": 0, "func": "void memory_global_dirty_log_stop(void)\n\n{\n\n    global_dirty_log = false;\n\n\n\n    /* Refresh DIRTY_LOG_MIGRATION bit.  */\n\n    memory_region_transaction_begin();\n\n    memory_region_update_pending = true;\n\n    memory_region_transaction_commit();\n\n\n\n    MEMORY_LISTENER_CALL_GLOBAL(log_global_stop, Reverse);\n\n}\n", "idx": 14840, "substitutes": {}}
{"project": "qemu", "commit_id": "77eec1b3f1493ca4813eae2fbf8702d1ef58f147", "target": 0, "func": "static inline int open_by_handle(int mountfd, const char *fh, int flags)\n\n{\n\n    errno = ENOSYS;\n\n    return -1;\n\n}\n", "idx": 14842, "substitutes": {"mountfd": ["procfd", "procdb", "mountdb", "mountd", "devd", "devor", "procor", "_or", "_d", "_db", "mountor", "_fd", "devfd", "devdb", "procd"], "fh": [" fH", "sfH", "fdH", "fdhh", "fH", "fhh", "fdh", "fdhs", "sfhh", "sfh", " fhs", "fhs", "sfhs", " fhh"], "flags": ["types", "args", "FLAG", "fs", "name", "settings", "ants", "files", "s", "options", "data", "features", "mode", "mask", "magic", "bits", "Flags", "offset", "stats", "ags", "ents", "ops", "windows", "flag", "len", "ptr", "vals"]}}
{"project": "qemu", "commit_id": "541dc0d47f10973c241e9955afc2aefc96adec51", "target": 0, "func": "static void cmd_get_event_status_notification(IDEState *s,\n\n                                              uint8_t *buf)\n\n{\n\n    const uint8_t *packet = buf;\n\n\n\n    struct {\n\n        uint8_t opcode;\n\n        uint8_t polled;        /* lsb bit is polled; others are reserved */\n\n        uint8_t reserved2[2];\n\n        uint8_t class;\n\n        uint8_t reserved3[2];\n\n        uint16_t len;\n\n        uint8_t control;\n\n    } __attribute__((packed)) *gesn_cdb;\n\n\n\n    struct {\n\n        uint16_t len;\n\n        uint8_t notification_class;\n\n        uint8_t supported_events;\n\n    } __attribute((packed)) *gesn_event_header;\n\n\n\n    enum notification_class_request_type {\n\n        NCR_RESERVED1 = 1 << 0,\n\n        NCR_OPERATIONAL_CHANGE = 1 << 1,\n\n        NCR_POWER_MANAGEMENT = 1 << 2,\n\n        NCR_EXTERNAL_REQUEST = 1 << 3,\n\n        NCR_MEDIA = 1 << 4,\n\n        NCR_MULTI_HOST = 1 << 5,\n\n        NCR_DEVICE_BUSY = 1 << 6,\n\n        NCR_RESERVED2 = 1 << 7,\n\n    };\n\n    enum event_notification_class_field {\n\n        ENC_NO_EVENTS = 0,\n\n        ENC_OPERATIONAL_CHANGE,\n\n        ENC_POWER_MANAGEMENT,\n\n        ENC_EXTERNAL_REQUEST,\n\n        ENC_MEDIA,\n\n        ENC_MULTIPLE_HOSTS,\n\n        ENC_DEVICE_BUSY,\n\n        ENC_RESERVED,\n\n    };\n\n    unsigned int max_len, used_len;\n\n\n\n    gesn_cdb = (void *)packet;\n\n    gesn_event_header = (void *)buf;\n\n\n\n    max_len = be16_to_cpu(gesn_cdb->len);\n\n\n\n    /* It is fine by the MMC spec to not support async mode operations */\n\n    if (!(gesn_cdb->polled & 0x01)) { /* asynchronous mode */\n\n        /* Only polling is supported, asynchronous mode is not. */\n\n        ide_atapi_cmd_error(s, SENSE_ILLEGAL_REQUEST,\n\n                            ASC_INV_FIELD_IN_CMD_PACKET);\n\n        return;\n\n    }\n\n\n\n    /* polling mode operation */\n\n\n\n    /*\n\n     * These are the supported events.\n\n     *\n\n     * We currently only support requests of the 'media' type.\n\n     */\n\n    gesn_event_header->supported_events = NCR_MEDIA;\n\n\n\n    /*\n\n     * We use |= below to set the class field; other bits in this byte\n\n     * are reserved now but this is useful to do if we have to use the\n\n     * reserved fields later.\n\n     */\n\n    gesn_event_header->notification_class = 0;\n\n\n\n    /*\n\n     * Responses to requests are to be based on request priority.  The\n\n     * notification_class_request_type enum above specifies the\n\n     * priority: upper elements are higher prio than lower ones.\n\n     */\n\n    if (gesn_cdb->class & NCR_MEDIA) {\n\n        gesn_event_header->notification_class |= ENC_MEDIA;\n\n        used_len = event_status_media(s, buf);\n\n    } else {\n\n        gesn_event_header->notification_class = 0x80; /* No event available */\n\n        used_len = sizeof(*gesn_event_header);\n\n    }\n\n    gesn_event_header->len = cpu_to_be16(used_len\n\n                                         - sizeof(*gesn_event_header));\n\n    ide_atapi_cmd_reply(s, used_len, max_len);\n\n}\n", "idx": 14846, "substitutes": {"s": ["secondary", "south", "sys", "ses", "m", "service", "t", "d", "sync", "fs", "sed", "private", "sym", "S", "submit", "status", "sets", "es", "session", "server", "ss", "o", "se", "sec", "resource", "e", "sf", "sb", "b", "f", "stat", "spec", "c", "is", "stats", "ssl", "side", "sl", "states", "services", "r", "ds"], "buf": ["bridge", "map", "port", "vec", "runner", "context", "uc", "bc", "queue", "fd", "array", "cv", "tmp", "batch", "config", "mount", "fb", "msg", "uf", "ref", "buffer", "bag", "append", "fp", "v", "buff", "output", "rb", "pb", "data", "fab", "b", "Buffer", "wb", "f", "result", "cb", "cmd", "que", "src", "seq", "pad", "ptr", "alloc", "callback"], "packet": ["packant", " packant", "packsets", "parametter", "bucketter", "compets", "passets", "packeter", " packetter", "packets", "packsen", "passen", "paramet", "passet", " packeter", "bucket", "compen", "packetter", "bucketer", "compet", "packen", "packacket", "packsacket", "parameter", "buckant", "packset", "compacket", "paramant", "passacket"], "reserved2": ["preserved2", "reserve0", "reserved4", "presumed0", "resumed0", "respired4", "respired2", "presumed2", "respired0", "reserved0", "resumed4", "reserve4", "presumed4", "reserve2", "resumed2", "preserved0", "preserved4"], "reserved3": ["reserved03", "preserve3", "reserved4", "resigned3", "reservation3", "preserved3", "resigned5", "preserve03", "preserve4", "reservation5", "resigned03", "reserved5", "reservation4", "preserve5", "preserved5", "reserve3", "reservation03", "reserve5", "reserve4", "preserved03", "resigned4", "reserve03", "preserved4"], "gesn_cdb": ["gesn_tds", "gesn_fds", "gesn_csonda", "gesn_xcdb", "gesn_gdoc", "gesn_mcdoc", "gesnLogcDb", "gesn_ecmb", "gesn_colldb", "gesn_fdata", "gesn_cmdb", "gesn_ncdoc", "gesnLogcmdb", "gesn_cDb", "gesn_fdb", "gesn_mcDb", "gesnLogcmdoc", "gesn_tdb", "gesn_toder", "gesn_csdb", "gesn_xcdoc", "gesn_csde", "gesn_codb", "gesn_econda", "gesn_collde", "gesn_gdb", "gesn_conda", "gesn_conn", "gesn_cmDb", "gesn_csbm", "gesn_cbm", "gesn_recdb", "gesn_cdoc", "gesn_ecnn", "gesnLogcpy", "gesn_gonda", "gesn_gde", "gesnLogcdb", "gesn_cbal", "gesn_cmdoc", "gesn_cnn", "gesn_foder", "gesn_cds", "gesn_codoc", "gesn_cdata", "gesn_ncdb", "gesn_cmb", "gesn_cpy", "gesn_coder", "gesn_recnn", "gesn_ecbm", "gesn_cmpy", "gesn_recmb", "gesn_gpy", "gesn_ncnn", "gesn_csds", "gesnLogcdoc", "gesn_csoder", "gesn_collmb", "gesn_csdata", "gesn_tdata", "gesnLogcmpy", "gesn_xcbal", "gesn_mcdb", "gesn_cobal", "gesnLogcmDb", "gesn_xcnn", "gesn_collnn", "gesn_gDb", "gesn_ecdb", "gesn_mcpy", "gesn_gbm", "gesn_ncbal", "gesn_recde", "gesn_cde", "gesn_ecde"], "max_len": ["maxxlength", "max_bin", "max\u00b7pos", "max2fen", "maxxbin", "max2len", "max_fen", "max\u00b7en", "maxxlen", " max2fen", " max_bin", " max_Len", " max_pos", "max_pos", "max\u00b7fen", "max\u00b7len", " max_fen", " max_length", "max_length", "max_Len", "max2pos", " max2len", "maxxLen", " max2pos", "max_en", " max_en", "max2en", " max2en"], "used_len": ["used67lim", "next67cache", "used7len", "used67cache", "used67val", "used7cache", "next_cache", "used2lim", "used7val", "used7lim", "next_lim", "used2val", "next_len", "used2cache", "used_lim", "used67len", "next_val", "used2len", "used_val", "next67len", "used_cache", "next67val", "next67lim"]}}
{"project": "FFmpeg", "commit_id": "850c6db97d1f78e7607952ab8b854a93a185319e", "target": 0, "func": "static int decode_plane(UtvideoContext *c, int plane_no,\n\n                        uint8_t *dst, int step, ptrdiff_t stride,\n\n                        int width, int height,\n\n                        const uint8_t *src, int use_pred)\n\n{\n\n    int i, j, slice, pix;\n\n    int sstart, send;\n\n    VLC vlc;\n\n    GetBitContext gb;\n\n    int prev, fsym;\n\n    const int cmask = c->interlaced ? ~(1 + 2 * (!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P)) : ~(!plane_no && c->avctx->pix_fmt == AV_PIX_FMT_YUV420P);\n\n\n\n    if (build_huff(src, &vlc, &fsym)) {\n\n        av_log(c->avctx, AV_LOG_ERROR, \"Cannot build Huffman codes\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (fsym >= 0) { // build_huff reported a symbol to fill slices with\n\n        send = 0;\n\n        for (slice = 0; slice < c->slices; slice++) {\n\n            uint8_t *dest;\n\n\n\n            sstart = send;\n\n            send   = (height * (slice + 1) / c->slices) & cmask;\n\n            dest   = dst + sstart * stride;\n\n\n\n            prev = 0x80;\n\n            for (j = sstart; j < send; j++) {\n\n                for (i = 0; i < width * step; i += step) {\n\n                    pix = fsym;\n\n                    if (use_pred) {\n\n                        prev += pix;\n\n                        pix   = prev;\n\n                    }\n\n                    dest[i] = pix;\n\n                }\n\n                dest += stride;\n\n            }\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    src      += 256;\n\n\n\n    send = 0;\n\n    for (slice = 0; slice < c->slices; slice++) {\n\n        uint8_t *dest;\n\n        int slice_data_start, slice_data_end, slice_size;\n\n\n\n        sstart = send;\n\n        send   = (height * (slice + 1) / c->slices) & cmask;\n\n        dest   = dst + sstart * stride;\n\n\n\n        // slice offset and size validation was done earlier\n\n        slice_data_start = slice ? AV_RL32(src + slice * 4 - 4) : 0;\n\n        slice_data_end   = AV_RL32(src + slice * 4);\n\n        slice_size       = slice_data_end - slice_data_start;\n\n\n\n        if (!slice_size) {\n\n            av_log(c->avctx, AV_LOG_ERROR, \"Plane has more than one symbol \"\n\n                   \"yet a slice has a length of zero.\\n\");\n\n            goto fail;\n\n        }\n\n\n\n        memset(c->slice_bits + slice_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);\n\n        c->bdsp.bswap_buf((uint32_t *) c->slice_bits,\n\n                          (uint32_t *)(src + slice_data_start + c->slices * 4),\n\n                          (slice_data_end - slice_data_start + 3) >> 2);\n\n        init_get_bits(&gb, c->slice_bits, slice_size * 8);\n\n\n\n        prev = 0x80;\n\n        for (j = sstart; j < send; j++) {\n\n            for (i = 0; i < width * step; i += step) {\n\n                pix = get_vlc2(&gb, vlc.table, VLC_BITS, 3);\n\n                if (pix < 0) {\n\n                    av_log(c->avctx, AV_LOG_ERROR, \"Decoding error\\n\");\n\n                    goto fail;\n\n                }\n\n                if (use_pred) {\n\n                    prev += pix;\n\n                    pix   = prev;\n\n                }\n\n                dest[i] = pix;\n\n            }\n\n            if (get_bits_left(&gb) < 0) {\n\n                av_log(c->avctx, AV_LOG_ERROR,\n\n                        \"Slice decoding ran out of bits\\n\");\n\n                goto fail;\n\n            }\n\n            dest += stride;\n\n        }\n\n        if (get_bits_left(&gb) > 32)\n\n            av_log(c->avctx, AV_LOG_WARNING,\n\n                   \"%d bits left after decoding slice\\n\", get_bits_left(&gb));\n\n    }\n\n\n\n    ff_free_vlc(&vlc);\n\n\n\n    return 0;\n\nfail:\n\n    ff_free_vlc(&vlc);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 14848, "substitutes": {"c": ["m", "ch", "self", "cm", "bc", "uc", "d", "cv", "ca", "t", "rc", "config", "pc", "l", "cc", "C", "lc", "cs", "g", "ctrl", "ci", "mc", "h", "cn", "cy", "cmp", "con", "ct", "v", "conf", "client", "cr", "cd", "u", "p", "e", "s", "nc", "k", "tc", "b", "co", "n", "f", "cat", "dc", "cu", "ac", "cb", "sc", "ce", "cf", "coll", "cp", "com", "center", "vc", "xc", "cache", "ec", "cur", "cl", "ctx"], "plane_no": ["planeqpos", "source_no", "plane_NO", "sourceqno", "planeqnumber", " plane_number", " plane_none", "plane__wa", "plane_number", "sourceqpos", "card__na", "source_spec", "card_na", "sourceqNO", "plane__no", "sourceqspec", "card_wa", "card__no", "card_no", "card__wa", "source_pos", "plane_na", "planeqnone", "plane_none", "planeqspec", "plane__na", "plane_wa", "card_info", "source_NO", "planeqno", "planeqNO", "plane_spec", "plane_info", "card__info", "plane_pos", "plane__info"], "dst": [" dsts", "adsc", "dedsc", "Dsc", "adnd", "datsts", "Dst", "ssc", "Dsts", " dsc", "adst", "dsts", "datst", "dnd", "dedsts", "Dost", " dnd", "Dsl", "sst", "snd", "dost", "dsc", "datsc", "dedst", "datsl", " dost", "adost", "sost", " dsl", "dsl", "dedost"], "step": ["draw", "d", "batch", "shift", "seed", "shape", "sample", "ride", "weight", "ste", "st", "unit", "STEP", "patch", "Step", "set", "pass", "grad", "mix", "size", "stage", "stop", "version", "pad", "sec", "z", "move", "wait", "max", "min", "length", "speed", "skip", "flow", "grade", "strike", "change", "transform", "scale", "loop", "sl", "cycle", "steps", "hop", "dim", "depth", "start"], "stride": ["colline", "Striden", "Strance", "Strine", "strider", "trine", "divipe", "iterided", "Stride", "Strade", "trided", "Strider", "spriden", "tridi", "collade", "divide", "collide", "strided", "divance", "trip", "lenider", " strider", "sprance", "collip", "strade", "strime", "Stridi", "trime", " strance", "divider", "Strided", " striden", "strance", "sprider", "stripe", "Strip", " stripe", "iteridi", "striden", "Strime", "lenipe", "stridi", "iteride", "lenide", "tride", "iterime", "strip", "trade", "lenance", "spride", "strine"], "height": ["head", "Height", "deep", "build", "input", "thin", "dist", "bottom", "grow", "shift", "id", "seed", "density", "shape", "style", "row", "gap", "h", "gh", "crop", "square", "rh", "rank", "hang", "alpha", "size", "tight", "direction", "three", "length", "count", "th", "flow", "resolution", "inc", "scroll", "timeout", "feed", "hold", "duration", "layout", "volume", "history", "power", "hop", "window", "depth", "y"], "src": ["uc", "input", "dist", "sync", "cv", "rc", "config", "shift", "code", "seed", "stream", "split", "shape", "sup", "source", "req", "conv", "image", "sr", "crop", "loc", "secure", "sq", "sit", "sid", "rec", "img", "rb", "pack", "sec", "desc", "sb", "inst", "spec", "url", "cb", "target", "sc", "ssl", "transform", "sn", "sci", "sl", "stack", "rest", "sel", "scene", "st", "fc", "ctx", "filename", "start"], "use_pred": ["use_cod", "USE_cod", "USE__Pred", "use_prev", "USE__cod", "use__reg", "use__Pred", "use__prev", "USE_Pred", "use__cod", " use_reg", " use_Pred", "USE_pred", "USE__pred", "use_reg", " use_prev", "use_Pred", "use__pred"], "i": ["ani", "ice", "qi", "ui", "it", "m", "I", "d", "ni", "ai", "xi", "l", "ini", "gi", "io", "ci", "x", "di", "si", "ie", "ii", "v", "uri", "o", "z", "u", "p", "e", "fi", "info", "mi", "li", "ix", "b", "n", "f", "ti", "ip", "eni", "end", "inner", "ji", "pi", "im", "r", "bi", "ori", "ami", "zi", "y", "ij", "index", "start"], "j": ["adj", "ice", "it", "m", "d", "fl", "ni", "jp", "l", "shift", "jump", "g", "syn", "sp", "x", "di", "jet", "ie", "ii", "v", "o", "w", "obj", "z", "ind", "jit", "p", "e", "u", "k", "li", "b", "n", "f", "jo", "jl", "end", "jc", "je", "ji", "ne", "im", "r", "J", "pos", "num", "y", "ij", "index", "start"], "slice": ["ice", "trial", "batch", "shape", "sample", "pixel", "image", "tile", "module", "si", "loc", "spec", "grade", "single", "sc", "sl", "cell", "volume", "sub", "zi", "dim", "index", "call", "vision", "part", "series", "seed", "pick", "pose", "sequence", "script", "blade", "ski", "multiple", "route", "pe", "knife", "minute", "pocket", "zip", "edge", "sort", "slot", "service", "config", "second", "source", "sp", "plane", "section", "unit", "ie", "live", "slave", "layer", "li", "diff", "scroll", "sh", "video", "hop", "sel", "channel", "pie", "shift", "split", "player", "range", "episode", "ii", "sq", "crop", "v", "uri", "region", "hole", "size", "p", "se", "pod", "match", "fit", "sci", "scale", "pad"], "pix": [" pixel", "vpix", "Pix", "PIX", "pike", "ipipe", "vpius", "Pixels", "dpx", "pIX", "pixels", "pixel", "spius", "ipike", " pike", "dpike", "spix", "px", "ipixel", " pip", "spip", "ipx", "spicks", "pipe", "pius", "apix", "apicks", "picks", "ipixels", " pipe", "vpixel", "vpip", "ipIX", " picks", "pip", " pIX", " pius", "Pixel", "apius", " pixels", "ipix", "dpix", "Pipe", "spixel", "apixel", "dpipe", " px", "Pike"], "sstart": ["sstep", "imsskip", "entsstarting", "csmax", "statesstop", "lsstart", "statespart", "dsmax", "statesstart", "csstart", "nsstart", "ssend", "nsstop", "sesskip", "sescall", "smax", "Sstart", "gslike", "Sstop", "asstop", "csfrom", "setscall", " sstarting", "esmax", "Send", "lsmin", "gsstep", "csinfo", "nsstep", "sskip", "sesstop", "imscall", "spart", "setsstart", "scall", "gsstop", "aspart", "statesfind", "sfrom", "dsinfo", "gsstart", "setsstop", " sfind", "imsstart", "esinfo", "ssstop", "gsstarting", "dsstart", "setsskip", "entsstop", "asfind", " sstop", "nsfind", "esstart", "Smin", "dsfrom", "slike", "esfrom", "sstarting", "asstart", "ssstart", "imsstop", "sinfo", "lsend", "gsfind", " slike", "sfind", "ssmin", "sesstart", "sstop", "entsstart", "lsstop", " spart", "entslike", "smin"], "send": ["transfer", "draw", "call", "en", "sort", "carry", "service", "sync", "enc", "dist", "shift", "seed", "msg", "sup", "source", "use", "missing", "err", "status", "mit", "init", "update", "nd", "Send", "append", "force", "give", "set", "check", "parse", "size", "ind", "se", "sec", "pack", "desc", "share", "eng", "nil", "pend", "read", "speed", "add", "export", "find", "end", "feed", "sc", "text", "transform", "scale", "write", "get", "sent", "see", "last", "push", "destroy", "start"], "vlc": ["vcc", "vlci", "llcs", "vrac", "vccs", "llu", "vcu", "vrct", "lvcli", "vcci", "lvc", "llci", "vlu", "vrcli", "wlci", "llcli", "vlcs", "vrc", "llc", "vlcli", "vlct", "wlcs", "llct", "wlu", "llac", "vlac", "wlc", "lvct", "lvac"], "gb": [" bc", "bc", " cd", "rc", " cf", "VC", " alloc", " cu", " comp", "ci", " img", " lib", " acc", " conv", " ac", " conf", " cmd", " co", " ic", " cal", " cis", " enc", " scr", " gcc", " parent", "vc", "CC", " gl", " config"], "prev": ["vec", "before", "ch", "rev", "root", "enc", "shift", "jump", "seed", "jp", "orig", "iv", "back", "pre", "val", "sup", "code", "gap", "req", "original", "ref", "cmp", "init", "pop", "sav", "append", "loc", "pres", "pred", "nav", "v", "var", "fix", "vert", "pass", "trip", "rec", "Prev", "p", "img", "comp", "op", "inst", "old", "pend", "wp", "skip", "best", "parent", "vious", "ip", "next", "block", "above", "par", "gen", "reverse", "last", "cache", "history", "rest", "seq", "rel", "post"], "fsym": ["bsm", " fscope", "tfSym", "psid", "fsm", "hcm", "hsym", "hsid", "tsid", "psm", "bsid", "tsym", "fcm", " fSym", "fym", "pym", "bsy", "hscope", "pSym", " fsy", "fSym", "tfsym", "fsy", "tSym", "tfsm", "tscope", "pnm", "hsy", "tcm", "psym", "tnm", "tsy", "tfym", "fsid", "bsym", " fym", "fscope", " fsid", " fsm", "fnm", " fnm", " fcm", "hsm"], "dest": ["dist", "delete", "flat", "append", "loc", "end", "reverse", "sc", "transform", "text", "Dest", "miss", "prop", "destroy", "dim", "comb", "true", "draw", "done", "sync", "seed", "sup", "sum", "pass", "img", "data", "route", "cont", "stack", "decl", "transfer", "path", "sort", "config", "source", "option", "output", "scan", "trip", "stage", "desc", "global", "push", "usr", "ord", "uc", "ignore", "shift", "orig", "die", "ident", "later", "feat", "keep", "move", "trans", "parent", "dc", "outer", "target", "write", "rest", "coord", "opt"], "slice_data_start": ["slice_data_pad", "slice_data_id", "slice_data_part", "slice_data_min"], "slice_data_end": ["slice_data__end", "slice_data___set", "_", "slice_data___offset", "ctr", "slice_data_set", "slice_data__ending", "slice_data_ending", "slice_data___start", "slice_data__start", "img", "slice_data_ends", "slice_data_offset", "slice_data__ends", "slice_data___end", "r", "pos"], "slice_size": ["image_size", "image_len", "slice2count", "ice_num", "slice_offset", "image_count", "ice_size", "slice_len", "slice_index", "ice_index", "slice_num", "ice_offset", "slice_count", "slice2len", "slice2size"]}}
{"project": "FFmpeg", "commit_id": "81a8701eb52d2b6469ae16ef442ce425388141b7", "target": 0, "func": "static int ogg_buffer_data(AVFormatContext *s, AVStream *st,\n\n                           uint8_t *data, unsigned size, int64_t granule,\n\n                           int header)\n\n{\n\n    OGGStreamContext *oggstream = st->priv_data;\n\n    OGGContext *ogg = s->priv_data;\n\n    int total_segments = size / 255 + 1;\n\n    uint8_t *p = data;\n\n    int i, segments, len, flush = 0;\n\n\n\n    // Handles VFR by flushing page because this frame needs to have a timestamp\n\n    // For theora, keyframes also need to have a timestamp to correctly mark\n\n    // them as such, otherwise seeking will not work correctly at the very\n\n    // least with old libogg versions.\n\n    // Do not try to flush header packets though, that will create broken files.\n\n    if (st->codec->codec_id == AV_CODEC_ID_THEORA && !header &&\n\n        (ogg_granule_to_timestamp(oggstream, granule) >\n\n         ogg_granule_to_timestamp(oggstream, oggstream->last_granule) + 1 ||\n\n         ogg_key_granule(oggstream, granule))) {\n\n        if (oggstream->page.granule != -1)\n\n            ogg_buffer_page(s, oggstream);\n\n        flush = 1;\n\n    }\n\n\n\n    // avoid a continued page\n\n    if (!header && oggstream->page.size > 0 &&\n\n        MAX_PAGE_SIZE - oggstream->page.size < size) {\n\n        ogg_buffer_page(s, oggstream);\n\n    }\n\n\n\n    for (i = 0; i < total_segments; ) {\n\n        OGGPage *page = &oggstream->page;\n\n\n\n        segments = FFMIN(total_segments - i, 255 - page->segments_count);\n\n\n\n        if (i && !page->segments_count)\n\n            page->flags |= 1; // continued packet\n\n\n\n        memset(page->segments+page->segments_count, 255, segments - 1);\n\n        page->segments_count += segments - 1;\n\n\n\n        len = FFMIN(size, segments*255);\n\n        page->segments[page->segments_count++] = len - (segments-1)*255;\n\n        memcpy(page->data+page->size, p, len);\n\n        p += len;\n\n        size -= len;\n\n        i += segments;\n\n        page->size += len;\n\n\n\n        if (i == total_segments)\n\n            page->granule = granule;\n\n\n\n        if (!header) {\n\n            AVStream *st = s->streams[page->stream_index];\n\n\n\n            int64_t start = av_rescale_q(page->start_granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n            int64_t next  = av_rescale_q(page->granule, st->time_base,\n\n                                         AV_TIME_BASE_Q);\n\n\n\n            if (page->segments_count == 255 ||\n\n                (ogg->pref_size     > 0 && page->size   >= ogg->pref_size) ||\n\n                (ogg->pref_duration > 0 && next - start >= ogg->pref_duration)) {\n\n                ogg_buffer_page(s, oggstream);\n\n            }\n\n        }\n\n    }\n\n\n\n    if (flush && oggstream->page.granule != -1)\n\n        ogg_buffer_page(s, oggstream);\n\n\n\n    return 0;\n\n}\n", "idx": 14865, "substitutes": {"s": ["sys", "ses", "m", "self", "d", "t", "service", "sg", "sync", "fs", "sed", "rs", "g", "cs", "S", "sp", "settings", "os", "si", "js", "es", "sq", "rows", "session", "server", "v", "ps", "ss", "storage", "o", "an", "se", "e", "sam", "plugins", "http", "sb", "sf", "site", "b", "f", "stat", "spec", "c", "ns", "serv", "is", "stats", "sc", "ssl", "sv", "sl", "ops", "services", "ds", "events", "com", "sa", "src", "soc", "ls", "su", "r", "ts", "us", "uploads", "sm"], "st": ["sta", "rss", "d", "t", "config", "sed", "stream", "pt", "td", "sp", "ste", "sth", "std", "sw", "str", "tt", "ct", "ld", "fr", "ss", "client", "cr", "stage", "bl", "stop", "se", "ST", "sam", "sec", "e", "sb", "sd", "sf", "St", "inst", "est", "fe", "c", "pe", "sn", "sc", "osc", "sv", "sl", "ast", "ds", "sh", "sa", "src", "rest", "ist", "stack", "ts", "sm", "sts", "ost", "start"], "data": ["area", "draw", "done", "after", "input", "d", "response", "batch", "config", "shift", "memory", "extra", "da", "sample", "a", "api", "name", "image", "missing", "buffer", "capacity", "init", "value", "alpha", "media", "download", "info", "buf", "length", "parent", "dat", "padding", "address", "number", "block", "next", "timeout", "Data", "offset", "body", "results", "scale", "load", "DATA", "write", "last", "cache", "empty", "video", "content", "window", "delay", "start"], "size": ["en", "memory", "shape", "event", "bytes", "x", "si", "loc", "screen", "limit", "count", "speed", "c", "timeout", "offset", "fee", "message", "slice", "g", "weight", "Size", "sum", "storage", "w", "group", "six", "length", "number", "feed", "body", "cache", "empty", "small", "sized", "second", "style", "large", "connection", "buffer", "unit", "member", "value", "z", "e", "sec", "engine", "max", "address", "SIZE", "type", "sh", "video", "sea", "channel", "ui", "zero", "code", "stream", "name", "send", "capacity", " sizes", "ize", "time", "mini", "mode", "n", "scale", "write", "last", "content", "start"], "granule": ["gorue", "gnue", " granul", " granume", " granularity", " granulus", "gnule", "gnulation", "gnulus", "ranulus", "granulus", "ranule", "gorularity", "generule", "granue", "generul", "gorul", "granul", "granume", "granularity", "generules", "granulation", "ranul", "gorules", "generulation", " granue", " granules", "generularity", "gorulation", "gorulus", " granulation", "ranules", "gnules", "granules", "gnul", "gorule", "ranularity", "gnume", "generume", "gnularity"], "header": ["channel", "date", "head", "plain", "title", "numbered", "director", "back", "player", "required", "name", "source", "border", "kernel", "event", "final", "h", "buffer", "writer", "comment", "aster", "commit", "master", "error", "table", "server", "leader", "client", "request", "document", "layer", "summary", "version", "download", "reader", "parent", "padding", "cover", "number", "timeout", "offset", "body", "ssl", "loop", "hard", "debug", "middle", "forward", "author", "headers", "dr", "tail", "Header", "over", "height"], "oggstream": ["oggengine", "ggform", "ogamessage", "obbstream", "oodstring", "ogcoll", "oghost", "ogaconsole", "bbserver", "oggenc", "obbserver", "ggStream", "oggpath", "oggstring", "ogacoll", "oggserver", "oggsystem", "gghost", "grossStream", "ottform", "aggstring", "bbenc", "ogconsole", "ogpath", "ogaserver", "ggfeed", "oodengine", "aggpath", "grossserver", "oggmessage", "ogchannel", "ogmessage", "ogmodel", "ogachild", "ogarow", "aggchild", "oggloop", "obbsystem", "agginput", "ogrow", "ogainput", "ogghost", "ggserver", "aggcoll", "ogloop", "aggserver", "aggmodel", "aggconsole", "otthost", "ogginput", "aggform", "ogapath", "aggrow", "oodstream", "ogastream", "ggloop", "ogStream", "ogchild", "oginput", "grossloop", "oggfeed", "bbform", "oodround", "agground", "oggchannel", "ogserver", "aggengine", "oggmodel", "ogasystem", "ogfeed", "bbstream", "ogsystem", "ottstream", "obbengine", "grossstream", "ogengine", "ogstream", "ogform", "oggStream", "aggsystem", "ogamodel", "ggstream", "ogenc", "ottfeed", "oggconsole", "aggenc", "ogaform", "ogachannel", "aggstream", "oggrow", "ogaengine", "oggchild", "oggform", "ogstring", "oground", "ogground", "aggmessage", "aggchannel", "oggcoll"], "ogg": ["gow", "ob", "ott", "cc", "bb", "gc", "pg", "audio", "eg", "pp", "acc", "og", "mm", "gd", "oc", "gg", "oga", "ogle", "ogo", "ogs", "ocr", "gram", "omm", "org", "od", "ga", "aud", "mpeg", "ow"], "p": ["port", "m", "po", "d", "t", "pc", "l", "jp", "up", "pt", "a", "pre", "api", "g", "sp", "h", "lp", "pool", "pp", "fp", "v", "ps", "o", "bp", "np", "z", "e", "b", "pointer", "j", "n", "f", "wp", "padding", "ip", "c", "per", "pe", "pi", "q", "dp", "r", "cp", "pad", "P", "tp"], "i": ["qi", "it", "ui", "slice", "I", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "inf", "io", "ci", "ki", "image", "di", "x", "si", "ie", "ii", "uri", "vi", "o", "ind", "u", "z", "e", "mini", "fi", "mi", "li", "cli", "ix", "multi", "j", "count", "phi", "n", "f", "ti", "ski", "none", "ip", "c", "eni", "ji", "pi", "ri", "pos", "zi", "y", "esi", "index", "start"], "segments": ["teges", "pegs", "parsegs", "schegements", "secgments", "parsegments", "pseasons", "SEgment", "persegment", "pesections", " Segements", "sements", "scalegements", "persegements", "sesections", "perseles", " segement", "psegements", "seegements", "sectors", "seasons", "scalegments", "peles", "gectors", "pements", "susections", "scalegs", "segement", " Sements", "psegments", " segements", "megment", "megments", "geabytes", "SEgements", "sugs", "pseabytes", " seges", "seeabytes", "parsegements", "seabytes", "pegements", "teasons", "seles", "seges", "sugements", "pegments", "segment", "schements", "schegments", "persegments", "secgements", "telements", "gegment", " Segment", "geles", "scalegment", "megements", " sectors", "pelements", "gegments", "secgement", " segment", "selements", "seegs", "tegments", "secges", " sements", "segements", "SEgments", "peasons", "mectors", "gegements", "tegement", "pegment", "psegs", "schegment", "SEments", " Segments", "gegs", "parsesections", "seegments", " segs", "gements", "sugments", "tegements", "pselements", "segs"], "len": ["en", "rev", "lin", "fl", "Len", "l", "lon", "val", "split", "pre", "lc", "syn", "sp", "low", "lp", "dl", "loss", "lang", "lit", "loc", "fn", "limit", "conn", "lib", "dy", "ll", "mem", "la", "fin", "lt", "li", "zi", "min", "length", "n", "lf", "count", "ler", "f", "span", "url", "offset", "sl", "elt", "le", "led", "all", "den", "seq", "ls", "pos", "num", "el", "bl", "ln", "lim", "err"], "page": ["area", "word", "child", "pre", "image", "www", "module", "asc", "server", "frame", "phrase", "web", "pl", "skip", "line", "c", "end", "change", "sl", "ae", "age", "order", "index", "message", "me", "pages", "gc", "g", "full", "comment", "session", "group", "instance", "entry", "Page", "result", " Page", "average", "url", "item", "route", "pe", "cache", "ge", "edge", "queue", "config", "pc", "account", "large", "pg", "sp", "section", "option", "update", "button", "aa", "chapter", "element", "view", "document", "stage", "stop", "menu", "e", "desc", "site", "eng", "f", "html", "inc", "pm", "stall", "load", "article", "blog", "video", "sel", "theme", "ph", "post", "node", "channel", "date", "record", "root", "enc", "response", "search", "stream", "object", "row", "gap", "user", "pp", "position", "v", "meta", "request", "plugin", "display", "match", "pointer", "n", "parent", "wp", "next", "wiki", "per", "rule", "write", "content"]}}
{"project": "FFmpeg", "commit_id": "38bb5a5434f913451aa512624a92b12b9925690f", "target": 0, "func": "void mpeg4_encode_picture_header(MpegEncContext * s, int picture_number)\n\n{\n\n    int time_incr;\n\n    int time_div, time_mod;\n\n\n\n    if(s->pict_type==AV_PICTURE_TYPE_I){\n\n        if(!(s->flags&CODEC_FLAG_GLOBAL_HEADER)){\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT) //HACK, the reference sw is buggy\n\n                mpeg4_encode_visual_object_header(s);\n\n            if(s->strict_std_compliance < FF_COMPLIANCE_VERY_STRICT || picture_number==0) //HACK, the reference sw is buggy\n\n                mpeg4_encode_vol_header(s, 0, 0);\n\n        }\n\n        if(!(s->workaround_bugs & FF_BUG_MS))\n\n            mpeg4_encode_gop_header(s);\n\n    }\n\n\n\n    s->partitioned_frame= s->data_partitioning && s->pict_type!=AV_PICTURE_TYPE_B;\n\n\n\n    put_bits(&s->pb, 16, 0);                /* vop header */\n\n    put_bits(&s->pb, 16, VOP_STARTCODE);    /* vop header */\n\n    put_bits(&s->pb, 2, s->pict_type - 1);  /* pict type: I = 0 , P = 1 */\n\n\n\n    assert(s->time>=0);\n\n    time_div= s->time/s->avctx->time_base.den;\n\n    time_mod= s->time%s->avctx->time_base.den;\n\n    time_incr= time_div - s->last_time_base;\n\n    assert(time_incr >= 0);\n\n    while(time_incr--)\n\n        put_bits(&s->pb, 1, 1);\n\n\n\n    put_bits(&s->pb, 1, 0);\n\n\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, s->time_increment_bits, time_mod); /* time increment */\n\n    put_bits(&s->pb, 1, 1);                             /* marker */\n\n    put_bits(&s->pb, 1, 1);                             /* vop coded */\n\n    if (    s->pict_type == AV_PICTURE_TYPE_P\n\n        || (s->pict_type == AV_PICTURE_TYPE_S && s->vol_sprite_usage==GMC_SPRITE)) {\n\n        put_bits(&s->pb, 1, s->no_rounding);    /* rounding type */\n\n    }\n\n    put_bits(&s->pb, 3, 0);     /* intra dc VLC threshold */\n\n    if(!s->progressive_sequence){\n\n         put_bits(&s->pb, 1, s->current_picture_ptr->top_field_first);\n\n         put_bits(&s->pb, 1, s->alternate_scan);\n\n    }\n\n    //FIXME sprite stuff\n\n\n\n    put_bits(&s->pb, 5, s->qscale);\n\n\n\n    if (s->pict_type != AV_PICTURE_TYPE_I)\n\n        put_bits(&s->pb, 3, s->f_code); /* fcode_for */\n\n    if (s->pict_type == AV_PICTURE_TYPE_B)\n\n        put_bits(&s->pb, 3, s->b_code); /* fcode_back */\n\n}\n", "idx": 14872, "substitutes": {"s": ["native", "i", "rs", "qs", "h", "new", "status", "js", "si", "server", "ps", "admin", "share", "spec", "c", "is", "states", "args", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "ches", "g", "cs", "es", "full", "session", "storage", "w", "u", "sf", "b", "ns", "results", "ops", "r", "comm", "sports", "ks", "sys", "parts", "service", "your", "details", "source", "hs", "os", "sets", "scope", "o", "ms", "e", "obs", "http", "site", "sb", "f", "services", "ls", "comments", "ses", "as", "l", "a", "er", "S", "its", "uns", "sq", "conf", "ss", "request", "set", "p", "se", "plugins", "ions", "n", "gs", "xs", "ssl", "side", "ds", "su", "ts", "us", "y"], "picture_number": ["pictureityindex", "pictureIdnumber", "picture_length", "pictureIddata", "pictureIdnum", " picture_index", "image_numbered", "pictureitynum", "image_number", "image_num", " picture_num", "pictureIdnumbered", "picture_index", "image_data", "pictureitylength", "picture_numbered", "pictureitynumber", "picture_data", "picture_num", " picture_length"], "time_incr": ["time_decr", "time_integru", "time_incrb", "time_integtr", "time_deccr", "time_Incrb", "time_integr", "time_decrx", "time_increcr", "time_integrx", "time_inctr", "time_decrc", "time_incrx", "time_incrc", "time_dectr", "time_incru", "time_Inccr", "time_decrb", "time_integerc", "time_increr", "time_integrb", "time_increrc", "time_increrr", "time_wincr", "time_corr", "time_winrar", "time_winrc", "time_incrar", "time_decrr", "time_inccr", "time_incrr", "time_corru", "time_increerc", "time_Incr", "time_winr", "time_integrr", "time_integcr", "time_decru", "time_incerc", "time_corcr", "time_cortr", "time_decerc", "time_integrc", "time_increrar", "time_Incrx", "time_decrar"], "time_div": ["timeCdiv", "timeCdev", "weight_div", "weight_mod", "time_init", "time00val", "time_base", "weight_val", "time_division", "time\u00b7mod", "weight00div", " time_dev", " time_division", "weight00def", "time_val", "time\u00b7dev", " time_init", " time_base", "time_dev", "time00mod", "time00def", "weight00mod", "time00div", "weight_def", "timeCinit", "timeCdivision", "time\u00b7base", "time_def", "weight00val", "time\u00b7div"], "time_mod": [" time_sign", "timealldiv", "time54dig", " time_inc", " time_dim", "time_dim", "timeallinc", "time_mult", "time_sign", "time___mult", "time54div", " time_mult", "time54mod", " time_dig", "timeallmodule", "timeallsign", "timeallmod", "time54dim", "time_module", "time_inc", "timeallmult", "time___div", "time___mod", "time_dig", " time_module", "time___sign"]}}
{"project": "FFmpeg", "commit_id": "0273ceebbd01f9fd5238558e6151e0b9aa3305ab", "target": 0, "func": "static void build_vlc(VLC *vlc, const uint8_t *bits_table, const uint8_t *val_table, \n\n                      int nb_codes)\n\n{\n\n    uint8_t huff_size[256];\n\n    uint16_t huff_code[256];\n\n\n\n    memset(huff_size, 0, sizeof(huff_size));\n\n    build_huffman_codes(huff_size, huff_code, bits_table, val_table);\n\n    \n\n    init_vlc(vlc, 9, nb_codes, huff_size, 1, 1, huff_code, 2, 2);\n\n}\n", "idx": 14884, "substitutes": {"vlc": ["vrf", "vlci", "llcs", "llv", "lvcs", "vlv", "lvv", "vll", "svci", "llci", "lvc", "vlf", "svv", "svf", "vrci", "lvci", "vlcs", "lll", "vrc", "llc", "llf", "vrl", "svcs", "svl", "svc"], "bits_table": ["bits_buffer", "bits_entry", "bits_tab", "bitssbuffer", " bits_tab", "bits_cache", "bits_test", "bitssentry", " bits_entry", "bitsstab", " bits_test", " bits_cache", "bitsstable", " bits_buffer"], "val_table": ["valstable", "eval_code", "val_code", "val_range", "valmatsys", "value_code", "valstab", "val_tab", "eval_table", "valettab", "val_sys", "eval_sys", "valetcode", "valmattable", "valmatarray", "valetrange", "valuesrange", "eval_array", "valuestable", "valsrange", "valscode", "value_table", "valuestab", "valuescode", "valmatcode", "value_tab", "val_array", "value_range", "valettable"], "nb_codes": ["num_cod", "nb2cells", "num_cells", "nb2codes", "nb_code", "nb2cod", "nb_cod", "num_code", "nb2states", "num_codes", "num_states", "nb_cells", "nb_states"], "huff_size": ["huffplength", "huffkcode", "huffy_count", "huffy_address", "huffy_shape", "huffy_code", "huffpcode", "huffksize", "huffacname", "huffkname", "huffpsize", "huf_loc", "huff64size", "huffaccode", "huffy_weight", "huff_data", "huffy_size", "huff64loc", "huff_loc", "huffacsize", "huff64code", "huffacshape", "huff_count", "huff64length", "huf_data", "huffsaddress", "huff_length", "huf_code", "huf_length", "huff_address", "huffkshape", "huff_weight", "huff_name", "huffsweight", "huffploc", "huffy_name", "huf_size", "huffssize", "huff_shape"], "huff_code": ["huffy_cod", "huffaccount", "huffpcod", "huffpcodes", "huffddesc", "huffdnumber", "huffy_count", "huffpcache", "huffaccode", "huffy_codes", "huff_count", "huff_number", "huffy_code", "huff_cod", "huff_cache", "huffy_number", "huffpcode", "huffdcount", "huff_codes", "huf_size", "huffy_size", "huf_codes", "huf_code", "huffacnumber", "huff_desc", "huf_cache", "huffy_desc", "huffacdesc", "huffpsize", "huffdcode"]}}
{"project": "qemu", "commit_id": "4d68e86bb10159099da0798f74e7512955f15eec", "target": 0, "func": "void qemu_coroutine_adjust_pool_size(int n)\n\n{\n\n    qemu_mutex_lock(&pool_lock);\n\n\n\n    pool_max_size += n;\n\n\n\n    /* Callers should never take away more than they added */\n\n    assert(pool_max_size >= POOL_DEFAULT_SIZE);\n\n\n\n    /* Trim oversized pool down to new max */\n\n    while (pool_size > pool_max_size) {\n\n        Coroutine *co = QSLIST_FIRST(&pool);\n\n        QSLIST_REMOVE_HEAD(&pool, pool_next);\n\n        pool_size--;\n\n        qemu_coroutine_delete(co);\n\n    }\n\n\n\n    qemu_mutex_unlock(&pool_lock);\n\n}\n", "idx": 14904, "substitutes": {"n": ["nat", "m", "en", "nl", "d", "t", "len", "l", "i", "nn", "N", "a", "cn", "nb", "x", "init", "fn", "o", "z", "u", "an", "p", "nan", "s", "e", "nc", "k", "b", "min", "j", "count", "f", "ns", "number", "c", "ne", "sn", "num", "ln"], "pool_size": ["pool__size", "pool__sized", "pool_max", "pool_capacity", "poolFsized", "poolFlimit", "pool_address", "queue_address", "queue_capacity", "queue_size", "queue_limit", "poolFsize", "poolFcapacity", "pool__limit", "pool_limit", "queue_max", "queue_sized", "pool__capacity", "pool_sized"], "co": ["aco", "mc", "bc", "po", "ca", "coe", "rc", "cc", "pc", "ko", "ra", "lc", "ci", "Co", "fo", "con", "loc", "o", "la", "lo", "nc", "ck", "oo", "ico", "mo", "fe", "c", "cu", "pe", "bo", "ro", "ce", "cf", "coll", "wo", "cl", "go", "CO"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void rndis_clear_responsequeue(USBNetState *s)\n\n{\n\n    struct rndis_response *r;\n\n\n\n    while ((r = s->rndis_resp.tqh_first)) {\n\n        TAILQ_REMOVE(&s->rndis_resp, r, entries);\n\n        qemu_free(r);\n\n    }\n\n}\n", "idx": 14911, "substitutes": {"s": ["secondary", "south", "args", "sys", "ses", "m", "service", "t", "sg", "fs", "sync", "rs", "sym", "g", "S", "new", "os", "si", "es", "js", "sq", "server", "storage", "ss", "ps", "o", "p", "e", "http", "sf", "sb", "b", "f", "gs", "spec", "ns", "c", "stats", "ssl", "side", "sv", "states", "services", "ds", "ops", "su", "ls", "ts"], "r": ["rr", "m", "ru", "R", "hr", "d", "rd", "response", "rc", "gr", "l", "i", "rs", "kr", "rar", "g", "er", "h", "rg", "sr", "v", "br", "fr", "rh", "cr", "o", "u", "mr", "p", "e", "lr", "rb", "b", "entry", "j", "reader", "n", "f", "result", "rl", "c", "re", "q", "resp", "nr", "ar", "dr", "res", "rf", "err"]}}
{"project": "FFmpeg", "commit_id": "e0c6cce44729d94e2a5507a4b6d031f23e8bd7b6", "target": 0, "func": "av_cold void ff_vp56dsp_init_x86(VP56DSPContext* c, enum AVCodecID codec)\n\n{\n\n#if HAVE_YASM\n\n    int mm_flags = av_get_cpu_flags();\n\n\n\n    if (CONFIG_VP6_DECODER && codec == AV_CODEC_ID_VP6) {\n\n#if ARCH_X86_32\n\n        if (mm_flags & AV_CPU_FLAG_MMX) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_mmx;\n\n        }\n\n#endif\n\n\n\n        if (mm_flags & AV_CPU_FLAG_SSE2) {\n\n            c->vp6_filter_diag4 = ff_vp6_filter_diag4_sse2;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 14913, "substitutes": {"c": ["acs", "m", "ch", "mc", "cm", "uc", "ca", "cv", "t", "rc", "cc", "l", "C", "gc", "lc", "cs", "g", "ctrl", "h", "con", "ct", "v", "cr", "u", "oc", "p", "e", "s", "b", "co", "f", "dc", "ac", "sc", "ce", "cf", "coll", "cp", "center", "vc", "xc", "cache", "cl", "ctx"], "codec": ["pedEC", "codenc", " codenc", " codEC", "Codac", "pedec", "codac", "pedac", "odac", " codac", "odenc", "CodEC", "codEC", "pedenc", "odec", "odEC", "Codec", "Codenc"]}}
{"project": "qemu", "commit_id": "b769d8fef6c06ddb39ef0337882a4f8872b9c2bc", "target": 0, "func": "int cpu_ppc_handle_mmu_fault (CPUState *env, uint32_t address, int rw,\n\n                              int is_user, int is_softmmu)\n\n{\n\n    uint32_t physical;\n\n    int prot;\n\n    int exception = 0, error_code = 0;\n\n    int access_type;\n\n    int ret = 0;\n\n\n\n//    printf(\"%s 0\\n\", __func__);\n\n    access_type = env->access_type;\n\n    if (env->user_mode_only) {\n\n        /* user mode only emulation */\n\n        ret = -2;\n\n        goto do_fault;\n\n    }\n\n    /* NASTY BUG workaround */\n\n    if (access_type == ACCESS_CODE && rw) {\n\n\tprintf(\"%s: ERROR WRITE CODE ACCESS\\n\", __func__);\n\n\taccess_type = ACCESS_INT;\n\n    }\n\n    ret = get_physical_address(env, &physical, &prot,\n\n                               address, rw, access_type);\n\n    if (ret == 0) {\n\n\tret = tlb_set_page(env, address & ~0xFFF, physical, prot,\n\n\t\t\t   is_user, is_softmmu);\n\n    } else if (ret < 0) {\n\n    do_fault:\n\n#if defined (DEBUG_MMU)\n\n\tif (loglevel > 0)\n\n\t    cpu_ppc_dump_state(env, logfile, 0);\n\n#endif\n\n        if (access_type == ACCESS_CODE) {\n\n            exception = EXCP_ISI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_ISI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_ISI_PROT;\n\n                break;\n\n            case -3:\n\n\t\t/* No execute protection violation */\n\n                error_code = EXCP_ISI_NOEXEC;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                /* No code fetch is allowed in direct-store areas */\n\n                error_code = EXCP_ISI_DIRECT;\n\n                break;\n\n            }\n\n        } else {\n\n            exception = EXCP_DSI;\n\n            switch (ret) {\n\n            case -1:\n\n                /* No matches in page tables */\n\n                error_code = EXCP_DSI_TRANSLATE;\n\n                break;\n\n            case -2:\n\n                /* Access rights violation */\n\n                error_code = EXCP_DSI_PROT;\n\n                break;\n\n            case -4:\n\n                /* Direct store exception */\n\n                switch (access_type) {\n\n                case ACCESS_FLOAT:\n\n                    /* Floating point load/store */\n\n                    exception = EXCP_ALIGN;\n\n                    error_code = EXCP_ALIGN_FP;\n\n                    break;\n\n                case ACCESS_RES:\n\n                    /* lwarx, ldarx or srwcx. */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT;\n\n                    break;\n\n                case ACCESS_EXT:\n\n                    /* eciwx or ecowx */\n\n                    exception = EXCP_DSI;\n\n                    error_code = EXCP_DSI_NOTSUP | EXCP_DSI_DIRECT |\n\n\t\t\tEXCP_DSI_ECXW;\n\n                    break;\n\n                default:\n\n\t\t    printf(\"DSI: invalid exception (%d)\\n\", ret);\n\n                    exception = EXCP_PROGRAM;\n\n                    error_code = EXCP_INVAL | EXCP_INVAL_INVAL;\n\n                    break;\n\n                }\n\n            }\n\n            if (rw)\n\n                error_code |= EXCP_DSI_STORE;\n\n\t    /* Store fault address */\n\n\t    env->spr[DAR] = address;\n\n        }\n\n#if 0\n\n        printf(\"%s: set exception to %d %02x\\n\",\n\n               __func__, exception, error_code);\n\n#endif\n\n        env->exception_index = exception;\n\n        env->error_code = error_code;\n\n        ret = 1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14936, "substitutes": {"env": ["forge", "erv", "proc", "en", "context", "enc", "ea", "config", "worker", "code", "enter", "profile", "eu", "style", "kn", "manager", "settings", "txt", "init", "scope", "server", "v", "conf", "conn", "np", "console", "obj", "loader", "energy", "dict", "e", "equ", "viron", "exc", "engine", "her", "site", "eng", "ext", "qt", "Environment", "dat", "export", "eni", "shell", "dt", "ne", "network", "here", "org", "que", "exec", "db", "ev", "inet", "ec", "et", "cache", "environment", "ef", "net", "err"], "address": ["channel", "area", "device", "port", "Address", "database", "interface", "context", "location", "array", "config", "enter", "external", "object", "shape", "absolute", "uration", "connection", "reference", "image", "ace", "position", "server", "uri", "localhost", "output", "password", "office", "p", "primary", "pointer", "entry", "mode", "ip", "number", "route", "type", "offset", "target", "attribute", "network", "host", "inet", "prefix", "addr", "contract", "index", "message"], "rw": ["func", "rr", "rss", "wh", "ru", "rc", "iw", "ww", "rs", "row", "rn", "wx", "sw", "sth", "raw", "slave", "rh", "nw", "wn", "access", "w", "password", "lr", "rb", "resource", "rx", "wb", "rack", "wp", "rl", "route", "ro", "rt", "r", "src", "work", "RW", "wl", "rf", "tty", "hw", "wr", "fw"], "is_user": [" is_bug", "islanduser", "is24user", "iswebbug", "iswebpublic", "iswebuse", " is_public", "is24force", "islanduse", " is_force", "is24users", " is_use", "iswebuser", "is_use", " is_users", "islandbug", "is_force", "is_users", "islandpublic", "is_bug", "is_public", "is24use"], "is_softmmu": ["is_softmcu", "is_hardmmou", "is_softmlcu", "is_softmlus", "is_hardmmcu", "is_softmmou", "is_softmmus", "is_softpmu", "is_softmmi", "is_softpmi", "is_softpmcu", "is_softmcus", "is_softpmou", "is_softmmcu", "is_hardmmus", "is_softpmus", "is_softmci", "is_hardmmi", "is_softmlu", "is_softmccu", "is_softmlou", "is_hardmmu"], "physical": ["channel", "secondary", "proc", "remote", "relative", "tmp", "config", "phys", "native", "external", "phone", "binary", "local", "api", "optional", "reference", "sp", "pg", "ref", "buffer", "server", "np", "password", "p", "temp", "info", "boot", "primary", "http", "pointer", "sb", "data", "rx", "ocol", "stat", "protected", "number", "route", "nt", "network", "hard", "virtual", "resp", "host", "prefix", "net", "php"], "prot": ["Prot", "alt", "transfer", "secondary", "port", "ret", "got", "format", "len", "plain", "response", "config", "phys", "gt", "fun", "reference", "status", "ref", "txt", "fp", "server", "uri", "platform", "conn", "password", "primary", "cli", "ext", "pointer", "notes", "stat", "protected", "att", "reset", "phy", "tell", "offset", "eth", "rt", "resp", "virtual", "pro", "seq", "pos", "prefix", "addr", "rf", "prop", "rot", "ptr", "bit", "php"], "access_type": ["access_role", "accessalinfo", " access_info", "access_level", "accessalname", "access_value", "accessenname", "play_role", "accessaltoken", "accessingrole", "playingtype", "accessalltypes", "action_method", "accessallstyle", " access_set", "playingcode", "accessingclass", "playingrole", "actioningtype", "action_types", "play_code", "access_style", " access_level", "accessfullvalue", " access_key", "accessencode", "actioningmethod", " access_value", "access_types", "accessfullkey", "access_token", "accessingmethod", "actioningclass", "accessingtypes", "accessalltype", "accessingtype", "accessingcode", "accessalset", "access_code", "action_class", "accessalcode", "access_info", " access_types", " access_name", " access_size", "accessalrole", "accessaltype", "accessallevel", "play_type", " access_style", "access_name", "actioningtypes", " access_token", "access_size", "access_method", "accessentype", "access_set", " access_code", "access_class", "accessfulltype", "accessentoken", "access_key", "action_type", "accessallcode", "accessfullcode"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942, "substitutes": {"buffer": ["seek", "bridge", "transfer", "database", "slice", "queue", "batch", "memory", "container", "player", "binary", "FFER", "source", "reference", "audio", "image", "manager", "border", "writer", "position", "comment", "server", "table", "buff", "document", "loader", "surface", "view", "size", "buf", "Buffer", "reader", "length", "result", "url", "uffer", "file", "iter", "cache", "header", "window", "program", "texture", "material", "filename"], "height": ["upper", "stroke", "head", "Height", "deep", "input", "thin", "d", "bottom", "my", "id", "level", "density", "shape", "style", "name", "row", "gap", "border", "image", "h", "x", "capacity", "third", "rows", "crop", "rank", "hang", "w", "size", "tight", "direction", "three", "distance", "han", "length", "flow", "padding", "resolution", "inches", "above", "dim", "wall", "center", "layout", "history", "volume", "high", "window", "ty", "depth", "header", "lat"], "stride": ["striided", "strid", "stade", " strine", "Strance", "Strine", "arrend", "striride", "strride", "dride", " strade", " strid", " strride", "Strride", "Stride", "stided", "Strade", "STRide", "stend", "STRine", "striine", "strided", "arrided", "arrid", "strone", "grid", "drine", "drid", "strade", "STRride", "STRid", " strance", "grend", "drone", "Strided", "grade", "drend", "strance", "drride", "trride", "arride", "gride", "Strid", "stide", "trance", "grided", "arrade", "grone", "arrone", "tride", "striide", "trade", "drided", "strend", "strine"], "y": ["ny", "yt", "ch", "hy", "ys", "t", "sky", "id", "l", "i", "ish", "ey", "yd", "py", "h", "x", "cy", "gy", "by", "ym", "ye", "yer", "o", "col", "yi", "dy", "w", "z", "ady", "yl", "p", "yr", "b", "yo", "j", "yn", "oy", "ay", "vy", "ry", "yu", "yah", "year", "Y", "ya", "ky", "xy", "yy", "zy", "ty", "sy"], "b0": ["p2", "B0", "bb2", "p4", "p0", "p05", "p3", " b4", "bb0", "f2", "bb5", "f0", "br1", "p1", "br05", "bb1", "f05", "B2", "B3", "f3", "b4", "bb4", "B4", "f1", "f5", " b5", "br2", "f4", "b05", "br0", "b5", "bb3"], "b1": ["p2", "B0", "bb2", "a1", "p3", " bone", "a0", "f2", "bb0", "f0", "p1", "b11", "bb1", "B1", "B2", "B3", "f3", "bbone", "fone", " b11", "f1", "p11", "a2", "f11", "a3", "bb3", "bone"], "b2": ["b6", "l3", "buff1", "B0", "b32", "bbb", "bb2", "l1", "btwo", "bufftwo", "bb", "bbtwo", " b32", "l2", "bb0", "f2", "sbb", "B6", "f0", "buff0", "bb1", "l0", "B1", " b6", "buff2", "bb32", "B2", "f3", "sb2", "f32", "sb0", "f1", "sb3", " btwo", "bb3", " bb", "bb6"], "b3": ["b6", "l3", "b33", "bb2", "f8", "l1", "fthree", "w3", "bThird", " bThird", "embThird", "emb6", "wThree", "bthree", "emb1", " b33", "l2", "abbThree", "bb0", "f2", " b8", "abb6", "f0", "bb1", "bThree", "w1", "l0", " b6", "bbthree", "fThree", "b8", "f3", "b4", "f33", "bb33", "l8", "emb3", "bb4", "embThree", "abbThird", " bThree", "f1", " bthree", "f4", "l4", "wthree", "embthree", "abb3", "bb3"]}}
{"project": "qemu", "commit_id": "0e7106d8b5f7ef4f9df10baf1dfb3db482bcd046", "target": 0, "func": "static int sd_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    BDRVSheepdogState *s = bs->opaque;\n\n    int ret, fd;\n\n    unsigned int datalen;\n\n\n\n    if (offset < s->inode.vdi_size) {\n\n        error_report(\"shrinking is not supported\");\n\n        return -EINVAL;\n\n    } else if (offset > SD_MAX_VDI_SIZE) {\n\n        error_report(\"too big image size\");\n\n        return -EINVAL;\n\n    }\n\n\n\n    fd = connect_to_sdog(s->addr, s->port);\n\n    if (fd < 0) {\n\n        return fd;\n\n    }\n\n\n\n    /* we don't need to update entire object */\n\n    datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id);\n\n    s->inode.vdi_size = offset;\n\n    ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id),\n\n                       s->inode.nr_copies, datalen, 0, false, s->cache_enabled);\n\n    close(fd);\n\n\n\n    if (ret < 0) {\n\n        error_report(\"failed to update an inode.\");\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 14951, "substitutes": {"bs": ["bt", "ses", "blocks", "as", "bc", "BS", "fs", "ins", "iss", "bb", "rs", "fb", "cs", "os", "cms", "es", "js", "ss", "ms", "rb", "obs", "pb", "b", "sb", "gb", "gs", "bits", "bh", "ns", "outs", "ds", "bi", "sa", "ls", "lb", "bos", "ts", "vs"], "offset": ["port", "adjusted", "enabled", "location", "Offset", "part", "slot", "shift", "id", "seed", "oa", "range", "bytes", "position", "fp", "loc", "error", "limit", "o", "alpha", "size", "data", "pointer", "af", "base", "length", "padding", "address", "number", "timeout", "reset", "fee", "off", "pos", "prefix", "addr", "num", "delay", "len", "ptr", "alloc", "index", "start"], "s": ["sys", "ses", "service", "sync", "fs", "t", "l", "ins", "i", "rs", "sym", "g", "cs", "qs", "S", "settings", "os", "its", "sets", "js", "es", "si", "sq", "uns", "session", "v", "ps", "ss", "conf", "storage", "o", "ms", "p", "e", "d", "site", "sb", "b", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "ssl", "sl", "states", "services", "ds", "ops", "r", "sa", "su", "ls", "sis", "ts", "in", "ks", "aws"], "ret": ["alt", "ft", "en", "rc", "id", "val", "code", "back", "rets", "fun", "sr", "ref", "det", "hash", "lit", "conn", "pass", "obj", "mt", "fin", "success", "data", "af", "base", "Ret", "ext", "bf", "lf", "result", "att", "url", "red", "arr", "cb", " result", "nt", "re", "out", "rt", "resp", "r", "db", "et", "RET", "al", "res", "reg", "addr", "rf", "flag", "len", "bit"], "fd": ["ft", "ff", "d", "fl", "rd", "fs", "id", "fb", "bd", "fm", "cond", " fid", "fun", "dl", "fx", "nd", "fat", "fp", "fn", "ld", "dir", "fr", "pd", "dy", "cd", "handler", "fi", "fin", "fed", "buf", "sf", "wb", "nil", "bf", "f", "result", "lf", "draft", "fe", "df", "dt", "dc", "feed", "end", "cb", "md", "cf", "fail", "resp", "dd", "db", "fee", "hd", "wd", "fc", "fa", "wat", "FD"], "datalen": [" dalength", "davaln", " dalen", "Davalan", " datallen", "davalang", "dalanength", "dalang", "dalength", "datalan", "Datalens", "dataline", "dillen", "davalan", " datalun", " dataline", " datalenc", "daln", "Datalan", "davalun", "Dataln", "datalenc", "dmalens", "dilenc", "dalanen", "datalun", "datalength", "dataln", "dilen", "dacline", " datalength", " dalun", " dotaline", " dotalenc", " datalang", "davalength", " dotalen", "davalens", "Davaln", "datallen", "datalang", "Datalen", " dalang", "datalens", "dmalan", "dmaln", "dotalenc", "dalan", "dotalen", "dalen", "dalanun", "dotallen", " dotallen", "diline", "dacllen", "dmalen", "daclenc", "dotaline", "Davalen", "daclen", "dalens", "dalanang", "dalun", "davalen", "Davalens"]}}
{"project": "qemu", "commit_id": "190563f9a90c9df8ad32fc7f3e4b166deda949a6", "target": 0, "func": "static int rndis_parse(USBNetState *s, uint8_t *data, int length)\n\n{\n\n    uint32_t msg_type;\n\n    le32 *tmp = (le32 *) data;\n\n\n\n    msg_type = le32_to_cpup(tmp);\n\n\n\n    switch (msg_type) {\n\n    case RNDIS_INITIALIZE_MSG:\n\n        s->rndis_state = RNDIS_INITIALIZED;\n\n        return rndis_init_response(s, (rndis_init_msg_type *) data);\n\n\n\n    case RNDIS_HALT_MSG:\n\n        s->rndis_state = RNDIS_UNINITIALIZED;\n\n        return 0;\n\n\n\n    case RNDIS_QUERY_MSG:\n\n        return rndis_query_response(s, (rndis_query_msg_type *) data, length);\n\n\n\n    case RNDIS_SET_MSG:\n\n        return rndis_set_response(s, (rndis_set_msg_type *) data, length);\n\n\n\n    case RNDIS_RESET_MSG:\n\n        rndis_clear_responsequeue(s);\n\n        s->out_ptr = s->in_ptr = s->in_len = 0;\n\n        return rndis_reset_response(s, (rndis_reset_msg_type *) data);\n\n\n\n    case RNDIS_KEEPALIVE_MSG:\n\n        /* For USB: host does this every 5 seconds */\n\n        return rndis_keepalive_response(s, (rndis_keepalive_msg_type *) data);\n\n    }\n\n\n\n    return USB_RET_STALL;\n\n}\n", "idx": 14982, "substitutes": {"s": ["secondary", "south", "sys", "ses", "m", "self", "service", "sync", "d", "sg", "fs", "native", "l", "i", "private", "sym", "a", "sup", "g", "cs", "sites", "S", "settings", "os", "this", "status", "sets", "es", "js", "si", "v", "ps", "ss", "conf", "storage", "o", "u", "an", "p", "e", "se", "info", "socket", "http", "sb", "b", "site", "f", "gs", "state", "spec", "ns", "c", "is", "ssl", "side", "sl", "states", "r", "ds", "services", "ops", "su", "ls", "ts", "us", "comments", "sports", "aws"], "data": ["args", "ada", "database", "ui", "partial", "device", "done", "part", "slice", "input", "array", "response", "d", "config", "shift", "i", "da", "sample", "a", "msg", "api", "bytes", "di", "missing", "buffer", "raw", "session", "error", "package", "o", "alpha", "size", "media", "ad", "p", "e", "buf", "multi", "result", "dat", "address", "state", "timeout", "start", "Data", "type", "body", "results", "DATA", "load", "events", "ds", "dd", "cache", "ata", "window", "pad", "len", "xxx", "message"], "length": ["path", "en", "slice", "id", "l", "shape", "style", "sequence", "full", "position", "maximum", "limit", "form", "failed", "size", "impl", "p", "pack", " Length", "match", "Length", "count", "ENGTH", "padding", "address", "number", "type", "load", "angle", "duration", "len", "ength", "message"], "msg_type": ["Msg_id", "msg_path", "msg_Type", "msg_types", "msgtypepath", " msg_types", "Msg_key", " msg_info", " msg_path", "msg_key", "Msg_type", "msg_name", "msg_id", "msg_info", "msgtypetype", " msg_name", "msgtypename", "msgtypetypes", " msg_id", "Msg_Type"], "tmp": ["m", "stuff", "slice", "fd", "array", "input", "mp", "fb", "binary", "msg", "sup", "uf", "txt", "buffer", "bag", "fp", "buff", "storage", "var", "np", "bp", "obj", "metadata", "mem", "temp", "img", "rb", "handler", "buf", "wb", "tc", "b", "ptr", "mo", "cb", "attr", "text", "su", "copy", "tp", "cpp"]}}
{"project": "FFmpeg", "commit_id": "ec4c48397641dbaf4ae8df36c32aaa5a311a11bf", "target": 1, "func": "static int sap_write_header(AVFormatContext *s)\n\n{\n\n    struct SAPState *sap = s->priv_data;\n\n    char host[1024], path[1024], url[1024], announce_addr[50] = \"\";\n\n    char *option_list;\n\n    int port = 9875, base_port = 5004, i, pos = 0, same_port = 0, ttl = 255;\n\n    AVFormatContext **contexts = NULL;\n\n    int ret = 0;\n\n    struct sockaddr_storage localaddr;\n\n    socklen_t addrlen = sizeof(localaddr);\n\n    int udp_fd;\n\n    AVDictionaryEntry* title = av_dict_get(s->metadata, \"title\", NULL, 0);\n\n\n\n    if (!ff_network_init())\n\n        return AVERROR(EIO);\n\n\n\n    /* extract hostname and port */\n\n    av_url_split(NULL, 0, NULL, 0, host, sizeof(host), &base_port,\n\n                 path, sizeof(path), s->filename);\n\n    if (base_port < 0)\n\n        base_port = 5004;\n\n\n\n    /* search for options */\n\n    option_list = strrchr(path, '?');\n\n    if (option_list) {\n\n        char buf[50];\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_port\", option_list)) {\n\n            port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"same_port\", option_list)) {\n\n            same_port = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"ttl\", option_list)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (av_find_info_tag(buf, sizeof(buf), \"announce_addr\", option_list)) {\n\n            av_strlcpy(announce_addr, buf, sizeof(announce_addr));\n\n        }\n\n    }\n\n\n\n    if (!announce_addr[0]) {\n\n        struct addrinfo hints = { 0 }, *ai = NULL;\n\n        hints.ai_family = AF_UNSPEC;\n\n        if (getaddrinfo(host, NULL, &hints, &ai)) {\n\n            av_log(s, AV_LOG_ERROR, \"Unable to resolve %s\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        if (ai->ai_family == AF_INET) {\n\n            /* Also known as sap.mcast.net */\n\n            av_strlcpy(announce_addr, \"224.2.127.254\", sizeof(announce_addr));\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        } else if (ai->ai_family == AF_INET6) {\n\n            /* With IPv6, you can use the same destination in many different\n\n             * multicast subnets, to choose how far you want it routed.\n\n             * This one is intended to be routed globally. */\n\n            av_strlcpy(announce_addr, \"ff0e::2:7ffe\", sizeof(announce_addr));\n\n#endif\n\n        } else {\n\n            freeaddrinfo(ai);\n\n            av_log(s, AV_LOG_ERROR, \"Host %s resolved to unsupported \"\n\n                                    \"address family\\n\", host);\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        freeaddrinfo(ai);\n\n    }\n\n\n\n    sap->protocols = ffurl_get_protocols(NULL, NULL);\n\n    if (!sap->protocols) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    contexts = av_mallocz(sizeof(AVFormatContext*) * s->nb_streams);\n\n    if (!contexts) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    s->start_time_realtime = av_gettime();\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        URLContext *fd;\n\n\n\n        ff_url_join(url, sizeof(url), \"rtp\", NULL, host, base_port,\n\n                    \"?ttl=%d\", ttl);\n\n        if (!same_port)\n\n            base_port += 2;\n\n        ret = ffurl_open(&fd, url, AVIO_FLAG_WRITE, &s->interrupt_callback, NULL,\n\n                         sap->protocols);\n\n        if (ret) {\n\n            ret = AVERROR(EIO);\n\n            goto fail;\n\n        }\n\n        ret = ff_rtp_chain_mux_open(&contexts[i], s, s->streams[i], fd, 0, i);\n\n        if (ret < 0)\n\n            goto fail;\n\n        s->streams[i]->priv_data = contexts[i];\n\n        s->streams[i]->time_base = contexts[i]->streams[0]->time_base;\n\n        av_strlcpy(contexts[i]->filename, url, sizeof(contexts[i]->filename));\n\n    }\n\n\n\n    if (s->nb_streams > 0 && title)\n\n        av_dict_set(&contexts[0]->metadata, \"title\", title->value, 0);\n\n\n\n    ff_url_join(url, sizeof(url), \"udp\", NULL, announce_addr, port,\n\n                \"?ttl=%d&connect=1\", ttl);\n\n    ret = ffurl_open(&sap->ann_fd, url, AVIO_FLAG_WRITE,\n\n                     &s->interrupt_callback, NULL, sap->protocols);\n\n    if (ret) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n\n\n    udp_fd = ffurl_get_file_handle(sap->ann_fd);\n\n    if (getsockname(udp_fd, (struct sockaddr*) &localaddr, &addrlen)) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    if (localaddr.ss_family != AF_INET\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n        && localaddr.ss_family != AF_INET6\n\n#endif\n\n        ) {\n\n        av_log(s, AV_LOG_ERROR, \"Unsupported protocol family\\n\");\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann_size = 8192;\n\n    sap->ann = av_mallocz(sap->ann_size);\n\n    if (!sap->ann) {\n\n        ret = AVERROR(EIO);\n\n        goto fail;\n\n    }\n\n    sap->ann[pos] = (1 << 5);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    if (localaddr.ss_family == AF_INET6)\n\n        sap->ann[pos] |= 0x10;\n\n#endif\n\n    pos++;\n\n    sap->ann[pos++] = 0; /* Authentication length */\n\n    AV_WB16(&sap->ann[pos], av_get_random_seed());\n\n    pos += 2;\n\n    if (localaddr.ss_family == AF_INET) {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in*)&localaddr)->sin_addr,\n\n               sizeof(struct in_addr));\n\n        pos += sizeof(struct in_addr);\n\n#if HAVE_STRUCT_SOCKADDR_IN6\n\n    } else {\n\n        memcpy(&sap->ann[pos], &((struct sockaddr_in6*)&localaddr)->sin6_addr,\n\n               sizeof(struct in6_addr));\n\n        pos += sizeof(struct in6_addr);\n\n#endif\n\n    }\n\n\n\n    av_strlcpy(&sap->ann[pos], \"application/sdp\", sap->ann_size - pos);\n\n    pos += strlen(&sap->ann[pos]) + 1;\n\n\n\n    if (av_sdp_create(contexts, s->nb_streams, &sap->ann[pos],\n\n                      sap->ann_size - pos)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    av_freep(&contexts);\n\n    av_log(s, AV_LOG_VERBOSE, \"SDP:\\n%s\\n\", &sap->ann[pos]);\n\n    pos += strlen(&sap->ann[pos]);\n\n    sap->ann_size = pos;\n\n\n\n    if (sap->ann_size > sap->ann_fd->max_packet_size) {\n\n        av_log(s, AV_LOG_ERROR, \"Announcement too large to send in one \"\n\n                                \"packet\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_free(contexts);\n\n    sap_write_close(s);\n\n    return ret;\n\n}\n", "idx": 15001, "substitutes": {"s": ["types", "args", "south", "sys", "ses", "m", "parts", "service", "t", "sync", "sg", "d", "fs", "sym", "rs", "a", "g", "cs", "qs", "S", "settings", "os", "sets", "js", "es", "si", "sq", "session", "server", "v", "storage", "ss", "conf", "o", "u", "params", "p", "e", "sb", "b", "n", "f", "gs", "spec", "c", "ns", "is", "stats", "sc", "ssl", "sv", "sl", "ops", "services", "ds", "r", "sa", "ls", "ts", "comments", "sports", "aws"], "sap": ["Saps", "ssap", "ssaps", "saps", "Sap", " sAP", "ssAP", "sAP", "SAP", " saps"], "host": ["port", "context", "domain", "location", "format", "connect", "config", "code", "container", "home", "name", "connection", "source", "Host", "h", "hub", "auth", "method", "dir", "server", "uri", "loc", "localhost", "client", "conn", "arch", "http", "component", "driver", "address", "ip", "proxy", "ac", "type", "file", "target", "eth", "cmd", "src", "hop", "prefix", "addr", "header", "hw", "node"], "path": ["port", "context", "root", "location", "part", "ath", "enc", "config", "id", "code", "container", "home", "name", "source", "image", "h", "user", "ref", "str", "method", "dir", "loc", "key", "uri", "value", "request", "p", "time", "resource", "http", "data", "pointer", "length", "Path", "c", "route", "PATH", "file", "text", "cmd", "cache", "pattern", "content", "prefix", "alias", "prop", "node"], "url": ["channel", "config", "mount", "stream", "api", "source", "image", "ref", "method", "loc", "server", "uri", "resource", "http", "address", "ip", "proxy", "route", "file", "ssl", "text", "sl", "URL", "cache", "href"], "announce_addr": ["announce1tag", "announce1address", "announce_dr", "announce2tag", "announceappdata", "announceappcoord", "announceappaddr", "announce2host", "announce_host", "announce_tag", "announce1host", "announce2addr", "announce_address", "announced_data", "announce2address", "announceingaddress", "announceinghost", "announceappaddress", "announce_coord", "announced_addr", "announceingdata", "announce_data", "announced_coord", "announce1addr", "announceingdr", "announceingaddr", "announced_address", "announceingcoord"], "option_list": ["options_type", "option_List", "optionaycoll", "option9list", "option_keep", " option_string", "optionaylisted", "optionPlist", "option9stack", "optionayList", "optionerlist", "opt_list", "option_string", " option_not", " option_test", "option_card", "options_List", "option_stack", "option_test", "optionertest", "opt_la", "optionadlist", "option_name", " option_array", "optionadlisted", " option_keep", "optionPla", "optionkList", " option_name", "option_listed", "optionadcoll", "optionktest", "optionklist", "option_not", "option_la", " option_coll", " option_List", "option6stack", "optionernot", "opt_name", "option_coll", " option_listed", "option_array", "option6list", "option6keep", "optionadList", "optionaylist", "optionknot", "options_list", "optionerList", " option_stack", "option9keep", "option_type", " option_card", "optionPname"], "i": ["I", "id", "iu", "a", "io", "h", "position", "loc", "uri", "u", "p", "info", "cli", "http", "multi", "n", "ip", "c", "end", "is", "inner", "pi", "r", "us", "net", "index"], "contexts": ["configi", "methodi", "confign", "configs", "Contexts", "contextn", "methodu", "contexti", "configu", "contextu", "Contextu", "Contextn", "methodn", "methods", "Contexti"], "localaddr": [" localhost", " locallen", "remoteaddress", " localAddress", "allen", "Localaddr", "alconn", "LocalAddress", "localAddress", "aladdress", "localhost", "Localconn", "remotehost", " localaddress", "Localhost", "localaddress", "locallen", "localconn", "Locallen", "Localaddress", "remoteAddress", " localconn", "remoteaddr", "aladdr"], "udp_fd": ["udp_stream", "udf_stream", "udf_fc", "udf_fd", "udp_resp", "udf_resp", "udp_fc"], "title": ["port", "config", "id", " msg", "msg", "name", "def", "details", "description", "meta", "metadata", " description", "version", "doc", "desc", " desc", "data", "entry", " metadata", "type", "text", " meta", "content", "seq", "alias", "header"], "buf": ["runner", "port", "proc", "nat", "ha", "bc", "uint", "msg", "pool", "fp", "loc", "br", " buffer", "rb", "bed", "box", "padding", "cb", "cas", "text", "dr", "off", "prop", "num", "context", "bin", "utf", "ru", "array", "rc", "home", "uf", "conv", "bus", "console", "img", "wb", "b", "feed", "cache", "header", "ptr", "alloc", "queue", "cv", "config", "extra", "fb", "null", "buffer", "lit", "bag", "grab", "exc", "bh", "block", "loop", "prefix", "ctx", "vec", "font", "pkg", "uc", "hal", "buff", "feat", "la", "cmd", "coll", "src", "seq", "su", "pad"], "ai": ["qi", "ais", "ca", "ni", "ia", "a", "asi", "api", "ci", "AI", "aii", "di", "iri", "ace", "si", "umi", "aa", "an", "ba", "hai", "pa", "ait", "iam", "au", "aaa", "ti", "am", "ay", "agi", "ac", "afi", "pi", "wa", "bi", "ae", "sa", "oci", "aud", "pai", "iat", "asm"], "pos": ["nat", "len", "id", "val", "pt", "def", "os", "ref", "unit", "post", "position", "loc", "pid", "col", "p", "mode", "neg", "ip", "type", "offset", "cp", "r", "seq", "prop", "opt", "index", "err"]}}
{"project": "FFmpeg", "commit_id": "ef23bd939d955f53bc58696bbb68960784066894", "target": 1, "func": "static void hls_prediction_unit(HEVCContext *s, int x0, int y0,\n\n                                int nPbW, int nPbH,\n\n                                int log2_cb_size, int partIdx, int idx)\n\n{\n\n#define POS(c_idx, x, y)                                                              \\\n\n    &s->frame->data[c_idx][((y) >> s->sps->vshift[c_idx]) * s->frame->linesize[c_idx] + \\\n\n                           (((x) >> s->sps->hshift[c_idx]) << s->sps->pixel_shift)]\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int merge_idx = 0;\n\n    struct MvField current_mv = {{{ 0 }}};\n\n\n\n    int min_pu_width = s->sps->min_pu_width;\n\n\n\n    MvField *tab_mvf = s->ref->tab_mvf;\n\n    RefPicList  *refPicList = s->ref->refPicList;\n\n    HEVCFrame *ref0, *ref1;\n\n    uint8_t *dst0 = POS(0, x0, y0);\n\n    uint8_t *dst1 = POS(1, x0, y0);\n\n    uint8_t *dst2 = POS(2, x0, y0);\n\n    int log2_min_cb_size = s->sps->log2_min_cb_size;\n\n    int min_cb_width     = s->sps->min_cb_width;\n\n    int x_cb             = x0 >> log2_min_cb_size;\n\n    int y_cb             = y0 >> log2_min_cb_size;\n\n    int x_pu, y_pu;\n\n    int i, j;\n\n\n\n    int skip_flag = SAMPLE_CTB(s->skip_flag, x_cb, y_cb);\n\n\n\n    if (!skip_flag)\n\n        lc->pu.merge_flag = ff_hevc_merge_flag_decode(s);\n\n\n\n    if (skip_flag || lc->pu.merge_flag) {\n\n        if (s->sh.max_num_merge_cand > 1)\n\n            merge_idx = ff_hevc_merge_idx_decode(s);\n\n        else\n\n            merge_idx = 0;\n\n\n\n        ff_hevc_luma_mv_merge_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                   partIdx, merge_idx, &current_mv);\n\n    } else {\n\n        hevc_luma_mv_mpv_mode(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                              partIdx, merge_idx, &current_mv);\n\n    }\n\n\n\n    x_pu = x0 >> s->sps->log2_min_pu_size;\n\n    y_pu = y0 >> s->sps->log2_min_pu_size;\n\n\n\n    for (j = 0; j < nPbH >> s->sps->log2_min_pu_size; j++)\n\n        for (i = 0; i < nPbW >> s->sps->log2_min_pu_size; i++)\n\n            tab_mvf[(y_pu + j) * min_pu_width + x_pu + i] = current_mv;\n\n\n\n    if (current_mv.pred_flag & PF_L0) {\n\n        ref0 = refPicList[0].ref[current_mv.ref_idx[0]];\n\n        if (!ref0)\n\n            return;\n\n        hevc_await_progress(s, ref0, &current_mv.mv[0], y0, nPbH);\n\n    }\n\n    if (current_mv.pred_flag & PF_L1) {\n\n        ref1 = refPicList[1].ref[current_mv.ref_idx[1]];\n\n        if (!ref1)\n\n            return;\n\n        hevc_await_progress(s, ref1, &current_mv.mv[1], y0, nPbH);\n\n    }\n\n\n\n    if (current_mv.pred_flag == PF_L0) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                    &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l0[current_mv.ref_idx[0]],\n\n                    s->sh.luma_offset_l0[current_mv.ref_idx[0]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref0->frame->data[1], ref0->frame->linesize[1],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][0], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][0]);\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref0->frame->data[2], ref0->frame->linesize[2],\n\n                      0, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l0[current_mv.ref_idx[0]][1], s->sh.chroma_offset_l0[current_mv.ref_idx[0]][1]);\n\n    } else if (current_mv.pred_flag == PF_L1) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_uni(s, dst0, s->frame->linesize[0], ref1->frame,\n\n                    &current_mv.mv[1], x0, y0, nPbW, nPbH,\n\n                    s->sh.luma_weight_l1[current_mv.ref_idx[1]],\n\n                    s->sh.luma_offset_l1[current_mv.ref_idx[1]]);\n\n\n\n        chroma_mc_uni(s, dst1, s->frame->linesize[1], ref1->frame->data[1], ref1->frame->linesize[1],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][0], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][0]);\n\n\n\n        chroma_mc_uni(s, dst2, s->frame->linesize[2], ref1->frame->data[2], ref1->frame->linesize[2],\n\n                      1, x0_c, y0_c, nPbW_c, nPbH_c, &current_mv,\n\n                      s->sh.chroma_weight_l1[current_mv.ref_idx[1]][1], s->sh.chroma_offset_l1[current_mv.ref_idx[1]][1]);\n\n    } else if (current_mv.pred_flag == PF_BI) {\n\n        int x0_c = x0 >> s->sps->hshift[1];\n\n        int y0_c = y0 >> s->sps->vshift[1];\n\n        int nPbW_c = nPbW >> s->sps->hshift[1];\n\n        int nPbH_c = nPbH >> s->sps->vshift[1];\n\n\n\n        luma_mc_bi(s, dst0, s->frame->linesize[0], ref0->frame,\n\n                   &current_mv.mv[0], x0, y0, nPbW, nPbH,\n\n                   ref1->frame, &current_mv.mv[1], &current_mv);\n\n\n\n        chroma_mc_bi(s, dst1, s->frame->linesize[1], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 0);\n\n\n\n        chroma_mc_bi(s, dst2, s->frame->linesize[2], ref0->frame, ref1->frame,\n\n                     x0_c, y0_c, nPbW_c, nPbH_c, &current_mv, 1);\n\n    }\n\n}\n", "idx": 15002, "substitutes": {"s": ["secondary", "south", "args", "sys", "m", "ses", "slice", "d", "t", "service", "sg", "sync", "l", "sym", "rs", "a", "g", "cs", "qs", "S", "settings", "os", "its", "sets", "js", "es", "si", "sq", "session", "styles", "storage", "ps", "ss", "conf", "set", "request", "u", "p", "e", "se", "plugins", "site", "b", "sb", "features", "n", "f", "gs", "less", "spec", "c", "ns", "xs", "is", "single", "stats", "sc", "ssl", "ops", "services", "r", "sie", "ds", "su", "ls", "sis", "ts", "us", "comments", "y"], "x0": [" x00", "x2", "y2", "X25", " x1", "px1", "X1", "xfe", "Xee", " xee", "x00", " x2", "xee", " x25", "x25", "w1", "px000", "w0", "y1", "x000", "Xfe", "px00", "y00", " xfe", "px0", "yfe", "y25", "X00", "w000", "X0", "X2", "x1", "yee", "w00", "y000"], "y0": ["sy0", "dy80", "Y2", "x2", "ym0", "y2", " y90", " y50", "Y90", "y5", "dy50", "Y1", " y1", " y25", "Y8", " y5", "y50", "dy0", "sy00", "Y25", "y90", "y80", "sy80", "Y00", " yi", "yi", "Yi", "ry1", "ym00", "y1", " y8", "sy50", "y00", "x90", "ry0", "Y0", "ym1", "ry5", "Y5", " y00", "dy00", "y25", "y8", " y80", "x8", "x1", " y2", "ry25", "ymi"], "nPbW": ["nPbWidth", "nPcWh", "nNcWidth", "nNcW", "nPmWh", "nNbW", "nPcW", "nPkW", "nPcWidth", "nPkWidth", "nPmWidth", "nPbX", "nNcX", "nPmW", "nPmX", "nPkWh", "nNbX", "nPcX", "nNcWh", "nNbWidth", "nNbWh", "nPkX", "nPbWh"], "nPbH": ["nPfW", "nHbW", "nHmW", "nPmH", "nPcW", "nPch", "nPbh", "nHbh", "nPcSH", "nPbSH", "nPmW", "nHmH", "nPfSH", "nHbSH", "nPfh", "nPcH", "nHmh", "nPfH", "nHmSH", "nPmSH", "nPmh", "nHbH"], "log2_cb_size": ["log2_cv_size", "log2_cb_SIZE", "log2_cb2SIZE", "log2_cv_len", "log2_cb_len", "log2_cb2len", "log2_cb64SIZE", "log2_cb64size", "log2_cb_sum", "log2_cb64len", "log2_cb2size", "log2_cb64sum", "log2_cv_sum", "log2_cb2sum", "log2_cv_SIZE"], "partIdx": [" partidy", "partLeny", "partidxs", "partidx", " partIdcode", "partidy", "partLenx", "partIdy", "partIDxs", "partLenxs", "partidcode", " partidx", " partidcode", " partIdy", "partIdxs", " partIdxs", "partIdcode", "partIDcode", " partidxs", "partLencode", "partIDy", "partIDx"], "idx": ["Idz", "idv", " idv", "Idx", "IDX", "IDx", "idX", "Idv", " idz", "idz", " idX", "IdX", "IDz", "IDv"], "lc": ["acs", "mc", "cm", "bc", "rc", "cc", "pc", "l", "LCS", "fs", "gc", "ctrl", "cs", "ci", "dl", "lp", "cn", "wcs", "cmp", "si", "fp", "loc", "lib", "lr", "kl", "cli", "lt", "nc", "tc", "sb", "lf", "gb", "c", "dc", "lu", "lv", "sc", "sci", "ec", "ls", "lb", "wl", "fc", "ln", "cl", "ctx", "LC"], "tab_mvf": ["tab_Mwc", "tab_mvmf", "tab_Mvfs", "tab_mavfc", "tab_mvcf", "tab_Mwfs", "tab_mwf", "tab_mvfc", "tab_mvmc", "tab_mavc", "tab_Mwfc", "tab_Mwcf", "tab_mvc", "tab_mavcf", "tab_mvfs", "tab_mavf", "tab_mqfs", "tab_mvmfc", "tab_Mvfc", "tab_mwfs", "tab_Mwf", "tab_mqf", "tab_mqcf", "tab_mavfs", "tab_Mvf", "tab_mwcf", "tab_mqc", "tab_Mvc", "tab_Mvcf", "tab_mvmfs", "tab_mwfc", "tab_mwc"], "refPicList": ["RefPictureSet", "refCaptTable", "refPicTable", "RefPicEx", "refPicEx", "refPicName", "refPictureOrder", "RefPictureEx", "RefPictureTable", "RefPicName", "RefPicOrder", "refCompList", "refObjSet", "refCompSet", "refCompName", "refPixelList", "refPictureSet", "refPicSet", "RefPictureList", "refPictureList", "RefPictureOrder", "refPictureName", "refCaptSet", "RefPictureName", "refObjOrder", "RefPicList", "refPicOrder", "RefPicSet", "refCompTable", "refCaptList", "refPixelEx", "RefPicTable", "refPixelOrder", "refObjList", "refObjEx", "refPixelSet", "refPictureTable", "refCaptName", "refPictureEx"], "ref0": ["source0", "reference0", " ref2", " ref00", "source00", "reference00", "reference2", "source2", "ref2", "ref00"], "ref1": [" ref2", "Ref1", "reference0", "Ref0", "reference2", "reference1", "ref2", "Ref2"], "dst0": ["nst00", "dpt0", "dbl0", "dbl00", "nbl3", "nbl0", "nst2", "dst3", "dsp00", "dsp3", "nbl2", "dbl2", "nst0", "dbl3", "dpt3", "dsp0", "nbl00", "dpt2", "dst00", "nst3", "dsp2", "dpt00"], "dst1": ["dste3", " dsp0", " dsp3", "dste1", " dst3", " dsp2", "dsp1", "dst3", "dste0", "dST3", "dsp3", " dsp1", "dste2", "dsp0", "dST1", "dsp2", "dST2", "dST0"], "dst2": ["dbl5", " dsp2", "dst5", "dsts4", "dsp1", "dst4", " dst4", "dbl2", " dsp1", "dsp5", "dbl4", " dsp4", "dsts5", "dsp4", " dst5", "dsts2", "dbl1", " dsp5", "dsp2", "dsts1"], "x_pu": ["x_cb", " x_cb", " x_np", " x_cpu", "x_np", "x_cpu"], "y_pu": ["y_cache", "y_cp", "y_api", "vy_cache", "vy_pu", "vy_api", "vy_cp", "y2cp", "y2cache", "y2api", "y2pu"], "i": ["it", "m", "I", "d", "ai", "id", "l", "io", "ci", "h", "x", "ii", "v", "z", "p", "e", "k", "li", "b", "n", "f", "ip", "c", "pi", "r", "y", "in"], "j": ["jj", "adj", "it", "m", "kj", "t", "jp", "jump", "l", "v", "job", "o", "obj", "z", "p", "note", "k", "axis", "b", "n", "jl", "ji", "offset", "q", "J", "y"]}}
{"project": "qemu", "commit_id": "2906cddfecff21af20eedab43288b485a679f9ac", "target": 0, "func": "static void virtio_blk_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    VirtIOBlockReq *req;\n\n    MultiReqBuffer mrb = {};\n\n\n\n    /* Some guests kick before setting VIRTIO_CONFIG_S_DRIVER_OK so start\n\n     * dataplane here instead of waiting for .set_status().\n\n     */\n\n    if (s->dataplane) {\n\n        virtio_blk_data_plane_start(s->dataplane);\n\n        return;\n\n    }\n\n\n\n    blk_io_plug(s->blk);\n\n\n\n    while ((req = virtio_blk_get_request(s))) {\n\n        virtio_blk_handle_request(req, &mrb);\n\n    }\n\n\n\n    if (mrb.num_reqs) {\n\n        virtio_blk_submit_multireq(s->blk, &mrb);\n\n    }\n\n\n\n    blk_io_unplug(s->blk);\n\n}\n", "idx": 15016, "substitutes": {"vdev": ["Vdiv", "mde", "vdef", "wdev", "mdevice", "Vdev", " vde", "Vdef", "vdiv", "wdevice", "vdi", "ldef", "mdi", "lde", "wdiv", "ldev", "ldi", "vdevice", " vdevice", " vdi", "mdev", "Vdevice", "ldevice", "vde", "wdef"], "vq": ["vcq", "vcw", "vqi", "valq", " vw", "valquest", " vqi", "vcqi", "vw", "valw", "vcquest", "valqi", "vquest", " vquest"], "s": ["south", "ses", "self", "m", "as", "rss", "parts", "d", "t", "sync", "sg", "service", "l", "i", "fs", "sym", "ins", "a", "current", "g", "cs", "S", "sk", "os", "its", "new", "si", "js", "es", "sq", "uns", "session", "v", "full", "ps", "ss", "o", "w", "u", "an", "params", "p", "se", "e", "ions", "http", "b", "sb", "n", "f", "gs", "spec", "c", "ns", "is", "ssl", "sv", "sl", "ops", "r", "ds", "services", "su", "ls", "us", "comments", "ks", "aws"], "req": ["sem", "rr", "call", "proc", "ch", "ru", "dq", "input", "hr", "gr", "rs", "def", "progress", "ref", "sq", "Request", "fr", "conf", "quest", "request", "w", "ind", "rec", "p", "ir", "ver", "desc", "require", "rx", "http", "ext", "comp", "qt", "requ", "spec", "crit", "ry", "iq", "pull", "cb", "wa", "q", "load", "r", "exec", "resp", "cache", "seq", "sub", "res", "reg", "cur", "rf", "err"]}}
{"project": "FFmpeg", "commit_id": "0c32e19d584ba6ddbc27f0a796260404daaf4b6a", "target": 0, "func": "static void av_noinline filter_mb_edgeh( uint8_t *pix, int stride, int16_t bS[4], unsigned int qp, H264Context *h ) {\n\n    const unsigned int index_a = 52 + qp + h->slice_alpha_c0_offset;\n\n    const int alpha = alpha_table[index_a];\n\n    const int beta  = (beta_table+52)[qp + h->slice_beta_offset];\n\n    if (alpha ==0 || beta == 0) return;\n\n\n\n    if( bS[0] < 4 ) {\n\n        int8_t tc[4];\n\n        tc[0] = tc0_table[index_a][bS[0]];\n\n        tc[1] = tc0_table[index_a][bS[1]];\n\n        tc[2] = tc0_table[index_a][bS[2]];\n\n        tc[3] = tc0_table[index_a][bS[3]];\n\n        h->s.dsp.h264_v_loop_filter_luma(pix, stride, alpha, beta, tc);\n\n    } else {\n\n        h->s.dsp.h264_v_loop_filter_luma_intra(pix, stride, alpha, beta);\n\n    }\n\n}\n", "idx": 15051, "substitutes": {"pix": [" pixel", "Pix", "spixels", "Pixels", " pik", "fik", "pixel", "pixels", "mixels", "mixel", "mip", " prc", "prc", "spix", "Pip", " pip", "spik", "fix", "mix", "fixels", "fixel", "sprc", "Prc", "frc", "pip", "Pixel", " pixels", "pik"], "stride": ["shride", "strid", "stider", "strider", "strice", "dride", " strid", "stides", "trided", "slid", "strad", "divide", "strided", "brided", "shrice", " strider", "slider", "divider", "drice", "bride", "slide", " strides", "brides", "brice", "drided", "slides", "strides", "drides", "divad", "trad", "shrides", "shrided", "stid", "divided", " strad", "trider", "tride", "stide", " strided"], "bS": ["fV", " bSi", "cP", "pEs", "bC", " bIS", "bWS", "basCS", "cC", " bC", "bEs", "barS", " bDS", "bP", "basSocket", " bs", " bWS", "fIS", "fs", "pS", "basDS", "rbSi", "bSS", "bSocket", "xJS", "rbs", " bSocket", "xS", "bIS", "barCS", " bV", " bP", "bV", "bDS", "xWS", "bDs", "bTS", "pDs", "partWS", "aC", "barSocket", "partS", "aS", " bSS", "lDs", "fSS", "fS", "aP", "bs", "lEs", "partJS", " bJS", " bDs", "bSi", "rbS", "cS", " bCS", "bCS", "fSi", "basS", "rbV", "bJS", "lS", " bTS", "barDS", " bEs", "fTS"], "qp": ["squ", "sqp", "dqc", "quu", "qup", "dqP", "fxn", "fxp", "dqp", "dqpr", "Qpr", "fxc", "quc", "fxu", "qn", "qtp", "QP", "qu", "quP", "Qc", "qun", "Qp", "sqpr", "sqc", "sqP", "Qtp", "qP", "qutp", "qpr", "sqn", "sqtp", "qc"], "h": ["hi", "m", "ch", "self", "ha", "hl", "hp", "hr", "t", "d", "oh", "ih", "l", "ah", "g", "hs", "hub", "x", "gh", "v", "rh", "conn", "uh", "w", "hh", "u", "p", "e", "s", "he", "eh", "http", "b", "han", "n", "f", "hm", "html", "bh", "c", "ht", "q", "r", "H", "host", "sh", "hd", "zh", "history", "hess", "ph", "hw", "ctx"], "tc": ["toc", "ui", "mc", "uc", "bc", "tx", "ca", "tmp", "tk", "rc", "config", "pc", "cc", "bb", "t", "binary", "ta", "lc", "ci", "cs", "ctrl", "beta", "tt", "acc", "asc", "uca", "loc", "tm", "ul", "term", "cum", "ticket", "temp", " TC", "Beta", "nc", "pb", "cus", "gb", "TC", "c", "gam", "cu", "dc", "fc", "ac", "tf", "type", "cas", "sc", "cb", "ic", "tu", "icc", "cases", "cache", "xc", "ec", "css", "ctx", "index"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "static void realize(DeviceState *d, Error **errp)\n\n{\n\n    sPAPRDRConnector *drc = SPAPR_DR_CONNECTOR(d);\n\n    Object *root_container;\n\n    char link_name[256];\n\n    gchar *child_name;\n\n    Error *err = NULL;\n\n\n\n    trace_spapr_drc_realize(spapr_drc_index(drc));\n\n    /* NOTE: we do this as part of realize/unrealize due to the fact\n\n     * that the guest will communicate with the DRC via RTAS calls\n\n     * referencing the global DRC index. By unlinking the DRC\n\n     * from DRC_CONTAINER_PATH/<drc_index> we effectively make it\n\n     * inaccessible by the guest, since lookups rely on this path\n\n     * existing in the composition tree\n\n     */\n\n    root_container = container_get(object_get_root(), DRC_CONTAINER_PATH);\n\n    snprintf(link_name, sizeof(link_name), \"%x\", spapr_drc_index(drc));\n\n    child_name = object_get_canonical_path_component(OBJECT(drc));\n\n    trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);\n\n    object_property_add_alias(root_container, link_name,\n\n                              drc->owner, child_name, &err);\n\n    g_free(child_name);\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return;\n\n    }\n\n    vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,\n\n                     drc);\n\n    qemu_register_reset(drc_reset, drc);\n\n    trace_spapr_drc_realize_complete(spapr_drc_index(drc));\n\n}\n", "idx": 15055, "substitutes": {"d": ["D", "dh", "m", "fd", "t", " D", "l", "i", "bd", "di", "ld", "o", "gd", "w", "ad", "p", "e", "dict", "data", "b", "driver", "sd", "did", "f", "dom", "xd", "dat", "c", "dt", "dc", "md", "dp", "r", "dr", "dm", "dos"], "errp": ["errpy", "rrpc", "erpre", "erpc", "rrpre", " erp", " errpre", "rrp", " erpre", "errP", " errP", "erp", "rrP", "errpre", " errpy", "erP", "errpc", " erP", "erpy", " errpc", " erpy"], "drc": ["tource", "dbirc", "prec", "pdrec", "dpc", "crc", " dource", "prc", "odrc", "drec", "Dource", "madrt", "ldRC", "sdrec", "drt", "dRC", "edrac", "lRC", "Drc", "madirc", "pdrc", "eRC", "trc", "madRC", "sdrc", "eirc", "odrec", "Dpc", "distrc", "distirc", "lrc", "Duc", "edrec", "idroc", "zrac", "eource", "ldsrc", "odRC", "bdrc", "dirc", "drac", "distrt", "madrc", "csrc", "zrc", "dource", "Drec", "circ", "bdsc", " droc", "ndrc", "tirc", "droc", "dbource", "lsrc", "idource", "sduc", "zource", "DRC", "duc", "ldroc", "pRC", "idync", " dirc", "bdource", " drec", " dsrc", "zrec", "dbrc", "dsource", "idrc", "ndrec", "erc", "dync", "dsrec", " dRC", "psrc", "sdRC", "edource", "odync", "crec", "pdrac", "Dirc", "ldrec", "Dsrc", "dsync", " duc", " dpc", "sdpc", "sdsrc", "ldsc", " dsc", "bdirc", "dbsc", "idsc", "ndsrc", "dsrc", "ldrc", "odsrc", "Drt", "ndirc", "idrec", "dsc", "idsrc", "tRC", "edrc", "pdource", "distRC", "lrec", "odource"], "root_container": ["root_class", "rt_root", "rtercomponent", "root_root", "root64entry", "rt_path", "rooterpath", " root_class", "rterroot", "root64container", "root_component", "rt_container", "rootercomponent", "rterpath", "rootscontainer", "rtercontainer", "rootscomponent", "root_entry", "rooterroot", "parent_entry", "parent_container", "rootsroot", "root64path", "rt_component", "rootspath", "parent_path", "root_path", " root_path", "rootercontainer"], "link_name": ["link_id", "key_id", "code_number", "key_address", "linkpnumber", " link_names", "link2no", "link_no", "parent_path", "linkFnumber", "linkpvalue", "key_name", "parent_name", "codeFname", "parent_type", "code_value", "linkpname", "link2name", "link_address", "link_names", " link_no", "link_type", "linkFvalue", "link_path", "link_number", "codeFvalue", "code_name", "link_value", "codeFnumber", "link2names", "linkFname"], "child_name": ["childWname", " child_path", " child_names", "childingnamed", " child_Name", "child_id", "imageingnamed", "link_link", "imageingclass", "child_address", "childOnamed", "childTagcount", "parent_path", "childingvalue", "childOname", "childssize", "childslink", "childingaddress", "childNnamed", "parent_name", "childTagname", "childsnames", "linksname", "child_names", "child_class", "childingname", "imageingname", "linkssize", "childingclass", "childWsize", "childOclass", "child_count", " child_count", "child_value", "linksName", "image_class", "childOaddress", "image_name", "childNclass", "childNname", "childWlink", "child_named", "childspath", "childWName", "childTagName", "childTagpath", "childsname", "link_size", "childsid", "link_Name", "child_link", "childNaddress", "imageingaddress", "image_address", "parent_value", "childingpath", "child_path", "image_named", "child_size", "childsName", "linkslink", " child_id", "child_Name"], "err": ["bug", "runner", "rr", "gz", "erer", "hr", "fy", "gr", "rs", "ah", "msg", "ctr", "kr", "g", "er", "Error", "req", "or", "ner", "str", "ace", "eor", "aster", "error", "Er", "fr", "rh", "var", "der", "oe", "cr", "mr", "ind", "orer", "ir", "fi", "exc", "lr", "rx", "e", "ver", "ler", "result", "arr", "acer", "cb", "iter", "r", "resp", "finder", "pr", "ev", "ar", "nr", "orr", "rage", "dr", "fee", "order", "ise", "ln"]}}
{"project": "qemu", "commit_id": "7ec1e5ea4bd0700fa48da86bffa2fcc6146c410a", "target": 0, "func": "static void gen_ld_asi(DisasContext *dc, TCGv dst, TCGv addr,\n\n                       int insn, int size, int sign)\n\n{\n\n    TCGv_i32 r_asi, r_size, r_sign;\n\n\n\n    r_asi = gen_get_asi(dc, insn);\n\n    r_size = tcg_const_i32(size);\n\n    r_sign = tcg_const_i32(sign);\n\n#ifdef TARGET_SPARC64\n\n    gen_helper_ld_asi(dst, cpu_env, addr, r_asi, r_size, r_sign);\n\n#else\n\n    {\n\n        TCGv_i64 t64 = tcg_temp_new_i64();\n\n        gen_helper_ld_asi(t64, cpu_env, addr, r_asi, r_size, r_sign);\n\n        tcg_gen_trunc_i64_tl(dst, t64);\n\n        tcg_temp_free_i64(t64);\n\n    }\n\n#endif\n\n    tcg_temp_free_i32(r_sign);\n\n    tcg_temp_free_i32(r_size);\n\n    tcg_temp_free_i32(r_asi);\n\n}\n", "idx": 15061, "substitutes": {"dc": ["context", "mc", "uc", "bc", "cm", "d", "fd", "rc", "cc", "pc", "config", "cdn", "DC", "lc", "cit", "cgi", "ct", "conn", "cd", "cot", "oc", "nc", "tc", "cca", "c", "dt", "jc", "ac", "cb", "cf", "dp", " DC", "icc", "ds", "db", "cache", "ec", "fc", "dm", "ctx"], "dst": ["dsst", "Dsc", "Dst", " dST", "idcr", "bsta", "Dsts", "ldsc", "sdcr", "dsta", " dsc", "dsts", "dssta", " dcr", "idsc", "bST", "dssts", "Dost", "ldst", "idste", "sdst", "sdsc", "ldost", "ldST", "dost", "dsc", " dste", "idst", "dST", "DST", "dsST", " dost", "sdste", "Dsta", "dcr", "bsts", "dste", "bst"], "addr": ["func", "ord", "ada", "context", "osi", "vr", "ha", "sta", "amp", "pkg", "arm", "amd", "player", "oa", "align", "anne", "str", "ace", "grad", "adr", "layer", "la", "arch", "data", "ptr", "au", "ann", "add", "address", "ip", "url", "afi", "offset", "attr", "ast", "ack", "host", "mac", "nr", "src", "ar", "dr", "work", "coord", "pad", "wd", "asm"], "insn": ["idsn", "intsl", "insc", "ainsn", "ainsize", "alsize", "alsnl", "ainsnl", "intsn", "insl", " insl", "intsc", "insnl", "insize", " insr", "insr", "intsr", "idsize", "idsnl", "INSl", "INSc", "alsnb", "ainsnb", "alsn", "idsnb", "INSr", " insc", "insnb", "INSn"], "size": ["en", "small", "sync", "enc", "sized", "shape", "large", "name", "g", "align", "send", "Size", "use", "capacity", "si", "sum", "storage", "ize", "six", "eng", "sd", "speed", "address", "grade", "SIZE", "esc", "sn", "sc", "security", "scale", "sh", "fee", "core"], "sign": ["draw", "carry", "enc", "id", "shift", "shape", "plus", "name", " signs", "act", "align", "SIGN", "sw", "raw", "sum", "form", "pass", "parse", "ize", "se", "pack", "min", "spec", "inc", "Sign", "round", "sc", "scale", "sl", "load", "strength", "sa", "save", "ign", "space", "push", "pad", "rap"], "r_asi": [" r_assi", "rMadr", "r_azi", "rplosi", " r_ta", "r_asin", "r0asin", "r0isa", "rpladr", "nr_asi", "r_adr", " r_zi", "rplasi", "r__asi", "r_ta", " r_asa", "r_assi", "nr_isa", " r_azi", "nr_asin", "r__isa", "rMasi", "r__asin", " r_ati", " r_adr", " r_isa", "r_aii", "nr_ai", "rMosi", "r0ai", "r_ati", " r_aii", "r0asi", "r_isa", "r_zi", "r__ai", "r_asa", "rMta", "r_osi", " r_osi", "rplta", "r_ai"], "r_size": ["nr_scale", "rb___score", "rb_loc", "nr_size", "rg_size", "rb___si", "r_score", "r_ize", "nr_sign", "dr_sign", "nr_asi", "dr_ize", "rb_score", "r___care", "r_ica", "rg_si", "rb_capacity", "r_scale", "rb___care", "rb_size", "rb___size", "rb_slice", "dr_size", "r_loc", "rb_care", "r_care", "rb_si", "r_si", "r___score", "rg_ica", "r___size", "r_fee", "rg_ize", "r___si", "dr_fee", "r_capacity", "r_slice"], "r_sign": ["r64signed", "r64SIGN", "mr_err", "r_min", "r_err", "rr64signed", "rr_like", "rPform", "rh_form", " r_keep", "r_like", "rh_length", "r9clean", "rr_signed", "rh_space", "mr_min", "r___sign", "mr_sign", "r64like", "rhPclean", "r_length", "r9sign", "r64sign", "rPsign", "rhPform", "rhPsign", "r___keep", "rhPlength", "r_space", "r9form", "r_keep", "r9length", "rh_clean", "rr_sign", "rr64SIGN", "rh_sign", "rr64like", "mr_size", "rPlength", "r_form", "r_signed", "rPclean", "r___sa", "rr64sign", " r_sa", "r_clean", "r_SIGN", "r___size", "r_sa", "rr_SIGN"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "static inline float64 ucf64_itod(uint64_t i)\n\n{\n\n    union {\n\n        uint64_t i;\n\n        float64 d;\n\n    } v;\n\n\n\n    v.i = i;\n\n    return v.d;\n\n}\n", "idx": 15066, "substitutes": {"i": ["qi", "it", "ui", "m", "I", "d", "t", "ai", "xi", "l", "iu", "gi", "ini", "a", "oi", "val", "ci", "ig", "h", "di", "x", "si", "ie", "ii", "vi", "o", "u", "p", "e", "li", "k", "ix", "b", "j", "phi", "f", "n", "ti", "c", "is", "pi", "ic", "r", "bi", "ri", "ik", "index"], "v": ["m", "d", "t", "vv", "l", "val", "vp", "iv", "g", "x", "vm", "value", "vi", "var", "tv", "o", "av", "w", "u", "p", "e", "ver", "k", "data", "j", "n", "f", "c", "lv", "ov", "sv", "q", "nv", "va", "uv", "V", "ev", "vd", "vt", "vs", "vals"]}}
{"project": "qemu", "commit_id": "23dceda62a3643f734b7aa474fa6052593ae1a70", "target": 0, "func": "int tcg_gen_code(TCGContext *s, tcg_insn_unit *gen_code_buf)\n\n{\n\n    int i, oi, oi_next, num_insns;\n\n\n\n#ifdef CONFIG_PROFILER\n\n    {\n\n        int n;\n\n\n\n        n = s->gen_last_op_idx + 1;\n\n        s->op_count += n;\n\n        if (n > s->op_count_max) {\n\n            s->op_count_max = n;\n\n        }\n\n\n\n        n = s->nb_temps;\n\n        s->temp_count += n;\n\n        if (n > s->temp_count_max) {\n\n            s->temp_count_max = n;\n\n        }\n\n    }\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP))) {\n\n        qemu_log(\"OP:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time -= profile_getclock();\n\n#endif\n\n\n\n#ifdef USE_TCG_OPTIMIZATIONS\n\n    tcg_optimize(s);\n\n#endif\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->opt_time += profile_getclock();\n\n    s->la_time -= profile_getclock();\n\n#endif\n\n\n\n    tcg_liveness_analysis(s);\n\n\n\n#ifdef CONFIG_PROFILER\n\n    s->la_time += profile_getclock();\n\n#endif\n\n\n\n#ifdef DEBUG_DISAS\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP_OPT))) {\n\n        qemu_log(\"OP after optimization and liveness analysis:\\n\");\n\n        tcg_dump_ops(s);\n\n        qemu_log(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    tcg_reg_alloc_start(s);\n\n\n\n    s->code_buf = gen_code_buf;\n\n    s->code_ptr = gen_code_buf;\n\n\n\n    tcg_out_tb_init(s);\n\n\n\n    num_insns = -1;\n\n    for (oi = s->gen_first_op_idx; oi >= 0; oi = oi_next) {\n\n        TCGOp * const op = &s->gen_op_buf[oi];\n\n        TCGArg * const args = &s->gen_opparam_buf[op->args];\n\n        TCGOpcode opc = op->opc;\n\n        const TCGOpDef *def = &tcg_op_defs[opc];\n\n        uint16_t dead_args = s->op_dead_args[oi];\n\n        uint8_t sync_args = s->op_sync_args[oi];\n\n\n\n        oi_next = op->next;\n\n#ifdef CONFIG_PROFILER\n\n        tcg_table_op_count[opc]++;\n\n#endif\n\n\n\n        switch (opc) {\n\n        case INDEX_op_mov_i32:\n\n        case INDEX_op_mov_i64:\n\n            tcg_reg_alloc_mov(s, def, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_movi_i32:\n\n        case INDEX_op_movi_i64:\n\n            tcg_reg_alloc_movi(s, args, dead_args, sync_args);\n\n            break;\n\n        case INDEX_op_insn_start:\n\n            if (num_insns >= 0) {\n\n                s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n            }\n\n            num_insns++;\n\n            for (i = 0; i < TARGET_INSN_START_WORDS; ++i) {\n\n                target_ulong a;\n\n#if TARGET_LONG_BITS > TCG_TARGET_REG_BITS\n\n                a = ((target_ulong)args[i * 2 + 1] << 32) | args[i * 2];\n\n#else\n\n                a = args[i];\n\n#endif\n\n                s->gen_insn_data[num_insns][i] = a;\n\n            }\n\n            break;\n\n        case INDEX_op_discard:\n\n            temp_dead(s, args[0]);\n\n            break;\n\n        case INDEX_op_set_label:\n\n            tcg_reg_alloc_bb_end(s, s->reserved_regs);\n\n            tcg_out_label(s, arg_label(args[0]), s->code_ptr);\n\n            break;\n\n        case INDEX_op_call:\n\n            tcg_reg_alloc_call(s, op->callo, op->calli, args,\n\n                               dead_args, sync_args);\n\n            break;\n\n        default:\n\n            /* Sanity check that we've not introduced any unhandled opcodes. */\n\n            if (def->flags & TCG_OPF_NOT_PRESENT) {\n\n                tcg_abort();\n\n            }\n\n            /* Note: in order to speed up the code, it would be much\n\n               faster to have specialized register allocator functions for\n\n               some common argument patterns */\n\n            tcg_reg_alloc_op(s, def, opc, args, dead_args, sync_args);\n\n            break;\n\n        }\n\n#ifndef NDEBUG\n\n        check_regs(s);\n\n#endif\n\n        /* Test for (pending) buffer overflow.  The assumption is that any\n\n           one operation beginning below the high water mark cannot overrun\n\n           the buffer completely.  Thus we can test for overflow after\n\n           generating code without having to check during generation.  */\n\n        if (unlikely((void *)s->code_ptr > s->code_gen_highwater)) {\n\n            return -1;\n\n        }\n\n    }\n\n    tcg_debug_assert(num_insns >= 0);\n\n    s->gen_insn_end_off[num_insns] = tcg_current_code_size(s);\n\n\n\n    /* Generate TB finalization at the end of block */\n\n    tcg_out_tb_finalize(s);\n\n\n\n    /* flush instruction cache */\n\n    flush_icache_range((uintptr_t)s->code_buf, (uintptr_t)s->code_ptr);\n\n\n\n    return tcg_current_code_size(s);\n\n}\n", "idx": 15067, "substitutes": {"s": ["ings", "rs", "qs", "h", "new", "js", "si", "server", "ps", "params", "groups", "lines", "tests", "spec", "c", "is", "states", "in", "south", "m", "self", "d", "t", "sync", "sg", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "ges", "storage", "w", "u", "b", "sf", "ns", "results", "ops", "r", "ks", "sys", "parts", "service", "hs", "os", "sets", "o", "e", "options", "site", "http", "sb", "features", "f", "ans", "services", "ls", "comments", "ses", "l", "rates", "sites", "S", "settings", "this", "its", "sq", "rows", "v", "conf", "ss", "request", "set", "p", "plugins", "ions", "ments", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "ims"], "gen_code_buf": ["gen_codelbuf", "gen_codepbuffer", "gen_codelbuffer", "gen_map_buf", "gen_codepbuff", "gen_call_buffer", "gen_codepbuf", "gen_const_buf", "gen_code_buff", "gen_call_queue", "gen_code_buffer", "gen_code_uf", "gen_codelbuff", "gen_const_buff", "gen_map_tab", "gen_const_uf", "gen_code_queue", "gen_map_buff", "gen_codeltab", "gen_codepqueue", "gen_const_buffer", "gen_call_buff", "gen_map_buffer", "gen_call_buf", "gen_code_tab"], "i": ["it", "ui", "I", "d", "ni", "io", "ci", "x", "si", "ii", "o", "p", "e", "b", "j", "phi", "f", "ti", "ip", "c", "pi", "bi", "num", "index", "start"], "oi": ["oni", "oid", "ani", "qi", "ui", "osi", "adi", "ni", "ai", "edi", "ilo", "ini", "iw", "flo", "xi", "oa", "asi", "api", "ci", "ki", "si", "ie", "ii", "elo", "uri", "oe", "ois", "o", "yi", "igi", "oda", "oko", "phi", "nu", "ti", "ogi", "ski", "oji", "isi", "uci", "eni", "agi", "jc", "ji", "pi", "obo", "bi", "ik", "oci", "imi", "ei", "ahi", "odi", "ori", " bi", "ami", "zi"], "oi_next": ["ci_start", "oi_later", "oi_first", "ci_later", "ci_last", "ci_next", "oi_current", "ci_current", "oi_last", "ci_first", "oi_start"], "num_insns": ["num_inxs", "num_outnas", "num_inn", "num_inls", "num_winls", "num_inccs", "num_insxs", "num_incn", "num_insnas", "num_outn", "num_pinxs", "num_incs", "num_incns", "num_winns", "num_inns", "num_wincs", "num_innas", "num_insls", "num_outns", "num_pinnas", "num_pinns", "num_insn", "num_incls", "num_winn", "num_pinn", "num_outxs", "num_inscs"], "n": ["ln", "adj", "nat", "m", "en", "non", "d", "t", "on", "ni", "l", "un", "N", "nn", "name", "syn", "na", "mn", "nb", "cn", "x", "fn", "v", "conn", "o", "w", "an", "z", "p", "nan", "net", "not", "e", "nc", "k", "b", "min", "nil", "j", "count", "nu", "f", "none", "nor", "c", "ns", "number", "ne", "pn", "ng", "sn", "nt", "nin", "r", "dn", "pos", "no", "num", "span", "len", "y", "max"], "op": ["oper", "ode", "proc", "OP", "ype", "id", "up", "name", "sp", "operation", "option", "init", "obj", "oc", "oop", "data", "omp", "expr", "ip", "block", "Op", "one", "ops", "hop", "num", "prev", "opt", "node"]}}
{"project": "qemu", "commit_id": "68d553587c0aa271c3eb2902921b503740d775b6", "target": 0, "func": "static int ehci_process_itd(EHCIState *ehci,\n\n                            EHCIitd *itd)\n\n{\n\n    USBPort *port;\n\n    USBDevice *dev;\n\n    int ret;\n\n    uint32_t i, j, len, pid, dir, devaddr, endp;\n\n    uint32_t pg, off, ptr1, ptr2, max, mult;\n\n\n\n    dir =(itd->bufptr[1] & ITD_BUFPTR_DIRECTION);\n\n    devaddr = get_field(itd->bufptr[0], ITD_BUFPTR_DEVADDR);\n\n    endp = get_field(itd->bufptr[0], ITD_BUFPTR_EP);\n\n    max = get_field(itd->bufptr[1], ITD_BUFPTR_MAXPKT);\n\n    mult = get_field(itd->bufptr[2], ITD_BUFPTR_MULT);\n\n\n\n    for(i = 0; i < 8; i++) {\n\n        if (itd->transact[i] & ITD_XACT_ACTIVE) {\n\n            pg   = get_field(itd->transact[i], ITD_XACT_PGSEL);\n\n            off  = itd->transact[i] & ITD_XACT_OFFSET_MASK;\n\n            ptr1 = (itd->bufptr[pg] & ITD_BUFPTR_MASK);\n\n            ptr2 = (itd->bufptr[pg+1] & ITD_BUFPTR_MASK);\n\n            len  = get_field(itd->transact[i], ITD_XACT_LENGTH);\n\n\n\n            if (len > max * mult) {\n\n                len = max * mult;\n\n            }\n\n\n\n            if (len > BUFF_SIZE) {\n\n                return USB_RET_PROCERR;\n\n            }\n\n\n\n            qemu_sglist_init(&ehci->isgl, 2);\n\n            if (off + len > 4096) {\n\n                /* transfer crosses page border */\n\n                uint32_t len2 = off + len - 4096;\n\n                uint32_t len1 = len - len2;\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len1);\n\n                qemu_sglist_add(&ehci->isgl, ptr2, len2);\n\n            } else {\n\n                qemu_sglist_add(&ehci->isgl, ptr1 + off, len);\n\n            }\n\n\n\n            pid = dir ? USB_TOKEN_IN : USB_TOKEN_OUT;\n\n\n\n            usb_packet_setup(&ehci->ipacket, pid, devaddr, endp);\n\n            usb_packet_map(&ehci->ipacket, &ehci->isgl);\n\n\n\n            ret = USB_RET_NODEV;\n\n            for (j = 0; j < NB_PORTS; j++) {\n\n                port = &ehci->ports[j];\n\n                dev = port->dev;\n\n\n\n                if (!(ehci->portsc[j] &(PORTSC_CONNECT))) {\n\n                    continue;\n\n                }\n\n\n\n                ret = usb_handle_packet(dev, &ehci->ipacket);\n\n\n\n                if (ret != USB_RET_NODEV) {\n\n                    break;\n\n                }\n\n            }\n\n\n\n            usb_packet_unmap(&ehci->ipacket);\n\n            qemu_sglist_destroy(&ehci->isgl);\n\n\n\n#if 0\n\n            /*  In isoch, there is no facility to indicate a NAK so let's\n\n             *  instead just complete a zero-byte transaction.  Setting\n\n             *  DBERR seems too draconian.\n\n             */\n\n\n\n            if (ret == USB_RET_NAK) {\n\n                if (ehci->isoch_pause > 0) {\n\n                    DPRINTF(\"ISOCH: received a NAK but paused so returning\\n\");\n\n                    ehci->isoch_pause--;\n\n                    return 0;\n\n                } else if (ehci->isoch_pause == -1) {\n\n                    DPRINTF(\"ISOCH: recv NAK & isoch pause inactive, setting\\n\");\n\n                    // Pause frindex for up to 50 msec waiting for data from\n\n                    // remote\n\n                    ehci->isoch_pause = 50;\n\n                    return 0;\n\n                } else {\n\n                    DPRINTF(\"ISOCH: isoch pause timeout! return 0\\n\");\n\n                    ret = 0;\n\n                }\n\n            } else {\n\n                DPRINTF(\"ISOCH: received ACK, clearing pause\\n\");\n\n                ehci->isoch_pause = -1;\n\n            }\n\n#else\n\n            if (ret == USB_RET_NAK) {\n\n                ret = 0;\n\n            }\n\n#endif\n\n\n\n            if (ret >= 0) {\n\n                if (!dir) {\n\n                    /* OUT */\n\n                    set_field(&itd->transact[i], len - ret, ITD_XACT_LENGTH);\n\n                } else {\n\n                    /* IN */\n\n                    set_field(&itd->transact[i], ret, ITD_XACT_LENGTH);\n\n                }\n\n\n\n                if (itd->transact[i] & ITD_XACT_IOC) {\n\n                    ehci_record_interrupt(ehci, USBSTS_INT);\n\n                }\n\n            }\n\n            itd->transact[i] &= ~ITD_XACT_ACTIVE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 15077, "substitutes": {"ehci": ["ehcu", "ahcin", "ihc", "ahdi", "evc", "ekCI", "ehdi", "ehc", "ekcu", "ecki", "ihcin", "ohco", "ecc", "ohdi", "ahli", "ehCI", "ahki", "ihci", "ecci", "evci", "ohcu", "ihdi", "ehli", "ahCI", "ecdi", "ihcu", "ahci", "evki", "ehcin", "hessci", "ehki", "ekci", "hesscu", "ahcu", "ihco", "ohcin", "ahc", "ehco", "ohc", "ohci", "hessli", "hessCI", "ahco", "ekli", "evdi"], "itd": [" ite", "iterdj", "ithdd", "mitds", "itsdn", "ithds", "idds", "ithl", "ITdd", "itdn", " itl", "itsd", "ittingds", "itds", "ITD", "editds", "iterd", "editl", "ctdn", "ctdj", "ittingd", "mitl", "itdj", "ide", "ite", "pitds", "ipl", "ipD", "ctd", "itl", " itds", "ipds", "ctds", "pitd", "pitD", "ITd", "itdat", "itsds", "ITl", "ctD", "idl", "ITdj", "itsdd", "ctl", "ITds", " itdat", "pitl", "mitd", "ITe", "itsD", "idD", "iddat", "ithd", "itD", "ittingdn", "itsl", "itdd", " itD", "ipd", "ittingD", "ITdat", "idd", "iterds", "mitD", "iterD", "editd"], "port": ["proc", "config", "pc", "Port", "pt", "iv", "test", "pp", "ind", "plugin", "select", "http", "op", "ort", "wp", "apter", "ip", "type", "ports", "dp", "cp", "host", "rest", "pos", "post", "tun", "gp"], "dev": ["plug", "device", "proc", "pkg", "cam", "dist", "priv", " device", "def", "Dev", "app", "conf", "gu", "conn", "w", "pub", "grad", "ad", "ver", "diff", " priv", "debug", "pro", "disk", "ev", "reg", "pad"], "ret": ["proc", "_", "rc", "val", "code", " resp", "lit", " reply", "conn", "mem", "mi", "Ret", "count", "result", " RET", " result", "eth", "nt", "re", "out", "all", "resp", "RET", "res", "no"], "i": ["ani", "qi", "it", "ui", "adi", "I", "t", "ni", "ai", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "iv", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "v", "o", "yi", "u", "ind", "p", "e", "fi", "info", "mi", "li", "cli", "b", "ix", "multi", "k", "phi", "n", "ti", "ip", "c", "is", "inner", "ji", "pi", "chi", "uli", "bi", "ri", "ori", "zi", "y", "in", "index"], "j": ["adj", "uni", "it", "en", "vision", "aj", "slice", "sync", "ni", "ai", "jp", "ii", "loc", "slave", "job", "ind", "li", "eni", "ji", "pi", "r", "pri", "ori", "rel", "pos", "ami", "delay", "index"], "len": ["en", "rev", "lin", "non", "fl", "Len", "l", "lan", "lon", "un", "val", "nn", "lc", "fun", "dl", "lang", "full", "lit", "fat", "loc", "ld", "valid", "limit", "fn", "lib", "vert", "size", "ll", "la", "fin", "lt", "li", "min", "length", "n", "lf", "count", "ann", "line", "ler", "f", "span", "url", "il", "lu", "ell", "nt", "sl", "le", "coll", "elt", "den", "all", "pos", "el", "bl", "ln", "lim"], "pid": ["path", "proc", "po", "ai", "ni", "pc", "ini", "id", "vid", "di", "pp", "pu", "ind", "mi", "pa", "ix", "mode", "ip", "pm", "pi", "cp", "pri", "pos", "ori", "delay", "pad", "pn", "uid"], "dir": ["path", "pkg", "part", "d", "dist", "fd", "level", "req", "di", "ref", "det", "Dir", "mod", "dest", "loc", "der", "grad", "orient", "dy", "ind", "doc", "direct", "direction", "desc", "mode", "dep", "diff", "md", "iter", "sl", "dn", "dr", "pos", "rel", "prefix", "order", "dim", "wd"], "devaddr": ["deviceptr", " devptr", "testaddress", "deviceaddress", "deviceaddr", " devAddress", "devaddress", "verptr", "testdr", "evaddress", "deviceAddress", "veraddress", "devAddress", "testaddr", "devdr", "verdr", "testptr", "evAddress", "veraddr", "evaddr", "evptr", " devdr", "devptr", " devaddress"], "endp": ["idpoint", "endedp", "endf", "idvp", "startf", "endpoint", "endedpoint", "endedf", "endpc", "idp", " endf", "startp", "startpc", "webp", "webpoint", "endvp", "webvp", " endvp", "startpoint", "webpc", " endpoint", " endpc", "idpc", "endedpc"], "pg": ["jj", "pse", "ff", "pkg", "ha", "ijk", "PG", "qa", "config", "pc", "cc", "mp", "bb", "ww", "pt", "g", "ig", "tg", "rg", "pool", "pp", "eg", "gh", "xp", "peg", "ager", "sq", "kk", "og", "ct", "ps", "gn", "pu", "conn", "mb", "ss", "col", "pub", "quad", "p", "gg", "pb", "pa", "pl", "k", "ag", "mg", "wp", "rog", "neg", "round", "pe", "ng", "gen", "ph", "ht", "cmd", "mag", "org", "cp", "db", "seq", "tag", "reg", "pad", "post", "pn", "gp"], "off": ["ord", "alt", "ff", "non", "on", "art", "id", "shift", "lon", "style", "oa", "pt", "def", "front", "low", "Off", "option", "offer", "raw", "OFF", "slave", "value", "output", "o", "open", "oc", "online", "own", "op", "opp", "mode", "ask", "rol", "anon", "length", "ip", "diff", "block", "end", "down", "offs", "type", "offset", "pull", "md", "ng", "now", "cmd", "out", "load", "half", "pos", "num", "addr", "no", "post", "over", "start"], "ptr1": [" ptrU", "padU", "len3", "pointerU", "pointer1", " ptr01", "ptrn", "pointer2", "pointer01", "pointern", "pad2", "pt100", "pointerone", "ptone", " ptr100", "ptrone", "pointer100", "ptr01", "pt1", "len2", "pad3", " ptrn", "ptrU", "ptr100", "ptr3", "pointer3", "pad1", " ptrone", "len1", "padn", "pt01"], "ptr2": [" ptr5", " ptrb", "plugTwo", "pointer182", "pointerTwo", "pointer2", "pt2", "pointer5", "reqtwo", " ptr182", "ptr52", "plug52", "req52", "ptrb", "req2", "sthb", "pointer52", "plugtwo", "ptr5", "reqTwo", " ptr4", "plug2", "ptr4", "pointerL", "ptr182", "pointertwo", "pointer4", "pt4", "sth5", "pointer62", " ptrL", "pointerb", "ptrL", "ptrtwo", "sth182", "pt62", "ptr62", "ptL", "sth2", "ptrTwo", " ptr62"], "max": ["depth", "wh", "part", "po", "dist", "on", "id", "def", "name", "range", "x", "post", "MAX", "total", "sum", "mod", "con", "opt", "patch", "limit", "conf", "strip", "w", "col", "pass", "size", "p", "ver", "k", "min", "Max", "length", "count", "n", "none", "parent", "ax", "c", "only", "cat", "end", "ph", "q", "scale", "comb", "out", "r", "last", "cache", "pos", "num", "order", "pad", "no", "cl", "height"], "mult": ["zip", "wh", "part", "dist", "batch", "mount", "util", "quant", "gap", "fun", "req", "multipl", "low", "pool", "mod", "sum", "master", "patch", "mot", "vert", "grad", "phase", "ul", "mut", "compl", "mun", "temp", "ver", "pl", "multi", "length", "mode", "count", "dom", "multiple", "parent", "pair", "diff", "per", "pull", "common", "man", "coll", "seq", "Mult", "prefix", "delay", "lat", "pad", "cur", "comb", "mu"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_input_pop(Visitor *v, void **obj)\n\n{\n\n    QmpInputVisitor *qiv = to_qiv(v);\n\n    StackObject *tos = QSLIST_FIRST(&qiv->stack);\n\n\n\n    assert(tos && tos->qapi == obj);\n\n    QSLIST_REMOVE_HEAD(&qiv->stack, node);\n\n    qmp_input_stack_object_free(tos);\n\n}\n", "idx": 15082, "substitutes": {"v": ["m", "self", "vim", "t", "vv", "l", "val", "vp", "i", "iv", "x", "vm", "vi", "inv", "o", "u", "p", "e", "k", "vs", "vis", "j", "n", "f", "c", "volt", "ov", "sv", "q", "uv", "vu", "vc", "V", "vd", "vt", "lv", "hw"], "obj": ["func", "po", "ob", "so", "art", "jp", "val", "object", "pt", "oa", "api", "act", "os", "x", "ref", "txt", "js", "fn", "bj", "Obj", "o", "lib", "w", "ant", "office", "p", "data", "j", "inst", "n", "op", "ns", "ov", "objects", "nt", "org", "pos", "opt", "ctx", "abi", "node"], "qiv": ["requivable", "qerv", "qsoc", "qriv", "Qiv", "qtIV", "viewiv", "zerv", "viewriv", " qoc", "Qoc", "qIV", "qtiv", "Qivist", "qoc", "qoi", " qriv", "qsivist", "viewivist", " qoi", "qtivist", "qsoi", "qsiv", " qivist", "qivable", "viewIV", "qivist", "ziv", "requiv", "zivist", "requivist", "zivable", "quiv", "quivist", "quivable", "qtriv", "querv", "Qoi", "requerv", " qIV"], "tos": ["ttos", "toS", "Toss", "ptos", "ttoS", "tis", "To", "xto", "xtos", "tOS", "tobi", "Tops", "ptops", "Tobi", "to", "xtOS", "ptoss", "ptotes", "toss", "ptis", "ptobi", "tto", "pto", "ttros", "ttotes", " tis", "Tros", "tros", "TOS", "ttoss", "xtoS", "ttOS", "Totes", "ptros", " tobi", "tops", "totes", "ttops", "Tis", "Tos", " tops", "ToS"]}}
{"project": "FFmpeg", "commit_id": "a443a2530d00b7019269202ac0f5ca8ba0a021c7", "target": 1, "func": "static int vmd_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVStream *st;\n\n    unsigned int toc_offset;\n\n    unsigned char *raw_frame_table;\n\n    int raw_frame_table_size;\n\n    offset_t current_offset;\n\n    int i, j;\n\n    unsigned int total_frames;\n\n    int64_t video_pts_inc = 0;\n\n    int64_t current_video_pts = 0;\n\n    unsigned char chunk[BYTES_PER_FRAME_RECORD];\n\n    int lastframe = 0;\n\n\n\n    /* fetch the main header, including the 2 header length bytes */\n\n    url_fseek(pb, 0, SEEK_SET);\n\n    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n\n        return AVERROR_IO;\n\n\n\n    vmd->audio_sample_counter = 0;\n\n    vmd->audio_frame_divisor = 1;\n\n    vmd->audio_block_align = 1;\n\n\n\n    /* start up the decoders */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR_NOMEM;\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    vmd->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_VMDVIDEO;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = LE_16(&vmd->vmd_header[12]);\n\n    st->codec->height = LE_16(&vmd->vmd_header[14]);\n\n    st->codec->time_base.num = 1;\n\n    st->codec->time_base.den = 10;\n\n    st->codec->extradata_size = VMD_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n\n\n\n    /* if sample rate is 0, assume no audio */\n\n    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n\n    if (vmd->sample_rate) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR_NOMEM;\n\n        av_set_pts_info(st, 33, 1, 90000);\n\n        vmd->audio_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = CODEC_ID_VMDAUDIO;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;\n\n        st->codec->sample_rate = vmd->sample_rate;\n\n        st->codec->block_align = vmd->audio_block_align =\n\n            LE_16(&vmd->vmd_header[806]);\n\n        if (st->codec->block_align & 0x8000) {\n\n            st->codec->bits_per_sample = 16;\n\n            st->codec->block_align = -(st->codec->block_align - 0x10000);\n\n            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);\n\n        } else {\n\n            st->codec->bits_per_sample = 8;\n\n\n        st->codec->bit_rate = st->codec->sample_rate *\n\n            st->codec->bits_per_sample * st->codec->channels;\n\n\n\n        /* for calculating pts */\n\n        vmd->audio_frame_divisor = st->codec->channels;\n\n\n\n        video_pts_inc = 90000;\n\n        video_pts_inc *= st->codec->block_align;\n\n        video_pts_inc /= st->codec->sample_rate;\n\n        video_pts_inc /= st->codec->channels;\n\n    } else {\n\n        /* if no audio, assume 10 frames/second */\n\n        video_pts_inc = 90000 / 10;\n\n\n\n\n    toc_offset = LE_32(&vmd->vmd_header[812]);\n\n    vmd->frame_count = LE_16(&vmd->vmd_header[6]);\n\n    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);\n\n    url_fseek(pb, toc_offset, SEEK_SET);\n\n\n\n    raw_frame_table = NULL;\n\n    vmd->frame_table = NULL;\n\n    raw_frame_table_size = vmd->frame_count * 6;\n\n    raw_frame_table = av_malloc(raw_frame_table_size);\n\n\n\n\n\n    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));\n\n    if (!raw_frame_table || !vmd->frame_table) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_NOMEM;\n\n\n    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=\n\n        raw_frame_table_size) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n", "idx": 15094, "substitutes": {"s": ["sys", "ses", "m", "service", "sg", "bs", "fs", "rs", "a", "g", "cs", "qs", "S", "sp", "os", "si", "es", "sq", "v", "ps", "ss", "an", "p", "e", "sec", "se", "sd", "sb", "b", "f", "gs", "spec", "c", "ns", "sc", "ssl", "sl", "services", "ds", "sa", "su", "ls", "ts", "ctx", "sts", "ks"], "ap": ["as", "amp", "pac", "jp", "mp", "sp", "pp", "aps", "bp", "np", "pa", "pl", "op", "arp", "au", "wp", "att", "am", "AP", "ac", "ams", "cap", "attr", "pi", " p", "cp", "ar", "al", "tp"], "vmd": ["gmand", "ldm", "ncmd", "vcmad", "Vmd", "lmm", "svmad", "ervmad", "lMD", "ervdoc", " vcd", "ivmd", "evdm", "svda", "Vdi", "ervmm", "ivmm", " vmm", "evcmd", "ervcmd", " vmand", "vvcmd", " vMD", "svMD", "gcd", "svcmd", "vvmand", "tmt", "vdd", "Vcmd", "vcd", "ivmad", "Vdm", "vvcd", "tmd", " vdi", "svmd", "gmd", "ervda", "ervmd", "nmt", "Vmm", "vdm", "nmd", "varimd", "varimm", "ndoc", "VMD", "vdi", "ivMD", "tmad", " vcmd", "vcdoc", "lcmd", "evMD", "vcmd", "ldd", "varidm", " vmad", "ldi", " vdm", "tcmd", "svdm", "nmad", "ivda", "vccmd", "vdoc", "svmm", "varicmd", "evmm", "vMD", "vmm", "vda", "vmand", "lmd", " vmt", "gcmd", " vdd", "vmad", "vmt", "vvmd", "evmd", "Vdd", "Vmad"], "pb": ["uc", "bc", "ob", "tmp", "bs", "pc", "mp", "fb", "uf", "prot", "ub", "pg", "orb", "hub", "lp", "pp", "buffer", "fp", "mb", "platform", "bp", "summary", "ba", "p", "ib", "bm", "rb", "pa", "pl", "sb", "b", "wb", "buf", "sf", "bf", "gb", "wp", "bh", "ab", "pm", "parser", "bps", "lab", "cb", "eb", "rob", "PB", "dp", "cp", "cpp", "abb", "db", "lb", "ppa", "fc", "ctx", "asm"], "st": ["sta", "art", "sth", "str", "nd", "ct", "obj", "ST", "stand", "end", "sn", "sc", "stim", "sl", "ist", "dr", "stress", "stable", "ft", "d", "t", "sr", "ld", "fr", "irst", "mt", "kt", "sf", "inst", "th", "ast", "sa", "stack", "rd", "td", "sp", "sw", "tt", "stage", "sec", "sb", "sd", "est", "nt", "rt", "sh", "bl", "post", "cl", "bt", "put", "l", "stream", "pt", "ust", "ste", "std", "ss", "cr", "set", "se", "lt", "St", "rest", "src", "ts", "gest", "et", "sett", "sts", "ost", "start"], "toc_offset": [" orig_slice", "tocamaddress", "tocamslice", "tocamsource", "toc_address", " orig_source", "toc_slice", "toc_source", "toc67slice", " orig_offset", "toc67offset", "toc67source", "toc67address", "tocamoffset", " orig_address"], "raw_frame_table": ["raw_frames_size", "raw_frame_buffer", "raw_frames_buffer", "raw_frames_table", "raw_frame_size", "raw_frames_count", "raw_frame_count"], "raw_frame_table_size": ["raw_frame_family_len", "raw_frame_family_size", "raw_frame_table_len", "raw_frame_family_SIZE", "raw_frame_table_SIZE"], "current_offset": ["currentalposition", "load_table", "load_position", "load_offset", "loadaloffset", "current_object", "currentalobject", "loadalobject", "loadalposition", "current_position", "currentaloffset", "loadaltable", "currentaltable", "current_table", "load_object"], "i": ["ui", "m", "I", "d", "ai", "l", "io", "ci", "h", "x", "ii", "u", "z", "ind", "p", "e", "mi", "b", "n", "f", "c", "pi", "y", "in", "index", "start"], "j": ["adj", "m", "aj", "jp", "jump", "l", "position", "ii", "v", "o", "step", "col", "obj", "z", "ind", "p", "k", "b", "n", "f", "ji", "q", "r", "J", "pos", "ij"], "total_frames": [" total_fps", "total_cycles", " total_cycles", "total_flows", " total_flows", "total_fps"], "chunk": ["Chunk", "chblock", "Chacket", "Chblock", " chunkacket", "chunks", "charblock", "charunk", "Chunks", " chunkblock", "chacket", "charunks", "characket", " chunkunks", " chunkunk"]}}
{"project": "FFmpeg", "commit_id": "99e5a9d1ea2a61ac9429427431e5b9c2fefb76a5", "target": 0, "func": "void dsputil_init_arm(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n    int idct_algo= avctx->idct_algo;\n\n\n\n    ff_put_pixels_clamped = c->put_pixels_clamped;\n\n    ff_add_pixels_clamped = c->add_pixels_clamped;\n\n\n\n    if (avctx->lowres == 0) {\n\n        if(idct_algo == FF_IDCT_AUTO){\n\n#if   HAVE_IPP\n\n            idct_algo = FF_IDCT_IPP;\n\n#elif HAVE_NEON\n\n            idct_algo = FF_IDCT_SIMPLENEON;\n\n#elif HAVE_ARMV6\n\n            idct_algo = FF_IDCT_SIMPLEARMV6;\n\n#elif HAVE_ARMV5TE\n\n            idct_algo = FF_IDCT_SIMPLEARMV5TE;\n\n#else\n\n            idct_algo = FF_IDCT_ARM;\n\n#endif\n\n        }\n\n\n\n        if(idct_algo==FF_IDCT_ARM){\n\n            c->idct_put= j_rev_dct_ARM_put;\n\n            c->idct_add= j_rev_dct_ARM_add;\n\n            c->idct    = j_rev_dct_ARM;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARM){\n\n            c->idct_put= simple_idct_ARM_put;\n\n            c->idct_add= simple_idct_ARM_add;\n\n            c->idct    = simple_idct_ARM;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#if HAVE_ARMV6\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV6){\n\n            c->idct_put= ff_simple_idct_put_armv6;\n\n            c->idct_add= ff_simple_idct_add_armv6;\n\n            c->idct    = ff_simple_idct_armv6;\n\n            c->idct_permutation_type= FF_LIBMPEG2_IDCT_PERM;\n\n#endif\n\n#if HAVE_ARMV5TE\n\n        } else if (idct_algo==FF_IDCT_SIMPLEARMV5TE){\n\n            c->idct_put= simple_idct_put_armv5te;\n\n            c->idct_add= simple_idct_add_armv5te;\n\n            c->idct    = simple_idct_armv5te;\n\n            c->idct_permutation_type = FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_IPP\n\n        } else if (idct_algo==FF_IDCT_IPP){\n\n            c->idct_put= simple_idct_ipp_put;\n\n            c->idct_add= simple_idct_ipp_add;\n\n            c->idct    = simple_idct_ipp;\n\n            c->idct_permutation_type= FF_NO_IDCT_PERM;\n\n#endif\n\n#if HAVE_NEON\n\n        } else if (idct_algo==FF_IDCT_SIMPLENEON){\n\n            c->idct_put= ff_simple_idct_put_neon;\n\n            c->idct_add= ff_simple_idct_add_neon;\n\n            c->idct    = ff_simple_idct_neon;\n\n            c->idct_permutation_type = FF_PARTTRANS_IDCT_PERM;\n\n        } else if ((CONFIG_VP3_DECODER || CONFIG_VP5_DECODER || CONFIG_VP6_DECODER || CONFIG_THEORA_DECODER) &&\n\n                   idct_algo==FF_IDCT_VP3){\n\n            c->idct_put= ff_vp3_idct_put_neon;\n\n            c->idct_add= ff_vp3_idct_add_neon;\n\n            c->idct    = ff_vp3_idct_neon;\n\n            c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n#endif\n\n        }\n\n    }\n\n\n\n    c->put_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_pixels_tab[0][1] = put_pixels16_x2_arm;\n\n    c->put_pixels_tab[0][2] = put_pixels16_y2_arm;\n\n    c->put_pixels_tab[0][3] = put_pixels16_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[0][0] = put_pixels16_arm;\n\n    c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_arm;\n\n    c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_arm;\n\n    c->put_no_rnd_pixels_tab[0][3] = put_no_rnd_pixels16_xy2_arm;\n\n    c->put_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_pixels_tab[1][1] = put_pixels8_x2_arm;\n\n    c->put_pixels_tab[1][2] = put_pixels8_y2_arm;\n\n    c->put_pixels_tab[1][3] = put_pixels8_xy2_arm;\n\n    c->put_no_rnd_pixels_tab[1][0] = put_pixels8_arm;\n\n    c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_arm;\n\n    c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_arm;\n\n    c->put_no_rnd_pixels_tab[1][3] = put_no_rnd_pixels8_xy2_arm;\n\n\n\n#if HAVE_ARMV5TE\n\n    c->prefetch = ff_prefetch_arm;\n\n#endif\n\n\n\n#if HAVE_IWMMXT\n\n    dsputil_init_iwmmxt(c, avctx);\n\n#endif\n\n#if HAVE_ARMVFP\n\n    ff_float_init_arm_vfp(c, avctx);\n\n#endif\n\n#if HAVE_NEON\n\n    ff_dsputil_init_neon(c, avctx);\n\n#endif\n\n}\n", "idx": 15106, "substitutes": {"c": ["call", "context", "ch", "mc", "uc", "bc", "cm", "d", "ca", "cv", "enc", "t", "cc", "pc", "rc", "l", "config", "C", "lc", "cs", "ci", "ctrl", "g", "cit", "h", "cy", "cmp", "con", "ct", "v", "conf", "conn", "cr", "cd", "u", "z", "rec", "p", "e", "nc", "k", "can", "cus", "tc", "co", "f", "cu", "dc", "ac", "sc", "ce", "cont", "cf", "ic", "coll", "cp", "com", "r", "vc", "cache", "ec", "cur", "fc", "cl", "ctx"], "avctx": ["afcca", "afconn", "navcca", "Avcontext", "abcontext", "abconn", "AVcmp", "Avctx", "avcmp", "abcmp", "navcmp", "AVcontext", "vercontext", "navctx", "afcmp", "AVconn", "AVctrl", "verconn", "afcontext", "AVcca", " avcontext", "vercmp", "avcontext", "verctx", "avconn", "afctx", "Avctrl", " avconn", "AVctx", "navcontext", "Avconn", "avctrl", "abctx", " avctrl", "avcca"]}}
{"project": "FFmpeg", "commit_id": "7a4f74eed51f914e9bbfebaffd4a92ac6791f819", "target": 0, "func": "av_cold void ff_h264_free_context(H264Context *h)\n\n{\n\n    int i;\n\n\n\n    ff_h264_free_tables(h);\n\n\n\n    if (h->DPB) {\n\n        for (i = 0; i < H264_MAX_PICTURE_COUNT; i++)\n\n            ff_h264_unref_picture(h, &h->DPB[i]);\n\n        av_freep(&h->DPB);\n\n    }\n\n\n\n    h->cur_pic_ptr = NULL;\n\n\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        av_freep(&h->slice_ctx[i].rbsp_buffer);\n\n    av_freep(&h->slice_ctx);\n\n    h->nb_slice_ctx = 0;\n\n\n\n    for (i = 0; i < MAX_SPS_COUNT; i++)\n\n        av_freep(h->sps_buffers + i);\n\n\n\n    for (i = 0; i < MAX_PPS_COUNT; i++)\n\n        av_freep(h->pps_buffers + i);\n\n}\n", "idx": 15108, "substitutes": {"h": ["hi", "m", "context", "hp", "hl", "ssh", "ha", "ih", "hr", "t", "FH", "oh", "d", "l", "home", "ah", "g", "beh", "hs", "this", "x", "gh", "v", "adh", "rh", "o", "uh", "w", "hh", "u", "p", "e", "he", "eh", "http", "k", "b", "n", "f", "hm", "html", "bh", "c", "ch", "ht", "q", "r", "H", "sh", "hd", "host", "work", "him", "hist", "ph", "header", "hw", "ctx"], "i": ["hi", "qi", "it", "ui", "m", "slice", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "mu", "ci", "g", "lc", "di", "x", "si", "ie", "init", "available", "ii", "uri", "v", "vi", "o", "yi", "u", "z", "p", "e", "fi", "info", "mi", "li", "k", "ix", "b", "multi", "j", "abi", "n", "f", "phi", "ti", "ip", "c", "eni", "ji", "pi", "cli", "bi", "r", "ri", "zi", "y", "in", "index"]}}
{"project": "qemu", "commit_id": "4a1cba3802554a3b077d436002519ff1fb0c18bf", "target": 1, "func": "bool aio_poll(AioContext *ctx, bool blocking)\n\n{\n\n    AioHandler *node;\n\n    int i, ret;\n\n    bool progress;\n\n    int64_t timeout;\n\n\n\n    aio_context_acquire(ctx);\n\n    progress = false;\n\n\n\n    /* aio_notify can avoid the expensive event_notifier_set if\n\n     * everything (file descriptors, bottom halves, timers) will\n\n     * be re-evaluated before the next blocking poll().  This is\n\n     * already true when aio_poll is called with blocking == false;\n\n     * if blocking == true, it is only true after poll() returns,\n\n     * so disable the optimization now.\n\n     */\n\n    if (blocking) {\n\n        atomic_add(&ctx->notify_me, 2);\n\n    }\n\n\n\n    ctx->walking_handlers++;\n\n\n\n    assert(npfd == 0);\n\n\n\n    /* fill pollfds */\n\n\n\n    if (!aio_epoll_enabled(ctx)) {\n\n        QLIST_FOREACH(node, &ctx->aio_handlers, node) {\n\n            if (!node->deleted && node->pfd.events\n\n                && aio_node_check(ctx, node->is_external)) {\n\n                add_pollfd(node);\n\n            }\n\n        }\n\n    }\n\n\n\n    timeout = blocking ? aio_compute_timeout(ctx) : 0;\n\n\n\n    /* wait until next event */\n\n    if (timeout) {\n\n        aio_context_release(ctx);\n\n    }\n\n    if (aio_epoll_check_poll(ctx, pollfds, npfd, timeout)) {\n\n        AioHandler epoll_handler;\n\n\n\n        epoll_handler.pfd.fd = ctx->epollfd;\n\n        epoll_handler.pfd.events = G_IO_IN | G_IO_OUT | G_IO_HUP | G_IO_ERR;\n\n        npfd = 0;\n\n        add_pollfd(&epoll_handler);\n\n        ret = aio_epoll(ctx, pollfds, npfd, timeout);\n\n    } else  {\n\n        ret = qemu_poll_ns(pollfds, npfd, timeout);\n\n    }\n\n    if (blocking) {\n\n        atomic_sub(&ctx->notify_me, 2);\n\n    }\n\n    if (timeout) {\n\n        aio_context_acquire(ctx);\n\n    }\n\n\n\n    aio_notify_accept(ctx);\n\n\n\n    /* if we have any readable fds, dispatch event */\n\n    if (ret > 0) {\n\n        for (i = 0; i < npfd; i++) {\n\n            nodes[i]->pfd.revents = pollfds[i].revents;\n\n        }\n\n    }\n\n\n\n    npfd = 0;\n\n    ctx->walking_handlers--;\n\n\n\n    /* Run dispatch even if there were no readable fds to run timers */\n\n    if (aio_dispatch(ctx, ret > 0)) {\n\n        progress = true;\n\n    }\n\n\n\n    aio_context_release(ctx);\n\n\n\n    return progress;\n\n}\n", "idx": 15115, "substitutes": {"ctx": ["context", "ch", "tx", "cm", "bc", "pkg", "qa", "cv", "ca", "sync", "config", "pc", "cc", "cdn", "ctr", "utils", "connection", "Context", "lc", "ctrl", "cs", "ci", "req", "conv", "section", "cn", "cmp", "scope", "loc", "ct", "cgi", "conn", "client", "kw", "cr", "cd", "handler", "cli", "nc", "kt", "tc", "component", "cus", "ck", "qt", "acl", "cfg", "c", "cca", "xs", "cu", "dc", "anc", "cb", "cas", "sci", "sc", "ce", "cmd", "cf", "cp", "exec", "kb", "vc", "xc", "src", "pai", "css", "git", "hw", "cl"], "blocking": ["channel", "remote", "blocks", "checking", "forcing", "using", "bc", "complete", "queue", "sync", "random", "latest", "holding", "binary", "locking", "period", "poll", "training", "regular", "boxing", "pool", "buffer", "full", "starting", "writing", "locked", "binding", "balanced", "testing", "consuming", "working", "moving", "background", "interrupted", "linear", "cli", "running", "calling", "negative", "length", "quiet", "padding", "block", "killing", "clock", "ssl", "loop", "rolling", "broad", "joining", "ocking", "changing", "ing", "rising", "lock", "prefix", "loading", "always"], "node": ["path", "remote", "call", "context", "root", "self", "edge", "part", "sync", "enc", "worker", "config", "native", "id", "cdn", "object", "child", "local", "nn", "connection", "name", "source", "event", "hub", "null", "missing", "ref", "full", "live", "fn", "server", "master", "slave", "package", "peer", "tree", "client", "nw", "document", "loader", "view", "plugin", "instance", "handler", "leaf", "component", "n", "none", "parent", "query", "global", "route", "cmd", "load", "host", "Node", "content", "num", "post", "index", "callback"], "i": ["hi", "qi", "it", "ui", "m", "part", "I", "t", "ni", "ai", "xi", "id", "iu", "val", "ini", "gi", "oi", "io", "my", "l", "ci", "image", "h", "x", "di", "si", "ie", "ii", "uri", "v", "o", "ind", "p", "e", "fi", "mi", "li", "k", "ix", "b", "abi", "j", "phi", "f", "n", "ti", "ip", "c", "eni", "end", "inner", "pi", "out", "you", "bi", "ri", "y", "in", "index", "start"], "ret": ["alt", "ft", "rev", "part", "reply", "rc", "val", "back", "pt", "def", "rets", "fun", "status", "ref", "sr", "arg", "hash", "full", "lit", "det", "xt", "error", "job", "feat", "pass", "grad", "obj", "ut", "mem", "bot", "success", "Ret", "count", "result", "att", "cat", "arr", "nt", "re", "rt", "resp", "rep", "pat", "RET", "res", "reg", "num", "lock", "flag", "len", "bit", "err"], "progress": ["show", "path", "action", "remote", "call", "partial", "done", "sort", "part", "complete", "reply", "dist", "queue", "rc", "val", "current", "act", "event", "status", "update", "live", "full", "quick", "error", "step", "bar", "grad", "active", "p", "move", "success", "data", "wait", "callback", "mode", "result", "stat", "skip", " status", "grade", "recent", "close", "state", "Progress", " result", "file", "results", " success", " error", "process", "debug", "track", "forward", "resp", "exec", "content", "push", "addr", "len", "proc", "err"], "timeout": ["alt", "remote", "call", "course", "slot", "reply", "service", "sync", "val", "confirmed", "io", "disabled", "connection", "period", "range", "event", "pool", "option", "unit", "missing", "Timeout", "live", "until", "error", "server", "table", "limit", "client", "conn", "always", "term", "size", "time", "temp", "wait", "socket", "interrupted", "tc", "nil", "qt", "length", "none", "timer", "parent", "scroll", "block", "type", "offset", "target", "nt", "ssl", "function", "security", "out", "all", "never", "command", "duration", "cache", "cookie", "cycle", "lock", "window", "delay", "span", "len", "sleep", "poll"], "walking_handlers": ["walking_hostries", "walking_handlerl", "walking_childles", "walking_handleles", "walking_handl", "walking_hostler", "walking_handlerlers", "walking_handlerles", "walking_handlerers", "walking_hosters", "walking_childler", "walking_counters", "walking_countlers", "walking_handlerler", "walking_countries", "walking_handleler", "walking_childlers", "walking_handler", "walking_handlel", "walking_countler", "walking_handries", "walking_handers", "walking_childl", "walking_handlelers", "walking_hostlers", "walking_handles", "walking_handlerries"], "epoll_handler": ["epoll_manager", "epollo_function", "epole_function", "epollerhand", "epolledpointer", "epoll_connection", "epollo_handle", "epoll_object", "epole_folder", "eprot_hand", "epoll_function", "epoll_pointer", "eprot_handle", "epollinghandler", "epolledconnection", "epollo_handler", "eprot_handler", "epollingfunction", "epoll_hand", "epollo_child", "epoll_folder", "epollermanager", "epollerhandler", "epole_handler", "epoll_child", "epole_object", "epollingchild", "epoll_handle", "eprot_connection", "epolledmanager", "eprot_pointer", "epolledhandler", "epollerhandle", "eprot_manager", "epollinghandle"]}}
{"project": "FFmpeg", "commit_id": "252c0bfdc014c1fb6ad4fe06242c7beca58a6b41", "target": 1, "func": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}", "idx": 15124, "substitutes": {"s": ["m", "ses", "d", "t", "fs", "i", "caps", "cs", "g", "S", "js", "session", "v", "ss", "o", "w", "ms", "p", "e", "b", "n", "f", "c", "ns", "ssl", "r", "services", "ts"], "pic": [" pc", "proc", " fn", "fs", "pc", "pins", "image", "Pic", "arg", "avi", "fn", "o", "cons", "oc", "p", "img", "fi", "mi", "pa", "pict", "pin", "ac", " p", "ic", "mac", "fc", "in"]}}
{"project": "FFmpeg", "commit_id": "d1a58afb95f68c5375b4a7556317d835108509ed", "target": 1, "func": "static int latm_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    PutBitContext bs;\n\n    int i, len;\n\n    uint8_t loas_header[] = \"\\x56\\xe0\\x00\";\n\n    uint8_t *buf = NULL;\n\n\n\n    if (s->streams[0]->codec->codec_id == CODEC_ID_AAC_LATM)\n\n        return ff_raw_write_packet(s, pkt);\n\n\n\n    if (pkt->size > 2 && pkt->data[0] == 0xff && (pkt->data[1] >> 4) == 0xf) {\n\n        av_log(s, AV_LOG_ERROR, \"ADTS header detected - ADTS will not be incorrectly muxed into LATM\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (pkt->size > 0x1fff)\n\n        goto too_large;\n\n\n\n    buf = av_malloc(pkt->size+1024);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    init_put_bits(&bs, buf, pkt->size+1024);\n\n\n\n    latm_write_frame_header(s, &bs);\n\n\n\n    /* PayloadLengthInfo() */\n\n    for (i = 0; i <= pkt->size-255; i+=255)\n\n        put_bits(&bs, 8, 255);\n\n\n\n    put_bits(&bs, 8, pkt->size-i);\n\n\n\n    /* The LATM payload is written unaligned */\n\n\n\n    /* PayloadMux() */\n\n    if (pkt->size && (pkt->data[0] & 0xe1) == 0x81) {\n\n        // Convert byte-aligned DSE to non-aligned.\n\n        // Due to the input format encoding we know that\n\n        // it is naturally byte-aligned in the input stream,\n\n        // so there are no padding bits to account for.\n\n        // To avoid having to add padding bits and rearrange\n\n        // the whole stream we just remove the byte-align flag.\n\n        // This allows us to remux our FATE AAC samples into latm\n\n        // files that are still playable with minimal effort.\n\n        put_bits(&bs, 8, pkt->data[0] & 0xfe);\n\n        avpriv_copy_bits(&bs, pkt->data + 1, 8*pkt->size - 8);\n\n    } else\n\n        avpriv_copy_bits(&bs, pkt->data, 8*pkt->size);\n\n\n\n    avpriv_align_put_bits(&bs);\n\n    flush_put_bits(&bs);\n\n\n\n    len = put_bits_count(&bs) >> 3;\n\n\n\n    if (len > 0x1fff)\n\n        goto too_large;\n\n\n\n    loas_header[1] |= (len >> 8) & 0x1f;\n\n    loas_header[2] |= len & 0xff;\n\n\n\n    avio_write(pb, loas_header, 3);\n\n    avio_write(pb, buf, len);\n\n\n\n    av_free(buf);\n\n\n\n    return 0;\n\n\n\ntoo_large:\n\n    av_log(s, AV_LOG_ERROR, \"LATM packet size larger than maximum size 0x1fff\\n\");\n\n    av_free(buf);\n\n    return AVERROR_INVALIDDATA;\n\n}\n", "idx": 15125, "substitutes": {"s": ["south", "sys", "ses", "self", "bis", "service", "t", "d", "sg", "sync", "fs", "sym", "ches", "g", "cs", "qs", "S", "os", "sets", "js", "si", "sq", "session", "server", "v", "conf", "ss", "ps", "client", "o", "w", "u", "p", "e", "plugins", "socket", "http", "data", "b", "sf", "sb", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "stats", "sc", "ssl", "sci", "sv", "sl", "ops", "services", "ds", "r", "sa", "su", "ls", "ubs", "space", "fts", "us", "support", "ts", "ks", "aws"], "pkt": ["spkt", "pet", "Pant", "pct", "pett", "facket", "ipet", "perkt", "spct", "cpkg", " pct", "fet", "ipcht", "Pct", "jacket", "spacket", "spelt", "pwk", "bqt", "pqt", "ppacket", " pant", "periece", "qcht", "psth", "pskt", "qacket", "Pet", "npkt", "bkt", " pqt", "ppelt", "fnt", " piece", "pcht", "npet", "npelt", "perwk", "jkt", "Piece", "cpet", "fkt", "Pkt", "Pcht", " pkg", "cpant", "Psth", "het", "macket", "Pwk", "mkt", "spnt", " pdt", "chcht", "hkt", " pet", " pnt", " pwk", " psth", "psct", "Pnt", "Pqt", "packet", "pant", "npacket", "ppkt", "hett", "backet", "jcht", "ppcht", " pett", "peracket", "fsth", "psdt", "Pett", "chet", "pnt", "bet", "tpacket", "fant", "chacket", "ipkt", "pelt", "piece", "pkg", "melt", "Packet", "chkt", "cpkt", "qkt", "tpelt", "qant", "pdt", "tpkt", "Pelt", "jelt", "met", "Pkg", "psacket", "spwk", "hacket", " pelt", "tpet", " pcht", "ipacket", "Pdt", "cpacket", " packet"], "pb": ["proc", "typ", "ses", "bc", "cv", "pc", "jp", "vp", "mp", "fb", "uf", "prot", "lc", "ub", "pg", "py", "lp", "fp", "ps", "platform", "bp", "pd", "np", "obj", "summary", "p", "rb", "bm", "plugins", "pl", "pa", "sb", "tc", "wb", "wp", "gb", "bh", "ab", "pm", "bps", "cb", "PB", "dp", "pro", "cpp", "db", "lb", "ppa", "fc", "tp", "ctx"], "bs": [" bc", "blocks", "tx", "bc", "qs", "bytes", "js", "boxes", "br", "ps", " cx", "base", "bf", "lines", "bps", "cb", "bas", "las", "bis", "fs", "ins", "g", "cs", " bos", "nos", "bus", "bp", "b", "bits", "ns", " fs", "outs", "bugs", "bi", "lb", "iss", "vals", "ks", "bid", "lbs", "BS", "pc", "fb", "os", "obs", "sb", "gb", "lins", "bu", "ls", "pos", "bl", "ctx", "BT", "ses", "bn", "BC", "its", "ros", "ss", "cks", "Bs", " ss", "gs", "bes", "ds", "css", "bos", "ts", "ubs", "us", "vs"], "i": ["hi", "qi", "ui", "adi", "I", "ai", "ni", "xi", "id", "ini", "iu", "gi", "inf", "io", "ci", "ki", "di", "x", "si", "ie", "ii", "uri", "col", "u", "ind", "z", "p", "e", "mini", "info", "fi", "mi", "li", "ix", "base", "multi", "j", "count", "b", "f", "phi", "ti", "line", "abi", "ip", "c", "is", "type", "ji", "pi", "field", "ri", "ami", "zi", "y", "in", "index", "start"], "len": ["vec", "en", "bin", "rev", "part", "lin", "non", "fl", "Len", "ni", "val", "lon", "l", "lan", "split", "lc", "fun", "low", "dl", "lang", "lit", "fat", "fn", "ld", "limit", "dy", "z", "size", "ll", "la", "lif", "fin", "lt", "li", "min", "length", "n", "lf", "ler", "count", "list", "ann", "line", "il", "lu", "nt", "body", "elt", "sl", "le", "all", "pos", "num", "el", "span", "ln", "lim"], "loas_header": ["loas2headers", "loas___gender", "loam_layer", "loas___header", "loas__table", "loac_table", "loas2layer", "loam_data", "loas___layer", "end", "loas_headers", "loas2gender", "loas__master", "loas_master", "loas__header", "loam_dr", "loas_dr", "at", "loam_header", "loac_headers", "r", "loas___headers", "loas_table", "loac_gender", "loas__layer", "loac_master", "loac_layer", "loas_gender", "_", "loas2header", "loac_header", "loas_layer", "loas_data", "all"], "buf": ["port", "vec", "ff", "pkg", "uc", "bc", "queue", "fd", "cv", "bid", "fl", "batch", "rc", "config", "bb", "fb", "bn", "home", "uf", "pool", "buffer", "lit", "fp", "bag", "loc", "v", "br", "buff", "feat", "rb", "data", "wb", "b", "box", "Buffer", "Buff", "block", "cb", "bo", "text", "cmd", "cf", "aux", "cache", "src", "seq", "cur", "bl", "ctx", "alloc", "fw"]}}
{"project": "qemu", "commit_id": "9e559533bd825a3e371497875576137a8586c831", "target": 1, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = g_malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        g_free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n\n    g_free(ctx);\n\n}", "idx": 15132, "substitutes": {"opaque": [" opaques", "OPacre", "Opaque", "ipaques", "opatile", "opacre", "obatile", "opac", "obacity", "opaques", "obaque", "OPaques", "copaques", "ipacity", "opacity", "ipaque", "OPac", "Opacre", "Opaques", "copac", "copaque", " opacity", "copacre", "OPaque", "obaques", "ipatile", " opatile", "Opac"], "ret": ["alt", "ft", "rev", "reply", "t", "inter", "rc", "id", "val", "back", "pt", "rets", "gt", "fun", "sr", "pret", "xt", "det", "ref", "lit", "mt", "mem", "fin", "desc", "ext", "Ret", "result", " RET", "try", " Ret", "nt", "re", "rt", "sur", "rot", "pat", "RET", "res", "num", "cur", "reg", "flag", "len", "red"], "ctx": [" context", "tx", "bc", "wcs", "cmp", "fp", "loc", "np", "obj", "handler", "c", "cb", "cas", "sc", "cp", "command", "fc", "context", "cam", "sync", "cc", "gc", "lc", "conv", "cn", "cgi", "fn", "client", "lib", "grad", "instance", "six", "anc", "exec", "kb", "xc", "support", "git", "cci", "alloc", "path", "sys", "cv", "ca", "config", "pc", "connection", "ci", "wx", "cpu", "scope", "conn", "kw", "rx", "nc", "tc", "qt", "cfg", "gpu", "cf", "que", "prefix", "hw", "cl", "fw", "pkg", "cm", "qa", "unc", "jp", "utils", "Context", "ctrl", "sq", "p", "cli", "component", "cus", "parent", "wp", "cca", "crit", "cu", "sci", "general", "cmd", "vc", "qq", "css"], "t2": ["p2", "dt8", "T62", "p0", "dt6", "T2", "dt2", " t0", "t4", "t1", " t6", "p1", "d2", "dt62", "T0", "dt4", "T1", "T8", "d1", "T6", " t62", "T4", "t8", "d8", " t1", "t62", " t8", "p8", " t4", "t0", "dt1", "d0", "t6"], "cmp_buf": ["cmp2buffer", "cmp_uf", "cmp_cb", "cmp_bc", "cmp2uf", "cmp2cap", "mp_buf", "comp_buff", "comp_bc", "mp_cb", "mp_rb", "mp_buff", "comp_buffer", "comp_uf", "cmp_buff", "cmp_cap", "cmp2buf", "mp_buffer", "comp_buf", "mp_uf", "comp_cap", "cmp_rb", "cmp_buffer"]}}
{"project": "FFmpeg", "commit_id": "3a54c221d574ec944db1eddf9df895808f32bf9e", "target": 1, "func": "static const char *read_ts(const char *buf, int *ts_start, int *ts_end,\n\n                           int *x1, int *y1, int *x2, int *y2)\n\n{\n\n    int i, hs, ms, ss, he, me, se;\n\n\n\n    for (i=0; i<2; i++) {\n\n        /* try to read timestamps in either the first or second line */\n\n        int c = sscanf(buf, \"%d:%2d:%2d%*1[,.]%3d --> %d:%2d:%2d%*1[,.]%3d\"\n\n                       \"%*[ ]X1:%u X2:%u Y1:%u Y2:%u\",\n\n                       &hs, &ms, &ss, ts_start, &he, &me, &se, ts_end,\n\n                       x1, x2, y1, y2);\n\n        buf += strcspn(buf, \"\\n\") + 1;\n\n        if (c >= 8) {\n\n            *ts_start = 100*(ss + 60*(ms + 60*hs)) + *ts_start/10;\n\n            *ts_end   = 100*(se + 60*(me + 60*he)) + *ts_end  /10;\n\n            return buf;\n\n        }\n\n    }\n\n    return NULL;\n\n}\n", "idx": 15133, "substitutes": {"buf": ["bt", "func", "runner", "vec", "port", "font", "context", "ff", "bc", "queue", "fd", "cv", "input", "tmp", "rc", "config", "fb", "orig", "binary", "bd", "msg", "uf", "conv", "buffer", "bag", "fp", "br", "buff", "output", "brace", "img", "rb", "bed", "fi", "pb", "data", "b", "sb", "Buffer", "wb", "Buff", "f", "result", "ab", "bh", "bu", "fe", "feed", "cat", "bind", "cb", "cas", "text", "bg", "offset", "cmd", "cf", "db", "cache", "src", "seq", "cur", "header", "ctx"], "ts_start": ["times_size", "tsprecur", "ts_max", "times_base", "ts_cur", "ats_end", "ats_get", "tsprenext", "ts__max", "times_end", "times_cur", "ts__end", "tsxnext", "ats_stop", "tsxstart", "ts_size", "ts__size", "ts_base", "tspreend", "tsprestart", "times_next", "tsxbase", "ats_start", "ts__start", "ts_stop", "tsxend", "ts_get", "times_max", "times_start", "ts_next"], "ts_end": ["tsacend", "tips_end", "ts_order", "tsacstop", "ts_ends", "tips_max", "ts___end", "tsacstart", " ts_ending", "ts_ending", "ts___send", "ts_send", "tips_start", "ts_max", "tips_order", "ats_stop", "ts___start", "tsacending", "ts_offset", " ts_ends", "ats_end", "times_end", "ats_ending", "ts___offset", "ts_stop", "times_send", "ats_start", "times_start", "times_offset"], "x1": ["y4", "X1", " x0", " x4", "x0", "w1", "w0", "w4", "y0", "w2", "x4", "X0", "X2"], "y1": ["y4", "Y2", " y4", "Y3", " y3", "Y1", "y3", "x0", "Y0", " y0", "y0", "Y4", "x4", "x3"], "x2": ["y4", "y5", "X1", "ix2", "y3", " x4", "ytwo", "X4", "x5", "xtwo", " x3", "ix3", "X5", " x5", "ixtwo", "ix1", " xtwo", "x4", "x3", "X2"], "y2": ["Y2", "Y3", " y3", "y5", "Y1", "vy1", "ya1", "y3", "x0", "vy2", "ya5", "ya2", "Y0", " y0", "y0", "vy5", "Y5", "x3"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "id", "l", "iu", "gi", "ini", "oi", "ci", "x", "di", "si", "ie", "init", "ii", "v", "o", "u", "ind", "p", "e", "info", "mi", "li", "b", "ix", "j", "count", "n", "f", "phi", "ti", "c", "eni", "ji", "pi", "chi", "bi", "ri", "ami", "zi", "in", "index", "start"], "hs": ["hes", "ems", "hi", "hp", "wh", "ys", "hem", "HS", "rs", "cs", "qs", "h", "sq", "hel", "ps", "hh", "His", "s", "ens", "her", "gs", "hm", "ns", "xs", "hops", "ph", "ht", "ds", "sh", "his", "css", "ls", "hop", "ts", "hess", "ims", "vs", "ks"], "ms": ["MS", "ems", "sem", "m", "mc", "ses", "ys", "Ms", "rs", "les", "cs", "mn", "js", "mm", "si", "mes", "ps", "s", "mi", "ma", "ns", "ans", "md", "ds", "sh", "ls", "ips", "pos", "ts", "us", "mys", "ims", "vs", "ks"], "ss": ["ess", "sem", "ses", "rss", "bs", "rs", "SS", "ass", "cs", "sp", "si", "es", "mm", "sq", "mes", "ps", "s", "vs", "sf", "ns", "sc", "ds", "sh", "css", "ls", "pos", "ts", "hess", "us", "st", "iss", "mys", "ks", "sy"], "he": ["ke", "hi", "hes", "che", "ge", "she", "en", "self", "wh", "ha", "He", "hy", "ih", "so", "ale", "hem", "xe", "HE", "h", "ste", "gh", "hu", "ee", "e", "s", "be", "her", "han", "hee", "fe", "pe", "hen", "spe", "het", "le", "here", "you", "sh", "we", "his", "hess", "hea"], "me": ["ke", "sem", "mis", "ge", "m", "self", "te", "ale", "hem", "my", "sp", "si", "mm", "mes", "ye", "em", "ps", "oe", "sle", "mer", "ee", "e", "mor", "Me", "mi", "min", "ma", "fe", "pe", "md", "le", "meg", "sh", "ae", "we", "sea", "ME", "pos", "ph", "mu"], "se": ["ke", "sem", "ge", "she", "ses", "te", "so", "sp", "ste", "h", "sw", "SE", "ase", "si", "sq", "ps", "sle", "ee", "s", "be", "e", "ese", "th", "fe", "pe", "ne", "spe", "sc", "ce", "sl", "le", "sh", "ae", "sa", "su", "ser", "see", "sea", "sel", "ph", "ze"]}}
{"project": "qemu", "commit_id": "3f2cbf0d1a1340bed4a63e05b044c46df93f4768", "target": 1, "func": "target_phys_addr_t cpu_get_phys_page_debug(CPUState *env, target_ulong addr)\n\n{\n\n    target_ulong pde_addr, pte_addr;\n\n    uint64_t pte;\n\n    target_phys_addr_t paddr;\n\n    uint32_t page_offset;\n\n    int page_size;\n\n\n\n    if (env->cr[4] & CR4_PAE_MASK) {\n\n        target_ulong pdpe_addr;\n\n        uint64_t pde, pdpe;\n\n\n\n#ifdef TARGET_X86_64\n\n        if (env->hflags & HF_LMA_MASK) {\n\n            uint64_t pml4e_addr, pml4e;\n\n            int32_t sext;\n\n\n\n            /* test virtual address sign extension */\n\n            sext = (int64_t)addr >> 47;\n\n            if (sext != 0 && sext != -1)\n\n                return -1;\n\n\n\n            pml4e_addr = ((env->cr[3] & ~0xfff) + (((addr >> 39) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pml4e = ldq_phys(pml4e_addr);\n\n            if (!(pml4e & PG_PRESENT_MASK))\n\n                return -1;\n\n\n\n            pdpe_addr = ((pml4e & ~0xfff) + (((addr >> 30) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        } else\n\n#endif\n\n        {\n\n            pdpe_addr = ((env->cr[3] & ~0x1f) + ((addr >> 27) & 0x18)) &\n\n                env->a20_mask;\n\n            pdpe = ldq_phys(pdpe_addr);\n\n            if (!(pdpe & PG_PRESENT_MASK))\n\n                return -1;\n\n        }\n\n\n\n        pde_addr = ((pdpe & ~0xfff) + (((addr >> 21) & 0x1ff) << 3)) &\n\n            env->a20_mask;\n\n        pde = ldq_phys(pde_addr);\n\n        if (!(pde & PG_PRESENT_MASK)) {\n\n            return -1;\n\n        }\n\n        if (pde & PG_PSE_MASK) {\n\n            /* 2 MB page */\n\n            page_size = 2048 * 1024;\n\n            pte = pde & ~( (page_size - 1) & ~0xfff); /* align to page_size */\n\n        } else {\n\n            /* 4 KB page */\n\n            pte_addr = ((pde & ~0xfff) + (((addr >> 12) & 0x1ff) << 3)) &\n\n                env->a20_mask;\n\n            page_size = 4096;\n\n            pte = ldq_phys(pte_addr);\n\n        }\n\n        if (!(pte & PG_PRESENT_MASK))\n\n            return -1;\n\n    } else {\n\n        uint32_t pde;\n\n\n\n        if (!(env->cr[0] & CR0_PG_MASK)) {\n\n            pte = addr;\n\n            page_size = 4096;\n\n        } else {\n\n            /* page directory entry */\n\n            pde_addr = ((env->cr[3] & ~0xfff) + ((addr >> 20) & 0xffc)) & env->a20_mask;\n\n            pde = ldl_phys(pde_addr);\n\n            if (!(pde & PG_PRESENT_MASK))\n\n                return -1;\n\n            if ((pde & PG_PSE_MASK) && (env->cr[4] & CR4_PSE_MASK)) {\n\n                pte = pde & ~0x003ff000; /* align to 4MB */\n\n                page_size = 4096 * 1024;\n\n            } else {\n\n                /* page directory entry */\n\n                pte_addr = ((pde & ~0xfff) + ((addr >> 10) & 0xffc)) & env->a20_mask;\n\n                pte = ldl_phys(pte_addr);\n\n                if (!(pte & PG_PRESENT_MASK))\n\n                    return -1;\n\n                page_size = 4096;\n\n            }\n\n        }\n\n        pte = pte & env->a20_mask;\n\n    }\n\n\n\n    page_offset = (addr & TARGET_PAGE_MASK) & (page_size - 1);\n\n    paddr = (pte & TARGET_PAGE_MASK) + page_offset;\n\n    return paddr;\n\n}\n", "idx": 15136, "substitutes": {"env": ["forge", "args", "edge", "en", "context", "qa", "enc", "cv", "ea", "config", "eye", "code", "enter", " environment", "eu", "oa", "pg", "manager", "event", "txt", "vm", "init", "fg", "server", "conf", "output", "conn", "np", "console", "obj", "loader", "hell", "dict", "e", "equ", "viron", "exc", "engine", "nc", "site", "her", "eng", "ext", "vs", "qt", "Environment", "ef", "assets", "state", "global", "eni", "shell", "dt", "ne", "cal", "que", "db", "ev", "cache", "ec", "emb", "ou", "environment", "el", "core", "et", "ctx", "err"], "addr": ["ord", "ode", "bridge", "Address", "rr", "en", "ha", "amp", "len", "inter", "adder", "arm", "amd", "config", "art", "memory", "oa", "nn", "er", "align", "anne", "rg", "cmp", "ace", "xp", "hash", "arg", "conn", "aug", "grad", "ad", "adr", "layer", "atom", "add", "address", "state", "ip", "url", "ridge", "route", "arr", "offset", "attr", "eth", "az", "ast", "rt", "host", "od", "db", "nr", "src", "seq", "dr", "ar", "hop", "order", "pad", "ptr", "asm", "node", "ost"], "pde_addr": ["pda__addr", "pda_ord", "pde__addr", "pde_layer", "pde_address", "pdc_addr", "pda_addr", "pda__ord", "pda__oa", "pde_ord", "pdu_addr", "pde_hop", "pde__address", "pda_address", "pdu_layer", "pde_ace", "pde__ord", "pde_oa", "pde_amd", "pda__address", "pdc_ace", "pda_oa", "pde__oa", "pdu_hop", "pdc_ord", "pdu_amd"], "pte_addr": ["pte_address", "pte_device", "ptee_amd", "ptee_device", "ptee_address", "pte_amd", "ptee_addr"], "pte": ["PTee", "PTd", "cte", "PTe", "ctee", "ptE", "ctE", "ctd", "PTE", "ptd", "aptd", "ptee", "aptE", "apte", "aptee"], "paddr": ["tpaddress", "tpcode", "tpaddr", "vpnode", "pcaddr", "vpaddr", "pcode", "vpcode", "pcnode", "vpaddress", "tpnode", "paddress", "pcaddress", "pnode", "pccode"], "page_offset": ["page\u00b7reset", "page2reset", "page_number", "page\u00b7size", "page\u00b7number", "page\u00b7offset", " page_reset", "page2offset", " page_number", "page2number", "page_reset", "page2size"], "page_size": [" page_len", "page64offset", "page64size", "page_len", "page64len"], "pdpe_addr": ["pdpe__addr", "pdpe_address", "pdke__orig", "pdpe__cmd", "pdke__address", "pdpe_ord", "pdque_layer", "pdke_orig", "pdke_addr", "pdfe_hop", "pdpe__ord", "pdpe_hop", "pdque_hop", "pdfe_int", "pdpo_addr", "pdpo_ord", "pdpe_cmd", "pdfe_lan", "pdpo_address", "pdpe_conn", "pdpe_layer", "pdpe__address", "pdfe_addr", "pdke_address", "pdque_addr", "pdpe_lan", "pdpe_orig", "pdque_conn", "pdke__hop", "pdpe_int", "pdfe_address", "pdpe__hop", "pdke_hop", "pdke__addr", "pdpe__orig", "pdpe__lan", "pdfe_cmd"], "pde": ["pne", "pdu", "gdu", "Pde", "dde", "copda", "hde", "pnode", "hdu", "pda", "gde", " pdu", " pnode", "hdc", " pdec", " pdc", "pdes", " pda", " pdes", "copde", "lpdc", "Pne", "copdec", "gdo", "pdec", "lpnode", "lpdu", "hnode", "copne", "gdes", "ddes", "lpde", "pdo", "ddo", "ddu", "pdc", " pdo", " pne", "Pda", "Pdec"], "pdpe": ["sdpe", "hdpes", "ddche", "pdde", "dpes", "ldper", "hdple", "hdte", "pdfe", "pcke", "draper", "pdoe", "eddper", "dfe", "pcque", "ldple", "padpe", "tdde", "hdper", "tdper", "ldke", "eddte", "pdper", "ddpe", "pdque", "ldche", "hdme", "tdfe", "sdque", "tdpe", "dsper", "tdte", "ddple", "drate", "drape", "dper", "pcpe", "tdpes", "tdple", "hdfe", "pdke", "dpe", "ldoe", "ddoe", "pdme", "hdde", "hdpe", "dte", "ldque", "ldpe", "hdche", "sdper", "pdple", "pdte", "pdpes", "dspe", "drame", "dke", "pdche", "padpes", "sdke", "padple", "tdke", "padde", "dste", "eddfe", "pcper", "hdke", "eddpe", "hdoe", "dsme"], "pml4e_addr": ["pml4er_address", "pml4e_offset", "pml4e_host", "pml4er_addr", "pml4er_offset", "pml4ee_len", "pml4e_hop", "pml4e__address", "pml4e_len", "pml4e_loc", "pml4ee_loc", "pml4exaddr", "pml4ee_addr", "pml4er_hop", "pml4e__hop", "pml4e_conn", "pml4e_func", "pml4er_host", "pml4e_address", "pml4ee_conn", "pml4er_func", "pml4exloc", "pml4exconn", "pml4e__offset", "pml4exlen", "pml4er_loc", "pml4e__addr"], "pml4e": ["pml004E", "pml8ee", "pwl12x", "pml12x", "pml4b", "pwl4pe", "pml6e", "pmal4b", "pmal6b", "pml4f", "pml5c", "pwl4e", "pmlfourer", "pml6ee", "pml12c", "pwl4E", "pwl12e", "pazel4e", "pwl12er", "pml5E", "pml12e", "pml04er", "pml4er", "pml6er", "pml04ee", "pml5x", "pml8f", "pml6f", "pmal6f", "pwl12c", "pml5e", "pml04b", "pml5pe", "pmal4f", "pml8e", "pmal4ee", "pml004c", "pml8er", "pml4ee", "pwl12E", "pwl12pe", "pml7e", "pwl4x", "pml6b", "pml5er", "pml7f", "pml04e", "pmal4e", "pml4c", "pazel4b", "pmal6e", "pwl4er", "pml4x", "pmal6ee", "pazel4ee", "pml12er", "pml12E", "pml7ee", "pml4E", "pml7b", "pml12pe", "pazel04er", "pazel04ee", "pml004er", "pml004e", "pazel04e", "pwl4c", "pml4pe", "pmlfoure", "pmlfourx", "pazel04b", "pml8b", "pmlfourpe", "pazel4er"], "sext": ["psexp", "tetxt", "tept", "selex", "netxt", "sept", "sect", "pselex", "pseext", "SEext", " setxt", "inext", "pexp", "neft", "teXT", "seext", " sexp", "texp", "inelect", "ineXT", "inexp", "pelect", "tect", "SExp", "SEpt", "select", "psext", "SExt", "seXT", " seft", "next", "sexp", " sept", "peXT", "seft", "SElex", "text", "psect", " selex", "nept", " seXT", "pext", "setxt", "pseXT", " select", "teft", "SEXT", " seext", "SEct", "psept"]}}
{"project": "qemu", "commit_id": "3a3b8502e6f0c8d30865c5f36d2c3ae4114000b5", "target": 1, "func": "void spapr_pci_rtas_init(void)\n\n{\n\n    spapr_rtas_register(\"read-pci-config\", rtas_read_pci_config);\n\n    spapr_rtas_register(\"write-pci-config\", rtas_write_pci_config);\n\n    spapr_rtas_register(\"ibm,read-pci-config\", rtas_ibm_read_pci_config);\n\n    spapr_rtas_register(\"ibm,write-pci-config\", rtas_ibm_write_pci_config);\n\n    if (msi_supported) {\n\n        spapr_rtas_register(\"ibm,query-interrupt-source-number\",\n\n                            rtas_ibm_query_interrupt_source_number);\n\n        spapr_rtas_register(\"ibm,change-msi\", rtas_ibm_change_msi);\n\n    }\n\n}\n", "idx": 15147, "substitutes": {}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static void compare_sec_rs_finalize(SocketReadState *sec_rs)\n\n{\n\n    CompareState *s = container_of(sec_rs, CompareState, sec_rs);\n\n\n\n    if (packet_enqueue(s, SECONDARY_IN)) {\n\n        trace_colo_compare_main(\"secondary: unsupported packet in\");\n\n    } else {\n\n        /* compare connection */\n\n        g_queue_foreach(&s->conn_list, colo_compare_connection, s);\n\n    }\n\n}\n", "idx": 15173, "substitutes": {"sec_rs": [" sec_ras", "sec_ras", " sec_rys", "sec_rys", "secJras", "secJRS", " sec_RS", "secJrys", " sec_ros", " sec_cs", "secJrs", " sec_rss", "sec_rss", "sec_cs", "sec_ros", "sec_RS"], "s": ["args", "south", "sys", "ses", "m", "self", "d", "sync", "service", "sg", "fs", "i", "sym", "rs", "https", "g", "cs", "S", "submit", "os", "new", "si", "js", "sq", "session", "ps", "ss", "o", "u", "p", "e", "sec", "groups", "se", "socket", "sf", "sb", "b", "f", "gs", "spec", "ns", "c", "xs", "is", "stats", "ssl", "side", "sl", "states", "r", "ds", "services", "ops", "src", "ls", "ts"]}}
{"project": "qemu", "commit_id": "b47b35250fbfa062aedf6ab6e5faab84c4a76f4f", "target": 1, "func": "FDCtrl *fdctrl_init_isa(DriveInfo **fds)\n\n{\n\n    ISADevice *dev;\n\n\n\n    dev = isa_create(\"isa-fdc\");\n\n    if (fds[0]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveA\", fds[0]->bdrv);\n\n    }\n\n    if (fds[1]) {\n\n        qdev_prop_set_drive_nofail(&dev->qdev, \"driveB\", fds[1]->bdrv);\n\n    }\n\n    if (qdev_init(&dev->qdev) < 0)\n\n        return NULL;\n\n    return &(DO_UPCAST(FDCtrlISABus, busdev, dev)->state);\n\n}\n", "idx": 15201, "substitutes": {"fds": [" fd", "fdd", "qns", "fys", "fns", "fDS", "fd", "fsts", "fordd", " fdd", "cdds", "pDS", "forts", " fns", " fks", "dsts", "fks", "lDS", "qrs", "dDS", "pds", "pks", "cfds", " fDS", "ld", " fsk", "lda", " fts", "dks", "qnas", " fys", "cd", "frs", " fdds", "cfys", "fdds", "fords", "qds", "cfrs", "psts", "qts", "qdd", " fda", "fda", " frs", "dds", "cDS", "ldds", "forks", "lds", "qda", "cfsk", "qsk", "lns", "cds", " fnas", "qys", "fts", "fsk", "fnas", "qks", "lnas", " fsts"], "dev": ["bug", "device", "ani", "kind", "self", "d", "priv", "die", "server", " device", "def", "rad", "req", "ve", "user", "di", "Dev", "mod", "bus", "error", "v", "app", "conf", "gu", "var", "adv", "de", "valid", "w", "grad", "pub", "ad", "conn", "temp", "info", "ver", "data", "sd", "driver", "ready", "diff", "develop", "df", "dem", "serv", "end", "DEV", " Dev", "ow", "host", "od", "dd", "ev", "prop", "debug", "wd", "err"]}}
{"project": "FFmpeg", "commit_id": "c571424c7f6276a6374e1784ce2a33d4b6a4292d", "target": 1, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n\n{\n\n    ASFContext *asf       = s->priv_data;\n\n    AVPacket pkt          = { 0 };\n\n    const CodecMime *mime = ff_id3v2_mime_tags;\n\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n\n    char mimetype[64];\n\n    uint8_t  *desc = NULL;\n\n    AVStream   *st = NULL;\n\n    int ret, type, picsize, desc_len;\n\n    ASFStream *asf_st;\n\n\n\n    /* type + picsize + mime + desc */\n\n    if (len < 1 + 4 + 2 + 2) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture type */\n\n    type = avio_r8(s->pb);\n\n    len--;\n\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n\n        type = 0;\n\n    }\n\n\n\n    /* picture data size */\n\n    picsize = avio_rl32(s->pb);\n\n    len    -= 4;\n\n\n\n    /* picture MIME type */\n\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n\n               mimetype);\n\n        return 0;\n\n    }\n\n\n\n    if (picsize >= len) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n\n               picsize, len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n", "idx": 15206, "substitutes": {"s": ["rs", "qs", "h", "si", "js", "server", "sim", "lines", "spec", "c", "is", "sc", "sv", "aws", "south", "m", "self", "sync", "sg", "fs", "ins", "sup", "g", "cs", "es", "full", "session", "storage", "an", "u", "b", "ns", "ops", "r", "sa", "space", "ks", "secondary", "sys", "service", "your", "private", "hs", "os", "sets", "e", "obs", "http", "sb", "f", "less", "services", "ls", "comments", "ctx", "ses", "a", "sites", "S", "submit", "settings", "its", "uns", "sq", "v", "conf", "ss", "request", "p", "se", "sign", "gs", "xs", "stats", "sci", "ssl", "ds", "su", "ts", "us"], "len": ["en", "fl", "Len", "lon", "val", "lic", "pre", "lp", "str", "loc", "limit", "mem", "fin", "pl", "base", "count", "end", "iter", "sl", "num", "span", "ln", "rev", "part", "lc", "fn", "ld", "lib", "data", "min", "length", "ann", "url", "il", "gen", "body", "elt", "el", "alt", "format", "ni", "lvl", "syn", "fun", "sp", "dl", "lit", "fat", "conn", "ll", "li", "lf", "html", "ls", "pos", "bl", "net", "lim", "err", "hl", "lin", "enc", "l", "split", "name", "lang", "size", "la", "lt", "n", "ell", "all", "resp", "den", "seq"], "asf": ["Asc", "Ascf", "ascf", "AScf", "asc", " asc", "ASfs", "ASf", "asfs", "Asf", "ASc", " ascf", " asfs", "Asfs"], "mime": ["Mide", "mimage", "pIME", "cmode", " mode", "mimes", "pime", "amime", "pmimes", "smise", "amimes", "mip", " mise", "imime", "Mimes", "pimes", "smime", "amIME", "pimage", "imimes", " mimage", "pmip", " mimes", "smIME", "cmip", "amise", "mIME", "pmime", "pide", " mize", "cmimes", "mise", "mode", " mich", "cmime", "smize", "pise", "pich", " mIME", "mich", "MIME", "imise", " mide", "Mimage", "Mise", "imich", "mide", "mize", "Mime", "pmode", "Mize", " mip"], "mimetype": ["mimitype", "mimellycape", "mimetytype", "mockeycape", "mamityme", "mimetypes", "mignitypress", "mimetrype", "mocketycape", "mimencyope", "mocketype", "mimetypress", "mumetyPE", "mimityape", "moyetypes", "mimellyplate", "mignitype", "mimenameype", "mimearpes", "mockeyope", "mametytype", "mametype", "mignetype", "mimetycape", "mimetyro", "mimeytype", "mumipetype", "mimearope", "mametypes", "mimilepress", "mimetyplate", "mameyype", "mockeyplate", "mimencycape", "mimeypes", "mametyro", "mametyme", "mimencyape", "mignetyape", "mimeyplate", "mimellyope", "moyetrypes", "mignetyme", "mimetyme", "mimenamepe", "mimeype", "mamitytype", "mimestype", "mimityme", "mimilepe", "mimileape", "mimileme", "mumipePE", "mimestpe", "mimitypes", "mocketyope", "mimearpe", "mimetyope", "mimerypes", "mimetrypes", "mimitytype", "mimipePE", "mimeryype", "moyetryype", "mimeryPE", "mockeype", "mimeryme", "mimipepe", "mumetypes", "mumipepe", "mimenamepes", "mimenametype", "mimenameme", "mimeyype", "mimipetype", "mimeyro", "mumetytype", "moyetype", "mameyro", "mimetyape", "mimetryope", "mimencyme", "mimestpes", "mumipepes", "mamitype", "mimencypress", "mimellype", "mignityape", "mimeycape", "mimetryype", "mumetype", "mimipepes", "mimetyPE", "moyetrype", "mimeyope", "moyetyype", "mignetypress", "mimitypress", "mimestro", "mocketyplate", "mimenamero", "mimencyplate", "mameypes", "mameype", "mametyype", "mignityme", "mimerytype", "mamitypes", "mimeyPE", "mimencype", "mimetyype", "moyetyope", "moyetryope", "mimeryope", "mimearype", "mimerype"], "desc": ["path", "uc", "bc", "dist", "Desc", "enc", "rc", "id", "code", "label", "def", "name", "fun", "description", "str", "ref", "asc", "lit", "dest", "comment", "dir", "loc", "meta", "de", "summary", "rec", "doc", "sec", "info", "ext", "des", "diff", "dc", "esc", "text", "md", "sc", "cont", "aux", "src", "sub", "seq", "content", "cur", "prev"], "st": ["sta", "rd", "sp", "ste", "sth", "std", "sw", "ct", "ss", "bl", "se", "ST", "sb", "St", "inst", "est", "sn", "stim", "sc", "sl", "ast", "sh", "sa", "rest", "ist", "sts", "ost"], "ret": [" orig", " val", " lang", "id", " ref", " resp", " ord", " alt", "Id", " lib", " def", " seq", " flag", " ext", " arg", " sent", " wid", "ID", " ID", " pos", " code", " flags", " url", " res", " base", " field", " clen", " gen"], "type": ["types", "area", "Type", "kind", "typ", "sort", "ype", "format", "part", "t", "id", "code", "val", "shape", "style", "name", "sp", "weight", "py", "null", "ref", "unit", "by", "TYPE", "comment", "total", "key", "like", "loc", "error", "value", "o", "size", "version", "p", "time", "info", "http", "min", "op", "length", "count", "spec", "state", "token", "number", "block", "pe", "single", "offset", "year", "class", "sub", "tag", "pos", "rel", "ty", "order", "span", "y", "index", "sy"], "picsize": ["picssize", "pnicizes", " pipsize", "policize", "Picsizes", "pipsize", "picksIZE", "picsrate", "pisze", "picizer", "picsizer", "pnicize", "nicsiz", "picalrate", "pickssize", "pipssize", " pipssize", "picsze", "picksizing", "picrate", " policize", "parsize", " policsize", "piciz", "policIZE", "picIZE", "parssize", "pixsize", "picizes", "picalsize", " policIZE", "pisize", " picrate", " policiz", "Pickssize", "nicsze", " pipsiz", "pipsizes", " picssize", "pixizer", "Picsize", " pipsizes", "pixize", "pnicsize", "picksrate", "Picksizing", "Picksize", " picsizer", "pisiz", "nicssize", " picsIZE", "picksize", " picsizes", "nicsize", "parsizing", " picsrate", " picizer", "pipsiz", "picze", " picize", "Picssize", "picksizes", "policsize", "parsizes", "picsiz", "nicize", "picize", "picaliz", "picsIZE", "niciz", "nicze", "picalize", "pissize", "picksiz", " piciz", "Picsizing", "picsizes", "picksze", "picksizer", "Picksizes", " picsiz", "pnicizing", "policiz", "picsizing", "pixiz"], "desc_len": ["dist_lf", "descqlen", " desc2val", " desc2len", "desc2Len", "desc2len", "descqlon", "description2len", "desc2lon", "dist_num", "desc_ln", " desc_lon", "descdden", "desc_num", "desc_dl", " desc_val", "description_ln", "descdlen", "desc___lon", "descqval", "descdlf", "dist_den", "description2ln", "distdnum", "desc_lon", "desc_den", "desc___len", "description2lon", "desc_val", "description_len", "desc_lf", " desc2lon", "desc___ln", "desc_Len", "description2Len", " desc2dl", "distdlen", "dist_len", "distdlf", "desc_lin", "desc___Len", "description_lon", "distdden", "desc2dl", "descqdl", "desc2val", "description_lin", "desc2ln", "description_num", " desc_dl", "description_Len", "descdnum"], "asf_st": ["asf__ST", "asf__St", "asb_st", "asf__st", "asf_ST", "asf__sl", "asb__sl", "asf_St", "asb__St", "asb_ST", "asf_sl", "asb_St", "asb_sl", "asb__st", "asb__ST"]}}
{"project": "qemu", "commit_id": "c0f4af171999eda4e49de5169906ce98246457f0", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209, "substitutes": {"env": ["erv", "en", "context", "bc", "enc", "prov", "ea", "config", "iss", "ini", "gr", "priv", "iv", "eu", "me", "oa", "virt", "txt", "vm", "scope", "server", "app", "v", "conf", "conn", "np", "console", "equ", "e", "viron", "exc", "net", "fi", "nc", "enable", "eng", "entry", "qt", "eni", "ridge", "serv", "ep", "cf", "here", "que", "exec", "gui", "db", "cache", "ec", "him", "environment", "vs", "ctx", "visor", "err"], "rip": ["rib", "tx", "rup", "ru", "rc", "jp", "ipe", "rs", "rn", "rg", "sr", "ick", "app", "rh", "rub", "region", "tri", "trip", "ris", "rx", "rin", "ix", "op", "RI", "arp", "rw", "ipp", "ip", "serv", "route", "pin", "cap", "rt", "ips", "strip", "rap", "raped"], "syndrome": ["Syndrome", "syindchrome", "syndchrome", "syundrom", "Syntchrome", "syundrome", "cyndchrome", "cyntchrome", "sydrom", "syundroma", "cyndrom", "sydchrome", "Syntrom", "cyntrome", "syndrom", "Syntrome", "sydroma", "syindroma", "syntrom", "Syndroma", "Syntroma", "cyntroma", "sydrome", "syundchrome", "syntrome", "syindrom", "syndroma", "cyntrom", "cyndroma", "syntroma", "Syndrom", "syntchrome", "Syndchrome", "cyndrome", "syindrome"], "ri": ["ani", "stri", "rid", "rd", "ni", "ai", "xi", "rc", "ini", "i", "gi", " RI", "iv", "io", "ra", "ci", "ki", "di", "sr", "iri", "rio", "si", "uri", "vi", "tri", "ris", "ir", "mi", "rx", "rin", "RI", "ti", "ski", "rm", "ip", "eni", "ry", "ro", "pi", "rt", "mir", "ori"]}}
{"project": "qemu", "commit_id": "b7c8c35f0afb62efcacd18a64067fe164e3206b6", "target": 1, "func": "static char *scsibus_get_dev_path(DeviceState *dev)\n\n{\n\n    SCSIDevice *d = DO_UPCAST(SCSIDevice, qdev, dev);\n\n    DeviceState *hba = dev->parent_bus->parent;\n\n    char *id = NULL;\n\n\n\n    if (hba && hba->parent_bus && hba->parent_bus->info->get_dev_path) {\n\n        id = hba->parent_bus->info->get_dev_path(hba);\n\n    }\n\n    if (id) {\n\n        return g_strdup_printf(\"%s/%d:%d:%d\", id, d->channel, d->id, d->lun);\n\n    } else {\n\n        return g_strdup_printf(\"%d:%d:%d\", d->channel, d->id, d->lun);\n\n    }\n\n}\n", "idx": 15239, "substitutes": {"dev": ["device", "development", "self", "dist", "die", "def", "rad", "req", "ve", "di", "user", "Dev", "mod", "comment", "v", "app", "conf", "conn", "der", "gd", "w", "de", "pub", "ad", "info", "ver", "data", "diff", "block", "dem", "dc", "DEV", " Dev", "md", "debug", "ds", "dd", "ev", "dim", "dom", "del", "err"], "d": ["D", "dh", "m", "fd", "t", "l", "i", "da", "a", "bd", "ded", "die", "g", "h", "dl", "std", "di", "nd", "ld", "gd", "dm", "w", "cd", "pd", "ad", "u", "p", "e", "s", "data", "b", "sd", "did", "n", "f", "dat", "c", "diff", "dad", "dt", "dc", "md", "dim", "ds", "dd", "od", "db", "dn", "vd", "dr", "wd", "dom", "del", "in", "dos"], "hba": ["ahb", "hrda", "phba", "hva", "hbas", "ahva", "hlbe", " hb", "hhba", "hpa", "phpa", "hlada", "Hna", "hhbe", "Hda", "hhna", "hlba", "Hada", " hda", "hsba", "hada", "Hbas", "hga", "hb", "hsbc", "hrbe", "hsda", "hrbo", "hhga", " hva", "hda", "hlpa", " hna", "ahba", "phva", "Hpa", "hlaba", "hrna", "Hba", "hrba", "Hga", "hsbo", "hbe", "phb", "haba", "Hva", "hhpa", " hpa", "hrva", "hbo", "hraba", "hhda", "hrbc", "Hbo", "hna", " hbo", "hlna", " hga", "ahpa", "hlbas", "hbc", " hbc", "hhada", " hbas", "hhbas", "hhaba"], "id": ["channel", "oid", "path", "it", "kind", "en", "bid", "part", "lin", "rid", "and", "i", "mid", "code", "val", "vid", "def", "name", "api", "Id", "act", "ident", "h", "null", "ref", "ide", "lit", "pid", "error", "key", "like", "ID", "ids", "ad", "sid", "p", "info", "version", "data", "bit", "length", "mad", "f", "parent", "ip", "url", "c", "start", "end", "type", "gen", "iden", "file", "one", "aid", "hid", "alias", "in", "kid", "index", "uid"]}}
{"project": "FFmpeg", "commit_id": "5e65f5df0e0cd91eed74cce87c5d65b19e176595", "target": 0, "func": "static int eval_lpc_coeffs(const float *in, float *tgt, int n)\n\n{\n\n    int x, y;\n\n    double f0, f1, f2;\n\n\n\n    if (in[n] == 0)\n\n        return 0;\n\n\n\n    if ((f0 = *in) <= 0)\n\n        return 0;\n\n\n\n    in--; // To avoid a -1 subtraction in the inner loop\n\n\n\n    for (x=1; x <= n; x++) {\n\n        f1 = in[x+1];\n\n\n\n        for (y=0; y < x - 1; y++)\n\n            f1 += in[x-y]*tgt[y];\n\n\n\n        tgt[x-1] = f2 = -f1/f0;\n\n        for (y=0; y < x >> 1; y++) {\n\n            float temp = tgt[y] + tgt[x-y-2]*f2;\n\n            tgt[x-y-2] += tgt[y]*f2;\n\n            tgt[y] = temp;\n\n        }\n\n        if ((f0 += f1*f2) < 0)\n\n            return 0;\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15249, "substitutes": {"in": ["IN", "it", "m", "bin", "isin", "lin", "part", "input", "on", "ins", "id", "ini", "i", "inf", "again", "up", "nn", "ex", "source", "image", "new", "inn", "circ", "init", "con", "update", "din", "conn", "win", "scan", "o", "pass", "rec", "p", "rin", "min", "inside", "old", "f", "line", "ax", "token", "inc", "c", "arr", "pin", "inner", "ac", "nin", "In", "out", "login", "index"], "tgt": [" twd", "wtnt", "qtgt", "pgt", " targ", "ttarget", "atlt", "tkt", "pgz", "fnt", "tgz", "parg", "qtgat", "ynt", "dgz", "ktga", "targ", "atgt", "ygt", "tgen", "wtgen", "Tgt", "wwd", "Tgz", " tgen", "plt", "twd", "dkt", " tft", "atnt", "atwd", "atgen", "dnt", " tnt", "Ttarget", "Tnt", "wnt", " tga", "ktlt", "dft", "qtga", "ktgat", "fwd", "dlt", "tgat", "wlt", " tgat", "wtwd", " tkt", "ywd", "fft", "Targ", " ttarget", "attarget", "dgt", "tnt", "ptarget", "tft", "tga", "pnt", "fgt", "dwd", "Tft", "ykt", "wgt", "qtlt", "tlt", "wtgt", " tgz", " tlt", "ktgt"], "n": ["m", "nl", "d", "t", "ni", "l", "i", "nn", "N", "name", "g", "h", "nb", "v", "o", "w", "z", "u", "size", "p", "e", "nan", "s", "nc", "k", "b", "j", "f", "c", "ns", "sn", "nt", "network", "out", "all", "r", "num", "span", "net"], "x": ["tx", "my", "i", "plus", "image", "h", "xt", "dx", "c", "X", "lex", "work", "num", "index", "m", "d", "t", "on", "xi", "id", "g", "full", "key", "w", "u", "s", "b", "min", "xx", "ax", "ip", "xc", "ty", "wx", "fx", "px", "step", "o", "mix", "z", "e", "rx", "ix", "j", "cross", "f", "sex", "wa", "no", "xxx", "any", "l", "code", "ww", "a", "name", "ex", "xa", "v", "yx", "dy", "p", "time", "k", "xs", "one", "xy", "wy", "max"], "y": ["ny", "yt", "m", "hy", "d", "t", "ys", "iny", "xi", "id", "sky", "i", "iy", "ish", "isy", "ey", "ci", "yd", "py", "cy", "gy", "ym", "key", "ye", "v", "o", "yx", "dy", "yi", "w", "z", "yl", "ady", "p", "e", "yr", "uy", "b", "yo", "j", "f", "xx", "ay", "c", "vy", "oy", "ry", "type", "year", "Y", "ya", "ky", "xy", "yy", "wy", "ty", "zy", "sy"], "f0": ["p2", "F0", "p0", "c2", " f3", "c1", "cf2", "cf0", "e0", "F6", "F2", "p1", " f6", "f6", "F00", "e2", "f00", "rf0", " f00", "f3", "rf00", "cf6", "rf1", "F3", "F1", "cf1", "e1", "e3", "rf2", "c0"], "f1": ["v5", "of2", "F0", " f64", "v0", "cf64", "cf2", "cf0", "sf2", "of0", "F2", "v2", "F4", " f4", "df2", "sf0", "sfone", "df1", "f7", "df64", "sf1", "fone", "df7", "v1", "f64", " fone", "F1", "cf4", "f5", " f5", "f4", " f7", "cf1", "F5", "of1", "Fone", "ofone", "cf7"], "f2": ["p2", "F0", "e4", "v0", "f8", "p0", " f02", "F02", "sf02", "fb", "sf2", "e0", "e8", "F2", "p1", "v2", "F4", " f4", "v8", "sf0", "e2", "pb", "F8", " fb", "sf1", "Fb", "v1", "F1", "f02", "f4", "e1", " f8"]}}
{"project": "FFmpeg", "commit_id": "71a1f76d3cc937fc1a47f501fc4866f95b74d0b0", "target": 0, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    free_temp(&s->dither);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n    swri_rematrix_free(s);\n\n\n\n    s->flushed = 0;\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested input sample format %d is invalid\\n\", s->in_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested output sample format %d is invalid\\n\", s->out_sample_fmt);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(av_get_planar_sample_fmt(s->in_sample_fmt) <= AV_SAMPLE_FMT_S16P || s->int_sample_fmt==AV_SAMPLE_FMT_S16P){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16P;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLTP;\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLTP){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, S16/S32/FLT is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    set_audiodata_fmt(&s-> in, s-> in_sample_fmt);\n\n    set_audiodata_fmt(&s->out, s->out_sample_fmt);\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, s->filter_size, s->phase_shift, s->linear_interp, s->cutoff, s->int_sample_fmt);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(    s->int_sample_fmt != AV_SAMPLE_FMT_S16P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_S32P\n\n        && s->int_sample_fmt != AV_SAMPLE_FMT_FLTP\n\n        && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16/s32/flt\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0 ||\n\n                 s->rematrix_custom;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\n    if(!s-> in.ch_count){\n\n        av_assert0(!s->in_ch_layout);\n\n        av_log(s, AV_LOG_ERROR, \"Input channel count and layout are unset\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if ((!s->out_ch_layout || !s->in_ch_layout) && s->used_ch_count != s->out.ch_count && !s->rematrix_custom) {\n\n        av_log(s, AV_LOG_ERROR, \"Rematrix is needed but there is not enough information to do it\\n\");\n\n        return -1;\n\n    }\n\n\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s->in_buffer= s->in;\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map && !s->dither_method){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count= s->used_ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        if(s->resample)\n\n            s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    set_audiodata_fmt(&s->postin, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->midbuf, s->int_sample_fmt);\n\n    set_audiodata_fmt(&s->preout, s->int_sample_fmt);\n\n\n\n    if(s->resample){\n\n        set_audiodata_fmt(&s->in_buffer, s->int_sample_fmt);\n\n    }\n\n\n\n    s->dither = s->preout;\n\n\n\n    if(s->rematrix || s->dither_method)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 15252, "substitutes": {"s": ["native", "i", "rs", "qs", "h", "js", "si", "server", "ps", "params", "groups", "spec", "c", "serv", "is", "in", "args", "south", "m", "self", "d", "sync", "t", "sg", "fs", "ins", "sym", "sup", "g", "cs", "es", "full", "session", "u", "an", "b", "sf", "ns", "ops", "r", "ks", "sys", "parts", "service", "hs", "os", "sets", "scope", "o", "ms", "e", "site", "http", "sb", "features", "f", "less", "services", "ls", "comments", "php", "ses", "l", "a", "changes", "S", "settings", "submit", "this", "its", "user", "sq", "rows", "conf", "ss", "request", "p", "sign", "ions", "n", "ments", "gs", "xs", "ssl", "side", "ds", "su", "ts", "us"]}}
{"project": "qemu", "commit_id": "8de433cb0820dc1f387a2d580d255744aacd60cc", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260, "substitutes": {"id": ["oid", "path", "bid", "rid", "d", "code", "val", "mid", "i", "name", "Id", "image", "ident", "h", "x", "ref", "ide", "pid", "key", "ID", "ids", "cd", "ad", "size", "sid", "p", "info", "data", "pointer", "base", "did", "count", "length", "f", "parent", "address", "ip", "url", "number", "c", "start", "end", "type", "num", "aid", "post", "max", "in", "kid", "index", "uid"], "errp": ["eorpb", "errpb", "iterps", "iterpa", "acerpa", "erfp", "ererp", "iterr", "interp", "errorp", " errc", "interlp", "ererpre", "errr", "acerps", "erlp", " errcp", "interfp", "erpa", "eorpart", "ererpart", "errfp", "errc", "ercp", "errP", "errorP", "erc", "errps", " errfp", " errP", "errpa", "erp", "eorp", "errpart", "errpre", "Erpb", " errlp", "ererpb", "Erp", "iterp", "acerp", "errlp", "errcp", "errorc", "erps", "Erpre", "errorcp", "interP", "Erpart", "acerr", "erP", "eorpre", "err"], "icc_bridge": ["iccacbridge", "ci_ridge", "icc_link", "icc__Bridge", "fc_server", "pc_gb", "icc__switch", "icc__brid", "icc_ridge", "icc_brid", "fc_switch", "iccaclink", "icc__server", "icc_gb", "fc_version", "iccacswitch", "pc_bridge", "icc_version", "fc_bridge", "pc_link", "ci_brid", "ci_bridge", "icc_switch", "icc__ridge", "iccacgb", "ci_Bridge", "icc_server", "icc__version", "icc_Bridge", "pc_switch", "icc__bridge"]}}
{"project": "qemu", "commit_id": "5b4a047fbe8ceb68ad1a78d51f0fadbe2bb12af7", "target": 1, "func": "static void xlnx_ep108_init(MachineState *machine)\n\n{\n\n    XlnxEP108 *s = g_new0(XlnxEP108, 1);\n\n    Error *err = NULL;\n\n\n\n    object_initialize(&s->soc, sizeof(s->soc), TYPE_XLNX_ZYNQMP);\n\n    object_property_add_child(OBJECT(machine), \"soc\", OBJECT(&s->soc),\n\n                              &error_abort);\n\n\n\n    object_property_set_bool(OBJECT(&s->soc), true, \"realized\", &err);\n\n    if (err) {\n\n        error_report(\"%s\", error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    if (machine->ram_size > EP108_MAX_RAM_SIZE) {\n\n        error_report(\"WARNING: RAM size \" RAM_ADDR_FMT \" above max supported, \"\n\n                     \"reduced to %llx\", machine->ram_size, EP108_MAX_RAM_SIZE);\n\n        machine->ram_size = EP108_MAX_RAM_SIZE;\n\n    }\n\n\n\n    if (machine->ram_size <= 0x08000000) {\n\n        qemu_log(\"WARNING: RAM size \" RAM_ADDR_FMT \" is small for EP108\",\n\n                 machine->ram_size);\n\n    }\n\n\n\n    memory_region_allocate_system_memory(&s->ddr_ram, NULL, \"ddr-ram\",\n\n                                         machine->ram_size);\n\n    memory_region_add_subregion(get_system_memory(), 0, &s->ddr_ram);\n\n\n\n    xlnx_ep108_binfo.ram_size = machine->ram_size;\n\n    xlnx_ep108_binfo.kernel_filename = machine->kernel_filename;\n\n    xlnx_ep108_binfo.kernel_cmdline = machine->kernel_cmdline;\n\n    xlnx_ep108_binfo.initrd_filename = machine->initrd_filename;\n\n    xlnx_ep108_binfo.loader_start = 0;\n\n    arm_load_kernel(s->soc.boot_cpu_ptr, &xlnx_ep108_binfo);\n\n}\n", "idx": 15288, "substitutes": {"machine": ["device", "proc", "interface", "mc", "memory", "sample", "motion", "image", "project", "module", "model", "server", "tm", "sim", "handler", "base", "c", "sc", "cp", "volume", "message", "normal", "m", "part", "home", "manager", "di", "vm", "comment", "session", "error", "mot", "group", "loader", "parse", "instance", "Machine", "b", "M", "link", "host", "mac", "template", "cache", "space", "alias", "controller", "core", "oper", "database", "sys", "ch", "service", "config", "connection", "sp", "game", "slave", "app", "o", "element", "processor", "e", "menu", "info", "boot", "engine", "note", "f", "address", "state", "block", "man", "field", "node", "channel", "object", "user", "by", "computer", "p", "mi", "match", "component", "mode", "parent", "rule", "process", "hard", "sm"], "s": ["args", "south", "sys", "m", "ses", "self", "service", "sync", "t", "sg", "fs", "l", "rs", "sym", "sample", "a", "sup", "g", "cs", "details", "S", "sp", "os", "h", "game", "js", "si", "es", "sq", "session", "server", "scope", "ps", "ss", "conf", "sim", "sch", "params", "p", "e", "sf", "b", "sb", "n", "f", "gs", "less", "spec", "c", "ns", "serv", "is", "sc", "ssl", "side", "sl", "services", "ds", "r", "sa", "su", "ls", "space", "sm"], "err": ["bug", "rr", "m", "gr", "rs", "orig", "a", "ah", "msg", "kr", "rar", "g", "er", "Error", "req", "rn", "sr", "str", "txt", "icer", "ace", "eor", "aster", "error", "Er", "br", "fr", "conf", "var", "der", "cr", "rh", "mr", "ind", "doc", "e", "ir", "lr", "fi", "ler", "n", "aaa", "result", "nor", "cfg", "arr", "acer", "cb", "iter", "r", "resp", "ev", "pr", "ar", "fee", "dr", "res", "orr", "nr", "order", "y"]}}
{"project": "FFmpeg", "commit_id": "00b3ca3c7a779e3b062d6ef0c5067c60c8f8a357", "target": 1, "func": "static int parse_inputs(const char **buf, AVFilterInOut **curr_inputs,\n\n                        AVFilterInOut **open_outputs, AVClass *log_ctx)\n\n{\n\n    int pad = 0;\n\n\n\n    while (**buf == '[') {\n\n        char *name = parse_link_name(buf, log_ctx);\n\n        AVFilterInOut *match;\n\n\n\n        if (!name)\n\n            return AVERROR(EINVAL);\n\n\n\n        /* First check if the label is not in the open_outputs list */\n\n        match = extract_inout(name, open_outputs);\n\n\n\n        if (match) {\n\n            av_free(name);\n\n        } else {\n\n            /* Not in the list, so add it as an input */\n\n            match = av_mallocz(sizeof(AVFilterInOut));\n\n            match->name    = name;\n\n            match->pad_idx = pad;\n\n        }\n\n\n\n        insert_inout(curr_inputs, match);\n\n\n\n        *buf += strspn(*buf, WHITESPACES);\n\n        pad++;\n\n    }\n\n\n\n    return pad;\n\n}\n", "idx": 15290, "substitutes": {"buf": ["func", "bridge", "path", "vec", "proc", "context", "ff", "uc", "bc", "queue", "cv", "tmp", "batch", "rc", "mount", "fb", "home", "uf", "bound", "auc", "conv", "pool", "ref", "buffer", "bag", "fp", "br", "buff", "pause", "la", "brace", "img", "rb", "grab", "data", "b", "sb", "wb", "Buff", "gb", "ab", "bh", "bu", "feed", "cat", "tab", "ucc", "cb", "cap", "text", "cas", "cmd", "cf", "abb", "fam", "src", "seq", "prop", "prefix", "ptr", "comb"], "curr_inputs": ["curr_refd", "curr_pulld", "curr_refs", "curr_contextes", "curr_outputds", "curr_connectds", "curr_inputd", "curr_outputb", "curr_outputd", "curr_pulls", "curr_pulles", "curr_refds", "curr_pullb", "curr_outputes", "curr_connects", "curr_contexts", "curr_inputes", "curr_refes", "curr_contextd", "curr_connectes", "curr_outputs", "curr_inputds", "curr_connectd", "curr_contextb", "curr_inputb"], "open_outputs": ["open_configs", "open_outputes", "open_connectts", "open_outputsets", "open_controls", "open_controlts", "open_outputors", "open_connectes", "open_inputsets", "open_inputs", "open_configts", "open_configes", "open_configsets", "open_inputors", "open_inputes", "open_inputts", "open_configors", "open_controles", "open_outputts", "open_connectors", "open_controlsets", "open_connects"], "log_ctx": ["logingctx", "Log_tx", "log_cb", "logingc", "logingcontext", "Log_c", "log_lc", "Log_cb", "Log_context", "Log_ctx", "log_context", "logingtx", "loginglc", "log_c", "Log_lc", "log_tx", "logingcb"], "name": ["channel", "word", "path", "action", "call", "m", "self", "part", "nam", "id", "search", "code", "a", "label", "connection", "image", "ident", "new", "x", "comment", "key", "member", "like", "value", "Name", "known", "NAME", "names", "group", "size", "version", "ame", "e", "resource", "data", "base", "n", "parent", "address", "number", "url", "type", "cap", "change", "no", "num", "space", "alias", "prefix", "coord", "nm", "index", "start"], "match": ["map", "ge", "call", "m", "include", "Match", "search", "mp", "player", "me", "handle", "mat", "test", "image", "use", "cmp", "model", "sum", "comment", "update", "member", "key", "live", "patch", "same", "help", "catch", "index", "group", "parse", "mor", "be", "info", "comp", "data", "meet", "select", "play", "result", "fire", "add", "address", "query", "pair", "url", "route", "cat", "pin", "message", "target", "matched", "rule", "change", "scale", "link", "track", "get", "field", "cache", "see", "tag", "alias", "push", "copy", "apply", "replace", "find"], "pad": ["bug", "ada", "stroke", "port", "done", "adder", "amp", "pc", "shift", "style", " padd", "pick", "gap", "align", "Pad", "buffer", "ace", "crop", "adjust", "patch", "help", "quad", "adding", "adr", "ad", "ady", "p", "size", "pod", " padding", "pointer", "base", "paste", "length", "count", "pend", "padding", "address", "add", "ping", "number", "reset", "end", "type", "offset", "scale", "pos", "prefix", "addr", "space", "span", "delay", "push", "ptr", "index", "start"]}}
{"project": "FFmpeg", "commit_id": "c341f734e5f9d6af4a8fdcceb6f5d12de6395c76", "target": 1, "func": "void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,\n\n                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,\n\n                   int block_w, int block_h, int width, int height, int linesize,\n\n                   vp8_mc_func mc_func[3][3])\n\n{\n\n    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];\n\n\n\n    if (AV_RN32A(mv)) {\n\n        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];\n\n        int my = mv->y&7, my_idx = subpel_idx[0][my];\n\n\n\n        x_off += mv->x >> 3;\n\n        y_off += mv->y >> 3;\n\n\n\n        // edge emulation\n\n        src1 += y_off * linesize + x_off;\n\n        src2 += y_off * linesize + x_off;\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);\n\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n", "idx": 15301, "substitutes": {"s": ["ses", "m", "self", "service", "d", "t", "sg", "fs", "rs", "g", "cs", "S", "sp", "os", "si", "js", "sq", "session", "ps", "ss", "sim", "w", "p", "se", "e", "sb", "b", "n", "f", "gs", "spec", "c", "ns", "ssl", "sl", "services", "ds", "ls", "ts"], "td": ["ft", "amp", "fd", "rd", "input", "d", "tmp", "t", "pc", "cz", "tl", "dl", "nd", "ld", "table", "tm", "pd", "cd", "ad", "img", "pb", "sd", "sb", "tc", "sf", "lf", "gb", "tif", "dt", "dc", "tf", "lv", "md", "ht", "dd", "hd", "ts", "TD", "fc", "BT"], "dst1": ["dsts0", " dscOne", "drcb", " dsc1", "Dstb", "Dst2", "Drcb", "drcOne", "dsp1", "drc0", "dsc2", "Drc0", "dscOne", "dscb", "dstb", " dsc2", "Dst0", "Drc2", "dst0", "dstsOne", "dsc1", "dsts2", "Dst1", " dsc0", "dstOne", "dsp0", "dspb", "drc2", "drc1", "dsp2", "Drc1", "dsts1", " dstOne", "dsc0", " dst0"], "dst2": ["drcb", "drc4", "dsrc1", " dST1", "dST4", "dst4", " dst4", "dstb", "dsrc2", "dsrcb", " dST2", "dSTb", " dST4", "drc2", "dST1", "drc1", "dST2", " dstb", " dSTb", "dsrc4"], "ref": ["proc", "remote", "inter", "ob", "rc", "config", "pc", "bb", "inf", "Ref", "pre", "def", "reference", "req", "null", "buffer", "thread", "conf", "fr", "buff", "lib", "obj", "mem", "p", "e", "aff", "rb", "info", "ib", "pb", "REF", "fab", "af", "bf", "f", "lf", "parent", "ab", "fe", "cb", "re", "r", "cal", "db", "cache", "rel", "reg", "el", "rf", "cl", "ctx"], "mv": ["smvc", "Mv", "Mf", "smv", "mf", "smvp", "mvp", "mp", " mp", "mvin", "amw", "bmf", "Mx", "dw", "amx", "mq", "pp", "mnw", " mvc", "mnx", "mvs", "dov", "mnvin", " mvin", "bmv", "mx", "pmv", "nw", " mh", "pmf", " mov", " mvs", "dx", "mov", " mw", " mf", "nvin", "bmvs", "mh", "pf", " mq", "dv", "amov", "smf", "Mvs", " mvp", "pv", " mx", "Mvc", "Mvp", "pmx", "nx", "amv", "mvc", "Mh", "nv", "Mq", "mw", "mnv", "Mp", "ph", "pmq", "bmq"], "x_off": ["x00offset", "x66offset", "x__OFF", "x_OFF", "x_down", "x00OFF", "x_out", "xFonly", "y_only", "xFnum", "mx00OFF", "x55load", "x_non", " x_non", "rx_offset", "y_num", "xFoff", " x_out", "x00off", "y_offs", " x_orig", "x_load", "x67out", "x00load", "x67load", "mx_OFF", "mx00offset", "mx00off", "x55non", "x__off", "x_over", "x_only", "x55off", "x67on", " x_on", "x67OFF", "x67off", "rx_load", "x66over", "mx_off", "x66load", "rx_off", "mx_load", "y_OFF", "mx00load", "xFoffs", "x_on", "x_orig", "rx_over", "x67orig", "x_num", "y_down", "x_offset", "x67offset", "x_offs", "mx_offset", "x66off", "xFdown", " x_load"], "y_off": ["i_offset", "y68offset", "i_offs", "y68no", "hop68ON", " y_OFF", "y44off", "i67offset", "yacoff", "x_OFF", "x_down", "i67offs", "y_shift", "y44offs", "y_ON", "y_length", " y_down", " y_shift", "hop68offset", "y67now", "i_length", "x_dev", "yl_off", "y_offs", " y_now", "y44offset", "yacof", "hop_offset", "y67of", "hop_off", "y_online", "yl_on", "y_of", "y67no", "y67off", "y68off", " y_oa", " y67now", " y_offs", "y67offs", "y44length", " y_non", "hop68off", " y67off", "hop_online", "y_offset", " y_no", "hop_ON", "yacnow", "y68of", "y_oa", "y_OFF", "y_now", " y67no", "yacno", "y68now", "y68ON", "x_on", "yl_ON", "y_non", " y67of", "i67off", "x_online", "y67offset", "y_on", "y_down", "x_offs", "y68online", " y_of", "y_dev", "y67length", "i67length", "y_no", "i_off", "hop68online"], "block_w": ["blockJwl", "block__wt", "block00h", "block00width", "blockableh", "blockablen", "blockJw", "block67wo", "blockJh", "block00w", "block_wl", "block__w", "block67n", "Block_wl", "Block_w", "block_n", "block_width", "block00wo", "block_wt", "Block_wt", "blockJwt", "block67i", "Block_h", "block__h", "block67h", "block67w", "block_wo", "block__wl", " block_width", "Block_i", " block_wo", "Block_n", "block_i", "block67width", "blockablei", "blockablew"], "block_h": ["blocklexwh", "block00h", "block_sh", "block00w", "block_c", "blocklexw", " block_wh", "lock_ah", " block_hs", "blocklexhs", "lock_ih", "block_wh", "blockrictih", "block_ih", "block00history", "block__hz", " block_c", "blockNhi", "blockingh", "blockricth", "block_ah", "blockableah", "lock_w", "block__sh", "block__h", "blocklexh", " block_history", "blocklexoh", "block00sh", "blockNh", " block_sh", " block_hz", "blockrictah", "blocklexsh", " block_hi", "blocklexhz", "lock_h", "blockingw", "blockingoh", "block_hz", "blockNc", "block_hs", " block_oh", "blockablew", "blockableh", "blockNw", "blockableih", "block_oh", "block_history", "blockrictw", "block_hi", "block__hs", "blockingwh"], "height": ["upper", "stroke", "Height", "deep", "build", "thin", "grow", "bottom", "level", "density", "shape", "style", "row", "gap", "h", "missing", "gh", "crop", " heights", "alpha", "hang", "dy", "w", "size", "tight", "images", "direction", " Height", "distance", "length", "th", "padding", "resolution", "holes", "inches", "pull", "above", "hold", "dim", "layout", "volume", "history", "window", "ty", "quality", "y", "depth"], "linesize": [" linesizer", "linsiz", "linesizer", "codesized", "opensize", "filesize", "posization", "facesiz", " linesizable", "posIZE", "netsization", "codesizer", "pagesiz", "framesiz", "facesIZE", "runsIZE", "codesize", "timesizing", "linsafe", "linersizing", "pagesizing", "filesization", "posize", "runsizer", "elinesize", "runsize", "timesize", "linsize", "facesafe", "lesizing", "elinesization", "runsization", "elinesiz", "worksizer", "facesizing", "posizing", "worksize", "facesize", "framesize", "linesizing", "opensizer", "lesization", " linesization", "elinesizing", "worksIZE", "linersize", " linesIZE", "framesizing", " linesizing", " linesized", "linesization", "filesIZE", "timesIZE", "linesized", "linsized", "lesize", "vertsization", "linsizing", "linersiz", "framesized", "opensiz", "opensized", "facesization", "vertsize", "pagesized", "worksization", "linesiz", "codesiz", "linesIZE", "linesafe", "linsizer", "pagesize", "vertsiz", "linersafe", "linesizable", "lesIZE", " linesiz", "filesizable", "netsize", "netsIZE", "netsizable", "vertsizing", "timesization"], "mc_func": [" mc2function", "mc__callback", " mc_unc", "mc_unc", "MC2function", "mc2function", "MC2func", "mc2callback", " mc2func", "mc_function", " mc_cc", "mc_callback", "mc_cc", " mc2cc", "mc2cc", " mc2unc", "MC2callback", "MC_func", "MC_callback", "mc2func", "mc__func", "MC_function", "mc__function", " mc_function", "mc2unc"], "src1": [" src0", "srcx", "sourcex", "buf01", "gl01", "gl1", "seqOne", "source01", "srcone", "sourcepre", "rc2", " srcx", "img1", "seq1", "loc0", "rc0", "rcone", "seqx", "source2", "sourceOne", "srcpre", "source1", "glpre", "img0", " srcOne", "bufpre", "loc1", "img2", "src01", "src0", "seq2", " srcone", "loc2", "rc1", "imgone", "srcOne", "buf1"], "src2": [" src0", "source02", "config2", "srctwo", "config0", "rc2", "rc0", "source2", "configtwo", "source1", " src4", "source0", "src4", "rc02", "rc4", "rctwo", "src0", "src02", "config4", "rc1", " src02", " srctwo"]}}
{"project": "FFmpeg", "commit_id": "7e7e59409294af9caa63808e56c5cc824c98b4fc", "target": 0, "func": "static void rgb24_to_yuv444p(AVPicture *dst, AVPicture *src,\n\n                             int width, int height)\n\n{\n\n    int src_wrap, x, y;\n\n    int r, g, b;\n\n    uint8_t *lum, *cb, *cr;\n\n    const uint8_t *p;\n\n\n\n    lum = dst->data[0];\n\n    cb = dst->data[1];\n\n    cr = dst->data[2];\n\n\n\n    src_wrap = src->linesize[0] - width * BPP;\n\n    p = src->data[0];\n\n    for(y=0;y<height;y++) {\n\n        for(x=0;x<width;x++) {\n\n            RGB_IN(r, g, b, p);\n\n            lum[0] = RGB_TO_Y_CCIR(r, g, b);\n\n            cb[0] = RGB_TO_U_CCIR(r, g, b, 0);\n\n            cr[0] = RGB_TO_V_CCIR(r, g, b, 0);\n\n            cb++;\n\n            cr++;\n\n            lum++;\n\n        }\n\n        p += src_wrap;\n\n        lum += dst->linesize[0] - width;\n\n        cb += dst->linesize[1] - width;\n\n        cr += dst->linesize[2] - width;\n\n    }\n\n}\n", "idx": 15321, "substitutes": {"dst": [" dsts", "lost", "tsc", "sstd", "fsts", " dST", "stest", "adst", "adsts", "idgest", "dnd", " dnd", "tnd", "sst", "dbl", "Drc", "stsc", "dST", "lgest", "dsts", " dest", "lsts", "sttd", "tost", "dost", "lsc", "idst", "idest", "stst", "dgest", " dost", " dgest", "drc", "adsc", "Dst", "delst", "Dsts", "ltd", "ssts", "lnd", "lst", "dcast", "fput", "adrc", " dtd", " dstd", "tbl", "fst", "sost", "delsc", "Dsc", "idput", "lcast", "lbl", " dsc", " drc", "fest", "dtd", "tcast", " dput", "dest", "lest", "dstd", "tst", "dsc", "delbl", "delcast", "idST", "lST", "dput", "idsts"], "src": ["rss", "gz", "uc", "slice", "dist", "cv", "tmp", "rc", "config", "rs", "sup", "source", "sr", "dest", "loc", "grad", "img", "rb", "s", "sb", "inst", "stat", "gb", "spec", "rl", "url", "sn", "sc", "ssl", "rob", "sl", "sur", "sub", "sel", "ruby", "st", "support", "ctx"], "height": ["Height", "build", "d", "thin", "bottom", "grow", "level", "density", "shape", "row", "h", "gh", "crop", "rows", "kw", "w", "hang", "dy", "size", "z", "s", "direction", "length", "flow", "padding", "resolution", "wp", "inches", "pull", "margin", "ht", "wall", "center", "layout", "work", "window", "depth"], "src_wrap": ["src_break", "src_wrapper", " src_break", " src_work", " src_wrapper", "srclexwrap", "srclexwrapper", "src_scroll", "srclexwork", "rc_scroll", "rc_wrap", "rc_margin", "rc_wrapper", "src_margin", "src_work"], "x": ["m", "d", "t", "on", "id", "l", "i", "image", "h", "px", "v", "w", "yx", "dx", "dy", "u", "z", "ady", "e", "s", "rx", "ix", "n", "f", "ax", "c", "X", "ya", "xy", "wy", "pos", "el", "ph", "in", "index"], "y": ["ny", "d", "t", "id", "l", "i", "ey", "py", "h", "gy", "cy", "ym", "ye", "v", "o", "w", "dy", "z", "u", "yl", "e", "yr", "yo", "j", "n", "f", "oy", "c", "vy", "ay", "ry", "type", "Y", "ya", "xy", "yy", "wy", "ty", "sy"], "r": ["rr", "m", "ru", "R", "d", "hr", "rc", "tr", "l", "i", "rs", "a", "ra", "er", "h", "rg", "sr", "v", "br", "rh", "fr", "o", "w", "u", "e", "s", "rb", "rx", "n", "f", "rl", "c", " w", "ro", "ur", "re", "ri", "pr", "nr", "dr", "usr", "err"], "g": ["ge", "m", "d", "sg", "gr", "l", "G", "i", "gi", "ig", "h", "rg", "v", "gn", "w", "group", "z", "gm", "u", "e", "s", "gg", "k", "j", "n", "f", "gs", "cfg", "c", "gen", "bg", "q", "go"], "b": ["m", "d", "t", "bs", "l", "i", "fb", "a", "h", "nb", "v", "o", "bp", "w", "u", "e", "s", "rb", "boot", "be", "pb", "base", "wb", "j", "sb", "n", "f", "ab", "bh", "c", "eb", "bi", "db", "B", "lb"], "lum": ["slum", "blumb", "lumption", " lub", " luf", "plam", "ylam", " lup", "bluf", "llum", "Lumb", "llums", "lumb", "lup", "Lup", " lumb", "lul", "ulums", " lumption", "ulumption", "slums", "lums", "llup", "lub", "luf", "ylul", "blam", "slam", "llam", "ulum", "ylum", "jlums", " lam", " lums", "Luf", "plumb", "Lum", "ulub", "plums", "slumb", "jlumption", "Lums", " lul", "blum", "ylumb", "plum", "Lam", "lam", "jlub", "Lul", "jlum"], "cb": ["rib", "ff", "uc", "bc", "cv", "ob", "ca", "rc", "cc", "bb", "fb", "ctr", "bd", "ctrl", "ci", "lc", "ub", "cor", "cn", "cmp", "kk", "abc", "mb", "conf", "cd", "CB", "ba", "gg", "rb", "bm", "pb", "buf", "nc", "sb", "co", "bf", "gb", "ab", "c", "cu", "dc", "lab", "eb", "cf", "nv", "cp", "abb", "db", "xc", "lb", "cur", "rf", "core", "cpp"], "cr": ["rr", "ch", "bc", "ca", "cv", "rc", "cc", "pc", "tr", "ctr", "Cr", "kr", "pre", "lc", "ci", "sp", "cor", "sr", "ref", "cy", "ct", "v", "br", "rh", "cd", "CR", "rb", "rx", "pb", "wp", "rm", "c", "cat", "pe", "sc", "cf", "cp", "db", "pr", "nr", "ar", "dr", "cro", "cur", "ph", "core", "err"], "p": ["m", "po", "d", "t", "pc", "jp", "i", "l", "pt", "pre", "api", "sp", "py", "lp", "h", "pp", "fp", "v", "ps", "o", "np", "w", "bp", "u", "z", "e", "pb", "pa", "j", "n", "f", "c", "pm", "pin", "per", "par", "pe", "pi", "q", "cache", "pr", "ar", "pos", "P", "tp"]}}
{"project": "qemu", "commit_id": "a5cf8262e4eb9c4646434e2c6211ef8608db3233", "target": 0, "func": "static char *pcibus_get_fw_dev_path(DeviceState *dev)\n\n{\n\n    PCIDevice *d = (PCIDevice *)dev;\n\n    char path[50], name[33];\n\n    int off;\n\n\n\n    off = snprintf(path, sizeof(path), \"%s@%x\",\n\n                   pci_dev_fw_name(dev, name, sizeof name),\n\n                   PCI_SLOT(d->devfn));\n\n    if (PCI_FUNC(d->devfn))\n\n        snprintf(path + off, sizeof(path) + off, \",%x\", PCI_FUNC(d->devfn));\n\n    return strdup(path);\n\n}\n", "idx": 15341, "substitutes": {"dev": ["device", "self", "dist", "id", "priv", "die", "def", "rad", "g", "req", "ve", "user", "di", "Dev", "mod", "nd", "v", "conf", "prom", "der", "gd", "conn", "w", "de", "ad", "ind", "info", "ver", "data", "sd", "inst", "diff", "block", "dem", "dc", "md", "r", "exec", "dd", "ev", "debug", "dom", "wd", "err"], "d": ["D", "dh", "device", "m", "done", "fd", "t", "id", "l", "ded", "da", "bd", "g", "td", "dl", "nd", "ld", "gd", "w", "dy", "cd", "pd", "ad", "p", "e", "s", "sd", "b", "did", "f", "dom", "mad", "dat", "c", "df", "dt", "dc", "md", "ds", "od", "db", "dd", "dn", "dm"], "path": ["root", " Path", "ath", "part", "enc", "config", "id", "code", " text", "child", "home", " node", "test", "image", "progress", "str", "txt", "method", " data", "ref", "full", "append", "fn", "dir", "loc", "value", "key", "request", "open", "pass", "clean", "an", " index", " description", "p", "desc", "data", "pointer", "base", "n", "Path", "cross", "parent", "line", "url", "c", "route", "PATH", "end", " child", "inner", "anc", "file", "text", "cmd", "out", " parent", "link", "pattern", "content", "work", "prefix", "wd", "node"], "name": ["word", "device", "self", "part", "nam", "id", "a", "image", "new", "x", "key", "package", "Name", "NAME", "w", "names", "size", "version", "time", "info", "ame", "desc", "data", "n", "f", "parent", "url", "block", "type", "out", "all", "no", "prefix", "alias", "day", "nm", "node"], "off": ["ord", "ff", "self", "on", "art", "and", "oa", "def", "fun", " OFF", "test", "Off", "new", "original", "offer", "raw", "how", "OFF", "error", "unknown", "of", "o", "open", "obj", " on", "online", "own", "ave", "buf", "data", "length", "opp", "flow", "line", "block", "only", "end", "down", "offs", "offset", "now", "ov", "needed", "out", "load", "all", "pos", "no", "num", "len", "ow"]}}
{"project": "qemu", "commit_id": "f69a8bde29354493ff8aea64cc9cb3b531d16337", "target": 1, "func": "static int qio_channel_websock_handshake_send_response(QIOChannelWebsock *ioc,\n\n                                                       const char *key,\n\n                                                       Error **errp)\n\n{\n\n    char combined_key[QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                      QIO_CHANNEL_WEBSOCK_GUID_LEN + 1];\n\n    char *accept = NULL, *response = NULL;\n\n    size_t responselen;\n\n\n\n    g_strlcpy(combined_key, key, QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN + 1);\n\n    g_strlcat(combined_key, QIO_CHANNEL_WEBSOCK_GUID,\n\n              QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n              QIO_CHANNEL_WEBSOCK_GUID_LEN + 1);\n\n\n\n    /* hash and encode it */\n\n    if (qcrypto_hash_base64(QCRYPTO_HASH_ALG_SHA1,\n\n                            combined_key,\n\n                            QIO_CHANNEL_WEBSOCK_CLIENT_KEY_LEN +\n\n                            QIO_CHANNEL_WEBSOCK_GUID_LEN,\n\n                            &accept,\n\n                            errp) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    response = g_strdup_printf(QIO_CHANNEL_WEBSOCK_HANDSHAKE_RESPONSE, accept);\n\n    responselen = strlen(response);\n\n    buffer_reserve(&ioc->encoutput, responselen);\n\n    buffer_append(&ioc->encoutput, response, responselen);\n\n\n\n    g_free(accept);\n\n    g_free(response);\n\n\n\n    return 0;\n\n}\n", "idx": 15368, "substitutes": {"ioc": ["iocol", "atiocol", "iosc", "uoc", "tiosc", "iob", "ioou", " ioca", "audiocom", "iiou", "tioc", "audioc", "ioca", "iioc", "ioow", "tioca", "iooc", " iosc", "audiocol", "iow", "iou", "riog", "iaoc", "uocol", "atiob", "iaoca", "atioc", "ioog", "riow", "iiog", "riou", "audiob", "iog", "iaosc", "uob", "iiow", "iaow", "rioc", " iow", "tiow", "atiocom", "iocom", "uocom"], "key": ["channel", "secret", "call", "input", "id", "code", "seed", "connection", "name", "source", "x", "Key", "error", "server", "value", "phrase", "client", "conn", "request", "password", "sign", "resource", "socket", "k", "data", "base", "pair", "ip", "block", "cert", "type", "text", "keys", "KEY", "fee", "ctx"], "errp": ["nerP", " errr", " errf", "derc", " errpe", "errf", "errorp", "erpe", " errc", "errorpe", "errr", "errpe", "nerf", "derp", "errc", "errP", "errorP", "derf", " errP", "erp", "nerp", "nerc", "derP", "erP", "errorr", "err"], "combined_key": ["combmented_value", "combosen_Key", "combinedFsecret", "combiner_value", "combinedFprefix", "combided_key", "combided_pair", "combiner_Key", "combided_k", "combiner_key", "combined_mode", "combined_prefix", "combmented_secret", "combined_Key", "combinedFKey", "combined_k", "combosen_prefix", "combinedFkey", "combided_id", "combosen_key", "combined_value", "combined_secret", "combined_id", "combined_pair", "combosen_secret", "combmented_mode", "combmented_key"], "accept": ["release", "call", "en", "connect", "uc", "input", "allow", "enc", "xml", "escape", "received", "name", "respond", "answer", "send", "image", "hello", "event", "bec", "other", "acc", "update", "pport", "loc", "valid", "output", "request", "open", "pass", "view", "rec", "oc", "sign", "select", "success", "data", "reflect", "entry", "length", "result", "json", "none", "address", "control", "close", "crit", "feed", "reason", "ac", "esc", "agree", "sex", "iter", "Accept", "ack", "lex", "host", "content", "adapt", "sel", "support", "opt", "exclusive", "message"], "response": ["secret", "partial", "en", "reply", "array", "example", "xml", "received", "code", "name", "api", "respond", "answer", "image", "hello", "description", "offer", " responses", "error", "server", "value", "onse", "output", "valid", "request", "o", "v", "view", "wave", "params", "version", "resource", "success", "data", "http", "result", "json", "reason", "feed", "ception", "body", "results", "application", "write", "Response", "resp", "respons", "su", "content", "res", "message"], "responselen": ["responclun", "respoensela", "respongelend", "responclEN", "respoensilenc", "responsellon", "respronselen", "responcelength", "responflend", "respoenseleng", "resprongelend", "respunsellen", "responfleng", "responcelen", "resprongelen", "responsellenc", "responcelun", "responfllen", "respongelenc", "respuncilun", "respunselEN", "responcilength", "respoenselenc", "responselleng", "responceleng", "responsleng", "responsellen", "responcellen", "responnellen", "respunselon", "respunselen", "respuncilEN", "responsileng", "responsella", "respronseleng", "respoenselen", "responselenc", "responslon", "respoensilen", "respunselength", "responclen", "responcelEN", "responsilen", "responnellon", "resprongellen", "respunsellz", "respronsellen", "respongelen", "respuncilen", "responslen", "responsellz", "responselz", "responselength", "responflen", "respongela", "responselon", "respunselun", "responseleng", "responselun", "responcilen", "respunseleng", "respongellen", "responsila", "respoensileng", "responcilun", "responselend", "responsilenc", "respongeleng", "responnellz", "responclength", "responnelleng", "respunselz", "respuncilength", "responcilEN", "responselEN", "responsela", "responcelend", "respronselend", "respunselleng", "resprongeleng", "responslz", "respoensila", "respunsellon"]}}
{"project": "qemu", "commit_id": "50628d3479e4f9aa97e323506856e394fe7ad7a6", "target": 1, "func": "void dpy_gfx_copy(QemuConsole *con, int src_x, int src_y,\n\n                  int dst_x, int dst_y, int w, int h)\n\n{\n\n    DisplayState *s = con->ds;\n\n    DisplayChangeListener *dcl;\n\n\n\n    if (!qemu_console_is_visible(con)) {\n\n        return;\n\n    }\n\n    QLIST_FOREACH(dcl, &s->listeners, next) {\n\n        if (con != (dcl->con ? dcl->con : active_console)) {\n\n            continue;\n\n        }\n\n        if (dcl->ops->dpy_gfx_copy) {\n\n            dcl->ops->dpy_gfx_copy(dcl, src_x, src_y, dst_x, dst_y, w, h);\n\n        } else { /* TODO */\n\n            dcl->ops->dpy_gfx_update(dcl, dst_x, dst_y, w, h);\n\n        }\n\n    }\n\n}\n", "idx": 15373, "substitutes": {"con": ["channel", "en", "mc", "cm", "connect", "uc", "bc", "ca", "enc", "core", "rc", "config", "pc", "unc", "cc", "lic", "canon", "current", "connection", "ctrl", "syn", "public", "conv", "cn", "lang", "conf", "cr", "win", "conn", "client", "cons", "col", "an", "CON", "ocon", "nc", "co", "can", "dom", "parent", "control", "c", "Con", "inc", "close", "dc", "anc", "type", "common", "login", "coll", "cal", "exec", "com", "cache", "ec", "dn", "class", "fc", "ln", "cl", "ctx", "anon"], "src_x": ["src01my", " src_rx", "src00orig", "src_orig", "src00y", "src_my", " src_xi", "src01rx", "src00x", "src01x", "src_xi", " src_my", "src00xi", "src_rx", " src_orig", "src01y"], "src_y": ["src_Y", " src_ya", " src_oy", " src_Y", " src_ny", "src_oy", "src_ny", "src_ya"], "dst_x": ["dsta_x", "dsta_xs", "dsts_x", "dsta_X", "drc_xi", "dsts_ix", "dsts_X", "drc_index", "dst_ix", "dst_xs", "dst_X", "dsts_y", "dst_xi", "drc_w", "dst_index", "dst_w", "drc_x", "dsta_y"], "dst_y": ["dest_vy", "dest_dy", "dest_x", "dest_bar", "dst_Y", "dst_i", "dst_vy", "dest_y", "dbl_y", "dst_z", "dbl_x", "dst_dy", "dbl_Y", "dst_bar", "dbl_z", "dest_i"], "w": ["m", "en", "wh", "d", "t", "iw", "l", "ww", "ew", "a", "g", "weight", "wx", "new", "wt", "x", "sw", "v", " W", "win", "o", "z", "p", "e", "b", "wb", "n", "f", "c", "W", "wa", "q", "fw", "r", "we", "work", "y", "ow"], "h": ["hi", "m", "ch", "en", "ha", "ih", "t", "hr", "l", "i", "g", "hs", "x", "gh", "v", "rh", "o", "help", "uh", "hh", "z", "p", "e", "time", "k", "b", "n", "f", "hm", "c", "W", "end", "q", "r", "H", "sh", "hw", "work", "ph", "y", "height"], "s": ["sys", "ses", "self", "sync", "l", "rs", "g", "cs", "syn", "S", "os", "new", "si", "sq", "session", "ps", "ss", "conn", "o", "p", "se", "e", "sb", "b", "n", "f", "acl", "spec", "c", "ns", "is", "sn", "sc", "ssl", "sl", "ds", "sa", "ls"], "dcl": ["cdcel", "dwl", "fcl", "idcl", "ddcl", "ldscl", "tcl", "dCL", "idbc", "dlfl", "sdcel", "dbl", " dlf", "adcl", "ncl", "fpl", "thell", "npl", "Dbc", "adCL", "dacl", "dlcl", "ddfl", " dCL", "idfc", "ldcl", "tscl", "dpl", "dlf", "lcl", "Dcl", "sdfl", "ddcel", "dlc", "nscl", " dbc", "cdcl", "dcel", " dwl", "dlpl", " dacl", "nCL", " dfl", "dhell", "dsl", "dscl", "dfc", "cdCL", "dsCL", "dlwl", "tfc", "idlf", " dcel", "ldacl", "Dpl", "adcel", "idpl", " dpl", "tlc", " dhell", "tfl", "dbc", "dsbl", "fCL", "lpl", "adfl", " dbl", "tbl", " dfc", " dsl", "lacl", "ldCL", "dfl", "lfl", "ldwl", "ddCL", "ldpl", " dlc", "sdhell", "ldsl", "Dlf", "idfl", "fscl", "ldfl", " dscl", "dssl", "ldbl", "tcel", "idlc", "sdcl", "cdfl"]}}
{"project": "qemu", "commit_id": "3c94193e0bbdd855bcbedabd27e3cbe1e6bc6242", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388, "substitutes": {"tcg_constant_folding": ["tcg_constant_constings", "tcg_constant_bufforing", "tcg_constant_creating", "tcg_constant_buffings", "tcg_constant_consting", "tcg_constant_constling", "tcg_constant_foldings", "tcg_constant_creatling", "tcg_constant_constoring", "tcg_constant_foldling", "tcg_constant_buffling", "tcg_constant_creatoring", "tcg_constant_foldoring", "tcg_constant_creatings", "tcg_constant_buffing"], "TCGContext": ["TCGPModule", "TCGPConfig", "TCCGContext", "TCGIComp", "tcGModule", "TCGPContext", "TCGModule", "tcGContext", "tcCGConfig", "TCGIContext", "tcCGComp", "tcGComp", "TCGConfig", "TCGIModule", "TCGPComp", "TCGIConfig", "tcCGContext", "TCCGModule", "tcCGModule", "TCGComp", "tcGConfig", "TCCGConfig", "TCCGComp"], "s": ["south", "sys", "ses", "m", "self", "d", "t", "sync", "service", "sg", "fs", "private", "sym", "sup", "g", "S", "os", "sets", "js", "si", "sq", "session", "storage", "ss", "sim", "conf", "o", "u", "p", "e", "se", "cli", "http", "sf", "b", "sb", "n", "f", "spec", "c", "ns", "setup", "xs", "is", "sci", "ssl", "sv", "services", "r", "su", "space"], "uint16_t": ["uint16_T", "uint8_type", "uint8_p", "uint16_type", "uint8_t", "uint8_T", "uint16_p"], "tcg_opc_ptr": ["tcg_opc_buf", "tcg_opc2pointer", "tcg_opcs_alloc", "tcg_opc2buf", "tcg_opcs_buf", "tcg_opcs_pointer", "tcg_opcs_ptr", "tcg_opc2alloc", "tcg_opc_pointer", "tcg_opc2ptr", "tcg_opc_alloc"], "TCGArg": ["TCGCarg", "TCLGarg", "TCGVar", "TCGDOpt", "TCGVArg", "TCGarg", "PCGUOp", "TCGUParam", "TCGUarg", "TCLGParam", "PCGParam", "UCGArgs", "TCGVArgs", "PCGOpt", "TCGUArg", " TCLGVar", "TCGCArg", "TCGCParam", "PCGarg", "TCgParam", "TCGUOp", "UCGVVal", "TCgOp", "TCgArg", "TCGVal", "UCGVArgs", " TCGarg", "TCGIArg", "TCLGArg", "TCGOpt", "TCGParam", "TCGArgs", "PCGUArg", "UCGVArg", " TCLGArg", " TCLGarg", "UCGArg", "TCGCVal", "TCMArg", "TCGCVar", "UCGarg", "TCGIOpt", "TCgVar", "PCGUarg", "PCGUParam", "TCGCArgs", "TCGOp", "TCGUVal", "TCMOp", "TCGVarg", "TCGIarg", "TCgarg", "TCGDArg", "TCGIParam", "PCGOp", "TCGVVal", " TCGParam", "UCGVarg", "PCGArg", "TCGUArgs", " TCLGParam", "TCGDarg", "TCGDParam", "UCGVal", "TCMarg", " TCGVar", "TCLGVar", "PCGUOpt", "TCGUOpt"], "args": ["msg", "grades", "bytes", "words", "ants", "module", "gas", "js", "ps", "ids", "params", "groups", "apps", "Args", "lines", "frames", "spec", "is", "ics", "states", "aws", "actions", "call", "ins", "g", "cs", "arg", "ras", "parse", "doc", "pack", "members", "data", "ns", "arr", "gen", "body", " arguments", "cache", "empty", "headers", "iss", "vals", "ks", "parts", "config", "extra", "style", "sp", "init", "pres", "help", "ms", "alls", "options", "ars", "keys", "uments", "pos", "orders", "cats", "as", "enc", "bs", "fields", "a", "ass", "ig", "py", "mm", "items", "flags", "strings", "names", "size", "p", "gs", "dat", "xs", "ams", "argument", "atts", "stats", "ports", "all", "ds", "ims", "vs"], "TCGOpDef": ["TCGopcDesc", "TCGOpRef", "TCGopDef", "TCGOppdef", "TCGOpcRef", "TCGopcDEF", "TCGOopDef", "TCGOpcDef", "TCGOppDef", "TCGOcRef", "TCGopDesc", "TCGopcdef", "TCGopcRef", "TCGOpcDesc", "TCGOopDesc", "TCGOcEx", "TCGopEx", "TCGOppEx", "TCGOgDef", "TCGopdef", "TCGOopdef", "TCGOpcdef", "TCGOppRef", "TCGopRef", "TCGOcDef", "TCGopcEx", "TCGOopDEF", "TCGOpDesc", "TCGOpEx", "TCGOgdef", "TCGopDEF", "TCGOpcEx", "TCGopcDef", "TCGOgDesc", "TCGOpcDEF", "TCGOpdef", "TCGOpDEF", "TCGOcdef", "TCGOgDEF"], "tcg_op_defs": ["tcg_op2definitions", "tcg_op_defp", "tcg_op_dfps", "tcg_op_refs", "tcg_op_defaults", "tcg_op_efp", "tcg_op_refgs", "tcg_op2defs", "tcg_op_dfes", "tcg_op_defgs", "tcg_op_declinitions", "tcg_op2decls", "tcg_op_defaultp", "tcg_op_dfp", "tcg_op_defaultes", "tcg_op_dfs", "tcg_op_decles", "tcg_op_efinitions", "tcg_op2declp", "tcg_op2defgs", "tcg_op_defes", "tcg_op2defp", "tcg_op_declp", "tcg_op_efgs", "tcg_op_defps", "tcg_op_declgs", "tcg_op_efs", "tcg_op_definitions", "tcg_op2declgs", "tcg_op_refp", "tcg_op_defaultps", "tcg_op_declps", "tcg_op_decls", "tcg_op2declinitions", "tcg_op_refinitions"], "i": ["hi", "qi", "it", "ui", "m", "I", "d", "ni", "ai", "xi", "id", "ini", "iu", "gi", "l", "io", "oi", "iv", "api", "mu", "ci", "lc", "sp", "a", "x", "di", "init", "si", "ie", "ii", "v", "uri", "o", "yi", "u", "ind", "z", "p", "e", "y", "info", "fi", "mini", "mi", "li", "k", "ix", "cli", "b", "j", "phi", "f", "multi", "ti", "n", "ip", "isi", "eni", "inner", "type", "ji", "pi", "bi", "ri", "ik", "ori", "zi", "opt", "in", "index", "start"], "nb_ops": ["nb_hops", "nn67oops", "nb_oops", "nn_oops", "NB_oops", "nb67oops", "nb_items", "nb__oops", "NB_hops", "nb__ops", "nn67ops", "nb67eps", "nb_steps", "NB_ops", "nb_eps", "nn_eps", "nb67items", "NB_OPS", "nn67items", "nb_alls", "nn_alls", "nb_OPS", "nn_steps", "nn_ops", "nn_items", "nb67ops", "nn67eps", "nn_OPS", "nb__OPS", "nb__hops"], "op_index": ["op_action", "genalcontext", "ipop_index", "gen_inc", "wp_span", "opworkind", "ipopworkind", "op_number", "op_source", "genalinc", "op2index", "gen_i", "op2id", "opxnumber", "ipop_source", "cp_thread", "gen_context", "op_ind", "wp_offset", "op2number", "op_degree", "genalindex", "copxid", "op_span", "ipop_loc", "opworkindex", "opxid", "copxind", "op2ind", "opalinc", "copxindex", "cp_action", "opalcontext", "opworkloc", "op_offset", "opxindex", "op_i", "cop_ind", "ipopworkloc", "opworksource", "ipop_ind", "ipopworksource", "copxnumber", "ipopworkindex", "cop_number", "opali", "cop_index", "op_thread", "wp_number", "op_loc", "cp_index", "op_inc", "op_id", "cop_id", "op_context", "opxind", "wp_index", "cp_degree", "gen_index", "opalindex", "genali"], "nb_temps": ["nb_comples", "nb_temp", "nb_termplates", "nb_memples", "nb_tempps", "nb_tupos", "nb_Tempps", "nb__templates", "nb_tmp", "nb_timpos", "nb_tempos", "nb_templates", "nb_stemples", "nb_stempos", "nb_stemplates", "nb_stempers", "nb_termpps", "nb_comps", "nb__stempers", "nb_termpoints", "nb_temppers", "nb_stempps", "nb__stemples", "nb_timplates", "nb_timps", "nb_timppers", "nb_timpoints", "nb_complates", "nb_tuplates", "nb_termps", "nb__temps", "nb__temples", "nb_stemppers", "nb_tups", "nb_tmpps", "nb__stemps", "nb_tmps", "nb__stemplates", "nb_Temps", "nb_mempps", "nb_stemp", "nb_memps", "nb_memplates", "nb_temples", "nb_Temples", "nb_mempers", "nb_tuppers", "nb_mempoints", "nb_tempoints", "nb_Temp", "nb_stemps", "nb_tempers", "nb_tmples", "nb__tempers", "nb_compers", "nb_timpps"], "nb_globals": ["nb_GLlocals", "nb_Globales", "nb_gllocalls", "nb_Glocalls", "nb_Globals", "nb_GLlocalls", "nb_glogalls", "nb_GLobals", "nb_globalobalf", "nb_glocals", "nb_GLlocales", "nb_glossales", "nb_glovales", "nb_globales", "nb_gllocales", "nb_Globations", "nb_glogials", "nb_Glocales", "nb_glossalf", "nb_Glocals", "nb_glocales", "nb_glogations", "nb_GLobials", "nb_Globalls", "nb_globaloballs", "nb_glovials", "nb_glocations", "nb_globalobales", "nb_glovalls", "nb_globials", "nb_globalf", "nb_glogales", "nb_glovals", "nb_gllocals", "nb_glossalls", "nb_GLobales", "nb_GLlocials", "nb_globalobals", "nb_glossals", "nb_globalls", "nb_gllocials", "nb_glocalls", "nb_globations", "nb_gllocalf", "nb_glogals", "nb_Glocations", "nb_GLoballs"], "nb_call_args": ["nb_call_flags", "nb_all_flags", "nb_callerargs", "nb_callerflags", "nb_all_args", "nb_callalargs", "nb_call_arg", "nb_all_arg", "nb_callalflags", "nb_callalarg", "nb_callerarg"], "op": ["oper", "it", "proc", "OP", "root", "cop", "top", "code", "mp", "sp", "operation", "option", "pp", "post", "pop", "init", "arg", " operation", " ops", "cmp", "key", "operator", "app", "mod", "loc", "o", "open", "obj", "opus", "oc", "p", "oop", " pop", "comp", "ext", "omp", "opp", "f", "expr", "parent", "ip", "Op", "cat", "type", "gen", " operator", "ops", "hop", "pos", "prop", "push", "num", "opt", "node"], "def": ["DEF", "proc", "call", "defined", "amd", "id", "da", "sup", "define", "uf", "eval", "req", "new", "missing", "ref", "post", "arg", "gh", "init", "lit", "pred", "conf", "adv", "de", "obj", "grad", "dev", "doc", "info", "desc", "du", "comp", "data", "f", "dom", "parent", "dep", "spec", "Def", "definition", "df", "diff", "block", "gen", "md", "cmd", "pro", "aux", "exec", "decl", "dr", "pos", "push", "prev", "ef", "del"], "gen_args": [" gen_Args", "gen___Args", "gen_abs", "gen__params", "gen_parts", " gen_arg", "gen_Args", "gen_arg", "gener__args", "gen___abs", "gen___args", "gen___extra", "gener__abs", "gener__extra", "gen___arg", "gen__abs", "gener_params", "gen_extra", "gen___parts", "gener__params", "gen__extra", "gener_args", "gen_params", "gen__args", " gen_parts", "gener_abs", "gener_extra", "gen___params"], "tmp": [" sup", "proc", " orig", "self", " arr", " coord", " var", " cat", " alloc", " ans", " img", " rc", " dummy", " dup", " dest", "obj", " obj", " param", " proc", " app", " params", " co", " temp", " accum", " dev", " parent", " disp"], "cond": ["irect", "Cond", "ainer", "ory", "ra", "act", "emon", "roller", "ed", "rier", "ependent", "ext", "rol", "parent", "less", "line", "ort", "rans", "ect", "ry", "cle", "ered", "load", "led", "ress", "lock", "rupt", "roll"], "gen_opc_buf": ["gen_opcs_buffer", "gen_opf_buffer", "gen_opc_uf", "gen_opcs_buf", "gen_opcs_uf", "gen_opc2buffer", "gen_opf_buf", "gen_opf_buff", "gen_opc_buffer", "gen_opc__uf", "gen_opc2uf", "gen_opc__buff", "gen_opc_buff", "gen_opcs_buff", "gen_opc__buf", "gen_opf_uf", "gen_opc__buffer", "gen_opc2buff", "gen_opc2buf"]}}
{"project": "qemu", "commit_id": "fedf0d35aafc4f1f1e5f6dbc80cb23ae1ae49f0b", "target": 1, "func": "static void vnc_connect(VncDisplay *vd, int csock,\n\n                        bool skipauth, bool websocket)\n\n{\n\n    VncState *vs = g_malloc0(sizeof(VncState));\n\n    int i;\n\n\n\n    vs->csock = csock;\n\n    vs->vd = vd;\n\n\n\n    if (skipauth) {\n\n\tvs->auth = VNC_AUTH_NONE;\n\n\tvs->subauth = VNC_AUTH_INVALID;\n\n    } else {\n\n        if (websocket) {\n\n            vs->auth = vd->ws_auth;\n\n            vs->subauth = VNC_AUTH_INVALID;\n\n        } else {\n\n            vs->auth = vd->auth;\n\n            vs->subauth = vd->subauth;\n\n        }\n\n    }\n\n    VNC_DEBUG(\"Client sock=%d ws=%d auth=%d subauth=%d\\n\",\n\n              csock, websocket, vs->auth, vs->subauth);\n\n\n\n    vs->lossy_rect = g_malloc0(VNC_STAT_ROWS * sizeof (*vs->lossy_rect));\n\n    for (i = 0; i < VNC_STAT_ROWS; ++i) {\n\n        vs->lossy_rect[i] = g_malloc0(VNC_STAT_COLS * sizeof (uint8_t));\n\n    }\n\n\n\n    VNC_DEBUG(\"New client on socket %d\\n\", csock);\n\n    update_displaychangelistener(&vd->dcl, VNC_REFRESH_INTERVAL_BASE);\n\n    qemu_set_nonblock(vs->csock);\n\n    if (websocket) {\n\n        vs->websocket = 1;\n\n        if (vd->ws_tls) {\n\n            qemu_set_fd_handler(vs->csock, vncws_tls_handshake_io, NULL, vs);\n\n        } else {\n\n            qemu_set_fd_handler(vs->csock, vncws_handshake_read, NULL, vs);\n\n        }\n\n    } else\n\n    {\n\n        qemu_set_fd_handler(vs->csock, vnc_client_read, NULL, vs);\n\n    }\n\n\n\n    vnc_client_cache_addr(vs);\n\n    vnc_qmp_event(vs, QAPI_EVENT_VNC_CONNECTED);\n\n    vnc_set_share_mode(vs, VNC_SHARE_MODE_CONNECTING);\n\n\n\n    if (!vs->websocket) {\n\n        vnc_init_state(vs);\n\n    }\n\n\n\n    if (vd->num_connecting > vd->connections_limit) {\n\n        QTAILQ_FOREACH(vs, &vd->clients, next) {\n\n            if (vs->share_mode == VNC_SHARE_MODE_CONNECTING) {\n\n                vnc_disconnect_start(vs);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15389, "substitutes": {"vd": ["vision", "vr", "d", "fd", "vv", "VD", "vp", "vid", "bd", "td", "dl", "ud", "ve", "di", "vm", "nd", "ld", "v", "gd", "help", "pd", "cd", "ant", "ad", "sd", "xd", "gb", "cover", "library", "df", "dt", "vg", "uds", "md", "ov", "sv", "va", "nv", "rt", "vo", "ds", "dd", "hd", "vc", "od", "dn", "dr", "vt", "wd", "lv"], "csock": ["cksock", "csody", " csink", "rsock", "dsocks", "jsick", "psorp", "bsink", "dsocker", "Csock", "vsocket", "psocket", "ciock", "cksocket", "jsocked", "psink", "cocks", "ssocker", "Csink", "ksocked", "cusocket", "cocked", "cssock", "rsocked", " csocket", "dsocked", "cssOCK", "csorp", "ksocket", "jsock", "ciink", "ksink", "cksocked", "vsock", "rsocket", "vsorp", "gsink", "bsOCK", "ssocket", "ssocked", "codesOCK", "ksocker", "cssink", " csick", "cocket", "csocked", "ciorp", "codesocket", "cock", "codesock", "cusock", "vsody", "vsick", "dsocket", "bsocket", "psock", "csink", "vsocker", "dsock", "bsock", "cssocket", "ksocks", "vsink", "csocks", "csocker", "dsink", "cusocked", "ksock", "wsocket", "csocket", "jsocket", "gsody", "csOCK", "resOCK", "codesink", "rsocker", "wsock", "wsink", "ssock", "gsick", " csody", "resock", "wsOCK", "Csocker", "cksick", " csocker", "dsOCK", "resink", "gsock", "Csocket", "cusick", "resocket", "ciocket", "csick"], "skipauth": [" skiputh", "skipauthent", "allowauth", "allowuth", "copyauthent", "copyacl", "allowauthent", "copyuth", "Skipauth", "allowAuth", "copyauth", "skipacl", "missingacl", "Skiputh", "Skipauthent", "missingauth", " skipacl", "skipAuth", "skiputh", "missingauthent", "missinguth", " skipauthent", " skipAuth", "SkipAuth"], "websocket": ["website", " weckset", "wealsession", "wealswitch", "rebspace", "websock", "webersession", "wealsocket", "weversocket", "wealsockets", "wecksite", "weversockets", "wecksockets", "shebswitch", "weasockets", "rebsocket", " websockets", "wecksock", "weasocket", "weblogocket", "wessession", "rebsockets", "reaswitch", "webset", "websockets", "weaswitch", "wecksource", "webswitch", "rebswitch", "webspace", "wessock", "wessocket", "wecksocket", "weversock", "pebsockets", " webset", "wesset", "shebsockets", "weckset", "weblogock", "webersockets", "wessite", "hebsock", "weaspace", "reasocket", "wesswitch", "websource", "pessockets", "hessystem", "wessource", "pebsocket", " website", "wecsocket", "webersocket", "pessocket", "pebscript", "wessystem", "weckswitch", "shebsock", "webscript", "shecksocket", "wesspace", "pebsession", "pesscript", "wecsockets", "wealscript", "weberscript", "wecsite", "weblogystem", "hebsystem", "weblogource", "reaspace", "websession", "websystem", "weverswitch", "wealsock", "hebsocket", "sheckswitch", "hebsource", "hessocket", " wecksocket", "shecksock", " wecksockets", "wecksystem", "wesscript", "reasockets", "wessockets", "hessource", " wecksite", "hessock", "pessession", "weckspace", "shecksockets", "shebsocket", "wecset"], "vs": ["vers", "env", "versions", "vp", "rs", "verts", "qs", "js", "ps", "eps", "ums", "lines", "asts", "sv", "events", "las", "fs", "ins", "Vs", "iv", "ups", "pages", "cs", "vm", "es", "nav", "views", "s", "ns", "nv", "ops", "vt", "res", "vals", "ks", "vr", "cv", "values", "pg", "hs", "os", "fg", "vi", "ves", "ms", "VS", "obs", "alls", "otes", "http", "state", "vg", "va", "services", "ls", "pos", "net", "as", "vv", "bs", "vid", "changes", "sk", "its", "nets", "v", "ss", "var", "flags", "vas", "gs", "wp", "blogs", "xs", "ports", "stats", "ov", "ds", "vc", "css", "ts", "ils", "sts"], "i": ["hi", "qi", "it", "ui", "I", "d", "t", "ai", "ni", "xi", "id", "iu", "l", "gi", "a", "io", "oi", "mu", "ci", "di", "x", "si", "ii", "v", "vi", "o", "yi", "u", "z", "p", "e", "fi", "li", "b", "base", "multi", "j", "ix", "n", "f", "phi", "ti", "ip", "c", "eni", "pi", "uli", "q", "r", "bi", "gui", "ri", "zi", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "ddbcc48b646737c8bff7f8e28e0a69dca65509cf", "target": 0, "func": "static int ftp_current_dir(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    const char *command = \"PWD\\r\\n\";\n\n    const int pwd_codes[] = {257, 0};\n\n\n\n    if (!ftp_send_command(s, command, pwd_codes, &res))\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '\"') {\n\n            if (!start) {\n\n                start = res + i + 1;\n\n                continue;\n\n            }\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (!end)\n\n        goto fail;\n\n\n\n    if (end > res && end[-1] == '/') {\n\n        end[-1] = '\\0';\n\n    } else\n\n        *end = '\\0';\n\n    av_strlcpy(s->path, start, sizeof(s->path));\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 15401, "substitutes": {"s": ["secondary", "south", "ses", "m", "service", "t", "d", "sync", "fs", "your", "rs", "sym", "a", "g", "cs", "sites", "S", "new", "sets", "opens", "es", "js", "sq", "session", "server", "ps", "ss", "conf", "o", "p", "e", "socket", "http", "sb", "b", "sf", "data", "f", "gs", "c", "ns", "is", "ssl", "ops", "r", "ds", "services", "ts", "us", "ssh", "aws"], "res": ["ons", "args", "rez", "remote", "ret", "rss", "blocks", "rev", "root", "reply", "Res", "rus", "response", "gr", "rc", "enc", "complete", "rs", "pre", "range", "row", "cs", "details", "req", "nos", "os", "opens", "es", "ros", "RES", "rows", "pres", "ras", "error", "rh", "ps", "request", "ids", "ms", "params", "rec", "ris", "resource", "ver", "rx", "ries", "lines", "result", "resolution", "des", "reset", "arr", "results", "re", "resp", "r", "rep", "ress", "ri", "rest", "reg", "rem", "prev", "RE", "vals", "err"], "start": ["part", "art", "id", "mid", "ish", "style", "pre", "range", "name", "sp", "send", "use", "x", "init", "ie", "Start", "starting", "error", "like", "set", "step", "open", "check", "parse", "ind", "stop", "p", "ad", "info", "size", "min", "length", "from", "count", "none", "line", "address", "next", "first", "offset", "started", "change", "get", "r", "empty", "rest", "work", "pos", "space", "len", "max", "index"], "end": ["en", "END", "End", "event", "use", "x", "nd", "append", "begin", "limit", "vert", "dev", "old", "grade", "c", "offset", "change", "order", "index", "part", "id", "api", "w", "u", "entry", "length", "pend", "url", "ion", "r", "core", "path", "edge", "after", "complete", "update", "value", "ad", "z", "stop", "e", "est", "address", "close", "reset", "ended", "pos", "post", "enc", "code", "object", "range", "name", "send", "patch", "set", "open", "size", "p", "ending", "next", "one", "all", "last", "rest", "max"], "i": ["qi", "it", "ui", "slice", "I", "d", "t", "ai", "ni", "xi", "id", "code", "ini", "gi", "l", "oi", "io", "iu", "api", "ci", "x", "di", "si", "ie", "shift", "ii", "uri", "v", "o", "u", "ind", "iii", "p", "e", "cli", "li", "mi", "ix", "b", "multi", "j", "n", "f", "phi", "ti", "ip", "c", "eni", "reset", "diff", "next", "pi", "r", "bi", "ri", "zi", "y", "in", "index"], "command": ["action", "remote", "escape", "response", "code", "name", "directory", "execute", "operation", "send", "method", "sequence", "comment", "script", "uri", "package", "request", "password", "clear", "resource", "data", "Command", "mode", "resolution", "query", "timeout", "type", "attribute", "function", "cmd", "process", "exec", "pattern", "content", "prefix", "exclusive", "message"], "pwd_codes": ["pwdpcode", "pwd2code", "pwd2codes", "pwdpcod", "pwd_desc", "pwd2cod", "pwdpdesc", "pw_keys", "pw_desc", "pwd_keys", "pwd2desc", "pw_cod", "pwdpcodes", "pw_code", "pwd_cod", "pw_codes", "pwd_code"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opts_print(QemuOpts *opts, void *dummy)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    fprintf(stderr, \"%s: %s:\", opts->list->name,\n\n            opts->id ? opts->id : \"<noid>\");\n\n    TAILQ_FOREACH(opt, &opts->head, next) {\n\n        fprintf(stderr, \" %s=\\\"%s\\\"\", opt->name, opt->str);\n\n    }\n\n    fprintf(stderr, \"\\n\");\n\n    return 0;\n\n}\n", "idx": 15411, "substitutes": {"opts": ["copter", " opter", " opms", "otks", "opments", "optls", "otter", "opcons", "ott", " optcons", " opls", " opks", " opttips", "otls", "operters", "opms", "copts", " opps", "opks", " opments", "opter", "otms", " optters", "opters", " optt", " optments", "otts", " opcons", "optks", " opters", "otters", "opttt", "optter", "optments", "operter", " optts", " opttt", "optt", "optts", "opttips", "opps", "optters", "copms", " optips", "optcons", "optps", "optips", "copters", "opls", "operps", "operts"], "dummy": ["too", "tummy", " dumper", " doo", "Ducky", "Dummy", "Dumper", "dumper", "Doo", "ducky", "tumper", "doo", "tucky", " ducky"], "opt": ["ord", "alt", "oper", "OP", "inter", "ott", "config", "id", "oss", "object", "optim", "null", "option", "txt", "init", "dest", "append", "error", "step", "open", "obj", "grad", "vert", "term", "p", "temp", "options", "info", "pot", "select", "ext", "op", "qt", "dot", "expr", "parent", "skip", "json", "item", "timeout", "cat", "nt", "loop", "iter", "text", "hop", "pos", "num", "Opt", "prev", "go", "err"]}}
{"project": "FFmpeg", "commit_id": "fe448cd28d674c3eff3072552eae366d0b659ce9", "target": 0, "func": "static int jpeg2000_decode_tile(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile,\n\n                                AVFrame *picture)\n\n{\n\n    int compno, reslevelno, bandno;\n\n    int x, y;\n\n\n\n    uint8_t *line;\n\n    Jpeg2000T1Context t1;\n\n\n\n    /* Loop on tile components */\n\n    for (compno = 0; compno < s->ncomponents; compno++) {\n\n        Jpeg2000Component *comp     = tile->comp + compno;\n\n        Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n\n\n        /* Loop on resolution levels */\n\n        for (reslevelno = 0; reslevelno < codsty->nreslevels2decode; reslevelno++) {\n\n            Jpeg2000ResLevel *rlevel = comp->reslevel + reslevelno;\n\n            /* Loop on bands */\n\n            for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n                int nb_precincts, precno;\n\n                Jpeg2000Band *band = rlevel->band + bandno;\n\n                int cblkno = 0, bandpos;\n\n\n\n                bandpos = bandno + (reslevelno > 0);\n\n\n\n                if (band->coord[0][0] == band->coord[0][1] ||\n\n                    band->coord[1][0] == band->coord[1][1])\n\n                    continue;\n\n\n\n                nb_precincts = rlevel->num_precincts_x * rlevel->num_precincts_y;\n\n                /* Loop on precincts */\n\n                for (precno = 0; precno < nb_precincts; precno++) {\n\n                    Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n                    /* Loop on codeblocks */\n\n                    for (cblkno = 0; cblkno < prec->nb_codeblocks_width * prec->nb_codeblocks_height; cblkno++) {\n\n                        int x, y;\n\n                        Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n                        decode_cblk(s, codsty, &t1, cblk,\n\n                                    cblk->coord[0][1] - cblk->coord[0][0],\n\n                                    cblk->coord[1][1] - cblk->coord[1][0],\n\n                                    bandpos);\n\n\n\n                        x = cblk->coord[0][0];\n\n                        y = cblk->coord[1][0];\n\n\n\n                        if (codsty->transform == FF_DWT97)\n\n                            dequantization_float(x, y, cblk, comp, &t1, band);\n\n                        else\n\n                            dequantization_int(x, y, cblk, comp, &t1, band);\n\n                   } /* end cblk */\n\n                } /*end prec */\n\n            } /* end band */\n\n        } /* end reslevel */\n\n\n\n        /* inverse DWT */\n\n        ff_dwt_decode(&comp->dwt, codsty->transform == FF_DWT97 ? (void*)comp->f_data : (void*)comp->i_data);\n\n    } /*end comp */\n\n\n\n    /* inverse MCT transformation */\n\n    if (tile->codsty[0].mct)\n\n        mct_decode(s, tile);\n\n\n\n    if (s->cdef[0] < 0) {\n\n        for (x = 0; x < s->ncomponents; x++)\n\n            s->cdef[x] = x + 1;\n\n        if ((s->ncomponents & 1) == 0)\n\n            s->cdef[s->ncomponents-1] = 0;\n\n    }\n\n\n\n    if (s->precision <= 8) {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n\n\n            y    = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            line = picture->data[plane] + y * picture->linesize[plane];\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint8_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = line + x * pixelsize + compno*!planar;\n\n\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s->cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        *dst = val << (8 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                line += picture->linesize[plane];\n\n            }\n\n        }\n\n    } else {\n\n        for (compno = 0; compno < s->ncomponents; compno++) {\n\n            Jpeg2000Component *comp = tile->comp + compno;\n\n            Jpeg2000CodingStyle *codsty = tile->codsty + compno;\n\n            float *datap = comp->f_data;\n\n            int32_t *i_datap = comp->i_data;\n\n            uint16_t *linel;\n\n            int cbps = s->cbps[compno];\n\n            int w = tile->comp[compno].coord[0][1] - s->image_offset_x;\n\n            int planar = !!picture->data[2];\n\n            int pixelsize = planar ? 1 : s->ncomponents;\n\n            int plane = 0;\n\n\n\n            if (planar)\n\n                plane = s->cdef[compno] ? s->cdef[compno]-1 : (s->ncomponents-1);\n\n\n\n            y     = tile->comp[compno].coord[1][0] - s->image_offset_y;\n\n            linel = (uint16_t *)picture->data[plane] + y * (picture->linesize[plane] >> 1);\n\n            for (; y < tile->comp[compno].coord[1][1] - s->image_offset_y; y += s->cdy[compno]) {\n\n                uint16_t *dst;\n\n\n\n                x   = tile->comp[compno].coord[0][0] - s->image_offset_x;\n\n                dst = linel + (x * pixelsize + compno*!planar);\n\n                if (codsty->transform == FF_DWT97) {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int  val = lrintf(*datap) + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                } else {\n\n                    for (; x < w; x += s-> cdx[compno]) {\n\n                        int val = *i_datap + (1 << (cbps - 1));\n\n                        /* DC level shift and clip see ISO 15444-1:2002 G.1.2 */\n\n                        val = av_clip(val, 0, (1 << cbps) - 1);\n\n                        /* align 12 bit values in little-endian mode */\n\n                        *dst = val << (16 - cbps);\n\n                        i_datap++;\n\n                        dst += pixelsize;\n\n                    }\n\n                }\n\n                linel += picture->linesize[plane] >> 1;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 15420, "substitutes": {"s": ["sys", "m", "ses", "self", "bis", "d", "t", "sg", "service", "sky", "fs", "l", "i", "sync", "g", "cs", "sk", "os", "sets", "js", "si", "scope", "sq", "es", "session", "o", "u", "p", "e", "sec", "cli", "site", "sb", "sf", "n", "f", "gs", "spec", "c", "ns", "ssl", "sv", "sl", "ops", "services", "lex", "ds", "com", "ls", "ts", "space", "sports"], "tile": ["device", "ge", "port", "rice", "te", "slice", "t", "so", "style", "chip", "pixel", "sample", "audio", "image", "tg", "sk", "txt", "ie", "frame", "tri", "tto", "layer", "metadata", "e", "img", "cli", "kt", "site", "component", "ole", "ski", "tif", "setup", "dt", "phy", "tf", "file", "tle", "ele", "scale", "sl", "tu", "coll", "cell", "video", "Tile", "ile", "texture", "node"], "picture": [" f", " Frame", "cam", "fram", "iframe", "fb", "fm", " img", "fps", "audio", " pic", "image", "movie", "ref", "avi", "rame", "document", "media", "img", "fi", "play", "feature", " frame", " image", "mac", "video", "mpeg", "pic"], "compno": ["proplo", "componentno", "playnu", " compnu", "cmpno", "hostyes", "zipnon", "zipnu", "zipyes", "proppos", "hostnum", " compnum", "complo", "playna", "hostpos", "propno", "collpos", "cmporno", "componentlo", " comporno", "propna", "Compnum", " compyes", "hosteno", "compnon", "cmpyes", "comppos", "collnumber", "Compno", "collno", "Compeno", "compeno", "configyes", "domno", "confignon", "domnon", "collna", "hostnumber", "propnumber", "compyes", " compeno", "zipcho", "configno", "zipnumber", "componentpos", "compnum", "configcho", "Compyes", "compcho", "playno", "compnu", "zipna", "hostorno", " compna", "comporno", "componentnumber", "hostna", "playnumber", "compnumber", "cmpna", " complo", "domyes", "hostno", " compnumber", " comppos", "domcho", "compna", "zipno"], "reslevelno": ["resstagenos", "rescolnumber", "reslvlnos", "reslvlno", "reslayernos", "reslayerlo", " reslevelorno", "reslevelnon", "reslayer1", "resstagenumber", "reslevelsno", "reslayernumber", "resfullnos", "resstageno", "rescollno", "reslettern", "resslevelnt", "resalllo", "reslayerno", "reslayername", "resday1", " reslevelnum", "reslevelsnumber", "resslevelno", "resstagenum", "resallno", "resmodelno", "rusday1", "reslevelsorno", "rusdayname", "resletternum", "resdayname", "resmodelnum", "reslevelorno", "reslayernum", "preslayernum", "resfullnumber", "resallnum", "ressletterno", "resslevelnumber", "resscolnumber", " reslayerorno", "rezstageno", "reslvlnt", "resslevelnos", "reslevello", "resslettern", "rezlevelnumber", "reslevelnt", "rescolno", "rezlevelnon", "resfullno", "resletterno", "rezstagenumber", "resstagenon", "rescolnt", "resleveln", "reslevelnumber", " reslevelnumber", "resscolnt", "preslevelnum", "resletternumber", "ruslevelno", "rezstagenos", "reslayerorno", "resallname", "ruslevelname", "resallnos", "preslayernos", "rescolnos", "reslayernon", "preslayerno", "ressleveln", "ressletternum", "reslevelname", "rescollnum", " reslayernumber", "resstageorno", "reslayern", "ruslevel1", " reslayernum", "resmodeln", "reslevelnos", "resfullnon", "rezlevelno", "resscolnos", "ressletternumber", "rezstagenon", "reslayernt", "resslevelnum", " reslayerno", "rescollnos", "reslevelnum", "reslevel1", "preslayerlo", "reslvlnumber", "preslevello", "rescolllo", "resall1", "preslevelnos", "resscolno", "resdayno", "rusdayno", "rezlevelnos", "resmodelnumber", "preslevelno", "reslevelsnum"], "bandno": ["roadpo", "cellnum", "disklo", " bandNo", "tagyes", "bandnon", "roadlo", "blockno", "disksn", "patchno", "tagno", "cellNo", "fieldnumber", "roadno", "compnode", " bandnumber", "tagnu", "bootnum", "bandnos", "tagnos", "bootpo", "cellko", " bandnos", "patchna", " bandna", "bootpos", " bandnon", "blockyes", " bandko", "bootlo", " bandnu", "blockNo", "portNo", " bandeno", "diskno", "portnon", "bandsn", "patchnu", "bootno", " bandorno", "cellpos", "bandnumber", "bandnu", "celleno", "fieldno", "fieldko", "bandpo", "compnumber", "tagNo", "compko", "roadsn", "diskpo", "patchnos", "porteno", "cellno", "bandnode", " bandnum", "tagorno", "portno", " bandyes", "fieldnode", "bandlo", "blockorno", "cellnon", "bandyes", " bandnode", "bandna", "bootsn", "bandeno", "bootko", "tagna", "bandnum", "bandko", "bandNo", "bandorno"], "x": ["m", "d", "t", "on", "l", "i", "code", "val", "a", "name", "ex", "wx", "h", "image", "v", "o", "w", "yx", "dx", "z", "yl", "u", "p", "e", "rx", "b", "ix", "n", "f", "xx", "ax", "ip", "c", "X", "Y", "xy", "xxx", "pos", "height", "index"], "y": ["yt", "m", "d", "t", "_", "id", "lon", "i", "l", "ey", "g", "h", "this", "buffer", "ym", "o", "w", "yi", "dy", "col", "z", "yl", "obj", "p", "e", "b", "yo", "j", "n", "f", "oy", "ay", "vy", "ry", "type", "q", "year", "all", "r", "Y", "ya", "yy", "index", "sy"], "line": ["record", "lin", "code", "val", "l", "Line", "style", "source", "LINE", "cpu", "buffer", "unit", "frame", "output", "lay", "layer", "e", "time", "data", "lines", "mode", "block", "out", "link", "coll", "cell", "len"], "t1": ["t2", "c2", "m3", "c1", "T2", "f2", "t4", "T3", "m1", "tone", " t2", " t3", "T1", "t3", " tone", "f3", "T4", "fone", "c4", "m2", "c3", "m4", "f1", "Tone"], "comp": ["oper", "ch", "cop", "config", "cc", "Component", "Comp", "supp", "pixel", "def", "cond", "lc", "project", "ref", "unit", "cmp", "mod", "con", "loc", "app", "imp", "lib", "col", "prof", "clip", "p", "sec", "pack", "component", "b", "op", "omp", "cel", "dep", "spec", "c", "crit", "par", "pro", "common", "chrom", "coll", "com", "cell", "cp", "mac", "comm", "om", "seq", "prep", "hop", "prop", "company", "coord", "cl", "ctx", "comb"], "codsty": ["Codst", "codedsty", " codestyle", "chempoly", "compgy", "codpoly", "codesty", "compsys", "cmdty", "compsym", " codstyle", "cdety", "codst", "codty", "comppoly", "Codsty", "codedst", "cmdstyle", "cmdsty", " codty", "Codstal", " codsys", "codestyle", "codedety", "Codety", "cdsty", "codstyle", "codety", "codsys", "cbpoly", "cdst", " codsym", "codesys", "cmdsym", "cmdestyle", "codsym", "chemsty", "cmdsys", "codstal", "cbsty", "codedstal", "codeestyle", "cdstal", "compty", "chemgy", "cbgy", "chemty", "codgy", "cbty", "compsty"], "rlevel": ["prflow", "srinc", "arvel", " rpe", "brvel", "arlevel", "srlevel", "rlevels", "clevel", "bsync", "lcl", "arsync", "rinc", "linc", " rcomp", "Rpe", " rinc", "rflow", " rcl", "rpe", "brlevels", "rcl", "llevel", "rletter", " rlevels", "srcl", " rLevel", "clevels", "bvel", "ccoll", "rcomp", " rcoll", "lcomp", "bletter", "srlevels", "Rflow", "prlevels", " rletter", "ccomp", "lvel", "prpe", "lcoll", "Rlevels", "rvel", "rcoll", " rsync", "blevel", "rsync", "brLevel", " rflow", " rvel", "brlevel", "Rlevel", "prlevel", "lLevel", "arletter", "rLevel", "llevels"], "nb_precincts": ["nb_precincted", "nb_precruptes", "nb_precrits", "nb_precincting", "nb_precractes", "nb_preCritions", "nb_precributions", "nb_precresss", "nb_preCinctions", "nb_precruptions", "nb_precrited", "nb_preCrited", "nb_precrupte", "nb_precracts", "nb_precracted", "nb_precractions", "nb_prercruptors", "nb_preCinctes", "nb_preCincted", "nb_precrite", "nb_precinding", "nb_precrupts", "nb_precributs", "nb_preCrits", "nb_precrites", "nb_prercincte", "nb_preCunctes", "nb_precressions", "nb_precritions", "nb_prercincts", "nb_precinctions", "nb_prercinctions", "nb_prercrupts", "nb_precincte", "nb_precribute", "nb_precruptors", "nb_prercinctors", "nb_precrupted", "nb_precinctors", "nb_precunctions", "nb_precinds", "nb_prercruptions", "nb_precindions", "nb_precuncts", "nb_precindes", "nb_preCrites", "nb_precuncting", "nb_preCuncting", "nb_preCincts", "nb_precributors", "nb_precresses", "nb_precressing", "nb_precunctes", "nb_preCuncts", "nb_precinctes", "nb_precritors", "nb_prercrupte", "nb_preCincting", "nb_preCunctions"], "precno": ["prefmo", "prerecauto", "prekNo", "perfNo", "perfnone", "propnos", "prefNo", "prebyes", "procno", "percnone", "prefindex", "prechnone", " preceno", " precnone", "precindex", "prefauto", "perfno", "prebnos", "precnum", "prefeno", "prerecnone", "prepcindex", " prerecno", "precnone", " prerecNo", "precauto", "prerecnum", " precindex", "perfauto", "prechmo", " prepceno", "prercindex", " prepcindex", "prerecNo", "precatno", "prefyes", "prebpo", "precatyes", "prerecmo", "precnos", "percauto", " precmo", " prepcNo", "preknone", "precatnone", "prekyes", "precpo", "prercno", "procyes", "preceno", "prepyes", "perfyes", "preppo", "preacauto", "proppo", "percNo", "percnum", "perfnum", "precatnos", " prerecnone", "percno", "preacNo", " precNo", "percyes", "precmo", "prepnos", "prepno", "prechno", "prebno", "prepcno", "prepceno", "prefnum", "prekno", "propno", "prerceno", "procnos", "prechNo", "prepcNo", " prerecmo", "precyes", " prepcno", "precNo", "prerecno", "precatNo", "prercNo", "prefnone", "propyes", "procpo", "prefno", "preacnum", "preacno", "precatpo"], "band": ["word", "bridge", "device", "camp", "amp", "batch", "bound", "low", "audio", "event", "project", "dev", "play", "flow", "song", "bind", "broad", "book", "cell", "work", "tag", "bin", "part", "d", "ground", "bb", "product", "bus", "group", "Band", "version", "b", "length", "function", "host", "core", "brand", "bands", "service", "style", "bd", "connection", "plane", "guide", "app", "output", "layer", "stage", "boot", "co", "f", "gb", "loop", "ph", "bit", "channel", "board", "code", "back", "range", "bass", "gap", "contact", "pp", "position", "phase", "plugin", "ball", "direction", "component", "mode", "pair", "lab", "now", "cmd", "coll", "db", "coord"], "bandpos": ["groundpos", "bandloc", "bitposition", "Bandno", "bandPos", "cellno", "bitloc", "groundposition", "bootpo", "bandposition", "cellpos", "BandPos", "cellPos", "groundloc", "cellpo", "boardpo", "bitPos", "groundPos", "Bandpo", " bandposition", " bandPos", " bandpo", "bootpos", "bandpo", "bitpos", "boardposition", "Bandpos", "bootposition", " bandloc", "boardpos"], "prec": ["perb", "aref", " prek", "percs", "proc", "proci", "perv", "Preh", "pec", "precs", "arec", "pev", "prk", "calc", "pre", "prcu", "calf", "prc", "precu", "percu", "arecs", "preh", "pecs", "Prec", "perf", "arev", "prof", "Precu", "Preb", "prb", "perci", "prev", "pere", "pree", " pree", "calcu", "prf", "preb", "cale", " pref", "pref", "perh", "perc", "preci", "prh", "Preci", "procu", "pef", "Pref", "prek", "perk"], "cblkno": ["cblpyes", "cblkidyes", "cblcnum", "cblchnor", "cblkkno", "cblktno", "cplkyes", "cplkno", "cplkcho", "cblmknumber", "cbakNO", "cblkidnor", "cblcno", "cbakidno", "cblechno", "cblekpos", "cblktna", "cblkna", "cblqno", "cplqno", "cblknor", "cblkyes", "cblfeno", "cblfno", "cblikna", "cblkenor", "cblekorno", "cblcnumber", "cbleknor", "cmlkno", "cblekno", "cblikNO", "cblktpos", "cblnnum", "cplqcho", "cblechnor", "cblmknum", "cblqcho", "cblchpos", "cblpcho", "cblkNO", "cblmkno", "cplqNO", "cblikpos", "cblechorno", "cmlkeno", "cbakna", "cblfnum", "cblnno", "cblkcho", "cblqyes", "cblkpos", "cmlfno", "cmlfnum", "cblqNO", "cblkidcho", "cbakidna", "cblkeno", "cblechpos", "cblkidNO", "cblneno", "cblikno", "cbakidpos", "cblkidorno", "cblchno", "cbakno", "cblkepos", "cblksno", "cblknum", "cblcinfo", "cbakpos", "cbakidNO", "cblknumber", "cblpNO", "cblkknumber", "cblkidno", "cblkseno", "cmlknum", "cblpno", "cblkinfo", "cmlfeno", "cblksnum", "cblkkinfo", "cplqyes", "cblkidpos", "cplkNO", "cblkeorno", "cblmkinfo", "cblchorno", "cblktNO", "cblkorno", "cblkidna", "cblkknum"], "cblk": ["cblck", "cblke", " crelks", "cbrc", "cplk", "crenak", "cBlke", "cwnc", "cwnb", " cblkin", "ecglck", "cblak", "cablkk", "crelc", "crelks", "callkt", " cablsk", "cglkid", "cablsk", " crelk", "crelb", " crelok", "cBlsk", " crelb", " cablkk", " cblok", "crenk", "cblc", "cronsk", "cllkid", "dblkh", "Cblkin", " cblb", "cglk", " cablk", " cablkin", "crelsk", "cllk", "cBlkin", "cllok", "callsk", "cllc", "cBlc", " cblc", "cablkin", "dmlck", "ecblkin", "crelok", " cblke", "cblkin", "cblkt", "cllck", "ecglkin", "cwnok", "scblak", "cplsk", "crensk", "scablak", "dmlk", "cmlkin", "dmlke", "cbalkin", "callak", "dblck", "cblb", "cronk", "cbrks", "crelk", "cmlck", "cablak", "cbrk", "dblkin", "dmlkin", "cblkid", "dblke", " crelc", " crelsk", "csynk", " crelke", "cllkin", "cglck", "cbrkin", "CBlks", "cronkin", "Cblk", "cBlks", "scblsk", "cronkk", "Cblks", " cblsk", "callk", "scablsk", "ecglkid", "cmlk", "cllb", "cblks", "cblkk", "cplks", "cplke", "scblkt", "csynkk", "cbalck", "CBlk", "CBlc", "scablkt", "cmlke", "scablk", "dblk", "cablkt", "csynsk", "cbalk", "cglkin", " cblkk", "dmlkh", "scblk", "cblkh", "cablk", " cblks", "crelke", "ecblk", "ecblck", "cwnk", "cblok", "cmlkh", "cblsk", "CBlkin", "cllks", "csynkin", "ecblkid", "ecglk", "cBlk", "Cblc", "crenkt", "cbalke"]}}
{"project": "qemu", "commit_id": "158fd3ce98afd21f2e2639600f6414ea703a9121", "target": 0, "func": "void qemu_run_all_timers(void)\n\n{\n\n    alarm_timer->pending = 0;\n\n\n\n    /* rearm timer, if not periodic */\n\n    if (alarm_timer->expired) {\n\n        alarm_timer->expired = 0;\n\n        qemu_rearm_alarm_timer(alarm_timer);\n\n    }\n\n\n\n    /* vm time timers */\n\n    qemu_run_timers(vm_clock);\n\n    qemu_run_timers(rt_clock);\n\n    qemu_run_timers(host_clock);\n\n}\n", "idx": 15434, "substitutes": {}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "static struct XenDevice *xen_be_get_xendev(const char *type, int dom, int dev,\n\n                                           struct XenDevOps *ops)\n\n{\n\n    struct XenDevice *xendev;\n\n\n\n    xendev = xen_be_find_xendev(type, dom, dev);\n\n    if (xendev) {\n\n        return xendev;\n\n    }\n\n\n\n    /* init new xendev */\n\n    xendev = g_malloc0(ops->size);\n\n    xendev->type  = type;\n\n    xendev->dom   = dom;\n\n    xendev->dev   = dev;\n\n    xendev->ops   = ops;\n\n\n\n    snprintf(xendev->be, sizeof(xendev->be), \"backend/%s/%d/%d\",\n\n             xendev->type, xendev->dom, xendev->dev);\n\n    snprintf(xendev->name, sizeof(xendev->name), \"%s-%d\",\n\n             xendev->type, xendev->dev);\n\n\n\n    xendev->debug      = debug;\n\n    xendev->local_port = -1;\n\n\n\n    xendev->evtchndev = xen_xc_evtchn_open(NULL, 0);\n\n    if (xendev->evtchndev == XC_HANDLER_INITIAL_VALUE) {\n\n        xen_be_printf(NULL, 0, \"can't open evtchn device\\n\");\n\n        g_free(xendev);\n\n        return NULL;\n\n    }\n\n    fcntl(xc_evtchn_fd(xendev->evtchndev), F_SETFD, FD_CLOEXEC);\n\n\n\n    if (ops->flags & DEVOPS_FLAG_NEED_GNTDEV) {\n\n        xendev->gnttabdev = xen_xc_gnttab_open(NULL, 0);\n\n        if (xendev->gnttabdev == XC_HANDLER_INITIAL_VALUE) {\n\n            xen_be_printf(NULL, 0, \"can't open gnttab device\\n\");\n\n            xc_evtchn_close(xendev->evtchndev);\n\n            g_free(xendev);\n\n            return NULL;\n\n        }\n\n    } else {\n\n        xendev->gnttabdev = XC_HANDLER_INITIAL_VALUE;\n\n    }\n\n\n\n    QTAILQ_INSERT_TAIL(&xendevs, xendev, next);\n\n\n\n    if (xendev->ops->alloc) {\n\n        xendev->ops->alloc(xendev);\n\n    }\n\n\n\n    return xendev;\n\n}\n", "idx": 15449, "substitutes": {"type": ["types", "device", "Type", "kind", "typ", "domain", "ype", "part", "id", "code", "style", "home", "pre", "name", "py", "null", "user", "module", "unit", "model", "TYPE", "key", "error", "like", "loc", "app", "server", "var", "platform", "col", "role", "size", "plugin", "version", "time", "family", "ver", "mon", "site", "base", "op", "length", "mode", "parent", "block", "pe", "attr", "year", "class", "sub", "prop", "ty", "company", "rel", "y"], "dom": ["bug", "device", "path", "domain", "deep", "root", "typ", "d", "dist", "id", "code", "mid", "rom", "home", "def", "name", " dim", "fun", "low", "virt", "di", "product", "module", "user", "mod", " domain", "ym", "model", "dir", "Dom", "dm", "dy", "mem", "version", "time", "mon", "ver", "du", "data", "mode", "url", "block", "dem", " dyn", "dc", "DOM", "md", "cmd", "debug", "host", "om", "db", "class", "prop", "num", "coord", "dim", "depth", "node"], "dev": ["bug", "device", "development", "kind", "d", " devs", "dist", "id", "priv", " device", "def", "name", "rad", " dim", "fun", "req", "virt", "serial", " def", "di", "user", "Dev", "mod", "comment", "valid", "app", "conf", "prom", "var", "der", "adv", "de", "pub", "mem", "version", "info", "ver", "engine", "data", "inst", "mode", "dis", "des", "diff", "block", "dem", "dc", "DEV", "debug", "dd", "ev", "rel", "dim", "depth", "err"], "ops": ["oper", "proc", "OP", "root", "tx", "uts", "cop", "ob", "rs", "utils", "ups", "Ops", "cs", "oops", "operation", "os", "opens", "OPS", "js", "scope", "operator", "app", "aps", "ps", "pps", "flags", "o", "lib", "obj", "opus", "ms", "opers", "params", "alls", "options", "obs", "eps", "img", "oop", "plugins", "boot", "http", "op", "inst", "apps", "opp", "trans", "bits", "ip", "ns", "ro", "outs", "scripts", "loop", "ents", "ds", "errors", "ips", "hop", "pos", "ts", "vs", "opt"], "xendev": ["xendedruction", "rxendapter", "xendov", "xendingef", "exendiev", "Xendeddev", "xstartev", "exendere", " xendruction", "xenek", " xstartdev", " xstartee", "xendew", "xestef", "xadef", "xestever", "xendedov", "axchangeov", "exenuv", "rxendever", "xchangeiev", "xentef", "axendev", "exenduv", " xnddev", "exndevin", "exendexp", " xndev", "xendederr", "xendingev", "wxendeddev", "xxenderv", "xendruction", "Xendedef", "xadddev", " xenef", "xendeddev", "exndever", "xenterv", "rxenddev", "xndevin", "xenever", "xnderv", "exenddev", "xendedee", "xchangeev", "xendedef", "xstartever", "xendep", "Xenddev", "xestee", "Xendef", "exendef", "wxendederv", "xenev", "xendeng", "xlineev", "xentev", "xentep", "xendsere", "exenew", "xndexp", "xxenddev", "Xendev", "xesterv", "exndiev", " xndov", "axchangeiev", "exenek", "Xendov", "xedgeov", " xendee", " xndever", "xestep", "xendingapter", "xenderev", "xstartiev", "exnddev", "xndeng", "xndiv", "exndef", "wxendedek", "xndever", "xchangedev", "xenapter", "xenddev", "Xendever", " xstartiev", "exenev", "xenov", "axenddev", "xenuv", "xendsev", "xestek", "xndek", "xentere", "xedgeiev", "axendov", "xenderevin", "exndeng", "xstartek", " xstartever", "xadeef", "wxendederr", "rxentdev", "xendedever", "exndov", " xndee", " xendedev", "xstartov", "xadeiev", "xendingerv", "xadderv", "xenef", " xendek", "xenep", "xndiev", " xendedek", "xaddek", "xendee", "xxentov", "exendov", "xxendov", "xadeev", "xenew", "xenduv", "axchangedev", "xentew", " xendedee", "xndov", "wxendiv", " xstartef", "xaddee", "exenef", "xendinguv", "xenterr", "xeniev", "xendsew", "wxendev", "wxendediv", "xnderr", "wxenderr", "xenteng", "xstartee", "xndep", "xestov", "xenderdev", " xndek", " xenee", "exenep", "xendere", "Xendedev", " xendeddev", "xxendev", " xenddev", "xentee", "xentov", "rxentapter", "xendek", "Xendedever", "xxenterv", "rxendedever", "xstartruction", "wxenderv", "xendereng", "xendiv", "xlineef", "exendep", "rxenderv", "xaddef", "exendek", "xenderr", "wxendedev", "xlineiev", "xentdev", "xendederv", "exndek", "xendedexp", "exendew", "xestiev", "xadev", "rxendeddev", " xenev", "xestdev", "xendeduv", " xendiev", "rxentev", "xentiev", "exndev", " xenov", "wxendedef", "xaddev", "xendiev", "rxendev", "xentevin", "xendever", "rxendedek", "xchangeov", "xendapter", "xstartef", "xendedev", "axendiev", "rxendek", " xendever", "xentapter", "xendef", "xadov", "xaddever", "rxendedev", "xendediv", "xndee", "exendevin", "xendedek", "exndexp", "exendever", "xadek", "xentruction", "xenee", " xendef", "xendexp", "xeniv", "xendsdev", " xendov", "xenere", "xxentdev", "xedgeev", " xenerv", "rxenterv", "xestev", "xentek", "exendeng", "xendingdev", "xenderv", " xstartruction", "xstartdev", "xenerv", "exenere", "exendev", "xnddev", "xadever", "xndef", "xxentev", "xlinedev", "xndev", "xadeever", "Xendedov", "axchangeev", " xstartev", "xendevin", "xadexp", " xenderv", "wxendef", "wxendek", "xedgedev", "wxenddev"]}}
{"project": "qemu", "commit_id": "c54616608af442edf4cfb7397a1909c2653efba0", "target": 0, "func": "static void json_message_process_token(JSONLexer *lexer, QString *token, JSONTokenType type, int x, int y)\n\n{\n\n    JSONMessageParser *parser = container_of(lexer, JSONMessageParser, lexer);\n\n    QDict *dict;\n\n\n\n    if (type == JSON_OPERATOR) {\n\n        switch (qstring_get_str(token)[0]) {\n\n        case '{':\n\n            parser->brace_count++;\n\n            break;\n\n        case '}':\n\n            parser->brace_count--;\n\n            break;\n\n        case '[':\n\n            parser->bracket_count++;\n\n            break;\n\n        case ']':\n\n            parser->bracket_count--;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n\n\n    dict = qdict_new();\n\n    qdict_put(dict, \"type\", qint_from_int(type));\n\n    QINCREF(token);\n\n    qdict_put(dict, \"token\", token);\n\n    qdict_put(dict, \"x\", qint_from_int(x));\n\n    qdict_put(dict, \"y\", qint_from_int(y));\n\n\n\n    parser->token_size += token->length;\n\n\n\n    qlist_append(parser->tokens, dict);\n\n\n\n    if (type == JSON_ERROR) {\n\n        goto out_emit_bad;\n\n    } else if (parser->brace_count < 0 ||\n\n        parser->bracket_count < 0 ||\n\n        (parser->brace_count == 0 &&\n\n         parser->bracket_count == 0)) {\n\n        goto out_emit;\n\n    } else if (parser->token_size > MAX_TOKEN_SIZE ||\n\n               parser->bracket_count + parser->brace_count > MAX_NESTING) {\n\n        /* Security consideration, we limit total memory allocated per object\n\n         * and the maximum recursion depth that a message can force.\n\n         */\n\n        goto out_emit_bad;\n\n    }\n\n\n\n    return;\n\n\n\nout_emit_bad:\n\n    /*\n\n     * Clear out token list and tell the parser to emit an error\n\n     * indication by passing it a NULL list\n\n     */\n\n    QDECREF(parser->tokens);\n\n    parser->tokens = NULL;\n\nout_emit:\n\n    /* send current list of tokens to parser and reset tokenizer */\n\n    parser->brace_count = 0;\n\n    parser->bracket_count = 0;\n\n    parser->emit(parser, parser->tokens);\n\n    if (parser->tokens) {\n\n        QDECREF(parser->tokens);\n\n    }\n\n    parser->tokens = qlist_new();\n\n    parser->token_size = 0;\n\n}\n", "idx": 15457, "substitutes": {"lexer": ["Lexe", "codec", "codter", "code", "coder", "Lexers", "legers", "lege", "lexers", "calle", "caller", "linec", "lexeder", " lexers", "lexter", "Lexec", "legeder", "Lexter", "Lexeder", " lexeder", "linter", " lexe", "lexe", "liner", "Lexer", "line", "callter", "leger", "callers", "lexec", " lexter"], "token": ["channel", "word", "KEN", "call", "xml", "translation", "input", "config", "id", "random", "seed", "i", "name", "er", "source", "Token", "event", "wt", "option", "str", "txt", "writer", "comment", "key", "uri", "tree", "o", "element", "document", "parse", "layer", "ok", "info", "atom", "socket", "note", "data", "reader", "json", "oken", "number", "item", "argument", "sn", "text", "iter", "rule", "language", "lex", "field", "template", "author", "tag", "yy", "prefix", "header", "node", "tick", "message"], "type": ["types", "path", "Type", "kind", "call", "typ", "action", "format", "part", "complete", "t", "id", "code", "i", "level", "style", "or", "pre", "name", "api", "py", "method", "TYPE", "key", "like", "error", "value", "o", "set", "size", "version", "p", "e", "time", "info", "handler", "direction", "data", "op", "length", "none", "parent", "spec", "ping", "block", "number", "state", "pe", "link", "field", "class", "tag", "no", "rel", "ty", "lock", "post"], "x": ["m", "d", "t", "on", "id", "code", "i", "l", "name", "ex", "h", "position", "key", "v", "w", "z", "p", "e", "k", "b", "ix", "length", "n", "f", "xx", "c", "number", "xs", "X", "pos", "in", "index"], "y": ["ny", "m", "t", "sky", "id", "i", "ey", "py", "key", "o", "w", "yi", "dy", "z", "size", "p", "e", "s", "k", "b", "yo", "j", "n", "f", "xx", "oy", "ay", "vy", "c", "start", "year", "Y", "ya", "yy", "zy", "index", "sy"], "parser": ["upper", "ger", "arser", "local", "event", "lp", "server", "super", "handler", "driver", "reader", "ler", "list", "magic", "spec", "iter", "book", "lex", "author", "command", "pillar", "message", "args", "context", "self", "part", "slice", "winner", "seed", "manager", "missing", "writer", "comment", "script", "Parser", "client", "loader", "parse", "instance", "pack", "data", "json", "inner", "template", "header", "jack", "python", "database", "xml", "config", "builder", "test", "buffer", "operator", "master", "value", "der", "scan", "processor", "layer", "document", "http", "ars", "block", "man", "ser", "post", "node", "oder", "php", "ner", "root", "input", "worker", "enter", "player", "er", "this", "tree", "plugin", "p", "parent", "wp", "pair", "above", "argument", "now", "file", "rule", "general"], "dict": ["bug", "map", "database", "record", "pkg", "slice", "build", "d", "array", "response", "sync", "po", "config", "code", "object", "style", "def", "auth", "di", "module", "str", "hash", "model", "sum", "dir", "session", "table", "ict", "patch", "conf", "tree", "der", "set", "key", "pass", "obj", "clean", "parse", "document", "doc", "info", "data", "dot", "list", "json", "result", "parent", "pair", "state", "diff", "df", "arr", "cat", "gen", "file", "coll", "dd", "db", "cache", "pillar", "dr", "copy"], "brace_count": ["braceboardlength", "stroke_key", "plateacmatch", "brace\u00b7key", "braceboardkey", "brace_code", "brace_time", "brace_width", "iron_count", "line_catch", "iron_depth", "stroke_time", "brace_catch", "line_size", "brace_size", "braceboardtime", "bracePoolcatch", "line_cond", "open_key", "brace_depth", "brace_field", "line_count", "brace\u00b7count", "iron_field", "repeat_length", "brace_index", "brace64found", "brace_cond", "brace64length", "brace\u00b7size", "open_start", "repeat_cond", "open_length", "iron_code", "plate_count", "stroke_count", "braceacindex", "brace\u00b7start", "stroke_length", "plate_index", "plate_width", "braceboardcount", "plate_match", "plateacindex", "repeat_found", "braceacmatch", "bracePoolsize", "brace\u00b7field", "repeat_count", "brace_found", "braceaccount", "brace\u00b7cond", "brace64count", "bracePoolcond", "brace\u00b7length", "brace\u00b7code", "brace_start", "brace\u00b7depth", "brace_key", "brace64cond", "bracePoolcount", "brace_length", "plateaccount", "brace\u00b7catch", "plateacwidth", "braceacwidth", "open_count", "brace_match"], "bracket_count": ["bracket\u00b7len", "bracket_number", "bracketlesscount", "bracket_flag", "bracket\u00b7group", "bracket_len", "brword_length", "bracket_path", "brace_type", "brword_number", "bracket_group", "branch_size", "bracket_depth", "brace_size", "brace_path", "brace_default", "brace_depth", "bracketlesssize", "bracket_age", "bracket_default", "brword_size", "branch_count", "bracket\u00b7count", "brace_age", "brace_group", "brace_sum", "brace_len", "bracket_sum", "branch_flag", "bracket_type", "bracketlessflag", "bracket_size", "brace_length", "bracket_length", "brword_count"]}}
{"project": "qemu", "commit_id": "076b35b5a56bca57c4aa41044ed304fe9c45d6c5", "target": 0, "func": "static void set_memory_options(uint64_t *ram_slots, ram_addr_t *maxram_size)\n\n{\n\n    uint64_t sz;\n\n    const char *mem_str;\n\n    const char *maxmem_str, *slots_str;\n\n    const ram_addr_t default_ram_size = (ram_addr_t)DEFAULT_RAM_SIZE *\n\n                                        1024 * 1024;\n\n    QemuOpts *opts = qemu_find_opts_singleton(\"memory\");\n\n\n\n    sz = 0;\n\n    mem_str = qemu_opt_get(opts, \"size\");\n\n    if (mem_str) {\n\n        if (!*mem_str) {\n\n            error_report(\"missing 'size' option value\");\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        sz = qemu_opt_get_size(opts, \"size\", ram_size);\n\n\n\n        /* Fix up legacy suffix-less format */\n\n        if (g_ascii_isdigit(mem_str[strlen(mem_str) - 1])) {\n\n            uint64_t overflow_check = sz;\n\n\n\n            sz <<= 20;\n\n            if ((sz >> 20) != overflow_check) {\n\n                error_report(\"too large 'size' option value\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        }\n\n    }\n\n\n\n    /* backward compatibility behaviour for case \"-m 0\" */\n\n    if (sz == 0) {\n\n        sz = default_ram_size;\n\n    }\n\n\n\n    sz = QEMU_ALIGN_UP(sz, 8192);\n\n    ram_size = sz;\n\n    if (ram_size != sz) {\n\n        error_report(\"ram size too large\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n\n\n    /* store value for the future use */\n\n    qemu_opt_set_number(opts, \"size\", ram_size, &error_abort);\n\n    *maxram_size = ram_size;\n\n\n\n    maxmem_str = qemu_opt_get(opts, \"maxmem\");\n\n    slots_str = qemu_opt_get(opts, \"slots\");\n\n    if (maxmem_str && slots_str) {\n\n        uint64_t slots;\n\n\n\n        sz = qemu_opt_get_size(opts, \"maxmem\", 0);\n\n        slots = qemu_opt_get_number(opts, \"slots\", 0);\n\n        if (sz < ram_size) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"maximum memory size (0x%\" PRIx64 \") must be at least \"\n\n                         \"the initial memory size (0x\" RAM_ADDR_FMT \")\",\n\n                         sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        } else if (sz > ram_size) {\n\n            if (!slots) {\n\n                error_report(\"invalid value of -m option: maxmem was \"\n\n                             \"specified, but no hotplug slots were specified\");\n\n                exit(EXIT_FAILURE);\n\n            }\n\n        } else if (slots) {\n\n            error_report(\"invalid value of -m option maxmem: \"\n\n                         \"memory slots were specified but maximum memory size \"\n\n                         \"(0x%\" PRIx64 \") is equal to the initial memory size \"\n\n                         \"(0x\" RAM_ADDR_FMT \")\", sz, ram_size);\n\n            exit(EXIT_FAILURE);\n\n        }\n\n\n\n        *maxram_size = sz;\n\n        *ram_slots = slots;\n\n    } else if ((!maxmem_str && slots_str) ||\n\n            (maxmem_str && !slots_str)) {\n\n        error_report(\"invalid -m option value: missing \"\n\n                \"'%s' option\", slots_str ? \"maxmem\" : \"slots\");\n\n        exit(EXIT_FAILURE);\n\n    }\n\n}\n", "idx": 15482, "substitutes": {"ram_slots": ["ram_Slashes", "ram_flops", "ram_lot", "ram_Slot", "ram_lashes", "ram_Slops", "ram_Slots", "ram_slops", "ram_flots", "ram_slot", "ram_flot", "ram_lots", "ram_lops", "ram_flashes", "ram_slashes"], "maxram_size": ["maxmem_scale", "maxmem_size", "maxmem_SIZE", "maxmem_address", "maxram_scale", "maxram_str", "maxram_address", "maxram_SIZE"], "sz": ["sce", "sinzh", "pszip", "Szy", "dszi", "Sz", "sinzn", "psze", "Sze", "setszy", "szi", " sgz", " szn", "gsiz", "setsz", "sze", "confce", "Sce", "szen", " sce", "wszip", " szh", "tz", "pszen", "tzip", " sza", "Siz", "siz", "sgz", "psq", "sbl", "asgz", "pszn", "sza", "psz", "wsq", "setsiz", " szy", "confzen", "sinze", "gszip", "Szi", "aszen", "eszip", "dsce", "esz", "Szen", " siz", "setszen", "asiz", "dsgz", "dsz", "dsze", "dsza", "psce", "dsbl", "asz", "sinz", "confz", "psiz", "tq", " sze", "dszen", "gsz", "wszh", "wsz", "Szip", "dsiz", "confiz", " sbl", " sq", "dszip", "sq", "Szh", "szy", "aszy", " szi", " szip", "gsza", "tzen", "eszy", " szen", "pszh", "szip", "esze", "pszi", "szh", "asza", "szn"], "mem_str": [" mem_text", "memFstr", "mem_sr", "memPStr", "ram_br", "mem_dr", "gram_sr", "mem_cur", "ram_sta", "mem_text", "gram_Str", "accesskstr", "access_str", "access_source", "memkdr", "memPstruct", "accessksource", "gram_st", "mem_string", "mem_br", "mem_source", "memFcur", "mem_st", "mem___sr", "accesskdr", "mem_inner", "mem___st", "memFdr", "access_dr", "memksource", "ram_struct", " mem_string", "memkcur", "ram_str", "mem_Str", "mem_sta", "memPbr", "ram_dr", "access_cur", "mem_STR", "ram_Str", "accesskcur", "mem___str", "memPstr", "gram_str", "mem___Str", "memkstr", " mem_STR", "mem_struct", "memFsource", "ram_inner"], "maxmem_str": ["maxmem_st", "maxmemenstr", "maxram_arr", "maxmem_string", "maxmem_size", "maxram_st", "maxmemenarr", "maxmemensize", "maxram_Str", "maxmem_br", "maxmem_Str", "maxram_str", "maxmem_arr", "maxmemenst", "maxram_string", "maxram_br"], "slots_str": ["slows_err", "slots_st", "slot_string", "slores_br", "slows_string", "slots_br", "slots_arr", "slot_str", "slows_str", "slows_arr", "slores_Str", "slots_Str", "slots_err", "slots_string", "slores_str", "slot_Str", "slores_st"], "opts": ["experends", "depted", "operments", " opttr", "experts", "appters", " opt", "operrs", "OPt", "operuts", " opters", "OPments", "optts", "depts", "opouts", " optrs", "operters", "deptr", "optrs", "operted", " opttc", " optlets", " opments", "OPtr", " optouts", "roptics", "OPters", "oplets", "OPuts", "operouts", "optr", "oprs", " optc", "opcs", "experpt", "opted", "opert", "optics", "oputs", " opends", "optouts", "optc", "operte", "OPtc", " opttics", " optters", "opters", "apputs", "oppt", " optr", "optt", "optters", " opte", "OPted", "optcs", "opte", "operts", "experters", "expertics", "roppt", "opments", "optuts", "ropts", "OPcs", "experlets", "OPte", "depters", "appts", "appted", " optpt", " optts", "OPts", "roplets", " opted", "experte", "opends", "opt", "opercs", "OPends"], "slots": ["klots", "slows", "klops", "Slips", "lots", "slops", "klans", " slans", "lans", "Slows", "klips", "lows", "lops", " slops", "slans", "Slots", "lips", "Slops", "slips", " slips", " slows"]}}
{"project": "qemu", "commit_id": "b9f7855a50a7cbf04454fa84e9d1f333151f2259", "target": 0, "func": "static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp)\n\n{\n\n    /* We don't actually refresh here, but just return data queried in\n\n     * iscsi_open(): iscsi targets don't change their limits. */\n\n\n\n    IscsiLun *iscsilun = bs->opaque;\n\n    uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff;\n\n\n\n    bs->request_alignment = iscsilun->block_size;\n\n\n\n    if (iscsilun->bl.max_xfer_len) {\n\n        max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len);\n\n    }\n\n\n\n    if (max_xfer_len * iscsilun->block_size < INT_MAX) {\n\n        bs->bl.max_transfer = max_xfer_len * iscsilun->block_size;\n\n    }\n\n\n\n    if (iscsilun->lbp.lbpu) {\n\n        if (iscsilun->bl.max_unmap < 0xffffffff) {\n\n            bs->bl.max_discard =\n\n                sector_limits_lun2qemu(iscsilun->bl.max_unmap, iscsilun);\n\n        }\n\n        bs->bl.discard_alignment =\n\n            sector_limits_lun2qemu(iscsilun->bl.opt_unmap_gran, iscsilun);\n\n    } else {\n\n        bs->bl.discard_alignment = iscsilun->block_size >> BDRV_SECTOR_BITS;\n\n    }\n\n\n\n    if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) {\n\n        bs->bl.max_pwrite_zeroes =\n\n            iscsilun->bl.max_ws_len * iscsilun->block_size;\n\n    }\n\n    if (iscsilun->lbp.lbpws) {\n\n        bs->bl.pwrite_zeroes_alignment =\n\n            iscsilun->bl.opt_unmap_gran * iscsilun->block_size;\n\n    } else {\n\n        bs->bl.pwrite_zeroes_alignment = iscsilun->block_size;\n\n    }\n\n    if (iscsilun->bl.opt_xfer_len &&\n\n        iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) {\n\n        bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len *\n\n                                        iscsilun->block_size);\n\n    }\n\n}\n", "idx": 15486, "substitutes": {"bs": ["bt", "blocks", "bis", "bc", "lbs", "BS", "ins", "iss", "sels", "bb", "fs", "fb", "rs", "bn", "bd", "sync", "cs", "qs", "BC", "os", "bytes", "js", "abc", "ros", "ps", "ss", "ba", "s", "obs", "cks", "pb", "http", "b", "sb", "base", "ums", "bf", "gb", "gs", "bits", "bh", "ns", "bps", "uss", "cb", "outs", "bes", "bas", "blog", "ls", "css", "bos", "lb", "ubs", "las", "bl", "vs", "ts", "us", "ks", "aws"], "errp": ["errr", "erp", "rP", "rr", " errr", "errP", "rp", "erfp", "errfp", "erP", " errfp", " errP", "rfp", "err"], "iscsilun": ["uscslren", "isclitur", "ircsiluna", "iscalun", "iscisluna", "uscsilon", "iscmilur", "miscilaoun", "isculinuna", "uscsiluna", "iscselun", "ISCsiluna", "iscvaleber", "isclesiunt", "iscillu", "isclituna", "iscislunt", "iscselluna", "iscilsunin", "iscryptun", "iscilaun", "ISCsilun", "ircsilunt", "iscillan", "isecsellu", "miscsilun", "iscivalun", "ircslur", "iscilul", "ircsilmun", "uscsilunt", "iscsiluno", "iscsylvunt", "iscilber", "iscilan", "isecsilken", "isciryuna", "isclassuna", "isccomplun", "iscilluna", "uscsilfun", "iscelligun", "iscelligunt", "uscsilmun", "uscslfun", "uscslu", "iscsilund", "isculinunt", "iscvalecon", "iscslund", "iscsilunt", "iscoblmun", "iscSiluna", "ecsilber", "miscsilune", "ircsilul", "iscselur", "micillunin", "miscilaunt", "wicsilken", "iscpirun", "iscislun", "iscsilen", "iscillut", "miscsiluna", "isecsilu", "iscilloren", "iscmilunt", "iscillren", "iscseluna", "iscsylvune", "miscsilunt", "isclesiuna", "iacsilmun", "isculinun", "iscivaluna", "iscSilur", "uscsilcon", "ircsilune", "uscslun", "isclassun", "iscilsune", "uscielunin", "iscvalean", "miscilaune", "ISClitunt", "uscsilut", "sicsilen", "iscsellut", "iscsellmun", "iscsilunin", "iscslfun", "iscielken", "iscmilun", "iscpiruna", "ircslmun", "uscslunin", "iscilaune", "iscsilunion", "isclitunt", "iscvaleken", "isclitul", "isclitfun", "iscslan", "wicillken", "iscryptfun", "iacsiluna", "iscilunt", "iscirymun", "iscsiluna", "usciluna", "iscinelken", "isecsilund", "ircsilu", "iscslu", "iscsellu", "iscsylvun", "iacsilun", "iscilon", "uscsilu", "ecsilun", "iscryptunin", "uscsilune", "iscislurn", "uscslunt", "eclitber", "iscielunt", "isclassren", "micsilunt", "wicsilun", "iscilaon", "iscsiloun", "iscvirtunin", "micsilunin", "ircsilur", "iscslunin", "iscsilur", "iscielu", "iacsellund", "miscilaun", "isclitan", "uscilmun", "iscslur", "iscivalund", "iscillunin", "iscinelen", "iscilaunt", "iscsilber", "iscvaleunt", "misclitun", "iscryptuna", "iscislune", "iscsellune", "micsilun", "ISClituna", "ecsilan", "isecsellken", "wicillun", "iacsellun", "uscielunt", "ircsloren", "iscselken", "sicsilmun", "isccomplund", "isccompluna", "iscoblken", "iscillunion", "iscslun", "sicsilun", "iscsilu", "iscslut", "iscalunin", "iscielun", "iscsiloren", "iscielune", "iscslren", "iacselluna", "iscvalemun", "wicsilunt", "miscsilur", "iscelligken", "iscielmun", "isclesiun", "iscsilcon", "ircsiloren", "iscinelun", "iscilsuna", "ircslu", "isculinmun", "uscsluna", "iscpirmun", "iscilren", "iscislmun", "iscalu", "iscillken", "ircslun", "ircsilut", "iscSilu", "iscvaleen", "micilluna", "iscsilren", "iscmiluna", "ircieluna", "ISCsilunion", "eclitan", "sicsilken", "uscsilren", "isclitunion", "isecsellun", "iscselluno", "isclassunt", "iscsilon", "ircslund", "uscslan", "iscsluna", "ircsilund", "iscislund", "iscsilune", "iscielunin", "isclitun", "iscoblen", "ircielun", "ISCsilunt", "iscoblun", "ircsilun", "uscieluna", "isclitber", "eclitun", "isclustuna", "uscielun", "isciryund", "isclesiune", "ircslunt", "uscsilunin", "iscielul", "iscsilken", "isclustun", "uscilunt", "ircielul", "isecsiluna", "ircielmun", "micsiluna", "ISClitun", "misclitunt", "wicsiluna", "ircsluna", "iscvirtun", "sicinelmun", "iscslune", "iscilaoun", "ircsluno", "iscilsun", "iscsilmun", "isecsilurn", "ircslune", "iscsluno", "ecsilul", "iscillunt", "isecislurn", "ISClitunion", "micillunt", "iscvirtuna", "iscSilun", "uscslon", "iscislut", "iscilmun", "iscslon", "isclustmun", "ircsiluno", "miscsiloun", "iscsilurn", "iscielund", "misclituna", "iscivalmun", "iscilauna", "iscvirtune", "isciluna", "uscsilan", "isclesiut", "iscvaleun", "iscieluna", "iscsilul", "iscelliguna", "isclesioren", "misclitur", "iscpirunt", "uscielcon", "uscilun", "isecsilun", "iscinelmun", "micillun", "iscsilfun", "isecislund", "iscilaren", "isecsellund", "uscslut", "iscisloun", "uscielune", "iscillun", "iscslunt", "sicinelun", "iscslmun", "ircslut", "wicillunt", "iscielcon", "iacsellmun", "iscsylvoun", "isccomplurn", "iscselu", "sicinelken", "isciryun", "isculinund", "iscvaleul", "iacsilund", "iscsloren", "iscvaleuna", "iscsellun", "isculinuno", "isclustul", "iscilun", "eclitul", "isclitcon", "isecislun", "isclitunin", "iscsellken", "uscsilun", "isecisluna", "iscsellund", "sicinelen", "iscillune", "iscselund", "wicilluna", "iscsilut", "iscsilan", "iscielunion", "iscaluna"]}}
{"project": "qemu", "commit_id": "c34d440a728fd3b5099d11dec122d440ef092c23", "target": 0, "func": "static int kvm_set_mce(CPUState *env, struct kvm_x86_mce *m)\n\n{\n\n    return kvm_vcpu_ioctl(env, KVM_X86_SET_MCE, m);\n\n}\n", "idx": 15492, "substitutes": {"env": ["args", "en", "context", "enh", "esp", "enc", "ea", "cv", "config", "iss", "code", "priv", "eu", "iv", "style", "er", "vm", "scope", "v", "conf", "nw", "conn", "np", "impl", "loader", "e", "enable", "viron", "exc", "vs", "state", "eni", "cb", "ov", "uv", "que", "ev", "ec", "environment", "core", "ef", "ctx", "esm", "err"], "m": ["mc", "cm", "d", "l", "i", "fm", "g", "h", "x", "module", "vm", "machine", "v", "tm", "mx", "o", "ms", "gm", "p", "e", "bm", "mi", "k", "mobile", "b", "n", "f", "hm", "address", "am", "c", "M", "md", "man", "dm", "sm"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "void ide_atapi_cmd(IDEState *s)\n\n{\n\n    uint8_t *buf;\n\n\n\n    buf = s->io_buffer;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    {\n\n        int i;\n\n        printf(\"ATAPI limit=0x%x packet:\", s->lcyl | (s->hcyl << 8));\n\n        for(i = 0; i < ATAPI_PACKET_SIZE; i++) {\n\n            printf(\" %02x\", buf[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n    /*\n\n     * If there's a UNIT_ATTENTION condition pending, only command flagged with\n\n     * ALLOW_UA are allowed to complete. with other commands getting a CHECK\n\n     * condition response unless a higher priority status, defined by the drive\n\n     * here, is pending.\n\n     */\n\n    if (s->sense_key == UNIT_ATTENTION &&\n\n        !(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA)) {\n\n        ide_atapi_cmd_check_status(s);\n\n        return;\n\n    }\n\n    /*\n\n     * When a CD gets changed, we have to report an ejected state and\n\n     * then a loaded state to guests so that they detect tray\n\n     * open/close and media change events.  Guests that do not use\n\n     * GET_EVENT_STATUS_NOTIFICATION to detect such tray open/close\n\n     * states rely on this behavior.\n\n     */\n\n    if (!(atapi_cmd_table[s->io_buffer[0]].flags & ALLOW_UA) &&\n\n        !s->tray_open && bdrv_is_inserted(s->bs) && s->cdrom_changed) {\n\n\n\n        if (s->cdrom_changed == 1) {\n\n            ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n            s->cdrom_changed = 2;\n\n        } else {\n\n            ide_atapi_cmd_error(s, UNIT_ATTENTION, ASC_MEDIUM_MAY_HAVE_CHANGED);\n\n            s->cdrom_changed = 0;\n\n        }\n\n\n\n        return;\n\n    }\n\n\n\n    /* Report a Not Ready condition if appropriate for the command */\n\n    if ((atapi_cmd_table[s->io_buffer[0]].flags & CHECK_READY) &&\n\n        (!media_present(s) || !bdrv_is_inserted(s->bs)))\n\n    {\n\n        ide_atapi_cmd_error(s, NOT_READY, ASC_MEDIUM_NOT_PRESENT);\n\n        return;\n\n    }\n\n\n\n    /* Execute the command */\n\n    if (atapi_cmd_table[s->io_buffer[0]].handler) {\n\n        atapi_cmd_table[s->io_buffer[0]].handler(s, buf);\n\n        return;\n\n    }\n\n\n\n    ide_atapi_cmd_error(s, ILLEGAL_REQUEST, ASC_ILLEGAL_OPCODE);\n\n}\n", "idx": 15495, "substitutes": {"s": ["rs", "qs", "new", "js", "si", "server", "ps", "params", "spec", "c", "is", "sl", "states", "in", "args", "south", "m", "self", "bis", "d", "t", "sg", "sync", "fs", "sym", "g", "cs", "es", "session", "client", "w", "u", "an", "b", "ns", "r", "sie", "sis", "sports", "sys", "service", "your", "uploads", "os", "sets", "opens", "o", "stage", "e", "site", "http", "sb", "f", "less", "state", "des", "services", "ls", "comments", "ses", "bs", "l", "a", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "se", "plugins", "ions", "n", "gs", "xs", "stats", "ssl", "ds", "su", "ts", "us", "y"], "buf": ["func", "args", "runner", "vec", "context", "uc", "bc", "queue", "fd", "cv", "tmp", "bs", "rc", "fb", "bd", "uf", "pool", "ref", "buffer", "bag", "fp", "br", "buff", "obj", "mem", "grab", "img", "rb", "pb", "data", "b", "wb", "Buffer", "box", "fab", "Buff", "f", "result", "flow", "sb", "ab", "block", "feed", "cb", "bo", "cap", "cmd", "cf", "aux", "db", "src", "seq", "cur", "pad", "ctx", "alloc"], "i": ["hi", "qi", "ui", "m", "I", "d", "ai", "ni", "xi", "id", "ini", "l", "gi", "iu", "a", "io", "oi", "ci", "h", "x", "di", "si", "ii", "key", "v", "uri", "o", "z", "u", "p", "e", "info", "fi", "mi", "li", "k", "ix", "multi", "j", "count", "n", "f", "length", "ti", "phi", "ip", "pi", "chi", "bi", "r", "ri", "zi", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "d208d1eba3799c58fd6d3602d31de3e686f14aec", "target": 1, "func": "void ff_hevc_luma_mv_merge_mode(HEVCContext *s, int x0, int y0, int nPbW,\n\n                                int nPbH, int log2_cb_size, int part_idx,\n\n                                int merge_idx, MvField *mv)\n\n{\n\n    int singleMCLFlag = 0;\n\n    int nCS = 1 << log2_cb_size;\n\n    LOCAL_ALIGNED(4, MvField, mergecand_list, [MRG_MAX_NUM_CANDS]);\n\n    int nPbW2 = nPbW;\n\n    int nPbH2 = nPbH;\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n\n\n    memset(mergecand_list, 0, MRG_MAX_NUM_CANDS * sizeof(*mergecand_list));\n\n\n\n    if (s->pps->log2_parallel_merge_level > 2 && nCS == 8) {\n\n        singleMCLFlag = 1;\n\n        x0            = lc->cu.x;\n\n        y0            = lc->cu.y;\n\n        nPbW          = nCS;\n\n        nPbH          = nCS;\n\n        part_idx      = 0;\n\n    }\n\n\n\n    ff_hevc_set_neighbour_available(s, x0, y0, nPbW, nPbH);\n\n    derive_spatial_merge_candidates(s, x0, y0, nPbW, nPbH, log2_cb_size,\n\n                                    singleMCLFlag, part_idx,\n\n                                    merge_idx, mergecand_list);\n\n\n\n    if (mergecand_list[merge_idx].pred_flag[0] == 1 &&\n\n        mergecand_list[merge_idx].pred_flag[1] == 1 &&\n\n        (nPbW2 + nPbH2) == 12) {\n\n        mergecand_list[merge_idx].ref_idx[1]   = -1;\n\n        mergecand_list[merge_idx].pred_flag[1] = 0;\n\n    }\n\n\n\n    *mv = mergecand_list[merge_idx];\n\n}\n", "idx": 15515, "substitutes": {"s": ["acs", "sys", "ses", "self", "bis", "service", "t", "sync", "sg", "fs", "l", "g", "cs", "qs", "S", "settings", "os", "sets", "js", "si", "es", "sq", "session", "server", "v", "ps", "storage", "ss", "o", "p", "e", "ions", "plugins", "groups", "site", "b", "sf", "sb", "n", "f", "gs", "spec", "c", "ns", "xs", "is", "sc", "ssl", "cases", "services", "r", "ds", "ops", "sa", "ls", "sis", "ts", "us", "ctx"], "x0": ["X90", " x00", "x2", "y2", " x1", "X1", "x00", " x2", "ex00", "ax1", "ex1", "ex0", "ax2", "ax0", "y1", " x90", "y00", "x90", "ax90", "X0", "ex2", "X2", "x1"], "y0": ["sy0", "dy2", "sy2", "Y2", "ey50", "Y80", "y2", " y50", "Y1", " y1", " y25", "y50", "dy0", "y80", "Y00", "vy00", "ey25", "idy8", "y1", " y8", "sy50", "y00", "dy1", "vy8", "Y0", "ey2", "ye0", "idy0", "ey0", " y00", "dy00", "y25", "vy0", "ye1", "ye80", "y8", " y80", "idy00", " y2", "sy25"], "nPbW": ["nPbhL", "nPfL", "nPkL", "nCdG", "nPcWh", "nPcGW", "nCdEng", "nTbGW", "nPfGW", "nPfW", "nPkH", "nPpL", "nPcL", "nPbGW", "nCdL", "nNcW", "nNbWe", "nPcG", "nPdG", "nNbW", "nTbL", "nPnWe", "nNbL", "nTkW", "nPcW", "nPfWe", "nTkH", "nCbW", "nCbEng", "nTbH", "nPkW", "nPdEng", "nPbhW", "nPbhEng", "nNbG", "nPpWh", "nNdG", "nNcWe", "nPbG", "nPcWe", "nPbhG", "nPbEng", "nPnWh", "nCbG", "nNcH", "nTbW", "nNbH", "nTkL", "nPdL", "nPkGW", "nPcH", "nPnL", "nPbL", "nPnG", "nNcWh", "nPpW", "nNdL", "nNbWh", "nNdWh", "nCdW", "nPdW", "nPpWe", "nTkGW", "nPfH", "nPkWe", "nCbL", "nPnW", "nPbWh", "nPcEng", "nNdW", "nPbWe", "nNcL", "nPdWh"], "nPbH": ["nQmbHi", "nPyW", "nPfHi", "nQdH", "nFcRH", "nNcHP", "nNdG", "nNbW", "nPmbSH", "nPbbM", "nQbHi", "nPpH", "nFbRH", "nPbaH", "nPbM", "nPbHi", "nPbrSH", "nPmbHi", "nQbY", "nPbS", "nPyh", "nPbY", "nFcM", "nPcH", "nPcRH", "nNdW", "nFcH", "nPvRH", "nPmbY", "nPbHH", "nFbSH", "nPmbH", "nNbh", "nPebW", "nPebH", "nPyH", "nQmbW", "nQmbY", "nPdS", "nPbrH", "nNdH", "nFbM", "nQdS", "nPdH", "nPfH", "nQbS", "nPbbRH", "nNdSH", "nPbaW", "nPyHP", "nPvSH", "nPebS", "nNch", "nQbH", "nPdG", "nPfY", "nNbG", "nPch", "nPmbW", "nPbh", "nFbH", "nPbSH", "nPcM", "nPbrW", "nNcH", "nPvH", "nPpW", "nPmbG", "nPendW", "nQbHH", "nPbrG", "nPfW", "nPendHP", "nNcW", "nPcW", "nPbbH", "nPvM", "nPendH", "nPbaHi", "nPdSH", "nPpHH", "nNbSH", "nPcSH", "nPbG", "nPbaY", "nQmbH", "nPbRH", "nFcSH", "nPpS", "nPebHH", "nPbHP", "nNbH", "nQdHH", "nNbHP", "nPdW", "nPcHP", "nQdW", "nPendh", "nQbW", "nPdHH", "nPbbSH"], "log2_cb_size": ["log2_cv_size", "log2_cb_SIZE", "log2_cv2size", "log2_cb_sec", "log2_cb2SIZE", "log2_cv2scale", "log2_cb2scale", "log2_cb_len", "log2_db_small", "log2_cv_len", "log2_cb2len", "log2_cv2SIZE", "log2_cv_sec", "log2_cv_scale", "log2_cb2sec", "log2_cb2size", "log2_db_size", "log2_cb_scale", "log2_cv_SIZE", "log2_cb_small", "log2_db_sec"], "part_idx": ["part_idn", "part_idX", "part_ridX", "part_ridxes", "part_IdX", "part_idxe", "part_ridx", "part_IDx", "part_Idx", "part_Idxs", "part_Idz", "part_IDX", "part_idz", "part_Idxe", "part_Idxes", "part_ridxs", "part_ridz", "part_Idn", "part_idxes", "part_ridxe", "part_IDn", "part_idxs", "part_IDxs"], "merge_idx": ["merge__IdX", "merge_Idxs", "merge_idX", "merge_idn", "merge__idx", "merge_IDc", "merge_IDy", "merge_Idx", "merge_Idcy", "merge__idX", "merge_ridc", "merge_kidy", "merge_ridz", "merge__Idxs", "merge_Idy", "merge_Idcent", "merge_indexx", "merge_ilcent", "merge__Idxb", "merge_kidx", "merge_kidcy", "merge_idxe", "merge__idxb", "merge__Idx", "merge_idsz", "merge_iden", "merge_indexxb", "merge_IDxe", "merge_idsy", "merge_idxb", "merge_ilx", "merge_Idxb", "merge_idex", "merge_idec", "merge_ridy", "merge_IDx", "merge_idxs", "merge_endy", "merge_idc", "merge_idy", "merge_endz", "merge_ridn", "merge_idz", "merge_Idz", "merge_ilz", "merge_indexX", "merge_ilc", "merge_kidz", "merge_Idc", "merge_idcent", "merge_indexxs", "merge_endx", "merge_IdX", "merge__idxs", "merge_idsx", "merge_idsxs", "merge_idcy", "merge_idey", "merge_ridxs", "merge_Idxe", "merge_endxs", "merge_ridx"], "mv": ["mc", "pw", "Mv", "Mf", "mf", "pc", " mb", "Mw", " mc", "Mb", "cmc", "cmf", "mb", "cmv", " mw", "Mc", " mf", "pb", "pv", "mw", "cmw"], "lc": ["acs", "cm", "bc", "uc", "rc", "cc", "pc", "l", "lic", "ci", "cs", "dl", "lp", "cci", "cn", "ld", "loc", "lr", "kl", "ku", "nc", "li", "cli", "tc", "cus", "acl", "uci", "c", "cu", "fc", "jc", "lu", "dc", "icc", "vc", "oci", "ls", "lb", "lv", "ln", "ctx", "LC"]}}
{"project": "qemu", "commit_id": "5f706fdc164b20b48254eadf7bd413edace34499", "target": 1, "func": "int s390_cpu_write_elf64_note(WriteCoreDumpFunction f, CPUState *cs,\n\n                              int cpuid, void *opaque)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    return s390x_write_all_elf64_notes(\"CORE\", f, cpu, cpuid, opaque);\n\n}\n", "idx": 15517, "substitutes": {"f": ["proc", "m", "interface", "fd", "d", "t", "fs", "l", "fb", "framework", "fm", "g", "h", "fx", "fo", "fp", "fn", "fr", "F", "p", "e", "fi", "sf", "b", "n", "bf", "fe", "c", "df", "tf", "function", "xf", "cf", "rf", "fac", "fc", "fen"], "cs": ["args", "acs", "mc", "cow", "fs", "pc", "cc", "rs", "ows", "lc", "CS", "os", "ace", "Cs", "ps", "cons", "s", "nc", "vs", "ix", "cus", "spec", "c", "ns", "dc", "ac", "ics", "cas", "sc", "ce", "cp", "ds", "cache", "ec", "css", "ips", "ls", "core", "ctx", "ks"], "cpuid": ["paid", "ppuid", " tcpuu", " cpUID", " cpid", "cpUID", " tcpuid", "cpupid", "cpaid", "epUID", "epupid", "pid", "ppupid", " cpuu", "cpuu", " tcpid", "epid", "ppUID", " cpupid", "cpid", "epuid", "puid", " tcpaid", "puu", " cpaid", "ppid"], "opaque": ["opace", "oopque", "ospacity", "opec", "opsec", "opsacity", "operace", "ospque", "operacity", "ospaques", "opaques", "opsaque", "operaque", "oopaque", "opacity", "operque", "ospaque", "operec", "opque", " opacity", "opsace", " opec", "oopacity", "operaques", " opace", "oopaques"], "cpu": ["proc", "bench", "cow", "fs", "pc", "io", "lc", "os", "pool", "vm", " cp", "linux", "performance", "fp", "pu", "platform", "conn", "processor", "GPU", " CPU", "CPU", "uci", "c", "proxy", "cu", "gpu", "fc", "clock", "cf", "cp", "cache", "ec", "css", "core", "ctx", "phy"]}}
{"project": "FFmpeg", "commit_id": "f1e173049ecc9de03817385ba8962d14cba779db", "target": 0, "func": "static void encode_clnpass(Jpeg2000T1Context *t1, int width, int height, int bandno, int *nmsedec, int bpno)\n\n{\n\n    int y0, x, y, mask = 1 << (bpno + NMSEDEC_FRACBITS);\n\n    for (y0 = 0; y0 < height; y0 += 4)\n\n        for (x = 0; x < width; x++){\n\n            if (y0 + 3 < height && !(\n\n            (t1->flags[y0+1][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+2][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+3][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG)) ||\n\n            (t1->flags[y0+4][x+1] & (JPEG2000_T1_SIG_NB | JPEG2000_T1_VIS | JPEG2000_T1_SIG))))\n\n            {\n\n                // aggregation mode\n\n                int rlen;\n\n                for (rlen = 0; rlen < 4; rlen++)\n\n                    if (t1->data[y0+rlen][x] & mask)\n\n                        break;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_RL, rlen != 4);\n\n                if (rlen == 4)\n\n                    continue;\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen >> 1);\n\n                ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + MQC_CX_UNI, rlen & 1);\n\n                for (y = y0 + rlen; y < y0 + 4; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        if (y > y0 + rlen)\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            } else{\n\n                for (y = y0; y < y0 + 4 && y < height; y++){\n\n                    if (!(t1->flags[y+1][x+1] & (JPEG2000_T1_SIG | JPEG2000_T1_VIS))){\n\n                        int ctxno = ff_jpeg2000_getsigctxno(t1->flags[y+1][x+1], bandno);\n\n                        ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, t1->data[y][x] & mask ? 1:0);\n\n                        if (t1->data[y][x] & mask){ // newly significant\n\n                            int xorbit;\n\n                            int ctxno = ff_jpeg2000_getsgnctxno(t1->flags[y+1][x+1], &xorbit);\n\n                            *nmsedec += getnmsedec_sig(t1->data[y][x], bpno + NMSEDEC_FRACBITS);\n\n                            ff_mqc_encode(&t1->mqc, t1->mqc.cx_states + ctxno, (t1->flags[y+1][x+1] >> 15) ^ xorbit);\n\n                            ff_jpeg2000_set_significance(t1, x, y, t1->flags[y+1][x+1] >> 15);\n\n                        }\n\n                    }\n\n                    t1->flags[y+1][x+1] &= ~JPEG2000_T1_VIS;\n\n                }\n\n            }\n\n        }\n\n}\n", "idx": 15520, "substitutes": {"t1": ["portae", "tau", "templateah", "tt61", "taOne", "yus", "tapp", "p3", "template100", "templateae", "t100", "T61", "retra", " t81", "port1", "untus", "t9", "t3", " tone", "y1", "attron", "ret1", "tt1", "ta6", "tsus", "attOne", "at81", "y01", "templateapp", "yah", "tsae", "t61", "theached", "attae", "tae", " tself", "p2", "templateOne", " tup", "yself", "T2", "y100", "ttron", "at01", "atached", "atae", "tup", "at121", "tron", "unt1", "tone", " t3", " t61", "tOne", "antself", "Tone", "untca", "ts61", "t81", "ts100", "tached", "antau", "pone", "it1", "taself", "the01", "retOne", "ta1", " tOne", "ts01", "port31", "attra", "the81", "tsca", "tca", "t01", "T3", "ttau", "p1", "yau", "itOne", "ts2", " t100", " t9", "tt6", "ts1", "tus", "template121", "yca", "unt01", "itae", "tt81", "ttah", "templateau", "template1", "ttself", " tached", "t6", "y61", "retron", "ts81", "t2", "tra", "at1", "it31", "ttra", "t121", "att31", "t31", "ts9", "tsup", "ant1", "tself", "portOne", "the1", "ttOne", " t6", " t2", "yapp", " tau", "ts121", "T1", "tt100", "template61", "tah", "T9", "ttup", " t01", "ttapp", "yOne", "template01", "ant100", "att1"], "height": ["head", "Height", "input", "thin", "d", "bottom", "id", "level", "density", "shape", "style", "row", "gap", "image", "h", "crop", "win", "w", "alpha", "view", "size", "pad", "direction", "three", "data", "length", "padding", "resolution", "inches", "above", "dim", "angle", "layout", "volume", "high", "window", "depth", "fw"], "bandno": ["cbnumber", "bandnumber", " bcNo", " bcno", "cbno", "bandnum", " bcnum", "bpnum", "bpnumber", "cbnum", "bandNo", "bpNo", "cbNo", " bcnumber"], "nmsedec": ["nmsledec", "nmsedisc", "nmmhedisc", "nmsedef", "nmmedEC", "nmmhedec", "nmmedef", "nmmhedef", "nmshedisc", "nmsledisc", "nmsedsEC", "nmmedisc", "nmsedEC", "nmsedsisc", "nmmedec", "nmsedsec", "nmshedef", "nmsedsef", "nmsledEC", "nmshedEC", "nmmhedEC", "nmshedec", "nmsledef"], "bpno": ["npnos", "pbeno", "bpnumber", "BPeno", "BPnos", "bpnos", "BPnumber", "BPNO", "npno", "BPno", "npNO", "pbNO", "npnumber", "pbno", "cpnos", "bpeno", "cpno", "cpNO", "pbnumber", "cpnumber", "bpNO", "cpeno"], "y0": ["sy0", "gy8", "yt0", "y2", "ey150", "dy0", "ky180", "ey250", "sy00", "x0", "ry80", "y80", "ry080", " yku", "y1", " y150", "y00", "ry0", "Y0", "ye180", "ye0", "ey0", "y8", "Y192", "x1", "num", "x2", "sy150", "ya050", "y100", "vy150", "y050", "g", "ky100", "yku", "s", "sy50", "ky0", "eyku", "ay6", "ey100", "dy00", " y100", "yt00", "ey080", "syee", "x050", "sy8", "eyee", "sy2", "gy0", "ey180", "Y1", " y1", "yt80", "x00", "syku", "y250", "y90", "sy80", "dy8", "ry1", "ky250", "sy1", "ry050", "ya50", "ay150", "x100", " y00", "ry90", "ey6", "ry00", "vy6", "ya00", "gy00", "ye100", "Y2", "ey90", "ey50", "sy192", " y90", " y50", "_", "dy50", "x192", "ey00", " y050", "gy50", "y50", "y180", " yee", "y6", "ay90", "sy050", "y080", "vy90", "yt050", "ya0", "ay0", "ey050", "ry100", "ye250", "all", "vy0", " y080", "y192", "ey1", "yee", "y150"], "x": ["m", "tx", "python", "d", "t", "on", "xi", "id", "l", "i", "any", "ww", "plus", "name", "ex", "g", "image", "h", "fx", "wx", "event", "xp", "full", "px", "v", "ct", "value", "win", "w", "yx", "dx", "z", "u", "ady", "p", "e", "time", "ctx", "s", "rx", "b", "ix", "j", "n", "f", "xx", "ax", "c", "xs", "pe", "X", "sex", "wa", "xc", "xy", "pos", "num", "el", "day", "lat", "in", "bit", "index"], "y": ["ny", "yt", "m", "d", "t", "sky", "i", "iy", "say", "name", "ey", "py", "h", "cy", "gy", "ym", "v", "yer", "w", "dy", "col", "yi", "z", "ady", "yl", "p", "bot", "uy", "b", "j", "n", "f", "ay", "c", "vy", "type", "year", "Y", "ya", "xy", "yy", "hop", "ty", "zy", "index", "sy"], "rlen": ["rrlon", "plin", "errler", "drlim", "prfin", "rlength", "hLen", "errdl", "rrval", "rval", "rrlim", "rden", "rrlen", "rtler", "mlen", "drden", "erlen", "plen", " rLen", "rrden", "errlen", "arlon", "nrLen", "arlen", "arLen", "mli", "mLen", "rsplit", "rrfin", "nrval", "rln", "hlen", "hden", "srlength", "nrlon", "prlen", "drlen", "erdl", "prsplit", "nrlength", "Rbl", "crlen", "mln", "drfin", "rfin", "plon", " rlength", "hval", "Rln", "rli", "rrsplit", "drlength", "srlen", "drdl", "RLen", "rtlen", "arlin", "erler", "rrLen", "rbl", "crlon", "rtden", "srLen", "rrlength", "drsplit", "rlin", " rval", "rLen", "rlim", "prlim", "hbl", "Rlen", "Rval", "Rlon", "rrbl", "rdl", "hlength", "Rli", "hdl", "nrlen", "errden", "crLen", "srli", "pLen", "Rlin", "crval", "rler", "srln", "rrdl", "rtdl", "crlength", "rlon", "Rlength", "srval", "erden"]}}
{"project": "qemu", "commit_id": "aea390e4be652d5b5457771d25eded0dba14fe37", "target": 0, "func": "static int ppc_hash64_pte_update_flags(struct mmu_ctx_hash64 *ctx,\n\n                                       target_ulong *pte1p,\n\n                                       int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & HPTE64_R_R)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= HPTE64_R_R;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & HPTE64_R_C)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= HPTE64_R_C;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 15521, "substitutes": {"ctx": ["sem", "proc", "context", "tx", "pkg", "cm", "qa", "ca", "sync", "cv", "rc", "config", "cc", "jp", "msg", "gc", "lc", "ctrl", "ci", "conv", "cn", "cmp", "sq", "loc", "conn", "client", "grad", "comp", "c", "cca", "gpu", "cb", "cas", "sc", "nt", "cmd", "cf", "cp", "exec", "kb", "mac", "cache", "xc", "qq", "prefix", "alloc"], "pte1p": ["pte2p", "pte8n", "pte121d", "ptc1pc", "pte1j", "pte4p", "pte4post", "pte01p", "pte9a", "pte3pc", "pte8p", "pte121pe", "ptse1j", "ptc2p", "pte9i", "ptque1post", "ptc2f", "ptque1p", "ptse6r", "ptea8p", "pte1a", "pte2b", "pte9p", "ptee1pc", "pte3p", "ptque121p", "pte2d", "pte6f", "pte6r", "pte2f", "ptque121post", "ptea1i", "pte9pc", "ptc2a", "pte3b", "ptse6p", "ptee2pc", "pte6pc", "pte6p", "pte01r", "pte11d", "ptse6j", "pte11b", "pte01j", "ptse1pc", "pte121post", "pte4pe", "ptee2d", "pte121p", "pte18d", "pte1b", "pte2a", "ptque121pe", "ptee2b", "ptea8f", "pte8i", "ptea8i", "ptque121d", "ptea1p", "pte8f", "pte01pc", "ptee1d", "pte1n", "pte18pe", "pte3d", "ptee1b", "pte1post", "ptc1a", "ptque1pe", "pte1i", "pte6j", "ptee1p", "pte9f", "pte1d", "ptee2p", "pte0p", "pte6i", "pte11f", "pte1f", "pte9n", "ptse1p", "pte0pc", "pte4d", "ptse6pc", "ptc1f", "ptea8n", "pte1r", "pte18post", "pte6n", "pte11a", "ptse1r", "ptea1f", "pte0r", "pte2pc", "pte1pe", "ptc1p", "pte11pc", "ptque1d", "ptc2pc", "ptea1n", "pte18p", "pte0j", "pte11p", "pte1pc"], "ret": ["alt", "secret", "ft", "reply", "val", "back", "def", "rets", "ref", "session", "pub", "sec", "match", "success", "Ret", "entry", "result", "store", "protected", "att", "protect", "reset", "arr", "route", "offset", "nt", "re", "rt", "sur", "resp", "last", "pat", "RET", "res", "reg", "rf", "flag", "len"], "rw": ["rr", "wk", "rss", "vr", "rc", "our", "ww", "ctr", "ride", "req", "rn", "wx", "sw", "rg", "sr", "wit", "raf", "rh", "nw", "kw", "w", "lr", "rb", "rx", "wb", "rack", "rl", "route", "wa", "rt", "rest", "dr", "RW", "wrap", "rf", "usr", "rue", "wr", "fw"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "BlockAIOCB *dma_bdrv_write(BlockDriverState *bs,\n\n                           QEMUSGList *sg, uint64_t sector,\n\n                           void (*cb)(void *opaque, int ret), void *opaque)\n\n{\n\n    return dma_bdrv_io(bs, sg, sector, bdrv_aio_writev, cb, opaque,\n\n                       DMA_DIRECTION_TO_DEVICE);\n\n}\n", "idx": 15524, "substitutes": {"bs": ["sys", "ses", "as", "bc", "ob", "BS", "fs", "iss", "bb", "fb", "rs", "bd", "cs", "qs", "os", "js", "ps", "ss", "bp", "obj", "ba", "obs", "s", "pb", "Bs", "sb", "b", "base", "bh", "ns", "bps", "bes", "bas", "ds", "bi", "db", "ls", "lb", "bos", "vs"], "sg": ["isu", "ses", "ys", "irs", "gc", "g", "cs", "pg", "tg", "sk", "rg", "std", "sr", "si", "fg", "sq", "storage", "ss", "gd", "gm", "s", "rb", "sf", "sd", "sb", "GS", "gs", "gb", "cfg", "spec", "sc", "ssl", "ds", "ga", "sa", "su", "db", "ls", "sis", "gp"], "sector": ["channel", "termin", "transfer", "port", "sys", "context", "bc", "queue", "series", "tier", "config", "io", "section", "buffer", "si", "fp", "server", "slave", "storage", "conn", "region", " sectors", "sec", "socket", "buf", "pointer", "sb", "driver", "sf", "mode", "address", "state", "proxy", "offset", "db", "sa", "ser", "ector", "tty", "ipher"], "cb": ["func", "done", "bc", "cv", "ob", "pc", "bb", "fb", "obb", "ctr", "ctrl", "fun", "orb", "cor", "cmp", "abc", "fp", "buff", "CB", " callback", "rb", "pb", "buf", "sb", "bf", "c", "dc", "eb", "rob", "cf", "cod", "cp", "abb", "db", "src", "seq", "cur", "ctx", "callback"], "opaque": [" opaques", "paque", "iopca", "pac", "OPca", "opac", "ipque", "opaques", "opca", "operaque", "paques", "ipacity", "operque", "ipaque", "opacity", " opac", "iopaque", "ipca", "OPacity", "iopacity", " opque", "OPque", "opque", " opacity", "OPaque", "iopque", "operac", "operaques", " opca", "pque"]}}
{"project": "qemu", "commit_id": "b6d36def6d9e9fd187327182d0abafc9b7085d8f", "target": 0, "func": "static int discard_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters, enum qcow2_discard_type type, bool full_discard)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_l2_entry;\n\n\n\n        old_l2_entry = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /*\n\n         * If full_discard is false, make sure that a discarded area reads back\n\n         * as zeroes for v3 images (we cannot do it for v2 without actually\n\n         * writing a zero-filled buffer). We can skip the operation if the\n\n         * cluster is already marked as zero, or if it's unallocated and we\n\n         * don't have a backing file.\n\n         *\n\n         * TODO We might want to use bdrv_get_block_status(bs) here, but we're\n\n         * holding s->lock, so that doesn't work today.\n\n         *\n\n         * If full_discard is true, the sector should not read back as zeroes,\n\n         * but rather fall through to the backing file.\n\n         */\n\n        switch (qcow2_get_cluster_type(old_l2_entry)) {\n\n            case QCOW2_CLUSTER_UNALLOCATED:\n\n                if (full_discard || !bs->backing_hd) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_ZERO:\n\n                if (!full_discard) {\n\n                    continue;\n\n                }\n\n                break;\n\n\n\n            case QCOW2_CLUSTER_NORMAL:\n\n            case QCOW2_CLUSTER_COMPRESSED:\n\n                break;\n\n\n\n            default:\n\n                abort();\n\n        }\n\n\n\n        /* First remove L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (!full_discard && s->qcow_version >= 3) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        } else {\n\n            l2_table[l2_index + i] = cpu_to_be64(0);\n\n        }\n\n\n\n        /* Then decrease the refcount */\n\n        qcow2_free_any_clusters(bs, old_l2_entry, 1, type);\n\n    }\n\n\n\n    qcow2_cache_put(bs, s->l2_table_cache, (void **) &l2_table);\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 15530, "substitutes": {"bs": ["sys", "ses", "bis", "bc", "lbs", "BS", "fs", "iss", "sync", "bb", "ins", "fb", "bn", "cs", "os", "bytes", "js", "ps", "ss", "obs", "bm", "plugins", "pb", "b", "sb", "base", "banks", "gs", "gb", "bits", "bh", "ns", "bps", "cb", "outs", "stats", "bes", "eb", "bas", "als", "ds", "bi", "db", "ls", "css", "bos", "lb", "ts", "las", "bl", "vs", "abi"], "offset": ["location", "Offset", "part", "slot", "slice", "config", "seed", "align", "reference", "nb", "ref", "position", "fp", "table", "o", "size", "online", "info", "pointer", "base", "entry", "length", "padding", "address", "timeout", "reset", "cache", "rot", "inet", "seq", "off", "pos", "prefix", "addr", "alias", "len", "alloc", "index", "start"], "nb_clusters": ["nb_oclumers", "nb_plers", "nb_shicas", "nb__clops", "nbofclards", "nb__collusters", "nb_CLuster", "nbJcousters", "nb_chroups", "nb_clers", "nb_shusters", "nb_clores", "nbofclients", "nbJcoumers", "nb_sclusters", "nb_labodes", "nb__clards", "nb_clumers", "nb_clgroups", "nb__collodes", "nb_shumers", "nb_plumers", "nb_blusters", "nbJclroups", "nb_Clibraries", "nb__collops", "nb_chancers", "nbofclusters", "nb_blodes", "nb_plgroups", "nb_plusters", "nb_collibraries", "nb_sclroups", "nb__collards", "nb_coancers", "nb_labops", "nb_clodes", "nb_sclancers", "nb_Clards", "nb_CLores", "nb_llusters", "nb_Clients", "nb_collusters", "nb_clops", "nb_clicas", "nb_CLers", "nb_shgroups", "nb_clients", "nb_clancers", "nb_ocluster", "nb_oclgroups", "nb_labards", "nb_blops", "nb_llients", "nb_pluster", "nb_oclicas", "nbofcollibraries", "nb_chumers", "nb_cousters", "nb_collodes", "nb_collards", "nbofcollients", "nb_chusters", "nbJcoroups", "nb_sclumers", "nb_collients", "nbJclancers", "nb__clusters", "nb_cluster", "nb_oclers", "nbJclusters", "nbofcollusters", "nbJcoancers", "nb_llibraries", "nb_plores", "nb_coroups", "nbofcollards", "nb_clibraries", "nb_labusters", "nb__clodes", "nb_llards", "nb_CLusters", "nb_blards", "nb_clroups", "nb_collops", "nb_oclores", "nb_clards", "nb_Clusters", "nbJclumers", "nb_oclusters", "nbofclibraries", "nb_plicas", "nb_coumers"], "type": ["types", "Type", "kind", "port", "typ", "sys", "format", "slot", "t", "id", "code", "val", "style", "name", "sp", "unit", "method", "TYPE", "ct", "error", "unknown", "o", "obj", "p", "e", "info", "pb", "base", "op", "none", "parent", "block", "pe", "single", "change", "rule", "out", "class", "off", "ty", "y"], "full_discard": ["full_recarded", "full_drart", "full_diarded", "full_badarded", "full_Discarded", "full_scard", "full_drair", "full_diskard", "full_declard", "full_disore", "full_discarding", "full_drore", "full_declign", "full_Discard", "full_diards", "full_Discign", "full_scart", "full_diard", "full_discARD", "full_diskarded", "full_recARD", "full_discarded", "full_scair", "full_score", "full_diskord", "full_Discart", "full_Discore", "full_drard", "full_disarding", "full_recards", "full_discign", "full_discair", "full_badarding", "full_discards", "full_DiscARD", "full_badord", "full_disord", "full_diskarding", "full_declore", "full_badard", "full_disign", "full_discore", "full_declarded", "full_Discards", "full_recard", "full_disarded", "full_discord", "full_discart", "full_Discair", "full_disard", "full_diARD"], "s": ["sys", "ses", "self", "parts", "service", "t", "sync", "rs", "sym", "utils", "g", "cs", "S", "settings", "os", "status", "sets", "js", "si", "sq", "session", "ps", "ss", "p", "se", "socket", "site", "b", "sb", "f", "stat", "gs", "state", "spec", "c", "ns", "is", "stats", "ssl", "sv", "sl", "states", "services", "ds", "sie", "sa", "su", "ls", "ts", "space", "us", "ks"], "l2_table": ["l2ptable", "l1_cache", "l2btable", "l1_table", "l2fstable", "l2jcomponent", "l1_address", "l2___machine", "l2___table", "ltwo_machine", "l2_key", "l1_key", "l2jtable", "l2_entry", "l2ttable", "l2baddress", "l4_cache", "ltwo_tree", "ltwottree", "l2ftable", "ltwotmachine", "l2_cache", "l2__table", "l2jkey", "l2_stable", "l1_component", "l2pentry", "l1_session", "ltwo_cache", "l2bentry", "l2fcache", "l2_address", "l2paddress", "l2_course", "ltwottable", "l2jcache", "l2__body", "l2_component", "l2bindex", "l2___tree", "l2_machine", "ltwotcache", "l1_count", "l1_entry", "l4_table", "l2__cache", "l2___cache", "l4_course", "l1_index", "l4_body", "l2_body", "l2tcache", "l2_session", "l2tmachine", "l2pindex", "l2ttree", "l2fbody", "l2_count", "l2_tree", "ltwo_table", "l4_stable", "l2__course"], "l2_index": ["l2_offset", "lbfPstyle", "l2xexit", "l2erheader", "l2lexposition", "l2Pposition", "l0_exit", "lbf_position", "l2Paddress", "l0_index", "l22_index", "l2roffset", "l6_cache", "l2_site", "l2rsize", "l2_entry", "lDB_site", "l2_header", "l2_cache", "l2_align", "l2Palign", "l0_header", "l0xindex", "l2xheader", "l2lexstyle", "l2_style", "l2xaddress", "l0_address", "l2lexindex", "l2Jbyte", "l22_entry", "l22_path", "lbfPindex", "lbf_style", "l2_address", "l0xexit", "l2erindex", "l2Jsecondary", "l2_path", "l1_offset", "l2xindex", "l2_byte", "l2rindex", "lDB_index", "l2Pexit", "l22_size", "l2_position", "lbf_align", "l6_size", "l2Pstyle", "l2Pheader", "lbfPposition", "lbfPalign", "l6_position", "l6_index", "l2Pindex", "l2_exit", "l2Jindex", "lDB_byte", "l1_index", "l0xaddress", "l2Jsite", "lDB_secondary", "l0xheader", "l2_secondary", "l2erexit", "l2lexalign", "l1_size", "l2eraddress", "lbf_index", "l2_size"], "ret": ["alt", "ft", "en", "let", "reply", "t", "inter", "rc", "val", "code", "back", "bad", "pre", "def", "rets", "gt", "fun", "status", "ref", "xt", "det", "lit", "obj", "mt", "ind", "ib", "fi", "fin", "info", "mi", "success", "match", "b", "ext", "Ret", "bf", "f", "result", "att", "rl", "try", "ry", "arr", " Ret", "nt", "iter", "re", "out", "rt", "get", "last", "RET", "al", "lb", "reg", "res", "cur", "flag", "num", "len"], "i": ["qi", "it", "ui", "I", "t", "ai", "ni", "xi", "id", "val", "l", "iu", "gi", "ini", "io", "mu", "ci", "x", "di", "si", "ie", "ii", "uri", "v", "u", "ind", "z", "p", "e", "info", "fi", "mi", "li", "b", "ix", "multi", "j", "count", "f", "result", "ti", "n", "abi", "ip", "c", "eni", "reset", "ji", "pi", "chi", "iter", "out", "r", "bi", "ri", "dim", "len", "y", "in", "index", "start"], "old_l2_entry": ["old_l2_slot", "old_l2_cell", "old_l2Jsession", "old_l3_module", "old_l1_name", "old_l4_table", "old_l1_Entry", "old_l3_cell", "old_l2Melement", "old_l2Oslot", "old_l2_Entry", "old_l3_table", "old_l1_slot", "old_l2Oentry", "old_l2actable", "old_l1_entry", "old_l2acentry", "old_l2Mentry", "old_l1_session", "old_l2__entry", "old_l2__cell", "old_l4_index", "old_l2_module", "old_l2_index", "old_l2Mindex", "old_l2_element", "old_l2_table", "old_l2__table", "old_l2Mtable", "old_l2Oname", "old_l4_element", "old_l2__module", "old_l3_entry", "old_l2_name", "old_l2Mname", "old_l4_entry", "old_l2Mslot", "old_l2accell", "old_l2acmodule", "old_l2JEntry", "old_l2_session", "old_l2Jentry"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static int64_t qemu_archipelago_getlength(BlockDriverState *bs)\n\n{\n\n    int64_t ret;\n\n    BDRVArchipelagoState *s = bs->opaque;\n\n\n\n    ret = archipelago_volume_info(s);\n\n    return ret;\n\n}\n", "idx": 15534, "substitutes": {"bs": ["bt", "blocks", "ses", "bis", "bc", "BS", "fs", "ins", "bb", "rs", "fb", "cs", "qs", "os", "bytes", "ps", "ss", "obj", "ba", "obs", "pb", "buf", "b", "sb", "bits", "bh", "ns", "bas", "ds", "ls", "lb", "bos", "ts", "ubs", "bl", "iss", "ks"], "ret": ["pet", "alt", "en", "rev", "part", "reply", "val", "def", "gc", "rets", "fun", "std", "final", "ref", "xt", "arg", "det", "full", "lit", "value", "obj", "ut", "pass", "mem", "info", "fi", "desc", "success", "data", "ext", "base", "Ret", "af", "bf", "result", "cat", " Ret", "nt", "re", "out", "rt", "RET", "res", "reg", "addr", "flag", "len", "opt", "bit"], "s": ["sys", "ses", "parts", "as", "bis", "service", "d", "i", "a", "g", "cs", "S", "os", "status", "js", "session", "ps", "o", "u", "p", "e", "b", "sb", "gs", "state", "spec", "c", "ns", "is", "stats", "ssl", "sl", "states", "services", "ds", "ops", "sa", "ls", "ks"]}}
{"project": "qemu", "commit_id": "47445c80fb57035331574ac1ac0bcee67fb84aeb", "target": 0, "func": "static void rtas_ibm_set_eeh_option(PowerPCCPU *cpu,\n\n                                    sPAPRMachineState *spapr,\n\n                                    uint32_t token, uint32_t nargs,\n\n                                    target_ulong args, uint32_t nret,\n\n                                    target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    sPAPRPHBClass *spc;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n    int ret;\n\n\n\n    if ((nargs != 4) || (nret != 1)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    addr = rtas_ld(args, 0);\n\n    option = rtas_ld(args, 3);\n\n\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    pdev = pci_find_device(PCI_HOST_BRIDGE(sphb)->bus,\n\n                           (addr >> 16) & 0xFF, (addr >> 8) & 0xFF);\n\n    if (!pdev || !object_dynamic_cast(OBJECT(pdev), \"vfio-pci\")) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    spc = SPAPR_PCI_HOST_BRIDGE_GET_CLASS(sphb);\n\n    if (!spc->eeh_set_option) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    ret = spc->eeh_set_option(sphb, addr, option);\n\n    rtas_st(rets, 0, ret);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15535, "substitutes": {"cpu": ["proc", "config", "pc", "fps", "pool", "vm", "cmp", "linux", "pid", "computer", "pu", "conn", "processor", "GPU", "mem", " CPU", "boot", "cli", "CPU", "proxy", "gpu", "process", "cp", "ips", "nic", "apple", "node", "gp"], "spapr": ["SPaprs", "spapner", "spapsrb", "scapr", "spapb", "spaperr", "SPrapc", "spappp", "scapp", "scappp", "spajp", "spraprs", "spappner", "scapb", "spajr", "spappr", "SPapc", "spajb", "spapc", "SPraprs", "sprapc", "spaperner", "SPaprb", "spajner", "scappr", "spapsrs", "spaprs", "scappner", "SPrapr", "spapsr", "spaprb", "sprapr", "spapsc", "spaperp", "scappb", "spappb", "SPraprb", "SPapr", "spapp", "spraprb", "spaperb", "scapner"], "token": ["func", "nat", "proc", "call", "reply", "response", "random", "native", "auth", "total", "conn", "win", "flag", "cost", "ok", "socket", "oken", "timeout", "next", "resp", "mac", "seq", "reg", "util", "opt", "callback"], "nargs": [" nfun", "largs", "nfun", "natret", "nflags", "nattarget", "numret", "uflags", " nArgs", "lArgs", "uargs", "lret", "numtarget", "numfun", "utarget", "natargs", "numargs", "numflags", "natflags", "ntarget", "uret", "numArgs", "lfun", "nArgs"], "args": ["func", "bug", "call", "parts", "reply", "config", "arms", "fields", "rs", "changes", "msg", "grades", "cs", "values", "details", "qs", "bytes", "use", "py", "opens", "arg", "ras", "frame", "conn", "flags", "ids", "grad", "ms", "active", "params", "parse", "alls", "sec", "pack", "vals", "match", "data", "ait", "members", "features", "Args", "lines", "gs", "days", "next", "arr", "yrs", "argument", "ams", "atts", "results", "cmd", "states", "resp", "links", "mac", "flag", "len", "asm"], "nret": [" nresult", "Nret", "nRet", "norest", "nresult", "nsuccess", "cret", "Nrest", "crets", " nrets", "nrest", "lret", "nrows", "noret", "lsuccess", "Nresult", " nrows", "csuccess", "nrets", "noresult", " nrest", "cRet", "lrets", " nRet", "norows", " nsuccess", "lRet", "Nrows"], "rets": ["alt", "secret", "proc", "uts", "ails", "reply", "fs", "ins", "fields", "rs", "changes", "utils", "def", "details", "fun", "opens", "buffer", "uns", "rows", "flags", "strings", "ids", "ures", "mem", "sec", "desc", "ries", "features", "nas", "tests", "store", "bits", "acks", "des", "ns", "ats", "outs", "nt", "results", "uds", "fits", "als", "aux", "ops", "errors", "ds", "ints", "seq", "res", "reg", "runs", "ts", "ls", "ils", "len", "ips", "pillar", "vals"], "sphb": [" sphd", "pphpb", "dsppbb", "psphm", "sclc", "pschrb", "dspha", "scfbi", "dsphb", "schrb", "dsphsb", "sPhbi", "sshc", "ppha", "pphbi", "scfb", "sphbb", "dsppa", "shpa", "pphr", "dsphbb", " sshc", "sppb", "scfa", " sshp", "sppa", "inshpbase", "inshpb", "sPhb", "sPHa", "sphpb", "sphc", "scpb", "sclp", "shpc", "sephd", "insphbase", "insphc", "sephc", "sshd", "sphbase", "sphpf", "sephp", "insphb", "schm", "shpb", "sPHbase", "sshm", "sppbb", "sphrb", "sshrb", "schb", "pphf", "sphm", "sphsb", "sphpm", "dsppb", "scpa", "pschb", "smphbb", "pphb", "scpr", "sPHb", "sphaa", "sppsb", "inshpa", "sphp", " sphp", "inspha", "sPhpb", "sPHc", "shpbase", "sclb", "scppb", "sPha", " sshb", "sPhr", " sphc", "sphabi", "sshp", "pschm", "scld", "sephb", "pPhbi", "sphprb", "smphsb", "sphab", "psphf", "sphd", "smpha", "pPhf", "sshf", "sphf", "schf", "sphaf", "smphb", "inshpc", "spha", "pschf", "pPha", "sPhf", "sshb", " sshd", "sphr", "psphrb", "scff", "psphb", "dsppsb", "pPhb", "sphbi"], "spc": ["Spc", "SPc", "epf", "ppf", "SPf", " spf", "spcs", "Sph", " spci", "spci", "epc", "spf", "Spf", "epci", "SPci", "SPcs", "sph", "Spci", "spd", " sph", " spd", "epd", "ppc", "SPh", "ppd", "Spcs", " spcs", "ppci"], "pdev": ["tdev", "pcerror", "ippad", "pcdevice", " pdef", "tdi", "pdi", "ndef", "pcdev", "pmod", " pdevice", " ppad", "ppad", "pdiv", "cdiv", "cerror", "ipdev", "vdiv", "cdevice", "ippriv", " pdiv", "vdev", "cdev", "tdevice", " pmod", "pdevice", "ndevice", "ndi", "vdevice", " ppriv", "ppriv", "vmod", "cpad", "pcpad", "ndev", " pdi", "ipdevice", "tdef", "cpriv", "pdef", "cmod"], "addr": ["ord", "alt", "device", "rr", "pkg", "part", "amp", "adder", "array", "enc", "arm", "amd", "config", "id", "rc", "oa", "name", "align", "ref", "arg", "ace", "cmp", "loc", "access", "grad", "adr", "ad", "layer", "mt", "active", "options", "data", "ext", "acl", "add", "address", "ip", "url", "route", "arr", "advert", "afi", "offset", "attr", "md", "cmd", "ack", "host", "dd", "seq", "ar", "dr", "hop", "prefix", "order", "pad", "alias", "pos", "opt", "ptr", "node"], "option": ["array", "config", "object", "style", "Option", "name", "connection", "optional", "operation", "section", "image", "event", "other", "arg", "offer", "position", "error", "value", "package", "o", "term", "adr", "version", "options", "direction", "resource", "cho", "entry", "op", "mode", "address", "custom", "ip", "route", "pin", "type", "offset", "attr", "ption", "tag", "alias", "opt", "replace"], "buid": ["auids", "buids", " buiden", " buids", "uuId", "basid", "suids", "bukid", "buID", "bookID", "auiden", " bukid", "uuID", "suID", "buId", "ruids", "bookids", "uuid", "suId", "bookid", "uuiden", "buiden", "basId", "basids", "rukid", "basID", "ruID", " buID", "bookkid", "uuids", "auID", "suid", "ruid", "auid"], "ret": ["alt", "reply", "inter", "rc", "sat", "val", "code", "back", "gt", "fun", "ref", "arg", "det", "pass", "mt", "rec", "success", "match", "ext", "Ret", "bit", "result", "cat", "arr", " Ret", "nt", "re", "out", "rt", "fail", "resp", "rep", "pat", "RET", "res", "reg", "num", "flag", "run", "len", "opt", "red", "err"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_acl_remove(qemu_acl *acl,\n\n                    const char *match)\n\n{\n\n    qemu_acl_entry *entry;\n\n    int i = 0;\n\n\n\n    TAILQ_FOREACH(entry, &acl->entries, next) {\n\n        i++;\n\n        if (strcmp(entry->match, match) == 0) {\n\n            TAILQ_REMOVE(&acl->entries, entry, next);\n\n            return i;\n\n        }\n\n    }\n\n    return -1;\n\n}\n", "idx": 15537, "substitutes": {"acl": ["acs", "bc", "qa", "enc", "l", "lic", "container", "oa", "api", "lc", "ctrl", "aml", "acc", "asc", "ace", "abc", "aa", "abl", "client", "access", "alpha", "lib", "filter", "ant", "la", "oc", "kl", "af", "cel", "rol", "am", "cca", "ac", "anc", "afi", "sl", "ic", "coll", "exec", "cache", "mac", "ec", "ar", "ocl", "wl", "el", "fc", "cl", "anon"], "match": ["email", "path", "map", "m", "Match", "allow", "id", "search", "code", "mat", "name", "test", "image", "use", "key", "like", "member", "guard", "patch", "atch", "access", "filter", "parse", "p", "info", "data", "ext", "mode", "mask", "find", "quote", "target", "text", "matched", "change", "re", "rule", "link", "get", "im", "field", "pattern", "pat", "content", "tag", "lock", "reg", "apply", "replace", "message"], "entry": ["zip", "card", "ge", "inter", "enc", "escape", "id", "enter", "search", "child", "or", "name", "row", "connection", "lc", "image", "ie", "si", "comment", "key", "server", "ent", "element", "ant", "parse", "se", "e", "info", "sec", "page", "li", "reader", "ries", "cel", "parent", "inc", "item", "next", "route", "feed", "ry", "end", "inner", "try", "cat", "first", "nt", "cell", "sea", "sub", "archive", "prev", "Entry", "index", "start"], "i": ["hi", "it", "ui", "m", "I", "ai", "ni", "xi", "id", "ini", "l", "gi", "code", "oi", "ci", "x", "di", "si", "init", "ii", "v", "uri", "o", "col", "u", "ind", "p", "mini", "li", "k", "b", "j", "multi", "n", "phi", "f", "ip", "c", "eni", "offset", "pi", "bi", "ri", "ori", "index", "start"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_initfn (PCIDevice *dev)\n\n{\n\n    PCIAC97LinkState *d = DO_UPCAST (PCIAC97LinkState, dev, dev);\n\n    AC97LinkState *s = &d->ac97;\n\n    uint8_t *c = d->dev.config;\n\n\n\n    s->pci_dev = &d->dev;\n\n    pci_config_set_vendor_id (c, PCI_VENDOR_ID_INTEL); /* ro */\n\n    pci_config_set_device_id (c, PCI_DEVICE_ID_INTEL_82801AA_5); /* ro */\n\n\n\n    c[0x04] = 0x00;      /* pcicmd pci command rw, ro */\n\n    c[0x05] = 0x00;\n\n\n\n    c[0x06] = 0x80;      /* pcists pci status rwc, ro */\n\n    c[0x07] = 0x02;\n\n\n\n    c[0x08] = 0x01;      /* rid revision ro */\n\n    c[0x09] = 0x00;      /* pi programming interface ro */\n\n    pci_config_set_class (c, PCI_CLASS_MULTIMEDIA_AUDIO); /* ro */\n\n    c[PCI_HEADER_TYPE] = PCI_HEADER_TYPE_NORMAL; /* headtyp header type ro */\n\n\n\n    c[0x10] = 0x01;      /* nabmar native audio mixer base\n\n                            address rw */\n\n    c[0x11] = 0x00;\n\n    c[0x12] = 0x00;\n\n    c[0x13] = 0x00;\n\n\n\n    c[0x14] = 0x01;      /* nabmbar native audio bus mastering\n\n                            base address rw */\n\n    c[0x15] = 0x00;\n\n    c[0x16] = 0x00;\n\n    c[0x17] = 0x00;\n\n\n\n    c[0x2c] = 0x86;      /* svid subsystem vendor id rwo */\n\n    c[0x2d] = 0x80;\n\n\n\n    c[0x2e] = 0x00;      /* sid subsystem id rwo */\n\n    c[0x2f] = 0x00;\n\n\n\n    c[0x3c] = 0x00;      /* intr_ln interrupt line rw */\n\n    c[0x3d] = 0x01;      /* intr_pn interrupt pin ro */\n\n\n\n    pci_register_bar (&d->dev, 0, 256 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    pci_register_bar (&d->dev, 1, 64 * 4, PCI_ADDRESS_SPACE_IO, ac97_map);\n\n    register_savevm (\"ac97\", 0, 2, ac97_save, ac97_load, s);\n\n    qemu_register_reset (ac97_on_reset, s);\n\n    AUD_register_card (\"ac97\", &s->card);\n\n    ac97_on_reset (s);\n\n}\n", "idx": 15549, "substitutes": {"dev": ["roll", "device", "development", "ch", "cam", "dist", "tr", "config", "priv", "die", "DC", " device", "def", "rad", "DE", "br", "test", "ve", "serial", "di", "Dev", "mod", "raw", "comment", "error", "v", "app", "conf", "gu", "adv", "der", "de", "conn", "w", "grad", "pub", "loader", "ad", "mem", "info", "ver", "engine", "desc", "pack", "data", "var", "dat", "diff", "block", "dem", "end", "DEV", " Dev", "md", "load", "link", "dd", "ev", "reg", "debug", "dom", "hw", "err"], "d": ["D", "dh", "m", "t", "l", "id", "i", "da", "ded", "bd", "g", "dl", "di", "nd", "ld", "gd", "pd", "dy", "cd", "ad", "z", "p", "e", "dict", "data", "b", "sd", "did", "n", "f", "dom", "dat", "dad", "dt", "dc", "md", "r", "ds", "dd", "db", "dn", "dr", "dm", "del", "dos"], "s": ["args", "south", "sys", "ses", "m", "t", "service", "sg", "fs", "l", "sed", "rs", "a", "g", "cs", "S", "settings", "os", "sw", "si", "sq", "session", "v", "conf", "ss", "o", "w", "z", "p", "e", "b", "sb", "sd", "n", "f", "gs", "state", "spec", "ns", "sc", "ssl", "sl", "r", "ds", "services", "sa", "y"], "c": ["call", "m", "ch", "mc", "cm", "uc", "bc", "ca", "t", "enc", "rc", "config", "l", "i", "cc", "code", "pc", "a", "C", "lc", "cs", "ci", "g", "ctrl", "h", "cn", "x", "con", "ct", "loc", "v", "conf", "chain", "cr", "o", "w", "col", "z", "u", "p", "e", "y", "nc", "k", "b", "co", "tc", "n", "f", "arc", "spec", "inc", "cu", "dc", "sc", "ce", "q", "cf", "cont", "ic", "coll", "r", "cp", "cache", "xc", "ec", "cur", "fc", "cl", "err"]}}
{"project": "FFmpeg", "commit_id": "68900bf16bb4dda35cf5f2801ce72c15056f1939", "target": 0, "func": "static int cook_parse(AVCodecParserContext *s1, AVCodecContext *avctx,\n\n                      const uint8_t **poutbuf, int *poutbuf_size,\n\n                      const uint8_t *buf, int buf_size)\n\n{\n\n    CookParseContext *s = s1->priv_data;\n\n\n\n    if (s->duration)\n\n        s1->duration = s->duration;\n\n    else if (avctx->extradata && avctx->extradata_size >= 8 && avctx->channels)\n\n        s->duration = AV_RB16(avctx->extradata + 4) / avctx->channels;\n\n\n\n    /* always return the full packet. this parser isn't doing any splitting or\n\n       combining, only setting packet duration */\n\n    *poutbuf      = buf;\n\n    *poutbuf_size = buf_size;\n\n    return buf_size;\n\n}\n", "idx": 15552, "substitutes": {"s1": ["p2", "p0", "sg11", "p4", "c2", "sg1", "S1", "S0", "c1", " s2", "ares1", "S2", "s11", "ares11", "ares2", "p1", "ws1", "s2", "c11", "s4", "wsone", "sg2", "sone", "cone", "s0", "Sone", "ws2", "ws4", "pone", "c0", " s4", " sone"], "avctx": ["abcontext", "aupkg", "afpkg", " avlc", "aucmp", "aucontext", "abcache", "AVcmp", "afcv", " avcf", "ajcontext", "avcmp", "avcv", "avlc", "abcmp", "abcdn", "avepkg", "afcf", "avcf", " avcv", "afcdn", "avelc", "AVcontext", "aflc", "avectx", "afxc", "aulc", "afcmp", " avcdn", "avecv", "auxc", "AVlc", "AVctrl", "avcdn", "ajctx", "afcontext", " avcmp", "AVxc", "auctx", "ajctrl", "abcf", " avcontext", "avecmp", "avcontext", "avxc", "ajcmp", "afctx", "AVctx", "avecontext", "afcache", "avcache", "avpkg", "afctrl", "avctrl", "abctx", " avcache"], "poutbuf": [" poutsbuf", "pOutqueue", "poutsbag", " poutscmd", "poutbag", " poutsqueue", "Pinqueue", " poutsbag", "poutscmd", "Pinbuff", "pOutbuff", " poutcmd", "poutsqueue", "piobag", "pantqueue", "piocmd", "Poutbuf", "Poutbuff", "poutcmd", " poutqueue", "poutqueue", "pantbuff", "pinbuf", "poutbuff", "pOutcmd", "Pinbuf", "piobuf", " poutbag", "pinbuff", "poutsbuf", "pantbuf", "pOutbuf", "pOutbag", "Poutqueue", "pinqueue", "pioqueue"], "poutbuf_size": ["poutqueue_size", "poutqueue_count", "poutbuf_Size", "poutbuf_count", "poutqueue_length", "poutbuf_length", "poutbuf_scale", "poutbuf__count", "poutbuf__length", "poutbuf__size"], "buf": ["vec", "context", "uc", "bc", "queue", "cv", "tmp", "batch", "config", "fb", "uf", "foo", "buffer", "bag", "fp", "buff", "rb", "pb", "data", "b", "wb", "Buffer", "bf", "result", "ab", "cb", "cap", "offset", "cmd", "aux", "src", "seq", "window", "pad", "ctx", "alloc"], "buf_size": ["buf67desc", "buf67size", "buf_index", "buf5index", "buf5size", " buf_index", "buf67sized", " buf_offset", "buff67desc", "buff67size", "buff_sized", "buf_desc", "buff67sized", "buf_scale", "buf_offset", "uf_Size", "buf_Size", "buf_sized", "buff_size", "buf5offset", "buff_desc", "uf_size", "uf_scale"], "s": ["args", "sys", "m", "context", "ses", "self", "d", "t", "sg", "service", "fs", "i", "rs", "a", "g", "cs", "qs", "S", "hs", "settings", "os", "new", "js", "es", "sq", "session", "ps", "u", "params", "p", "e", "sec", "data", "b", "sb", "sf", "n", "f", "gs", "spec", "c", "ns", "ans", "ssl", "ops", "r", "ds", "services", "sa", "su", "ls", "ts", "ctx", "aws"]}}
{"project": "FFmpeg", "commit_id": "2f4233614a7fbe176b81de0ef14bf38bad8e6693", "target": 0, "func": "static void add_codec(FFServerStream *stream, AVCodecContext *av,\n\n                      FFServerConfig *config)\n\n{\n\n    AVStream *st;\n\n    AVDictionary **opts, *recommended = NULL;\n\n    char *enc_config;\n\n\n\n    if(stream->nb_streams >= FF_ARRAY_ELEMS(stream->streams))\n\n        return;\n\n\n\n    opts = av->codec_type == AVMEDIA_TYPE_AUDIO ?\n\n           &config->audio_opts : &config->video_opts;\n\n    av_dict_copy(&recommended, *opts, 0);\n\n    av_opt_set_dict2(av->priv_data, opts, AV_OPT_SEARCH_CHILDREN);\n\n    av_opt_set_dict2(av, opts, AV_OPT_SEARCH_CHILDREN);\n\n    if (av_dict_count(*opts))\n\n        av_log(NULL, AV_LOG_WARNING,\n\n               \"Something is wrong, %d options are not set!\\n\", av_dict_count(*opts));\n\n\n\n    if (config->stream_use_defaults) {\n\n    //TODO: reident\n\n    /* compute default parameters */\n\n    switch(av->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"ab\", av->bit_rate, 0);\n\n        }\n\n        if (av->sample_rate == 0) {\n\n            av->sample_rate = 22050;\n\n            av_dict_set_int(&recommended, \"ar\", av->sample_rate, 0);\n\n        }\n\n        if (av->channels == 0) {\n\n            av->channels = 1;\n\n            av_dict_set_int(&recommended, \"ac\", av->channels, 0);\n\n        }\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (av->bit_rate == 0) {\n\n            av->bit_rate = 64000;\n\n            av_dict_set_int(&recommended, \"b\", av->bit_rate, 0);\n\n        }\n\n        if (av->time_base.num == 0){\n\n            av->time_base.den = 5;\n\n            av->time_base.num = 1;\n\n            av_dict_set(&recommended, \"time_base\", \"1/5\", 0);\n\n        }\n\n        if (av->width == 0 || av->height == 0) {\n\n            av->width = 160;\n\n            av->height = 128;\n\n            av_dict_set(&recommended, \"video_size\", \"160x128\", 0);\n\n        }\n\n        /* Bitrate tolerance is less for streaming */\n\n        if (av->bit_rate_tolerance == 0) {\n\n            av->bit_rate_tolerance = FFMAX(av->bit_rate / 4,\n\n                      (int64_t)av->bit_rate*av->time_base.num/av->time_base.den);\n\n            av_dict_set_int(&recommended, \"bt\", av->bit_rate_tolerance, 0);\n\n        }\n\n\n\n        if (!av->rc_eq) {\n\n            av->rc_eq = av_strdup(\"tex^qComp\");\n\n            av_dict_set(&recommended, \"rc_eq\", \"tex^qComp\", 0);\n\n        }\n\n        if (!av->rc_max_rate) {\n\n            av->rc_max_rate = av->bit_rate * 2;\n\n            av_dict_set_int(&recommended, \"maxrate\", av->rc_max_rate, 0);\n\n        }\n\n\n\n        if (av->rc_max_rate && !av->rc_buffer_size) {\n\n            av->rc_buffer_size = av->rc_max_rate;\n\n            av_dict_set_int(&recommended, \"bufsize\", av->rc_buffer_size, 0);\n\n        }\n\n        break;\n\n    default:\n\n        abort();\n\n    }\n\n    } else {\n\n        switch(av->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (av->bit_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio bit rate is not set\\n\");\n\n            if (av->sample_rate == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"audio sample rate is not set\\n\");\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (av->width == 0 || av->height == 0)\n\n                report_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                                    &config->errors, \"video size is not set\\n\");\n\n            break;\n\n        default:\n\n            av_assert0(0);\n\n        }\n\n    }\n\n\n\n    st = av_mallocz(sizeof(AVStream));\n\n    if (!st)\n\n        return;\n\n    av_dict_get_string(recommended, &enc_config, '=', ',');\n\n    av_dict_free(&recommended);\n\n    av_stream_set_recommended_encoder_configuration(st, enc_config);\n\n    st->codec = av;\n\n    stream->streams[stream->nb_streams++] = st;\n\n}\n", "idx": 15555, "substitutes": {"stream": ["channel", "oper", "path", "port", "record", "m", "uc", "input", "cv", "iver", "object", "iv", "audio", "image", "sw", "AV", "raw", "model", "Stream", "server", "v", "form", "client", "upload", "view", "wave", "media", "instance", "http", "data", "f", "parent", "spec", "url", "wav", "feed", "transform", "loop", "sv", "sl", "REAM", "coll", "ack", "video", "src", "archive", "ream"], "av": ["port", "ak", "capt", "art", "audio", "auc", "image", "aut", "avi", "aim", "raft", "media", "dev", "ver", "af", "att", "am", "attr", "sv", "aux", "com", "off", "array", "bb", "iv", "uf", "api", "ra", "air", "acc", "nav", "data", "ann", "cap", "ack", "um", "ev", "archive", "lv", "aver", "aj", "cv", "tr", "AV", "aa", "aph", "app", "raf", "aps", "ad", "ave", "http", "li", "bh", "ac", "man", "aud", "record", "uc", "ai", "a", "act", "auth", "user", "ap", "v", "var", "oc", "aw", "buf", "au", "ab", "wav", "ov", "aval", "sav"], "config": ["fig", "path", "context", "ch", "bc", "capt", "ca", "allow", "input", "Config", "rc", "ctrl", "lc", "manager", "settings", "image", "acc", "con", "ct", "nav", "app", "server", "conf", "conn", "client", "sec", "options", "img", "data", "ext", "driver", "cfg", "control", "spec", "c", "design", "cap", "text", "sc", "cf", "man", "cal", "exec", "aux", "cache", "db", "FIG", "reg", "support", "ctx"], "st": ["sta", "ru", "amp", "capt", "art", "ste", "std", "sth", "sw", "str", "ct", "ss", "ad", "stage", "se", "ST", "sb", "est", "inst", "St", "sn", "sc", "sl", "ast", "sa", "rest", "src", "ost"], "opts": ["optte", "ots", "operfs", " opt", " opfs", " optt", "OPt", " optfs", " optty", "OPments", "optts", " oprs", "opertx", " opets", "opals", "opertd", "opta", " optta", "opouts", " optrs", "optd", "optets", "optrs", " optter", "operta", " opments", " optouts", "opfs", "optments", "operter", "ops", "optr", "oprs", "otets", " optals", " opouts", "opert", "opttd", "opets", "opty", " optes", "optouts", " optd", "opter", " opals", " optths", " optr", "optt", "operals", " optx", " opths", " opte", "optx", "opttx", "operts", "opte", " opter", "opments", "OPta", " opttes", "optTS", "optes", "OPte", " ops", "OPfs", "opths", "otts", "opttes", "opTS", "otTS", " optts", "OPts", "OPths", " opTS", "OPty", "opttr", "opertr", " opty", "opt"], "recommended": ["suspened", "shortended", "depended", "recommened", "shortending", "shortension", "recommENDED", "recommend", "suspend", "pretended", "depened", "pretributed", "advertened", "navending", "shortened", "depending", "navended", "pretending", "suspended", "dependending", "extend", "advertended", "advertension", "pretened", "dependended", "depENDED", "navributed", "advertend", "extened", "dependened", "depend", "recommension", "advertENDED", "dependension", "navened", "recommributed", "suspending", "pretENDED", "pretension", "extributed", "extension", "advertending", "pretend", "depension", "suspension", "extended", "recommending", "extending"], "enc_config": ["sec7content", "encodercontext", "enc7config", "sec_content", "enc__content", "encoderconfig", "sec7config", "enc_length", "sec7context", "enc7content", "enc__length", "sec_context", "sec_config", "sec_length", "encoderlength", "encodercontent", "enc7length", "enc_context", "sec7length", "enc__config", "enc_content", "enc__context", "enc7context"]}}
{"project": "qemu", "commit_id": "15c2f669e3fb2bc97f7b42d1871f595c0ac24af8", "target": 1, "func": "static void qmp_output_end_struct(Visitor *v, Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    QObject *value = qmp_output_pop(qov);\n\n    assert(qobject_type(value) == QTYPE_QDICT);\n\n}\n", "idx": 15582, "substitutes": {"v": ["m", "self", "vim", "d", "t", "l", "val", "i", "vp", "iv", "g", "x", "vm", "vi", "tv", "inv", "o", "w", "u", "version", "p", "e", "k", "vis", "b", "vs", "j", "f", "c", "volt", "q", "sv", "uv", "r", "V", "vt", "lv"], "errp": ["errr", "nerpb", "errpc", "errpb", "rrp", "nerpc", " errr", "nerp", "rrpc", "nerr", " errpb", "rrpb", " errpc", "rrr"], "qov": ["aqou", "quovy", "qovo", " qovo", "aqovo", "aqov", "ayov", "Qov", " qoh", "qovy", " qove", "ayoh", "qove", " qou", "quoh", "ayovy", "aqovy", " qovy", "Qovo", "Qou", "quove", "quov", "Qovy", "qoh", "qou", "ayove"], "value": ["m", "format", "xml", "response", "any", "val", "object", "style", "name", "values", "VALUE", "image", "section", "null", "module", "model", "comment", "key", "member", "expression", "output", "element", "w", "document", "p", "Value", "data", "entry", "result", "parent", "feature", "type", "function", "anything", "content", "python", "node", "message"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n", "idx": 15589, "substitutes": {"s": ["south", "ses", "m", "self", "bis", "service", "t", "d", "sky", "fs", "l", "a", "g", "cs", "S", "settings", "sk", "sets", "js", "sq", "session", "v", "o", "u", "p", "e", "se", "b", "sf", "sb", "n", "f", "scl", "gs", "spec", "ns", "setup", "sc", "ssl", "sv", "sl", "services", "r", "su", "space", "support"], "main_data": ["all_data", "all_shape", "main\u00b7shape", "min_lane", "mainacdata", "mainacline", "main_module", "main_lane", "min_data", "mainacbody", "all_module", "main\u00b7line", "all_line", "mainaclane", "main\u00b7module", "main\u00b7data", "min_line", "main_body", "min_body", "main_shape"], "main_linesizes": ["main_linesenses", "main_linersinks", "main_linersize", "main\u00b7linesites", "main_limitsizes", "main_linesinks", "main_linersizes", "main_linsinks", "main_lineites", "main\u00b7linesizes", "main\u00b7limitsiz", "main_lineenses", "main_lineizes", "main_linesiz", "main_linsize", "main\u00b7limitsites", "main\u00b7linesize", "main_planesize", "main\u00b7limitsize", "main_linesize", "main_lineiz", "main_limitsites", "main_lineize", "main_linsizes", "main_linersenses", "main_limitsiz", "main_lineinks", "main_planesites", "main\u00b7limitsizes", "main_linesites", "main_planesiz", "main\u00b7linesiz", "main_linsenses", "main_planesizes", "main_limitsize"], "ref_data": ["reference_data", "ref1message", "reference_line", "reference_message", "ref1line", "reference_frame", "ref_lines", "ref_frame", "ref_message", "reference_info", "ref1data", "ref1info", "ref_info", "reference_lines"], "ref_linesizes": ["ref_lineizes", "ref_filesizes", "ref_linersize", "ref_linesize", "ref_linesys", "ref_linersizable", "ref_lineys", "ref_filesites", "ref_linersizing", "ref_lineizable", "ref_filesize", "ref_linersys", "ref_linize", "ref_lineize", "ref_linizes", "ref_linizing", "ref_lineizing", "ref_linesizable", "ref_filesizable", "ref_lineites", "ref_linersites", "ref_linys", "ref_linersizes", "ref_linesites", "ref_linesizing"], "w": ["m", "wh", "d", "l", "a", "x", "v", "win", "u", "z", "p", "e", "aw", "b", "wb", "n", "f", "W", "wa", "q", "r", "we", "wd", "y", "fw"], "h": ["hi", "ch", "ih", "l", "g", "hs", "x", "gh", "v", "rh", "hh", "z", "u", "p", "e", "he", "b", "f", "th", "hm", "bh", "ht", "q", "H", "sh", "ph", "y"], "mse": [" mSE", "pse", "mde", "nze", "nse", "dmne", "pze", " mte", "nmce", "mne", " mde", "mce", "mSE", "dmde", " mze", " mce", "mze", "nmne", "nte", "nmse", "pte", "dmce", "nSE", "nmde", "mte", " mne", "pSE", "dmse"], "i": ["ani", "qi", "uni", "ui", "it", "m", "I", "d", "ni", "ai", "xi", "l", "iu", "ini", "gi", "oi", "io", "g", "ci", "ki", "x", "di", "si", "ie", "ii", "v", "vi", "uri", "o", "yi", "u", "z", "ind", "p", "e", "fi", "mi", "li", "k", "b", "ix", "n", "f", "phi", "ti", "eni", "ji", "pi", "chi", "r", "bi", "ri", "ami", "zi", "y"], "c": ["call", "m", "ch", "mc", "cm", "uc", "d", "t", "ca", "cc", "code", "l", "pc", "config", "C", "a", "lc", "ci", "cs", "g", "cor", "cit", "cn", "x", "cy", "ct", "v", "cr", "col", "z", "u", "p", "e", "nc", "k", "b", "co", "count", "n", "f", "dc", "jc", "cu", "ac", "cat", "ce", "cf", "coll", "cp", "r", "vc", "cache", "ec", "cycle", "cur", "fc", "y", "cl"], "j": ["jj", "adj", "qi", "uj", "it", "m", "ch", "aj", "d", "ni", "ja", "jp", "l", "oj", "g", "dj", "x", "di", "str", "ie", "js", "si", "ii", "bj", "v", "br", "fr", "o", "z", "u", "ind", "p", "e", "k", "li", "b", "n", "f", "jo", "next", "jl", "jc", "je", "ji", "r", "J", "pr", "pos", "el", "y", "ij"], "main_line": [" main_side", "ref_plane", "ref__plane", "ref__line", "main_lines", "main__plane", "main_code", "mainjlines", "main_side", "main_pin", " main_code", "main__frame", "mainjpin", "ref__frame", "ref_lines", "main_frame", "ref_frame", "main__lines", "main_slice", "ref_pin", "main_plane", "ref__lines", "main__line", "mainjframe", "mainjline", " main_slice"], "ref_line": [" ref_lane", "ref___lines", "main_scale", "ref_scale", " ref_lines", "ref_layer", "main_lines", "ref___scale", "reference_line", "ref___line", "reference_name", "reference_layer", "ref_lines", "ref_name", "reference_lines", "ref_lane"]}}
{"project": "qemu", "commit_id": "0dacea92d26c31d453c58de2e99c178fee554166", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594, "substitutes": {"sum": ["Sum", "pal", "val", "style", "mean", "ass", "g", "weight", "user", "acc", "loss", "si", "vol", "total", "fat", "comment", "aa", "hash", "alpha", "ul", "cost", "summary", "mem", "sign", "doc", "size", "parse", "match", "count", "dot", "result", "skip", "add", "average", "gram", "ac", "scale", "out", "cal", "sh", "um", "sa", "cache", "fee", "pos", "num"]}}
{"project": "qemu", "commit_id": "84aa07f109f0afaeeec63c159f3a578b955c3de9", "target": 0, "func": "uint32_t HELPER(clcle)(CPUS390XState *env, uint32_t r1, uint64_t a2,\n\n                       uint32_t r3)\n\n{\n\n    uintptr_t ra = GETPC();\n\n    uint64_t destlen = get_length(env, r1 + 1);\n\n    uint64_t dest = get_address(env, r1);\n\n    uint64_t srclen = get_length(env, r3 + 1);\n\n    uint64_t src = get_address(env, r3);\n\n    uint8_t pad = a2 & 0xff;\n\n    uint32_t cc = 0;\n\n\n\n    if (!(destlen || srclen)) {\n\n        return cc;\n\n    }\n\n\n\n    if (srclen > destlen) {\n\n        srclen = destlen;\n\n    }\n\n\n\n    for (; destlen || srclen; src++, dest++, destlen--, srclen--) {\n\n        uint8_t v1 = srclen ? cpu_ldub_data_ra(env, src, ra) : pad;\n\n        uint8_t v2 = destlen ? cpu_ldub_data_ra(env, dest, ra) : pad;\n\n        if (v1 != v2) {\n\n            cc = (v1 < v2) ? 1 : 2;\n\n            break;\n\n        }\n\n    }\n\n\n\n    set_length(env, r1 + 1, destlen);\n\n    /* can't use srclen here, we trunc'ed it */\n\n    set_length(env, r3 + 1, env->regs[r3 + 1] - src - env->regs[r3]);\n\n    set_address(env, r1, dest);\n\n    set_address(env, r3, src);\n\n\n\n    return cc;\n\n}\n", "idx": 15615, "substitutes": {"env": ["en", "enh", "tx", "esp", "priv", "ah", "event", "h", "server", "np", "obj", "dev", "export", "c", "end", "here", "ec", "chal", "fen", "context", "done", "iv", "eu", "req", "vm", "txt", "w", "console", "loader", "equ", "viron", "her", "ext", "eni", "dt", "exec", "gui", "ev", "el", "core", "erv", "edge", "po", "ea", "ench", "cv", "config", "kn", "pg", "conn", "stage", "enable", "e", "exc", "engine", "nc", "site", "eng", "Environment", "state", "global", "ne", "que", "net", "ctx", "err", "qa", "enc", "ex", "er", "py", "this", "v", "conf", "energy", "buf", "dat", "shell", "esc", "environment", "vs", "opt"], "r1": ["p2", "r81", " r6", "rOne", " rOne", "R16", "arOne", "R3", "R4", " r16", " r2", "rc2", "r01", "p3", "sr2", "nr1", "R01", "ar2", " r4", " r81", "sr1", "v2", "p1", "r4", "R1", "nr16", " r01", "p01", "r2", "v6", "ar4", "v3", "rc3", "rc4", "r6", "sr4", "v1", "R81", "nr81", "ar1", "srOne", "r16", "rc1", "R2", "nr3", "R6"], "a2": ["A2", "A1", "alpha3", "alpha4", "A0", "a1", "va3", "a0", "A8", " a72", "A4", "as0", "alpha1", "as72", "alpha2", "va4", "A3", "va1", "va2", "A72", "a72", " a8", " a0", "a4", "a3", "as8", "as2", "a8"], "r3": ["rbThird", "rarthree", " r53", "er53", "dr03", "rr2003", " r6", " rThird", "ar3", "R3", " r2003", "er83", "rb3", " r2", " r9", "rr3", "r63", "rc63", "ar6", "arThree", "p3", "ar03", "ar53", "a53", "rb83", "rc03", "a03", "rbthree", "rar2003", "rthree", "dr9", "p03", "rr1", "R1", "dr53", "rar2", "r2", "er3", "r83", "Rthree", "rc3", "rarThree", "r9", "rcThree", "r6", "ar63", "p53", "p83", "r2003", " rthree", "er03", "r53", "rThird", "rb2", "ar1", "rarThird", " r03", "dr3", "rar3", "rb03", "rb53", "a3", "rrthree", "rThree", "rar63", "R2", "a9", "R53", "rr2", "R6", "rar03", "r03"], "src": ["RC", "rib", "proc", "uc", "bc", "slice", "sync", "dist", "rc", "cc", "config", "supp", "ctr", "sup", "https", "ub", "syn", "source", "req", "range", "sr", "st", "sq", "loc", "server", "uri", "access", "img", "rb", "desc", "comp", "b", "sb", "inst", "rw", "trans", "ape", "gb", "origin", "spec", "url", "cb", "sn", "sc", "ssl", "rob", "text", "target", "sl", "rt", "sur", "sh", "sub", "sel", "ource", "cur", "ruby", "addr"], "dest": ["ord", "tx", "uc", "ru", "d", "dist", "tmp", "rc", "config", "cdn", "priv", "da", "home", "sup", "source", "ident", "di", "txt", "asc", "dir", "loc", "conn", "de", "access", "dev", "rec", "rb", "desc", "data", "wb", "rw", "trans", "dat", "dep", "route", "dc", "gen", "target", "text", "sc", "cont", "sur", "ds", "Dest", "sub", "decl", "rest", "coord", "wd", "ptr", "comb", "go"], "destlen": ["destLen", "targetlength", "Destlength", "destli", " destli", "distl", "targetcount", "sourceLen", "desclength", " destl", " destpos", "descLen", "destlength", " destLen", " destlength", "destpos", "srclength", "srcel", "srcLen", "Destlen", "Destli", "destl", "desccount", "distlen", "sourcelength", "sourcepos", "targetlen", "distLen", "targetLen", "routelen", "sourcelen", "Destcount", "Destl", "descli", "destcount", "descl", "desclen", "distel", "srcli", "descel", "DestLen", "routelength", "destel", "srcpos", "routeLen", "srcl"], "srclen": ["serslen", "srgline", "hrclener", "serslhen", "srllenn", "nrcler", "srclend", "yrsleni", "serclena", "vraclen", "vrclenn", "srcelenn", "hrclen", "serslena", "srceler", "srClenc", "hrflend", "krclened", "vraclener", "yrslense", "srflen", "hrflon", "krslened", "vrclener", "sraclenn", "srblense", "sercleng", "srslened", "srcline", "nrclenn", "srslon", "srclun", "hrllener", "yrclenc", "srblenc", "yrclen", "nrceler", "srllener", "srblend", "srglenn", "srlcener", "srcilenn", "srglun", "srlcenn", "srclon", "srflon", "srclener", "srslenc", "hrlline", "srglen", "nrcelen", "krclun", "srlcaren", "srCleni", "vrclen", "srglened", "srclense", "srClena", "srClense", "nrclen", "srsleng", "srsclaren", "srcilan", "srslend", "srfleng", "srflhen", "hrclon", "srsclenn", "krslan", "serclen", "srbleni", "hrclenn", "srslense", "srslener", "srCleng", "yrclense", "sracline", "srcilun", "srsleni", "srlcen", "srselen", "srselenn", "srsclener", "hrllen", "srcleng", "srclenn", "srcelen", "yrslen", "vraclenn", "srlline", "hrflener", "srblener", "srslena", "yrslenc", "nrcelon", "srclan", "srllen", "hrllenn", "sraclen", "srsclen", "vraclaren", "sraclaren", "srslun", "krclen", "srclenc", "srciler", "srcler", "srflener", "srblen", "srClen", "srslan", "sersleng", "srslen", "vrclaren", "srseler", "hrcline", "srglener", "srcleni", "srflend", "srClhen", "srclhen", "srcilon", "srclened", "srglan", "srslhen", "sraclener", "yrcleni", "serclhen", "srflena", "hrflen", "srselon", "srclaren", "srblon", "nrcelenn", "krclan", "srclena", "hrclend", "krslun", "nrclon", "srcelon", "krslen", "srcilen", "srcilened"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "void *bios_linker_loader_cleanup(GArray *linker)\n\n{\n\n    return g_array_free(linker, false);\n\n}\n", "idx": 15634, "substitutes": {"linker": ["markener", "Linker", "marker", "loadener", " linkner", "markter", "Linkner", "layner", "linkler", " linkter", "layler", "loader", "layer", " linkler", "loadter", "Linkener", "linkter", "linkener", "loadner", "Linkler", " linkener", "markner", "linkner", "layener"]}}
{"project": "qemu", "commit_id": "36778660d7fd0748a6129916e47ecedd67bdb758", "target": 0, "func": "const ppc_hash_pte64_t *ppc_hash64_map_hptes(PowerPCCPU *cpu,\n\n                                             hwaddr ptex, int n)\n\n{\n\n    ppc_hash_pte64_t *hptes = NULL;\n\n    hwaddr pte_offset = ptex * HASH_PTE_SIZE_64;\n\n\n\n    if (cpu->env.external_htab == MMU_HASH64_KVM_MANAGED_HPT) {\n\n        /*\n\n         * HTAB is controlled by KVM. Fetch into temporary buffer\n\n         */\n\n        hptes = g_malloc(HASH_PTEG_SIZE_64);\n\n        kvmppc_read_hptes(hptes, ptex, n);\n\n    } else if (cpu->env.external_htab) {\n\n        /*\n\n         * HTAB is controlled by QEMU. Just point to the internally\n\n         * accessible PTEG.\n\n         */\n\n        hptes = (ppc_hash_pte64_t *)(cpu->env.external_htab + pte_offset);\n\n    } else if (cpu->env.htab_base) {\n\n        hwaddr plen = n * HASH_PTE_SIZE_64;\n\n        hptes = address_space_map(CPU(cpu)->as, cpu->env.htab_base + pte_offset,\n\n                                 &plen, false);\n\n        if (plen < (n * HASH_PTE_SIZE_64)) {\n\n            hw_error(\"%s: Unable to map all requested HPTEs\\n\", __func__);\n\n        }\n\n    }\n\n    return hptes;\n\n}\n", "idx": 15644, "substitutes": {"cpu": ["device", "proc", "intel", "bench", "uc", "cow", "sync", "config", "pc", "jp", "chip", "roc", "connection", "gc", "lc", "ctrl", "kernel", "cn", "pool", "module", "vm", "cmp", "linux", "performance", "hu", "computer", "gru", "pu", "platform", "conn", "np", "lib", "processor", "loader", "GPU", "mem", "instance", "u", " CPU", "boot", "drm", "cli", "CPU", "component", "uci", "c", "eni", "gpu", "prem", "lu", "clock", "phy", "loop", "process", "cp", "cache", "colo", "nic", "program", "core", "hw", "node", "gp"], "ptex": ["ptrEx", "ptexp", "ptlex", "ptz", " ptes", "ptx", "ptix", "PTes", "mintrex", "iptex", "ptEx", "ctEx", "petlex", "PTexp", "PTlex", "PTix", "PTEx", "iptix", "petes", "petex", "ctx", "ptrex", "iptrex", "iptx", "ptes", "ptrix", "petexp", "PTex", "ctex", "iptEx", "mintx", "mintEx", "ctrex", "mintex", " ptexp", " ptlex", "ptrz", "iptz", "PTz"], "n": ["m", "en", "nl", "d", "t", "l", "i", "un", "N", "a", "name", "g", "h", "cn", "nb", "x", "fn", "v", " N", "o", "w", "z", "u", "p", "e", "s", "nc", "k", "b", "j", "f", "none", "nor", "c", "ns", "number", "ne", "sn", "network", "r", "num", "len", "pn", "nm", "node"], "hptes": ["hpte", "hntes", "hppises", "hsptions", "hpetes", "hcts", "hPTe", "hpethes", "hctES", "hptises", "Hptets", "hiptes", "hctets", "hpties", " hPTe", "haptES", "haptises", " hipties", "hptES", "hpetions", "haptes", " hptends", "hpts", "hspetions", "haptses", "hapts", "hpses", "hiptions", "hcte", "hpetizes", "hsptizes", "Haptets", " hPTends", " hpties", " hiptises", "hPTends", "Hpts", "hapties", "hiptses", "hports", " hptses", "hppes", "hiptends", "hportes", " hipte", "hpse", "hspetes", "hpss", " hpte", "Haptes", "hppies", "Hapte", "Hapts", "hportES", "hctends", "hppe", "hptets", "hctes", "hiptizes", "hapte", " haptES", " haptes", "hPTses", "hptizes", " hPTses", "hctses", "hPTes", " hpts", "Hptes", "hspthes", " hapts", "hnthes", "hporte", "hntions", " hPTies", "hpsets", " hptES", "hipte", "hptends", "hspethes", "hipties", " hiptes", "hPTies", "hspetizes", "hptses", "hpthes", " hapte", "hntizes", " hPTes", "Hpte", "haptets", "hptions", "hsptes", " hptises", "hiptises", "hipthes"]}}
{"project": "qemu", "commit_id": "ecf5e8eae8b0b5fa41f00b53d67747b42fd1b8b9", "target": 0, "func": "static inline bool regime_translation_disabled(CPUARMState *env,\n\n                                               ARMMMUIdx mmu_idx)\n\n{\n\n    if (arm_feature(env, ARM_FEATURE_M)) {\n\n        switch (env->v7m.mpu_ctrl &\n\n                (R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK)) {\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK:\n\n            /* Enabled, but not for HardFault and NMI */\n\n            return mmu_idx == ARMMMUIdx_MNegPri ||\n\n                mmu_idx == ARMMMUIdx_MSNegPri;\n\n        case R_V7M_MPU_CTRL_ENABLE_MASK | R_V7M_MPU_CTRL_HFNMIENA_MASK:\n\n            /* Enabled for all cases */\n\n            return false;\n\n        case 0:\n\n        default:\n\n            /* HFNMIENA set and ENABLE clear is UNPREDICTABLE, but\n\n             * we warned about that in armv7m_nvic.c when the guest set it.\n\n             */\n\n            return true;\n\n        }\n\n    }\n\n\n\n    if (mmu_idx == ARMMMUIdx_S2NS) {\n\n        return (env->cp15.hcr_el2 & HCR_VM) == 0;\n\n    }\n\n    return (regime_sctlr(env, mmu_idx) & SCTLR_M) == 0;\n\n}\n", "idx": 15653, "substitutes": {"env": ["forge", "erv", "en", "context", "enh", "esp", "enc", "cv", "ench", "ea", "profile", "enter", "config", "core", "eve", "iv", "eu", "oa", "press", "ass", "er", "req", "txt", "skin", "conf", "np", "loader", "energy", "impl", "dict", "equ", "e", "viron", "engine", "exc", "eng", "ext", "Environment", "export", "eni", "shell", "dt", "ne", "ov", "que", "exec", "db", "ev", "vel", "ec", "emb", "environment", "fen", "el", "iss", "ef", "cur", "err"], "mmu_idx": ["mmu_idX", "mmu_idex", "mmu_idsX", "mmu_idsc", "mmu_idc", "mmu_sidx", "mmu_midx", "mmu_ridx", "mmu_ridb", "mmu_idev", "mmu_Idc", "mmu_sidxc", "mmu_idexe", "mmu_Idb", "mmu_idb", "mmu_sidc", "mmu_idsy", "mmu_midxc", "mmu_midy", "mmu_midxe", "mmu_idxc", "mmu_IdX", "mmu_sidxe", "mmu_ridxc", "mmu_sidX", "mmu_Idx", "mmu_idsx", "mmu_Idv", "mmu_idv", "mmu_Idxc", "mmu_idexc", "mmu_idy", "mmu_Idxe", "mmu_sidy", "mmu_ridX", "mmu_idxe"]}}
{"project": "qemu", "commit_id": "2adba0a18a7950d14827e82d8068c1142ee87789", "target": 0, "func": "static void build_processor_devices(Aml *sb_scope, unsigned acpi_cpus,\n\n                                    AcpiCpuInfo *cpu, AcpiPmInfo *pm)\n\n{\n\n    int i;\n\n    Aml *dev;\n\n    Aml *crs;\n\n    Aml *pkg;\n\n    Aml *field;\n\n    Aml *ifctx;\n\n    Aml *method;\n\n\n\n    /* The current AML generator can cover the APIC ID range [0..255],\n\n     * inclusive, for VCPU hotplug. */\n\n    QEMU_BUILD_BUG_ON(ACPI_CPU_HOTPLUG_ID_LIMIT > 256);\n\n    g_assert(acpi_cpus <= ACPI_CPU_HOTPLUG_ID_LIMIT);\n\n\n\n    /* create PCI0.PRES device and its _CRS to reserve CPU hotplug MMIO */\n\n    dev = aml_device(\"PCI0.\" stringify(CPU_HOTPLUG_RESOURCE_DEVICE));\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A06\")));\n\n    aml_append(dev,\n\n        aml_name_decl(\"_UID\", aml_string(\"CPU Hotplug resources\"))\n\n    );\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->cpu_hp_io_base, pm->cpu_hp_io_base, 1,\n\n               pm->cpu_hp_io_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(sb_scope, dev);\n\n    /* declare CPU hotplug MMIO region and PRS field to access it */\n\n    aml_append(sb_scope, aml_operation_region(\n\n        \"PRST\", AML_SYSTEM_IO, aml_int(pm->cpu_hp_io_base), pm->cpu_hp_io_len));\n\n    field = aml_field(\"PRST\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n    aml_append(field, aml_named_field(\"PRS\", 256));\n\n    aml_append(sb_scope, field);\n\n\n\n    /* build Processor object for each processor */\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        dev = aml_processor(i, 0, 0, \"CP%.02X\", i);\n\n\n\n        method = aml_method(\"_MAT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_MAT_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_STA\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call1(CPU_STATUS_METHOD, aml_int(i))));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"_EJ0\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method,\n\n            aml_return(aml_call2(CPU_EJECT_METHOD, aml_int(i), aml_arg(0)))\n\n        );\n\n        aml_append(dev, method);\n\n\n\n        aml_append(sb_scope, dev);\n\n    }\n\n\n\n    /* build this code:\n\n     *   Method(NTFY, 2) {If (LEqual(Arg0, 0x00)) {Notify(CP00, Arg1)} ...}\n\n     */\n\n    /* Arg0 = Processor ID = APIC ID */\n\n    method = aml_method(AML_NOTIFY_METHOD, 2, AML_NOTSERIALIZED);\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        ifctx = aml_if(aml_equal(aml_arg(0), aml_int(i)));\n\n        aml_append(ifctx,\n\n            aml_notify(aml_name(\"CP%.02X\", i), aml_arg(1))\n\n        );\n\n        aml_append(method, ifctx);\n\n    }\n\n    aml_append(sb_scope, method);\n\n\n\n    /* build \"Name(CPON, Package() { One, One, ..., Zero, Zero, ... })\"\n\n     *\n\n     * Note: The ability to create variable-sized packages was first\n\n     * introduced in ACPI 2.0. ACPI 1.0 only allowed fixed-size packages\n\n     * ith up to 255 elements. Windows guests up to win2k8 fail when\n\n     * VarPackageOp is used.\n\n     */\n\n    pkg = acpi_cpus <= 255 ? aml_package(acpi_cpus) :\n\n                             aml_varpackage(acpi_cpus);\n\n\n\n    for (i = 0; i < acpi_cpus; i++) {\n\n        uint8_t b = test_bit(i, cpu->found_cpus) ? 0x01 : 0x00;\n\n        aml_append(pkg, aml_int(b));\n\n    }\n\n    aml_append(sb_scope, aml_name_decl(CPU_ON_BITMAP, pkg));\n\n}\n", "idx": 15654, "substitutes": {"sb_scope": ["bg_theme", "sbJroot", "stabJslice", "sb_source", "sb_context", "sbJslice", "SB_scope", "sb_code", "stabJscope", "sbjdepth", "sbJtheme", "sbjmode", "sb_theme", "sb_rule", "sbjscope", "stab_private", "stab_slice", "bg_scope", "storagejscope", "sbJrule", "bg_rule", "storagejmode", "sb_scale", "sbJprivate", "sbJscope", "bg_code", "sb_root", "sbJcode", "sbjcontext", "storage_mode", "SB_root", "storage_depth", "sb_mode", "storagejdepth", "sb_slice", "storage_scope", "stabJprivate", "sb_private", "SB_scale", "stab_root", "stab_scope", "SB_source", "stabJroot", "storage_context", "sb_depth", "storagejcontext"], "acpi_cpus": ["acpi_copors", "acpi_mpus", "acpi_hpuses", "acpi_orpubes", "acpi__mpis", "acpi_mpubes", "acpi_cpuus", "acpi_copus", "acpi_mpuses", "acpi__cpus", "acpi_cpis", "acpi_hpums", "acpi_gpuses", "acpi_cpos", "acpi_mpums", "acpi_orpis", "acpi__cpubes", "acpi_hpis", "acpi_gpus", "acpi__cpis", "acpi_copis", "acpi_cpuuses", "acpi_gpubes", "acpi_gpos", "acpi__cpos", "acpi__mpubes", "acpi_gpums", "acpi_mpis", "acpi__mpos", "acpi_cpuses", "acpi_orpos", "acpi_orpus", "acpi_cpors", "acpi_cpuors", "acpi_copuses", "acpi_gpis", "acpi_hpus", "acpi_cpums", "acpi__mpus", "acpi_gpors", "acpi_mpos", "acpi_cpubes", "acpi_cpuis"], "cpu": ["proc", "mc", "amd", "pc", "lc", "vm", "cmp", "rpm", "pu", "mx", "conn", "processor", "loader", "mem", "fi", "cli", "CPU", "nc", "vidia", "uci", "gpu", "prem", "cp", "cache", "core", "hw", "gp"], "pm": ["m", "wm", "cm", "mc", "ram", "pc", "mp", "vp", "imm", "fm", "pg", "manager", "pool", "module", "vm", "umi", "mm", "ym", "model", "px", "em", "tm", "rpm", "pd", "gm", "mr", "plugin", "p", "bm", "PM", "mi", "pb", "cli", "pa", "iam", "gb", "hm", "rm", "am", "dem", "prem", "gem", "lv", "pi", "im", "param", "dim", "vim", "dm", "nm", "km", "gp"], "i": ["ani", "hi", "qi", "ui", "m", "adi", "I", "d", "ni", "xi", "id", "iu", "ini", "gi", "l", "oi", "io", "name", "mu", "ci", "ki", "di", "x", "si", "ie", "ii", "key", "v", "uri", "gu", "yi", "u", "ind", "p", "e", "mini", "fi", "cli", "li", "k", "b", "ix", "multi", "j", "n", "phi", "f", "ti", "ski", "ip", "c", "ji", "type", "chi", "uli", "pi", "bi", "ri", "r", "ami", "zi", "index"], "dev": ["bug", "device", "development", "env", "proc", "v", "self", "d", "dist", "service", "prov", "priv", "die", "home", "def", "test", "serial", "ve", "project", "di", "user", "Dev", "model", "comment", "error", "app", "package", "conf", "pu", "var", "der", "adv", "gu", "de", "prom", "clean", "pub", "av", "temp", "info", "engine", "pack", "ver", "data", "driver", "valid", "dom", "dep", "feature", "spec", "diff", "develop", "block", "dem", "DEV", "dim", "dd", "ev", "dn", "pos", "push", "debug", "dm", "wd", "node", "go", "err"], "crs": ["cRS", "Cros", "grs", "acrs", " cri", " csr", "prs", "csr", "acRS", "acrd", " cros", "scrc", "crc", "rcras", "grd", "cri", " cras", "pras", "cros", "scrs", "prd", "gsr", "rcrs", " crd", "grc", "gri", "rcRS", "cras", "Crs", "acrc", "pRS", "Crd", "scri", " crc", "acras", " cRS", "rcrc", "gros", "crd", "scsr", "Cri"], "pkg": ["proc", "priv", "api", "pool", "module", "cmp", "fp", "app", "package", "lib", "loader", "install", "plugin", "pack", "comp", "spec", "attr", "ssl", "cmd", "kg", "cp", "cache", "param", "prefix", "util", "core", "hw", "ctx", "gp"], "field": ["condition", "ff", "ignore", "input", "mount", "id", "style", "label", "def", "name", "row", "manager", "option", "post", "update", "model", "comment", "key", "force", "package", "value", "group", "term", "layer", "time", "engine", "Field", "match", "box", "bf", "f", "lf", "add", "diff", "block", "type", "attribute", "file", "attr", "change", "rule", "function", "FIELD", "cell", "dd", "tag", "lock", "off", "bl", "fc", "len", "round", "message"], "ifctx": ["libcontext", "libcb", "ifdef", "IFcontext", "libdef", "fcontext", "ifcontext", "IFctx", "fcb", "libctx", "fdef", "IFdef", "IFcb", "fctx", "ifcb"], "method": ["path", "record", "call", "sort", "self", "service", "fl", "label", "name", "fun", "source", "manager", "image", "send", "effect", "description", "option", "module", "user", "full", "model", "comment", "session", "member", "fn", "package", "value", "ul", "term", "Method", "plugin", "version", "time", "instance", "engine", "sign", "METHOD", "school", "url", "block", "end", "type", "function", "attr", "text", "process", "each", "util", "round", "message"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "e1000_mmio_read(void *opaque, target_phys_addr_t addr, unsigned size)\n\n{\n\n    E1000State *s = opaque;\n\n    unsigned int index = (addr & 0x1ffff) >> 2;\n\n\n\n    if (index < NREADOPS && macreg_readops[index])\n\n    {\n\n        return macreg_readops[index](s, index);\n\n    }\n\n    DBGOUT(UNKNOWN, \"MMIO unknown read addr=0x%08x\\n\", index<<2);\n\n    return 0;\n\n}\n", "idx": 15655, "substitutes": {"s": ["secondary", "south", "ses", "m", "service", "array", "sync", "fs", "i", "sym", "a", "S", "settings", "h", "status", "si", "scope", "sq", "session", "server", "v", "ss", "o", "p", "e", "socket", "sf", "sb", "n", "f", "state", "spec", "c", "is", "ssl", "states", "ops", "ds", "ips", "copy"]}}
{"project": "qemu", "commit_id": "c7dfbf322595ded4e70b626bf83158a9f3807c6a", "target": 1, "func": "static void ccid_on_apdu_from_guest(USBCCIDState *s, CCID_XferBlock *recv)\n\n{\n\n    uint32_t len;\n\n\n\n    if (ccid_card_status(s) != ICC_STATUS_PRESENT_ACTIVE) {\n\n        DPRINTF(s, 1,\n\n                \"usb-ccid: not sending apdu to client, no card connected\\n\");\n\n        ccid_write_data_block_error(s, recv->hdr.bSlot, recv->hdr.bSeq);\n\n        return;\n\n    }\n\n    len = le32_to_cpu(recv->hdr.dwLength);\n\n    DPRINTF(s, 1, \"%s: seq %d, len %d\\n\", __func__,\n\n                recv->hdr.bSeq, len);\n\n    ccid_add_pending_answer(s, (CCID_Header *)recv);\n\n    if (s->card) {\n\n        ccid_card_apdu_from_guest(s->card, recv->abData, len);\n\n    } else {\n\n        DPRINTF(s, D_WARN, \"warning: discarded apdu\\n\");\n\n    }\n\n}\n", "idx": 15664, "substitutes": {"s": ["secondary", "sys", "ses", "m", "self", "service", "t", "d", "sg", "sync", "fs", "your", "l", "private", "i", "sym", "rs", "sup", "g", "cs", "qs", "S", "submit", "new", "h", "os", "comments", "es", "js", "si", "sq", "session", "server", "v", "storage", "ss", "client", "o", "same", "w", "request", "u", "an", "sid", "p", "e", "se", "http", "site", "b", "sb", "n", "f", "tests", "gs", "spec", "c", "ns", "is", "stats", "ssl", "sv", "states", "services", "ds", "r", "ops", "su", "us", "support", "aws"], "recv": ["Recf", "conev", " recve", " recvd", "recq", "produvert", "produv", "recve", "recvar", " recsv", "recvm", "conv", "rcve", "produf", "rcvs", "rcV", "discV", "incf", "incvm", "incvert", "RecV", "conceive", "rcv", "ucv", "Recev", "conf", "convd", "Recvs", "Recov", " recvm", " recvert", "rcsv", " recV", "recf", " recf", "Recv", "recvd", "discq", "recov", "rcf", "rcq", "recvs", " recvar", " recq", "recceive", "rcceive", "recev", " recov", "recV", "recvert", "produvm", "discsv", "conve", "conov", "recsv", "conq", "ucf", "ucvar", "Recvar", "ucV", "incv", "discv", " recev", "rcov", "Recceive", "conV", " recvs", "Recvd"], "len": ["zen", "en", "lin", "d", "fl", "Len", "id", "l", "val", "lon", "lan", "lp", "dl", "str", "lang", "ie", "ld", "v", "lib", "dy", "z", "ll", "bl", "e", "fin", "li", "data", "base", "min", "length", "L", "ler", "f", "n", "lf", "line", "count", "il", "offset", "le", "sl", "all", "El", "seq", "pos", "num", "el", "span", "ln", "net", "err"]}}
{"project": "FFmpeg", "commit_id": "17dc7c7a60798d3e1f78bad97423fb49c8dc1c1d", "target": 0, "func": "void ff_h264_pred_init_x86(H264PredContext *h, int codec_id)\n\n{\n\n    mm_flags = mm_support();\n\n\n\n#if HAVE_YASM\n\n    if (mm_flags & FF_MM_MMX) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_mmx;\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmx;\n\n        h->pred8x8  [VERT_PRED8x8] = ff_pred8x8_vertical_mmx;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmx;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmx;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmx;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmx;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_MMX2) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_mmxext;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_mmxext;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_mmxext;\n\n        h->pred4x4  [DC_PRED     ] = ff_pred4x4_dc_mmxext;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_mmxext;\n\n            h->pred8x8  [DC_PRED8x8   ] = ff_pred8x8_dc_rv40_mmxext;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_mmxext;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_mmxext;\n\n            h->pred4x4  [VERT_PRED    ] = ff_pred4x4_vertical_vp8_mmxext;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE) {\n\n        h->pred16x16[VERT_PRED8x8] = ff_pred16x16_vertical_sse;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse;\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSE2) {\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_sse2;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred16x16[PLANE_PRED8x8] = ff_pred16x16_tm_vp8_sse2;\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_sse2;\n\n        }\n\n    }\n\n\n\n    if (mm_flags & FF_MM_SSSE3) {\n\n        h->pred16x16[HOR_PRED8x8 ] = ff_pred16x16_horizontal_ssse3;\n\n        h->pred16x16[DC_PRED8x8  ] = ff_pred16x16_dc_ssse3;\n\n        h->pred8x8  [HOR_PRED8x8 ] = ff_pred8x8_horizontal_ssse3;\n\n        if (codec_id == CODEC_ID_VP8) {\n\n            h->pred8x8  [PLANE_PRED8x8] = ff_pred8x8_tm_vp8_ssse3;\n\n            h->pred4x4  [TM_VP8_PRED  ] = ff_pred4x4_tm_vp8_ssse3;\n\n        }\n\n    }\n\n#endif\n\n}\n", "idx": 15679, "substitutes": {"h": ["hi", "m", "hp", "ch", "hl", "ha", "ssh", "ih", "hr", "oh", "t", "l", "hhh", "ah", "g", "hs", "auth", "x", "gh", "hash", "rh", "conn", "uh", "w", "hh", "z", "p", "y", "he", "eh", "http", "k", "f", "th", "hm", "bh", "c", "ht", "q", "r", "H", "sh", "host", "history", "hd", "hw", "him", "hist", "ph", "cl"], "codec_id": ["codecFvid", "codisc_name", "codec_ids", "codric_vid", "codric_status", "coduc_id", "codec_status", "codecFids", "codec_type", "codisc_type", "codecFid", "codec_vid", "codecFstatus", "codec_pid", "codric_ids", "codec_name", "codisc_id", "coduc_ids", "coduc_name", "coduc_pid", "codisc_ids", "codric_id"]}}
{"project": "qemu", "commit_id": "c7e35da348e2e4df072e6979c48fa5283e07d1db", "target": 1, "func": "static inline abi_long target_to_host_timespec(struct timespec *host_ts,\n\n                                               abi_ulong target_addr)\n\n{\n\n    struct target_timespec *target_ts;\n\n\n\n    if (!lock_user_struct(VERIFY_READ, target_ts, target_addr, 1))\n\n        return -TARGET_EFAULT;\n\n    host_ts->tv_sec = tswapal(target_ts->tv_sec);\n\n    host_ts->tv_nsec = tswapal(target_ts->tv_nsec);\n\n    unlock_user_struct(target_ts, target_addr, 0);\n\n    return 0;\n\n}\n", "idx": 15690, "substitutes": {"host_ts": ["target_tr", "target_ims", " host_times", " host_fs", " hostingcs", "host_times", "host_ims", "target_times", "host_tr", "host_ports", "hostingts", " host_cs", " hostingfs", "hostingfs", "target_cs", "hostingcs", "target_ports", "host_cs", " hostingts", "hostingtimes", "host_fs", " hostingtimes"], "target_addr": ["target_host", " target_address", " target_ord", "target_ptr", " target_host", "target_ord", " target_ptr", "target_address", " target_nr", "target_nr"], "target_ts": [" target_uts", "targetedcs", "targetablews", "targetablets", "target_t", "targetedts", " target_times", "target_Ts", "host_stats", "target_ws", "target_times", "targetedds", "target_uts", "target_ds", " target_cs", "target_struct", "host_times", "host_struct", " target_ds", "target_tests", "targetablett", "target_stats", "target_tt", "targetablecs", " target_t", " target_TS", " target_Ts", " target_tests", " target_tt", " target_ws", "target_TS", "targeteduts", "target_cs"]}}
{"project": "qemu", "commit_id": "5039d6e23586fe6bbedc5e4fe302b48a66890ade", "target": 0, "func": "void DMA_init(int high_page_enable, qemu_irq *cpu_request_exit)\n\n{\n\n}\n", "idx": 15696, "substitutes": {"high_page_enable": [" cpu_page_disable", " cpu_page_enabled", " cpu_page_enable", " cpu_page_open"], "cpu_request_exit": ["cpu_requestpreenable", "cpu_page_close", "cpu_requestprepass", "cpu_page_pass", "cpu_page_exit", "cpu_requestpreclose", "cpu_request_close", "cpu_request_enable", "cpu_requestpreexit", "cpu_request_pass", "cpu_page_enable"]}}
{"project": "FFmpeg", "commit_id": "51a1c1c6ac98d1d0d0a654f066782707af092fed", "target": 0, "func": "static void decode_delta_l(uint8_t *dst,\n\n                           const uint8_t *buf, const uint8_t *buf_end,\n\n                           int w, int flag, int bpp, int dst_size)\n\n{\n\n    GetByteContext off0, off1, dgb, ogb;\n\n    PutByteContext pb;\n\n    unsigned poff0, poff1;\n\n    int i, k, dstpitch;\n\n    int planepitch_byte = (w + 7) / 8;\n\n    int planepitch = ((w + 15) / 16) * 2;\n\n    int pitch = planepitch * bpp;\n\n\n\n    if (buf_end - buf <= 64)\n\n        return;\n\n\n\n    bytestream2_init(&off0, buf, buf_end - buf);\n\n    bytestream2_init(&off1, buf + 32, buf_end - (buf + 32));\n\n    bytestream2_init_writer(&pb, dst, dst_size);\n\n\n\n    dstpitch = flag ? (((w + 7) / 8) * bpp): 2;\n\n\n\n    for (k = 0; k < bpp; k++) {\n\n        poff0 = bytestream2_get_be32(&off0);\n\n        poff1 = bytestream2_get_be32(&off1);\n\n\n\n        if (!poff0)\n\n            continue;\n\n\n\n        if (2LL * poff0 >= buf_end - buf)\n\n            return;\n\n\n\n        if (2LL * poff1 >= buf_end - buf)\n\n            return;\n\n\n\n        bytestream2_init(&dgb, buf + 2 * poff0, buf_end - (buf + 2 * poff0));\n\n        bytestream2_init(&ogb, buf + 2 * poff1, buf_end - (buf + 2 * poff1));\n\n\n\n        while ((bytestream2_peek_be16(&ogb)) != 0xFFFF) {\n\n            uint32_t offset = bytestream2_get_be16(&ogb);\n\n            int16_t cnt = bytestream2_get_be16(&ogb);\n\n            uint16_t data;\n\n\n\n            offset = ((2 * offset) / planepitch_byte) * pitch + ((2 * offset) % planepitch_byte) + k * planepitch;\n\n            if (cnt < 0) {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                cnt = -cnt;\n\n                data = bytestream2_get_be16(&dgb);\n\n                for (i = 0; i < cnt; i++) {\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            } else {\n\n                bytestream2_seek_p(&pb, offset, SEEK_SET);\n\n                for (i = 0; i < cnt; i++) {\n\n                    data = bytestream2_get_be16(&dgb);\n\n                    bytestream2_put_be16(&pb, data);\n\n                    bytestream2_skip_p(&pb, dstpitch - 2);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 15723, "substitutes": {"dst": [" dsts", "adsc", "Dsc", "Dst", "Dsts", " dsc", "adst", "dsts", " dsrc", "idsc", "adsrc", "dsrc", "idbl", "dbl", "Dbl", "dsc", "idst", "idsts", " dbl", "adbl", "Dsrc"], "buf": ["aka", "port", "proc", "ff", "ha", "bc", "uint", "batch", "h", "pool", "fp", "loc", "begin", "br", "pub", "rb", "box", "c", "cb", "cas", "text", "cp", "off", "num", "window", "comb", "utf", "ru", "rc", "home", "ctr", "uf", "conv", "client", "img", "b", "wb", "length", "Buff", "cap", "um", "header", "filename", "path", "queue", "cv", "config", "fb", "large", "ref", "buffer", "bag", "desc", "http", "block", "cur", "bl", "ph", "ctx", "lim", "fw", "vec", "pkg", "uc", "orig", "ctrl", "hum", "dest", "buff", "av", "feat", "cli", "ab", "wav", "cmd", "src", "seq", "coord", "len"], "buf_end": ["bufipopen", "bufsbegin", "buf_ending", "buf_open", "bufsending", "buf67clean", "buf_start", "uf_ize", "bufsstart", "fbMexit", "pkg_stop", "bufMends", "buf2ending", "fbMend", "buf2end", " buf_edge", "buf_ends", "buf67exit", "buf_clean", "buf2id", "bufMexit", " buf_begin", "buf2start", "buf_id", "fbMclean", "uf_ending", "buffer2id", "bufipend", "fb_end", "uf_end", "buf_stop", "buf2clean", "buf67end", "buffer_start", " buf_start", "fbMends", "uf_start", "uf_ends", "buffer_end", "buf_size", "buf_edge", "fb_clean", "buf_exit", "buf2begin", "buffer2size", "buffer2start", "buf_for", "buf_ize", "buf2ender", "buf2exit", "bufipfor", "pkg_open", " buf_ending", " buf_ended", "buf2edge", "uf_ender", "buf2ends", "buf67ends", "buffer2end", "buffer_size", "uf_open", "bufMclean", "buf2ended", "fb_ends", "buf_begin", "bufipstart", "bufsend", "pkg_start", "buffer_id", "pkg_end", "bufMend", "buf2size", "buf_ender", "fb_exit", "buf_ended", "uf_for"], "w": ["word", "wh", "d", "iw", "l", "ww", "ew", "g", "wx", "h", "sw", "wt", "x", "wcs", "v", "web", "kw", "win", "wave", "p", "wal", "aw", "max", "wb", "b", "n", "rw", "c", "W", "tw", "wid", "wa", "fw", "wei", "wall", "wed", "we", "work", "wo", "window", "num", "wd", "wl", "hw", "ow"], "flag": ["ui", "ff", "bin", "FLAG", "bc", "nl", "sync", "binary", "xp", "v", "flags", "win", "band", "group", "wave", "z", "info", "ag", "nc", "byte", "count", "lf", "lag", "f", "mask", "big", "pin", "cb", "offset", "bg", "q", "debug", "Flag", "field", "empty", "pad", "fc", "len", "bit", "start"], "bpp": ["bcp", "ppps", " bupp", "fbpe", "bpo", "hsp", "psp", "sbpush", "lbpo", "fpp", "fbpp", "lcp", " bps", "fps", "lpo", "bupp", "hcpp", "ppp", " bcp", "pps", "sbcp", "lbpe", "sbpp", "lpp", " bpush", "pupp", "fff", "bff", "lbcp", "bsp", " bpe", "hpps", "pff", "bpps", "bps", "lbcpp", "fupp", "bpush", "lbsp", "hpp", "lpe", "sbpe", "pcpp", "lbpps", "bpe", "fbpo", "fbcp", " bff", "lbpush", "bcpp", "lbpp"], "dst_size": ["dst_addr", "dstblocksize", "dstblockname", "dst_Size", "dbl_size", "dbl_addr", "dst_name", "dstblockaddr", "dbl_name"], "off0": ["off12", "Off0", "offer0", "ff00", "ff1", "eff1", "Off8", "Off1", "Off00", "off8", "offZero", "eff00", "offer8", "offer12", "ff0", "off00", "off02", "ff02", "offset1", "Off12", " offZero", "Off02", "OffZero", "eff0", "flow0", "flow12", "offsetZero", "flow8", "offset0", "flow1", "offer1", "eff02"], "off1": ["offer2", "off2", " offone", "Off0", "OFF2", " offOne", "OFFOne", "offer0", "OFFone", "Off2", "Off1", "OffOne", "Off4", "off4", "OFF1", "offer4", "out0", "OFF0", "offerone", "offone", "offer1", "offOne", "out1", " off2", "out4"], "dgb": ["madgb", "adGB", "xdgl", "adgl", "bdGB", "bdgg", "adgg", "pdgb", "dgz", "pdGB", "pdbm", " dbm", " dGB", "madgz", "bdgl", "xdgg", "pdgz", "dgg", "bdgb", "adgb", "dgl", "madbm", "madGB", "xdgb", "xdGB", "dbm", " dgz", "dGB"], "ogb": ["ogf", "orgl", "ongc", "odf", "OGb", "agd", "ocd", "ogl", "agf", "ugb", "oggp", "ocb", "odl", "ogB", "oggB", "ocf", "odc", "agB", "ugc", "ongv", "ocp", "ogd", "OGc", "ugd", "oggf", "orgr", "orgc", "ocv", "OGf", "ogc", "OGB", "ogr", "odb", "ogp", "occ", "oggc", "orgb", "ongl", "ongb", "agb", "oggb", "ocl", "odp", "ugf", "ogv", "agc", "ongr", "odr", "orgv"], "pb": ["xb", "typ", "tx", "bc", " PB", "tmp", "pc", "jp", "bb", "fb", "ub", "pg", "lp", "fp", "bp", "pd", "p", "rb", "bm", "sb", "wb", "tc", "bf", "rw", "wp", "bh", "ab", " subp", "cb", "eb", "PB", "dp", "cp", "kb", "db", "src", "lb", "fc", "tp", "cpp"], "poff0": ["pOff1", "pnum86", "poffs1", "pdefNe", "puff06", " poffs0", " poffs3", "POff06", "poffer20", " pOff00", "poffset0", " poff00", "perrore", "pOff06", "poffsee", "Poff86", "puff1", "poff00", " pout0", "poffer90", "pdef86", "poff90", "pdef0", "pout20", " pout13", "pnum0", "qoffere", "peff00", "perror0", "poffere", "qoff90", "qoffer0", " poutee", "poff20", "peff0", " poff3", "pinfo20", "Poff4", "poffer0", "pout13", " poff13", "Poff1", "perrorNe", "pofferNe", " pOff0", "pnum1", "poffset1", "qoffNe", "puff0", "Poff0", "peff1", " pout20", "poffset3", "POff1", "poffsetee", "POff0", "pdef1", "poffe", "poff3", "pOff00", "perror90", "poffer13", "pinfoee", "pinfo0", "pdef90", "pofferee", "qoff0", "pnum4", "qoffe", "poff4", "poffs0", "poff06", "poutee", " poff20", "pout0", "pinfo13", " poffsee", " poffs1", "Poff06", " poffee", "poffee", "poffNe", "poffs3", "pOff0", "qoffer90", "poff13", " pOff1", "qofferNe", "poff86", "pdef4", "pdefe"], "poff1": ["pOff1", "poffs1", "poffOne", "pload0", "poff2", "pdef2", " pload1", "pOFF1", "POff81", " pOFF0", "poffn", "poffb", "poffset0", "Poff81", " pOFFn", "pfor0", "pdef0", " pload2", "poffsn", "POffn", " pload0", " pOFF1", "pOffn", "poffsetb", "pload1", " poffb", "pOff81", "Poff1", "pload2", "POffOne", "pfor1", "poffset1", "pOffOne", "Poff0", "POff1", "pOFFb", "POff0", "pdef1", "poffs81", "poffset81", "poffsetOne", "pforn", "pOFFn", "poffs0", " poffn", "poffsetn", "poff81", "PoffOne", " poff2", "pOFF0", "poffsOne", " pOFFb", "Poffn", "pOff0"], "i": ["it", "ui", "m", "I", "d", "l", "io", "g", "x", "ii", "v", "o", "u", "z", "ind", "p", "e", "info", "b", "j", "n", "f", "ip", "c", "pi", "ik", "index"], "k": ["ke", "dk", "kat", "m", "ek", "ak", "d", "kj", "unk", "ko", "g", "kick", "ki", "kn", "uk", "sk", "h", "x", "kk", "v", "kh", "kw", "o", "u", "z", "p", "e", "ok", "ku", "ck", "b", "j", "n", "f", "c", "K", "q", "kin", "r", "ik", "ky", "work", "y", "km", "kid", "ks"], "dstpitch": ["destpatch", "dstPose", "dstpitching", "dstwpose", "dstnpiece", "destnpitching", "dostPiece", "dstnpITCH", "dostPose", "destnpose", "dstpose", "dstwpitch", "dstnpose", "dstwpitching", "dstepose", "dstnpitching", "dstPiece", "dstwpatch", "dostpiece", "dstepitch", "destpose", "dostpose", "dstpITCH", "dstnpitch", "dstPitch", "dostPitch", "dostPITCH", "dstPITCH", "destnpatch", "dstpiece", "dstepITCH", "dstPitching", "destnpitch", "dstPatch", "dostpitch", "dostpITCH", "destpitching", "dstpatch", "destpitch", "dstnpatch", "dstepiece"], "data": ["partial", "bin", "complete", "batch", "shift", "val", "extra", "align", "bytes", "buffer", "raw", "total", "aa", "valid", "info", "block", "next", "Data", "body", "DATA", "pos", "pad", "len", "index", "start"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void intel_hda_mmio_writeb(void *opaque, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    IntelHDAState *d = opaque;\n\n    const IntelHDAReg *reg = intel_hda_reg_find(d, addr);\n\n\n\n    intel_hda_reg_write(d, reg, val, 0xff);\n\n}\n", "idx": 15728, "substitutes": {"opaque": ["OPec", "OPrc", "Opaque", "opdc", "opec", "oppaques", " oprc", "oppity", "oppacity", "opity", "ipopity", "oppaque", "opaques", "OPity", "ipopacity", " opdc", "OPaques", "ipopaque", "opacity", "OPacity", "oprc", "ipopaques", "Opec", "Oprc", "OPaque", "Opdc", " opec", "OPdc"], "addr": ["ord", "alt", "device", "fd", "enc", "arm", "amd", "config", "pc", "rc", "inter", "align", "x", "ref", "arg", "xp", "ace", "grad", "ad", "adr", "ind", "pointer", "data", "mode", "point", "address", "state", "offset", "attr", "rt", "host", "mac", "src", "nr", "dr", "pos", "prefix", "pad", "coord", "ptr", "index"], "val": ["ret", "slot", "pt", "cond", "VAL", "eval", "x", "ref", "unit", "arg", "vol", "lit", "loc", "valid", "v", "value", "grad", "buf", "data", "b", "base", "arr", "offset", "Val", "al", "sel", "el", "bl", "len", "vals", "index"], "d": ["D", "dh", "m", "t", "fd", "l", "i", "id", "da", "ded", "bd", "g", "di", "ld", "o", "gd", "cd", "ad", "z", "ind", "p", "e", "k", "data", "b", "sd", "f", "dat", "state", "c", "dt", "dc", "md", "ade", "r", "ds", "od", "db", "dom"], "reg": ["enc", "config", "pc", "g", "pg", "ig", "rg", "eg", "acc", "arg", "mod", "loc", "ld", "conn", "win", "grad", "ad", "bl", "rec", "mem", "ind", "sec", "stat", "Reg", "dat", "arr", "ac", "re", "REG", "r", "exec", "tag", "res", "debug", "red"]}}
{"project": "qemu", "commit_id": "1a29cc8f5ebd657e159dbe4be340102595846d42", "target": 0, "func": "void serial_realize_core(SerialState *s, Error **errp)\n\n{\n\n    if (!qemu_chr_fe_backend_connected(&s->chr)) {\n\n        error_setg(errp, \"Can't create serial device, empty char device\");\n\n        return;\n\n    }\n\n\n\n    s->modem_status_poll = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) serial_update_msl, s);\n\n\n\n    s->fifo_timeout_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, (QEMUTimerCB *) fifo_timeout_int, s);\n\n    qemu_register_reset(serial_reset, s);\n\n\n\n    qemu_chr_fe_set_handlers(&s->chr, serial_can_receive1, serial_receive1,\n\n                             serial_event, NULL, s, NULL, true);\n\n    fifo8_create(&s->recv_fifo, UART_FIFO_LENGTH);\n\n    fifo8_create(&s->xmit_fifo, UART_FIFO_LENGTH);\n\n    serial_reset(s);\n\n}\n", "idx": 15775, "substitutes": {"s": ["i", "rs", "qs", "js", "si", "server", "ps", "spec", "c", "serv", "is", "sl", "states", "aws", "south", "m", "self", "d", "sync", "t", "sg", "fs", "sym", "g", "cs", "es", "session", "client", "w", "u", "socket", "b", "sf", "ns", "ops", "r", "ks", "secondary", "sys", "service", "os", "sets", "secure", "o", "e", "sec", "site", "http", "sb", "f", "services", "ls", "ses", "l", "a", "S", "settings", "sq", "v", "conf", "ss", "set", "p", "plugins", "n", "gs", "xs", "stats", "ssl", "side", "ds", "su", "ts"], "errp": [" errr", " errpe", "erpre", "erpc", "erpe", "frpre", "errr", "rrpre", " errpre", "rrp", "errpe", "frpe", "errP", " errP", "erp", "rrP", "errpre", "frp", "frpc", "errpc", " errpc", "erP", "rrr", "err"]}}
{"project": "qemu", "commit_id": "44bc910794eff956ceba0030f0751a26bed748b5", "target": 0, "func": "static int get_physical_address(CPUPPCState *env, mmu_ctx_t *ctx,\n\n                                target_ulong eaddr, int rw, int access_type)\n\n{\n\n    int ret;\n\n\n\n#if 0\n\n    qemu_log(\"%s\\n\", __func__);\n\n#endif\n\n    if ((access_type == ACCESS_CODE && msr_ir == 0) ||\n\n        (access_type != ACCESS_CODE && msr_dr == 0)) {\n\n        if (env->mmu_model == POWERPC_MMU_BOOKE) {\n\n            /* The BookE MMU always performs address translation. The\n\n               IS and DS bits only affect the address space.  */\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n        } else if (env->mmu_model == POWERPC_MMU_BOOKE206) {\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                                   access_type);\n\n        } else {\n\n            /* No address translation.  */\n\n            ret = check_physical(env, ctx, eaddr, rw);\n\n        }\n\n    } else {\n\n        ret = -1;\n\n        switch (env->mmu_model) {\n\n        case POWERPC_MMU_32B:\n\n        case POWERPC_MMU_601:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment32(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n        case POWERPC_MMU_SOFT_6xx:\n\n        case POWERPC_MMU_SOFT_74xx:\n\n            /* Try to find a BAT */\n\n            if (env->nb_BATs != 0) {\n\n                ret = get_bat(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            if (ret < 0) {\n\n                /* We didn't match any BAT entry or don't have BATs */\n\n                ret = get_segment_6xx_tlb(env, ctx, eaddr, rw, access_type);\n\n            }\n\n            break;\n\n\n\n#if defined(TARGET_PPC64)\n\n        case POWERPC_MMU_64B:\n\n        case POWERPC_MMU_2_06:\n\n        case POWERPC_MMU_2_06d:\n\n            ret = get_segment64(env, ctx, eaddr, rw, access_type);\n\n            break;\n\n#endif\n\n\n\n        case POWERPC_MMU_SOFT_4xx:\n\n        case POWERPC_MMU_SOFT_4xx_Z:\n\n            ret = mmu40x_get_physical_address(env, ctx, eaddr,\n\n                                              rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE:\n\n            ret = mmubooke_get_physical_address(env, ctx, eaddr,\n\n                                                rw, access_type);\n\n            break;\n\n        case POWERPC_MMU_BOOKE206:\n\n            ret = mmubooke206_get_physical_address(env, ctx, eaddr, rw,\n\n                                               access_type);\n\n            break;\n\n        case POWERPC_MMU_MPC8xx:\n\n            /* XXX: TODO */\n\n            cpu_abort(env, \"MPC8xx MMU model is not implemented\\n\");\n\n            break;\n\n        case POWERPC_MMU_REAL:\n\n            cpu_abort(env, \"PowerPC in real mode do not do any translation\\n\");\n\n            return -1;\n\n        default:\n\n            cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n#if 0\n\n    qemu_log(\"%s address \" TARGET_FMT_lx \" => %d \" TARGET_FMT_plx \"\\n\",\n\n             __func__, eaddr, ret, ctx->raddr);\n\n#endif\n\n\n\n    return ret;\n\n}\n", "idx": 15779, "substitutes": {"env": ["en", "enh", "esp", "oa", "event", "server", "np", "obj", "dev", "spec", "c", "ec", "chal", "context", "cdn", "eu", "lc", "txt", "vm", "console", "equ", "viron", "fi", "eni", "dt", "qv", "cal", "exec", "cache", "ev", "ou", "lv", "iss", "erv", "ea", "cv", "config", "kn", "init", "scope", "conn", "e", "exc", "engine", "nc", "site", "eng", "qt", "Environment", "dep", "global", "ne", "osc", "que", "pos", "cur", "hw", "net", "enc", "act", "v", "conf", "inv", "energy", "chn", "cli", "dat", "shell", "org", "db", "environment", "util", "vs", "et", "esi"], "ctx": ["sem", "proc", "context", "ch", "tx", "pkg", "bc", "qa", "gz", "cv", "enc", "tk", "rc", "config", "sync", "jp", "ca", "utils", "lc", "ctrl", "ci", "qs", "conv", "cn", "wcs", "cmp", "linux", "fp", "ct", "loc", "conf", "conn", "kw", "np", "lib", "obj", "client", "exc", "cli", "nc", "kt", "qt", "inst", "state", "c", "cu", "cb", "cas", "sci", "sc", "cf", "exec", "que", "vc", "xc", "src", "environment", "git", "hw", "cl", "fw"], "eaddr": ["asyhr", "adydr", "efdr", "cehr", "reamric", "cedr", "cefr", "oadric", "ewayder", "adybr", "ealdress", "asydr", "ealdr", "asyfr", "ewaydr", "eadder", "reamder", "ecdr", "egdr", "eadDr", "ewayDr", "eybr", "eadfr", "ellhr", "eadhr", "eadbr", "adyhr", "eyhr", "ellfr", "ealder", "adyDR", "ayder", "asyDR", "egdress", "ecDR", "ecDr", "eadDR", "ayDR", "oadder", "eghr", "egder", "ealDR", "eeddr", "egbr", "ayric", "eadric", "efDr", "egfr", "efDR", "eedder", "aydr", "ellder", "ecder", "ayfr", "eedDR", "oadDR", "ceDR", "aydress", "asyder", "egDR", "oaddr", "ayhr", "ellDR", "eydr", "adyfr", "efder", "oadhr", "elldr", "eedfr", "ewayDR", "eyDR", "eaddress", "reamDR", "reamdr"], "rw": ["wer", "rr", "wk", "wh", "vr", "ru", "iw", "worker", "ww", "ew", "row", "rn", "wx", "rg", "sw", "wt", "wcs", "sr", "raw", "writer", "rh", "wn", "nw", "kw", "war", "w", "rew", "lr", "wal", "rb", "ring", "rx", "wb", "wu", "rack", "wp", "nor", "rl", "dra", "tw", "lv", "wa", "r", "resp", "vc", "work", "RW", "wo", "wl", "usr", "rf", "hw", "wd", "wr", "fw"], "access_type": ["accesstypetypes", " access_address", "access_role", "accessXlevel", "access_level", "access_site", " access_length", "accessabletype", "access_TYPE", "accessableaddress", "accesstypetype", "accessettype", "access_value", "accessablelevel", " access_model", " access_class", "accessalblock", "accessetvalue", "access_style", " access_level", " access_rel", " access_key", "accessentime", " access_value", "access_types", "access_model", "accessingTYPE", "access_block", "access_address", "access_field", "accessetclass", "accesstypelevel", "accessallength", "accessingtype", "accessingcode", " access_role", "access_length", "access_code", " access_types", " access_TYPE", "accessXtype", "accessalrole", "accessaltype", "accessallevel", "accesstypeaddress", " access_site", " access_field", " access_block", " access_style", "accessingkey", "accessalkey", "access_rel", "accessentype", "access_ver", " access_ver", "accessXmodel", " access_code", "accessabletypes", "access_class", " access_time", "access_key", "access_time", "accessenmodel"], "ret": ["pet", "alt", "ft", "let", "rev", "part", "reply", "art", "rc", "id", "val", "back", "def", "rets", "gt", "fun", "std", "status", "ref", "arg", "det", "lit", "error", "job", "aug", "feat", "pass", "ut", "obj", "mt", "mem", "info", "lt", "success", "match", "ext", "Ret", "bf", "result", "fit", " RET", "att", "rl", "url", "cat", "arr", "nt", "re", "rt", "resp", "db", "RET", "res", "num", "reg", "cur", "flag", "len", "opt", "bit", "err"]}}
{"project": "qemu", "commit_id": "35c648078aa493c3b976840eb7cf2e53ab5b7a2d", "target": 0, "func": "static uint8_t eeprom24c0x_read(void)\n\n{\n\n    logout(\"%u: scl = %u, sda = %u, data = 0x%02x\\n\",\n\n        eeprom.tick, eeprom.scl, eeprom.sda, eeprom.data);\n\n    return eeprom.sda;\n\n}\n", "idx": 15788, "substitutes": {}}
{"project": "qemu", "commit_id": "6a8f9661dc3c088ed0d2f5b41d940190407cbdc5", "target": 0, "func": "static void blockdev_do_action(int kind, void *data, Error **errp)\n\n{\n\n    TransactionAction action;\n\n    TransactionActionList list;\n\n\n\n    action.kind = kind;\n\n    action.data = data;\n\n    list.value = &action;\n\n    list.next = NULL;\n\n    qmp_transaction(&list, errp);\n\n}\n", "idx": 15791, "substitutes": {"kind": ["ke", "func", "path", "head", "context", "part", "id", "code", "mid", "style", "shape", "def", "name", "kick", "sth", "std", "method", "init", "lit", "nd", "dest", "dir", "feat", "ind", "sid", "plugin", "Kind", "good", "direction", "kt", "k", "concept", "mode", "th", "spec", "brand", "end", "type", "IND", "cmd", "class", "decl", "need", "cycle", "prop", "depth", "in", "kid", "tick", "start"], "data": ["args", "device", "draw", "actions", "record", "database", "done", "parts", "d", "input", "array", "response", "batch", "val", "object", "da", "a", "name", "api", "values", "image", "progress", "new", "missing", "raw", "key", "value", "alpha", "media", "params", "options", "resource", "primary", "base", "entry", "multi", "parent", "dat", "result", "state", "next", "arr", "Data", "type", "function", "body", "results", "DATA", "load", "exec", "dd", "post", "index", "start"], "errp": [" errpe", "rrpc", "erfp", "rrfp", "erpc", " errap", "rrp", "errpe", "errfp", "derp", "derpe", " errfp", "erap", "erp", "rrap", "derpc", "errap", " errlp", "arrpc", "errpc", "errlp", "derlp", "arrp", "arrpe", " errpc", "arrlp"], "action": ["actions", "call", "before", "self", "tx", "sort", "ction", "edit", "bin", "array", "response", "sync", "root", "l", "val", "a", "account", "api", "current", "ass", "act", "actor", "event", "this", "section", "option", "init", "commit", "error", "step", "admin", "element", "active", "stage", "version", "ACTION", "base", "entry", "result", "parent", "export", "item", "block", "next", "Action", "ac", "type", "function", "change", "out", "all", "load", "ack", "save", "index"], "list": ["show", "record", "call", "self", "part", "array", "sync", "batch", "l", "code", "object", "val", "act", "test", "null", "plan", "sequence", "LIST", "value", "chain", "set", "filter", "List", "view", "p", "e", "li", "base", "entry", "L", "n", "result", "join", "add", "item", "block", "arr", "type", "loop", "change", "out", "all", "load", "coll", "class", "lock", "tail", "cl", "index"]}}
{"project": "FFmpeg", "commit_id": "659d4ba5af5d72716ee370bb367c741bd15e75b4", "target": 0, "func": "static void h263_h_loop_filter_mmx(uint8_t *src, int stride, int qscale)\n\n{\n\n    if (CONFIG_H263_DECODER || CONFIG_H263_ENCODER) {\n\n        const int strength = ff_h263_loop_filter_strength[qscale];\n\n        DECLARE_ALIGNED(8, uint64_t, temp)[4];\n\n        uint8_t *btemp = (uint8_t*)temp;\n\n\n\n        src -= 2;\n\n\n\n        transpose4x4(btemp,     src,              8, stride);\n\n        transpose4x4(btemp + 4, src + 4 * stride, 8, stride);\n\n        __asm__ volatile (\n\n            H263_LOOP_FILTER // 5 3 4 6\n\n\n\n            : \"+m\"(temp[0]),\n\n              \"+m\"(temp[1]),\n\n              \"+m\"(temp[2]),\n\n              \"+m\"(temp[3])\n\n            : \"g\"(2 * strength), \"m\"(ff_pb_FC)\n\n            );\n\n\n\n        __asm__ volatile (\n\n            \"movq      %%mm5, %%mm1         \\n\\t\"\n\n            \"movq      %%mm4, %%mm0         \\n\\t\"\n\n            \"punpcklbw %%mm3, %%mm5         \\n\\t\"\n\n            \"punpcklbw %%mm6, %%mm4         \\n\\t\"\n\n            \"punpckhbw %%mm3, %%mm1         \\n\\t\"\n\n            \"punpckhbw %%mm6, %%mm0         \\n\\t\"\n\n            \"movq      %%mm5, %%mm3         \\n\\t\"\n\n            \"movq      %%mm1, %%mm6         \\n\\t\"\n\n            \"punpcklwd %%mm4, %%mm5         \\n\\t\"\n\n            \"punpcklwd %%mm0, %%mm1         \\n\\t\"\n\n            \"punpckhwd %%mm4, %%mm3         \\n\\t\"\n\n            \"punpckhwd %%mm0, %%mm6         \\n\\t\"\n\n            \"movd      %%mm5, (%0)          \\n\\t\"\n\n            \"punpckhdq %%mm5, %%mm5         \\n\\t\"\n\n            \"movd      %%mm5, (%0, %2)      \\n\\t\"\n\n            \"movd      %%mm3, (%0, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm3, %%mm3         \\n\\t\"\n\n            \"movd      %%mm3, (%0, %3)      \\n\\t\"\n\n            \"movd      %%mm1, (%1)          \\n\\t\"\n\n            \"punpckhdq %%mm1, %%mm1         \\n\\t\"\n\n            \"movd      %%mm1, (%1, %2)      \\n\\t\"\n\n            \"movd      %%mm6, (%1, %2, 2)   \\n\\t\"\n\n            \"punpckhdq %%mm6, %%mm6         \\n\\t\"\n\n            \"movd      %%mm6, (%1, %3)      \\n\\t\"\n\n            :: \"r\"(src),\n\n               \"r\"(src + 4 * stride),\n\n               \"r\"((x86_reg)stride),\n\n               \"r\"((x86_reg)(3 * stride))\n\n            );\n\n    }\n\n}\n", "idx": 15804, "substitutes": {"src": ["rib", "bc", "dist", "inf", "supp", "shape", "low", "loc", "ind", "temp", "rb", "spec", "c", "cb", "text", "sc", "transform", "attr", "sl", "sur", "fc", "bis", "slice", "sync", "rc", "seed", "iv", "ctr", "sup", "req", "lower", "conv", "sr", "grad", "img", "s", "data", "b", "length", "inst", "url", "r", "ptr", "gz", "config", "source", "ie", "lit", "secure", "sec", "comp", "gb", "chrom", "sel", "cur", "RC", "input", "tmp", "shift", "stream", "send", "dest", "gl", "buf", "bg", "ssl", "scale", "seq", "start"], "stride": ["strid", "trade", " strine", "strision", "Strine", "strider", "dride", " strid", "striding", "chider", "stides", "Stride", "stided", "staid", "trided", "Strider", "Strade", "spide", "staide", "stidi", "chidi", "strided", " strate", "drision", "spade", "staider", "octide", "briding", "staided", "StrIDE", " strider", "trIDE", "strade", "Strides", "stine", "spides", "spided", "Stridi", "bride", "Strided", "state", "octides", " strides", " stridi", " strIDE", "strIDE", "octided", "slide", "brides", "strides", "slides", "Strid", "drides", "slision", "brision", "sliding", "octate", "chide", "stridi", "trides", "strate", "chided", "tride", "driding", "stide", " strided", "strine"], "qscale": ["qgrade", "dqseed", "qseed", "qtile", " qgrade", "qtscale", " qslice", "eqseed", "qslice", "dqtile", "Qslice", "dqscale", "eqtile", "qtslice", "Qscale", "qtgrade", "Qseed", "qrate", "eqrate", "Qgrade", "dqrate", "Qtile", "Qrate", "eqscale"], "btemp": ["ntmp", "sbtem", "bflat", "sbtmp", "pfont", "ntem", "rtemp", "ptx", "bfont", "Btem", "sbfont", "rtem", "sbtemp", "btx", "ntemp", "bTemp", "lbtmp", "lbfont", "lbtemp", "rflat", " bflat", "btem", "ptemp", "mtem", "sbtx", "sbflat", "btmp", "Bflat", "Btemp", "ptmp", "rtmp", "mflat", "nflat", " btem", "BTemp", "lbtx", "mTemp", "mtemp", " bTemp"], "H263_LOOP_FILTER": ["H263_LOOP_FLTER", "H263_LOOP_ILTE", "H263_LOOP_FLER", "H263_LOOP_FILER", "H263_LOOP_ILTER", "H263_LOOP_AFTER", "H263_LOOP_FLTE", "H263_LOOP_FLVER", "H263_LOOP_ILER", "H263_LOOP_AFER", "H263_LOOP_AFVER", "H263_LOOP_AFTE", "H263_LOOP_FILVER", "H263_LOOP_ILVER", "H263_LOOP_FILTE"], "m": ["mc", "cm", "d", "t", "l", "i", "imm", "a", "fm", "g", "h", "x", "vm", "ym", "v", "tm", "o", "w", "ms", "gm", "mt", "u", "p", "e", "s", "bm", "mi", "b", "j", "n", "f", "c", "pm", "M", "im", "r", "y", "sm", "mu"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void bootp_reply(struct bootp_t *bp)\n\n{\n\n    BOOTPClient *bc;\n\n    struct mbuf *m;\n\n    struct bootp_t *rbp;\n\n    struct sockaddr_in saddr, daddr;\n\n    struct in_addr dns_addr;\n\n    int dhcp_msg_type, val;\n\n    uint8_t *q;\n\n\n\n    /* extract exact DHCP msg type */\n\n    dhcp_decode(bp->bp_vend, DHCP_OPT_LEN, &dhcp_msg_type);\n\n    dprintf(\"bootp packet op=%d msgtype=%d\\n\", bp->bp_op, dhcp_msg_type);\n\n\n\n    if (dhcp_msg_type == 0)\n\n        dhcp_msg_type = DHCPREQUEST; /* Force reply for old BOOTP clients */\n\n\n\n    if (dhcp_msg_type != DHCPDISCOVER &&\n\n        dhcp_msg_type != DHCPREQUEST)\n\n        return;\n\n    /* XXX: this is a hack to get the client mac address */\n\n    memcpy(client_ethaddr, bp->bp_hwaddr, 6);\n\n\n\n    if ((m = m_get()) == NULL)\n\n        return;\n\n    m->m_data += IF_MAXLINKHDR;\n\n    rbp = (struct bootp_t *)m->m_data;\n\n    m->m_data += sizeof(struct udpiphdr);\n\n    memset(rbp, 0, sizeof(struct bootp_t));\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n    new_addr:\n\n        bc = get_new_addr(&daddr.sin_addr);\n\n        if (!bc) {\n\n            dprintf(\"no address left\\n\");\n\n            return;\n\n        }\n\n        memcpy(bc->macaddr, client_ethaddr, 6);\n\n    } else {\n\n        bc = find_addr(&daddr.sin_addr, bp->bp_hwaddr);\n\n        if (!bc) {\n\n            /* if never assigned, behaves as if it was already\n\n               assigned (windows fix because it remembers its address) */\n\n            goto new_addr;\n\n        }\n\n    }\n\n\n\n    if (bootp_filename)\n\n        snprintf((char *)rbp->bp_file, sizeof(rbp->bp_file), \"%s\",\n\n                 bootp_filename);\n\n\n\n    dprintf(\"offered addr=%08x\\n\", ntohl(daddr.sin_addr.s_addr));\n\n\n\n    saddr.sin_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_ALIAS);\n\n    saddr.sin_port = htons(BOOTP_SERVER);\n\n\n\n    daddr.sin_port = htons(BOOTP_CLIENT);\n\n\n\n    rbp->bp_op = BOOTP_REPLY;\n\n    rbp->bp_xid = bp->bp_xid;\n\n    rbp->bp_htype = 1;\n\n    rbp->bp_hlen = 6;\n\n    memcpy(rbp->bp_hwaddr, bp->bp_hwaddr, 6);\n\n\n\n    rbp->bp_yiaddr = daddr.sin_addr; /* Client IP address */\n\n    rbp->bp_siaddr = saddr.sin_addr; /* Server IP address */\n\n\n\n    daddr.sin_addr.s_addr = 0xffffffffu;\n\n\n\n    q = rbp->bp_vend;\n\n    memcpy(q, rfc1533_cookie, 4);\n\n    q += 4;\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPOFFER;\n\n    } else if (dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_MSG_TYPE;\n\n        *q++ = 1;\n\n        *q++ = DHCPACK;\n\n    }\n\n\n\n    if (dhcp_msg_type == DHCPDISCOVER ||\n\n        dhcp_msg_type == DHCPREQUEST) {\n\n        *q++ = RFC2132_SRV_ID;\n\n        *q++ = 4;\n\n        memcpy(q, &saddr.sin_addr, 4);\n\n        q += 4;\n\n\n\n        *q++ = RFC1533_NETMASK;\n\n        *q++ = 4;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0xff;\n\n        *q++ = 0x00;\n\n\n\n        if (!slirp_restrict) {\n\n            *q++ = RFC1533_GATEWAY;\n\n            *q++ = 4;\n\n            memcpy(q, &saddr.sin_addr, 4);\n\n            q += 4;\n\n\n\n            *q++ = RFC1533_DNS;\n\n            *q++ = 4;\n\n            dns_addr.s_addr = htonl(ntohl(special_addr.s_addr) | CTL_DNS);\n\n            memcpy(q, &dns_addr, 4);\n\n            q += 4;\n\n        }\n\n\n\n        *q++ = RFC2132_LEASE_TIME;\n\n        *q++ = 4;\n\n        val = htonl(LEASE_TIME);\n\n        memcpy(q, &val, 4);\n\n        q += 4;\n\n\n\n        if (*slirp_hostname) {\n\n            val = strlen(slirp_hostname);\n\n            *q++ = RFC1533_HOSTNAME;\n\n            *q++ = val;\n\n            memcpy(q, slirp_hostname, val);\n\n            q += val;\n\n        }\n\n    }\n\n    *q++ = RFC1533_END;\n\n\n\n    m->m_len = sizeof(struct bootp_t) -\n\n        sizeof(struct ip) - sizeof(struct udphdr);\n\n    udp_output2(NULL, m, &saddr, &daddr, IPTOS_LOWDELAY);\n\n}\n", "idx": 15811, "substitutes": {"bp": ["bt", "proc", "hp", "pkg", "batch", "jp", "pc", "vp", "mp", "bb", "fb", "pg", "sp", "orb", "lp", "nb", "pp", "ap", "fp", "bitcoin", "np", "plugin", "p", "ctx", "bm", "ib", "pb", "cli", "sb", "b", "wb", "bf", "arp", "gb", "wp", "bh", "pm", "cb", "eb", "cp", "BP", "kb", "db", "lb", "prefix", "git", "tp", "cpp", "gp"], "bc": ["mc", "uc", "cm", "ha", "ca", "sync", "core", "rc", "cc", "pc", "code", "bb", "config", "lic", "fb", "bn", "bd", "msg", "gc", "bs", "lc", "ctrl", "ci", "BC", "cms", "ref", "cmp", "abc", "loc", "cgi", "br", "web", "conn", "cr", "lib", "oc", "sec", "ok", "exc", "nc", "pb", "tc", "sb", "b", "bf", "acl", "c", "cca", "dc", "jc", "ac", "anc", "cb", "bo", "sc", "CBC", "bg", "cf", "cp", "bi", "vc", "xc", "db", "ec", "cache", "lb", "ou", "fc", "cl"], "m": ["mc", "cm", "wm", "d", "t", "l", "i", "sym", "msg", "fm", "g", "manager", "h", "mn", "module", "vm", "mm", "ym", "machine", "v", "tm", "em", "o", "ms", "gm", "mr", "mt", "p", "e", "media", "bm", "u", "b", "j", "n", "f", "mad", "mo", "hm", "ma", "rm", "am", "c", "M", "md", "man", "im", "r", "om", "um", "dm", "y", "sm", "mu"], "rbp": ["rlpr", "rlp", "fbpe", "cbp", "erbP", "rrpp", "robm", "rltp", "rbpe", "robpe", "cbc", "cbpe", "rfm", "rbpr", "erbp", "nrpp", "rcp", "rcpp", "rrpa", "dbpr", "crc", "rrp", "robc", "RBpr", "erbc", "rbvp", "rbc", "rbP", "sbp", "nrpa", "cbP", "rbm", "rbpg", "crp", "fbp", "rcpa", "erbvp", "RBpg", "rdc", "rfp", "rbtp", "rrpr", "erbpe", "dbp", "RBp", "sbP", "nrp", "sbvp", "rdvp", "rbpp", "rbpa", "nrpr", "crP", "erbm", "rdP", "dbpg", "rcpr", "robp", "dbtp", "rlpg", "sbc", "RBtp", "rfpe", "fbP", "fbc", "rdp", "crpe", "rfc"], "saddr": ["hptr", "ghost", "fptr", "dsarr", "fhost", "shost", "Saddress", "dhost", "Saddr", "southaddress", "serg", "dserg", "sptr", "srt", "fhop", "hhop", "southaddr", "sarr", "southerg", "shop", " saddress", " shost", "dsaddress", "dptr", " serg", "Shost", "dhop", "gaddress", "hhost", "dsaddr", "southarr", "gaddr", " sarr", " srt", "Srt", "saddress", "grt", "faddr", "haddr"], "daddr": ["sdorig", "daddress", " dadr", "sdaug", "pdorig", "sdaddress", " dadd", "dorder", "diptr", " daddress", "sdorder", "adaddress", " dorder", "sdaddr", "adadr", "pdaddr", "sptr", "diaddr", "sdalign", "sdarr", "pdalign", "sarr", "sadr", "darr", " daug", "sdadr", "diaddress", "sadd", "daug", "sorder", "dadd", "dptr", "diadd", " dorig", " darr", "dorig", " dptr", "pdaddress", "adarr", "saug", "dalign", " dalign", "dadr", "saddress", "adaddr"], "dns_addr": ["dnet_addr", "dnet_error", "dnet_server", "dnet_address", "dnsiperror", "dnsipaddress", "dns_error", "dns_address", "dnsipserver", "dns_server", "dnsipaddr"], "dhcp_msg_type": ["dhcp_msg_value", "dhcp_msg_Type", "dhcp_message_class", "dhcp_msg2types", "dhcp_msg4id", "dhcp_message_key", "dhcp_msg_types", "dhcp_msg2set", "dhcp_msg_name", "dhcp_msg4style", "dhcp_message_no", "dhcp_msg_info", "dhcp_msgxid", "dhcp_msgxtype", "dhcp_message_name", "dhcp_message_type", "dhcp_message_value", "dhcp_msg_key", "dhcp_message_info", "dhcp_msg_id", "dhcp_msgxkey", "dhcp_msg2type", "dhcp_msg_no", "dhcp_message_types", "dhcp_msg4value", "dhcp_msg_class", "dhcp_message_set", "dhcp_msg4type", "dhcp_msg_set", "dhcp_message_style", "dhcp_msgxno", "dhcp_msg2id", "dhcp_message_Type", "dhcp_msg_style", "dhcp_message_id"], "val": ["ret", "slot", "enc", "msg", "eval", "x", "ref", "key", "valid", "v", "value", "mem", "sec", "buf", "data", "byte", "timeout", "offset", "resp", "fee", "seq", "al", "sel", "num", "len", "vals", "bit"], "q": ["qa", "dq", "config", "quant", "required", "g", "req", "buffer", "sq", "key", "v", "w", "eq", "k", "qt", "P", "f", "query", "c", "iq", "r", "qq", "seq", "num", "quality", "Q", "bit"]}}
{"project": "qemu", "commit_id": "4445b1d27ee65ceee12b71bc20242996c8eb5cf8", "target": 0, "func": "static uint32_t drc_isolate_physical(sPAPRDRConnector *drc)\n\n{\n\n    switch (drc->state) {\n\n    case SPAPR_DRC_STATE_PHYSICAL_POWERON:\n\n        return RTAS_OUT_SUCCESS; /* Nothing to do */\n\n    case SPAPR_DRC_STATE_PHYSICAL_CONFIGURED:\n\n        break; /* see below */\n\n    case SPAPR_DRC_STATE_PHYSICAL_UNISOLATE:\n\n        return RTAS_OUT_PARAM_ERROR; /* not allowed */\n\n    default:\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    /* if the guest is configuring a device attached to this DRC, we\n\n     * should reset the configuration state at this point since it may\n\n     * no longer be reliable (guest released device and needs to start\n\n     * over, or unplug occurred so the FDT is no longer valid)\n\n     */\n\n    g_free(drc->ccs);\n\n    drc->ccs = NULL;\n\n\n\n    drc->state = SPAPR_DRC_STATE_PHYSICAL_POWERON;\n\n\n\n    if (drc->unplug_requested) {\n\n        uint32_t drc_index = spapr_drc_index(drc);\n\n        trace_spapr_drc_set_isolation_state_finalizing(drc_index);\n\n        spapr_drc_detach(drc);\n\n    }\n\n\n\n    return RTAS_OUT_SUCCESS;\n\n}\n", "idx": 15818, "substitutes": {"drc": ["pirc", "pduc", "dpc", "prc", "drec", "dRC", "lRC", "Drc", "pdrc", "Dbc", "trc", "sdrc", "lrc", "Duc", "pdroc", "lirc", "ldsrc", "ddroc", "adfc", "dirc", "dsroc", "dcc", "Drec", "ldpc", " dconfig", " droc", "ddirc", "dconfig", "sdbc", "sdirc", " dbc", "droc", "adirc", "tsrc", "sduc", "DRC", "duc", "dfc", " dirc", "dssrc", " drec", " dsrc", "adsrc", "ddconfig", "pfc", " dRC", "psrc", "fcc", "sdRC", "dbc", "Dconfig", "adrc", "dspc", "pdsrc", "fRC", "dsuc", " dfc", "fbc", "Dirc", "Dsrc", " duc", "tcc", "fsrc", "sdcc", "Droc", " dpc", "sdsrc", "dsirc", "ddrc", "dsrc", "ldrc", "tRC", "frc", "lrec", "ldirc"]}}
{"project": "qemu", "commit_id": "2e6a64cb8d7506ad27d3b6c8000bc8d773936932", "target": 0, "func": "static void input_linux_event_mouse(void *opaque)\n\n{\n\n    InputLinux *il = opaque;\n\n    struct input_event event;\n\n    int rc;\n\n\n\n    for (;;) {\n\n        rc = read(il->fd, &event, sizeof(event));\n\n        if (rc != sizeof(event)) {\n\n            if (rc < 0 && errno != EAGAIN) {\n\n                fprintf(stderr, \"%s: read: %s\\n\", __func__, strerror(errno));\n\n                qemu_set_fd_handler(il->fd, NULL, NULL, NULL);\n\n                close(il->fd);\n\n            }\n\n            break;\n\n        }\n\n\n\n        input_linux_handle_mouse(il, &event);\n\n    }\n\n}\n", "idx": 15823, "substitutes": {"opaque": [" opaques", "appacity", "ipaques", "cpacle", "cpity", "popacity", "ospity", "opity", "popaques", "appaques", "cpaque", "opac", "ospaques", "ospacle", "opaques", " opacle", "ipac", "cpaques", "ipacity", "opacity", "ipaque", "ospaque", "appaque", "opacle", "popac", "appac", " opity", "popaque"], "il": ["intel", "hl", "lin", "iol", "nl", "fl", "ilo", "oll", "util", "l", "iu", "syn", "dl", "lp", "ml", "kel", "mil", "ipl", "loc", "fp", "sil", "ill", "ul", "ll", "ir", "IL", "li", "pl", "ail", "isl", "nil", "cel", "acl", "fil", "rl", "ol", "iel", "sl", "inet", "ilk", "al", "lb", "sel", "wl", "ils", "el", "fc", "owl"], "event": ["date", "bug", "channel", "context", "input", "xml", "code", "vent", "object", "container", "stream", "large", "name", "row", "ex", "actual", "source", "test", "image", "cue", "x", "raw", "update", "comment", "error", "server", "element", "view", "ee", "e", "handler", "resource", "exc", "rx", "data", "pointer", "byte", "entry", "reader", " Event", "f", "feature", "address", "url", "inner", "Event", "type", "esc", "text", "pull", "ce", "load", "ack", "events", "exec", "ev", "content", "ec", "irc", "message"], "rc": ["RC", "rr", "ffff", "hl", "bc", "cv", "cc", "pc", "code", "bb", "roc", "row", "lc", "rn", "auc", "sth", "rg", "ref", " src", "abc", "loc", "ct", "error", "rh", "cr", "rec", "oc", "ok", "rb", "nc", "ck", "rx", "co", " RC", "result", "rl", "c", "inc", "dc", "ac", "cb", "sc", "nt", "rt", "vc", "xc", "src", "ec", "cur", "fc", "irc", "err"]}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "int float64_eq( float64 a, float64 b STATUS_PARAM )\n\n{\n\n\n\n    if (    ( ( extractFloat64Exp( a ) == 0x7FF ) && extractFloat64Frac( a ) )\n\n         || ( ( extractFloat64Exp( b ) == 0x7FF ) && extractFloat64Frac( b ) )\n\n       ) {\n\n        if ( float64_is_signaling_nan( a ) || float64_is_signaling_nan( b ) ) {\n\n            float_raise( float_flag_invalid STATUS_VAR);\n\n        }\n\n        return 0;\n\n    }\n\n    return ( a == b ) || ( (bits64) ( ( a | b )<<1 ) == 0 );\n\n\n\n}\n", "idx": 15833, "substitutes": {"a": ["area", "m", "as", "aj", "d", "ca", "ea", "art", "ai", "ia", "l", "i", "da", "g", "x", "ap", "ama", "aa", "o", "alpha", "an", "ad", "ba", "p", "e", "A", "la", "u", "aw", "pa", "b", "af", "n", "f", "au", "at", "aaa", "ma", "ab", "am", "c", "ac", "ao", "va", "aux", "ae", "sa", "ga", "ar", "y"], "STATUS_PARAM": ["STATUS_VAR", "STATUS_VARM", "STATUS_STATAR", "STATUS_VAME", "STATUS_PARM", "STATUS_PARAR", "STATUS_PARAME", "STATUS_PAM", "STATUS_STATAME", "STATUS_VAM", "STATUS_PAME", "STATUS_STATARM", "STATUS_STATAM", "STATUS_PARARM", "STATUS_PAR"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static always_inline void gen_cmp(TCGCond cond,\n\n                                  int ra, int rb, int rc,\n\n                                  int islit, uint8_t lit)\n\n{\n\n    int l1, l2;\n\n    TCGv tmp;\n\n\n\n    if (unlikely(rc == 31))\n\n    return;\n\n\n\n    l1 = gen_new_label();\n\n    l2 = gen_new_label();\n\n\n\n    if (ra != 31) {\n\n        tmp = tcg_temp_new(TCG_TYPE_I64);\n\n        tcg_gen_mov_i64(tmp, cpu_ir[ra]);\n\n    } else\n\n        tmp = tcg_const_i64(0);\n\n    if (islit)\n\n        tcg_gen_brcondi_i64(cond, tmp, lit, l1);\n\n    else\n\n        tcg_gen_brcond_i64(cond, tmp, cpu_ir[rb], l1);\n\n\n\n    tcg_gen_movi_i64(cpu_ir[rc], 0);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_movi_i64(cpu_ir[rc], 1);\n\n    gen_set_label(l2);\n\n}\n", "idx": 15840, "substitutes": {"cond": ["bug", "proc", "condition", "bc", "fd", "Cond", "config", "code", "pre", "def", "lc", "act", "ond", "ref", "unit", "cmp", "circ", "loc", "race", "lib", "cd", "ind", "la", "sec", "temp", "comp", "pl", "co", "count", "bf", "rol", "c", "diff", "dc", "ac", "lab", "cont", "resp", "xc", "lock", "reg", "pos", "prop", "fc", "red"], "ra": ["ror", "area", "RC", "ora", "rr", "ria", "ha", "ru", "qa", "rup", "RA", "Ra", "rd", "ca", "da", "a", "ta", "rad", "rar", "range", "sha", "star", "ras", "raf", "meta", "cr", "alpha", "ara", "la", "stage", "ran", "ir", "spec", "dra", "ro", "wa", "rt", "rac", "r", "ri", "sa", "ar", "asa", "ica", "rap", "in"], "rb": ["rr", "vr", "ru", "rid", "rd", "reb", "bb", "fb", "rad", "rar", "lc", "rn", "rg", "abc", "br", "raf", "rh", "cr", "lr", "pb", "b", "sb", "bf", "gb", "rm", "ab", "rl", "cb", "RB", "rob", "rt", "ril", "r", "ri", "db", "src", "nr", "lb", "ruby", "rf"], "rc": ["RC", "rr", "uc", "ru", "bc", "hl", "rd", "cv", "pc", "ctr", "roc", "rad", "lc", "row", "rar", "rn", "rg", "ref", "loc", "error", "ras", "rh", "cr", "rank", "alpha", "la", "rec", "lr", "rx", "arc", "rog", "spec", "inc", "c", "rl", "dc", "ac", "cb", "sc", "rac", "rt", "ril", "r", "xc", "src", "reg", "cur", "rf", "fc", "irc"], "islit": ["implIT", "islite", "cilitted", "ilite", "isolite", "implit", "isolIT", "cilitting", "cilIT", "ilitting", "islIT", "iplit", "islitting", "cilit", "flitted", "flit", "flIT", "implitting", "iplIT", "iplitting", "ilit", "isolitting", "implitted", "islitted", "iplite", "isolit", "flitting", "ilIT"], "lit": ["alt", "it", "nat", "lin", "len", "l", "val", "inf", "lic", "split", "lc", "ref", "lang", "unit", "ie", "loc", "late", "lib", "la", "lo", "sec", "fi", "lt", "pl", "base", "stat", "lite", "il", "lab", "iter", "sl", "src", "lb", "prop", "pos", "lv", "lat", "lim"], "l1": ["l3", "l60", "L1", "dl1", "il2", "el8", "el2", "dl3", " l8", "L60", " l60", "L8", "ml60", "ml1", "L100", "dl8", "el3", "L2", "ml3", "dl2", " l3", "ml2", "el1", "l8", "L4", "L3", "il1", "l100", "el4", "l4", " l4", "il3", " l100", "il100"], "l2": ["l3", "L1", "v0", " l02", "el2", " l0", "ltwo", "L02", "L0", "sltwo", "v2", "el3", "L2", "l0", " ltwo", "v3", "eltwo", " l3", "el1", "l02", "sl2", "L4", "v1", "L3", "el4", "l4", " l4", "el0", "sl0", "sl4", "el02"], "tmp": ["bt", "proc", "ff", "cm", "stuff", "bc", "cop", "config", "jp", "mp", "bb", "fb", "api", "sup", "lc", "emp", "beta", "lp", "nb", "ref", "txt", "vm", "kk", "cmp", "acc", "fp", "loc", "storage", "output", "buff", "np", "obj", "temp", "img", "pot", "pb", "buf", "data", "sb", "ctx", "tc", "etc", "comp", "ptr", "bf", "result", "phi", "cca", "EMP", "tab", "tf", "cb", "lab", "nt", "cp", "abb", "cache", "xc", "src", "cro", "prop", "cpp"]}}
{"project": "qemu", "commit_id": "e3c9d76acc984218264bbc6435b0c09f959ed9b8", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846, "substitutes": {"qdev": ["sqdev", "qude", "sqdevelopment", "iqdiv", "wdev", " qdd", "sqde", "sqdd", "iqdef", "qqDev", "iqdev", "qver", "wde", "qudebug", "wdd", "qdevelopment", "qudev", "Qver", "qdevice", "wdevice", "qde", "questdef", "Qdiv", "iqdom", "qdebug", "qudevice", "Qdef", "Qdom", "QDev", "qqdev", "qdd", "wdevelopment", "wdebug", "sqdebug", " qdevice", "qDev", "qqver", "qdom", "Qdev", "questdom", " qdevelopment", " qver", " qDev", "qdiv", "qdef", "questdev", "qqdiv", " qdiv", "questdiv", "sqdevice"], "s": ["ses", "self", "service", "fs", "rs", "g", "cs", "qs", "S", "settings", "sk", "os", "sr", "si", "sq", "v", "ps", "ss", "o", "ms", "p", "e", "sf", "sb", "b", "f", "spec", "state", "c", "ns", "is", "sn", "ssl", "sv", "sl", "services", "su", "ls", "ts", "iss", "ks"], "vs": ["vers", "vr", "bs", "fs", "vp", "rs", "Vs", "gi", "cs", "fps", "hs", "os", "sk", "vm", "si", "v", "ps", "ss", "ms", "VS", "alls", "sb", "gs", "ns", "vg", "lv", "stats", "ov", "sv", "va", "services", "ds", "vc", "ls", "ips", "vt", "ks"]}}
{"project": "qemu", "commit_id": "7d6e771f49c36f4388798ce25bde1dede40cda74", "target": 0, "func": "static int pci_vpb_init(SysBusDevice *dev)\n\n{\n\n    PCIVPBState *s = FROM_SYSBUS(PCIVPBState, dev);\n\n    PCIBus *bus;\n\n    int i;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        sysbus_init_irq(dev, &s->irq[i]);\n\n    }\n\n    bus = pci_register_bus(&dev->qdev, \"pci\",\n\n                           pci_vpb_set_irq, pci_vpb_map_irq, s->irq,\n\n                           get_system_memory(), get_system_io(),\n\n                           PCI_DEVFN(11, 0), 4);\n\n\n\n    /* ??? Register memory space.  */\n\n\n\n    memory_region_init_io(&s->mem_config, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-selfconfig\", 0x1000000);\n\n    memory_region_init_io(&s->mem_config2, &pci_vpb_config_ops, bus,\n\n                          \"pci-vpb-config\", 0x1000000);\n\n    if (s->realview) {\n\n        isa_mmio_setup(&s->isa, 0x0100000);\n\n    }\n\n\n\n    sysbus_init_mmio_cb2(dev, pci_vpb_map, pci_vpb_unmap);\n\n\n\n    pci_create_simple(bus, -1, \"versatile_pci_host\");\n\n    return 0;\n\n}\n", "idx": 15879, "substitutes": {"dev": ["device", "development", "ch", "self", "cam", "d", "t", "die", " device", "def", "rad", "serial", "ve", "di", "devices", "Dev", "mod", "comment", "app", "v", "conf", "gu", "conn", "der", "de", "w", "grad", "pub", "ad", "info", "ver", "data", "sd", "driver", "dom", "diff", "dc", "DEV", "md", "pro", "ds", "dd", "sh", "ev", "debug", "dm", "hw", "phy"], "s": ["args", "sys", "m", "ses", "self", "d", "service", "sg", "sync", "fs", "l", "t", "a", "g", "cs", "S", "sp", "os", "js", "si", "sq", "session", "server", "v", "ps", "ss", "conf", "o", "w", "u", "p", "e", "http", "b", "sf", "sb", "n", "f", "gs", "spec", "state", "c", "ns", "is", "ssl", "side", "sv", "sl", "ops", "r", "services", "ds", "su", "ls", "ts", "us", "aws"], "bus": ["plug", "bug", "bridge", "device", "port", "board", "bis", "bc", "service", "sync", "config", "l", "io", "ride", "ass", "front", "os", "serial", "use", "x", "o", "lib", "pass", "p", "BUS", "boot", "lo", "plugin", "http", "data", "b", "usb", "base", "driver", "f", "c", "proxy", "block", "feed", "cat", "is", "cb", "Bus", "loop", "book", "db", "cache", "class", "us"], "i": ["hi", "qi", "ui", "m", "I", "d", "ni", "ai", "xi", "in", "ini", "level", "gi", "iu", "oi", "l", "mu", "ci", "x", "di", "si", "ie", "ii", "key", "v", "uri", "o", "yi", "u", "z", "p", "e", "info", "fi", "mi", "li", "k", "b", "base", "multi", "j", "count", "phi", "min", "n", "ti", "ip", "c", "eni", "pi", "chi", "r", "bi", "ri", "zi", "y", "abi", "index"]}}
{"project": "qemu", "commit_id": "feced894fb6c474eb56daeb2b2d1f99bae87677f", "target": 0, "func": "static void rng_random_set_filename(Object *obj, const char *filename,\n\n                                 Error **errp)\n\n{\n\n    RngBackend *b = RNG_BACKEND(obj);\n\n    RndRandom *s = RNG_RANDOM(obj);\n\n\n\n    if (b->opened) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    if (s->filename) {\n\n        g_free(s->filename);\n\n    }\n\n\n\n    s->filename = g_strdup(filename);\n\n}\n", "idx": 15883, "substitutes": {"obj": ["self", "bis", "po", "ob", "enc", "so", "tmp", "sync", "object", "obb", "io", "g", "Object", "orb", "os", "nb", "fn", "bj", "br", "buff", "Obj", "o", "office", "p", "e", "img", "rb", "bm", "data", "sb", "j", "n", "f", "bh", "bo", "cb", "objects", "src", "emb", "archive", "lock", "ctx", "node"], "filename": ["dll", "word", "ename", "path", "utf", "location", "fd", "title", "enc", "l", "fb", "binary", "required", "name", "kn", "source", "directory", "final", "description", "original", "txt", "sequence", "method", "gender", "position", "fp", "fn", "maximum", "files", "uri", "phrase", "package", "Filename", "brush", "sound", "password", "size", "download", "loader", "kl", "folder", "data", "nil", "sheet", "length", "provided", "f", "property", "json", "subject", "fil", "token", "url", "license", "file", "lace", "initial", "prefix", "username", "message"], "errp": ["nerP", "lerp", "lrpr", "cerp", "errpr", "erlp", "cerlp", "erpr", "errP", "errps", "cerps", "lrp", "nerps", "lerps", "erp", "cerP", "nerp", "lerP", "errlp", "lerlp", "lrps", "erps", "lrP", "nerpr", "erP"], "b": ["bt", "xb", "m", "bc", "d", "ob", "bs", "l", "bb", "fb", "a", "bd", "h", "nb", "mb", "o", "ba", "p", "e", "be", "rb", "bm", "boot", "ib", "sb", "wb", "j", "usb", "bf", "f", "n", "gb", "bh", "ab", "c", "bg", "r", "db", "B", "y"], "s": ["sys", "ses", "self", "d", "sync", "sg", "service", "bs", "l", "ins", "fs", "g", "cs", "qs", "S", "sp", "hs", "new", "os", "its", "si", "js", "es", "v", "ss", "o", "w", "params", "p", "e", "se", "sb", "sf", "n", "f", "gs", "c", "ns", "sn", "ssl", "sv", "sl", "r", "services", "ds", "sa", "su", "ls", "ts", "y", "aws"]}}
{"project": "qemu", "commit_id": "fd56e0612b6454a282fa6a953fdb09281a98c589", "target": 0, "func": "static void rtas_ibm_get_config_addr_info2(PowerPCCPU *cpu,\n\n                                           sPAPRMachineState *spapr,\n\n                                           uint32_t token, uint32_t nargs,\n\n                                           target_ulong args, uint32_t nret,\n\n                                           target_ulong rets)\n\n{\n\n    sPAPRPHBState *sphb;\n\n    PCIDevice *pdev;\n\n    uint32_t addr, option;\n\n    uint64_t buid;\n\n\n\n    if ((nargs != 4) || (nret != 2)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    buid = rtas_ldq(args, 1);\n\n    sphb = spapr_pci_find_phb(spapr, buid);\n\n    if (!sphb) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    if (!spapr_phb_eeh_available(sphb)) {\n\n        goto param_error_exit;\n\n    }\n\n\n\n    /*\n\n     * We always have PE address of form \"00BB0001\". \"BB\"\n\n     * represents the bus number of PE's primary bus.\n\n     */\n\n    option = rtas_ld(args, 3);\n\n    switch (option) {\n\n    case RTAS_GET_PE_ADDR:\n\n        addr = rtas_ld(args, 0);\n\n        pdev = spapr_pci_find_dev(spapr, buid, addr);\n\n        if (!pdev) {\n\n            goto param_error_exit;\n\n        }\n\n\n\n        rtas_st(rets, 1, (pci_bus_num(pdev->bus) << 16) + 1);\n\n        break;\n\n    case RTAS_GET_PE_MODE:\n\n        rtas_st(rets, 1, RTAS_PE_MODE_SHARED);\n\n        break;\n\n    default:\n\n        goto param_error_exit;\n\n    }\n\n\n\n    rtas_st(rets, 0, RTAS_OUT_SUCCESS);\n\n    return;\n\n\n\nparam_error_exit:\n\n    rtas_st(rets, 0, RTAS_OUT_PARAM_ERROR);\n\n}\n", "idx": 15885, "substitutes": {"cpu": ["proc", "config", "pool", "vm", "cmp", "linux", "pid", "computer", "pu", "conn", "processor", "loader", "GPU", "mem", " CPU", "boot", "cli", "CPU", "vidia", "proxy", "gpu", "clock", "process", "cp", "ips", "nic", "node", "gp"], "spapr": ["spapepr", "spippr", "spAPr", "spappd", "Spappr", "scapr", "spapb", "scaprc", "scapstr", "spaperc", "scaptr", "spipppr", "spapsb", "spaped", "spapm", "spaptr", "spaper", "spapd", "spapers", "spipprc", "spaxb", "spAPtr", "scapb", "Spapb", "spapspr", "spappr", "scapsb", "spaxtr", "scapsr", "scaprs", "scapsrc", "Spappb", "scappr", "spapem", "spappm", "Spapd", "spapsrs", "spapsrc", "spacm", "spaprs", "spipprs", "spapstr", "spapsr", "Spapr", "Spapm", "spaxr", "Spappd", "spappb", "spacd", "spacr", "spapeb", "spaprc", "scapspr", "spAPb", "scapsrs", "Spappm", "spacb"], "token": ["nat", "secret", "proc", "call", "reply", "response", "random", "util", "prot", "serial", "event", "auth", "init", "total", "conn", "win", "password", "ok", "socket", "match", "timeout", "target", "mac", "seq", "flag", "opt", "callback"], "nargs": [" nresult", " nflags", "ncparams", "ncargs", "fargs", "fArgs", "nflags", "ncArgs", "ncresult", "bresult", "nresult", "pret", "bargs", "numresult", "pargs", "fparams", "nparams", "bflags", "numparams", "numargs", "presult", "bret", "numArgs", "nArgs", "pflags", "fresult"], "args": ["func", "bug", "ret", "call", "parts", "reply", "amd", "config", "arms", "fields", "extra", "msg", "grades", "cs", "ig", "details", "py", "use", "bytes", "module", "opens", "arg", "init", "limits", "linux", "ras", "frame", "conn", "flags", "ids", "active", "params", "parse", "alls", "sec", "boot", "options", "vals", "match", "data", "ait", "features", "Args", "lines", "result", "gs", "bits", "spec", "arr", "is", "argument", "atts", "stats", "cmd", "states", "res", "flag", "len", "asm"], "nret": ["ntret", "numlen", "Nret", " nexit", "nRet", "Nlen", "numret", "nreturn", "ntrets", "nexit", "tRet", "lret", "nrets", "lreturn", "treturn", "trets", "Nexit", "ntreturn", "ntRet", "lrets", "tret", " nRet", "NRet", "numexit", " nlen", "lRet", "nlen", "numRet"], "rets": ["types", "alt", "vers", "secret", "ret", "proc", "uts", "ails", "reply", "dies", "fs", "fields", "rs", "utils", "def", "tracks", "verts", "details", "grades", "bytes", "expected", "its", "opens", "uns", "rows", "checks", "ras", "nuts", "flags", "strings", "archives", "reads", "mem", "groups", "info", "features", "nas", "lines", "tests", "store", "bits", "acks", "ns", "ats", "roots", "uds", "nt", "results", "fits", "outs", "als", "aux", "errors", "urs", " secrets", "ints", "seq", "runs", "res", "ts", "reg", "ils", "fts", "ls", "RET", "vals"], "sphb": [" sphd", "ssPhab", "sPhp", "shpr", "Saphl", " sphl", "sPhab", " spha", "shpl", "shpa", " sghp", "saphbs", "sPhl", "sophb", "saphl", "sPhb", "Sphbs", " sphr", "sphl", "sphbs", "sephd", "ssPhb", "sghb", "ssphb", "sPhbs", "sphobj", "sephp", " sPhl", "sophobj", " sPhobj", " sghr", "shpb", "Saphb", "sPhobj", "ssPhl", "shpobj", "sophl", "sghr", "sphp", " sphp", "smphr", " sPha", "sPha", "sPhr", "ssphab", "smphbs", "Sphr", "sephb", "sephr", "Saphbs", "sghd", "sphab", "ssphr", "sphd", "sPhd", "saphb", "ssPhr", " sphobj", "saphr", "sephab", "sephl", "shpab", "smphb", "Saphr", "spha", "sopha", " sPhb", "Sphb", "sphr", "ssphl", " sghb", "smphl", " sghd", "sghp", "Sphl"], "pdev": ["pconn", "prdevice", "pprov", "mpriv", "bdev", "fdiff", "rdevice", "mdevice", "spdevice", " pdef", " pconn", "Pdev", "bdef", " pdevice", "fdev", "mdiff", "papp", "cdevice", "fpdev", "Pdef", " pdiff", "pdiff", "cdev", "fppriv", "fdevice", "sppriv", "bapp", "spdiff", "fpdiff", "rpriv", "fpdevice", "rdiff", "pdevice", "prconn", "prdev", " ppriv", "Ppriv", "rdev", "fpriv", "ppriv", "prprov", "spdev", " pprov", "cconn", "mdev", "bpriv", " papp", "pdef", "cprov", "Papp"], "addr": ["alt", "edge", "ret", "rr", "amp", "adder", "arm", "amd", "config", "id", "name", "arg", "ace", "loc", "grad", "ad", "adr", "layer", "data", "mode", "ann", "address", "ip", "route", "arr", "advert", "ac", "afi", "type", "attr", "md", "cmd", "rt", "ack", "host", "dd", "mac", "r", "src", "seq", "dr", "pos", "prefix", "alias", "pad", "hop", "opt"], "option": ["device", "action", "OP", "config", "id", "object", "style", "Option", "or", "name", "connection", "range", "weight", "image", "section", "operation", "project", "other", "arg", "offer", "method", "position", "key", "error", "package", "value", "o", "adr", "version", "options", "resource", "cho", "direction", "op", "mode", "result", "pair", "ip", "number", "route", "timeout", "block", "pin", "type", "function", "ption", "tag", "lock", "prop", "opt"], "buid": ["appID", "auids", "buids", "guids", " buids", "bgkid", "auip", "appId", "suids", "bukid", "guid", " buip", "buID", " bukid", "bgID", "baip", "suID", "buId", "gukid", "guID", "baids", "bufids", "suId", "appid", "bakid", " buId", "bufId", "bgid", "bufid", "baid", "bgids", "appids", "buip", "bufID", " buID", "aukid", "guId", "suid", "auid"]}}
{"project": "qemu", "commit_id": "a3fa1d78cbae2259491b17689812edcb643a3b30", "target": 0, "func": "static void migrate_fd_completed(MigrationState *s)\n\n{\n\n    DPRINTF(\"setting completed state\\n\");\n\n    migrate_fd_cleanup(s);\n\n    if (s->state == MIG_STATE_ACTIVE) {\n\n        s->state = MIG_STATE_COMPLETED;\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    }\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 15890, "substitutes": {"s": ["secondary", "south", "args", "sys", "ses", "m", "d", "t", "sg", "fs", "sync", "sym", "rs", "a", "cs", "qs", "S", "hs", "submit", "os", "settings", "status", "sets", "es", "js", "si", "sq", "ps", "ss", "o", "ms", "an", "u", "p", "e", "plugins", "sb", "f", "gs", "less", "state", "spec", "ns", "c", "xs", "is", "stats", "ssl", "sv", "states", "services", "ds", "ls", "ts", "aws"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_adds_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tint size = memsize_z(dc);\n\n\tDIS(fprintf (logfile, \"adds.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(size),\n\n\t\t    dc->op1, dc->op2));\n\n\n\n\tcris_cc_mask(dc, CC_MASK_NZVC);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\t/* Size can only be qi or hi.  */\n\n\tt_gen_sext(t0, cpu_R[dc->op1], size);\n\n\tcris_alu(dc, CC_OP_ADD,\n\n\t\t    cpu_R[dc->op2], cpu_R[dc->op2], t0, 4);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 15897, "substitutes": {"dc": ["RC", "draw", "context", "mc", "cm", "bc", "uc", "d", "fd", "ea", "input", "rc", "cc", "pc", "config", "enter", "cdn", "enc", "da", "DC", "gc", "lc", "std", "di", "ct", "loc", "conn", "cr", "cd", "doc", "desc", "nc", "tc", "dat", "spec", "cca", "c", "design", "df", "dt", "jc", "ac", "cb", "sc", "cmd", "cf", "dp", "disc", " DC", "ds", "gui", "vc", "db", "ga", "ec", "exec", "dr", "mac", "fc", "dm", "ctx"], "t0": ["f000", "dt20", "t2", "Tii", "c1", "T2", " t20", "pt0", " t5", "tt000", "dt5", "c6", "t5", "T100", "at0", "t4", "t1", "et100", "t100", " t6", "f0", "t20", "at2", "t00", "c8", "tt8", "T0", " t2", "dt00", "T1", " tii", "tt4", "dt0", "tt1", "tt6", "t8", "et1", " t000", "atii", "pt20", " t1", "pt5", " t8", "f1", " t00", "et0", " t4", "f4", "tt0", "it0", "pt00", "c0", "tii", "t000", "t6", "it100", "it1"]}}
{"project": "FFmpeg", "commit_id": "02055b6d40d0cff867a9e41cad48edcaf6e10f2f", "target": 0, "func": "static void create_map(vorbis_context *vc, unsigned floor_number)\n\n{\n\n    vorbis_floor *floors = vc->floors;\n\n    vorbis_floor0 *vf;\n\n    int idx;\n\n    int blockflag, n;\n\n    int32_t *map;\n\n\n\n    for (blockflag = 0; blockflag < 2; ++blockflag) {\n\n        n = vc->blocksize[blockflag] / 2;\n\n        floors[floor_number].data.t0.map[blockflag] =\n\n            av_malloc((n + 1) * sizeof(int32_t)); // n + sentinel\n\n\n\n        map =  floors[floor_number].data.t0.map[blockflag];\n\n        vf  = &floors[floor_number].data.t0;\n\n\n\n        for (idx = 0; idx < n; ++idx) {\n\n            map[idx] = floor(BARK((vf->rate * idx) / (2.0f * n)) *\n\n                             (vf->bark_map_size / BARK(vf->rate / 2.0f)));\n\n            if (vf->bark_map_size-1 < map[idx])\n\n                map[idx] = vf->bark_map_size - 1;\n\n        }\n\n        map[n] = -1;\n\n        vf->map_size[blockflag] = n;\n\n    }\n\n\n\n    for (idx = 0; idx <= n; ++idx) {\n\n        av_dlog(NULL, \"floor0 map: map at pos %d is %d\\n\", idx, map[idx]);\n\n    }\n\n}\n", "idx": 15906, "substitutes": {"vc": ["vr", "bc", "cv", "vv", "rc", "cc", "vp", "bb", "cdn", "VC", "lc", "cs", "ci", "ctrl", "wx", "cit", "circ", "fp", "ct", "v", "ant", "ll", "oc", "nc", "vs", "c", "CV", "cu", "voc", "dc", "lv", "cb", "sv", "cf", "nv", "ic", "uv", "rt", "vd", "vt", "util", "fc", "hw", "ctx", "fw"], "floor_number": ["floor_money", "floorishdocument", "floorityzero", "flooramenumber", " floor_source", "floor_factor", "floorxfactor", " floor_no", "futureishnumber", "flooramespan", "flooringnumber", "floor2numbered", " floor_span", "floorallnumber", "future_nr", "floorallzero", "futureishnr", "floor_source", " floor_factor", "floorfullno", "future_document", "flooringsource", "futureishdocument", "flooringnumbered", "floor_span", "floor2number", "floorxnumbered", " floor_money", "floorxsource", " floor_token", "floor_nr", "flooramemoney", "floor_numbered", "floorishnumber", "floorishzero", "flooramenumbered", "floorxnumber", "future_zero", "flooritynr", "floorallnr", "flooringfactor", "floor2span", "floor2money", "flooralldocument", "floorfullnumber", "flooritydocument", " floor_numbered", "floor_document", "floorfullnumbered", "futureishzero", "floor_token", "future_number", "floorishnr", "floorfulltoken", "flooritynumber", "floor_no", "floor_zero"], "floors": ["boors", "feors", "flores", "flor", "floore", " floore", "floops", "factons", "colorers", "Floor", "boor", "flore", "colors", "flos", "floores", "feor", "floorers", "fevers", "Floons", "boos", " floorers", "boons", " floores", "flvers", "Floores", "floos", " floops", "colores", "factor", "feores", "florers", "boores", "floons", "factors", "flops", "Floops", "colvers", "boore", " floos", "color", "Floors", "flovers", "flors", "factores"], "vf": ["ff", " vb", "tvfen", " vph", " vfen", "antfe", "antfs", "svrf", "vccf", " vv", "evfe", "avsf", "avph", "evcf", "svf", "vpb", "antf", "ffc", " vfc", "avn", "vfs", "fv", "vfen", "svfe", "avc", "Vfe", "avf", "tvcf", "vn", "tvf", "tvfs", " vfe", "evfc", "vcn", " vn", " vbf", "vrf", "svsf", "avfc", "vfe", "antcf", "avcf", "tvfc", " vsf", "vcph", "vcf", "svb", "fcf", "avv", "Vfs", "tvrf", "vpf", "vpfc", "vph", "svcf", "evfen", "evfs", " vcf", "vv", "evrf", "vb", "Vbf", "svbf", "svfc", "vbf", "vfc", " vrf", "vprf", "svfs", "vsf", " vfs", "tvfe", "Vf", "evf", "svc"], "idx": ["pidx", "idcl", "itxes", "indxs", "itxc", " idco", "idco", "Idy", " idxb", "idc", "ridy", " idX", "Idxc", "ideax", "itxs", "itxx", "indcl", "idxes", "idz", "itx", " idxes", "Idp", "indxx", "ridx", "Idnex", "idxa", "ridX", " idxc", "idn", "idez", "ideX", "pidX", "idey", "pidn", "indco", "vidxs", "indxa", "idax", "idxs", "IdX", "indp", "itz", " idn", " idcl", "Idc", "itX", "itxb", "idex", "idnex", "Idx", "vidx", "idp", "indc", " idp", "ipx", "Idxa", "Idxes", "idxb", " idy", "ipc", "vidco", "pidy", "pidxs", "indnex", "Idxx", "idxx", "idxc", "ridxs", "Idz", " idax", "indx", "ridz", "idy", "vidy", "itn", "indX", "indy", " idnex", " idz", "pidcl", "ipy", "itxa", "idX", "ridxb", "indax", " idxs", "ipxx", "indz", "ity"], "blockflag": ["rowflag", "blockcode", "blockguard", " blockletter", "rowcount", "blockstyle", " blockcode", "bitstyle", "blocklag", "blockflags", "typestyle", "keyflags", "rowflags", " blocklag", "Blockflag", "rowletter", "blockaddr", "blockbit", "blcode", "walladdr", "errorbit", "objectforce", "objectflag", "keyaddr", " blockf", "blockforce", "baninfo", "broadflag", "typecount", "blflag", "Blockfield", "bitflag", "blocktag", " blockcount", "blockcount", "packcode", " blockforce", "ackletter", "errorflag", "errorguard", "blockf", "wallcode", "blockfeat", "banflag", "errorcount", "packtag", "objectf", "banfeat", "blstyle", "packstyle", "typefield", "bitfeat", " blocktag", " blockbit", "broadf", "broadforce", " blockguard", "bltag", " blockfield", "bitinfo", "Blockcount", "broadstyle", "ackflag", "objectstyle", " blockfeat", " blockstyle", "wallflags", "rowbit", "blockfield", "banstyle", "ackbit", "typeflag", "wallflag", "Blockstyle", "ackflags", "rowguard", "blockletter", "keycode", " blockaddr", " blockflags", "packflag", "rowlag", "keyflag", "blockinfo", "Blocklag", " blockinfo", "Blockflags"], "n": ["m", "en", "nl", "d", "t", "ni", "l", "i", "un", "N", "nn", "name", "g", "na", "mn", "nb", "x", "cn", "fn", "v", "conn", "o", "w", "z", "u", "size", "p", "nan", "e", "s", "nc", "k", "b", "j", "f", "nu", "c", "ns", "number", "ne", "sn", "nt", "network", "r", "nr", "dn", "no", "num", "len", "y", "net", "node"], "map": ["bridge", "port", "top", "shape", "pre", "msg", "use", "module", "model", "Map", "table", "mx", "mem", "dict", "share", "list", "MAP", "change", "lock", "copy", "comb", "m", "array", "key", "group", "pack", "data", "result", "cover", "maps", "arr", "cap", "cache", "space", "ge", "config", "mp", "apper", "buffer", "scope", "master", "app", "view", "co", "mate", "mask", "address", "block", "down", "type", "pos", "node", "replace", "record", "code", "up", "name", "ap", "meta", "set", "open", "wave", "p", "move", "match", "rate", "where", "parent", "place", "file", "scale", "pad", "max"]}}
{"project": "qemu", "commit_id": "b6866fee58bc25b01485dcfcf8be44a915c5f573", "target": 0, "func": "static void virtio_scsi_parse_req(VirtIOSCSI *s, VirtQueue *vq,\n\n                                  VirtIOSCSIReq *req)\n\n{\n\n    assert(req->elem.out_num && req->elem.in_num);\n\n    req->vq = vq;\n\n    req->dev = s;\n\n    req->sreq = NULL;\n\n    req->req.buf = req->elem.out_sg[0].iov_base;\n\n    req->resp.buf = req->elem.in_sg[0].iov_base;\n\n\n\n    if (req->elem.out_num > 1) {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.out_sg[1],\n\n                               &req->elem.out_addr[1],\n\n                               req->elem.out_num - 1);\n\n    } else {\n\n        qemu_sgl_init_external(&req->qsgl, &req->elem.in_sg[1],\n\n                               &req->elem.in_addr[1],\n\n                               req->elem.in_num - 1);\n\n    }\n\n}\n", "idx": 15911, "substitutes": {"s": ["sys", "ses", "service", "d", "t", "sg", "i", "a", "g", "cs", "qs", "S", "sp", "os", "si", "es", "js", "session", "server", "v", "ps", "ss", "o", "w", "u", "dev", "p", "e", "sb", "f", "gs", "spec", "c", "ns", "ssl", "q", "services", "ds", "r", "y"], "vq": ["gq", "uQ", "vqq", "vqueue", "gqq", " viq", "jque", "jqs", "zqueue", "up", "vp", "giq", "vQ", "pp", "pQ", " vqq", "gQ", " vQ", "viq", "uque", "fiq", "cque", "cQ", "zque", "vque", "uq", "fq", "vqs", "zq", "pq", "pqs", "jq", "fQ", "cp", "zqs", "cq", "jqueue", "pqueue", "fqq", "pque"], "req": ["sem", "proc", "cook", "art", "def", "msg", "str", "rec", "dev", "ver", "tar", "requ", "spec", "serv", "ry", "cb", "pro", "com", "get", "pri", "ae", "ec", "sub", "call", "ru", "dq", "ctr", "cgi", "fr", "client", "grad", "resource", "require", "data", "ext", "url", "ce", "urg", "r", "exec", "comm", "pr", "ev", "res", "rf", "core", "rr", "fer", "rd", "gr", "tr", "config", "task", "test", "ref", "app", "rh", "conn", "war", "ir", "desc", "rx", "http", "comp", "qt", "f", "query", "inc", "diff", "ro", "wa", "cf", "load", "hop", "cur", "err", "qa", "input", "hr", "response", "jp", "required", "respond", "sq", "conf", "cr", "request", "quest", "form", "crit", "per", "pull", "q", "cmd", "org", "resp", "prep", "qq", "seq"]}}
{"project": "qemu", "commit_id": "5eb6d9e3ef1fac096ab5b3f5c14e1f4079dd7367", "target": 0, "func": "static void usb_uas_task(UASDevice *uas, uas_ui *ui)\n\n{\n\n    uint16_t tag = be16_to_cpu(ui->hdr.tag);\n\n    uint64_t lun64 = be64_to_cpu(ui->task.lun);\n\n    SCSIDevice *dev = usb_uas_get_dev(uas, lun64);\n\n    int lun = usb_uas_get_lun(lun64);\n\n    UASRequest *req;\n\n    uint16_t task_tag;\n\n\n\n    req = usb_uas_find_request(uas, be16_to_cpu(ui->hdr.tag));\n\n    if (req) {\n\n        goto overlapped_tag;\n\n    }\n\n\n\n    switch (ui->task.function) {\n\n    case UAS_TMF_ABORT_TASK:\n\n        task_tag = be16_to_cpu(ui->task.task_tag);\n\n        trace_usb_uas_tmf_abort_task(uas->dev.addr, tag, task_tag);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        req = usb_uas_find_request(uas, task_tag);\n\n        if (req && req->dev == dev) {\n\n            scsi_req_cancel(req->req);\n\n        }\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    case UAS_TMF_LOGICAL_UNIT_RESET:\n\n        trace_usb_uas_tmf_logical_unit_reset(uas->dev.addr, tag, lun);\n\n        if (dev == NULL) {\n\n            goto bad_target;\n\n        }\n\n        if (dev->lun != lun) {\n\n            goto incorrect_lun;\n\n        }\n\n        qdev_reset_all(&dev->qdev);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_COMPLETE, 0);\n\n        break;\n\n\n\n    default:\n\n        trace_usb_uas_tmf_unsupported(uas->dev.addr, tag, ui->task.function);\n\n        usb_uas_queue_response(uas, tag, UAS_RC_TMF_NOT_SUPPORTED, 0);\n\n        break;\n\n    }\n\n    return;\n\n\n\noverlapped_tag:\n\n    usb_uas_queue_response(uas, req->tag, UAS_RC_OVERLAPPED_TAG, 0);\n\n    return;\n\n\n\nbad_target:\n\n    /* FIXME: correct?  [see long comment in usb_uas_command()] */\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INVALID_INFO_UNIT, 0);\n\n    return;\n\n\n\nincorrect_lun:\n\n    usb_uas_queue_response(uas, tag, UAS_RC_INCORRECT_LUN, 0);\n\n}\n", "idx": 15924, "substitutes": {"uas": ["uiase", "suases", " uasha", "huasp", "tuaks", "cuasha", "uaks", "puase", "urach", "uach", "euasha", "uased", "tuas", "suas", "cuas", "puams", "uuased", "huases", "uuas", "uasha", "uams", "uuaks", "huans", "nuams", "euase", "luast", "luaser", "ruacs", "luases", "uuach", "uaser", "uiasp", "luams", "urast", "huas", "euas", "cuases", "puasp", "uast", "uases", "uuase", "uuases", "ruaks", "uasp", "huams", "luas", "cuacs", "luach", "urans", "ruase", "huaser", " uasse", "huacs", "uras", "ruams", "cuase", "huasa", "uase", "nuasp", "cuams", "uiams", "luasp", "puas", "cuasa", "suasse", "uasse", "uuasse", "ruain", "suased", " uase", "cuans", "ruasp", "uain", "nuase", "ruases", " uams", "urase", "tuain", "euams", "uuacs", "urases", "huast", "huase", "ruas", "uraser", " uased", "luase", " uases", "uans", "uasa", "uacs", "tuacs", "nuas", "uuain", "uias", "urasa"], "ui": ["uni", "isu", "UI", "una", "ai", "ilo", "iu", "i", "uda", "eu", "io", "fu", "api", "ci", "ki", "uu", "umi", "si", "ii", "hu", "gnu", "uri", "vi", "gru", "pu", "ul", "u", "menu", "ku", "cli", "li", "usb", "nu", "ti", "usa", "uci", "bu", "cu", "lu", "sci", "tu", "wei", "bi", "gui", "um", "su", "ei", "ou", "us", "util", "abi", "mu"], "dev": ["device", "dist", "priv", "def", "rad", "module", "vol", "br", "pub", "mem", "temp", "ver", "driver", "flow", "spec", "serv", "dem", "end", "md", "deb", "pro", "dd", "od", "tag", "off", "debug", "dom", "plug", "self", "d", "id", "serial", "di", "gh", "comment", "error", "client", "grad", "own", "pack", "data", "develop", "link", "exec", "cache", "ev", "reg", "ch", "nov", "test", "game", "valid", "app", "adv", "conn", "info", "dep", "diff", "block", "DEV", "nt", "push", "hw", "err", "bug", "root", "code", "name", "sk", "user", "mod", "Dev", "conf", "prom", "gu", "var", "de", "p", "good", "ov", "cmd", "start"], "req": ["sem", "rib", "proc", "cook", "rs", "ah", "def", "str", "cmp", "mr", "rec", "ind", "ver", "tar", "requ", "rw", "spec", "ry", "cb", "pro", "get", "pri", "tag", "order", "raq", "plug", "call", "ru", "dq", "id", "ctr", "fr", "check", "grad", "loader", "require", "ext", "min", "iq", "r", "exec", "cache", "pr", "ev", "res", "reg", "rf", "zip", "rr", "fer", "gr", "tr", "config", "task", "test", "ref", "app", "rh", "conn", "war", "grab", "sec", "desc", "rx", "http", "comp", "qt", "dep", "par", "ro", "load", "rt", "hop", "cur", "push", "err", "bug", "pkg", "hr", "worker", "jp", "required", "sq", "patch", "quest", "request", "cr", "crit", "per", "pull", "q", "cmd", "org", "resp", "qq", "seq", "need"], "task_tag": ["taskingbug", "task_cat", "taskencat", "taskentag", " task_token", "ask_bit", "task_bit", "taskingtag", "task_TAG", "task_id", "task_bug", " task_num", "task_reg", "task2TAG", " task_id", "trackentag", "task_ag", "tasklogid", "task2token", " task_cat", "taskxtoken", "task_token", "tasklogtag", " task_TAG", "ask_token", "trackenreg", " task_task", "task2length", "ask_bug", "track_reg", "taskentarget", "taskenreg", "tasklognum", "taskxtarget", "task_length", "ask_tag", "track_tag", "track_target", "trackenag", "trackentarget", "task2tag", "task_task", "taskxtag", "taskingtoken", "track_ag", " task_length", "task_num", "task_target", "tasklogtask", " task_target", "taskentoken", "taskenag", "taskingbit", "taskxcat"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int ide_qdev_init(DeviceState *qdev, DeviceInfo *base)\n\n{\n\n    IDEDevice *dev = DO_UPCAST(IDEDevice, qdev, qdev);\n\n    IDEDeviceInfo *info = DO_UPCAST(IDEDeviceInfo, qdev, base);\n\n    IDEBus *bus = DO_UPCAST(IDEBus, qbus, qdev->parent_bus);\n\n\n\n    if (!dev->conf.dinfo) {\n\n        fprintf(stderr, \"%s: no drive specified\\n\", qdev->info->name);\n\n        goto err;\n\n    }\n\n    if (dev->unit == -1) {\n\n        dev->unit = bus->master ? 1 : 0;\n\n    }\n\n    switch (dev->unit) {\n\n    case 0:\n\n        if (bus->master) {\n\n            fprintf(stderr, \"ide: tried to assign master twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->master = dev;\n\n        break;\n\n    case 1:\n\n        if (bus->slave) {\n\n            fprintf(stderr, \"ide: tried to assign slave twice\\n\");\n\n            goto err;\n\n        }\n\n        bus->slave = dev;\n\n        break;\n\n    default:\n\n        goto err;\n\n    }\n\n    return info->init(dev);\n\n\n\nerr:\n\n    return -1;\n\n}\n", "idx": 15929, "substitutes": {"qdev": ["kdev", "sqdev", "qude", "qdist", "dqdata", " qdie", " qde", "dqvar", "dqde", "wdev", "qdie", "quvar", "reqvar", " qdiff", "dqdiv", "qpack", "dqdevice", " qbus", "pdiv", "qapp", "qudev", "qudist", "qdevice", "wdevice", "reqdist", "qadevelop", " qdevelop", "qde", "qadevice", " qdata", "pdev", "qdem", "qdiff", "Qvar", "reqdiff", "qvar", "qudevice", "Qdef", " qdef", "reqdie", "wbus", "reqdef", "kdevice", "pdata", " qpack", "Qdiff", " qdevice", "reqdev", "reqdem", "pdevice", " qapp", "qdata", "kapp", "sqapp", "qudie", " qvar", "Qdev", "dqdev", "qadev", "kpack", " qdist", "qbus", " qdem", "qdevelop", "qdiv", "qdef", "wdevelop", "qudem", "qabus", " qdiv", "sqdevice", "sqpack"], "base": ["area", "normal", "root", "build", "config", "id", "fs", "i", "extra", "home", "io", "api", "name", "builder", "ref", "buffer", "init", "Base", "error", "conf", "lib", "bot", "cli", "http", "data", "b", "fab", "f", "block", "bas", "iso", "db", "cache", "prefix", "kit", "stable"], "dev": ["plug", "bug", "device", "development", "ch", "v", "d", "dist", "config", "id", "priv", "die", "def", "rad", "api", "test", "sk", "ve", "serial", "project", "user", "di", "mod", "init", "Dev", "comment", "model", "error", "app", "valid", "conf", "gu", "adv", "conn", "var", "de", "client", "cd", "pub", "ad", "lib", "w", "slave", "temp", "ver", "pack", "data", "driver", "result", "diff", "block", "dem", "dc", "end", "DEV", "md", "dim", "fail", "dd", "vc", "ev", "sh", "debug", "wd", "go"], "info": ["bug", "show", "hi", "ui", " inf", "thin", "service", "dist", "config", "id", "i", "inf", "extra", "home", "io", "def", "api", "name", "source", "py", "fo", "module", "ref", "user", "si", "init", "di", "machine", "error", "app", "conf", "meta", "parse", "family", "desc", "fi", "li", "data", "http", "f", "tech", "state", "diff", "block", "INFO", "end", "is", "inner", "type", "gen", "pi", "link", "cache", "Info", "start"], "bus": ["plug", "bug", "bridge", "device", "board", "self", "bc", "service", "d", "cop", "config", "mount", "die", "home", "io", "local", "def", "front", "hub", "use", "serial", "di", "unit", "comment", "machine", "conf", "lib", "band", "pass", "plugin", "BUS", "boot", "fi", "http", "data", "b", "driver", "usb", "diff", "proxy", "block", "cat", "feed", "Bus", "loop", "host", "bi", "cache", "lock", "us", "pos", "controller"]}}
{"project": "qemu", "commit_id": "b2c98d9d392c87c9b9e975d30f79924719d9cbbe", "target": 0, "func": "static int tcg_match_ori(TCGType type, tcg_target_long val)\n\n{\n\n    if (facilities & FACILITY_EXT_IMM) {\n\n        if (type == TCG_TYPE_I32) {\n\n            /* All 32-bit ORs can be performed with 1 48-bit insn.  */\n\n            return 1;\n\n        }\n\n    }\n\n\n\n    /* Look for negative values.  These are best to load with LGHI.  */\n\n    if (val < 0) {\n\n        if (val == (int16_t)val) {\n\n            return 0;\n\n        }\n\n        if (facilities & FACILITY_EXT_IMM) {\n\n            if (val == (int32_t)val) {\n\n                return 0;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 15943, "substitutes": {"type": ["types", "Type", "call", "typ", "ype", "t", "id", "code", "i", "object", "style", "pre", "name", "py", "unit", "by", "model", "TYPE", "key", "like", "value", "var", "set", "col", "size", "p", "e", "info", "base", "op", "parent", "state", "block", "pe", "is", "target", "rule", "link", "class", "tag", "ty", "y"], "val": ["alt", "slot", "pal", "split", " value", "pt", "l", "pre", "def", "VAL", "eval", "x", "str", "ref", "arg", "unit", "vol", "lit", "fat", "loc", "valid", " Val", "value", "v", "key", "pol", "vert", "grad", "ind", "dev", "ee", "ver", "pl", "data", "min", "base", "count", "bal", "il", "ol", "isal", "rule", "elt", "sl", "Val", "aval", "cal", "al", "sel", "num", "rel", "el", "bl", "len", "vals"]}}
{"project": "qemu", "commit_id": "6e0d8677cb443e7408c0b7a25a93c6596d7fa380", "target": 0, "func": "void OPPROTO op_addq_EDI_T0(void)\n\n{\n\n    EDI = (EDI + T0);\n\n}\n", "idx": 15962, "substitutes": {}}
{"project": "qemu", "commit_id": "af08a58f0ca338eafee855921859a8c1ace0175b", "target": 0, "func": "static void hypercall_register_types(void)\n\n{\n\n    /* hcall-pft */\n\n    spapr_register_hypercall(H_ENTER, h_enter);\n\n    spapr_register_hypercall(H_REMOVE, h_remove);\n\n    spapr_register_hypercall(H_PROTECT, h_protect);\n\n    spapr_register_hypercall(H_READ, h_read);\n\n\n\n    /* hcall-bulk */\n\n    spapr_register_hypercall(H_BULK_REMOVE, h_bulk_remove);\n\n\n\n    /* hcall-dabr */\n\n    spapr_register_hypercall(H_SET_DABR, h_set_dabr);\n\n\n\n    /* hcall-splpar */\n\n    spapr_register_hypercall(H_REGISTER_VPA, h_register_vpa);\n\n    spapr_register_hypercall(H_CEDE, h_cede);\n\n\n\n    /* processor register resource access h-calls */\n\n    spapr_register_hypercall(H_SET_SPRG0, h_set_sprg0);\n\n    spapr_register_hypercall(H_SET_MODE, h_set_mode);\n\n\n\n    /* \"debugger\" hcalls (also used by SLOF). Note: We do -not- differenciate\n\n     * here between the \"CI\" and the \"CACHE\" variants, they will use whatever\n\n     * mapping attributes qemu is using. When using KVM, the kernel will\n\n     * enforce the attributes more strongly\n\n     */\n\n    spapr_register_hypercall(H_LOGICAL_CI_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CI_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_LOAD, h_logical_load);\n\n    spapr_register_hypercall(H_LOGICAL_CACHE_STORE, h_logical_store);\n\n    spapr_register_hypercall(H_LOGICAL_ICBI, h_logical_icbi);\n\n    spapr_register_hypercall(H_LOGICAL_DCBF, h_logical_dcbf);\n\n    spapr_register_hypercall(KVMPPC_H_LOGICAL_MEMOP, h_logical_memop);\n\n\n\n    /* qemu/KVM-PPC specific hcalls */\n\n    spapr_register_hypercall(KVMPPC_H_RTAS, h_rtas);\n\n\n\n    /* ibm,client-architecture-support support */\n\n    spapr_register_hypercall(KVMPPC_H_CAS, h_client_architecture_support);\n\n}\n", "idx": 15965, "substitutes": {}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void virtio_blk_update_config(VirtIODevice *vdev, uint8_t *config)\n\n{\n\n    VirtIOBlock *s = VIRTIO_BLK(vdev);\n\n    BlockConf *conf = &s->conf.conf;\n\n    struct virtio_blk_config blkcfg;\n\n    uint64_t capacity;\n\n    int blk_size = conf->logical_block_size;\n\n\n\n    bdrv_get_geometry(s->bs, &capacity);\n\n    memset(&blkcfg, 0, sizeof(blkcfg));\n\n    virtio_stq_p(vdev, &blkcfg.capacity, capacity);\n\n    virtio_stl_p(vdev, &blkcfg.seg_max, 128 - 2);\n\n    virtio_stw_p(vdev, &blkcfg.cylinders, conf->cyls);\n\n    virtio_stl_p(vdev, &blkcfg.blk_size, blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.min_io_size, conf->min_io_size / blk_size);\n\n    virtio_stw_p(vdev, &blkcfg.opt_io_size, conf->opt_io_size / blk_size);\n\n    blkcfg.heads = conf->heads;\n\n    /*\n\n     * We must ensure that the block device capacity is a multiple of\n\n     * the logical block size. If that is not the case, let's use\n\n     * sector_mask to adopt the geometry to have a correct picture.\n\n     * For those devices where the capacity is ok for the given geometry\n\n     * we don't touch the sector value of the geometry, since some devices\n\n     * (like s390 dasd) need a specific value. Here the capacity is already\n\n     * cyls*heads*secs*blk_size and the sector value is not block size\n\n     * divided by 512 - instead it is the amount of blk_size blocks\n\n     * per track (cylinder).\n\n     */\n\n    if (bdrv_getlength(s->bs) /  conf->heads / conf->secs % blk_size) {\n\n        blkcfg.sectors = conf->secs & ~s->sector_mask;\n\n    } else {\n\n        blkcfg.sectors = conf->secs;\n\n    }\n\n    blkcfg.size_max = 0;\n\n    blkcfg.physical_block_exp = get_physical_block_exp(conf);\n\n    blkcfg.alignment_offset = 0;\n\n    blkcfg.wce = bdrv_enable_write_cache(s->bs);\n\n    memcpy(config, &blkcfg, sizeof(struct virtio_blk_config));\n\n}\n", "idx": 15977, "substitutes": {"vdev": ["kdev", " vdes", "svpu", "vrvalid", "fdev", "svgd", " vpu", "vvalid", "bdevice", "lprof", "bgd", "hdes", "lgd", "hpu", "svdev", " vserial", "bdevelopment", "bserial", "bdev", "vdes", "vrdev", "wdevice", "bmod", "nconn", " vconn", "kgd", "hvalid", "wvalid", "fdevice", "vdd", " vgd", "brad", "vprof", "nvmod", "vmod", "bdes", "hver", "vpack", "vde", " vrad", "bdd", "vpu", "vconn", "bver", " vmod", "wdev", "hdiv", "hdevice", "vrdevice", "svdevice", " vdevelopment", "ldd", "vrde", "nvdev", "fconn", "bpack", "vrad", "kpack", " vpack", "nvserial", "krad", "ldevice", "vserial", "nvdevelopment", "hde", "vgd", " vver", "wde", "vver", "frad", "svrad", "vdevelopment", "hdev", "svdd", "vdiv", "bdiv", "bprof", "hprof", "ldev", "nrad", "vdevice", "ndevice", " vdevice", "hrad", "ndev"], "config": ["fig", "proc", "m", "cm", "bc", "ca", "Config", "rc", "ini", "inf", "def", "ci", "settings", "image", "con", "init", "v", "conn", "sec", "info", "fi", "pl", "data", "Conf", "f", "cfg", "address", "spec", "c", "dc", "gate", "sc", "cf", "exec", "cache", "param", "fee", "sub", "cl", "ctx"], "s": ["sys", "ses", "m", "d", "service", "sync", "sg", "t", "fs", "bs", "i", "rs", "sym", "a", "sup", "g", "cs", "sites", "S", "qs", "os", "sk", "h", "sets", "si", "js", "sum", "sq", "con", "session", "v", "ss", "ps", "o", "sch", "w", "an", "p", "e", "ions", "b", "sf", "n", "f", "gs", "spec", "c", "ns", "serv", "sc", "ssl", "states", "services", "ds", "r", "sub", "ls", "ts", "us", "ks"], "conf": ["bug", "ch", "self", "cm", "bc", "ca", "sche", "cc", "confirmed", "inf", "def", "cz", "lc", "cs", "req", "conv", "cn", "ref", "module", "cmp", "con", "vol", "sum", "comment", "init", "app", "conn", "cr", "client", "cons", "pub", "impl", "host", "dev", "info", "aff", "ver", "fi", "cli", "co", "Conf", "f", "cfg", "spec", "global", "c", "block", "cb", "sc", "cf", "cal", "cp", "exec", "cache", "cell", "param", "sub", "css", "com", "lock", "fam", "core", "cl", "ctx"], "blkcfg": ["plckgz", "blkeargs", "plkinit", "plckcgi", "plckcb", "bldgc", "plkscale", "blckfg", " blqconn", "blchconfig", "blworkinit", "blgconfig", "blkcb", "plkcfg", "blqconfig", "blckcgi", "blcheconfig", "blckconf", "plkcf", "BLkfg", "blskdc", "blkconn", "blcheini", "blqcgi", "blckargs", "blickconfig", "plckargs", "plckconfig", "plckgen", "blkwfg", "plkcgi", "blkwgz", "plckconn", "plkconf", "blkeconfig", "plckinit", "bldcfg", "blkeconn", " bldcfg", "blakcfg", "plckdc", "plkgen", "blckcb", "blkgen", " blckcmd", "blckcmd", "blckini", " blckcfg", "blkwcfg", "blchcfg", "plkdc", " blqfg", "blksconn", "bldargs", "plkfg", "bldfg", "blekconfig", "blakconf", "blbconn", "blkdc", "clkconfig", "blekini", "BLkcfg", "bldcmd", " bldconfig", "blksconf", "blijkconfig", "blkscfg", "blkargs", "blkini", "plkgz", " blqconfig", " blkconfig", "blkcf", "plkgate", "blickfg", "plckconf", "blckcf", " bldcmd", "plbcf", "blekcfg", "blbcfg", "blskfg", "blkconf", "plkargs", "blchgc", "blskcfg", "blqcfg", "blginit", "blckconfig", "blckgz", "BLqcfg", "blckdefinition", "BLkconn", "clkcfg", "blakfg", "blkscale", "blijkcfg", "blchedefinition", "blqfg", "blkfg", "blckscale", " blqcfg", "blijkfg", "blckinit", "blckconn", "bldcb", "cldfg", "blworkcfg", "plckscale", "blkdefinition", "blskconfig", "plbconfig", "blkgc", "blskcmd", "plckgate", "blckgate", "bldconf", "blqcmd", "blijkcgi", "BLqfg", "cldconfig", "plckcf", "blckdc", "blchfg", " bldgc", "blbconf", "plbconf", "blkgate", "bldgate", "bldconn", "blgcfg", "blecheini", " blkgc", "bldscale", "blkwconfig", "blijkini", "blecheconfig", "blkecb", "bldconfig", "blckcfg", "plckfg", "blkgz", " blckfg", " blckconfig", "blksfg", "blbconfig", "clkfg", "BLqconf", "blksconfig", "blkinit", "blechedefinition", "blkecfg", "blggen", "blkegate", "blckgc", "blickcfg", "blqconn", " blkconn", "blickcmd", "plkcb", "blqgz", "blekdefinition", "blqconf", "blkcgi", "BLqconn", "plckcfg", "clkconn", " blkcmd", "cldcfg", "blkcmd", "blechecfg", "plkconfig", " bldfg", "blijkdefinition", "blbfg", "blakconfig", "cldconn", "blkconfig", " blkfg", "plbcfg", "blckgen", "blworkconfig", "blddc", "BLkconf", "plkconn", "blworkgen", "blkscf", "blchecfg", "bldcf", "blskscale", "blbcf"], "capacity": ["charge", "usage", "carry", "bc", "cc", "growth", "memory", "density", "shape", "large", "connection", "lc", "pool", "buffer", "position", "performance", "maximum", "limit", "storage", "demand", "size", "instance", "p", "max", "length", "count", "n", "acl", "flow", "address", "spec", "c", "definition", "dc", "SIZE", "cap", "scale", "network", "acity", "cache", "volume", "power", "content", "largest", "space", "core", "alloc"]}}
{"project": "qemu", "commit_id": "aea14095ea91f792ee43ee52fe6032cd8cdd7190", "target": 0, "func": "static void decode_opc (CPUMIPSState *env, DisasContext *ctx)\n\n{\n\n    int32_t offset;\n\n    int rs, rt, rd, sa;\n\n    uint32_t op, op1;\n\n    int16_t imm;\n\n\n\n    /* make sure instructions are on a word boundary */\n\n    if (ctx->pc & 0x3) {\n\n        env->CP0_BadVAddr = ctx->pc;\n\n        generate_exception(ctx, EXCP_AdEL);\n\n        return;\n\n    }\n\n\n\n    /* Handle blikely not taken case */\n\n    if ((ctx->hflags & MIPS_HFLAG_BMASK_BASE) == MIPS_HFLAG_BL) {\n\n        int l1 = gen_new_label();\n\n\n\n        MIPS_DEBUG(\"blikely condition (\" TARGET_FMT_lx \")\", ctx->pc + 4);\n\n        tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n        tcg_gen_movi_i32(hflags, ctx->hflags & ~MIPS_HFLAG_BMASK);\n\n        gen_goto_tb(ctx, 1, ctx->pc + 4);\n\n        gen_set_label(l1);\n\n    }\n\n\n\n    if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) {\n\n        tcg_gen_debug_insn_start(ctx->pc);\n\n    }\n\n\n\n    op = MASK_OP_MAJOR(ctx->opcode);\n\n    rs = (ctx->opcode >> 21) & 0x1f;\n\n    rt = (ctx->opcode >> 16) & 0x1f;\n\n    rd = (ctx->opcode >> 11) & 0x1f;\n\n    sa = (ctx->opcode >> 6) & 0x1f;\n\n    imm = (int16_t)ctx->opcode;\n\n    switch (op) {\n\n    case OPC_SPECIAL:\n\n        decode_opc_special(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL2:\n\n        decode_opc_special2_legacy(env, ctx);\n\n        break;\n\n    case OPC_SPECIAL3:\n\n        decode_opc_special3(env, ctx);\n\n        break;\n\n    case OPC_REGIMM:\n\n        op1 = MASK_REGIMM(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_BLTZL: /* REGIMM branches */\n\n        case OPC_BGEZL:\n\n        case OPC_BLTZALL:\n\n        case OPC_BGEZALL:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        case OPC_BLTZ:\n\n        case OPC_BGEZ:\n\n            gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            break;\n\n        case OPC_BLTZAL:\n\n        case OPC_BGEZAL:\n\n            if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                if (rs == 0) {\n\n                    /* OPC_NAL, OPC_BAL */\n\n                    gen_compute_branch(ctx, op1, 4, 0, -1, imm << 2, 4);\n\n                } else {\n\n                    generate_exception(ctx, EXCP_RI);\n\n                }\n\n            } else {\n\n                gen_compute_branch(ctx, op1, 4, rs, -1, imm << 2, 4);\n\n            }\n\n            break;\n\n        case OPC_TGEI ... OPC_TEQI: /* REGIMM traps */\n\n        case OPC_TNEI:\n\n            check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            gen_trap(ctx, op1, rs, -1, imm);\n\n            break;\n\n        case OPC_SYNCI:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            /* Break the TB to be able to sync copied instructions\n\n               immediately */\n\n            ctx->bstate = BS_STOP;\n\n            break;\n\n        case OPC_BPOSGE32:    /* MIPS DSP branch */\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_BPOSGE64:\n\n#endif\n\n            check_dsp(ctx);\n\n            gen_compute_branch(ctx, op1, 4, -1, -2, (int32_t)imm << 2, 4);\n\n            break;\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DAHI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 32);\n\n            }\n\n            MIPS_DEBUG(\"dahi %s, %04x\", regnames[rs], imm);\n\n            break;\n\n        case OPC_DATI:\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            check_mips_64(ctx);\n\n            if (rs != 0) {\n\n                tcg_gen_addi_tl(cpu_gpr[rs], cpu_gpr[rs], (int64_t)imm << 48);\n\n            }\n\n            MIPS_DEBUG(\"dati %s, %04x\", regnames[rs], imm);\n\n            break;\n\n#endif\n\n        default:            /* Invalid */\n\n            MIPS_INVAL(\"regimm\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_CP0:\n\n        check_cp0_enabled(ctx);\n\n        op1 = MASK_CP0(ctx->opcode);\n\n        switch (op1) {\n\n        case OPC_MFC0:\n\n        case OPC_MTC0:\n\n        case OPC_MFTR:\n\n        case OPC_MTTR:\n\n#if defined(TARGET_MIPS64)\n\n        case OPC_DMFC0:\n\n        case OPC_DMTC0:\n\n#endif\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, op1, rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_C0_FIRST ... OPC_C0_LAST:\n\n#ifndef CONFIG_USER_ONLY\n\n            gen_cp0(env, ctx, MASK_C0(ctx->opcode), rt, rd);\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_MFMC0:\n\n#ifndef CONFIG_USER_ONLY\n\n            {\n\n                uint32_t op2;\n\n                TCGv t0 = tcg_temp_new();\n\n\n\n                op2 = MASK_MFMC0(ctx->opcode);\n\n                switch (op2) {\n\n                case OPC_DMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dmt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EMT:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_emt(t0);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_dvpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_EVPE:\n\n                    check_insn(ctx, ASE_MT);\n\n                    gen_helper_evpe(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    break;\n\n                case OPC_DI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_di(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                case OPC_EI:\n\n                    check_insn(ctx, ISA_MIPS32R2);\n\n                    save_cpu_state(ctx, 1);\n\n                    gen_helper_ei(t0, cpu_env);\n\n                    gen_store_gpr(t0, rt);\n\n                    /* Stop translation as we may have switched the execution mode */\n\n                    ctx->bstate = BS_STOP;\n\n                    break;\n\n                default:            /* Invalid */\n\n                    MIPS_INVAL(\"mfmc0\");\n\n                    generate_exception(ctx, EXCP_RI);\n\n                    break;\n\n                }\n\n                tcg_temp_free(t0);\n\n            }\n\n#endif /* !CONFIG_USER_ONLY */\n\n            break;\n\n        case OPC_RDPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_load_srsgpr(rt, rd);\n\n            break;\n\n        case OPC_WRPGPR:\n\n            check_insn(ctx, ISA_MIPS32R2);\n\n            gen_store_srsgpr(rt, rd);\n\n            break;\n\n        default:\n\n            MIPS_INVAL(\"cp0\");\n\n            generate_exception(ctx, EXCP_RI);\n\n            break;\n\n        }\n\n        break;\n\n    case OPC_BOVC: /* OPC_BEQZALC, OPC_BEQC, OPC_ADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BOVC, OPC_BEQZALC, OPC_BEQC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_ADDI */\n\n            /* Arithmetic with immediate opcode */\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_ADDIU:\n\n         gen_arith_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SLTI: /* Set on less than with immediate opcode */\n\n    case OPC_SLTIU:\n\n         gen_slt_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_ANDI: /* Arithmetic with immediate opcode */\n\n    case OPC_LUI: /* OPC_AUI */\n\n    case OPC_ORI:\n\n    case OPC_XORI:\n\n         gen_logic_imm(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_J ... OPC_JAL: /* Jump */\n\n         offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n         gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n         break;\n\n    /* Branch */\n\n    case OPC_BLEZC: /* OPC_BGEZC, OPC_BGEC, OPC_BLEZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BLEZC, OPC_BGEZC, OPC_BGEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BLEZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BGTZC: /* OPC_BLTZC, OPC_BLTC, OPC_BGTZL */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rt == 0) {\n\n                generate_exception(ctx, EXCP_RI);\n\n                break;\n\n            }\n\n            /* OPC_BGTZC, OPC_BLTZC, OPC_BLTC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_BGTZL */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        }\n\n        break;\n\n    case OPC_BLEZALC: /* OPC_BGEZALC, OPC_BGEUC, OPC_BLEZ */\n\n        if (rt == 0) {\n\n            /* OPC_BLEZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BLEZALC, OPC_BGEZALC, OPC_BGEUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BGTZALC: /* OPC_BLTZALC, OPC_BLTUC, OPC_BGTZ */\n\n        if (rt == 0) {\n\n            /* OPC_BGTZ */\n\n            gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n        } else {\n\n            check_insn(ctx, ISA_MIPS32R6);\n\n            /* OPC_BGTZALC, OPC_BLTZALC, OPC_BLTUC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        }\n\n        break;\n\n    case OPC_BEQL:\n\n    case OPC_BNEL:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_BEQ:\n\n    case OPC_BNE:\n\n         gen_compute_branch(ctx, op, 4, rs, rt, imm << 2, 4);\n\n         break;\n\n    case OPC_LWL: /* Load and stores */\n\n    case OPC_LWR:\n\n    case OPC_LL:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LB ... OPC_LH:\n\n    case OPC_LW ... OPC_LHU:\n\n         gen_ld(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SWL:\n\n    case OPC_SWR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SB ... OPC_SH:\n\n    case OPC_SW:\n\n         gen_st(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_SC:\n\n         check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n         gen_st_cond(ctx, op, rt, rs, imm);\n\n         break;\n\n    case OPC_CACHE:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_cp0_enabled(ctx);\n\n        check_insn(ctx, ISA_MIPS3 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n    case OPC_PREF:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS4 | ISA_MIPS32);\n\n        /* Treat as NOP. */\n\n        break;\n\n\n\n    /* Floating point (COP1). */\n\n    case OPC_LWC1:\n\n    case OPC_LDC1:\n\n    case OPC_SWC1:\n\n    case OPC_SDC1:\n\n        gen_cop1_ldst(ctx, op, rt, rs, imm);\n\n        break;\n\n\n\n    case OPC_CP1:\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP1(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_MFHC1:\n\n            case OPC_MTHC1:\n\n                check_insn(ctx, ISA_MIPS32R2);\n\n            case OPC_MFC1:\n\n            case OPC_CFC1:\n\n            case OPC_MTC1:\n\n            case OPC_CTC1:\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#if defined(TARGET_MIPS64)\n\n            case OPC_DMFC1:\n\n            case OPC_DMTC1:\n\n                check_insn(ctx, ISA_MIPS3);\n\n                gen_cp1(ctx, op1, rt, rd);\n\n                break;\n\n#endif\n\n            case OPC_BC1EQZ: /* OPC_BC1ANY2 */\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    /* OPC_BC1EQZ */\n\n                    gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                    rt, imm << 2);\n\n                } else {\n\n                    /* OPC_BC1ANY2 */\n\n                    check_cop1x(ctx);\n\n                    check_insn(ctx, ASE_MIPS3D);\n\n                    gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                }\n\n                break;\n\n            case OPC_BC1NEZ:\n\n                check_insn(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1_r6(ctx, MASK_CP1(ctx->opcode),\n\n                                rt, imm << 2);\n\n                break;\n\n            case OPC_BC1ANY4:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                check_cop1x(ctx);\n\n                check_insn(ctx, ASE_MIPS3D);\n\n                /* fall through */\n\n            case OPC_BC1:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n                gen_compute_branch1(ctx, MASK_BC1(ctx->opcode),\n\n                                    (rt >> 2) & 0x7, imm << 2);\n\n                break;\n\n            case OPC_PS_FMT:\n\n                check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n            case OPC_S_FMT:\n\n            case OPC_D_FMT:\n\n                gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                           (imm >> 8) & 0x7);\n\n                break;\n\n            case OPC_W_FMT:\n\n            case OPC_L_FMT:\n\n            {\n\n                int r6_op = ctx->opcode & FOP(0x3f, 0x1f);\n\n                if (ctx->insn_flags & ISA_MIPS32R6) {\n\n                    switch (r6_op) {\n\n                    case R6_OPC_CMP_AF_S:\n\n                    case R6_OPC_CMP_UN_S:\n\n                    case R6_OPC_CMP_EQ_S:\n\n                    case R6_OPC_CMP_UEQ_S:\n\n                    case R6_OPC_CMP_LT_S:\n\n                    case R6_OPC_CMP_ULT_S:\n\n                    case R6_OPC_CMP_LE_S:\n\n                    case R6_OPC_CMP_ULE_S:\n\n                    case R6_OPC_CMP_SAF_S:\n\n                    case R6_OPC_CMP_SUN_S:\n\n                    case R6_OPC_CMP_SEQ_S:\n\n                    case R6_OPC_CMP_SEUQ_S:\n\n                    case R6_OPC_CMP_SLT_S:\n\n                    case R6_OPC_CMP_SULT_S:\n\n                    case R6_OPC_CMP_SLE_S:\n\n                    case R6_OPC_CMP_SULE_S:\n\n                    case R6_OPC_CMP_OR_S:\n\n                    case R6_OPC_CMP_UNE_S:\n\n                    case R6_OPC_CMP_NE_S:\n\n                    case R6_OPC_CMP_SOR_S:\n\n                    case R6_OPC_CMP_SUNE_S:\n\n                    case R6_OPC_CMP_SNE_S:\n\n                        gen_r6_cmp_s(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    case R6_OPC_CMP_AF_D:\n\n                    case R6_OPC_CMP_UN_D:\n\n                    case R6_OPC_CMP_EQ_D:\n\n                    case R6_OPC_CMP_UEQ_D:\n\n                    case R6_OPC_CMP_LT_D:\n\n                    case R6_OPC_CMP_ULT_D:\n\n                    case R6_OPC_CMP_LE_D:\n\n                    case R6_OPC_CMP_ULE_D:\n\n                    case R6_OPC_CMP_SAF_D:\n\n                    case R6_OPC_CMP_SUN_D:\n\n                    case R6_OPC_CMP_SEQ_D:\n\n                    case R6_OPC_CMP_SEUQ_D:\n\n                    case R6_OPC_CMP_SLT_D:\n\n                    case R6_OPC_CMP_SULT_D:\n\n                    case R6_OPC_CMP_SLE_D:\n\n                    case R6_OPC_CMP_SULE_D:\n\n                    case R6_OPC_CMP_OR_D:\n\n                    case R6_OPC_CMP_UNE_D:\n\n                    case R6_OPC_CMP_NE_D:\n\n                    case R6_OPC_CMP_SOR_D:\n\n                    case R6_OPC_CMP_SUNE_D:\n\n                    case R6_OPC_CMP_SNE_D:\n\n                        gen_r6_cmp_d(ctx, ctx->opcode & 0x1f, rt, rd, sa);\n\n                        break;\n\n                    default:\n\n                        gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                                                       (imm >> 8) & 0x7);\n\n                        break;\n\n                    }\n\n                } else {\n\n                    gen_farith(ctx, ctx->opcode & FOP(0x3f, 0x1f), rt, rd, sa,\n\n                               (imm >> 8) & 0x7);\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                MIPS_INVAL(\"cp1\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n    /* Compact branches [R6] and COP2 [non-R6] */\n\n    case OPC_BC: /* OPC_LWC2 */\n\n    case OPC_BALC: /* OPC_SWC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BC, OPC_BALC */\n\n            gen_compute_compact_branch(ctx, op, 0, 0,\n\n                                       sextract32(ctx->opcode << 2, 0, 28));\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_BEQZC: /* OPC_JIC, OPC_LDC2 */\n\n    case OPC_BNEZC: /* OPC_JIALC, OPC_SDC2 */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            if (rs != 0) {\n\n                /* OPC_BEQZC, OPC_BNEZC */\n\n                gen_compute_compact_branch(ctx, op, rs, 0,\n\n                                           sextract32(ctx->opcode << 2, 0, 23));\n\n            } else {\n\n                /* OPC_JIC, OPC_JIALC */\n\n                gen_compute_compact_branch(ctx, op, 0, rt, imm);\n\n            }\n\n        } else {\n\n            /* OPC_LWC2, OPC_SWC2 */\n\n            /* COP2: Not implemented. */\n\n            generate_exception_err(ctx, EXCP_CpU, 2);\n\n        }\n\n        break;\n\n    case OPC_CP2:\n\n        check_insn(ctx, INSN_LOONGSON2F);\n\n        /* Note that these instructions use different fields.  */\n\n        gen_loongson_multimedia(ctx, sa, rd, rt);\n\n        break;\n\n\n\n    case OPC_CP3:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        if (ctx->CP0_Config1 & (1 << CP0C1_FP)) {\n\n            check_cp1_enabled(ctx);\n\n            op1 = MASK_CP3(ctx->opcode);\n\n            switch (op1) {\n\n            case OPC_LWXC1:\n\n            case OPC_LDXC1:\n\n            case OPC_LUXC1:\n\n            case OPC_SWXC1:\n\n            case OPC_SDXC1:\n\n            case OPC_SUXC1:\n\n                gen_flt3_ldst(ctx, op1, sa, rd, rs, rt);\n\n                break;\n\n            case OPC_PREFX:\n\n                /* Treat as NOP. */\n\n                break;\n\n            case OPC_ALNV_PS:\n\n            case OPC_MADD_S:\n\n            case OPC_MADD_D:\n\n            case OPC_MADD_PS:\n\n            case OPC_MSUB_S:\n\n            case OPC_MSUB_D:\n\n            case OPC_MSUB_PS:\n\n            case OPC_NMADD_S:\n\n            case OPC_NMADD_D:\n\n            case OPC_NMADD_PS:\n\n            case OPC_NMSUB_S:\n\n            case OPC_NMSUB_D:\n\n            case OPC_NMSUB_PS:\n\n                gen_flt3_arith(ctx, op1, sa, rs, rd, rt);\n\n                break;\n\n            default:\n\n                MIPS_INVAL(\"cp3\");\n\n                generate_exception (ctx, EXCP_RI);\n\n                break;\n\n            }\n\n        } else {\n\n            generate_exception_err(ctx, EXCP_CpU, 1);\n\n        }\n\n        break;\n\n\n\n#if defined(TARGET_MIPS64)\n\n    /* MIPS64 opcodes */\n\n    case OPC_LDL ... OPC_LDR:\n\n    case OPC_LLD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_LWU:\n\n    case OPC_LD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_ld(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SDL ... OPC_SDR:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n    case OPC_SD:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_SCD:\n\n        check_insn_opc_removed(ctx, ISA_MIPS32R6);\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_st_cond(ctx, op, rt, rs, imm);\n\n        break;\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC, OPC_DADDI */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            /* OPC_BNVC, OPC_BNEZALC, OPC_BNEC */\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            /* OPC_DADDI */\n\n            check_insn(ctx, ISA_MIPS3);\n\n            check_mips_64(ctx);\n\n            gen_arith_imm(ctx, op, rt, rs, imm);\n\n        }\n\n        break;\n\n    case OPC_DADDIU:\n\n        check_insn(ctx, ISA_MIPS3);\n\n        check_mips_64(ctx);\n\n        gen_arith_imm(ctx, op, rt, rs, imm);\n\n        break;\n\n#else\n\n    case OPC_BNVC: /* OPC_BNEZALC, OPC_BNEC */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n            gen_compute_compact_branch(ctx, op, rs, rt, imm << 2);\n\n        } else {\n\n            MIPS_INVAL(\"major opcode\");\n\n            generate_exception(ctx, EXCP_RI);\n\n        }\n\n        break;\n\n#endif\n\n    case OPC_DAUI: /* OPC_JALX */\n\n        if (ctx->insn_flags & ISA_MIPS32R6) {\n\n#if defined(TARGET_MIPS64)\n\n            /* OPC_DAUI */\n\n            check_mips_64(ctx);\n\n            if (rt != 0) {\n\n                TCGv t0 = tcg_temp_new();\n\n                gen_load_gpr(t0, rs);\n\n                tcg_gen_addi_tl(cpu_gpr[rt], t0, imm << 16);\n\n                tcg_temp_free(t0);\n\n            }\n\n            MIPS_DEBUG(\"daui %s, %s, %04x\", regnames[rt], regnames[rs], imm);\n\n#else\n\n            generate_exception(ctx, EXCP_RI);\n\n            MIPS_INVAL(\"major opcode\");\n\n#endif\n\n        } else {\n\n            /* OPC_JALX */\n\n            check_insn(ctx, ASE_MIPS16 | ASE_MICROMIPS);\n\n            offset = (int32_t)(ctx->opcode & 0x3FFFFFF) << 2;\n\n            gen_compute_branch(ctx, op, 4, rs, rt, offset, 4);\n\n        }\n\n        break;\n\n    case OPC_MDMX:\n\n        check_insn(ctx, ASE_MDMX);\n\n        /* MDMX: Not implemented. */\n\n        break;\n\n    case OPC_PCREL:\n\n        check_insn(ctx, ISA_MIPS32R6);\n\n        gen_pcrel(ctx, rs, imm);\n\n        break;\n\n    default:            /* Invalid */\n\n        MIPS_INVAL(\"major opcode\");\n\n        generate_exception(ctx, EXCP_RI);\n\n        break;\n\n    }\n\n}\n", "idx": 15980, "substitutes": {"env": ["erv", "proc", "en", "context", "pkg", "tx", "qa", "queue", "enc", "cv", "ea", "pec", "config", "code", "priv", "eu", "oa", "kn", "req", "txt", "vm", "init", "scope", "loc", "conf", "conn", "np", "console", "obj", "loader", "dev", "dict", "e", "viron", "exc", "fi", "info", "buf", "cli", "qt", "inst", "Environment", "ocr", "bg", "ce", "ep", "cal", "que", "exec", "db", "ev", "ec", "vt", "prefix", "environment", "util", "vs", "et", "hw", "esi", "err"], "ctx": [" context", "tx", "bc", "pec", "wcs", "cmp", "fp", "ct", "loc", "np", "obj", "ck", "scl", "c", "cas", "sc", "cp", "fc", "cpp", "anon", "context", "sync", "rc", "cc", "lc", "cs", "conv", "cn", "cms", "txt", "fn", "client", "bp", "console", "grad", "kt", "anc", "cases", "exec", "kb", "xc", "history", "support", "sys", "cv", "ca", "config", "pc", "cz", "ci", "wx", "cy", "xp", "scope", "linux", "conn", "kw", "nc", "tc", "acl", "gpu", "voc", "chan", "cf", "prefix", "hw", "cl", "fw", "pkg", "cm", "qa", "jp", "utils", "Context", "ctrl", "na", "std", "sq", "cli", "cus", "wp", "cca", "cu", "sci", "cmd", "qq", "vc", "src", "util"], "offset": ["oid", "Offset", "ff", "ffff", "top", "align", "fp", "loc", "error", "base", "bit", "origin", "skip", "ip", "rot", "src", "seq", "hop", "pos", "num", "prefix", "no", "len", "ptr", "alloc"], "rs": ["RC", "Rs", "rr", "rc", "ins", "cs", "hs", "os", "rg", "rows", "pps", "ps", "aps", "ms", "rb", "rx", "ars", "RS", "rl", "ns", "xs", "ops", "r", "ds", "rep", "pr", "ips", "dr", "res", " RS", "ls", "hop", "ims", "vs", "reg", "agg"], "rt": ["rr", "apt", "ru", "irt", "RT", "rat", "rc", "tr", "pt", "rn", "wt", "sr", "br", "rh", "adr", "mt", "rec", "rb", "rx", "NT", "ann", "rm", "rl", "cat", "ur", "attr", "nt", "rob", "r", "pr", "dr", "rel", "rf", "rot", "ptr", "rit", "err"], "rd": ["rr", "rss", "as", "ru", "rid", "d", "hr", "rc", "da", "bd", "ra", "RD", "rn", "rg", "ld", "lda", "rh", "adr", "lr", "rb", "rx", "nas", "rw", "rm", "rl", "dra", "dc", "attr", "md", "rob", "r", "ds", "dd", "ri", "dr", "addr", "rf"], "sa": ["sta", "as", "ca", "sg", "da", "a", "asi", "ta", "ra", "ain", "na", "sha", "sr", "si", "ama", "sq", "aa", "ras", "SA", "ba", "s", "sam", "pa", "sf", "sb", "au", "ann", "ma", "Sa", "ans", "ssl", "va", "ds", "ga", "asa", "ity", "sm", "asm"], "op": ["oper", "oid", "OP", "cop", "ipop", "api", "sp", "option", "pp", "post", "pop", "cmp", "mod", "operator", "loc", "app", "pol", "o", "set", "vert", "opus", "ant", "oc", "p", "comp", "oop", "omp", "opp", "expr", "ipp", "ip", "Op", "cat", "type", "ops", "ic", " Op", "hop", "off", "pos", "upp", "prop", "rot", "opt", "bit"], "op1": ["OP1", "hop1", "optn", "op3", "oper2", "OP2", "oper1", "opt3", "OPn", "opername", "opn", "op0", "hop3", "OP0", "opt1", " op0", " opn", "hop2", "optname", " op3", "opt2", "opname", " opname", "opt0"], "imm": ["cm", "lig", "fl", "amm", "mitt", "orm", "Imm", "fm", "cond", "umm", "umi", "mm", "mit", "si", "aim", "tm", "sim", "imp", "gm", "mt", "mem", "mun", "lif", "bm", "mi", "ann", "rm", "pm", "serv", "attr", "im", "ism", "lamm", "imet", "imi", "dim", "sm", "lim"]}}
{"project": "qemu", "commit_id": "8f3a73bc57ea83e5b3930d14fc596ea51859987a", "target": 0, "func": "bool blk_dev_is_tray_open(BlockBackend *blk)\n\n{\n\n    if (blk->dev_ops && blk->dev_ops->is_tray_open) {\n\n        return blk->dev_ops->is_tray_open(blk->dev_opaque);\n\n    }\n\n    return false;\n\n}\n", "idx": 15985, "substitutes": {"blk": ["plb", "BLks", "belb", "slk", "belks", "clsk", "clck", "slke", "flks", "plkt", "blke", " blb", "relunk", "clb", "BLke", " blke", "plk", "blastsk", " blq", "relck", "blsk", "blunk", "relk", " blks", "plks", "BLk", "belk", "blck", "blastck", "plck", "clk", "blkt", "slks", "belq", "blq", "slb", "BLq", "blastunk", "relsk", " blkt", " blunk", "blb", "flb", " blsk", "blastk", " blck", "plsk", "flk", "blks", "flkt", "BLb"]}}
{"project": "FFmpeg", "commit_id": "88ddcfa37f0067aae7457b44f433982f4c6d72ee", "target": 1, "func": "static av_cold int tdsc_init(AVCodecContext *avctx)\n\n{\n\n    TDSCContext *ctx = avctx->priv_data;\n\n    const AVCodec *codec;\n\n    int ret;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGR24;\n\n\n\n    /* These needs to be set to estimate buffer and frame size */\n\n    if (!(avctx->width && avctx->height)) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Video size not set.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* This value should be large enough for a RAW-only frame plus headers */\n\n    ctx->deflatelen = avctx->width * avctx->height * (3 + 1);\n\n    ret = av_reallocp(&ctx->deflatebuffer, ctx->deflatelen);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Allocate reference and JPEG frame */\n\n    ctx->refframe = av_frame_alloc();\n\n    ctx->jpgframe = av_frame_alloc();\n\n    if (!ctx->refframe || !ctx->jpgframe)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* Prepare everything needed for JPEG decoding */\n\n    codec = avcodec_find_decoder(AV_CODEC_ID_MJPEG);\n\n    if (!codec)\n\n        return AVERROR_BUG;\n\n    ctx->jpeg_avctx = avcodec_alloc_context3(codec);\n\n    if (!ctx->jpeg_avctx)\n\n        return AVERROR(ENOMEM);\n\n    ctx->jpeg_avctx->flags = avctx->flags;\n\n    ctx->jpeg_avctx->flags2 = avctx->flags2;\n\n    ctx->jpeg_avctx->dct_algo = avctx->dct_algo;\n\n    ctx->jpeg_avctx->idct_algo = avctx->idct_algo;;\n\n    ret = avcodec_open2(ctx->jpeg_avctx, codec, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    /* Set the output pixel format on the reference frame */\n\n    ctx->refframe->format = avctx->pix_fmt;\n\n\n\n    return 0;\n\n}\n", "idx": 15987, "substitutes": {"avctx": ["ajwcs", "varconn", "ajcu", "airctx", "vertx", "avcas", "avhw", "varcv", "navctx", "afconfig", " avcmp", "avecci", "avcu", " avcontext", "avecmp", "AVkb", "varcci", "afcmd", "AVcas", "avecontext", "navcontext", "avconfig", "varcontext", "avalcpu", "afcas", "avalkw", "auwcs", "AVconfig", "afconn", "avca", "avcv", "aftx", "AVcontext", "avectx", "ajkw", "afcu", "AVconn", "averctx", "afcontext", "avecas", "avehw", "avcpu", "avkb", "avconn", " avcas", "AVcmd", "aircas", "ajcas", "avkw", "varcmp", "ajcv", "avecu", "vercontext", "aveca", "avtx", " avca", "ajctx", "aveconfig", "vercmp", "verctx", "aircontext", "afctx", "afcci", "avcci", "aukw", "avercontext", "aucpu", "afkb", "AVcmp", "varcas", "avwcs", "avcmp", "navkb", "AVhw", "avalwcs", "afcmp", "avecv", "afhw", "varctx", "avercmd", "avcmd", "auctx", "avalctx", "avercmp", "aircmp", "avcontext", " avhw", "aveconn", "afca", "navconn", "AVctx", "varcu", "ajcpu", "AVtx"], "ctx": ["sys", "context", "tx", "cam", "cm", "bc", "pkg", "cv", "ca", "qa", "sync", "config", "pc", "cc", "cdn", "Context", "gc", "ctrl", "lc", "ci", "cs", "connection", "conv", "wx", "cms", "cn", "wcs", "cmp", "loc", "conn", "kw", "np", "client", "uc", "nc", "ck", "data", "tc", "cus", "component", "cli", "co", "wp", "cfg", "c", "cca", "cu", "cat", "anc", "cb", "cas", "sci", "cmd", "cf", "aux", "cp", "exec", "coll", "vc", "xc", "kb", "css", "fc", "git", "hw", "alloc", "fw"], "codec": ["codecode", "Codesc", "codect", "opec", "opc", "odesc", " coddec", "codek", "cedeus", "codenc", "codc", " codenc", "odc", " codect", "cdesc", "Codac", "cmdcode", "codac", "predec", "coduc", " codek", "codeect", "cmdenc", " codesc", " codeus", "odac", "coddec", " codc", "codesc", " codac", "dbeus", "odenc", "cduc", "cedec", "codcode", " codep", "cmdec", "cedek", "codep", "cdec", "dbdec", "codeec", "predac", " coduc", "cdac", "ceddec", "cmdect", "opep", "codeus", "dbek", "dbec", "predesc", "preduc", "odec", "odep", " codcode", "openc", "Codec", "Codenc", "codeenc"], "ret": ["pet", "en", "reply", "art", "val", " resp", "def", "gt", "str", "fin", "rb", "bf", "att", "cat", "end", " result", "iter", "out", "fail", "RET", "off", "num", " fun", "ft", "rev", "len", "rets", "det", "arg", "error", "pass", "mt", "result", "url", "ur", "r", "ard", "res", "reg", "aid", "rf", "flag", "run", "red", "alt", "let", " alt", "fun", " len", "ref", "lit", " arg", " pat", "sb", "Ret", "nt", " success", "re", "rt", "usr", "bit", "err", "code", "back", "pt", "std", " reply", "feat", "lt", "success", "all", "last", "pat", "et"]}}
{"project": "qemu", "commit_id": "3010460fb99776bdf0a8b170555f2ab076382f9c", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999, "substitutes": {"cpu": ["device", "runner", "proc", "intel", "profile", "roc", "auc", "image", "pool", "module", "cmp", "hu", "gru", "np", "ck", "c", "prem", "cp", "nic", "program", "fen", "fc", "cpp", "chip", "home", "gc", "lc", "fps", "cn", "product", "vm", "lua", "console", "loader", "GPU", "instance", " CPU", "eni", "clock", "host", "cache", "colo", "mac", "lb", "core", "python", "fork", "consumer", "pty", "queue", "ilo", "config", "pc", "uu", "uno", "linux", "px", "conn", "processor", "boot", "nc", "CPU", "cfg", "uci", "gpu", "cf", "que", "prefix", "ctx", "node", "hp", "bench", "pkg", "cm", "worker", "utils", "kernel", "performance", "computer", "rpm", "pu", "platform", "cli", "component", "cu", "process", "pai", "css"], "x86_cpu": ["x86JCPU", "x54_cpu", "x86_processor", "x86Jprocessor", "xea_processor", "x86_CPU", "x54_CPU", "x86_conn", "x54_gpu", "x86_gpu", "x86Jcpu", "x86Jgpu", "xea_gpu", "xea_cpu", "x54_conn", "xea_CPU"], "env": ["args", "path", "egg", "en", "context", "esp", "enc", "ea", "config", "profile", " environment", "worker", "extra", "priv", "eu", "style", "api", "ex", "fg", "scope", "skin", "estate", "conf", "conn", "np", "console", "dev", "equ", "e", "enable", "exc", "exe", "cli", "ext", "eng", "Environment", "cfg", "dep", "export", "global", "eni", "agent", "ne", "esc", "file", "ep", "gui", "db", "cache", "ev", "ec", "properties", "stack", "inet", "environment", "el", "fen", "opt", "net", "err"]}}
{"project": "FFmpeg", "commit_id": "332f9ac4e31ce5e6d0c42ac9e0229d7d1b2b4d60", "target": 0, "func": "int intel_h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format;\n\n\n\n    /* picture header */\n\n    if (get_bits_long(&s->gb, 22) != 0x20) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad picture start code\\n\");\n\n        return -1;\n\n    }\n\n    s->picture_number = get_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad marker\\n\");\n\n        return -1;\t/* marker */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Bad H263 id\\n\");\n\n        return -1;\t/* h263 id */\n\n    }\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n    if (format != 7) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Intel H263 free format not supported\\n\");\n\n        return -1;\n\n    }\n\n    s->h263_plus = 0;\n\n\n\n    s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n    \n\n    s->unrestricted_mv = get_bits1(&s->gb); \n\n    s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"SAC not supported\\n\");\n\n        return -1;\t/* SAC: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        s->obmc= 1;\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Advanced Prediction Mode not supported\\n\");\n\n//        return -1;\t/* advanced prediction mode: off */\n\n    }\n\n    if (get_bits1(&s->gb) != 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"PB frame mode no supported\\n\");\n\n        return -1;\t/* PB frame mode */\n\n    }\n\n\n\n    /* skip unknown header garbage */\n\n    skip_bits(&s->gb, 41);\n\n\n\n    s->qscale = get_bits(&s->gb, 5);\n\n    skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n\n\n    s->y_dc_scale_table=\n\n    s->c_dc_scale_table= ff_mpeg1_dc_scale_table;\n\n\n\n    return 0;\n\n}\n", "idx": 16020, "substitutes": {"s": ["native", "i", "rs", "qs", "h", "new", "js", "si", "ps", "spec", "is", "states", "in", "args", "m", "self", "d", "t", "sg", "fs", "ins", "sym", "g", "cs", "es", "full", "session", "u", "data", "b", "sf", "ns", "ops", "r", "ks", "sys", "parts", "service", "os", "sets", "o", "ms", "e", "site", "http", "f", "services", "ls", "comments", "ses", "as", "l", "a", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "set", "p", "plugins", "n", "gs", "xs", "stats", "ssl", "side", "ds", "su", "ts", "us", "y"], "format": [" fmt", "zip", "nat", "fd", "t", "frequency", "style", "name", "gap", "flat", "act", "MAT", "unit", "method", "position", "fp", "fn", "frame", "package", "form", "category", "feat", "filter", "size", " formats", "version", "ant", "stage", "data", "base", "qt", "length", "mode", "f", "at", "magic", "cat", "feed", "ats", "type", "offset", "function", "pi", "transform", "scale", "language", "et", "template", "layout", "prefix", "lat", "quality", "len", "Format"]}}
{"project": "qemu", "commit_id": "b5eff355460643d09e533024360fe0522f368c07", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047, "substitutes": {"bs": ["bt", "blocks", "bid", "bis", "bc", "lbs", "BS", "fs", "sync", "ins", "fb", "rs", "cs", "fps", "bytes", "os", "js", "abc", "ps", "ss", "obj", "obs", "rb", "plugins", "s", "pb", "vs", "b", "sb", "base", "banks", "gs", "bits", "ns", "bu", "bps", "cb", "outs", "bes", "eb", "bas", "ds", "bi", "ls", "css", "bos", "ubs", "lb", "las", "bl", "iss", "abi"], "offset": ["area", "port", "location", "Offset", "root", "part", "slot", "config", "shift", "absolute", "bound", "reference", "align", "image", "bytes", "operation", "ref", "position", "fp", "loc", "error", "set", "o", "phase", "size", "layer", "online", "boot", "pointer", "data", "base", "length", "count", "padding", "address", "timeout", "reset", "type", "attribute", "initial", "seq", "off", "pos", "prefix", "addr", "order", "et", "ptr", "index", "start"], "buf1": ["buff1", "bag2", "seqed", " bufname", "buf2", "seq1", "buffer2", " buf2", " bufone", "bufname", "buffered", "buff2", "bag1", "seqone", "seq2", "buffer1", "bufed", " bufed", "bagname", "bufone", "bufferone", "buffname", "buffername", "bagone"], "count1": ["Count1", "cond1", "lengthone", "Count6", "base8", " countone", "CountOne", "cacheone", "length2", "condone", " count6", "sum1", "count2", "count6", "part2", "partOne", "condOne", "count8", "sum8", "length1", "Count2", " count8", "countOne", " countOne", "lengthOne", "part6", "base1", "cache1", "countone", "baseone", "sumone", " count2", "part1", "cond2", "cache2"], "drv": [" drb", "DRp", "DRc", "DRb", "Drp", "driv", "drV", "irtb", "Drb", "Drf", " drc", "drvr", "irtv", "irtf", "Drv", " drf", " drvr", "drib", "DRv", "drb", "DRV", " drp", "hrb", "DRf", "irtvr", "srv", "drif", "drf", "drivr", "hrf", "srV", "hrv", "src", "srf", "Drvr", "hrvr", "drc", "drp", " drV", "hrV", "DrV"]}}
{"project": "qemu", "commit_id": "ac125d993b461d4dee4d6df4d93ac3f2eb959d1d", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057, "substitutes": {"ctx": ["context", "tx", "cm", "bc", "pkg", "cv", "ca", "sync", "rc", "config", "Context", "gc", "lc", "cs", "ctrl", "conv", "cmp", "scope", "fp", "loc", "client", "conn", "fi", "cli", "tc", "driver", "gb", "c", "cca", "anc", "cas", "sc", "sci", "cf", "coll", "cp", "exec", "kb", "cache", "xc", "window", "hw", "fw"], "fs_path": ["fs_project", "fs_ath", " fs_name", "fs67path", " fs_node", "fs_node", "fsblockpath", "gs67case", "gs67project", "gs_location", "gs67location", "fs67case", "fsblocklocation", "gs67path", "fs_location", "gs_project", "gs_path", "gs_case", "fs67location", "fs_name", "fs_case", "fs67project", "fsblockproject", " fs_ath", "fsblockcase"], "size": ["args", "en", "small", "izes", "complete", "sync", "grow", "shift", "code", "any", "large", "name", "g", "Size", "bytes", "str", "izer", "form", "ize", "six", "sec", "e", "max", "data", "length", "from", "address", "timeout", "end", "SIZE", "esc", "sn", "offset", "scale", "empty", "fee", "ise", "len"], "buffer": ["transfer", "port", "context", "bin", "slice", "queue", "input", "response", "batch", "code", "seed", "binary", "FFER", "pointer", "source", "reference", "border", "pool", "ref", "writer", "comment", "fp", "buff", "output", "rb", "resource", "buf", "data", "b", "base", "Buffer", "reader", "count", "length", "f", "result", "read", "url", "block", "feed", "uffer", "file", "iter", "cache", "header", "window", "prefix", "texture", "ptr", "message"], "ret": ["alt", "ft", "done", "part", "reply", "complete", "after", "val", "def", "rets", "gt", "fun", "final", "status", "str", "ref", "xt", "lit", "limit", "obj", "pass", "active", "mem", "info", "success", "data", "match", "base", "Ret", "ext", "count", "bf", "read", "result", " Ret", "offset", "nt", "iter", "re", "rt", "get", "RET", "no", "reg", "flag", "len", "bit", "replace"], "path": ["area", "port", "location", "context", "root", "self", "ath", "enc", "name", "builder", "image", "txt", "raw", "key", "dir", "loc", "rh", "clean", "loader", "p", "folder", "buf", "data", "pointer", "base", "entry", "length", "Path", "parent", "url", "c", "anc", "text", "cache", "pattern", "content", "space", "node"]}}
{"project": "qemu", "commit_id": "8ba2aae32c40f544def6be7ae82be9bcb781e01d", "target": 0, "func": "void uuid_unparse(const uuid_t uu, char *out)\n\n{\n\n    snprintf(out, 37, UUID_FMT,\n\n            uu[0], uu[1], uu[2], uu[3], uu[4], uu[5], uu[6], uu[7],\n\n            uu[8], uu[9], uu[10], uu[11], uu[12], uu[13], uu[14], uu[15]);\n\n}\n", "idx": 16068, "substitutes": {"uu": ["uni", "ubuntu", "zero", "utf", "uc", "ru", "una", "input", "ucl", "vv", "uint", "unc", "up", "un", "ug", "eu", "oa", "uf", "UID", "hum", "unique", "null", "user", "acc", "kk", "UU", "valid", "ull", "gu", "uh", "ul", "fff", "u", "iii", "pack", "uy", "du", "buf", "gb", "usa", "bu", "cu", "lu", "flu", "ucc", "iq", "uum", " u", "tu", "uv", "empty", "su", "universal", "seq", "U", "ou", "num", "mult", "username", "uid"], "out": ["word", "m", "self", "input", "array", "escape", "up", "code", "again", "name", "dump", "ex", "this", "user", "str", "buffer", "pool", "key", "error", "v", "output", "conn", "w", "doc", "temp", "pad", "data", "b", "base", "dot", "point", "parent", "line", "at", "c", "inc", "down", "ac", "OUT", "outs", "write", "Out", "prefix", "in", "err"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static int stellaris_enet_can_receive(void *opaque)\n\n{\n\n    stellaris_enet_state *s = (stellaris_enet_state *)opaque;\n\n\n\n    if ((s->rctl & SE_RCTL_RXEN) == 0)\n\n        return 1;\n\n\n\n    return (s->np < 31);\n\n}\n", "idx": 16083, "substitutes": {"opaque": ["infonymous", "infasma", "opasma", "oponymous", "obacity", "operacity", "opaques", "obaque", "operaque", "OPaques", "ospasma", "opacity", "operque", "OPacity", "ospaque", "osponymous", "OPque", "opque", "obaques", "OPaque", " opasma", " oponymous", "obque", "operaques", "infaque"], "s": ["secondary", "south", "sys", "ses", "m", "self", "service", "sync", "rs", "sym", "a", "g", "S", "send", "new", "status", "si", "es", "sq", "session", "server", "ss", "o", "an", "u", "p", "e", "se", "sec", "socket", "http", "sb", "sf", "b", "n", "stat", "spec", "state", "c", "ns", "is", "ssl", "sl", "states", "r", "services", "sie", "ops", "sa", "su", "ds"]}}
{"project": "qemu", "commit_id": "75f27498220e6ff6f78bf08fbe2cc662ec76ba89", "target": 0, "func": "void acpi_memory_unplug_cb(MemHotplugState *mem_st,\n\n                           DeviceState *dev, Error **errp)\n\n{\n\n    MemStatus *mdev;\n\n\n\n    mdev = acpi_memory_slot_status(mem_st, dev, errp);\n\n    if (!mdev) {\n\n        return;\n\n    }\n\n\n\n    /* nvdimm device hot unplug is not supported yet. */\n\n    assert(!object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM));\n\n    mdev->is_enabled = false;\n\n    mdev->dimm = NULL;\n\n}\n", "idx": 16089, "substitutes": {"mem_st": [" mem_inst", " mem_fr", " mem_ST", "mem1st", "mem_inst", "mem1sta", "mem_ST", "mem_start", "mem_sta", "mem_fr", " mem_sta", "mem1ST", " mem_start", "mem1start"], "dev": ["bug", "device", "development", "proc", "d", "priv", " device", "def", "rad", "bd", " sd", "sk", "serial", " def", "user", "Dev", "mod", "comment", "error", "valid", "conf", "gu", "adv", "der", "var", "gd", "w", "grad", "conn", "ad", "obj", "mem", "info", "ver", "de", "prom", "data", "sd", "spec", "diff", "dem", "DEV", "md", "debug", "od", "ev", "pos", " dw", "wd", "fr", "err"], "errp": [" errr", " errf", "erfp", "errf", "erpc", "errorp", "errr", "errorfp", "errfp", "errorP", "errP", " errfp", " errP", "erp", "erP", "errorpc", "errorf", "errpc", "erf", " errpc", "errorr", "err"], "mdev": ["fmdev", " mdevice", "mtr", "ndd", "fmdevice", "nvalid", "mdevice", "pev", "mdiv", "pdi", "fmdd", " mvalid", "prad", "pdiv", "amdiv", "amdev", "mvalid", "maddev", "dmver", "fmev", "mdi", "pdev", "mev", "mrad", "mver", "madrad", "mdd", "dmdiv", "ptr", "amtr", " mdi", "maddiv", "dmdevice", "pdevice", "ndevice", "amvalid", "ndi", "amver", "nev", " mev", " mdiv", " mtr", "ndev", " mrad", "madev", "pvalid", " mdd", " mver", "amdevice", "dmdev"]}}
{"project": "qemu", "commit_id": "a7824a886ed50eb4fe3c6fcd6afd8814a6973583", "target": 0, "func": "alloc_f(int argc, char **argv)\n\n{\n\n\tint64_t offset;\n\n\tint nb_sectors;\n\n\tchar s1[64];\n\n\tint num;\n\n\tint ret;\n\n\tconst char *retstr;\n\n\n\n\toffset = cvtnum(argv[1]);\n\n\tif (offset & 0x1ff) {\n\n\t\tprintf(\"offset %lld is not sector aligned\\n\",\n\n\t\t\t(long long)offset);\n\n\t\treturn 0;\n\n\t}\n\n\n\n\tif (argc == 3)\n\n\t\tnb_sectors = cvtnum(argv[2]);\n\n\telse\n\n\t\tnb_sectors = 1;\n\n\n\n\tret = bdrv_is_allocated(bs, offset >> 9, nb_sectors, &num);\n\n\n\n\tcvtstr(offset, s1, sizeof(s1));\n\n\n\n\tretstr = ret ? \"allocated\" : \"not allocated\";\n\n\tif (nb_sectors == 1)\n\n\t\tprintf(\"sector %s at offset %s\\n\", retstr, s1);\n\n\telse\n\n\t\tprintf(\"%d/%d sectors %s at offset %s\\n\",\n\n\t\t\tnum, nb_sectors, retstr, s1);\n\n\treturn 0;\n\n}\n", "idx": 16090, "substitutes": {"argv": ["Argv", " argvals", "Argc", "passu", " argp", "argumentv", "tagc", "tagv", "axc", "Argp", "passc", "tagp", "Argu", "argvals", "axv", "argumentc", "tagu", "axp", "passv", "argc", "argumentvals", "argumentp", "argp", "passp", "argu", " argu", " argc", "axvals"], "offset": ["elta", "location", "Offset", "part", "slot", "slice", "array", "config", "shift", "seed", "range", "gap", "align", "uple", "missing", "ref", "buffer", "position", "sum", "append", "loc", "error", "fp", "limit", "set", "o", "alpha", "annot", "size", "stop", "pointer", "data", "base", "af", "length", "count", "origin", "acl", "padding", "address", "skip", "number", "url", "reset", "timeout", "olerance", "end", "type", "rot", "fee", "et", "seq", "layout", "off", "pos", "addr", "prefix", "delay", "len", "alias", "ptr", "alloc", "index", "start"], "nb_sectors": ["nb_serctors", "nb_searers", "nb_sctions", "nb_vector", "nb_secs", "nb_specctions", "nb_secctors", "nb_partivers", "nb_veapters", "nb_sercs", "nb_seors", "nb_serapters", "nb2sector", "nb_desctors", "nb_partctor", "nb_Sections", "nb_vegments", "nb_SEivers", "nb_SEgments", "nb__sectors", "nb_secsections", "nb__SEctors", "nb_SEors", "nb_vesections", "nb2SEgments", "nb_secgments", "nb_SEcs", "nb_seapters", "nb_specctors", "nb_sergments", "nb_SEctors", "nb_seccs", "nb__seors", "nb_partors", "nb_speccs", "nb_speclements", "nb_seivers", "nb_seclements", "nb_sgments", "nb_desvec", "nb_desarers", "nb_sersections", "nb_vectors", "nb_sevec", "nb_selements", "nb_vections", "nb_secctor", "nb_sctors", "nb_sections", "nb_segments", "nb_sesections", "nb_veivers", "nb_sector", "nb_secctions", "nb_scs", "nb__seivers", "nb2SEctors", "nb_partctors", "nb_desctions", "nb__SEivers", "nb_Sevec", "nb2sections", "nb_SEctor", "nb2sectors", "nb_serarers", "nb2SEctor", "nb_Searers", "nb2SEctions", "nb_Sectors", "nb_veors", "nb_serlements", "nb__sector", "nb_serctions", "nb__SEors", "nb_SEctions", "nb_servec", "nb__SEctor", "nb2segments", "nb_secapters"], "s1": ["p2", "ps5", "p0", "psp", " s2", "sp", "ps1", "pp", "f2", " s5", "fp", "f0", "p1", "sesone", "s2", "ses1", "s5", " sp", "sone", "p5", "s0", "f1", "ps0", " s0", "pone", "ses2", " sone"], "num": ["uni", "en", "bin", "NUM", "on", "unc", "id", "split", "un", "nn", "name", "nb", "ref", "unit", "init", "con", "sum", "umi", "loc", "valid", "fn", "begin", "np", "ul", "temp", "info", "old", "n", "f", "nu", "result", "number", "end", "Num", "nt", "um", "nr", "off", "no", "util", "len", "nm", "node", "index"], "ret": [" fun", "alt", "en", "done", "rev", "reply", "art", "rc", "tr", "val", " alt", "def", "rets", "fun", " len", "final", "ref", "pret", "arg", "det", "xt", "lit", " mem", "valid", "pub", "info", "fin", "match", "success", "ext", "Ret", "bf", "result", "fit", "att", " fut", " result", "nt", "iter", "re", "rt", "repl", "et", "RET", "res", "reg", "flag", "len", "bit"], "retstr": ["refStr", "returnstring", "retr", "alttext", "retstring", "refstr", "refSTR", "retSTR", " retstri", "returnr", "altst", "replystr", "revstr", "resultStr", "pretstr", "resultstr", "altstr", "refr", " retStr", "rettext", "Retr", " rettext", "retStr", "replyr", "replystri", " retr", "retstruct", "returnstr", "retstri", "resultr", "revst", "pretstri", "RetSTR", "pretstruct", "Retstr", "replystruct", "returnStr", " retst", "resultstring", "revtext", "RetStr", " retstring", "pretr", " retSTR", " retstruct", "retst"]}}
{"project": "qemu", "commit_id": "788cf9f8c8cbda53843e060540f3e91a060eb744", "target": 1, "func": "static void hmp_cont_cb(void *opaque, int err)\n\n{\n\n    if (!err) {\n\n        qmp_cont(NULL);\n\n    }\n\n}\n", "idx": 16093, "substitutes": {"opaque": ["ospatile", "OPatile", "ospacity", " opaya", "opacity", "OPaque", "OPacity", "ospaque", "OPaya", "ospaya", "opatile", " opatile", "opaya", " opacity"], "err": ["bug", "rr", "gz", "done", "arm", "rc", "gr", "orig", "or", "ctr", "rar", "Error", "er", "req", "test", "str", "cmp", "init", "ace", "eor", "error", "Er", "rh", "e", "lr", "rb", "ok", "reader", "result", "raise", "fe", "arr", "end", "acer", "cb", " error", "iter", "r", "errors", "finder", "ev", "ar", "rage", "dr", "ise", "core", "ptr", "callback"]}}
{"project": "qemu", "commit_id": "36fef36b91f7ec0435215860f1458b5342ce2811", "target": 1, "func": "static int megasas_ctrl_get_info(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *pci_dev = PCI_DEVICE(s);\n\n    PCIDeviceClass *pci_class = PCI_DEVICE_GET_CLASS(pci_dev);\n\n    MegasasBaseClass *base_class = MEGASAS_DEVICE_GET_CLASS(s);\n\n    struct mfi_ctrl_info info;\n\n    size_t dcmd_size = sizeof(info);\n\n    BusChild *kid;\n\n    int num_pd_disks = 0;\n\n\n\n    memset(&info, 0x0, cmd->iov_size);\n\n    if (cmd->iov_size < dcmd_size) {\n\n        trace_megasas_dcmd_invalid_xfer_len(cmd->index, cmd->iov_size,\n\n                                            dcmd_size);\n\n        return MFI_STAT_INVALID_PARAMETER;\n\n    }\n\n\n\n    info.pci.vendor = cpu_to_le16(pci_class->vendor_id);\n\n    info.pci.device = cpu_to_le16(pci_class->device_id);\n\n    info.pci.subvendor = cpu_to_le16(pci_class->subsystem_vendor_id);\n\n    info.pci.subdevice = cpu_to_le16(pci_class->subsystem_id);\n\n\n\n    /*\n\n     * For some reason the firmware supports\n\n     * only up to 8 device ports.\n\n     * Despite supporting a far larger number\n\n     * of devices for the physical devices.\n\n     * So just display the first 8 devices\n\n     * in the device port list, independent\n\n     * of how many logical devices are actually\n\n     * present.\n\n     */\n\n    info.host.type = MFI_INFO_HOST_PCIE;\n\n    info.device.type = MFI_INFO_DEV_SAS3G;\n\n    info.device.port_count = 8;\n\n    QTAILQ_FOREACH(kid, &s->bus.qbus.children, sibling) {\n\n        SCSIDevice *sdev = DO_UPCAST(SCSIDevice, qdev, kid->child);\n\n        uint16_t pd_id;\n\n\n\n        if (num_pd_disks < 8) {\n\n            pd_id = ((sdev->id & 0xFF) << 8) | (sdev->lun & 0xFF);\n\n            info.device.port_addr[num_pd_disks] =\n\n                cpu_to_le64(megasas_get_sata_addr(pd_id));\n\n        }\n\n        num_pd_disks++;\n\n    }\n\n\n\n    memcpy(info.product_name, base_class->product_name, 24);\n\n    snprintf(info.serial_number, 32, \"%s\", s->hba_serial);\n\n    snprintf(info.package_version, 0x60, \"%s-QEMU\", qemu_hw_version());\n\n    memcpy(info.image_component[0].name, \"APP\", 3);\n\n    snprintf(info.image_component[0].version, 10, \"%s-QEMU\",\n\n             base_class->product_version);\n\n    memcpy(info.image_component[0].build_date, \"Apr  1 2014\", 11);\n\n    memcpy(info.image_component[0].build_time, \"12:34:56\", 8);\n\n    info.image_component_count = 1;\n\n    if (pci_dev->has_rom) {\n\n        uint8_t biosver[32];\n\n        uint8_t *ptr;\n\n\n\n        ptr = memory_region_get_ram_ptr(&pci_dev->rom);\n\n        memcpy(biosver, ptr + 0x41, 31);\n\n        memcpy(info.image_component[1].name, \"BIOS\", 4);\n\n        memcpy(info.image_component[1].version, biosver,\n\n               strlen((const char *)biosver));\n\n        info.image_component_count++;\n\n    }\n\n    info.current_fw_time = cpu_to_le32(megasas_fw_time());\n\n    info.max_arms = 32;\n\n    info.max_spans = 8;\n\n    info.max_arrays = MEGASAS_MAX_ARRAYS;\n\n    info.max_lds = MFI_MAX_LD;\n\n    info.max_cmds = cpu_to_le16(s->fw_cmds);\n\n    info.max_sg_elements = cpu_to_le16(s->fw_sge);\n\n    info.max_request_size = cpu_to_le32(MEGASAS_MAX_SECTORS);\n\n    if (!megasas_is_jbod(s))\n\n        info.lds_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_present = cpu_to_le16(num_pd_disks);\n\n    info.pd_disks_present = cpu_to_le16(num_pd_disks);\n\n    info.hw_present = cpu_to_le32(MFI_INFO_HW_NVRAM |\n\n                                   MFI_INFO_HW_MEM |\n\n                                   MFI_INFO_HW_FLASH);\n\n    info.memory_size = cpu_to_le16(512);\n\n    info.nvram_size = cpu_to_le16(32);\n\n    info.flash_size = cpu_to_le16(16);\n\n    info.raid_levels = cpu_to_le32(MFI_INFO_RAID_0);\n\n    info.adapter_ops = cpu_to_le32(MFI_INFO_AOPS_RBLD_RATE |\n\n                                    MFI_INFO_AOPS_SELF_DIAGNOSTIC |\n\n                                    MFI_INFO_AOPS_MIXED_ARRAY);\n\n    info.ld_ops = cpu_to_le32(MFI_INFO_LDOPS_DISK_CACHE_POLICY |\n\n                               MFI_INFO_LDOPS_ACCESS_POLICY |\n\n                               MFI_INFO_LDOPS_IO_POLICY |\n\n                               MFI_INFO_LDOPS_WRITE_POLICY |\n\n                               MFI_INFO_LDOPS_READ_POLICY);\n\n    info.max_strips_per_io = cpu_to_le16(s->fw_sge);\n\n    info.stripe_sz_ops.min = 3;\n\n    info.stripe_sz_ops.max = ctz32(MEGASAS_MAX_SECTORS + 1);\n\n    info.properties.pred_fail_poll_interval = cpu_to_le16(300);\n\n    info.properties.intr_throttle_cnt = cpu_to_le16(16);\n\n    info.properties.intr_throttle_timeout = cpu_to_le16(50);\n\n    info.properties.rebuild_rate = 30;\n\n    info.properties.patrol_read_rate = 30;\n\n    info.properties.bgi_rate = 30;\n\n    info.properties.cc_rate = 30;\n\n    info.properties.recon_rate = 30;\n\n    info.properties.cache_flush_interval = 4;\n\n    info.properties.spinup_drv_cnt = 2;\n\n    info.properties.spinup_delay = 6;\n\n    info.properties.ecc_bucket_size = 15;\n\n    info.properties.ecc_bucket_leak_rate = cpu_to_le16(1440);\n\n    info.properties.expose_encl_devices = 1;\n\n    info.properties.OnOffProperties = cpu_to_le32(MFI_CTRL_PROP_EnableJBOD);\n\n    info.pd_ops = cpu_to_le32(MFI_INFO_PDOPS_FORCE_ONLINE |\n\n                               MFI_INFO_PDOPS_FORCE_OFFLINE);\n\n    info.pd_mix_support = cpu_to_le32(MFI_INFO_PDMIX_SAS |\n\n                                       MFI_INFO_PDMIX_SATA |\n\n                                       MFI_INFO_PDMIX_LD);\n\n\n\n    cmd->iov_size -= dma_buf_read((uint8_t *)&info, dcmd_size, &cmd->qsg);\n\n    return MFI_STAT_OK;\n\n}\n", "idx": 16112, "substitutes": {"s": ["secondary", "south", "sys", "ses", "m", "service", "d", "sync", "sg", "fs", "i", "sym", "a", "current", "g", "cs", "S", "settings", "new", "os", "es", "js", "si", "sq", "session", "server", "v", "conf", "ss", "client", "o", "request", "p", "e", "sec", "http", "k", "b", "sf", "sb", "j", "n", "f", "gs", "state", "spec", "c", "serv", "setup", "ns", "is", "stats", "ssl", "side", "ops", "services", "r", "sis", "start"], "cmd": ["args", "device", "pkg", "cm", "dq", "input", "config", "id", "cc", "code", "msg", "def", "name", "ctrl", "cs", "req", "event", "cms", "module", "method", "init", "cmp", "conf", "conn", "client", "request", "cd", "metadata", "cli", "nc", "ck", "mode", "cfg", "ctl", "c", "setup", "dc", "cb", "target", "md", "Cmd", "cod", "q", "cf", "command", "cp", "host", "qq", "comm", "mac", "dom", "ctx"], "pci_dev": ["pcu_dev", "pcu_device", "pci__de", "pci__ev", "pci_device", "pciacspec", "pcm_de", "pci_spec", "pci_ev", "pci__dev", "pci__device", "pcm_ev", "pciacdev", "pciacclass", "pci_de", "pciacdevice", "pcm_dev", "pcu_class", "pcu_spec", "pcm_device"], "pci_class": ["pcioutbus", "pcioutclasses", "pcinspec", "pci_comp", "pcioutclass", "pcinmodel", "pcixspec", "pci67spec", "pccinnum", "pcci_model", "ppi_spec", "pci__type", "pci__comp", "pci_bin", "pcixtype", "pii_class", "pci_bus", "ppi67lab", "pcinclass", "pcioutbin", "pci_spec", "ppi67type", "pcci_class", "pcci_num", "pii_spec", "pci_model", "pcli_comp", "pdi_class", "pci_type", "ppi_type", "pcli_class", "pcixsession", "pii_session", "pci__class", "pcli_line", "ppi67class", "ppi_class", "pci67type", "pci_session", "pccinclass", "pci_line", "pci__lab", "pci_classes", "pcixline", "ppi67spec", "pci__line", "pdi_classes", "pcixsystem", "pdi_bin", "pcinnum", "pci_num", "pcli_type", "pii_system", "pccinspec", "pcixclass", "pci__spec", "pci67lab", "pcci_spec", "ppi_lab", "pdi_bus", "pci_system", "pci_lab", "pcixcomp", "pci67class", "pccinmodel"], "base_class": ["cache_class", "base2class", "cache_name", "base2type", "cache_type", "base_type", "base_name", "base2name"], "info": ["show", "build", "i", "inf", "def", "image", "event", "h", "si", "frame", "obj", "ok", "base", "end", "afi", "get", "command", "off", "Info", "ami", "debug", "index", "slice", "fs", "id", "home", "api", "comment", "error", "fi", "data", "ext", "result", "json", "inner", "alias", "support", "zip", "ch", "shared", "config", "extra", "fo", "init", "update", "about", "linux", "app", "conn", "help", "metadata", "options", "http", "f", "state", "diff", "INFO", "type", "ctx", "node", "fw", "bug", "ui", "ret", "gi", "die", "name", "kernel", "py", "ii", "conf", "buff", "cli", "setup", "now", "iso", "start"], "kid": ["ke", "bug", "dk", "kind", "wk", "dq", "wife", "id", "seed", "da", "child", "die", "ko", "kick", "sk", " kids", "kk", "node", "pid", "key", "Kid", "ids", "quad", "ad", "sid", "ku", "du", "kt", "k", "ck", "ski", "dad", "kie", "start", "iq", "anc", "gen", "iden", "nice", "cb", "ce", "kids", "kg", "cookie", "kb", "need", "idy", "chid", "uid"], "sdev": [" spack", "tspack", "setsdevice", "ssdevice", "ssdev", "jsdiv", "sconn", "svar", "setsdev", "jsvar", "cvar", "sdevice", "setsdiv", " sdevice", " sconn", "Sconn", " svar", "cdiv", "jsdevice", "cdevice", "jsdev", "Sdev", "cdev", "sdiv", "ssdiv", "tsdiv", "ssvar", "tsconn", "Sdiv", "tsdev", "setsvar", "Spack", " sdiv", "spack"], "pd_id": ["pdIPid", "vd_ID", "pd_kid", "vdIPdb", "pd_ids", "vd_kid", "vdIPid", "pd_sid", "pc_ids", "vd_db", "pa_len", "pdIPdb", "pd2name", "pdIPID", "paapplen", "paappid", "pd_name", "pdapplen", "pc_sid", "vd_id", "pc_name", "pd_len", "pdappids", "pd2ids", "pd2sid", "pc_id", "pd2id", "pdIPkid", "pa_id", "pdappid", "paappids", "pd_db", "pa_ids", "pd_ID", "vdIPkid", "vdIPID"], "num_pd_disks": ["num_pd_duck", "num_pdvsdk", "num_pd_freps", "num_pd_hardps", "num_pd_DISck", "num_pd2disck", "num_pd_disps", "num_pd_duds", "num_pd_disk", "num_pdvdisk", "num_pd2disds", "num_pdvsdps", "num_pd_disck", "num_pd_sdk", "num_pd_hardk", "num_pd_deks", "num_pd2DISks", "num_pdvdevck", "num_pd2DIScs", "num_pdvsdke", "num_pd_freke", "num_pd_dups", "num_pdvdevks", "num_pdvdevq", "num_pd_DISds", "num_pdvdisck", "num_pd2disks", "num_pd_devps", "num_pd_sdps", "num_pd_disds", "num_pd_freks", "num_pdvdisq", "num_pd_frek", "num_pd_devck", "num_pd_DISks", "num_pd_duq", "num_pd_freq", "num_pd_decs", "num_pd_ducs", "num_pd_devq", "num_pd_deds", "num_pd_sdke", "num_pd_devks", "num_pd_diske", "num_pd_hardks", "num_pdvdisps", "num_pd_DIScs", "num_pd2DISds", "num_pd_sdks", "num_pd_hardke", "num_pd_deck", "num_pd_disq", "num_pd2DISck", "num_pd2discs", "num_pdvdevps", "num_pd_duks", "num_pdvdisks", "num_pd_freck", "num_pdvsdks", "num_pdvdiske", "num_pd_discs"]}}
{"project": "FFmpeg", "commit_id": "f4aaf987a588fcf5978e636edf2193df35b3e83b", "target": 1, "func": "int ff_thread_video_encode_frame(AVCodecContext *avctx, AVPacket *pkt, const AVFrame *frame, int *got_packet_ptr){\n\n    ThreadContext *c = avctx->internal->frame_thread_encoder;\n\n    Task task;\n\n    int ret;\n\n\n\n    av_assert1(!*got_packet_ptr);\n\n\n\n    if(frame){\n\n        if(!(avctx->flags & CODEC_FLAG_INPUT_PRESERVED)){\n\n            AVFrame *new = avcodec_alloc_frame();\n\n            if(!new)\n\n                return AVERROR(ENOMEM);\n\n            pthread_mutex_lock(&c->buffer_mutex);\n\n            ret = c->parent_avctx->get_buffer(c->parent_avctx, new);\n\n            pthread_mutex_unlock(&c->buffer_mutex);\n\n            if(ret<0)\n\n                return ret;\n\n            new->pts = frame->pts;\n\n            new->quality = frame->quality;\n\n            new->pict_type = frame->pict_type;\n\n            av_image_copy(new->data, new->linesize, (const uint8_t **)frame->data, frame->linesize,\n\n                          avctx->pix_fmt, avctx->width, avctx->height);\n\n            frame = new;\n\n        }\n\n\n\n        task.index = c->task_index;\n\n        task.indata = (void*)frame;\n\n        pthread_mutex_lock(&c->task_fifo_mutex);\n\n        av_fifo_generic_write(c->task_fifo, &task, sizeof(task), NULL);\n\n        pthread_cond_signal(&c->task_fifo_cond);\n\n        pthread_mutex_unlock(&c->task_fifo_mutex);\n\n\n\n        c->task_index = (c->task_index+1) % BUFFER_SIZE;\n\n\n\n        if(!c->finished_tasks[c->finished_task_index].outdata && (c->task_index - c->finished_task_index) % BUFFER_SIZE <= avctx->thread_count)\n\n            return 0;\n\n    }\n\n\n\n    if(c->task_index == c->finished_task_index)\n\n        return 0;\n\n\n\n    pthread_mutex_lock(&c->finished_task_mutex);\n\n    while (!c->finished_tasks[c->finished_task_index].outdata) {\n\n        pthread_cond_wait(&c->finished_task_cond, &c->finished_task_mutex);\n\n    }\n\n    task = c->finished_tasks[c->finished_task_index];\n\n    *pkt = *(AVPacket*)(task.outdata);\n\n    av_freep(&c->finished_tasks[c->finished_task_index].outdata);\n\n    c->finished_task_index = (c->finished_task_index+1) % BUFFER_SIZE;\n\n    pthread_mutex_unlock(&c->finished_task_mutex);\n\n\n\n    *got_packet_ptr = 1;\n\n\n\n    return task.return_code;\n\n}\n", "idx": 16135, "substitutes": {"avctx": ["AVconfig", "afconn", "Avcontext", "avecmd", "afkb", "AVcmp", "Avctx", "ajcontext", "avcmp", "afcb", "AVkb", "navcmd", "AVcontext", "akcb", "avectx", "averctl", "akloc", "averlib", "navctx", "aflib", "AVcci", "afcmp", "AVconn", "averctx", "afconfig", "afcontext", "ajctx", "avelib", "Avcb", "avecci", "avcmd", " avkb", "navconfig", "avectl", "aveconfig", "avkb", "avecmp", "afloc", "Avloc", "avcontext", "avcb", "akctx", "avconn", "aveconn", " avcontext", "avloc", "ajcci", "ajcmp", "afctx", "afcmd", "afctl", "avcci", "AVctx", "avecontext", "navcontext", " avconn", "avconfig", "avctl", "avlib", "akcontext", "avercontext"], "pkt": ["pct", "Pqt", "pqt", "pdu", "Pdu", "Pkt", " pdu", "opdu", " pct", " pqt", "opqt", "Pct", "opkt", "opct"], "frame": ["remote", "shape", "motion", "image", "event", "module", "model", "fp", "force", "rame", "obj", "base", "old", "bf", "flow", "frames", "line", "cb", "cycle", "window", "message", "draw", "call", "m", "part", "slice", "session", "parse", "fake", "fi", "data", "create", "function", "thread", "Frame", "fram", "config", "iframe", "fb", "style", "connection", "source", "game", "buffer", "update", "live", "scope", "element", "document", "view", "e", "info", "f", "none", "point", "cfg", "feature", "state", "fe", "block", "cf", "video", "node", "channel", "up", "object", "position", "zone", "p", "time", "parent", "definition", "setup", "next", "now", "file", "target", "coll", "figure", "callback"], "got_packet_ptr": ["got_packet_thread", "got_packet64handle", "got_packet__thread", "got_packet__addr", "got_packacket_pointer", "got_packet_addr", "got_packet__ptr", "got_packet__pointer", "got_packet_tr", "got_packet_handle", "got_packacket_handle", "got_packacket_thread", "got_packet64pointer", "got_packet64ptr", "got_packacket_ptr", "got_packet_pointer", "got_packet64tr", "got_packacket_addr", "got_packacket_tr"], "c": ["call", "m", "ch", "mc", "cm", "uc", "bc", "d", "t", "ca", "course", "rc", "cc", "l", "pc", "i", "container", "config", "C", "lc", "cs", "ctrl", "g", "ci", "h", "cn", "this", "cy", "con", "ct", "v", "conf", "conn", "cr", "w", "u", "oc", "p", "e", "s", "rec", "nc", "k", "b", "can", "co", "tc", "n", "f", "arc", "cat", "dc", "cu", "ac", "sc", "ce", "cf", "ic", "coll", "icc", "cp", "center", "vc", "cache", "exec", "ec", "r", "cur", "fc", "cl", "ctx"], "task": ["channel", "func", "device", "transfer", "proc", "remote", "piece", "tx", "course", "complete", "service", "t", "sync", "queue", "batch", "config", "worker", "object", "container", "nn", "child", "manager", "test", "image", "event", "project", "module", "game", "kk", "session", "error", "master", "job", "key", "patch", "slave", "table", "layer", "Task", "instance", "resource", "pack", "data", "tc", "ask", "result", "parent", "next", "block", "tf", "target", "process", "ack", "exec", "empty", "class", "work", "tag", "thread", "node", "message"], "ret": ["alt", "ft", "en", "rev", "part", "reply", "_", "art", "rc", "val", "code", "back", "rets", "gt", "fun", "sr", "ref", "det", "lit", "error", "br", "mt", "mem", "fin", "rb", "success", "data", "Ret", "bf", "result", " RET", "att", "url", " Ret", "file", "nt", "re", "out", "rt", "fail", "resp", "rot", "RET", "al", "res", "num", "reg", "flag", "run", "len", "bit", "replace"], "new": ["word", "remote", "child", "msg", "image", "other", "raw", "box", "old", "make", "ec", "copy", "message", "func", "m", "self", "d", "array", "or", "g", "missing", "to", "full", "unknown", "client", "w", "resource", "data", "create", "gen", " New", "r", "mac", "another", "el", "small", "and", "extra", "again", "current", "large", "unique", "null", "game", "update", "valid", "New", "package", "e", "found", "j", "f", "add", "inc", "block", "first", "more", "fresh", "node", "replace", "root", "existing", "l", "ew", "news", "name", "this", "user", "later", "v", "same", "NEW", "p", "n", "next", "now", "one", "content", "join"]}}
{"project": "qemu", "commit_id": "fa3aad24d94a6cf894db52d83f72a399324a17bb", "target": 0, "func": "int vmstate_load_state(QEMUFile *f, const VMStateDescription *vmsd,\n\n                       void *opaque, int version_id)\n\n{\n\n    VMStateField *field = vmsd->fields;\n\n\n\n    if (version_id > vmsd->version_id) {\n\n        return -EINVAL;\n\n    }\n\n    if (version_id < vmsd->minimum_version_id_old) {\n\n        return -EINVAL;\n\n    }\n\n    if  (version_id < vmsd->minimum_version_id) {\n\n        return vmsd->load_state_old(f, opaque, version_id);\n\n    }\n\n    while(field->name) {\n\n        if (field->version_id <= version_id) {\n\n            void *base_addr = opaque + field->offset;\n\n            int ret, i, n_elems = 1;\n\n\n\n            if (field->flags & VMS_ARRAY) {\n\n                n_elems = field->num;\n\n            } else if (field->flags & VMS_VARRAY) {\n\n                n_elems = *(size_t *)(opaque+field->num_offset);\n\n            }\n\n            if (field->flags & VMS_POINTER) {\n\n                base_addr = *(void **)base_addr;\n\n            }\n\n            for (i = 0; i < n_elems; i++) {\n\n                void *addr = base_addr + field->size * i;\n\n\n\n                if (field->flags & VMS_STRUCT) {\n\n                    ret = vmstate_load_state(f, field->vmsd, addr, version_id);\n\n                } else {\n\n                    ret = field->info->get(f, addr, field->size);\n\n\n\n                }\n\n                if (ret < 0) {\n\n                    return ret;\n\n                }\n\n            }\n\n        }\n\n        field++;\n\n    }\n\n    if (vmsd->run_after_load)\n\n        return vmsd->run_after_load(opaque);\n\n    return 0;\n\n}\n", "idx": 16147, "substitutes": {"f": ["func", "m", "ff", "self", "fd", "elf", "d", "fs", "l", "inf", "fb", "framework", "uf", "fm", "g", "h", "fx", "this", "fo", "fp", "fn", "v", "raf", "fr", "buff", "conf", "form", "o", "F", "p", "e", "info", "handler", "fed", "b", "af", "sf", "lf", "fe", "c", "df", "feed", "tf", "file", "xf", "cf", "fen", "rf", "fc", "fa"], "vmsd": ["envmsds", " vamsdm", "fmsdn", "fcsds", " vmsdm", "ventsd", "vmsdal", " vmsdd", " vmsde", "vmasd", "vnsdal", "svmsdc", " vMSds", "vamsdm", "vmmd", "vopsdy", "vpsdos", "vicsdt", "vmssd", "vmasdy", "vMSdy", "vamsd", "vmsde", "vmesp", "vmsdn", " vMSdy", "vmesds", "vmesdo", " vamsdd", "svatsdal", " vmpp", "ventsds", "vmsD", "envmsd", " vMSdt", "vamsdo", " vamsdt", "vvsbd", "vmesD", "svatsds", "vMSds", "vcsdy", "fpsz", "vmsdc", "vatsdc", "vopsbd", "fmsdy", "fmsds", "vssdc", " vmsdc", " vamscd", " vmesde", "envmssd", "varmsdo", "vomsd", "vcsdc", "vopsd", " vmsD", "vmpd", "vvsd", "vcsdal", "enventsds", "vicsd", " vmpds", "vMSdt", " vmesD", "vpsd", "vomsdt", "vpsz", "vMSde", "vopsdn", "fcsd", "vamsdd", "vmsdos", "fcsdn", "vamsdt", " vmsdo", "svatsd", "varmsdy", "enventssd", "vMSd", "vmpdc", " vMSd", "vmsdt", " vmesd", "vatsd", "svmsdal", "vcsdn", "vmsds", " vmsds", "vcsde", "vicsdm", "vmmds", "vmsdb", "vvsz", "vmsdd", "vssds", "varmscd", "vvsds", "vopsz", "vmmsd", " vmsdb", "vnsd", "envmsdos", "varmsdn", "vmpp", "vmscd", " vmscd", "vssdt", "vopsds", "vatsdal", "varmsds", "vmescd", "fpsd", "fpsds", "vpsds", "ventssd", "ventsdos", "vssdy", "fcsdy", "enventsdos", " vmsdy", "vnsds", "vcsds", "svmsds", "vatsds", "svatsdc", "vpssd", "vmsdm", "vcsd", "vmesd", "enventsd", "vmmdos", "vmesdb", "vicsdd", " vamsd", "vmesde", "vamsdb", " vmsdt", "vMSD", "vmpds", "vmsz", "vssp", "svmsd", "vamscd", "fmsd", " vmpdc", "vmasdt", "vnsdc", " vamsdo", "vmasds", "varmsdb", "vssd", " vmsp", "vcsD", "fmsbd", " vamsdb", "vmsbd", "fmsz", "fpsbd", "vpsbd", "vmsdo", "vmesdc", " vmpd", " vmesds", "vmsdy", "varmsd", "vmsp", "vomsdm", "vomsdd"], "opaque": ["ospacity", "copacity", "paque", "copica", "pula", "oppacity", "pac", "opsacity", "opsaques", "opsane", "oponymous", "oppula", "copane", "ipque", "opac", "operacity", "opane", "oppaque", "opaques", "ospacle", "opsaque", "operaque", "operacle", "copaques", "ipac", "ipacity", "operica", "opacity", "ipaque", "operque", " opac", "iopaque", "operonymous", "ospaque", "osponymous", "ioponymous", "iopacity", " opque", "copaque", "oppac", "opque", " opacity", "iopane", "iopaques", "iopacle", "opula", "operula", "opacle", "pacity", "operac", " opica", "copque", "opica"], "version_id": ["version_Id", "install_id", " version_count", "version_offset", "package_kind", "version_uid", "package_info", "versioningid", "install_ids", "version0name", " version_offset", "version_ids", "version_sid", "creation_ID", "versionxids", " version_sid", "instanceingvid", "version_ident", "creation_id", "ver_id", "version0id", "version_ide", "ver_name", "versionxid", "version11vid", "version_type", "version0ID", " version_size", "versioninglike", "version11like", "version_kind", "version0ids", "version0kind", "versioningis", "versioningsid", " version_name", "versionxoffset", "version_like", "version11is", " version_Id", "version_is", "version_ID", " version_ids", "version11id", "versionxsize", "instanceingid", "version_count", "instance_vid", "package_id", "version0info", "version_info", "install_uid", "version0ident", "instanceinglike", "creation_ident", "versioningId", "instanceingis", "versioningvid", "install_ide", "package_name", "creation_ids", "instance_like", "instance_is", "version_name", "version_vid", "ver_ids", "version_size", "instance_id", " version_i", "ver_type", "versioningi", "version_i"], "field": ["word", "child", "label", "event", "module", "method", "model", "force", "handler", "box", "list", "line", "end", "cell", "off", "window", "index", "message", "wire", "slice", "lc", "manager", "comment", "key", "error", "fix", "group", "Field", "data", "entry", "number", "function", "um", "flag", "condition", "after", "service", "ield", "and", "style", "section", "option", "ref", "machine", "member", "package", "value", "element", "term", "layer", "document", "lf", "feature", "holder", "diff", "block", "type", "loop", "load", "man", "FIELD", "post", "record", "player", "object", "back", "name", "row", "er", "form", "open", "plugin", "match", "attribute", "file", "rule"], "base_addr": [" base_pos", "base_pos", " base_url", "base_url", "base_point", " base_address", " base_offset", " base_name", "base_ptr", " base_coord", " base_ptr", "base_address", "base_offset", "base_name", "base_coord", " base_point"], "ret": [" fun", "alt", "pet", "en", "ft", "rev", "reply", "rc", "val", "back", "def", "rets", "fun", " def", "str", "ref", "arg", "det", "lit", "error", " reply", "job", "value", " arg", "feat", "obj", "mem", "fi", "info", "match", "success", "data", "Ret", "count", "bf", "result", " RET", "att", "url", "red", "cat", "end", " result", "nt", " success", "re", "rt", "get", "r", "rep", "et", "pat", "RET", "res", "reg", "num", "flag", "len", "bit", "err"], "i": ["hi", "qi", "it", "ui", "I", "ni", "ai", "xi", "id", "ini", "inf", "gi", "iu", "l", "ci", "ig", "di", "x", "arg", "si", "ie", "ii", "key", "v", "uri", "u", "ind", "z", "p", "e", "ib", "info", "fi", "mi", "li", "k", "ix", "b", "multi", "j", "phi", "ti", "ip", "c", "eni", "pi", "r", "ri", "ami", "zi", "abi", "index", "start"], "addr": ["ord", "area", "osi", "pkg", "part", "slice", "amp", "amd", "rc", "id", "align", "x", "ref", "ace", "loc", " address", "uri", "ad", "adr", "layer", "p", "la", "rx", "pointer", "ix", "result", "address", "ip", "url", "route", "arr", "afi", "offset", "r", "host", "ar", "work", "dr", "hop", "prefix", "coord", "pad", "alias", "pos", "ptr", "index"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_setcond2(TCGContext *s, TCGCond cond, TCGReg ret,\n\n                             TCGReg al, TCGReg ah, TCGReg bl, TCGReg bh)\n\n{\n\n    TCGReg tmp0 = TCG_TMP0;\n\n    TCGReg tmp1 = ret;\n\n\n\n    assert(ret != TCG_TMP0);\n\n    if (ret == ah || ret == bh) {\n\n        assert(ret != TCG_TMP1);\n\n        tmp1 = TCG_TMP1;\n\n    }\n\n\n\n    switch (cond) {\n\n    case TCG_COND_EQ:\n\n    case TCG_COND_NE:\n\n        tmp1 = tcg_out_reduce_eq2(s, tmp0, tmp1, al, ah, bl, bh);\n\n        tcg_out_setcond(s, cond, ret, tmp1, TCG_REG_ZERO);\n\n        break;\n\n\n\n    default:\n\n        tcg_out_setcond(s, TCG_COND_EQ, tmp0, ah, bh);\n\n        tcg_out_setcond(s, tcg_unsigned_cond(cond), tmp1, al, bl);\n\n        tcg_out_opc_reg(s, OPC_AND, tmp1, tmp1, tmp0);\n\n        tcg_out_setcond(s, tcg_high_cond(cond), tmp0, ah, bh);\n\n        tcg_out_opc_reg(s, OPC_OR, ret, tmp1, tmp0);\n\n        break;\n\n    }\n\n}\n", "idx": 16155, "substitutes": {"s": ["south", "sys", "ses", "m", "self", "bis", "service", "t", "sync", "sg", "native", "d", "l", "private", "sym", "rs", "sup", "g", "S", "hs", "os", "sets", "js", "si", "scope", "sq", "es", "session", "secure", "server", "ss", "u", "p", "e", "groups", "se", "ions", "http", "site", "b", "sf", "sb", "f", "gs", "spec", "c", "ns", "setup", "xs", "ssl", "side", "sv", "states", "services", "r", "ds", "su", "sing", "y", "ctx"], "cond": ["condition", "day", "bc", "fd", "Cond", "config", "val", "code", "lic", "pre", "lc", "fun", "act", "fact", "null", "ref", "unit", "cmp", "det", "con", "eff", "ct", "fn", "pred", "loc", "conf", "col", "obj", "term", "sign", "sec", "desc", "comp", "cho", "co", "rol", "diff", "crit", "reason", "type", "cb", "cas", "change", "cont", "cmd", "comb", "ic", "fail", "resp", "cell", "ound", "no", "reg", "pos", "prop", "rupt", "fc", "contin", "red", "cl"], "ret": ["pet", "alt", "ft", "rev", "ru", "reply", "tr", "rc", "id", "val", "back", "alg", "cache", "def", "rets", "fun", "py", "final", "sr", "ref", "pret", "arg", "det", "lit", "alf", "sil", "flag", "obj", "mt", "ben", "mem", "active", "ib", "fi", "fin", "success", "match", "ext", "sb", "Ret", "result", "ort", "att", "red", "ry", "ne", "re", "hard", "rt", "ert", "r", "repl", "rep", "pat", "RET", "seq", "res", "reg", "rel", "cur", "resp", "len", "rem", "sel", "bit"], "al": ["alt", "en", "nl", "ai", "ale", "pal", "l", "val", "ia", "mal", "a", "Al", "ap", "hal", "ali", "alf", "ral", "AL", "ul", "ill", "alist", "ad", "eal", "ll", "p", "ag", "pl", "ail", "af", "b", "bal", "f", "au", "ab", "ay", "am", "il", "ial", "ell", "isal", "eb", "fal", "all", "als", "sl", "sh", "ae", "ar", "rel", "el", "bel", "gal", "alog"], "ah": ["area", "nah", "en", "ch", "ff", "aj", "ha", "ak", "oh", "ih", "ai", "ach", "jp", "a", "cz", "ey", "ig", "h", "ref", "gh", "abc", "ap", "loc", "aph", "adh", "rh", "br", "av", "uh", "z", "la", "ee", "p", "ib", "ang", "anch", "arch", "ag", "eh", "af", "au", "ab", "ay", "am", "c", "lah", "eth", "eb", "q", "cf", "az", "sl", "yah", "sh", "ae", "ev", "sa", "ec", "ahi", "ar", "el", "ph", "ef"], "bl": ["ch", "hl", "nl", "fl", "bs", "val", "l", "bd", "ub", "ref", "ld", "br", "mb", "Ub", "ill", "z", "ll", "ba", "p", "ib", "bm", "pl", "li", "sb", "b", "af", "BL", "bf", "lf", "Bl", "ab", "amb", "il", "lab", "bg", "eb", "sl", "sh", "db", "lam", "lb", "el", "cl"], "bh": ["bt", "nah", "ch", "hl", "bc", "nl", "oh", "ih", "ob", "ha", "bs", "fl", "l", "bb", "bah", "h", "nb", "ref", "gh", "sq", "bj", "aph", "loc", "adh", "rh", "kh", "br", "uh", "hh", "p", "ib", "rb", "pb", "pl", "b", "sb", "bf", "ab", "amb", "ph", "cb", "lab", "ht", "eb", "bg", "yah", "deb", "sl", "zh", "bi", "sh", "db", "lb", "cl"]}}
{"project": "qemu", "commit_id": "28f4a7083dcca084243e313ab18fcdb20d60334e", "target": 0, "func": "static void display_mouse_define(DisplayChangeListener *dcl,\n\n                                 QEMUCursor *c)\n\n{\n\n    SimpleSpiceDisplay *ssd = container_of(dcl, SimpleSpiceDisplay, dcl);\n\n\n\n    qemu_mutex_lock(&ssd->lock);\n\n    if (c) {\n\n        cursor_get(c);\n\n    }\n\n    cursor_put(ssd->cursor);\n\n    ssd->cursor = c;\n\n    ssd->hot_x = c->hot_x;\n\n    ssd->hot_y = c->hot_y;\n\n    g_free(ssd->ptr_move);\n\n    ssd->ptr_move = NULL;\n\n    g_free(ssd->ptr_define);\n\n    ssd->ptr_define = qemu_spice_create_cursor_update(ssd, c, 0);\n\n    qemu_mutex_unlock(&ssd->lock);\n\n}\n", "idx": 16163, "substitutes": {"dcl": ["dll", "ndacl", "ldCL", "ndll", "sdcc", "Dacl", "ldcl", "pdcc", "dcc", " dcel", "ldacl", "DCL", "dCL", "Dcl", "ndCL", "pdll", "sdll", "pdCL", "pdcl", "dcel", " dacl", " dll", "dacl", " dcc", "Dll", "ndcl", "ldcel", "sdcl", "sdCL", " dCL"], "c": ["m", "ch", "mc", "cm", "d", "t", "enc", "ca", "unc", "cc", "l", "i", "pc", "C", "lc", "ci", "cs", "g", "x", "cy", "con", "ct", "loc", "v", "chain", "cr", "o", "client", "w", "col", "u", "oc", "p", "e", "s", "nc", "k", "pointer", "b", "cus", "n", "f", "cu", "dc", "ac", "anc", "ce", "cf", "ic", "coll", "r", "cp", "vc", "cache", "ec", "cur", "fc", "cl", "ctx"], "ssd": ["msdn", "csss", "ssdb", "cusd", "essdb", "issd", "essdc", "psl", "hesssd", "SSds", "cssdc", "rssds", "psdc", "cssds", "ussds", "ssds", "ssdc", "cssdl", "rssd", "nsdc", "amsds", "wsds", "arsd", "essdk", "cssd", "cusdl", "cusdc", "SSsd", "ssdl", "csssd", "tsdl", "hesshd", "essdl", "sshd", "ussdl", "esssd", "rssl", "psds", "issdc", "arsdc", "cssdk", "SSd", "msdc", "amsdad", "ssdn", "cssdad", "issds", "nsds", "hessd", " ssds", "msd", "hessds", "wsd", "rssdc", "sssd", "hessl", "ssad", "essdn", "sss", "psdl", "cssad", "wsdc", "cssdn", "tsd", "ssdad", "arsdl", "rssdl", "nss", "nsd", "essds", "cssl", "amss", "essl", "tsad", "cusds", "msds", "amsd", "wsdk", "arsds", "cssdb", "ssdk", "osss", "rsss", "psd", "ussd", "essd", " sshd", " sssd", "tsds", "ossds", "ssl", "SShd", "issdb", "ossd", "ossdad", "ussad"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline void stw_phys_internal(hwaddr addr, uint32_t val,\n\n                                     enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!memory_region_is_ram(section->mr) || section->readonly) {\n\n        addr = memory_region_section_addr(section, addr);\n\n        if (memory_region_is_ram(section->mr)) {\n\n            section = &phys_sections[phys_section_rom];\n\n        }\n\n#if defined(TARGET_WORDS_BIGENDIAN)\n\n        if (endian == DEVICE_LITTLE_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#else\n\n        if (endian == DEVICE_BIG_ENDIAN) {\n\n            val = bswap16(val);\n\n        }\n\n#endif\n\n        io_mem_write(section->mr, addr, val, 2);\n\n    } else {\n\n        unsigned long addr1;\n\n        addr1 = (memory_region_get_ram_addr(section->mr) & TARGET_PAGE_MASK)\n\n            + memory_region_section_addr(section, addr);\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr(addr1);\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            stw_le_p(ptr, val);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            stw_be_p(ptr, val);\n\n            break;\n\n        default:\n\n            stw_p(ptr, val);\n\n            break;\n\n        }\n\n        invalidate_and_set_dirty(addr1, 2);\n\n    }\n\n}\n", "idx": 16164, "substitutes": {"addr": ["ord", "rr", "vr", "tx", "amp", "arm", "rc", "config", "amd", "code", "id", "nn", "name", "align", "x", "ref", "module", "ace", "ld", "loc", "v", "access", "ad", "adr", "mt", "mr", "layer", "ctx", "size", "ind", "pointer", "data", "ext", "mode", "point", "ann", "add", "address", "rm", "pair", "url", "at", "route", "arr", "nm", "offset", "attr", "md", "rt", "r", "dd", "host", "src", "work", "dr", "pos", "nr", "usr", "pad", "ar", "len", "hop", "coord", "node", "index"], "val": ["alt", "ret", "tx", "part", "slot", "slice", "fl", "pal", "pc", "pt", "pre", "cond", "VAL", "eval", "test", "py", "null", "x", "ref", "unit", "arg", "vol", "update", "lit", "loc", "valid", "v", "value", "key", "pid", "cr", "ind", "mem", "p", "data", "base", "count", "fe", "ol", "arr", "all", "elt", "sl", "ival", "aval", "Val", "cal", "fee", "seq", "rot", "al", "pos", "sel", "el", "bl", "len", "vals"], "endian": [" endendor", " endians", "endednic", "ndian", "endnic", "ndIAN", "enian", "endedians", "endendor", "ndorian", "enien", "entrian", " endorian", " endrian", "Endiant", "endedian", "endIAN", "endedorian", "enIAN", "endiant", "eniant", "endedrian", "engric", "startrian", "endedIAN", "endrian", "endien", " endIAN", "ndians", " endric", "engian", "startnic", "engrian", "Endian", "Endien", "startian", "endric", " endnic", "endediant", "endians", "EndIAN", "engendor", "endorian", "startIAN", "endedien", "entric", "entendor", "entian"], "ptr": ["plug", "port", "tx", "slice", "trace", "fd", "slot", "tr", "mount", "code", "pc", "pt", "ctr", "td", "eval", "py", "str", "ace", "vol", "lit", "loc", "v", "br", "grad", "adr", "ind", "p", "ctx", "pad", "fi", "pl", "pointer", "data", "buf", "nil", "inst", "length", "point", "address", "pair", "arr", "pe", "type", "offset", "attr", "eth", "rt", "Val", "Ptr", "pr", "src", "dr", "pos", "dim", "rot", "index"], "section": ["area", "child", "module", "loc", "server", "sections", "sc", "sl", "sub", "division", "index", "vision", "part", "slice", "array", "rc", "ECTION", "lc", "ment", "comment", "script", "session", "storage", "lib", "sector", "group", "version", "socket", "data", "ext", "entry", "pe", "ion", "function", "layout", "sa", "core", "Section", "small", "service", "config", "account", "connection", "large", "description", "option", "ie", "character", "fat", "member", "package", "element", "sec", "site", "address", "feature", "sel", "channel", "sect", "shadow", "row", "job", "patch", "region", "setting", "plugin", "se", "component", "parent", "pair", "journal", "environment"], "addr1": ["dr2", "ampone", "addrone", "addressone", "val1", "arm9", "address1", "align1", " addr0", "addr0", "arm1", "addr2", "aceone", "ptr2", "ptrone", "addr9", "amp1", "address2", "ptr1", "ace2", "address0", "addr6", "adr6", "ace0", "dr0", "align0", "align2", "adr1", "ace1", " addr2", "drone", "arm6", "ptr0", " addrone", "address9", "adr9", "alignone", "address6", "valone", "dr1"]}}
{"project": "FFmpeg", "commit_id": "afa982fdae1b49a8aee00a27da876bba10ba1073", "target": 1, "func": "static void compute_scale_factors(unsigned char scale_code[SBLIMIT],\n\n                                  unsigned char scale_factors[SBLIMIT][3], \n\n                                  int sb_samples[3][12][SBLIMIT],\n\n                                  int sblimit)\n\n{\n\n    int *p, vmax, v, n, i, j, k, code;\n\n    int index, d1, d2;\n\n    unsigned char *sf = &scale_factors[0][0];\n\n    \n\n    for(j=0;j<sblimit;j++) {\n\n        for(i=0;i<3;i++) {\n\n            /* find the max absolute value */\n\n            p = &sb_samples[i][0][j];\n\n            vmax = abs(*p);\n\n            for(k=1;k<12;k++) {\n\n                p += SBLIMIT;\n\n                v = abs(*p);\n\n                if (v > vmax)\n\n                    vmax = v;\n\n            }\n\n            /* compute the scale factor index using log 2 computations */\n\n            if (vmax > 0) {\n\n                n = av_log2(vmax);\n\n                /* n is the position of the MSB of vmax. now \n\n                   use at most 2 compares to find the index */\n\n                index = (21 - n) * 3 - 3;\n\n                if (index >= 0) {\n\n                    while (vmax <= scale_factor_table[index+1])\n\n                        index++;\n\n                } else {\n\n                    index = 0; /* very unlikely case of overflow */\n\n                }\n\n            } else {\n\n                index = 63;\n\n            }\n\n            \n\n#if 0\n\n            printf(\"%2d:%d in=%x %x %d\\n\", \n\n                   j, i, vmax, scale_factor_table[index], index);\n\n#endif\n\n            /* store the scale factor */\n\n            assert(index >=0 && index <= 63);\n\n            sf[i] = index;\n\n        }\n\n\n\n        /* compute the transmission factor : look if the scale factors\n\n           are close enough to each other */\n\n        d1 = scale_diff_table[sf[0] - sf[1] + 64];\n\n        d2 = scale_diff_table[sf[1] - sf[2] + 64];\n\n        \n\n        /* handle the 25 cases */\n\n        switch(d1 * 5 + d2) {\n\n        case 0*5+0:\n\n        case 0*5+4:\n\n        case 3*5+4:\n\n        case 4*5+0:\n\n        case 4*5+4:\n\n            code = 0;\n\n            break;\n\n        case 0*5+1:\n\n        case 0*5+2:\n\n        case 4*5+1:\n\n        case 4*5+2:\n\n            code = 3;\n\n            sf[2] = sf[1];\n\n            break;\n\n        case 0*5+3:\n\n        case 4*5+3:\n\n            code = 3;\n\n            sf[1] = sf[2];\n\n            break;\n\n        case 1*5+0:\n\n        case 1*5+4:\n\n        case 2*5+4:\n\n            code = 1;\n\n            sf[1] = sf[0];\n\n            break;\n\n        case 1*5+1:\n\n        case 1*5+2:\n\n        case 2*5+0:\n\n        case 2*5+1:\n\n        case 2*5+2:\n\n            code = 2;\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        case 2*5+3:\n\n        case 3*5+3:\n\n            code = 2;\n\n            sf[0] = sf[1] = sf[2];\n\n            break;\n\n        case 3*5+0:\n\n        case 3*5+1:\n\n        case 3*5+2:\n\n            code = 2;\n\n            sf[0] = sf[2] = sf[1];\n\n            break;\n\n        case 1*5+3:\n\n            code = 2;\n\n            if (sf[0] > sf[2])\n\n              sf[0] = sf[2];\n\n            sf[1] = sf[2] = sf[0];\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n        \n\n#if 0\n\n        printf(\"%d: %2d %2d %2d %d %d -> %d\\n\", j, \n\n               sf[0], sf[1], sf[2], d1, d2, code);\n\n#endif\n\n        scale_code[j] = code;\n\n        sf += 3;\n\n    }\n\n}\n", "idx": 16177, "substitutes": {"scale_code": ["scale2code", "scale2function", "scale2codes", "scale2const", " scale_const", "scale_const", "scale_function", " scale_codes", " scale_function", "scale_codes"], "scale_factors": ["scale_formors", "scale_fores", "scale_factories", "scale_formos", "scale_fors", "scale_actories", "scale_actors", "scale_for", "scale_factos", "scale_factorions", "scale_factoros", "scale_actor", "scale_factorores", "scale_formores", "scale_formions", "scale_factoror", "scale_actores", "scale_fories", "scale_factor", "scale_factores", "scale_actos", "scale_factions", "scale_factorors", "scale_factorories", "scale_actions"], "sb_samples": ["sb_namps", "sb_salls", "sb_tamps", "sb_exores", "sb_lances", "sb_scalls", "sb_lales", "sb_namples", "sb_examps", "sb_sitesalls", "sb_sitesales", "sb_examples", "sb_samps", "sb_sitesances", "sb_exipes", "sb_tipes", "sb_scances", "sb_nores", "sb_sipes", "sb_lamples", "sb_tores", "sb_sores", "sb_nipes", "sb_scales", "sb_tamples", "sb_lalls", "sb_sitesamples", "sb_sances", "sb_scamples", "sb_sales"], "sblimit": ["splIMIT", "sclimIT", "sbllimite", "sblrimit", "sclIMiter", "sbllimIT", "splimit", "sclIMit", "sclimiter", "sblrimite", "sclIMIT", "splimite", "sblIMIT", "sblimiter", "sblimsit", "sblIMited", "sclimit", "sblimsIT", "sblimsite", "sblIMiter", "splimIT", "sblimite", "sblimsited", "sblimIT", "sclimite", "sbllimit", "sblrimiter", "splIMited", "sblIMit", "sblimited", "sblIMite", "sclIMite", "splIMit", "splIMite", "sblimsiter", "sblrimIT", "splimited", "sbllimited"], "p": ["port", "m", "po", "d", "t", "pc", "jp", "l", "pt", "a", "api", "g", "sp", "h", "lp", "py", "x", "pp", "ap", "patch", "ps", "bp", "np", "w", "z", "u", "e", "y", "s", "pa", "b", "f", "point", "ip", "c", "pe", "per", "pn", "pi", "q", "r", "cp", "pr", "P", "tp"], "vmax": ["nvmin", "lvrange", "vcmad", "vvmin", "jax", "vcl", "Vax", "vax", "jc", "valrange", "nvrange", "vctotal", "vtotal", "vrange", "valmax", "vcax", "lvMax", " vax", "llast", "lcl", "lmin", "lvmax", " vc", "vmin", " vMax", "svlast", "jMax", " vlast", "lvparent", "lmax", "Vdev", "lvmin", "jmax", " vmin", "vdev", "lMax", "valparent", "valmin", " vmad", "svmax", "vMax", "vvcl", "Vc", "VMax", "jdiv", "vvMax", " vdiv", "Vdiv", "Vmax", "svMax", "jtotal", "vvmax", "jmad", "nvmax", "nvparent", "lvcl", " vdev", "vdiv", "vlast", "vvc", "vparent", "Vlast", "Vmin", "vcmax", "vmad", "svmin", " vtotal", "vvdev", "lax", "vc", "svax"], "v": ["m", "d", "t", "vv", "cv", "l", "vp", "val", "iv", "api", "g", "conv", "ve", "h", "x", "vol", "value", "vi", "tv", "av", "w", "u", "z", "ver", "vs", "b", "f", "c", "ov", "sv", "q", "va", "nv", "uv", "V", "ev", "lv", "y", "max"], "n": ["ny", "m", "en", "d", "t", "ni", "l", "N", "a", "nn", "g", "na", "cn", "nb", "x", "mn", "o", "np", "w", "u", "z", "size", "e", "ind", "net", "nc", "b", "min", "f", "c", "ns", "pn", "ng", "sn", "network", "r", "dn", "num", "len", "y", "max"], "i": ["qi", "it", "ui", "m", "I", "d", "t", "ai", "ni", "xi", "jp", "ini", "iu", "l", "id", "io", "api", "ci", "x", "di", "si", "ie", "ii", "key", "o", "yi", "u", "ind", "z", "e", "s", "mi", "li", "b", "ix", "f", "phi", "ip", "c", "eni", "ji", "pi", "r", "bi", "ik", "ori", "y", "in"], "j": ["jj", "it", "m", "d", "t", "ja", "jp", "l", "g", "h", "x", "jet", "js", "si", "ii", "key", "o", "w", "u", "z", "ind", "e", "li", "b", "f", "jo", "c", "jl", "jc", "ji", "q", "r", "J", "pos", "y", "ij", "start"], "k": ["ke", "dk", "m", "ek", "ch", "ak", "t", "id", "l", "ko", "g", "kn", "ki", "uk", "sk", "h", "x", "kk", "key", "kw", "o", "w", "z", "u", "an", "ok", "s", "b", "c", "mk", "K", "q", "r", "ik", "ph", "y", "ks"], "code": ["zip", "charge", "codes", "func", "call", "condition", "slice", "example", "cc", "id", "name", "ci", "test", "use", "unit", "sequence", "comment", "loc", "error", "key", "catch", "size", "ind", "info", "desc", "nc", "match", "data", "entry", "count", "length", "Code", "result", "xx", "line", "state", "fe", "close", "c", "pair", "end", "ne", "type", "offset", "message", "text", "change", "function", "cod", "cycle", "xxx", "content", "comb", "start"], "index": ["val", "shape", "x", "si", "loc", "ind", "old", "list", "c", "end", "ng", "offset", "iter", "num", "in", "action", "part", "slice", "d", "sync", "example", "xi", "id", "weight", "comment", "key", "error", "expression", "version", "page", "length", "number", "ion", "body", "thread", "Index", "path", "condition", "ini", "second", "style", "nn", "current", "connection", "test", "option", "original", "update", "member", "value", "output", "element", "alpha", "online", "info", "ix", "f", "none", "address", "fe", "inc", "diff", "start", "ne", "type", "loop", "see", "no", "node", "xxx", "date", "degree", "insert", "zero", "input", "search", "name", "position", "size", "match", "pointer", "network", "find"], "d1": ["j1", "cdOne", "j7", " d0", "d0", "jOne", "f2", "dOne", "t1", "f0", "cd3", "j2", "t3", "d3", "D0", "cd1", "f3", "D2", "tOne", "D1", "f7", "fOne", " d3", "f1", " d7", " dOne", "d7", "D3"], "d2": ["p2", "dtwo", "p4", "c2", "ldtwo", "pii", " dii", "ld2", "day6", " d02", "dc5", "d4", "ctwo", "daytwo", "d6", "ld82", "dc4", " d6", "d02", " d5", "dcii", "d5", "ld6", "dc2", "c02", " dtwo", "p5", "dctwo", "c4", "d82", " d4", "dc02", " d82", "dii", "day82", "day2"], "sf": ["support", "ft", "ff", "wm", "fd", "ffe", "cv", "flo", "isf", "fs", "dist", "split", "vp", "ffield", "fb", "iw", "fm", "uf", "stab", "sp", "settings", "models", "fx", "lp", "sw", "si", "sq", "fp", "fn", "fr", "eph", "hh", "prof", "fi", "pb", "sb", "sd", "bf", "f", "lf", "gb", "result", "tif", "fit", "fe", "diff", "df", "xs", "tf", "lv", "xf", "ssl", "sv", "SF", "cf", "fw", "sl", "cp", "gif", "sm", "fee", "su", "hw", "ls", "ppa", "rf", "fts", "fc", "fen", "tp", "tta", "ze", "gp"]}}
{"project": "FFmpeg", "commit_id": "b926b6282d3b9fc8115660ae013f74f4f8c06d30", "target": 0, "func": "static void opt_new_stream(const char *opt, const char *arg)\n\n{\n\n    AVFormatContext *oc;\n\n    if (nb_output_files <= 0) {\n\n        fprintf(stderr, \"At least one output file must be specified\\n\");\n\n        ffmpeg_exit(1);\n\n    }\n\n    oc = output_files[nb_output_files - 1];\n\n\n\n    if      (!strcmp(opt, \"newvideo\"   )) new_video_stream   (oc);\n\n    else if (!strcmp(opt, \"newaudio\"   )) new_audio_stream   (oc);\n\n    else if (!strcmp(opt, \"newsubtitle\")) new_subtitle_stream(oc);\n\n    else assert(0);\n\n}\n", "idx": 16183, "substitutes": {"opt": ["oper", "path", "ott", "config", "mp", "test", "optim", "option", "str", "txt", "init", "eff", "fn", "loc", "error", "o", "feat", "obj", "p", "ok", "options", "cho", "pot", "ext", "op", "ort", "ocr", "spec", "token", "crit", "cat", "type", "text", "attr", "hop", "off", "prop", "Opt", "tag", "usr", "color"], "arg": ["args", "path", "proc", "call", "enc", "config", "val", "or", "ig", "option", "loc", "lib", "obj", "parse", "doc", "ok", "ext", "op", "arc", "ax", "cat", "argument", "Arg", "ar", "tag", "prop", "alloc"], "oc": ["toc", "oid", "aco", "mc", "uc", "bc", "enc", "unc", "irc", "pc", "cc", "iv", "roc", " alloc", "auc", "acc", "abc", "og", "loc", "OC", "output", "isc", "o", "oco", "ir", "mic", "op", "ocol", "ocr", "c", "cu", "voc", "ac", "anc", "ucc", "AC", "ogg", "ic", "org", "exec", "oci", "ec", "soc", "orc", "hop", "fc", "oca", "alloc"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190, "substitutes": {"src": ["RC", "rib", "sys", "gz", "bc", "dist", "tmp", "rc", "config", "cdn", "rs", "iv", "source", "hub", "obl", "sr", "sq", "sit", "loc", "dest", "sil", "sound", "gl", "lib", "img", "rb", "sec", "ctx", "sb", "jpg", "inst", "scl", "stat", "gb", "spec", "rl", "url", "sci", "ssl", "rob", "sc", "sl", "rect", "sub", "sel", "cur", "ruby", "gal", "filename"], "ydst": ["dyst", "hdost", "hdstr", "iddST", "hdst", "ynsta", "iddstr", "ydstr", "ecdST", "hdest", "hdrest", "xdST", "eyst", "ynost", "dyost", "ynSt", "hdsta", "ecdstr", "ydost", "ydST", "iddbl", "dyrest", "ecdst", "hdSt", "xdstr", "dystr", "ydrest", "dySt", "ynst", "xdst", "ydest", "iddst", "eyest", "eyrest", "eystr", "ydsta", "xdbl", "dyest", "ydbl", "dysta", "ydSt", "ecdbl"], "udst": ["ddst", "hdost", "vdbl", "udast", "hdst", "udbl", "udost", "UDst", "hdast", "ddST", "UDbl", "udST", "hdST", "vdast", "ddost", "vdST", "vdost", "ddast", "UDost", "UDST", "ddbl"], "vdst": ["hdost", "iddST", "hdst", "udest", "udost", "hdest", "xdST", "hdset", "vdset", "udsrc", "iddsrc", "vdest", "vdsrc", "xdset", "xdest", "hdST", "iddset", "vdST", "vdost", "xdst", "hdsrc", "iddst", "iddost", "iddest"], "height": ["stroke", "Height", "d", "thin", "bottom", "level", "density", "shape", "style", "def", "h", "x", "crop", "rows", "w", "size", "images", "max", "length", "th", "padding", "resolution", "ensions", "diff", "holes", "dim", "layout", "window", "ty", "depth"], "lumStride": ["lUMStride", "lumsCride", "lumShuse", "lUMPrite", "lumsCrict", "lumstrite", "lumPride", "lUMStrite", "lUMPride", "lumstride", "lUMPr", "lumsStrict", "lumsCuse", "lumPerve", "lumSTride", "lumCrite", "lumsStrite", "lumShrite", "lumPrite", "lumCrict", "lumsCrite", "lumShride", "lumShrict", "lumsterve", "lumStr", "lumsStride", "lumSTrite", "lumsStuse", "lumStuse", "lumStrict", "lumPr", "lumSTerve", "lUMPerve", "lumCuse", "lumSterve", "lumstr", "lumSTr", "lUMStr", "lumCride", "lumStrite", "lUMSterve"], "chromStride": ["chromContrip", "romstrip", "romStipe", "chromScrip", "chromstipe", "chromScrite", "chromstrip", "chromContipe", "chromStrite", "chromstride", "chromStipe", "chromScride", "chromContrite", "romStrite", "romStrip", "chromScipe", "romstipe", "romstrite", "chromStrip", "romStride", "chromstrite", "chromContride", "romstride"], "srcStride": ["srcstrite", "srcstructure", "srcStructure", "srcEstride", "srcStrict", " srcstri", "srcBlrite", "sourceStrite", "srcSTrite", "srcSTride", " srcstride", "sourceStride", "srcSlride", "srcSlrate", "srcstride", "srcSTrict", "srcSlrict", " srcStrite", "srcStrate", " srcStructure", "sourceStrate", "sourceStrict", "srcEstrite", "srcBlructure", "srcStri", "srcSTrate", "srcBlride", "srcEstri", " srcstructure", " srcStri", "srcstri", "srcEstructure", "srcSlrite", "srcBlri", "srcStrite", " srcstrite"], "y": ["ny", "yt", "hy", "d", "ys", "t", "sky", "my", "ey", "yd", "py", "h", "x", "cy", "ym", "ye", "w", "dy", "yi", "col", "z", "yl", "ady", "p", "yr", "yo", "j", "n", "f", "yn", "oy", "c", "vy", "ay", "ry", "year", "Y", " Y", "ya", "ky", "xy", " cy", "yy", "wy", "ty", "zy", "sy"]}}
{"project": "FFmpeg", "commit_id": "80b1e1c03d26ade05b0f53d0731aa7398d4ef6f9", "target": 1, "func": "static int huf_uncompress(GetByteContext *gb,\n\n                          uint16_t *dst, int dst_size)\n\n{\n\n    int32_t src_size, im, iM;\n\n    uint32_t nBits;\n\n    uint64_t *freq;\n\n    HufDec *hdec;\n\n    int ret, i;\n\n\n\n    src_size = bytestream2_get_le32(gb);\n\n    im = bytestream2_get_le32(gb);\n\n    iM = bytestream2_get_le32(gb);\n\n    bytestream2_skip(gb, 4);\n\n    nBits = bytestream2_get_le32(gb);\n\n    if (im < 0 || im >= HUF_ENCSIZE ||\n\n        iM < 0 || iM >= HUF_ENCSIZE ||\n\n        src_size < 0)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    bytestream2_skip(gb, 4);\n\n\n\n    freq = av_calloc(HUF_ENCSIZE, sizeof(*freq));\n\n    hdec = av_calloc(HUF_DECSIZE, sizeof(*hdec));\n\n    if (!freq || !hdec) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_unpack_enc_table(gb, im, iM, freq)) < 0)\n\n        goto fail;\n\n\n\n    if (nBits > 8 * bytestream2_get_bytes_left(gb)) {\n\n        ret = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n    if ((ret = huf_build_dec_table(freq, im, iM, hdec)) < 0)\n\n        goto fail;\n\n    ret = huf_decode(freq, hdec, gb, nBits, iM, dst_size, dst);\n\n\n\nfail:\n\n    for (i = 0; i < HUF_DECSIZE; i++) {\n\n        if (hdec[i].p)\n\n            av_freep(&hdec[i].p);\n\n    }\n\n\n\n    av_free(freq);\n\n    av_free(hdec);\n\n\n\n    return ret;\n\n}\n", "idx": 16197, "substitutes": {"gb": ["ge", "gz", "cm", "bc", "sync", "rc", "pc", "gio", "bb", "binary", "gc", "gt", "g", "ko", "hub", "rg", "py", "gy", "game", "gin", "gnu", "cgi", "gru", "tm", "mb", "storage", "gd", "gm", "gg", "bm", "rb", "du", "cli", "sb", "usb", "jpg", "b", "bf", "gs", "cfg", "gam", "gram", "gom", "cb", "bg", "eb", "cod", "kb", "hd", "GB", "db", "ga", "src", "gal", "ctx", "go", "gp"], "dst": [" dsts", "sdST", " dST", "sdrest", "dsts", "pdost", "bST", "fdst", "sdsts", "dstore", "drest", "sdst", "dost", "dST", "fdsts", " drest", " dost", "pdst", "fdost", "fdstore", "pdsts", "bsts", "brest", " dstore", "bst", "pdstore"], "dst_size": ["dst_capacity", "dsc_size", "dsc_SIZE", "dst_len", "dsts_size", "dsts_len", "dsts_capacity", "dsc_name", "dst_name", "dst_SIZE"], "src_size": ["rss_size", " src_ize", " src_Size", " src_speed", "src_Size", "src_capacity", " src_capacity", "rss_ize", "src_ize", "rss_Size", "src_speed"], "im": ["sem", "m", "cm", "ru", "ai", "iu", "imm", "iv", "fm", "ci", "image", "hub", "IM", "umi", "mm", "ym", "ie", "model", "loc", "em", "ims", "Im", "aim", "sim", "imp", "size", "gm", "u", "img", "ib", "mi", "ext", "iam", "rm", "ip", "am", "pm", "om", "um", "ima", "imi", "imet", "dim", "dm", "nm", "lim", " unim"], "iM": ["iD", "siT", "siB", "oiD", "uI", "siL", "tiL", "oiM", " iMQ", "qiD", " iL", "qiM", "piM", "oiN", "uM", "uN", " iC", "siAM", "qiN", "iniP", "tiN", " iAM", "tiM", "siD", "siN", "iniN", "piN", "iC", "siM", "iniM", "iMQ", "iT", "iI", "tiT", "oM", "uMQ", " iG", "oI", "oim", "uC", "uAM", "oG", "iN", "iniB", "oD", "siP", "iL", " iT", "piC", " iD", " iB", " iP", "uB", "iP", "um", "iG", " iN", "uD", "uG", "iAM", "qiMQ", "piB", " iI", "iB"], "nBits": ["nNBats", "nDBis", " nMBats", "nFit", " nMBis", " nFitches", "nLits", " nMBits", "nLimitches", "nMBins", "nWits", "nMBITS", "nBITS", "nMBis", "nFats", "nBsats", "nBitches", "nCBits", "nLins", " nMBins", "nWats", "nCBitches", "nLimit", "nBsITS", "nNBITS", "nMBats", " nFITS", "nCBbits", "nLimbits", "nMBists", "nFitches", " nBit", " nBbits", " nFit", "nLITS", " nBis", "nWands", "nNBists", "nMBits", " nBins", "nLats", "nLands", "nBit", " nBitches", " nFbits", "nBsits", " nFits", "nBins", "nBis", "nFbits", "nBats", "nLis", " nBats", "nFits", " nFats", "nLimits", " nBITS", "nBsists", "nFands", " nMBists", "nDBins", "nNBits", "nBists", " nBists", "nWITS", "nDBits", "nBands", " nBands", "nFITS", " nFands", "nBbits", "nCBit", " nMBITS", "nDBITS"], "freq": ["freqs", "feeQ", "Freq", "speq", " frec", "frequencyque", "frequencyQ", "feeqs", "greqs", " freck", "frequencyquality", "frec", "frequencyqi", "offq", "luqs", "frequal", " frece", "Freqi", "Frequal", "frequencyce", "luck", " freque", "funque", "Fredq", "frequality", "offqs", "frece", "freQ", "feeq", "frep", "greq", "greque", " frequality", " freqs", "grequal", "Freck", "Frece", " frep", "offdq", "speqs", "fredq", "Frequality", "FreQ", "speqq", "feep", "offiq", " fredq", "freqq", "Frec", "Frep", "speiq", " freqq", "funq", "funqual", "Freque", "freque", "freck", "freqi", "Freqs", " freqi", "freiq", " freQ", "feec", "funqs", "luq", "frequencyq", " freiq", "Freiq", "Freqq"], "hdec": ["rhdec", "hmsec", "rhdecl", "hrec", "shrec", "hec", "phrec", "hydel", "hldec", "hldata", "hdes", "hldisc", "hdecl", "shdig", "fseq", "hseq", "hmdec", "ihdecl", " henc", "Hdecl", "hmdata", "hlseq", "hydiv", "bhenc", " hdiv", "hmrec", "hdig", "fdec", " hdes", " hDec", "hydecl", "shseq", " hsec", "Hrec", "bhdes", "hdesc", "hdeg", "ahdec", "wdec", "phdec", "pdisc", "shdel", " hdisc", "ahdata", "shdiv", "herdecl", "ihdata", "hdiv", "bhdec", "hlrec", "bhdecl", "Hsec", "pdesc", "HDec", "hmdecl", "shdecl", "hdisc", "fdecl", "Hdata", "pdec", "hdel", "hlenc", "phdig", "rhdata", "hdata", "hldig", "bhdata", "herdec", "ahdecl", " hdesc", "henc", " hec", " hdel", "wdeg", "wdecl", "ahseq", " hrec", "hldesc", "herdeg", "phseq", "Hseq", "hsec", "herec", "hDec", " hdecl", "fdata", "Hdec", "hldes", " hdeg", "hmDec", "ihdec", " hdata", "wec", "rhenc", "hydec", "ihrec", "shdec"], "ret": ["pet", "alt", "ft", "let", "rev", "part", "format", "reply", "id", "val", "code", "back", "def", "rets", "gt", "fun", "status", "str", "ref", "det", "arg", "lit", "valid", "feat", "obj", "ut", "mt", "mem", "bot", "info", "fi", "fin", "match", "data", "ext", "success", "Ret", "j", "result", "fit", "att", "cat", "nt", "re", "out", "rt", "rep", "resp", "db", "pat", "RET", "al", "res", "reg", "num", "flag", "len", "opt", "bit"], "i": ["ani", "qi", "it", "ui", "part", "I", "ni", "ai", "xi", "iu", "ini", "gi", "l", "oi", "io", "g", "ci", "ki", "mu", "di", "x", "si", "ie", "ii", "uri", "u", "ind", "p", "e", "mini", "fi", "info", "mi", "li", "ix", "multi", "j", "phi", "f", "ti", "ip", "eni", "pi", "chi", "bi", "ri", "ori", "ami", "zi", "y", "abi", "index"]}}
{"project": "FFmpeg", "commit_id": "b25e84b7399bd91605596b67d761d3464dbe8a6e", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203, "substitutes": {"s": ["i", "rs", "qs", "new", "js", "si", "ps", "lines", "tests", "spec", "c", "is", "sl", "tp", "in", "aws", "args", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sym", "cs", "g", "es", "full", "session", "w", "u", "b", "sf", "ns", "r", "comm", "ks", "secondary", "sys", "parts", "service", "os", "sets", "o", "ms", "e", "site", "http", "sb", "f", "less", "services", "ls", "comments", "ctx", "ses", "as", "l", "a", "sites", "S", "settings", "this", "its", "sq", "v", "conf", "ss", "p", "se", "n", "ments", "gs", "xs", "ssl", "ds", "ts", "us", "ims", "y"], "lc": ["acs", "mc", "cm", "bc", "cc", "pc", "l", "cs", "ci", "dl", "lp", "cn", "si", "loc", "ld", "conn", "lr", "kl", "cli", "nc", "sb", "tc", "cus", "lf", "acl", "gb", "c", "ns", "lu", "lv", "cb", "sc", "sl", "coll", "lex", "ls", "lb", "wl", "fc", "ln", "cl", "ctx", "LC"], "ret": ["pet", "reply", "art", "sat", "val", "def", "gt", "str", "mem", "base", "count", " RET", "att", "cat", "end", "sur", "RET", "num", "ft", "rev", "part", "rets", "arg", "det", "error", "pass", "mt", "data", "result", "try", "arr", "al", "res", "reg", "rf", "flag", "run", "red", "alt", "let", "fun", "ref", "lit", "valid", "bot", "info", "Ret", "html", "rl", "reset", "nt", "re", "rt", "rep", "no", "usr", "bit", "err", "code", "back", "pt", "py", "feat", "lt", "success", "match", "fit", " Ret", "resp", "db", "pat", "len"]}}
{"project": "qemu", "commit_id": "4ed7b2c3a78f785a1bcbe575e08c379b166723e3", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, V9fsPath *dir_path, const char *name,\n\n                       int flags, FsCred *credp, V9fsFidOpenState *fs)\n\n{\n\n    char *path;\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n    V9fsString fullname;\n\n    char *buffer;\n\n\n\n    /*\n\n     * Mark all the open to not follow symlinks\n\n     */\n\n    flags |= O_NOFOLLOW;\n\n\n\n    v9fs_string_init(&fullname);\n\n    v9fs_string_sprintf(&fullname, \"%s/%s\", dir_path->data, name);\n\n    path = fullname.data;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(buffer, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set client credentials in .virtfs_metadata directory files */\n\n        err = local_set_mapped_file_attr(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if ((fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n               (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        buffer = rpath(fs_ctx, path);\n\n        fd = open(buffer, flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            g_free(buffer);\n\n            err = fd;\n\n            goto out;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    err = fd;\n\n    fs->fd = fd;\n\n    goto out;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(buffer);\n\n    errno = serrno;\n\n    g_free(buffer);\n\nout:\n\n    v9fs_string_free(&fullname);\n\n    return err;\n\n}\n", "idx": 16204, "substitutes": {"fs_ctx": ["fs__ctx", "fsdefctx", "fs32ctx", "fs_spec", "fs__gz", "fs_xc", "fs_lc", "FS_conn", "fs32cm", "vs_wcs", "flows_ctx", "fsMsci", "fs_cms", "fs_loc", "ds_tx", "irs_ctx", "fsdefconn", "FS_spec", "flows_xc", "sfMctx", "fs_anc", "sf_ctx", "fs_cu", "fs_wcs", "fs__anc", "ds_gz", "fs32tx", "fsMctx", "ds_ctx", "irs__anc", "fsvalspec", "FS_context", "sf_ctrl", "vs_local", "sfMsci", "fsvalcm", "vs_loc", "fs_context", "sf_cu", "fsdefcu", "flows_cm", "fsMwcs", "sfdefctrl", "fs___conn", "irs__ctx", "fsdefctrl", "fsvalcontext", "fs_sci", "fs_conn", "irs_anc", "sfdefcu", "fs__lc", "fsMloc", "fsMscope", "fsMlocal", "fsMlc", "fs_gz", "fs_local", "fs_tx", "fs32xc", "fs___ctrl", "sf_lc", "sfdefctx", "sfMscope", "fs__tx", "flows_tx", "FS_cm", "irs__conn", "sf_conn", "sf_scope", "vs_ctx", "irs_lc", "fs_scope", "sfdefconn", "sfMlc", "fs__cms", "FS_tx", "fs_cm", "fs_ctrl", "fs___ctx", "sf_sci", "irs__lc", "FS_ctx", "irs_conn", "ds_cms", "fs__conn", "fs___cu", "fsvalctx"], "dir_path": [" dir_fn", " dir_pointer", "dirallpath", "dirallctx", "dir_ctx", "dir_fn", " dir_ctx", " dir_name", " dir_context", "dirallcontext", "dir_name", "dir_pointer", "dir_context", "dirallfn"], "name": ["word", "part", "id", "home", "image", "x", "comment", "key", "Name", "NAME", "names", "size", "time", "info", "data", "ext", "base", "ix", "length", "n", "f", "parent", "url", "block", "type", "file", "host", " prefix", "content", "prefix", "space", "alias", "filename"], "flags": ["types", "args", "parts", "FLAG", "format", "ffff", "xml", "fl", "util", "locks", "fields", "utils", "prot", "tails", "FL", "fps", "details", "settings", "bytes", "status", "opens", "linux", "files", "items", "feat", "reads", "s", "options", "plugins", "includes", "faces", "nil", "features", "lines", "mask", "lag", "frames", "lf", "bits", "feed", "Flags", "ports", "stats", "ops", "links", "ds", "errors", "fee", "ints", "ips", "rules", "fts", "ils", "flag", "vals", "xxx"], "credp": ["ccrowdpc", "crimpo", "crowdpc", "lcrdpc", "Credf", " creditp", "Creds", "lcrdv", "creditsv", "credc", "ccrowdp", " cprivvp", "creditsp", " creditpi", "crsi", " cprivp", "crsm", "cribpc", "crimf", "creedc", "credo", "crdpc", "crimp", " credf", "crdp", "cannedo", "creds", "credpa", "lcrdp", "lcrdi", "cprivc", "cribpa", "Creditsp", "crcp", "lcredc", "cannedp", "Creder", "crsp", "Crder", "crcs", "creditpo", "lcredi", "crsc", "ccrowdf", "creditspm", "lcreditspm", "crdf", "crowdpa", "crdc", "creditsc", "crds", "crdpm", "cribpo", "cribf", "cdefpc", "Credp", "cribp", " credvp", "creditso", " credpo", "credpi", "crder", "lcredm", "lcrdm", "lcreditsv", "creedp", "Crdf", "lcredpc", "crdvp", "cessp", "crowdp", "cRedp", "ccedv", "ccredf", "caredc", " creditpo", "creditp", "credpm", "credpc", "cannedu", "credm", "cessv", "creditpi", "creditspa", "ccredpa", "caredvp", "Creditsu", "crdi", "ccedp", " credc", " cprivpo", "credi", "ccredpc", " cprivc", "credpo", "crdv", "lcreditsc", "Crds", "cdefp", "cesspc", "lcrdc", "creedm", "creditsu", "cessc", " credpi", "caredp", "crowdf", "Credu", "crcf", "crcer", "ccrowdpa", "lcredp", "crdpo", "creditspc", "cRedu", "ccredp", " creditf", "cprivvp", "cprivp", "caredpo", "creditsf", "cdefv", "credv", "credu", "Creditso", "cprivpo", "cribpi", "Crdp", "lcredv", "lcreditsp", "credf", "creditf", "creder", "crdm", "Credo", "creedi", "cdefc", "crimpi", "ccedpm", "ccedc", "credvp", "lcredpm", "cRedo"], "fs": ["Fs", "acs", "sys", "sync", "irs", "fb", "rs", "cs", "settings", "os", "fp", "files", "FS", "sec", "f", "ns", "feed", "stats", "cf", "states", "cache", "ls", "ts", "fc", "vals", "fw"], "path": ["channel", "port", "location", "context", "root", "self", "ath", "enc", "config", "mount", "code", "id", "stream", "object", "home", "child", "source", "directory", "image", "user", "method", "dir", "fn", "uri", "key", "loc", "password", "pass", "loader", "size", "p", "temp", "resource", "time", "buf", "pointer", "data", "entry", "length", "mode", "Path", "draft", "parent", "PATH", "url", "route", "c", "feed", "inner", "file", "text", "transform", "host", "cache", "pattern", "content", "prefix", "alias", "node"], "fullname": [" fullnumber", "flatname", "fullytext", "fultext", "flatword", "Fullpath", "flatkey", "flatpath", "fullName", "fulkey", " fullName", "shortpath", "fullypath", "Fullname", "fullystart", "fullnumber", " fullstart", "fullyname", "fullsize", "fulltext", " fullpath", "fulword", "flatnumber", " fullsize", "fullykey", "fullpath", "flattext", "FullName", "fullyword", "Fullsize", "flatstart", "shortname", "fullword", "fulname", "fullstart", "shortsize", "fullkey", "fullynumber", "shortName"], "buffer": ["area", "device", "port", "batch", "profile", "memory", "image", "pool", "available", "fp", "server", "table", "limit", "handler", "base", "Buffer", "reader", "timeout", "cb", "offset", "attr", "text", "iter", "window", "copy", "message", "seek", "bin", "slice", "seed", "uf", "FFER", "reference", "writer", "comment", "fr", "loader", "resource", "data", "b", "byte", "entry", "page", "length", "result", "url", "feed", "uffer", "function", "cache", "stack", "header", "ptr", "filename", "transfer", "queue", "fd", "source", "document", "layer", "flash", "f", "address", "token", "delay", "texture", "channel", "input", "stream", "player", "binary", "position", "buff", "bar", "size", "wave", "buf", "shell", "file", "pad", "callback"]}}
{"project": "FFmpeg", "commit_id": "63d6a6b91e4997737905bbd2cf5970ad90a31869", "target": 1, "func": "static void fix_coding_method_array (int sb, int channels, sb_int8_array coding_method)\n\n{\n\n    int j,k;\n\n    int ch;\n\n    int run, case_val;\n\n    int switchtable[23] = {0,5,1,5,5,5,5,5,2,5,5,5,5,5,5,5,3,5,5,5,5,5,4};\n\n\n\n    for (ch = 0; ch < channels; ch++) {\n\n        for (j = 0; j < 64; ) {\n\n            if((coding_method[ch][sb][j] - 8) > 22) {\n\n                run = 1;\n\n                case_val = 8;\n\n            } else {\n\n                switch (switchtable[coding_method[ch][sb][j]]) {\n\n                    case 0: run = 10; case_val = 10; break;\n\n                    case 1: run = 1; case_val = 16; break;\n\n                    case 2: run = 5; case_val = 24; break;\n\n                    case 3: run = 3; case_val = 30; break;\n\n                    case 4: run = 1; case_val = 30; break;\n\n                    case 5: run = 1; case_val = 8; break;\n\n                    default: run = 1; case_val = 8; break;\n\n                }\n\n            }\n\n            for (k = 0; k < run; k++)\n\n                if (j + k < 128)\n\n                    if (coding_method[ch][sb + (j + k) / 64][(j + k) % 64] > coding_method[ch][sb][j])\n\n                        if (k > 0) {\n\n                           SAMPLES_NEEDED\n\n                            //not debugged, almost never used\n\n                            memset(&coding_method[ch][sb][j + k], case_val, k * sizeof(int8_t));\n\n                            memset(&coding_method[ch][sb][j + k], case_val, 3 * sizeof(int8_t));\n\n                        }\n\n            j += run;\n\n        }\n\n    }\n\n}\n", "idx": 16205, "substitutes": {"sb": ["codes", "sem", "sys", "cm", "bc", "zb", "array", "ob", "config", "jp", "code", "bb", "fb", "phys", "binary", "nn", "kr", "obb", "g", "ub", "stab", "sk", "nb", "sth", "cn", "buffer", "java", "si", "ym", "sit", "machine", "bj", "frame", "buff", "jam", "fr", "conn", "bp", "obj", "s", "rb", "ib", "bm", "sf", "b", "usb", "inst", "component", "gb", "shop", "bh", "jc", "SB", "cb", "sn", "sc", "eb", "sv", "cod", "uv", "cp", "zh", "sh", "db", "abb", "src", "lb", "hw"], "channels": ["Chapters", "Chords", " chapters", "chords", "echapters", "schores", "echords", "cunks", "cores", " chanes", "schanes", "canes", "schannels", "chapters", "chanes", "schunks", " chunks", "Channels", "echannels", "chunks", "cannels", "chores", " chores", " chords"], "coding_method": ["coder_call", "code_array", "coding___code", "coding2round", "coder_num", "code_round", "coder_condition", "coding2method", "codingbookformat", "codingbookarray", "coding2array", "coding2model", "coder_method", "coding_model", "codingbookfunction", "coding2table", "codingbookmethod", "coding___function", "coding___method", "coder_array", "coding_array", "coder_record", "coding_function", "coder_model", "coding_table", "coding_code", "coding_format", "coding_condition", "coding2function", "code_method", "coder_format", "code_table", "coder_code", "coding_call", "coding_num", "coder_function", "coding___num", "coding_record", "coding_round"], "j": ["jj", "uj", "jen", "it", "qi", "adj", "m", "vision", "aj", "kj", "d", "ja", "jp", "l", "i", "code", "un", "oj", "jon", "dj", "h", "ock", "x", "jet", "ie", "js", "ju", "bj", "key", "v", "job", "fr", "jam", "br", "o", "obj", "z", "ind", "jit", "p", "e", "boot", "note", "li", "b", "n", "f", "jan", "c", "jo", "block", "jl", "jc", "ji", "q", "J", "ik", "pr", "el", "y", "ij"], "k": ["ke", "dk", "kat", "m", "ek", "ak", "d", "l", "i", "unk", "kr", "ko", "row", "kn", "kick", "ki", "g", "uk", "sk", "h", "x", "kk", "key", "v", "kw", "o", "w", "z", "u", "ka", "p", "e", "ok", "ku", "ck", "b", "n", "f", "c", "mk", "K", "q", "kg", "kin", "ack", "r", "ik", "ky", "work", "y", "km", "kid", "ks"], "ch": ["ach", "batch", "i", "cham", "cht", "h", "br", "cher", "ver", "count", "c", "ry", "cb", "change", "zh", "cp", "cell", "chal", "chip", "cor", "gh", "con", "cha", "b", "inst", "cand", "th", "ich", "el", "core", "un", "ci", "cy", "machine", "conn", "sch", "arch", "f", "bh", "chan", "cf", "sh", "ph", "hw", "ctx", "channel", "che", "cm", "_", "jp", "code", "l", "range", "sk", "v", "conf", "buff", "form", "col", "p", "chart", "chn", "cho", "chy", "n", "Ch", "chu", "chi", "ht", "q", "cmd", "cod", "y"], "run": ["runner", "batch", "use", "x", "model", "loc", "win", "rain", "play", "c", "end", "work", "tag", "lock", "num", "order", "in", "index", "head", "call", "m", "ru", "d", "sync", "rc", "id", "g", "key", "rank", "pass", "group", "clean", "ran", "min", "ann", "route", "r", "exec", "reg", "core", "round", "thread", "config", "un", "fun", "unit", "race", "step", "mix", "view", "boot", "inc", "block", "type", "ro", "loop", "kg", "man", "ron", "pos", "no", "node", "record", "month", "name", "row", "ain", "Run", "mod", "job", "cr", "move", "match", "running", "n", "read", "rule", "q", "kin", "db", "runs", "day", "len", "start"], "case_val": ["ase_label", "case_eval", "ase_eval", " case_bal", "choice___la", " case_aval", "case___val", "caseFkey", "case_VAL", "case67value", "case__vals", "caseFvals", "case__val", "choice___value", "case_key", "caseFel", "case_vol", "case_aval", "ase_vals", "choice_val", "caseevol", "caseevalue", "case67val", "choice_value", "caseerrot", " case_rot", "case_el", "choice_eval", "case__key", " case_eval", "case7vals", "caseFval", "choice_la", "case_label", "case67label", "ase_vol", "case7aval", "ase_cal", "case67vals", "choice___val", " case_pos", "caseervals", "caseecal", "ase_value", "case7val", "case_pos", "caseerVAL", "case_rot", "caseerval", "case___eval", " case_key", " case_vals", " case_el", "case7eval", "case_la", " case_VAL", "case_cal", "case___la", "choice___eval", "case_value", "case_vals", "case_bal", " case_value", "case__el", "case___value", "caseeval", "ase_val"], "switchtable": ["callarray", "jumpTable", " switchTable", "callinterface", "changearray", "testinterface", "caserule", "jumptable", " switchrule", "changetable", "switchrule", "callTable", "testarray", "switchTable", "switcharray", "testTable", "casetable", "jumprule", "caseTable", "calltable", "testtable", "switchinterface", "changeinterface", "changeTable"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207, "substitutes": {"ctx": ["context", "ch", "tx", "cm", "bc", "qa", "pkg", "cv", "ca", "sync", "rc", "config", "pc", "cc", "jp", "Context", "gc", "lc", "cs", "ci", "ctrl", "cpu", "wx", "cn", "cms", "wcs", "cmp", "fp", "ct", "loc", "cgi", "gru", "conn", "cr", "client", "np", "obj", "la", "nc", "cli", "ck", "component", "cus", "c", "cca", "crit", "cu", "gpu", "anc", "cas", "sc", "sci", "cmd", "cf", "cp", "exec", "que", "ga", "xc", "src", "vc", "css", "hw", "fc", "cl"]}}
{"project": "qemu", "commit_id": "e2f89926f19d2940eda070542501f39f51a8c81f", "target": 1, "func": "int usb_packet_map(USBPacket *p, QEMUSGList *sgl)\n\n{\n\n    int is_write = (p->pid == USB_TOKEN_IN);\n\n    target_phys_addr_t len;\n\n    void *mem;\n\n    int i;\n\n\n\n    for (i = 0; i < sgl->nsg; i++) {\n\n        len = sgl->sg[i].len;\n\n        mem = cpu_physical_memory_map(sgl->sg[i].base, &len,\n\n                                      is_write);\n\n        if (!mem) {\n\n            goto err;\n\n        }\n\n        qemu_iovec_add(&p->iov, mem, len);\n\n        if (len != sgl->sg[i].len) {\n\n            goto err;\n\n        }\n\n    }\n\n    return 0;\n\n\n\nerr:\n\n    usb_packet_unmap(p);\n\n    return -1;\n\n}\n", "idx": 16211, "substitutes": {"p": ["port", "proc", "m", "po", "d", "t", "pc", "jp", "l", "a", "pre", "g", "sp", "lp", "pp", "post", "ap", "v", "patch", "ps", "o", "bp", "u", "e", "pb", "pa", "data", "b", "op", "j", "n", "f", "point", "wp", "parent", "c", "pe", "per", "pi", "q", "process", "cp", "r", "pr", "pat", "P", "tp"], "sgl": ["sgb", "pssl", "sGl", "psgl", " sbl", "chesgb", "wsdl", "fsgl", "sysGL", "ssbl", "chesgel", "sgn", "opsgl", "wsgl", "anslu", " sdl", "sysdl", " sGL", "sbl", "opsbl", " slu", "fsgb", " sgel", "wsGL", "slu", "fsgel", "sdl", "chesgl", " sGl", "slam", "ansgb", "cheslam", "fslam", "sGL", "ssgb", " splay", "sysplay", "opsdl", "ansgl", " slam", " ssl", "wsplay", "ssl", "sslu", "sgel", "ssgl", "ansbl", " sgb", " sglobal", "opsgn", "sysgl", "sglobal", " sgn", "splay", "psGl", "psglobal"], "len": ["ln", "en", "rev", "part", "lin", "non", "fl", "Len", "ni", "id", "l", "val", "lan", "lic", "lon", "split", "label", "name", " length", "lc", "fun", "low", "dl", "str", "lang", "ie", "lit", "ld", "limit", "lib", " l", "z", "ll", "size", "la", "lif", "fi", "fin", "li", "data", "pl", "base", "min", "ler", "length", "lf", "n", "f", "line", "count", "il", "lu", "afi", "gen", "ell", "cap", "le", "lex", "den", "seq", "pos", "num", "lock", "el", "bl", "del", "lim", "err"], "mem": ["device", "m", "bin", "ram", "val", "l", "memory", "mp", "me", "home", "name", "g", " Mem", "fun", "sp", "mob", "cpu", "pool", "ref", "vm", "buffer", "mm", "loc", "em", "job", "buff", "mb", "conn", "size", "la", "med", "mor", "lif", "fi", "temp", "mi", "buf", "data", "base", "f", "lf", "mo", "ann", "rm", "ip", "dem", "wa", "le", "lex", "cache", "mac", "Mem", "num", "reg", "el", "hw", "nm", "lim", "alloc"], "i": ["en", "val", "oi", "x", "si", "limit", "base", "phi", "c", "ami", "zi", "in", "index", "hi", "m", "d", "t", "xi", "id", "iu", "iv", "io", "api", "ki", "di", "u", "s", "fi", "b", "ti", "ip", "eni", "r", "bi", "el", "mu", "qi", "ni", "ini", "ci", "ie", "o", "z", "e", "info", "li", "ix", "multi", "j", "f", "err", "it", "ui", "adi", "I", "ai", "l", "gi", "ii", "uri", "v", "yi", "mi", "cli", "n", "pi", "all", "ri", "ori", "y", "abi"]}}
{"project": "qemu", "commit_id": "73d60fa5fae60c8e07e1f295d8c7fd5d04320160", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216, "substitutes": {"ibs": ["ipo", "iamsys", "IBS", "ipm", "ibo", "pubS", "ibS", "iamS", "bbsys", "ipsys", "ipS", "iwin", "bbS", "iws", "IBs", "ibn", "ibm", "ipds", "ibin", "iams", "pubo", "bbs", "ipin", "IBo", "ibds", "iwm", "ibsys", "bbds", "iamds", "ipn", "ips", " ibn", "pubs", "iwn", " ibin", " ibm"], "cmd": ["args", "path", "pkg", "input", "config", "id", "code", "msg", "ctrl", "req", "MD", "module", "init", "nd", "force", "frame", "gn", "client", "conn", "cd", "grad", "clean", "ind", "dict", "pipe", "buf", "ck", "op", "count", "mode", "cfg", "c", "crit", "route", "cat", "dc", "bind", "chan", "cb", "gen", "md", "Cmd", "cod", "cf", "kg", "command", "cp", "mac", "comm", "seq", "dom", "cl", "ctx"], "cmd_len": ["cmdslength", " cmdsl", "cmdsl", "cmd2val", " cmdsval", "cmd_val", " cmd_length", " cmd_val", "cmdsval", " cmdslength", " cmdslen", " cmd_l", "cmdslen", "cmd_l", "cmd2l", "cmd2len", "cmd2length", "cmd_length"], "rsp": ["rst", "srpc", " resp", " rst", " rpc", " rserv", "srserv", "rsc", "rresp", "sresp", "rrsp", "rserv", "rrserv", " rp", "rpc", "srsp", "rp", " rsc", "Rp", "srst", "srsc", "resp", "srp", "rrst", "Rsp", "Rpc", "Rsc"], "rsp_len": ["rsp_Len", "rsc_limit", "rsp_limit", "rsc_len", "rsc_length", "rsc_Len", "rsp_length"], "max_rsp_len": ["max_rsp_length", "max_rsp_l", "max_rsc_length", "max_rsc_count", "max_rsc_l", "max_rsc_len", "max_rsp_count"], "sens": [" sENS", "symener", "Sents", "symENS", "gens", "densor", "fenses", "tensor", "Soss", "Sensor", "dets", "gener", "genders", "sener", "slens", "symens", "Senses", "sps", " senders", " sents", "sents", " sensor", "soss", "foss", "fensor", "denses", "sets", "serener", "syncensor", "fENS", "serENS", "sligs", "serigs", "sENS", "dents", "dENS", "senses", "pener", "dens", "sensor", "fents", "pents", "tets", "slener", "gENS", "gps", "tENS", "senders", "pENS", "pens", "slenses", "pigs", "sigs", "pets", "slets", "tener", " senses", "gensor", "gents", " soss", " sets", "tents", "slENS", "symensor", " sps", "syncens", "syncenders", "serens", "tens", "syncENS", "Sps", "Sens", "fens"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "void ff_mjpeg_encode_mb(MpegEncContext *s, int16_t block[12][64])\n\n{\n\n    int i;\n\n    if (s->chroma_format == CHROMA_444) {\n\n        encode_block(s, block[0], 0);\n\n        encode_block(s, block[2], 2);\n\n        encode_block(s, block[4], 4);\n\n        encode_block(s, block[8], 8);\n\n        encode_block(s, block[5], 5);\n\n        encode_block(s, block[9], 9);\n\n\n\n        if (16*s->mb_x+8 < s->width) {\n\n            encode_block(s, block[1], 1);\n\n            encode_block(s, block[3], 3);\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[10], 10);\n\n            encode_block(s, block[7], 7);\n\n            encode_block(s, block[11], 11);\n\n        }\n\n    } else {\n\n        for(i=0;i<5;i++) {\n\n            encode_block(s, block[i], i);\n\n        }\n\n        if (s->chroma_format == CHROMA_420) {\n\n            encode_block(s, block[5], 5);\n\n        } else {\n\n            encode_block(s, block[6], 6);\n\n            encode_block(s, block[5], 5);\n\n            encode_block(s, block[7], 7);\n\n        }\n\n    }\n\n}\n", "idx": 16227, "substitutes": {"s": ["en", "rs", "qs", "x", "js", "si", "ps", "params", "lines", "stat", "spec", "c", "is", "states", "com", "aws", "south", "m", "self", "bis", "d", "t", "sync", "sg", "fs", "sup", "g", "cs", "es", "session", "w", "u", "an", "sf", "b", "ns", "ops", "r", "support", "ks", "sys", "service", "os", "sets", "o", "ms", "e", "info", "http", "site", "sb", "f", "less", "services", "sh", "ls", "ui", "ses", "as", "enc", "bs", "l", "a", "sites", "S", "settings", "this", "its", "sq", "styles", "v", "conf", "ss", "p", "se", "ions", "plugins", "k", "n", "gs", "xs", "ssl", "ds", "su", "ts", "us", "y"], "block": ["word", "map", "blocks", "batch", "val", "shape", "label", "def", "pre", "image", "bytes", "panel", "str", "module", "model", "loc", "frame", "filter", "obj", "base", "box", "list", "line", "work", "off", "lock", "num", "index", "bin", "sync", "id", "full", "comment", "key", "error", "check", "group", "clean", " Block", "pack", "data", "page", "byte", "ip", "number", "arr", "cap", "link", "um", "style", "Block", "unit", "buffer", "view", "mix", "point", "none", "type", "pos", "no", "bl", "post", "cl", "bit", "tick", "record", "shift", "object", "month", "name", "row", "patch", "chain", "set", "plugin", "keep", "pull", "seq", "ban", "join"], "i": ["hi", "qi", "it", "ui", "I", "d", "ni", "ai", "xi", "in", "iu", "split", "gi", "ini", "oi", "io", "l", "id", "a", "ci", "h", "di", "x", "si", "init", "ii", "uri", "v", "o", "index", "yi", "z", "u", "p", "e", "info", "fi", "mi", "li", "k", "ix", "b", "multi", "j", "phi", "f", "n", "ti", "ip", "c", "is", "ji", "pi", "q", "bi", "ri", "ami", "zi", "y", "abi", "mu"]}}
{"project": "qemu", "commit_id": "496272a7018ba01aa2b87a1a5ed866ff85133401", "target": 0, "func": "int pte_update_flags(mmu_ctx_t *ctx, target_ulong *pte1p,\n\n                     int ret, int rw)\n\n{\n\n    int store = 0;\n\n\n\n    /* Update page flags */\n\n    if (!(*pte1p & 0x00000100)) {\n\n        /* Update accessed flag */\n\n        *pte1p |= 0x00000100;\n\n        store = 1;\n\n    }\n\n    if (!(*pte1p & 0x00000080)) {\n\n        if (rw == 1 && ret == 0) {\n\n            /* Update changed flag */\n\n            *pte1p |= 0x00000080;\n\n            store = 1;\n\n        } else {\n\n            /* Force page fault for first write access */\n\n            ctx->prot &= ~PAGE_WRITE;\n\n        }\n\n    }\n\n\n\n    return store;\n\n}\n", "idx": 16237, "substitutes": {"ctx": ["sem", "context", "tx", "pkg", "bc", "cm", "qa", "ca", "cv", "sync", "rc", "config", "cc", "jp", "ctrl", "ci", "cs", "cn", "std", "cmp", "sq", "loc", "conn", "client", "obj", "grad", "comp", "c", "cca", "cb", "cas", "sci", "sc", "cmd", "cf", "cp", "exec", "qq", "xc", "src", "mac", "hw"], "pte1p": ["pte2p", "pte01p", "pte0c", "ptee1point", "pte1fp", "ptec6p", "pte001point", "pte01c", "pte001p", "pte251p", "ptec6e", "pte5c", "ptee1f", "ptee3f", "pte2b", "pte6e", "pte3point", "pte3p", "pte251fp", "pte01f", "pte6f", "pte2f", "ptea1point", "ptea001c", "ptee1c", "ptec6sp", "pte1s", "pte6p", "pte5fp", "pte3l", "ptea1c", "pte11b", "pte251sp", "pte1l", "ptea1l", "ptee3p", "pte0point", "ptec1fp", "pteonep", "pte6s", "pteonef", "pte1b", "ptec6fp", "pte5sp", "ptee2b", "pte3s", "pte6c", "ptee3c", "pte01point", "ptee2f", "ptea1p", "pte2point", "pte2s", "ptea001l", "ptea001point", "ptee1b", "ptec1e", "pte001l", "pte1e", "pte001c", "pte6fp", "pte3f", "ptee1p", "pte251e", "ptee2p", "pte0p", "pte1sp", "pte11f", "pte1f", "ptec1p", "pte5p", "pte6sp", "pte5point", "ptee1s", "pte2c", "pte1point", "ptee3s", "pte5e", "pte0l", "ptec1sp", "pteoneb", "ptea001p", "pte1c", "pte3c", "pte5f", "ptee2point", "ptee2c", "pte11p"], "ret": ["pet", "alt", "nat", "ft", "reply", "val", "back", "def", "gt", "rets", "ref", "feat", "match", "success", "ext", "Ret", "result", "store", " RET", "att", "rl", "route", "ry", "offset", "nt", "re", "rt", "sur", "resp", "pat", "RET", "rest", "reg", "rf", "flag", "bit"], "rw": ["rr", "wk", "rss", "reply", "rus", "rd", "rc", "our", "ride", "rn", "wx", "rg", "sw", "sr", "raf", "rh", "nw", "feat", "w", "adr", "rec", "lr", "rb", "rx", "wb", "rack", "rl", "route", "ro", "attr", "rt", "RW", "wrap", "rf", "usr", "rue", "fw"]}}
{"project": "qemu", "commit_id": "5a2223ca26b1a34e131b5b9a63599d9426d2c25c", "target": 0, "func": "static void enable_device(AcpiPciHpState *s, unsigned bsel, int slot)\n\n{\n\n    s->acpi_pcihp_pci_status[bsel].device_present |= (1U << slot);\n\n}\n", "idx": 16246, "substitutes": {"s": ["secondary", "south", "port", "sys", "ses", "service", "sync", "t", "fs", "private", "rs", "sym", "g", "S", "settings", "js", "sq", "session", "server", "ss", "o", "p", "e", "http", "sf", "sb", "b", "f", "stat", "c", "ns", "stats", "ssl", "ops", "services", "ds", "ssh"], "bsel": ["fbsels", "fbsl", "lbsels", " bsell", "bbsl", "lbsel", "lbsl", " bsl", "bsl", "fbsell", "bsell", "bbsel", "bbsell", "cbsel", "fbsel", "bsels", "bbsels", "lbsell", "cbsels", "cbsl", " bsels", "cbsell"], "slot": ["spot", "slice", "service", "trial", "hide", "second", "pixel", "nit", "shot", "disabled", " slots", "lot", "option", "vol", "session", "antine", "zo", "hole", "sector", "zone", "role", "lo", "sec", "Slot", "pot", "boot", "not", "socket", "rol", " Slot", "token", "serv", "offset", "loop", "sl", "layout", "rot", "bit"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "void ff_avg_h264_qpel16_mc12_msa(uint8_t *dst, const uint8_t *src,\n\n                                 ptrdiff_t stride)\n\n{\n\n    avc_luma_midh_qrt_and_aver_dst_16w_msa(src - (2 * stride) - 2,\n\n                                           stride, dst, stride, 16, 0);\n\n}\n", "idx": 16255, "substitutes": {"dst": ["fdsp", "Dsc", "fdrc", "Dst", "sdsrc", " dsc", " dsrc", " dsp", " drc", "fdst", "dsrc", "dsp", "sdst", "fdsrc", "sdsc", "dsc", "Drc", "sdrc", "Dsp", "drc", "Dsrc"], "src": ["ffff", "slice", "d", "dist", "sync", "rc", "config", "i", "supp", "sup", "source", "low", "use", "sr", "dest", "loc", "rec", "img", "rb", "sec", "rate", "sb", "b", "inst", "gb", "url", "cb", "sc", "bg", "sl", "sur", "r", "sub", "sel", "cur", "st", "fc"], "stride": ["strider", "str8", "dride", " strade", "Stride", "trided", "Strider", "arrode", "drade", "divide", "strided", "brided", "arrided", "Strside", " strside", "trside", " str8", "hrided", "brade", "divade", "brode", "dr8", " strider", "strade", "div8", "Strides", "hride", "hrider", "bride", "Strided", " strides", "arride", "drided", "hrd", "strides", "Strd", "strode", " strode", "arrade", " strd", "divided", "strside", "trides", "tride", "strd", " strided"]}}
{"project": "FFmpeg", "commit_id": "6221e2478c593a0ce1183eed929cb2101dbf5265", "target": 0, "func": "int av_parse_color(uint8_t *rgba_color, const char *color_string, int slen,\n\n                   void *log_ctx)\n\n{\n\n    char *tail, color_string2[128];\n\n    const ColorEntry *entry;\n\n    int len, hex_offset = 0;\n\n\n\n    if (color_string[0] == '#') {\n\n        hex_offset = 1;\n\n    } else if (!strncmp(color_string, \"0x\", 2))\n\n        hex_offset = 2;\n\n\n\n    if (slen < 0)\n\n        slen = strlen(color_string);\n\n    av_strlcpy(color_string2, color_string + hex_offset,\n\n               FFMIN(slen-hex_offset+1, sizeof(color_string2)));\n\n    if ((tail = strchr(color_string2, ALPHA_SEP)))\n\n        *tail++ = 0;\n\n    len = strlen(color_string2);\n\n    rgba_color[3] = 255;\n\n\n\n    if (!av_strcasecmp(color_string2, \"random\") || !av_strcasecmp(color_string2, \"bikeshed\")) {\n\n        int rgba = av_get_random_seed();\n\n        rgba_color[0] = rgba >> 24;\n\n        rgba_color[1] = rgba >> 16;\n\n        rgba_color[2] = rgba >> 8;\n\n        rgba_color[3] = rgba;\n\n    } else if (hex_offset ||\n\n               strspn(color_string2, \"0123456789ABCDEFabcdef\") == len) {\n\n        char *tail;\n\n        unsigned int rgba = strtoul(color_string2, &tail, 16);\n\n\n\n        if (*tail || (len != 6 && len != 8)) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid 0xRRGGBB[AA] color string: '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        if (len == 8) {\n\n            rgba_color[3] = rgba;\n\n            rgba >>= 8;\n\n        }\n\n        rgba_color[0] = rgba >> 16;\n\n        rgba_color[1] = rgba >> 8;\n\n        rgba_color[2] = rgba;\n\n    } else {\n\n        entry = bsearch(color_string2,\n\n                        color_table,\n\n                        FF_ARRAY_ELEMS(color_table),\n\n                        sizeof(ColorEntry),\n\n                        color_table_compare);\n\n        if (!entry) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Cannot find color '%s'\\n\", color_string2);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        memcpy(rgba_color, entry->rgb_color, 3);\n\n    }\n\n\n\n    if (tail) {\n\n        unsigned long int alpha;\n\n        const char *alpha_string = tail;\n\n        if (!strncmp(alpha_string, \"0x\", 2)) {\n\n            alpha = strtoul(alpha_string, &tail, 16);\n\n        } else {\n\n            alpha = 255 * strtod(alpha_string, &tail);\n\n        }\n\n\n\n        if (tail == alpha_string || *tail || alpha > 255) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Invalid alpha value specifier '%s' in '%s'\\n\",\n\n                   alpha_string, color_string);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        rgba_color[3] = alpha;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16256, "substitutes": {"rgba_color": ["rgba4pixel", "rgba_or", "rgba4color", "rgbon4with", "rgba_with", "rgbo_color", "rgba2or", "rgga_colour", "rgba4or", "rgbo_colour", "rgba_private", "rgba64size", "rgba__pixel", "rgpa_string", "rgbon_with", "rgba64colour", "rgba_number", "rgaba_token", "rgba2line", "rgba_author", "rgga_color", "rgba__token", "rgba_style", "rgva_style", "rgba_parent", "rgbon4or", "rgbo_size", "rgbon_pixel", "rgva_or", "rgba2white", "rgpa_size", "rgba_pixel", "rgba64number", "rgbo_line", "rgama_white", "rgba_option", "rgbon4pixel", "rgbon4color", "rgba_colour", "rgba4with", "rgpa_color", "rgbon_color", "rgva_pixel", "rgama_colour", "rgbo2number", "rgbo_number", "rgba__parent", "rgpa_blue", "rgba_white", "rgaba_parent", "rgga_author", "rgba_string", "rgga_token", "rgba2colour", "rgba_source", "rgba2number", "rgba_line", "rgaba_pixel", "rgba2size", "rgba2source", "rgba2color", "rgbo2line", "rgva_option", "rgva_private", "rgama_color", "rgba_token", "rgbo2color", "rgva_colour", "rgbon_or", "rgba__color", "rgaba_color", "rgama_or", "rgba64color", "rgva_size", "rgva_color", "rgba_blue", "rgbo_source", "rgba2pixel", "rgbo2source", "rgba_size"], "color_string": ["colorablestrings", "color2string", " color_class", "coloracstrings", "coloringclass", " color_strings", "color2length", "colour_text", "colorqstr", "color_text", "coloracstring", "colour_length", "colour_string", "colorableclass", "color_section", "coloracletter", " color_letter", "coloringstrings", "colour2length", "colorqstring", "colour2section", " color_number", "colour_format", "color_space", "colorglength", " color_section", "coloringstring", " color_space", "colorablesection", "colour_str", "colour2string", " color_uri", "color_strings", "colorgformat", "color2section", "color_uri", "colorqlength", "coloringlength", "colorablestring", "colorgtext", "color_str", "color_format", "color2str", "coloracspace", "color_length", "color_class", "colorgstring", "coloringsection", "colour_section", "colorqsection", "colour2str", "color_letter", "coloringstr", "color_number"], "slen": ["lenc", "splain", " slatten", "lEN", "slot", "swenc", "swens", "selend", "slens", "lain", "splEN", "selot", "clens", "lens", "clz", " slain", " slens", " slz", "slain", "swen", "clend", "mlens", "sslen", "slz", "spllen", "selenn", "sslens", "clatten", "llen", "silenn", "clot", "slEN", "clen", "silot", "silen", "slenc", "sslz", " sllen", " slEN", "mlen", "slenn", "clenn", "sslatten", "mllen", "splen", "selen", "swlen", "mlenc", "slend", "sllen", "silend", "slatten"], "log_ctx": ["loglogcontext", "log_loc", "error_context", " log_section", "logvalcontext", "log_data", "log_scope", "loglogctx", "error_ctx", "loglogsection", "logvalscope", "error_data", " log_scope", "logFcontext", "log_section", " log_context", "logFdata", "logFctx", "error_loc", "log_context", "logFloc", "logvalsection", "loglogscope", "logvalctx"], "tail": ["alt", "head", "ignore", "split", "suff", "foot", "letter", "style", "name", "tails", "lc", "align", "weight", "test", "unit", "det", "fat", "comment", "thread", "limit", "conn", "ill", "ul", "col", "term", "size", "stop", "sign", "ll", "ind", "match", "li", "ail", "tc", "nil", "tip", "length", "padding", "token", "timeout", "il", "end", "pull", "margin", "offset", "target", "body", "lead", "pattern", "rest", "tag", "color", "prefix", "wl", "lock", "run", "wrap", "index", "start"], "color_string2": ["color_version2", "color_source2", "color_result2", "color_function1", "color_string4", "color_stringsTwo", "color_versionSecond", "color_strings6", "color_seriesTwo", "color_letterDB", "color_stringDB", "color_letter2", "color_number2", "color_version1", "color_function6", "color_string6", "color_seriesDB", "color_configII", "color_name2", "color_letterTwo", "color_source1", "color_series1", "color_str2", "color_sectionTwo", "color_strSecond", "color_stringII", "color_letter1", "color_number1", "color_strings1", "color_section2", "color_pair2", "color_int1", "color_config1", "color_strings2002", "color_stringscopy", "color_number0", "color_object2", "color_strings8", "color_pair4", "color_stream1", "color_stream2", "color_array2", "color_stringsII", "color_seriescopy", "color_strings20", "color_intII", "color_pair1", "color_text2", "color_pair8", "color_number4", "color_string20", "color_pair0", "color_config2", "color_stringsDB", "color_int2", "color_string1", "color_nameTwo", "color_sourceTwo", "color_string8", "color_stringTwo", "color_function8", "color_strings2", "color_numberTwo", "color_stringSecond", "color_pair6", "color_result1", "color_stringcopy", "color_string2002", "color_str20", "color_string0", "color_section2002", "color_function2", "color_str1", "color_array4", "color_stringsSecond", "color_array1", "color_section1", "color_streamTwo", "color_text1", "color_series2", "color_stream2002", "color_section4", "color_object1", "color_strings0", "color_strings4", "color_name1", "color_objectcopy", "color_version20"], "entry": ["card", "ge", "insert", "array", "id", "code", "letter", "or", "name", "row", "image", "ident", "ie", "si", "member", "import", "ent", "value", "set", "tri", "quad", "term", "parse", "la", "mer", "info", "match", "data", "her", "ries", "count", "result", "expr", "line", "parent", "feed", "ry", "try", "cat", "cell", "sub", "dr", "color", "Entry"], "len": ["en", "lin", "non", "fl", "Len", "lon", "split", "val", "l", "lan", "name", "lc", "dl", "inn", "ie", "lit", "loc", "fn", "limit", "dy", "z", "ll", "size", "ind", "fin", "lt", "li", "min", "length", "n", "ler", "lf", "count", "line", "span", "il", "end", "offset", "nt", "sl", "elt", "all", "le", "pos", "rel", "el", "ln", "lim"]}}
{"project": "qemu", "commit_id": "22d5cd82e98b61b1dbd791fab9f4ae0f77c0ed14", "target": 0, "func": "static int raw_inactivate(BlockDriverState *bs)\n\n{\n\n    int ret;\n\n    uint64_t perm = 0;\n\n    uint64_t shared = BLK_PERM_ALL;\n\n\n\n    ret = raw_handle_perm_lock(bs, RAW_PL_PREPARE, perm, shared, NULL);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n    raw_handle_perm_lock(bs, RAW_PL_COMMIT, perm, shared, NULL);\n\n    return 0;\n\n}\n", "idx": 16274, "substitutes": {"bs": ["ses", "blocks", "bis", "bc", "lbs", "BS", "fs", "iss", "ins", "bb", "ocks", "rs", "sync", "cs", "qs", "fps", "os", "js", "ss", "obj", "ba", "s", "pb", "sb", "b", "base", "gs", "gb", "bits", "bh", "ns", "bps", "cb", "bes", "ds", "sa", "src", "ec", "ls", "css", "bos", "ubs", "las", "bl", "vs", "ks"], "ret": ["pet", "alt", "en", "ft", "rev", "reply", "tmp", "art", "rc", "id", "val", "code", "back", "pre", "def", "rets", "fun", "req", "std", "ref", "xt", "det", "lit", "pred", "valid", "active", "fin", "success", "data", "af", "base", "Ret", "match", "bf", "fab", "result", "ext", "att", "red", "cat", " Ret", "nt", "re", "out", "rt", "repl", "pat", "RET", "res", "reg", "cur", "flag", "len", "bit"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void qmp_output_type_any(Visitor *v, const char *name, QObject **obj,\n\n                                Error **errp)\n\n{\n\n    QmpOutputVisitor *qov = to_qov(v);\n\n    qobject_incref(*obj);\n\n    qmp_output_add_obj(qov, name, *obj);\n\n}\n", "idx": 16276, "substitutes": {"v": ["env", "m", "vim", "d", "t", "l", "i", "vp", "iv", "g", "x", "value", "vi", "gu", "inv", "tv", "o", "var", "w", "u", "p", "e", "k", "vs", "b", "vis", "j", "f", "c", "volt", "q", "sv", "va", "uv", "r", "V", "ev", "vt", "lv"], "name": ["word", "path", "self", "part", "nam", "id", "object", "style", "label", "null", "x", "comment", "key", "Name", "NAME", "o", "w", "names", "ame", "time", "named", "info", "data", "ext", "base", "j", "n", "f", "none", "parent", "type", "attr", "prefix", "alias", "nm", "filename"], "obj": ["args", "adj", "alt", "aj", "part", "po", "ob", "so", "art", "bs", "tmp", "code", "val", "object", "pt", "obb", "oa", "nn", "api", "Object", "orb", "os", "nb", "x", "ref", "js", "eff", "fn", "bj", "output", "Obj", "o", "otype", "office", "data", "b", "ext", "sb", "j", "inst", "n", "arr", "cb", "attr", "objects", "obo", "elt", "ops", "pr", "emb", "pos", "prefix", "ctx"], "errp": ["erp", "rrp", "nerpo", "nerp", "rrpo", "erfp", "errfp", "rrfp", "nerfp", "erpo", "errpo"], "qov": ["quoo", "qoyer", "quoyer", "Qov", "Qove", " qoo", " qob", " qove", "qob", "Qoo", "qove", " qoyer", "quOV", " qOV", "ckob", "QOV", "qvo", " qvo", "Qvo", "Qoyer", "ckove", "ckvo", "quov", "qoo", "ckov", "qOV", "Qob"]}}
{"project": "qemu", "commit_id": "41ecc72ba5932381208e151bf2d2149a0342beff", "target": 0, "func": "static int setup_sigcontext(struct target_sigcontext *sc,\n\n                            CPUSH4State *regs, unsigned long mask)\n\n{\n\n    int err = 0;\n\n    int i;\n\n\n\n#define COPY(x)         __put_user(regs->x, &sc->sc_##x)\n\n    COPY(gregs[0]); COPY(gregs[1]);\n\n    COPY(gregs[2]); COPY(gregs[3]);\n\n    COPY(gregs[4]); COPY(gregs[5]);\n\n    COPY(gregs[6]); COPY(gregs[7]);\n\n    COPY(gregs[8]); COPY(gregs[9]);\n\n    COPY(gregs[10]); COPY(gregs[11]);\n\n    COPY(gregs[12]); COPY(gregs[13]);\n\n    COPY(gregs[14]); COPY(gregs[15]);\n\n    COPY(gbr); COPY(mach);\n\n    COPY(macl); COPY(pr);\n\n    COPY(sr); COPY(pc);\n\n#undef COPY\n\n\n\n    for (i=0; i<16; i++) {\n\n        __put_user(regs->fregs[i], &sc->sc_fpregs[i]);\n\n    }\n\n    __put_user(regs->fpscr, &sc->sc_fpscr);\n\n    __put_user(regs->fpul, &sc->sc_fpul);\n\n\n\n    /* non-iBCS2 extensions.. */\n\n    __put_user(mask, &sc->oldmask);\n\n\n\n    return err;\n\n}\n", "idx": 16281, "substitutes": {"sc": [" Sc", "ch", "SC", "bc", "uc", "ca", "enc", "sche", "rc", "cc", "pc", "cv", "sync", "lc", "cs", "sw", "asc", "scope", "loc", "isc", "cr", "oc", "sec", "desc", "cli", "pl", "nc", "tc", "cus", "Sc", "scl", "spec", "c", "cca", "inc", "dc", "anc", "esc", "osc", "cont", "sci", "cf", "org", "com", "exec", "usc", "ga", "sh", "src", "ec", "sub", "cur", "cl", "go"], "regs": ["registerqs", "gregS", "logsets", "accounts", "registers", "registersb", "rogqs", "gregs", "rogp", "rogss", "regp", "regss", "regsb", "rogis", "regsi", "gregp", "gregss", "grams", " regsets", " regqs", "gregis", "REGs", "REGstates", "rogs", "REGsi", "regS", "accountqs", "rogns", " regS", "registerns", "aggs", "gramp", "rogsb", "gregstates", "aggsets", "gramis", "accountns", "logqs", "REGS", "regis", "regsets", "accountsb", "logs", " regsi", "aggqs", "regqs", "regstates", "regns", "gregsi", " regstates", "gramss"], "mask": ["bug", "map", "ch", "root", "weight", "sk", "sum", "comment", "patch", "conf", "Mask", "flags", "fix", "filter", "scan", "pass", "flag", "clear", "arch", "wait", "match", "ix", "ask", "skip", "ma", "bits", "diff", "gate", "scale", "mac", "pattern", "work", "lock", "ban", "delay", "prefix", "pad", " Mask", "alias", "depth", "bit"], "i": ["hi", "qi", "it", "ui", "m", "part", "I", "d", "ni", "ai", "xi", "id", "ini", "my", "gi", "iu", "a", "io", "oi", "l", "mu", "ci", "di", "x", "init", "si", "ie", "ii", "error", "v", "uri", "k", "o", "yi", "u", "z", "p", "e", "mini", "ver", "fi", "mi", "li", "info", "b", "ix", "abi", "j", "count", "n", "f", "result", "ti", "phi", "ip", "c", "eni", "counter", "is", " err", "ji", "chi", "pi", "r", "bi", "ri", "ami", "zi", "y", "in", "index"]}}
{"project": "qemu", "commit_id": "7c4228b4771acddcb8815079bc116007cec8a1ff", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293, "substitutes": {"vdev": ["lvdevelopment", "wdd", "nvserver", "vapp", "vardev", "evdev", "wrad", "vneg", "svev", "ivdev", "evev", "Vserv", " vprof", "nvdraft", "svvar", "vpub", "svdraft", "svapp", "evver", "svdev", "lev", "bdev", "bvar", "svpack", "nverror", "wdevice", "svdb", "vserv", "vdd", "svneg", " vgd", "wdiv", "svver", "vprof", "hver", "vpack", "vde", "vev", " vrad", " vapp", "sverror", "bver", "wdev", "verror", "ivgd", "Vdev", "ivdevice", " vde", "nvdb", "svdevelopment", "wpub", "lserver", "evneg", " vdevelopment", "svprof", "ldd", "nvdev", "varerror", "lvpack", "vrad", "vdraft", "varserver", " vpack", "ldevice", "svserv", "lvapp", " vvar", "Vdiv", "Vpub", "nvev", "vgd", "wgd", " vver", "wde", "hev", "vver", "svserver", "vdevelopment", "vardraft", "hdev", "ivde", "vdiv", "lvdev", "bprof", "lrad", " vdd", "ldev", "ldb", "vdevice", "vdb", "wserv", "hneg", "svdiv", " vdevice", "svpub", "vserver", "vvar"], "nr": ["runner", "rr", "nl", "ru", "rid", "ni", "rc", "nov", "our", "nn", "ctr", "kr", "name", "range", "rn", "rg", "nb", "ner", "sr", "br", "nw", "inv", "np", "adr", "mr", "lr", "rb", "yr", "nc", "rin", "n", "nu", "nor", "number", "eni", "ng", "sn", "nt", "r", "NR", "no", "num", "rf", "nom", "nm", "wr", "err"], "bar": ["bug", "bridge", "way", "card", "show", "cart", "area", "ha", "ca", "allow", "array", "batch", "arrow", "worker", "home", "bad", "row", "er", "gap", "border", "cor", "progress", "Bar", "this", "browser", "user", "buffer", "project", "star", "comment", "bag", "error", "table", "br", "job", "server", "var", "google", "war", "request", "app", "group", "grid", "aer", "page", "b", "can", "car", "usa", "feature", "ab", "item", "block", "gar", "cat", "tab", "par", "ebin", "bg", "broad", "far", "org", "r", "db", "ga", "ar", "work", "ban", "cur", "order", "bars"]}}
{"project": "qemu", "commit_id": "babfa20ca4721e950d8096f32b1dc091763a8837", "target": 0, "func": "static bool ept_emulation_fault(uint64_t ept_qual)\n\n{\n\n    int read, write;\n\n\n\n    /* EPT fault on an instruction fetch doesn't make sense here */\n\n    if (ept_qual & EPT_VIOLATION_INST_FETCH) {\n\n        return false;\n\n    }\n\n\n\n    /* EPT fault must be a read fault or a write fault */\n\n    read = ept_qual & EPT_VIOLATION_DATA_READ ? 1 : 0;\n\n    write = ept_qual & EPT_VIOLATION_DATA_WRITE ? 1 : 0;\n\n    if ((read | write) == 0) {\n\n        return false;\n\n    }\n\n\n\n    /*\n\n     * The EPT violation must have been caused by accessing a\n\n     * guest-physical address that is a translation of a guest-linear\n\n     * address.\n\n     */\n\n    if ((ept_qual & EPT_VIOLATION_GLA_VALID) == 0 ||\n\n        (ept_qual & EPT_VIOLATION_XLAT_VALID) == 0) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16318, "substitutes": {"ept_qual": ["ester_qual", "ept__quality", "ept_deep", "eptalquality", "ep_component", "apt_quality", "ept_equal", "ep_quality", "ept_component", "ept_qualified", "apt_cert", "eff_quality", "ept_ident", "ept1component", "ept__cert", "ep_quant", "ept2component", "ester_deep", "ept__quick", "ept2qual", "eff_cert", "ester_quant", "ep2quant", "ept1quality", "ep2qual", "ept1qual", "ep_qual", "ept_quick", "ept_cert", "ept2quant", "eptalqual", "eptalcert", "eptalqualified", "ep2component", "ept2quality", "apt_quick", "eff_quick", "eff_qual", "ept_quant", "ester_quality", "apt_equal", "apt_ident", "apt_quant", "apt_qual", "ept__qual", "ep2quality", "ept_quality", "ept1quant", "apt_qualified"], "read": ["seek", "reading", "allow", "sync", "id", "i", "level", "child", "io", "ride", "name", "send", "use", "x", "raw", "update", "scan", "access", "w", "check", "pass", "view", "size", "open", "time", "resource", "boot", "data", "reader", "count", "play", "length", "add", "READ", "pair", "ip", "feed", "type", "create", "load", "Read", "lex", "work", "run", "index", "start"], "write": ["sync", "allow", "put", "memory", "name", "send", "use", "other", "unit", "update", "writer", "writing", "append", "key", "force", "drive", "output", "w", "vert", "Write", "size", "pipe", "enable", "wait", "note", "data", "n", "flow", "end", "text", "writ", "change", "network", "out", "fail", "written", "lock", "want", "index"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_X_c_template(SwsContext *c, const int16_t *lumFilter,\n\n                       const int32_t **lumSrc, int lumFilterSize,\n\n                       const int16_t *chrFilter, const int32_t **chrUSrc,\n\n                       const int32_t **chrVSrc, int chrFilterSize,\n\n                       const int32_t **alpSrc, uint16_t *dest, int dstW,\n\n                       int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int j;\n\n        int Y  = -0x40000000;\n\n        int U  = -128 << 23; // 19\n\n        int V  = -128 << 23;\n\n        int R, G, B;\n\n\n\n        for (j = 0; j < lumFilterSize; j++) {\n\n            Y += lumSrc[j][i]  * (unsigned)lumFilter[j];\n\n        }\n\n        for (j = 0; j < chrFilterSize; j++) {;\n\n            U += chrUSrc[j][i] * (unsigned)chrFilter[j];\n\n            V += chrVSrc[j][i] * (unsigned)chrFilter[j];\n\n        }\n\n\n\n        if (hasAlpha) {\n\n            A = -0x40000000;\n\n            for (j = 0; j < lumFilterSize; j++) {\n\n                A += alpSrc[j][i] * (unsigned)lumFilter[j];\n\n            }\n\n            A >>= 1;\n\n            A += 0x20002000;\n\n        }\n\n\n\n        // 8bit: 12+15=27; 16-bit: 12+19=31\n\n        Y  >>= 14; // 10\n\n        Y += 0x10000;\n\n        U  >>= 14;\n\n        V  >>= 14;\n\n\n\n        // 8bit: 27 -> 17bit, 16bit: 31 - 14 = 17bit\n\n        Y -= c->yuv2rgb_y_offset;\n\n        Y *= c->yuv2rgb_y_coeff;\n\n        Y += 1 << 13; // 21\n\n        // 8bit: 17 + 13bit = 30bit, 16bit: 17 + 13bit = 30bit\n\n\n\n        R = V * c->yuv2rgb_v2r_coeff;\n\n        G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n        B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n        // 8bit: 30 - 22 = 8bit, 16bit: 30bit - 14 = 16bit\n\n        output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n        output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n        output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n        if (eightbytes) {\n\n            output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n            dest += 4;\n\n        } else {\n\n            dest += 3;\n\n        }\n\n    }\n\n}\n", "idx": 16335, "substitutes": {"i": ["qi", "it", "ui", "m", "I", "d", "ni", "ai", "xi", "id", "l", "ini", "iu", "a", "gi", "io", "api", "iv", "oi", "ci", "ki", "h", "x", "di", "si", "ie", "init", "ii", "v", "uri", "o", "w", "yi", "z", "u", "p", "e", "ir", "info", "fi", "mi", "k", "li", "b", "ix", "n", "f", "phi", "ti", "ip", "c", "eni", "is", "jc", "ji", "pi", "q", "r", "bi", "ik", "ri", "ei", "ori", "ami", "zi", "y", "ij"], "j": ["jj", "uj", "jen", "it", "adj", "qi", "m", "ch", "ui", "aj", "d", "t", "ja", "jp", "l", "oj", "g", "er", "syn", "dj", "h", "x", "di", "jet", "js", "si", "ie", "ii", "key", "v", "br", "fr", "jam", "job", "o", "obj", "z", "u", "jit", "p", "e", "Ja", "not", "k", "li", "b", "ix", "n", "f", "json", "jo", "next", "jl", "block", "jc", "ji", "je", "q", "r", "J", "we", "el", "y", "ij"], "R": ["D", "T", "E", "RA", "I", "O", "N", "C", "Q", "S", "RR", "AR", "GR", "F", "A", "L", "UR", "W", "M", "K", "X", "r", "H", "Y", "J", "V", "GB", "SR", "U", "P"], "G": ["D", "VG", "GL", "E", "I", "LG", "GD", "C", "Q", "N", "g", "S", "GG", "GR", "F", "A", "BG", "L", "SG", "RG", "W", "M", "K", "GE", "GV", "H", "Y", "J", "V", "GB", "Gs", "U", "P"], "B": ["D", "T", "BO", "E", "BA", "BS", "O", "C", "AB", "BC", "AR", "F", "OB", "Bs", "b", "MB", "L", "NB", "BL", "W", "M", "WB", "SB", "PB", "BB", "H", "Y", "J", "V", "GB", "BI", "U", "Bi", "UB", "P", "DB"]}}
