{"project": "qemu", "commit_id": "cca1af8c4d2ef6449fd61494ba2cb087b838011c", "target": 1, "func": "static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args,\n\n                            int opc)\n\n{\n\n    int addr_regl, addr_reg1, addr_meml;\n\n    int data_regl, data_regh, data_reg1, data_reg2;\n\n    int mem_index, s_bits;\n\n#if defined(CONFIG_SOFTMMU)\n\n    void *label1_ptr, *label2_ptr;\n\n    int sp_args;\n\n#endif\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(CONFIG_SOFTMMU)\n\n    uint8_t *label3_ptr;\n\n# endif\n\n    int addr_regh, addr_reg2, addr_memh;\n\n#endif\n\n    data_regl = *args++;\n\n    if (opc == 3)\n\n        data_regh = *args++;\n\n    else\n\n        data_regh = 0;\n\n    addr_regl = *args++;\n\n#if TARGET_LONG_BITS == 64\n\n    addr_regh = *args++;\n\n#endif\n\n    mem_index = *args;\n\n    s_bits = opc & 3;\n\n\n\n    if (opc == 3) {\n\n#if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n        data_reg1 = data_regh;\n\n        data_reg2 = data_regl;\n\n#else\n\n        data_reg1 = data_regl;\n\n        data_reg2 = data_regh;\n\n#endif\n\n    } else {\n\n        data_reg1 = data_regl;\n\n        data_reg2 = 0;\n\n    }\n\n#if TARGET_LONG_BITS == 64\n\n# if defined(TCG_TARGET_WORDS_BIGENDIAN)\n\n    addr_reg1 = addr_regh;\n\n    addr_reg2 = addr_regl;\n\n    addr_memh = 0;\n\n    addr_meml = 4;\n\n# else\n\n    addr_reg1 = addr_regl;\n\n    addr_reg2 = addr_regh;\n\n    addr_memh = 4;\n\n    addr_meml = 0;\n\n# endif\n\n#else\n\n    addr_reg1 = addr_regl;\n\n    addr_meml = 0;\n\n#endif\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    tcg_out_opc_sa(s, OPC_SRL, TCG_REG_A0, addr_regl, TARGET_PAGE_BITS - CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_imm(s, OPC_ANDI, TCG_REG_A0, TCG_REG_A0, (CPU_TLB_SIZE - 1) << CPU_TLB_ENTRY_BITS);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_A0, TCG_REG_A0, TCG_AREG0);\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_meml);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T0, TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n    tcg_out_opc_reg(s, OPC_AND, TCG_REG_T0, TCG_REG_T0, addr_regl);\n\n\n\n# if TARGET_LONG_BITS == 64\n\n    label3_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BNE, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_AT, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addr_read) + addr_memh);\n\n\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, addr_regh, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n\n\n    reloc_pc16(label3_ptr, (tcg_target_long) s->code_ptr);\n\n# else\n\n    label1_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_T0, TCG_REG_AT, 0);\n\n    tcg_out_nop(s);\n\n# endif\n\n\n\n    /* slow path */\n\n    sp_args = TCG_REG_A0;\n\n    tcg_out_mov(s, sp_args++, addr_reg1);\n\n# if TARGET_LONG_BITS == 64\n\n    tcg_out_mov(s, sp_args++, addr_reg2);\n\n# endif\n\n    tcg_out_movi(s, TCG_TYPE_I32, sp_args++, mem_index);\n\n    tcg_out_movi(s, TCG_TYPE_I32, TCG_REG_T9, (tcg_target_long)qemu_ld_helpers[s_bits]);\n\n    tcg_out_opc_reg(s, OPC_JALR, TCG_REG_RA, TCG_REG_T9, 0);\n\n    tcg_out_nop(s);\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xff);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 24);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 24);\n\n        break;\n\n    case 1:\n\n        tcg_out_opc_imm(s, OPC_ANDI, data_reg1, TCG_REG_V0, 0xffff);\n\n        break;\n\n    case 1 | 4:\n\n        tcg_out_opc_sa(s, OPC_SLL, TCG_REG_V0, TCG_REG_V0, 16);\n\n        tcg_out_opc_sa(s, OPC_SRA, data_reg1, TCG_REG_V0, 16);\n\n        break;\n\n    case 2:\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    case 3:\n\n        tcg_out_mov(s, data_reg2, TCG_REG_V1);\n\n        tcg_out_mov(s, data_reg1, TCG_REG_V0);\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n    label2_ptr = s->code_ptr;\n\n    tcg_out_opc_imm(s, OPC_BEQ, TCG_REG_ZERO, TCG_REG_ZERO, 0);\n\n    tcg_out_nop(s);\n\n\n\n    /* label1: fast path */\n\n    reloc_pc16(label1_ptr, (tcg_target_long) s->code_ptr);\n\n\n\n    tcg_out_opc_imm(s, OPC_LW, TCG_REG_V0, TCG_REG_A0,\n\n                    offsetof(CPUState, tlb_table[mem_index][0].addend) + addr_meml);\n\n    tcg_out_opc_reg(s, OPC_ADDU, TCG_REG_V0, TCG_REG_V0, addr_regl);\n\n\n\n    addr_reg1 = TCG_REG_V0;\n\n#endif\n\n\n\n    switch(opc) {\n\n    case 0:\n\n        tcg_out_opc_imm(s, OPC_LBU, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 0 | 4:\n\n        tcg_out_opc_imm(s, OPC_LB, data_reg1, addr_reg1, 0);\n\n        break;\n\n    case 1:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LHU, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 1 | 4:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LHU, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap16s(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LH, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 2:\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n        }\n\n        break;\n\n    case 3:\n\n#if !defined(CONFIG_SOFTMMU)\n\n        tcg_out_mov(s, TCG_REG_V0, addr_reg1);\n\n        addr_reg1 = TCG_REG_V0;\n\n#endif\n\n        if (TCG_NEED_BSWAP) {\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 4);\n\n            tcg_out_bswap32(s, data_reg1, TCG_REG_T0);\n\n            tcg_out_opc_imm(s, OPC_LW, TCG_REG_T0, addr_reg1, 0);\n\n            tcg_out_bswap32(s, data_reg2, TCG_REG_T0);\n\n        } else {\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg1, addr_reg1, 0);\n\n            tcg_out_opc_imm(s, OPC_LW, data_reg2, addr_reg1, 4);\n\n        }\n\n        break;\n\n    default:\n\n        tcg_abort();\n\n    }\n\n\n\n#if defined(CONFIG_SOFTMMU)\n\n    reloc_pc16(label2_ptr, (tcg_target_long) s->code_ptr);\n\n#endif\n\n}\n", "idx": 16352, "substitutes": {"s": ["ns", "spec", "m", "ts", "t", "stats", "f", "settings", "services", "service", "r", "n", "g", "i", "sec", "fs", "o", "cs", "w", "qs", "e", "ssl", "ses", "sync", "private", "js", "c", "sym", "p", "support", "S", "secondary", "b", "sys", "u", "h", "a", "os", "groups", "sets", "south", "sq", "ds", "sf"], "args": ["GS", "ns", "ans", "limits", "init", "func", "aws", "ras", "call", "fields", "all", "reg", "results", "vals", "ams", "yrs", "ys", "loc", "points", "Arg", "items", "sec", "ass", "arr", "enc", "arg", "cs", "orders", "axis", "size", "ins", "aux", "ig", "blocks", "config", "qs", "asm", "ars", "alls", "uments", "bits", "atts", "argument", "doc", "ks", "ids", "gs", "alloc", " arguments", "arms", "bytes", "parts", "addr", "flags", "lang", "groups", "Args", "params", "conn", "ds"], "opc": ["opf", "OPct", "copc", "copcu", "ropct", "copct", " opf", "opci", "OPpc", "coplc", "oppc", "ropcu", " opcs", "opercu", "opcu", "ppci", "optc", "opcs", "operct", "coppc", "copf", "oplc", "opdc", "optct", "OPci", "opct", " opci", "OPc", "OPlc", " opct", "ppcs", "optcs", "optf", "operc", "OPf", "copdc", "OPcs", "operdc", "ropdc", "ropc", " oplc", "ppc", " oppc", "pppc"], "addr_regl": ["addr_rems", "addr_registerc", "addr_rigsl", "addr_regb", "addr_memul", "addr_registern", "addr_servs", "addr_reml", "addr_rec2", "addr_REGb", "addr_rig2", "addr_regc", "addr_refc", "addr_memg", "addr_recl", "addr_recg", "addr_regg", "addr_regnl", "addr_rigb", "addr_regL", "addr_registerul", "addr_reL", "addr_memsl", "addr_reg", "addr_regsl", "addr_rigl", "addr_reb", "addr_memL", "addr_refg", "addr_REG2", "addr_regn", "addr_serv2", "addr_mems", "addr_rel", "addr_regul", "addr_memnl", "addr_REGsl", "addr_recnl", "addr_refl", "addr_ref2", "addr_servl", "addr_REGl", "addr_servnl", "addr_re2", "addr_refs", "addr_mem2", "addr_reful", "addr_registerl", "addr_refn", "addr_REGs", "addr_memn", "addr_recs", "addr_remL", "addr_regs", "addr_REGg", "addr_rem2", "addr_res", "addr_memb", "addr_memc"], "addr_reg1": ["addr_gregr", "addr_recl", "addr_greg5", "addr_recr", "addr_REG2", "addr_regn", "addr_rec0", "addr_REG0", "addr_loc2", "addr_loc5", "addr_REG1", "addr_orig5", "addr_registern", "addr_loc0", "addr_recS", "addr_registerS", "addr_greg1", "addr_recn", "addr_struct1", "addr_gregN", "addr_register1", "addr_rec2", "addr_reg5", "addr_locN", "addr_register2", "addr_origN", "addr_regN", "addr_structn", "addr_REGr", "addr_structS", "addr_struct2", "addr_orig1", "addr_REGl", "addr_locl", "addr_rec1", "addr_greg2", "addr_reg0", "addr_gregl", "addr_loc1", "addr_origl", "addr_regr", "addr_regS"], "addr_meml": ["addr_regli", "addr_memd", "addr_regb", "addr_memp", "addr_memel", "addr_servs", "addr_laml", "addr_reml", "addr_threadp", "addr_regd", "addr_ramh", "addr_memli", "addr_servlc", "addr_morphl", "addr_regkl", "addr_ramb", "addr_morphkl", "addr_servli", "addr_limel", "addr_remb", "addr_reglc", "addr_limc", "addr_memkl", "addr_regp", "addr_lamb", "addr_morphll", "addr_memll", "addr_remc", "addr_mems", "addr_threadll", "addr_liml", "addr_lamel", "addr_lamd", "addr_raml", "addr_REGlc", "addr_servl", "addr_REGl", "addr_limd", "addr_ramc", "addr_morphp", "addr_REGli", "addr_REGs", "addr_limb", "addr_remh", "addr_memlc", "addr_regs", "addr_threadl", "addr_regel", "addr_limh", "addr_threadkl", "addr_regll", "addr_memb", "addr_memc"], "data_regl": ["data_regdl", "data_struct2", "data_resd", "data_regn", "data_REGd", "data_core2", "data_raclate", "data_rec2", "data_racn", "data_retli", "data_recn", "data_memr", "data_structL", "data_regL", "data_REGl", "data_corelate", "data_resl", "data_recli", "data_recdl", "data_recL", "data_structr", "data_REGlate", "data_racl", "data_recs", "data_racli", "data_REGs", "data_coreli", "data_retl", "data_mems", "data_regli", "data_structl", "data_REGli", "data_racs", "data_structs", "data_rets", "data_memdl", "data_REG2", "data_retn", "data_reglate", "data_memL", "data_regr", "data_structdl", "data_recd", "data_recl", "data_regd", "data_meml", "data_regs", "data_corel", "data_rac2", "data_res2", "data_ress", "data_mem2", "data_recr"], "data_regh": ["data_rehl", "data_pregin", "data_reggg", "data_refgin", "data_reghl", "data_recgg", "data_rebgh", "data_reh", "data_rebgin", "data_rebgg", "data_refgo", "data_creigh", "data_cregh", "data_gregg", "data_reigh", "data_recgin", "data_preck", "data_cregin", "data_regg", "data_reggh", "data_resgh", "data_regin", "data_greigh", "data_greck", "data_resgg", "data_recgh", "data_rebhl", "data_rengg", "data_prego", "data_gregin", "data_cregg", "data_gregh", "data_greh", "data_renck", "data_resgin", "data_reggin", "data_pregg", "data_recigh", "data_rugh", "data_resh", "data_pregh", "data_refgh", "data_preigh", "data_rego", "data_ruh", "data_rugg", "data_rechl", "data_reck", "data_refigh", "data_rengin", "data_recgo", "data_rengh", "data_rugin"], "data_reg1": ["data_rule6", "data_register01", "data_REGl", "data_rulel", "data_tag01", "data_tagone", "data_log81", "data_recone", "data_modb", "data_reg01", "data_register2", "data_recb", "data_recl", "data_REG1", "data_regb", "data_rec6", "data_rel", "data_REGb", "data_rec2", "data_rule2", "data_rec1", "data_re1", "data_mod1", "data_tag1", "data_rule1", "data_tag2", "data_register1", "data_re2", "data_REG6", "data_mod2", "data_rec81", "data_REG2", "data_reg6", "data_reg81", "data_modl", "data_log2", "data_rec01", "data_registerone", "data_regone", "data_logl", "data_re81", "data_log1"], "data_reg2": ["data_greg1", "data_REGl", "data_gregl", "data_memb", "data_reg0", "data_grl", "data_REG0", "data_register2", "data_register0", "data_regu", "data_recb", "data_recl", "data_REG1", "data_mem1", "data_regb", "data_meml", "data_greg2", "data_rel", "data_REGb", "data_rec2", "data_re1", "data_rec1", "data_gr62", "data_mod1", "data_reg62", "data_REGL", "data_recL", "data_registerL", "data_modu", "data_register1", "data_gr1", "data_re2", "data_gr2", "data_recu", "data_mod2", "data_gregu", "data_mem2", "data_REG2", "data_rec0", "data_modl", "data_rec62", "data_regL", "data_re62"], "mem_index": ["byteaclen", "mem__index", "mem_ind", "byteacindex", "alloc_ind", "memaclength", "mem_count", "mem_length", "mem__length", "alloc_index", "memrindex", "byteaclength", "memrcount", "byte_list", "mem__len", "alloc_count", "byteaclist", "memaclist", "allocfindex", "byte_length", "allocfind", "memfind", "mem_len", "memaclen", "mem__list", "memfindex", "memacindex", "mem_list", "memfcount", "allocfcount", "memrind", "byte_index", "byte_len"], "s_bits": ["s__bytes", "s_bit", "d_ops", "s__parts", "s__ops", "s_bytes", "s__bits", "d_bits", "s_ops", "s_locks", "p_bytes", "s__locks", "d_bytes", "p_bit", "p_locks", "s__bit", "s_parts", "d_parts", "p_bits"], "label1_ptr": ["label2_dr", "label2_pointer", "label1_tr", "label1_pointer", "label2_tr", "label1_dr"], "label2_ptr": ["label02_dr", "label2_dr", "label02_pointer", "label02_ptr", "label02_tr", "label2_pointer", "label2_tr"], "sp_args": ["sp__len", "sp_len", " sp2args", " sp_lang", "sp_lang", " sp2len", "sp2arg", "sp__args", "sp__arg", "sp2args", " sp_arg", "sp2len", " sp2lang", "sp_arg", "sp2lang", " sp2arg", " sp_len", "sp__lang"], "label3_ptr": ["label3_pointer", "label3_tr", "label3_inter", "label1_inter", "label1_tr", "label1_pointer"], "addr_regh": ["addr_resq", "addr_recg", "addr_req", "addr_regg", "addr_reggin", "addr_reggy", "addr_prehs", "addr_reshs", "addr_pregin", "addr_mergh", "addr_recgh", "addr_reggh", "addr_prego", "addr_syngy", "addr_preg", "addr_rego", "addr_pregg", "addr_mergg", "addr_merhs", "addr_syngg", "addr_merq", "addr_resgh", "addr_preq", "addr_synga", "addr_reggg", "addr_reg", "addr_cachegg", "addr_regin", "addr_rega", "addr_syngh", "addr_rehs", "addr_pregh", "addr_reggo", "addr_recgo", "addr_cachega", "addr_recgg", "addr_regy", "addr_resgg", "addr_recgin", "addr_cachegh", "addr_cachegy", "addr_regga"], "addr_reg2": ["addr_recl", "addr_res8", "addrPrg1", "addr_REG2", "addrPrg62", "addrPreg2", "addrPreg1", "addr_regall", "addr_reg8", "addr_blocksl", "addr_REG1", "addr_res1", "addr_reg22", "addr_rec22", "addr_greg22", "addr_origall", "addr_rg8", "addr_greg1", "addr_reg62", "addr_origsl", "addr_res62", "addr_rg1", "addr_recsl", "addr_blockall", "addr_res2", "addr_rec2", "addrPrg8", "addrPrg2", "addr_REG22", "addr_regsl", "addr_rg2", "addr_orig2", "addr_blockl", "addr_rec62", "addr_REGl", "addr_rg62", "addrPreg62", "addr_block2", "addr_rec1", "addr_greg2", "addr_rec8", "addr_gregl", "addr_origl", "addr_recall", "addrPreg8"], "addr_memh": ["addr_reten", "addr_reth", "addr_graml", "addr_gramle", "addr_mopl", "addr_gramul", "addr_memul", "addr_ramb", "addr_regr", "addr_memel", "addr_ramen", "addr_memen", "addr_limr", "addr_regul", "addr_liml", "addr_limel", "addr_retl", "addr_raml", "addr_moph", "addr_gramh", "addr_memr", "addr_regel", "addr_regle", "addr_retb", "addr_limh", "addr_mopr", "addr_memle", "addr_memb", "addr_mopel", "addr_ramh"]}}
{"project": "qemu", "commit_id": "9ecaa27e7123211f45ca723a736ffae14f6c1f42", "target": 1, "func": "static void dec_calc(DisasContext *dc, uint32_t insn)\n\n{\n\n    uint32_t op0, op1, op2;\n\n    uint32_t ra, rb, rd;\n\n    op0 = extract32(insn, 0, 4);\n\n    op1 = extract32(insn, 8, 2);\n\n    op2 = extract32(insn, 6, 2);\n\n    ra = extract32(insn, 16, 5);\n\n    rb = extract32(insn, 11, 5);\n\n    rd = extract32(insn, 21, 5);\n\n\n\n    switch (op0) {\n\n    case 0x0000:\n\n        switch (op1) {\n\n        case 0x00:    /* l.add */\n\n            LOG_DIS(\"l.add r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0001:    /* l.addc */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.addc r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 tcy = tcg_temp_local_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_cy = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_andi_i32(sr_cy, cpu_sr, SR_CY);\n\n                tcg_gen_extu_i32_i64(tcy, sr_cy);\n\n                tcg_gen_shri_i64(tcy, tcy, 10);\n\n                tcg_gen_add_i64(td, ta, tb);\n\n                tcg_gen_add_i64(td, td, tcy);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 32);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(tcy);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_cy);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0002:    /* l.sub */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.sub r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv_i64 ta = tcg_temp_new_i64();\n\n                TCGv_i64 tb = tcg_temp_new_i64();\n\n                TCGv_i64 td = tcg_temp_local_new_i64();\n\n                TCGv_i32 res = tcg_temp_local_new_i32();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n\n\n                tcg_gen_extu_i32_i64(ta, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(tb, cpu_R[rb]);\n\n                tcg_gen_sub_i64(td, ta, tb);\n\n                tcg_gen_extrl_i64_i32(res, td);\n\n                tcg_gen_shri_i64(td, td, 31);\n\n                tcg_gen_andi_i64(td, td, 0x3);\n\n                /* Jump to lab when no overflow.  */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x0, lab);\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, td, 0x3, lab);\n\n                tcg_gen_ori_i32(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_i32(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_i32(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_i32(cpu_R[rd], res);\n\n                tcg_temp_free_i64(ta);\n\n                tcg_temp_free_i64(tb);\n\n                tcg_temp_free_i64(td);\n\n                tcg_temp_free_i32(res);\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0003:    /* l.and */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.and r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_and_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0004:    /* l.or */\n\n        switch (op1) {\n\n        case 0x00:\n\n            LOG_DIS(\"l.or r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_or_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0005:\n\n        switch (op1) {\n\n        case 0x00:    /* l.xor */\n\n            LOG_DIS(\"l.xor r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_xor_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0006:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mul */\n\n            LOG_DIS(\"l.mul r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (ra != 0 && rb != 0) {\n\n                gen_helper_mul32(cpu_R[rd], cpu_env, cpu_R[ra], cpu_R[rb]);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0x0);\n\n            }\n\n            break;\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0009:\n\n        switch (op1) {\n\n        case 0x03:    /* l.div */\n\n            LOG_DIS(\"l.div r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGLabel *lab3 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[ra],\n\n                                       0x80000000, lab2);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0xffffffff, lab2);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab3);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab2);\n\n                    tcg_gen_div_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab3);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000a:\n\n        switch (op1) {\n\n        case 0x03:    /* l.divu */\n\n            LOG_DIS(\"l.divu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab0 = gen_new_label();\n\n                TCGLabel *lab1 = gen_new_label();\n\n                TCGLabel *lab2 = gen_new_label();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                if (rb == 0) {\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab0);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab0);\n\n                } else {\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, cpu_R[rb],\n\n                                       0x00000000, lab1);\n\n                    tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                    tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                    tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab2);\n\n                    gen_exception(dc, EXCP_RANGE);\n\n                    gen_set_label(lab1);\n\n                    tcg_gen_divu_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                    gen_set_label(lab2);\n\n                }\n\n                tcg_temp_free_i32(sr_ove);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000b:\n\n        switch (op1) {\n\n        case 0x03:    /* l.mulu */\n\n            LOG_DIS(\"l.mulu r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            if (rb != 0 && ra != 0) {\n\n                TCGv_i64 result = tcg_temp_local_new_i64();\n\n                TCGv_i64 tra = tcg_temp_local_new_i64();\n\n                TCGv_i64 trb = tcg_temp_local_new_i64();\n\n                TCGv_i64 high = tcg_temp_new_i64();\n\n                TCGv_i32 sr_ove = tcg_temp_local_new_i32();\n\n                TCGLabel *lab = gen_new_label();\n\n                /* Calculate each result. */\n\n                tcg_gen_extu_i32_i64(tra, cpu_R[ra]);\n\n                tcg_gen_extu_i32_i64(trb, cpu_R[rb]);\n\n                tcg_gen_mul_i64(result, tra, trb);\n\n                tcg_temp_free_i64(tra);\n\n                tcg_temp_free_i64(trb);\n\n                tcg_gen_shri_i64(high, result, TARGET_LONG_BITS);\n\n                /* Overflow or not. */\n\n                tcg_gen_brcondi_i64(TCG_COND_EQ, high, 0x00000000, lab);\n\n                tcg_gen_ori_tl(cpu_sr, cpu_sr, (SR_OV | SR_CY));\n\n                tcg_gen_andi_tl(sr_ove, cpu_sr, SR_OVE);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_ove, SR_OVE, lab);\n\n                gen_exception(dc, EXCP_RANGE);\n\n                gen_set_label(lab);\n\n                tcg_temp_free_i64(high);\n\n                tcg_gen_trunc_i64_tl(cpu_R[rd], result);\n\n                tcg_temp_free_i64(result);\n\n                tcg_temp_free_i32(sr_ove);\n\n            } else {\n\n                tcg_gen_movi_tl(cpu_R[rd], 0);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000e:\n\n        switch (op1) {\n\n        case 0x00:    /* l.cmov */\n\n            LOG_DIS(\"l.cmov r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            {\n\n                TCGLabel *lab = gen_new_label();\n\n                TCGv res = tcg_temp_local_new();\n\n                TCGv sr_f = tcg_temp_new();\n\n                tcg_gen_andi_tl(sr_f, cpu_sr, SR_F);\n\n                tcg_gen_mov_tl(res, cpu_R[rb]);\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, sr_f, SR_F, lab);\n\n                tcg_gen_mov_tl(res, cpu_R[ra]);\n\n                gen_set_label(lab);\n\n                tcg_gen_mov_tl(cpu_R[rd], res);\n\n                tcg_temp_free(sr_f);\n\n                tcg_temp_free(res);\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000f:\n\n        switch (op1) {\n\n        case 0x00:    /* l.ff1 */\n\n            LOG_DIS(\"l.ff1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_ctzi_tl(cpu_R[rd], cpu_R[ra], -1);\n\n            tcg_gen_addi_tl(cpu_R[rd], cpu_R[rd], 1);\n\n            break;\n\n        case 0x01:    /* l.fl1 */\n\n            LOG_DIS(\"l.fl1 r%d, r%d, r%d\\n\", rd, ra, rb);\n\n            tcg_gen_clzi_tl(cpu_R[rd], cpu_R[ra], TARGET_LONG_BITS);\n\n            tcg_gen_subfi_tl(cpu_R[rd], TARGET_LONG_BITS, cpu_R[rd]);\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x0008:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.sll */\n\n                LOG_DIS(\"l.sll r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shl_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x01:    /* l.srl */\n\n                LOG_DIS(\"l.srl r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_shr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x02:    /* l.sra */\n\n                LOG_DIS(\"l.sra r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_sar_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n            case 0x03:    /* l.ror */\n\n                LOG_DIS(\"l.ror r%d, r%d, r%d\\n\", rd, ra, rb);\n\n                tcg_gen_rotr_tl(cpu_R[rd], cpu_R[ra], cpu_R[rb]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000c:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.exths */\n\n                LOG_DIS(\"l.exths r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extbs */\n\n                LOG_DIS(\"l.extbs r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x02:    /* l.exthz */\n\n                LOG_DIS(\"l.exthz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext16u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x03:    /* l.extbz */\n\n                LOG_DIS(\"l.extbz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext8u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    case 0x000d:\n\n        switch (op1) {\n\n        case 0x00:\n\n            switch (op2) {\n\n            case 0x00:    /* l.extws */\n\n                LOG_DIS(\"l.extws r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32s_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n            case 0x01:    /* l.extwz */\n\n                LOG_DIS(\"l.extwz r%d, r%d\\n\", rd, ra);\n\n                tcg_gen_ext32u_tl(cpu_R[rd], cpu_R[ra]);\n\n                break;\n\n\n\n            default:\n\n                gen_illegal_exception(dc);\n\n                break;\n\n            }\n\n            break;\n\n\n\n        default:\n\n            gen_illegal_exception(dc);\n\n            break;\n\n        }\n\n        break;\n\n\n\n    default:\n\n        gen_illegal_exception(dc);\n\n        break;\n\n    }\n\n}\n", "idx": 16360, "substitutes": {"dc": ["oc", "pc", "jc", "cdn", "irc", "ct", "rc", "bc", "fc", "mc", "enc", "nc", "ac", "oci", "DC", "tc", "xc", "dm", "sc", "cam", "lc", "da", "uc", "cd", "icc", "isc", "cc"], "insn": [" insne", "exn", "inne", "issc", "incb", "inn", "inb", "atsn", "insnan", "innt", "itsc", "lsconn", "linb", "inl", "linssn", "exsn", "inc", "issb", "exc", "itsne", "lsn", "linc", "insb", "itsb", "ksc", "intsn", "ind", "insd", "itsn", "insc", "insne", "issn", "atsd", " insl", "insl", "ksnt", "intsp", " inssn", "intsne", " insp", "linn", "inp", "intsl", "incc", "insconn", "linsd", "linsn", "lsne", "inssn", "insnt", "issne", "atssn", "ksn", "inconn", "lsb", "atsnt", "innan", "ksne", "lsc", "incconn", " insc", " insnan", "incn", "insp", "linsnt", "issnt", "linnt", "exnan"], "op0": [" op3", "oper0", "opt0", "hop4", "opt3", "hop0", "OP3", "opt1", "hop2", " op6", "oper4", " op4", "op4", "oper6", "op3", "opt2", "OP0", "hop6", "oper2", "OP2", "OP1", "op6"], "op1": ["cop3", " op3", "opt01", "hop4", "OP01", "cop2", "cop1", "cop4", "oper3", "opt3", "hop2", "OP3", "opt1", "hop1", "op01", "oper1", " op4", "op4", "op3", "opt2", " op01", "cop01", "OP2", "oper2", "OP1", "hop01", "oper01"], "op2": ["cop3", " op3", "oper0", "hop4", "cop2", "cop1", "cop4", "hop0", "hop2", "OP3", " op32", "oper4", "hop32", "oper32", " op4", "op4", "op3", "op32", "OP4", "oper2", "OP2", "OP1"], "ra": ["dra", "na", "rr", "au", "ira", "rs", "ras", "ara", "rc", "r", "from", "rt", "ro", "ar", "rad", "oa", "rg", "min", "stra", "ba", "ca", "po", "ta", "up", "RA", "tra", "rar", "ru", "ria", "tar", "sr", "pa", "cr", "gra", "ka", "da", "ri", "area", "ada", "va", "la", "wa", "a", "rap", "ia", "ma", "ina", "alpha", "ran", "sa", "Ra"], "rb": ["rx", "RB", "ab", "rr", "db", "rs", "vr", "rc", "r", "reb", "rid", "rt", "rm", "sb", "cb", "ril", "usr", "rh", "wb", "rg", "pb", "lb", "rf", "rab", "gb", "rob", "nr", "bf", "rar", "ru", "rn", "sr", "ruby", "raf", "fb", "lr", "cr", "rl", "ri", "rw", "b", "adr", "erb"], "rd": ["rx", "dra", "rr", "dd", "rs", "vr", "ras", "td", "rc", "r", "rid", "rm", "rt", "RF", "rh", "rg", "ld", "rf", "rod", "RR", "d", "rob", "nr", "rar", "ru", "rn", "sr", "dr", "fd", "lr", "cr", "rl", "ri", "rw", "rss", "rera", "RD", "adr"], "lab": ["ab", "eb", "db", "pub", "las", "ref", "obj", "ob", "td", "train", "reg", "lit", "fe", "pl", "LAB", "cb", "loc", "node", "msg", "ls", "ctx", "pb", "cz", "lb", "ld", "nb", "abc", "Lab", "label", "ca", "lf", "tab", "home", "gb", "inf", "cel", "Label", "sc", "bl", "fb", "lam", "lc", "bg", "lib", "line", "col", "la", "cell", "AB", "local", "lang", "leg"]}}
{"project": "qemu", "commit_id": "225d02cd1a34d5d87e8acefbf8e244a5d12f5f8c", "target": 1, "func": "int qemu_calculate_timeout(void)\n\n{\n\n#ifndef CONFIG_IOTHREAD\n\n    int timeout;\n\n\n\n    if (!vm_running)\n\n        timeout = 5000;\n\n    else {\n\n     /* XXX: use timeout computed from timers */\n\n        int64_t add;\n\n        int64_t delta;\n\n        /* Advance virtual time to the next event.  */\n\n\tdelta = qemu_icount_delta();\n\n        if (delta > 0) {\n\n            /* If virtual time is ahead of real time then just\n\n               wait for IO.  */\n\n            timeout = (delta + 999999) / 1000000;\n\n        } else {\n\n            /* Wait for either IO to occur or the next\n\n               timer event.  */\n\n            add = qemu_next_deadline();\n\n            /* We advance the timer before checking for IO.\n\n               Limit the amount we advance so that early IO\n\n               activity won't get the guest too far ahead.  */\n\n            if (add > 10000000)\n\n                add = 10000000;\n\n            delta += add;\n\n            qemu_icount += qemu_icount_round (add);\n\n            timeout = delta / 1000000;\n\n            if (timeout < 0)\n\n                timeout = 0;\n\n        }\n\n    }\n\n\n\n    return timeout;\n\n#else /* CONFIG_IOTHREAD */\n\n    return 1000;\n\n#endif\n\n}\n", "idx": 16365, "substitutes": {"timeout": ["offset", "outer", "global", "time", "interrupted", "init", "cookie", "call", "buffer", "scroll", "service", "io", "duration", "money", "try", "wait", "window", "root", "type", "max", "trial", "this", "count", "out", "vm", "always", "slot", "size", "event", "socket", "fail", "ticket", "length", "tc", "delay", "limit", "Timeout", "start", "sync", "span", "temp", "unit", "latest", "cache", "fee", "null", "missing", "error", "timer", "append", "period", "clock", "number", "connection", "port", "server", "command", "value", "sleep"], "add": ["set", "enable", "dd", "extra", "mod", "skip", "sleep", "data", "push", "base", "call", "ctl", "name", "plus", "ix", "apply", "inc", "wait", "num", "max", "date", "count", "create", "added", "load", "d", "change", "parse", "new", "cost", "ADD", "ac", "build", "and", "event", "ad", "start", "delay", "id", "send", "sync", "update", "post", "pad", "address", "depth", "append", "Add", "next", "number", "addr", "end", "diff"], "delta": ["dadd", "dta", "delt", "ddetime", "zta", "adelt", "adelta", "rdelt", "sday", "Delt", "ddDelta", "Dota", " day", "dyota", "detime", " dition", "cdelta", "adada", "dyelta", "ddadd", "zelt", "Delta", "dition", "dota", "ddta", "dada", "day", " detime", "dyition", "ddelta", "cdta", "sdelta", "rdadd", "aday", " dta", "zota", "rdelta", "sdota", "ddota", "ddelt", "dyetime", " dadd", "cdada", "cdota", "sdelt", "adota", "dDelta", "sdDelta", "rdta", "DDelta", " delt", "cdelt", "ddition", "zelta", "adta", " dota", " dada"]}}
{"project": "FFmpeg", "commit_id": "e1fb3143bb3a6006612fe0e1d1a15c8eb4955802", "target": 1, "func": "static int ftp_abort(URLContext *h)\n\n{\n\n    static const char *command = \"ABOR\\r\\n\";\n\n    int err;\n\n    static const int abor_codes[] = {225, 226, 0};\n\n    FTPContext *s = h->priv_data;\n\n\n\n    /* According to RCF 959:\n\n       \"ABOR command tells the server to abort the previous FTP\n\n       service command and any associated transfer of data.\"\n\n\n\n       There are FTP server implementations that don't response\n\n       to any commands during data transfer in passive mode (including ABOR).\n\n\n\n       This implementation closes data connection by force.\n\n    */\n\n\n\n    if (ftp_send_command(s, command, NULL, NULL) < 0) {\n\n        ftp_close_both_connections(s);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    } else {\n\n        ftp_close_data_connection(s);\n\n    }\n\n\n\n    if (ftp_status(s, NULL, abor_codes) < 225) {\n\n        /* wu-ftpd also closes control connection after data connection closing */\n\n        ffurl_closep(&s->conn_control);\n\n        if ((err = ftp_connect_control_connection(h)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Reconnect failed.\\n\");\n\n            return err;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16370, "substitutes": {"h": ["m", "ch", "t", "eh", "f", "oh", "r", "hr", "dh", "gh", "g", "hi", "hd", "z", "rh", "auth", "hes", "th", "uh", "head", "host", "l", "d", "hw", "ht", "sh", "kh", "him", "ssh", "w", "hl", "id", "k", "e", "bh", "cl", "ih", "v", "c", "history", "hp", "p", "hm", "b", "http", "hh", "ph", "ha", "hs", "he", "hand", "ah", "H", "u"], "command": ["content", "code", "data", "name", "attribute", "comment", "service", "three", "document", "query", "communication", "method", "function", "raw", "timeout", "password", "execute", "exec", "database", "new", "zero", "prefix", "response", "Command", "which", "send", "handler", "c", "cmd", "resource", "sudo", "error", "a", "connection", "message", "sequence", "operation", "input"], "err": ["rr", "ner", "rage", "br", "user", "ah", "cor", "call", "all", "runner", "better", "r", "orer", " Err", "hr", "result", "str", "ar", " er", "far", "cb", "root", "nor", "rh", "var", "msg", "orig", "ie", "oller", "actor", "owner", "resp", "magic", "ise", "der", "act", "arr", "orr", "erer", "found", "nr", " error", "mr", "rag", "rar", "ev", "key", "ler", "e", "dr", "handler", "acer", "req", "erg", "temp", "dev", "ir", "off", "doc", "wr", "error", "Er", "er", "errors", "message", "iter", "Error", "order", "attr", "ver", "bug"], "abor_codes": ["abor_code", " arbitration_odes", "abor_count", "abor_sets", "abor_odes", " arbitration_code", " arbitration_coded", "aborrorcount", "oper_codes", "aborrorcodes", "oper_code", "oper_count", "aborrorsets", " arbitration_codes", "aborrorcode", "abor_coded", "oper_sets"], "s": ["ns", "m", "session", "sg", "ch", "t", "data", "rs", "x", "f", "settings", "shared", "service", "r", "n", "sb", "g", "sw", "sl", "cpp", "ss", "ls", "hes", "ops", "ctx", "xs", "is", "o", "cs", "l", "d", "sh", "ssh", "args", "qs", "e", "ssl", "sc", "ses", "sync", "cli", "c", "ps", "si", "js", "p", "S", "ks", "http", "b", "gs", "sys", "storage", "a", "es", "os", "us", "hs", "server", "se", "sq", "an", "sa", "ds", "u"]}}
{"project": "FFmpeg", "commit_id": "a4fec9a7eab842ea5eea1b1ee98624356cb31422", "target": 1, "func": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n    written++;\n    channel_id = hdr & 0x3F;\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;", "idx": 16385, "substitutes": {"h": ["m", "ch", "t", "eh", "f", "oh", "r", "hr", "g", "gh", "auth", "rh", "uh", "head", "host", "context", "d", "hw", "ht", "sh", "FH", "w", "hl", "img", "q", "e", "bh", "ih", "c", "hum", "history", "hp", "uc", "hm", "b", "http", "hh", "ph", "ha", "hs", "ah", "H", "u"], "p": ["pc", "m", "j", "t", "fp", "f", "r", "n", "pl", "i", "cp", "ap", "d", "pi", "w", "q", "e", "v", "c", "hp", "b", "ph", "tp", "port", "pt", "P", "u"], "chunk_size": ["chunk_small", "chunk4small", "chblock_ize", "chunk_ize", "chunk4capacity", "chblock_small", "chunk4ize", "chunk_capacity", "chblock_size", "chblock_capacity", "chunk4size"], "prev_pkt_ptr": ["prev_packet_pointer", "prev_pkt_handle", "prev_pkt_ref", "prev_packet_loc", "prev_pkt5handle", "prev_pkt5pointer", "prev_pkt_loc", "prev_pkt5ref", "prev_packet_ptr", "prev_pkt_tr", "prev_packet_handle", "prev_pkt5ptr", "prev_pkt_addr", "prev_packet_addr", "prev_pkt_pointer", "prev_packet_ref", "prev_packet_tr"], "nb_prev_pkt": ["nb_prev_ipk", "nb_prev_pct", "nb_prev_Pkt", "nb_prev_Packet", "nb_prev_mk", "nb_prev_macket", "nb_prev_pck", "nb_prev_peacket", "nb_prev_Pk", "nb_prev_Pck", "nb_prev_ptch", "nb_prev_Ptch", "nb_prev_packet", "nb_prev_mtch", "nb_prev_ipkt", "nb_prev_Pct", "nb_prev_mkt", "nb_prev_ipacket", "nb_prev_petch", "nb_prev_ipck", "nb_prev_pk", "nb_prev_pect", "nb_prev_pekt", "nb_prev_mck", "nb_prev_mct"], "hdr": ["shhr", "Hrt", "chvr", "Hird", "ohrt", "bhdr", " hr", "thrt", "hrt", "bhr", "shdi", "hr", "hDR", "hrc", "hdi", "Hdr", "chrid", "hhr", " hheader", "Hvr", " hird", "shrid", "thdr", "thDR", "hvr", "ohDR", " hrc", "third", "bhheader", " hhr", "shvr", "bhhr", "shDR", "ohdr", "phrt", "hird", "hhDR", "chdr", "hhheader", "hheader", " hDR", "hrid", "phheader", "hhrc", "phDR", "HDR", "Hrid", " hrt", "bhrc", "Hdi", "shdr", "hhdr", " hdi", "phdr", "chDR", "shr", "ohheader", "bhDR"], "buf": ["ab", "br", "vec", "cf", "fab", "pb", "cas", "gb", "feat", "box", "config", "buff", "comb", "pad", "opt", "loop", "bag", "cv", "bin", "txt", "pub", "ctr", "rc", "bc", "Buff", "cp", "msg", "done", "bed", "bf", "queue", "tmp", "uc", "ha", "port", "desc", "code", "fp", "f", "r", "cb", "block", "src", "loc", "wb", "mem", "home", "begin", "bu", "ru", "batch", "fb", "c", "b", "func", "data", "pool", "buffer", "uf", "ctx", "uh", "ba", "prop", "context", "header", "conv", "img", "bd", "fd", "bh", "cur", "rb", "seq", "cmd", "cmp", "cap", "proc", "usr"], "channel_id": ["channel2ids", "channel_name", "channel_uid", "error_ident", "channelOhead", "channel2id", "Channel_ids", "channel_size", " channel_number", "channelxnumber", "error_head", "channel_ident", "channelingid", "channel_info", "channel_ID", " channel_ids", "error_ID", "channelinglike", "channel33kid", "channel_Id", "channelPid", "channel33number", " channel_Id", "channel_kid", "channelxid", "channel2size", "channelingbase", "channelOident", "Channel_ident", "channelPids", " channel_ID", " channel_uid", " channel_base", "channel_number", "channel_head", "channel33id", " channel_like", "Channel_id", "channelOid", " channel_side", "channelxids", " channel_path", "channelingpath", "error_id", "channel2info", " channel_kid", "channelinguid", "channelPident", "channelxkid", "channel_like", "channel33ids", "channel_ids", " channel_size", "channel_type", "channelingids", "channel_side", " channel_info", " channel_name", " channel_type", "channelOID", "channel_path", "channel_base"], "timestamp": ["imetime", "timeeless", "imest", "timeetime", "typetime", "timest", "typeless", "timeest", "typest", "timeless", "timetime", "imestamp", "timeestamp", "typestamp", "imeless"], "size": ["made", "scale", "offset", "extra", "content", "capacity", "shape", "small", "data", "SIZE", "name", "time", "esc", "code", "confirmed", "sized", "channel", "max", "loc", "sec", "timeout", "exclusive", "count", "speed", "empty", "complete", "grade", "large", "ize", "length", "sync", "unit", "si", "needed", "address", "sent", "sum", "fee", "external", "form", "storage", "body", "weight", "bytes", "message", "write", "Size", "version", "len"], "ts_field": ["ts_layer", "tsxfield", "tsgfield", "ks_field", "tsmattag", "tx_num", "tsmatapi", "ps2layer", "tsuufield", "strings_spec", "ks_level", "ks_FIELD", "ps2flag", "tx_level", "tsmatfield", "tsuutag", "ps_len", "tsxbit", "tx_field", "tsmatspec", "tspnum", "strings_tag", "ts2len", "ts2layer", "ts_FIELD", "tsglevel", "tsxFIELD", "tspfield", "ps_flag", "ps2len", "ts_group", "tsuuapi", "tsuuspec", "ts_tag", "tsggroup", "ts_num", "strings_api", "tx_group", "ts_api", "ts_level", "ts__FIELD", "ps2field", "ks_bit", "tsgnum", "tspgroup", "tsxlevel", "ps_layer", "ps_field", "ts__field", "ts_spec", "ts_flag", "ts2field", "strings_field", "ts2flag", "ts__bit", "tsplevel", "ts_bit", "ts_len", "ts__level"], "type": ["types", "shape", "scale", "offset", "extra", "code", "t", "data", "info", "x", "name", "time", "op", "ping", "media", "platform", "action", "r", "pe", "file", "version", "family", "num", "option", "block", "kind", "pos", "related", "tag", "count", "object", "description", "pretty", "other", "val", "class", "title", "Type", "like", "event", "style", "format", "no", "length", "id", "key", "unit", "position", "TYPE", "off", "total", "resource", "error", "field", "number", "weight", "ty", "message", "state", "port", "value", "ype", "P", "typ"], "ret": ["rx", "status", "part", "code", "data", "obj", "ref", "alt", "rc", "nt", "lit", "rt", "fun", "result", "match", "bc", "ext", "done", "resp", "rets", "def", "en", "out", "arr", "bad", "att", "val", "re", "Ret", "fail", " RET", "back", "reset", "value", "no", "det", "rev", "temp", "req", "RET", "sent", "failed", "error", "red", "res", "valid", "reply", "success", "len"], "toread": ["ltareAD", "tureads", "ltaready", "ltaread", "tourad", "ltoready", "tureAD", "tourads", "taread", "ltoreads", "tourAD", "toready", "tourady", "tareads", "tareAD", "toreads", "tuready", "turead", "ltoread", "ltareads", "toreAD", "ltoreAD", "taready"], "prev_pkt": ["prev_copaint", "prev_Piece", "prev_compacket", "prev_Punt", "prev_pce", "prev_packet", "prev_rkt", "prev_racket", "prev_pdu", "prev_pakt", "prev_wpkt", "prev_chkt", "prev_wpunt", "prev_cpinch", "prev_Pdu", "prev_Pkt", "prev_cpet", "prev_punt", "prev_fpacket", "prev_wpacket", "prev_fpeth", "prev_Peth", "prev_compkt", "prev_npce", "prev_Punch", "prev_painch", "prev_opiece", "prev_packer", "prev_compacker", "prev_chacket", "prev_cpiece", "prev_rett", "prev_Pett", "prev_Paint", "prev_npacker", "prev_cpacket", "prev_opkt", "prev_opacket", "prev_reth", "prev_peth", "prev_Packer", "prev_paint", "prev_npacket", "prev_ipacket", "prev_ipmt", "prev_paett", "prev_copunt", "prev_ipkt", "prev_fpett", "prev_paet", "prev_opunch", "prev_ipdu", "prev_pinch", "prev_npkt", "prev_wpaint", "prev_chdu", "prev_Packet", "prev_chmt", "prev_Pmt", "prev_cpett", "prev_wpet", "prev_wpett", "prev_punch", "prev_pett", "prev_pmt", "prev_fpkt", "prev_cpkt", "prev_pet", "prev_Pce", "prev_copkt", "prev_cpunch", "prev_copacket", "prev_piece", "prev_wpinch", "prev_compce"], "written": ["broken", "made", "generated", "wed", "updated", "writ", "finished", "printed", "checked", "ref", "net", "sized", "wait", "current", "called", "Written", "ritten", "done", "protected", "byte", "started", "ended", "aligned", "loaded", "after", "added", "numbered", "read", "nc", "memory", "w", "seen", "fd", "writers", "won", "temp", "unit", "used", "needed", "sent", "output", "writing", "wn", "wa", "worked", "write", "weight", "connection", "connected", "rawn", "writer", "created", "wrote", "locked", "len"]}}
{"project": "qemu", "commit_id": "6fedcaa1c5419fa89c31fd34dabbd71861c615d2", "target": 0, "func": "void eeprom93xx_write(eeprom_t *eeprom, int eecs, int eesk, int eedi)\n\n{\n\n    uint8_t tick = eeprom->tick;\n\n    uint8_t eedo = eeprom->eedo;\n\n    uint16_t address = eeprom->address;\n\n    uint8_t command = eeprom->command;\n\n\n\n    logout(\"CS=%u SK=%u DI=%u DO=%u, tick = %u\\n\",\n\n           eecs, eesk, eedi, eedo, tick);\n\n\n\n    if (! eeprom->eecs && eecs) {\n\n        /* Start chip select cycle. */\n\n        logout(\"Cycle start, waiting for 1st start bit (0)\\n\");\n\n        tick = 0;\n\n        command = 0x0;\n\n        address = 0x0;\n\n    } else if (eeprom->eecs && ! eecs) {\n\n        /* End chip select cycle. This triggers write / erase. */\n\n        if (eeprom->writable) {\n\n            uint8_t subcommand = address >> (eeprom->addrbits - 2);\n\n            if (command == 0 && subcommand == 2) {\n\n                /* Erase all. */\n\n                for (address = 0; address < eeprom->size; address++) {\n\n                    eeprom->contents[address] = 0xffff;\n\n                }\n\n            } else if (command == 3) {\n\n                /* Erase word. */\n\n                eeprom->contents[address] = 0xffff;\n\n            } else if (tick >= 2 + 2 + eeprom->addrbits + 16) {\n\n                if (command == 1) {\n\n                    /* Write word. */\n\n                    eeprom->contents[address] &= eeprom->data;\n\n                } else if (command == 0 && subcommand == 1) {\n\n                    /* Write all. */\n\n                    for (address = 0; address < eeprom->size; address++) {\n\n                        eeprom->contents[address] &= eeprom->data;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        /* Output DO is tristate, read results in 1. */\n\n        eedo = 1;\n\n    } else if (eecs && ! eeprom->eesk && eesk) {\n\n        /* Raising edge of clock shifts data in. */\n\n        if (tick == 0) {\n\n            /* Wait for 1st start bit. */\n\n            if (eedi == 0) {\n\n                logout(\"Got correct 1st start bit, waiting for 2nd start bit (1)\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"wrong 1st start bit (is 1, should be 0)\\n\");\n\n                tick = 2;\n\n                //~ assert(!\"wrong start bit\");\n\n            }\n\n        } else if (tick == 1) {\n\n            /* Wait for 2nd start bit. */\n\n            if (eedi != 0) {\n\n                logout(\"Got correct 2nd start bit, getting command + address\\n\");\n\n                tick++;\n\n            } else {\n\n                logout(\"1st start bit is longer than needed\\n\");\n\n            }\n\n        } else if (tick < 2 + 2) {\n\n            /* Got 2 start bits, transfer 2 opcode bits. */\n\n            tick++;\n\n            command <<= 1;\n\n            if (eedi) {\n\n                command += 1;\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits) {\n\n            /* Got 2 start bits and 2 opcode bits, transfer all address bits. */\n\n            tick++;\n\n            address = ((address << 1) | eedi);\n\n            if (tick == 2 + 2 + eeprom->addrbits) {\n\n                logout(\"%s command, address = 0x%02x (value 0x%04x)\\n\",\n\n                       opstring[command], address, eeprom->contents[address]);\n\n                if (command == 2) {\n\n                    eedo = 0;\n\n                }\n\n                address = address % eeprom->size;\n\n                if (command == 0) {\n\n                    /* Command code in upper 2 bits of address. */\n\n                    switch (address >> (eeprom->addrbits - 2)) {\n\n                        case 0:\n\n                            logout(\"write disable command\\n\");\n\n                            eeprom->writable = 0;\n\n                            break;\n\n                        case 1:\n\n                            logout(\"write all command\\n\");\n\n                            break;\n\n                        case 2:\n\n                            logout(\"erase all command\\n\");\n\n                            break;\n\n                        case 3:\n\n                            logout(\"write enable command\\n\");\n\n                            eeprom->writable = 1;\n\n                            break;\n\n                    }\n\n                } else {\n\n                    /* Read, write or erase word. */\n\n                    eeprom->data = eeprom->contents[address];\n\n                }\n\n            }\n\n        } else if (tick < 2 + 2 + eeprom->addrbits + 16) {\n\n            /* Transfer 16 data bits. */\n\n            tick++;\n\n            if (command == 2) {\n\n                /* Read word. */\n\n                eedo = ((eeprom->data & 0x8000) != 0);\n\n            }\n\n            eeprom->data <<= 1;\n\n            eeprom->data += eedi;\n\n        } else {\n\n            logout(\"additional unneeded tick, not processed\\n\");\n\n        }\n\n    }\n\n    /* Save status of EEPROM. */\n\n    eeprom->tick = tick;\n\n    eeprom->eecs = eecs;\n\n    eeprom->eesk = eesk;\n\n    eeprom->eedo = eedo;\n\n    eeprom->address = address;\n\n    eeprom->command = command;\n\n}\n", "idx": 16406, "substitutes": {"eeprom": ["eiprm", "eppdem", "eyprec", "eeeproc", "aeepro", "seepchrom", "eefram", "eecrec", "eEProm", "aeepchrom", "weyprob", "peppram", "zeekron", "pecrum", "aeepron", "peepro", "eekrum", "eecron", "zeekrum", "eyprim", "zeepsrome", "eEPrim", "eecram", "seypro", "eeprum", "aeeprm", "sempram", "seypron", "sempchrom", "seeproc", "zeeprum", "eecrm", "pepro", "epproc", "eegrost", "eepsrom", "eekrob", "peeprim", "eepprum", "eiprom", "peefro", "eephrome", "eephrom", "eecrum", "teecrec", "eekroy", "peeprom", "emprom", "peepram", "eipdem", "eefrim", "zeekro", "eegroy", "eupprec", "zeepron", "aeecrum", "teecrom", "eepprom", "jeecrom", "seiproc", "eEPro", "seipdem", "peprum", "eeprm", "eekrm", "eecroman", "eeproy", "seipram", "jeecroman", "eeeprom", "eamproy", "weypro", "aeyprom", "eecchrom", "eecrome", "eepsrob", "weeprob", "seyprob", "epprum", "zeekrom", "zeeprm", "eupro", "zeekram", "eyprom", "eipram", "jeeprum", "aeyprim", "aeyproc", "eepproc", "pecrom", "zeekrm", "eepron", "aeypro", "peefrm", "eebrome", "seeprom", "teeprome", "eiproc", "eebrom", "peprom", "seeprob", "eeeprm", "weeprom", "eyproy", "eppram", "semprom", "eamprom", "aeypron", "eepsroy", "eekram", "eefrom", "eepram", "eeprob", "eipro", "peppdem", "eekron", "euproy", "aeecrm", "seiprom", "zeekrome", "pepprm", "eecroy", "eeprim", "eekroc", "epproy", "eephron", "eephrum", "jeecro", "eecrob", "aeeprim", "eupprum", "eyprob", "eecro", "eepsron", "eepprim", "jeeproman", "eypron", "peeprm", "eeprome", "epprm", "eamprome", "emprm", "eefroc", "peefrim", "eepsrome", "eepsrim", "seyprom", "pepprom", "emprim", "eepprost", "eeepram", "peepdem", "eupprome", "eepprm", "eypro", "eampron", "eeeproy", "aeecrom", "peefrom", "semprm", "eepsroc", "eupprom", "eypdem", "eepsrum", "aeecchrom", "zeeproy", "eekroman", "eepchrom", "jeeprom", "aeeproc", "eefrm", "eyproman", "weyprom", "euprum", "eebron", "eeprost", "aeyprec", "pecro", "zeepram", "eecrom", "teeprom", "eepro", "peefram", "seepdem", "epprom", "epprim", "eypram", "eekrom", "eeeprum", "zeepsron", "eyprum", "teecrum", "eepsrost", "aeeprom", "teeprum", "aeeprec", "eiprim", "teecrome", "empchrom", "eppchrom", "zeepro", "epprost", "aeeprum", "jeepro", "zeeprome", "emprum", "jeecrum", "euprom", "eyproc", "eekrome", "seepron", "seiprm", "zeepsroy", "pecroy", "eepproy", "eeppram", "seepro", "weepro", "eebrum", "empro", "peproy", "eegrom", "eeproc", "weeprum", "eepsrec", "seeprm", "eEProc", "empram", "eefrum", "eegrim", "eepdem", "eeproman", "seepram", "weyprum", "eekro", "eepsro", "eeeprim", "eeprec", "eecrim", "zeeprom", "eefchrom", "eeeprost", "eefro", "zeepsrom", "teeprec", "eyprm", "eyprome"], "eecs": ["peepls", "beecs", "eefsb", "eepd", "eepsym", "ceeks", "eveekds", "eeco", "eveecrates", "cekls", "ceekrs", "peecgroups", "peeco", " eecses", "eegs", "beecn", "eecf", "eevcs", "eefrs", " eeksb", "eevls", "peepo", " eecsb", "eercrs", "eveekrs", "peecd", "eefrates", "eveecrs", "eECsb", "peepgroups", "ereamgs", "eevf", "eecgs", "peepns", "eercd", "eectns", "eectgs", "eercns", "eectn", "eECrs", "eekrs", "eekf", "eevs", "eercds", "cecf", "ereamrs", "eekcs", "beectsync", "eectd", "eveeks", "eefds", "ceekgs", "eepls", "eepn", "eecrs", "eefsym", " eekses", "beecgroups", "eefs", "eekgs", "beecsync", "beectn", "beects", "peepsym", "peecs", "eecsb", "eegsym", "ceecd", "ceecs", "eveecs", "eekd", "ceks", "eECses", "cecls", "eecls", "eects", "cecs", "eectsync", "eecds", "eectrs", "ceecrs", " eecrs", "eekds", "eekrates", "eeccs", "eecns", "eepsync", "beectgroups", "ereamsync", " eekrs", "eemptf", "eempts", "eveecds", "eefses", "eecn", "ereams", "eepns", "peeps", " eeks", "ceccs", "ereamgroups", "eveekrates", "eecsym", "eegls", "peepd", "eemptcs", "eemptls", "eego", "ereamd", "peecsym", "eeksb", "eekses", "eercgroups", "ceekd", "eecses", "eercs", "eekls", "eepgroups", "eeps", "eecrates", "eECs", "eecd", "peecls", "eecsync", "peecns", "ceecgs", "eefls", "ereamn", "eepo", "eectgroups", "cekf", "eecgroups", "eeks", "eercrates", "cekcs", "eefo"], "eesk": ["ipsK", "ipesk", "apeskin", "eeskin", "apesk", "eeskw", "eedskw", "lesks", "eskin", "esK", "ipsks", "lesK", "ipesK", "eesK", "ipsok", "esok", "elsk", "eedsky", "eesks", "elskw", "esky", "eedsK", "elsks", "apesks", "eesok", "ipesky", "ipeskin", "eedsks", "eedsk", "ipsk", "esk", "esks", "eskw", "apesky", "lesky", "eedsok", "elsky", "lesk", "eesky", "ipesks"], "eedi": ["ebi", "seedy", "seedi", "seedo", "eadi", "ddi", "efo", "elli", "eedy", "expectedi", "eado", "eei", "eey", "expectedy", "eqo", "seedoi", "eedoi", "expectedo", "eeda", "eeoi", "eqa", "devi", "equ", "eadiu", "eedu", "efiu", "expectedoi", "devo", "eeiu", "eeu", "eqi", "eba", "efi", "eede", "devio", "eedio", "eby", "ddu", "elly", "elloi", "eeio", "eea", "eediu", "eee", "eeo", "devoi", "ddo", "eedo", "ebo", "dda", "efe", "seeda", "eade", "ello", "seedio"], "address": ["uri", "entry", "point", "offset", "Address", "element", "comment", "service", "duration", "align", "package", "reference", "pair", "location", "layer", "path", "socket", "length", "config", "id", "resource", "output", "interface", "command", "target", "program", "content", "work", "direction", "name", "pointer", "object", "size", "condition", "route", "connection", "operation", "order", "operator", "expression", "instance", "code", "image", "type", "date", "page", "host", "grade", "email", "network", "activity", "device", "position", "ace", "character", "addr", "edge", "alpha", "shape", "request", "mode", "attribute", "office", "channel", "module", "enter", "index", "password", "ip", "context", "alias", "event", "add", "argument", "url", "error", "number", "message", "server"], "tick": ["click", "plot", "x", "comment", "toggle", "trial", "padding", "cycle", "d", "bang", "stuff", "config", "length", "paste", "pad", "loop", "write", "bytes", "repeat", "sequence", "trigger", "command", "scale", "hour", "track", "token", "hop", "charge", "scope", "timeout", "nick", "magic", "pointer", "axis", "style", "height", "key", "patch", "ick", "shift", "reason", "time", "cookie", "push", "call", "kick", "ping", "window", "block", "type", "task", "this", "byte", "date", "nice", "start", "delay", "batch", "sync", "history", "lock", "check", "timer", "progress", "tip", "sleep", "hello", "bug", "s", "shape", "all", "scroll", "trace", "theme", "feed", "g", "module", "year", "month", "stick", "index", "slice", "day", "tag", "step", "event", "pull", "_", "cmd", "argument", "pick", "error", "clock", "callback"]}}
{"project": "qemu", "commit_id": "acfb23ad3dd8d0ab385a10e483776ba7dcf927ad", "target": 0, "func": "static void *iothread_run(void *opaque)\n\n{\n\n    IOThread *iothread = opaque;\n\n\n\n    qemu_mutex_lock(&iothread->init_done_lock);\n\n    iothread->thread_id = qemu_get_thread_id();\n\n    qemu_cond_signal(&iothread->init_done_cond);\n\n    qemu_mutex_unlock(&iothread->init_done_lock);\n\n\n\n    while (!iothread->stopping) {\n\n        aio_context_acquire(iothread->ctx);\n\n        while (!iothread->stopping && aio_poll(iothread->ctx, true)) {\n\n            /* Progress was made, keep going */\n\n        }\n\n        aio_context_release(iothread->ctx);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 16410, "substitutes": {"opaque": ["appca", "operaco", "appacity", " opacity", "OPaco", " opca", "iopca", "opacity", "iopaque", "OPque", "operaque", "oplque", "oplaco", "appaque", "oplaque", "opoc", "oploc", "opca", "operque", "opaco", "OPaque", "operoc", "iopacity", "appaques", "OPoc", "opaques", "iopaques", "opque", " opaques"], "iothread": ["uuthread", "iothlock", "uothcheck", "iouthread", "uuthwait", "iithwrite", "iothreads", "iighthread", "iuthcheck", "iuthscan", "iohwrite", "atiothread", "iometscan", "iopterread", "iopterwrite", "uuthwrite", "icothreader", "icoshsync", "aophreader", "aoretload", "ioughreader", "ioretwrite", "xiuthread", "xiuthstart", "ioretsync", "atiothwrite", "iuthlock", "icoshwrite", "ithmode", "iopterreader", "iothreader", "ioshreader", "ioothwrite", "iuthwait", "ihedwrite", "iothrank", "iuthread", "iuthadd", "iithlock", "iometload", "icothwait", "iothsync", "xiothmode", "aoretsync", "iohreader", "xiothreader", "atiithlock", "iophadd", "icothloop", "ioenwrite", "iothcheck", "iohread", "icoshread", "aophwrite", "aothreader", "aophadd", "ioothreader", "icoothreads", "ioothreads", "aothadd", "xiothstart", "ithread", "iuthrank", "iopathwait", "ioughread", "ioughwrite", "icoothread", "ioshcheck", "ihedreads", "aoretwrite", "icothsync", "atiithrank", "iuthstart", "uothscan", "icoothreader", "iopterscan", "iophwrite", "iophreads", "iothmode", "iophread", "iothloop", "xiothread", "iuthsync", "xiuthmode", "ithreader", "aothsync", "icothwrite", "icoshwait", "atiothlock", "xiuthwrite", "icoshloop", "iophstart", "iothload", "iouthsync", "iuthmode", "iithrank", "uuthreader", "ioshwrite", "uothread", "iometwrite", "icoshreader", "iighthreader", "xiuthreader", "iophreader", "iothwait", "atiithread", "atiithwrite", "iouthloop", "uuthscan", "aothwrite", "aothload", "uothwrite", "iuthwrite", "iopathwrite", "iohmode", "icoothwrite", "ioenrank", "ioretloop", "ihedreader", "iuthload", "uothreader", "ioretreader", "iopathstart", "iothstart", "ioshwait", "iothwrite", "iothadd", "ithwrite", "iopathreader", "ioretread", "ioshread", "aothread", "ioshloop", "iometreader", "uuthcheck", "iophwait", "ioshsync", "ihedread", "xiothwrite", "iometsync", "ioenlock", "iithread", "iothscan", "ioughwait", "ioretload", "aophread", "iouthreader", "ioenread", "aoretread", "iometread", "iighthadd", "ioothread", "iopathread", "uothwait", "icothread", "iighthwrite", "icothreads", "atiothrank", "iuthreader", "iopathcheck"]}}
{"project": "FFmpeg", "commit_id": "d6604b29ef544793479d7fb4e05ef6622bb3e534", "target": 0, "func": "static av_cold int encode_close(AVCodecContext *avctx)\n\n{\n\n    av_frame_free(&avctx->coded_frame);\n\n    return 0;\n\n}\n", "idx": 16412, "substitutes": {"avctx": ["afcmp", "afcam", "AVcmp", "afcontext", "afctx", "audcontext", "afcca", " avcf", "avcf", "AVcca", "AVcf", "AVcam", "audcam", "AVctx", "audctx", " avcontext", "avcca", "audcmp", "AVcontext", "avcmp", "afcf", "avcam", " avcca", "avcontext"]}}
{"project": "qemu", "commit_id": "3c3e88a814ef4eb8b2f8bf81863baec24838d998", "target": 0, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    int64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n\n\n    mr = host_memory_backend_get_memory(dimm->hostmem, errp);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_int(v, name, &value, errp);\n\n}\n", "idx": 16415, "substitutes": {"obj": ["org", "j", "code", "ob", "bj", "ref", "obb", "nt", "objects", "module", "ut", "src", "ctx", "pos", "act", "object", "o", "po", "host", "val", "oi", "oid", "img", "ev", "xxx", "emb", "tmp", "lib", "p", "b", "orb", "Object", "inst", "iv", "api", "boot", "os", "opt", "fi", "Obj"], "v": ["m", "V", "j", "s", "t", "x", "f", "n", "g", "i", "z", "object", "o", "vm", "uv", "l", "d", "val", "conv", "vim", "w", "e", "k", "q", "client", "c", "inv", "tv", "p", "volt", "b", "vv", "iv", "api", "env", "u"], "name": ["part", "time", "data", "info", "x", "image", "base", "n", "type", "var", "nam", "Name", "filename", "object", "label", "NAME", "alias", "space", "size", "path", "memory", "no", "prefix", "key", "named", "b", "null", "cap", "names", "a", "len", "word", "attr"], "opaque": ["ospacle", "iopacs", "ospec", "opec", "ospaque", "opacs", "ospacs", "iopec", " opacs", " opec", " opacle", "opacle", "iopaque", "iopacle"], "errp": ["errorpi", "errpi", " errP", "err", "errP", "errorpc", "rrr", "errpc", "errorP", " errlp", "errorp", "rarp", "erp", "ryP", "errr", "rarpc", " errr", "rrp", "errlp", "rrpi", "rypc", "erP", "rarP", "rarlp", "rrP", " errpc", "errorlp", "rypi", "ryp", "rrpc"], "value": ["values", "scale", "offset", "Value", "data", "element", "image", "media", "result", "type", "function", "index", "min", "member", "count", "range", "val", "balance", "array", "format", "size", "memory", "large", "flow", "length", "id", "limit", "unit", "age", "position", "VALUE", "total", "area", "fee", "feature", "pr", "va", "number", "write", "weight", "message", "addr", "version"], "mr": ["m", "rr", "fr", "br", "MR", "mir", "rs", "vr", "r", "hr", "rm", "rt", "bm", "mn", "pm", "rh", "rg", "mc", "rf", "manager", "kr", "LR", "ml", "gor", "nm", "rd", "nr", "sr", "dr", "lr", "igr", "mx", "yr", "rl", "wm", "ir", "rb", "wr", "mor", "pr", "adr", "mer", "er", "mt", "mm", "Mr", "gr", "shr"], "dimm": ["Dimm", "sdim", " damm", "Dym", "sdimp", " dym", "sdimm", "dim", "sdym", "dimp", "Damm", "Dim", " digr", "dym", " dimp", "digr", "damm", "Dimp", " dim", "Digr"]}}
{"project": "qemu", "commit_id": "d0e7605ee0d91c3737052127a79199ddab3ff653", "target": 0, "func": "pflash_t *pflash_cfi02_register(target_phys_addr_t base, ram_addr_t off,\n\n                                BlockDriverState *bs, uint32_t sector_len,\n\n                                int nb_blocs, int nb_mappings, int width,\n\n                                uint16_t id0, uint16_t id1,\n\n                                uint16_t id2, uint16_t id3,\n\n                                uint16_t unlock_addr0, uint16_t unlock_addr1)\n\n{\n\n    pflash_t *pfl;\n\n    int32_t chip_len;\n\n\n\n    chip_len = sector_len * nb_blocs;\n\n    /* XXX: to be fixed */\n\n#if 0\n\n    if (total_len != (8 * 1024 * 1024) && total_len != (16 * 1024 * 1024) &&\n\n        total_len != (32 * 1024 * 1024) && total_len != (64 * 1024 * 1024))\n\n        return NULL;\n\n#endif\n\n    pfl = qemu_mallocz(sizeof(pflash_t));\n\n    /* FIXME: Allocate ram ourselves.  */\n\n    pfl->storage = qemu_get_ram_ptr(off);\n\n    pfl->fl_mem = cpu_register_io_memory(pflash_read_ops, pflash_write_ops,\n\n                                         pfl);\n\n    pfl->off = off;\n\n    pfl->base = base;\n\n    pfl->chip_len = chip_len;\n\n    pfl->mappings = nb_mappings;\n\n    pflash_register_memory(pfl, 1);\n\n    pfl->bs = bs;\n\n    if (pfl->bs) {\n\n        /* read the initial flash content */\n\n        bdrv_read(pfl->bs, 0, pfl->storage, chip_len >> 9);\n\n    }\n\n#if 0 /* XXX: there should be a bit to set up read-only,\n\n       *      the same way the hardware does (with WP pin).\n\n       */\n\n    pfl->ro = 1;\n\n#else\n\n    pfl->ro = 0;\n\n#endif\n\n    pfl->timer = qemu_new_timer(vm_clock, pflash_timer, pfl);\n\n    pfl->sector_len = sector_len;\n\n    pfl->width = width;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n    pfl->status = 0;\n\n    pfl->ident[0] = id0;\n\n    pfl->ident[1] = id1;\n\n    pfl->ident[2] = id2;\n\n    pfl->ident[3] = id3;\n\n    pfl->unlock_addr[0] = unlock_addr0;\n\n    pfl->unlock_addr[1] = unlock_addr1;\n\n    /* Hardcoded CFI table (mostly from SG29 Spansion flash) */\n\n    pfl->cfi_len = 0x52;\n\n    /* Standard \"QRY\" string */\n\n    pfl->cfi_table[0x10] = 'Q';\n\n    pfl->cfi_table[0x11] = 'R';\n\n    pfl->cfi_table[0x12] = 'Y';\n\n    /* Command set (AMD/Fujitsu) */\n\n    pfl->cfi_table[0x13] = 0x02;\n\n    pfl->cfi_table[0x14] = 0x00;\n\n    /* Primary extended table address */\n\n    pfl->cfi_table[0x15] = 0x31;\n\n    pfl->cfi_table[0x16] = 0x00;\n\n    /* Alternate command set (none) */\n\n    pfl->cfi_table[0x17] = 0x00;\n\n    pfl->cfi_table[0x18] = 0x00;\n\n    /* Alternate extended table (none) */\n\n    pfl->cfi_table[0x19] = 0x00;\n\n    pfl->cfi_table[0x1A] = 0x00;\n\n    /* Vcc min */\n\n    pfl->cfi_table[0x1B] = 0x27;\n\n    /* Vcc max */\n\n    pfl->cfi_table[0x1C] = 0x36;\n\n    /* Vpp min (no Vpp pin) */\n\n    pfl->cfi_table[0x1D] = 0x00;\n\n    /* Vpp max (no Vpp pin) */\n\n    pfl->cfi_table[0x1E] = 0x00;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x1F] = 0x07;\n\n    /* Timeout for min size buffer write (NA) */\n\n    pfl->cfi_table[0x20] = 0x00;\n\n    /* Typical timeout for block erase (512 ms) */\n\n    pfl->cfi_table[0x21] = 0x09;\n\n    /* Typical timeout for full chip erase (4096 ms) */\n\n    pfl->cfi_table[0x22] = 0x0C;\n\n    /* Reserved */\n\n    pfl->cfi_table[0x23] = 0x01;\n\n    /* Max timeout for buffer write (NA) */\n\n    pfl->cfi_table[0x24] = 0x00;\n\n    /* Max timeout for block erase */\n\n    pfl->cfi_table[0x25] = 0x0A;\n\n    /* Max timeout for chip erase */\n\n    pfl->cfi_table[0x26] = 0x0D;\n\n    /* Device size */\n\n    pfl->cfi_table[0x27] = ctz32(chip_len);\n\n    /* Flash device interface (8 & 16 bits) */\n\n    pfl->cfi_table[0x28] = 0x02;\n\n    pfl->cfi_table[0x29] = 0x00;\n\n    /* Max number of bytes in multi-bytes write */\n\n    /* XXX: disable buffered write as it's not supported */\n\n    //    pfl->cfi_table[0x2A] = 0x05;\n\n    pfl->cfi_table[0x2A] = 0x00;\n\n    pfl->cfi_table[0x2B] = 0x00;\n\n    /* Number of erase block regions (uniform) */\n\n    pfl->cfi_table[0x2C] = 0x01;\n\n    /* Erase block region 1 */\n\n    pfl->cfi_table[0x2D] = nb_blocs - 1;\n\n    pfl->cfi_table[0x2E] = (nb_blocs - 1) >> 8;\n\n    pfl->cfi_table[0x2F] = sector_len >> 8;\n\n    pfl->cfi_table[0x30] = sector_len >> 16;\n\n\n\n    /* Extended */\n\n    pfl->cfi_table[0x31] = 'P';\n\n    pfl->cfi_table[0x32] = 'R';\n\n    pfl->cfi_table[0x33] = 'I';\n\n\n\n    pfl->cfi_table[0x34] = '1';\n\n    pfl->cfi_table[0x35] = '0';\n\n\n\n    pfl->cfi_table[0x36] = 0x00;\n\n    pfl->cfi_table[0x37] = 0x00;\n\n    pfl->cfi_table[0x38] = 0x00;\n\n    pfl->cfi_table[0x39] = 0x00;\n\n\n\n    pfl->cfi_table[0x3a] = 0x00;\n\n\n\n    pfl->cfi_table[0x3b] = 0x00;\n\n    pfl->cfi_table[0x3c] = 0x00;\n\n\n\n    return pfl;\n\n}\n", "idx": 16419, "substitutes": {"base": ["at", "ab", "bin", "bi", "offset", "br", "extra", "info", "fat", "core", "alt", "Base", "bit", "buffer", "io", "block", "root", "bare", "type", "bc", "index", "pos", "byte", "out", "ip", "home", "balance", "up", "zero", "bf", "ui", "back", "use", "reset", "prefix", "id", "start", "front", "bas", "open", "hard", "pad", "area", "b", "cache", "boot", "ace", "beta", "api", "ase", "end", "port", "server", "bal", "real", "version"], "off": ["offer", "ab", "offset", "br", "ff", "data", "info", "mode", "obj", "full", "ref", "alt", "name", "bit", "Off", "on", "block", "type", "oa", "rom", "function", "raw", "pos", "normal", "out", "online", "o", "ip", "home", "low", "load", "non", "empty", "unknown", "up", "zero", "offs", "new", "ON", "back", "no", "reset", "flow", "start", "front", "remote", "bas", "open", "buf", "slave", "OFF", "address", "none", "output", "boot", "end", "less", "down"], "bs": ["ns", "ros", "ab", "bi", "ts", "db", "fps", "lbs", "rs", "ras", "las", "ob", "hz", "ubs", "ro", "bm", "sb", "cb", "bc", "ss", "ls", "ops", "nas", "pb", "fs", "lb", "bb", "ba", "bid", "cs", "gb", "bos", "bed", "bps", "obs", "outs", "BS", "iss", "blocks", "bis", "sub", "prefix", "bl", "bas", "sync", "bh", "bits", "ps", "buf", "ses", "b", "gs", "boot", "res", "bytes", "os", "us", "bes", "banks", "bing"], "sector_len": ["sector33length", "comment_lf", "sector2length", "io_den", "piece_length", "sector__len", "sector_count", "sector_cap", "area\u00b7len", "comment_length", "area_length", "sectornden", "sector1length", "area_count", "piece_span", "area\u00b7length", "sector64cap", "sector\u00b7length", "sector64length", "sector33limit", "sector\u00b7cap", "sector_limit", "sector\u00b7count", "io_length", "io2den", "sectornlen", "sector2len", "sector33len", "piece_den", "comment33len", "comment33lf", "comment33length", "area_len", "sector_length", "sectorncount", "sector2count", "area_cap", "sector\u00b7len", "sector_span", "io2count", "piece_len", "comment33limit", "io_len", "sector64len", "comment_limit", "sector2den", "io2len", "sector_lf", "sector64count", "io2length", "sector33lf", "sectornlength", "sector_den", "sector64span", "sector__length", "area\u00b7count", "comment_len", "sector1len", "sector1lf", "sector64den", "io_count", "sector1limit", "sector__den", "sector__span", "area\u00b7cap"], "nb_blocs": ["nb_blocin", "nb_blocals", "nb_blallocations", "nb_Blocn", "nb_flocn", "nb_blOCals", "nb_bloggs", "nb_blocit", "nb_blucments", "nb_blOCments", "nb_Blocin", "nb_flocals", "nb_blocn", "nb_bloct", "nb_Blocis", "nb_flallocations", "nb_Blocs", "nb_Blociments", "nb_blocis", "nb_flallocn", "nb_flallocs", "nb_blucn", "nb_blOCs", "nb_Bloct", "nb_blallocs", "nb_blociments", "nb_blucs", "nb_blocments", "nb_flocations", "nb_blallocals", "nb_Blocit", "nb_bloggn", "nb_blOCn", "nb_blallocn", "nb_blOCt", "nb_blocations", "nb_bloggations", "nb_flocs", "nb_Blocments", "nb_blOCations", "nb_flallocals", "nb_bluct", "nb_bloggals"], "nb_mappings": ["nb2mapping", "nb_napping", "nb_maps", "nb_bmapping", "nb_bmairs", "nb_tmairs", "nb_mapping", "nb_Mapping", "nb2tmappings", "nb_mairs", "nb_tmapping", "nb2maps", "nb_Maps", "nb2mappings", "nb_bmaps", "nb_Mairs", "nb_smapping", "nb_nocks", "nb_smappings", "nb_Mapped", "nb_napped", "nb_Mocks", "nb2tmaps", "nb_smapped", "nb_mapped", "nb2mairs", "nb2tmairs", "nb_bmappings", "nb_Mappings", "nb2tmapping", "nb_nappings", "nb_tmaps", "nb_smocks", "nb_tmappings", "nb_mocks"], "id0": ["ID8", "ids0", "ID01", "sid8", "aid8", "id8", "aid0", "Id00", "ID00", "sid0", "Id01", "ids01", "id00", "ids00", "Id8", "ids8", "aid2", " id8", "sid2", "ID0", "Id0", "id01"], "id1": ["kid7", "idOne", "id7", " idOne", " id7", "aid001", "index1", "ident01", "aid01", "ident7", "ident1", " id11", "ident001", "aid1", "ID7", "indexOne", "kid001", "aid7", "ID1", "index7", "ID11", "id01", "kid01", "index11", "id11", "kid1", "IDOne", "id001"], "id2": ["pid2", "id32", "it6", "ID2", "id7", "it32", " id7", "pid1", "kid6", "kid32", "id4", " id4", "it1", "ip1", "pid4", "ID4", "ID7", "ID1", "ip32", "pid7", "kid2", "id6", "kid1", "it2", "ip2", "ip6"], "id3": ["ip3", "IdThree", " idThree", "id03", "uidThree", " id03", "Id2", "uid03", "ip1", "uid3", "ip15", "Id1", "uid2", "Id03", "id15", "Id15", "idThree", " id15", "ip2", "Id3"], "unlock_addr0": ["unlock_ext1", "unlock_add0", "unlock_address50", "unlock_ext2", "unlock_dr0", "unlock_address0", "unlock_dr50", "unlock_ext50", "unlock_offset1", "unlock_addr50", "unlock_add2", "unlock_dr1", "unlock_addr16", "unlock_offset0", "unlock_address2", "unlock_dr16", "unlock_ext0", "unlock_address16", "unlock_add1", "unlock_add50", "unlock_addr2", "unlock_offset16", "unlock_offset50", "unlock_address1"], "unlock_addr1": ["unlock_wdOne", "unlock_wd3", "unlock_dr3", "unlock_drOne", "unlock_dr1", "unlock_address3", "unlock_addrOne", "unlock_addr3", "unlock_addressOne", "unlock_address1", "unlock_wd1"], "pfl": [" pfail", "pefw", "ppflo", "perflo", "apFL", "execfl", "apcompl", "tpurl", "upflash", "piflat", "bfl", "pafx", "ppkl", "qfl", "Pfd", "ppform", "apflush", "pfail", "phl", " pFL", "parFL", "pefall", "ppcompl", "pefly", "perfly", "qll", "pfw", "pflash", "wpzl", "piflo", "pFl", "bFL", "qflo", "peflat", "ipul", "uphl", "portfall", " pFl", " psl", "plu", "pfx", "PFL", "psfr", "portfl", "psfw", "Pf", "PFl", "apfw", "wpflush", "postfl", "pafl", "ppl", "ppfly", "pkl", "psel", "pcompl", "ppFl", "patchfl", "bfr", "perfl", "ppfw", "tpoper", "spflush", "pafail", "upfle", " pflat", "paFL", "peflush", "peroper", "pfall", "pifl", " pfly", "psul", " pul", "parfl", "wpflo", "apflo", "lpwl", "pfr", "perflush", "purl", "apiflash", "ppfr", " pfall", "poper", "spflo", "pfly", "apfl", "pflat", "Pflo", "qfx", "pfol", "lpfly", " pflash", "perfr", "peflow", "pflow", "pefl", "parfr", "paflash", "pall", "postflo", " pflow", " pkl", "qf", "psl", "execf", "execcompl", " pzl", "pfd", "pezl", " pflush", "peflo", "lpfw", "lpflight", "piFL", "lpflush", "patchflush", " pf", "psflush", "ipfd", "pflush", " pflight", "execflo", "parpl", "Pfl", "apfly", "Psl", "ppflush", "Pflight", "lpflow", "paflo", "npflush", "ppf", "ppflash", "pflo", "postFL", "upf", "iplu", "lpzl", "lpform", "tpzl", "npflo", "pform", " phl", "npcompl", "apifl", "ipFL", " pflo", "lpfl", "pisl", "tpfly", "patchhl", "pf", "bpl", "ppFL", " pfr", "portfly", " pfd", "peurl", "apikl", "upfail", "psfl", "spfl", " ppl", "apfr", "pslu", "pzl", "upflush", "lpflash", "pll", "pul", "ppfl", "lpFL", "wpfl", "pesl", "ppflow", "portfw", "qflush", " plu", "patchf", "ipfl", " pcompl", "qfw", "pflight", "perform", "pwl", "perwl", "npfl", "paf", "ppwl", " pfle", "pfle", "piflush", "tpfl", " pll", "tpflush", " pfx", "apiFL", "pafol", "lpfle", "apsl", "ipFl", "lpflo", "Pfol", "spkl", "postsel", "upfl", "npfly", "ipfr", "tpflo", "lpfr", "ipflow", "pisel", "peoper", " pfw", "pFL", " pfol", "qzl", "lpf", "Psel", "perkl", "perurl"], "chip_len": [" chip_lon", " chip_lin", "chipsln", "chip_limit", "core_lon", "chip32length", "chipJsize", "chipJlen", " chip_val", "chip32len", "chip_pos", "chip\u00b7val", "chip00vec", "chip64len", "coresln", "chipJvec", "pixel_pos", "chip00size", "pixel_length", "chip\u00b7limit", "chip_vec", "chip00len", "ip00size", "chip_li", "chip_ln", "chip_size", "chip64lit", "coreslon", "coreslen", " chip_lit", "core_length", "chip32lon", "chipslen", "ip00vec", "chip2lon", "chip_val", "chip\u00b7lin", " chip_li", "ip_len", "ip_vec", "chip32ln", "chipslon", "chip64lon", "chip_lit", " chip_limit", "chipslength", "chip_length", "core_len", "chip2pos", "chip64li", "pixel_len", "core_ln", "ip_size", "chip2ln", "chip_lin", "chip\u00b7len", "chip2len", "ip00len", "chip_lon", "coreslength", "chip2length"]}}
{"project": "qemu", "commit_id": "e95ead32efc48157de12e0a257ea1c52541a6ce1", "target": 0, "func": "static int v9fs_do_chmod(V9fsState *s, V9fsString *path, mode_t mode)\n\n{\n\n    return s->ops->chmod(&s->ctx, path->data, mode);\n\n}\n", "idx": 16422, "substitutes": {"s": ["ns", "status", "ts", "stats", "rs", "f", "settings", "services", "ows", "ils", "service", "sb", "uploads", "ss", "ls", "ops", "fs", " fs", "is", "o", "cs", "als", "e", "ssl", "side", "ses", "sync", "private", "c", "ps", "js", "si", "sym", "p", "secondary", "S", "gs", "sys", "its", "states", "es", "os", "state", "hs", "opens", "sets", "south", "sq", "less", "ds"], "path": ["ion", "pattern", "m", "txt", "text", "data", "user", "token", "dir", "image", "name", "loader", "root", "anc", "method", "type", "ath", "rh", "node", "th", "pass", "slice", "pointer", "object", "enc", "prop", "PATH", "alias", "step", "key", "id", "sc", "parent", "c", "Path", "p", "test", "desc"], "mode": ["move", "term", "m", "mod", "code", "data", "direction", "name", "dir", "MODE", "md", "Mode", "de", "phrase", "role", "module", "method", "type", "node", "mask", "def", "lane", "perm", "range", "ODE", "d", "alias", "grade", "key", "slave", "sym", "access", "cmd", "none", " modes", "level", "ace", "ode", "ma", "mac", "command"]}}
{"project": "qemu", "commit_id": "12de9a396acbc95e25c5d60ed097cc55777eaaed", "target": 1, "func": "static int check_physical (CPUState *env, mmu_ctx_t *ctx,\n\n                           target_ulong eaddr, int rw)\n\n{\n\n    int in_plb, ret;\n\n\n\n    ctx->raddr = eaddr;\n\n    ctx->prot = PAGE_READ;\n\n    ret = 0;\n\n    switch (env->mmu_model) {\n\n    case POWERPC_MMU_32B:\n\n    case POWERPC_MMU_SOFT_6xx:\n\n    case POWERPC_MMU_SOFT_74xx:\n\n    case POWERPC_MMU_601:\n\n    case POWERPC_MMU_SOFT_4xx:\n\n    case POWERPC_MMU_REAL_4xx:\n\n    case POWERPC_MMU_BOOKE:\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#if defined(TARGET_PPC64)\n\n    case POWERPC_MMU_64B:\n\n    case POWERPC_MMU_64BRIDGE:\n\n        /* Real address are 60 bits long */\n\n        ctx->raddr &= 0x0FFFFFFFFFFFFFFFULL;\n\n        ctx->prot |= PAGE_WRITE;\n\n        break;\n\n#endif\n\n    case POWERPC_MMU_SOFT_4xx_Z:\n\n        if (unlikely(msr_pe != 0)) {\n\n            /* 403 family add some particular protections,\n\n             * using PBL/PBU registers for accesses with no translation.\n\n             */\n\n            in_plb =\n\n                /* Check PLB validity */\n\n                (env->pb[0] < env->pb[1] &&\n\n                 /* and address in plb area */\n\n                 eaddr >= env->pb[0] && eaddr < env->pb[1]) ||\n\n                (env->pb[2] < env->pb[3] &&\n\n                 eaddr >= env->pb[2] && eaddr < env->pb[3]) ? 1 : 0;\n\n            if (in_plb ^ msr_px) {\n\n                /* Access in protected area */\n\n                if (rw == 1) {\n\n                    /* Access is not allowed */\n\n                    ret = -2;\n\n                }\n\n            } else {\n\n                /* Read-write access is allowed */\n\n                ctx->prot |= PAGE_WRITE;\n\n            }\n\n        }\n\n        break;\n\n    case POWERPC_MMU_BOOKE_FSL:\n\n        /* XXX: TODO */\n\n        cpu_abort(env, \"BookE FSL MMU model not implemented\\n\");\n\n        break;\n\n    default:\n\n        cpu_abort(env, \"Unknown or invalid MMU model\\n\");\n\n        return -1;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 16431, "substitutes": {"env": ["viron", "ogen", "cf", "environment", "fen", "enc", "vm", "equ", "exec", "anne", "ev", "config", "ette", "qt", "cli", "ea", "vt", "dat", "end", "enh", "fi", "conn", "ion", "enable", "txt", "init", "cdn", "engine", "eu", "ne", "app", "erv", "dt", "self", "eng", "vert", "pect", "him", "het", "v", "dev", "ec", "et", "export", "org", "err", "net", "ou", "act", "inet", "network", "vs", "c", "pec", "edge", "eni", "np", "ah", "esi", "Environment", "db", "global", "info", "conf", "n", "exc", "loader", "oa", "en", "her", "context", "profile", "nc", "event", "site", "e", "cmd", "que", "cache", "proc", "server", "press"], "ctx": ["pc", "util", "na", "grad", "cc", "cfg", "btn", "wx", "obj", "cca", "vc", "rc", "exc", "cf", "cpp", "cb", "cp", "loc", "src", "bc", "wcs", "utils", "console", "git", "kw", "ctrl", "act", "cas", "ca", "exec", "css", "context", "cs", "hw", "acs", "std", "conv", "kb", "nc", "pkg", "tx", "ci", "config", "xc", "soc", "cu", "client", "cli", "lc", "c", "sync", "qa", "cmd", "ck", "sci", "cmp", "sys", "cn", "co", "sq", "cv", "conn"], "eaddr": ["EWfr", "eedbr", "eeder", "eadrr", "eebr", "evhr", "evder", "awdress", "eeDR", "ebDr", "eedDr", "awdr", "ebDR", "edrr", "elrr", "eedDR", "elder", "eddDR", "eerid", "eddbr", "eadDr", "eadbr", "eefr", "ealDR", "EWdr", "edder", "eaddress", "eldr", "eeddr", "ebdress", "eadder", "ebdr", "elhr", "aybr", "ayDR", "ealbr", "eedrr", "eadrid", "eddr", "awDr", "evdr", "EWDR", "aydr", "ayder", "eeddress", "edhr", "eedhr", "ealdr", "ealhr", "ealder", "edddr", "evrr", "eadDR", "eddder", "eadfr", "awDR", "eedr", "ealrr", "EWrid", "eedder", "eadhr"], "rw": ["rx", "wp", "rr", "fw", "wx", "RW", "r", "worker", "wl", "rack", "sw", "wb", "rg", "rew", "kw", "ew", "wk", "hw", "nr", "feat", "ww", "ffff", "w", "sr", "sth", "nw", "rb", "wer", "wr", "tw", "wu", "wh", "wn", "wa", "usr"], "in_plb": ["in_clbh", "in_plp", "in_plugbh", "in_PLa", "in_flB", "in_clB", "in_plc", "in_slb", "in_clb", "in_flab", "in_pelbh", "in_PLb", "in_plab", "in_plugb", "in_plugB", "in_cla", "in_pla", "in_plbh", "in_plugp", "in_clab", "in_plB", "in_fla", "in_flb", "in_slab", "in_clp", "in_pelp", "in_pelb", "in_clc", "in_slB", "in_pelB", "in_PLc", "in_sla", "in_PLp"], "ret": ["part", "code", "data", "al", "ref", "alt", "let", "lit", "r", "nt", "reg", "fun", "rt", "rc", "result", "try", "num", "sb", "match", "pass", "resp", "rets", "count", "def", "lt", "arg", "att", "art", "out", "val", "re", "Ret", "feat", "reset", "back", "last", "rot", "det", "fit", "id", "rev", "cur", "rl", "rb", "gt", "RET", "pet", "res", "mt", "ft", "valid", "addr", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "void ff_xvmc_field_end(MpegEncContext *s)\n\n{\n\n    struct xvmc_pix_fmt *render = (struct xvmc_pix_fmt*)s->current_picture.f.data[2];\n\n    assert(render);\n\n\n\n    if (render->filled_mv_blocks_num > 0)\n\n        ff_mpeg_draw_horiz_band(s, 0, 0);\n\n}\n", "idx": 16437, "substitutes": {"s": ["ns", "m", "ts", "session", "styles", "stats", "rs", "t", "conf", "f", "request", "settings", "services", "details", "sb", "g", "ss", "src", "as", "ops", "ctx", "scope", "fs", "self", "o", "cs", "sports", "context", "qs", "e", "ssl", "ses", "sync", "c", "ps", "js", "si", "p", "b", "gs", "es", "os", "sets", "sq", "ds"], "render": ["plot", "record", "mir", "shape", "element", "err", "color", "hide", "r", "nder", "apply", "report", "result", "Render", "make", "match", "effect", "run", "rendered", "replace", "after", "design", "load", "pair", "cover", "header", "parse", "draw", "build", "aster", "style", "use", "response", "open", "be", "layout", "material", "xml", "flower", "transform", "save", "frame", "callback", "before", "end", "attr", "author", "round"]}}
{"project": "qemu", "commit_id": "8786db7cb96f8ce5c75c6e1e074319c9dca8d356", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449, "substitutes": {"mr": ["pc", "m", "rr", "fr", "MR", "rs", "vr", "err", "r", "md", "rm", "rt", "mi", "bm", "mn", "pm", "rh", "rg", "mc", "rf", "manager", "kr", "nr", "sr", "dr", "lr", "yr", "mx", "rw", "ur", "wr", "pr", "adr", "er", "mt", "mm", "Mr", "gr", "attr", "RM"]}}
{"project": "FFmpeg", "commit_id": "c96f3750c22ef1576a46140f3101e3585041f41f", "target": 0, "func": "pp_mode *pp_get_mode_by_name_and_quality(const char *name, int quality)\n\n{\n\n    char temp[GET_MODE_BUFFER_SIZE];\n\n    char *p= temp;\n\n    static const char filterDelimiters[] = \",/\";\n\n    static const char optionDelimiters[] = \":\";\n\n    struct PPMode *ppMode;\n\n    char *filterToken;\n\n\n\n    ppMode= av_malloc(sizeof(PPMode));\n\n\n\n    ppMode->lumMode= 0;\n\n    ppMode->chromMode= 0;\n\n    ppMode->maxTmpNoise[0]= 700;\n\n    ppMode->maxTmpNoise[1]= 1500;\n\n    ppMode->maxTmpNoise[2]= 3000;\n\n    ppMode->maxAllowedY= 234;\n\n    ppMode->minAllowedY= 16;\n\n    ppMode->baseDcDiff= 256/8;\n\n    ppMode->flatnessThreshold= 56-16-1;\n\n    ppMode->maxClippedThreshold= 0.01;\n\n    ppMode->error=0;\n\n\n\n    memset(temp, 0, GET_MODE_BUFFER_SIZE);\n\n    av_strlcpy(temp, name, GET_MODE_BUFFER_SIZE - 1);\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: %s\\n\", name);\n\n\n\n    for(;;){\n\n        char *filterName;\n\n        int q= 1000000; //PP_QUALITY_MAX;\n\n        int chrom=-1;\n\n        int luma=-1;\n\n        char *option;\n\n        char *options[OPTIONS_ARRAY_SIZE];\n\n        int i;\n\n        int filterNameOk=0;\n\n        int numOfUnknownOptions=0;\n\n        int enable=1; //does the user want us to enabled or disabled the filter\n\n\n\n        filterToken= strtok(p, filterDelimiters);\n\n        if(filterToken == NULL) break;\n\n        p+= strlen(filterToken) + 1; // p points to next filterToken\n\n        filterName= strtok(filterToken, optionDelimiters);\n\n        av_log(NULL, AV_LOG_DEBUG, \"pp: %s::%s\\n\", filterToken, filterName);\n\n\n\n        if(*filterName == '-'){\n\n            enable=0;\n\n            filterName++;\n\n        }\n\n\n\n        for(;;){ //for all options\n\n            option= strtok(NULL, optionDelimiters);\n\n            if(option == NULL) break;\n\n\n\n            av_log(NULL, AV_LOG_DEBUG, \"pp: option: %s\\n\", option);\n\n            if(!strcmp(\"autoq\", option) || !strcmp(\"a\", option)) q= quality;\n\n            else if(!strcmp(\"nochrom\", option) || !strcmp(\"y\", option)) chrom=0;\n\n            else if(!strcmp(\"chrom\", option) || !strcmp(\"c\", option)) chrom=1;\n\n            else if(!strcmp(\"noluma\", option) || !strcmp(\"n\", option)) luma=0;\n\n            else{\n\n                options[numOfUnknownOptions] = option;\n\n                numOfUnknownOptions++;\n\n            }\n\n            if(numOfUnknownOptions >= OPTIONS_ARRAY_SIZE-1) break;\n\n        }\n\n        options[numOfUnknownOptions] = NULL;\n\n\n\n        /* replace stuff from the replace Table */\n\n        for(i=0; replaceTable[2*i]!=NULL; i++){\n\n            if(!strcmp(replaceTable[2*i], filterName)){\n\n                int newlen= strlen(replaceTable[2*i + 1]);\n\n                int plen;\n\n                int spaceLeft;\n\n\n\n                if(p==NULL) p= temp, *p=0;      //last filter\n\n                else p--, *p=',';               //not last filter\n\n\n\n                plen= strlen(p);\n\n                spaceLeft= p - temp + plen;\n\n                if(spaceLeft + newlen  >= GET_MODE_BUFFER_SIZE - 1){\n\n                    ppMode->error++;\n\n                    break;\n\n                }\n\n                memmove(p + newlen, p, plen+1);\n\n                memcpy(p, replaceTable[2*i + 1], newlen);\n\n                filterNameOk=1;\n\n            }\n\n        }\n\n\n\n        for(i=0; filters[i].shortName!=NULL; i++){\n\n            if(   !strcmp(filters[i].longName, filterName)\n\n               || !strcmp(filters[i].shortName, filterName)){\n\n                ppMode->lumMode &= ~filters[i].mask;\n\n                ppMode->chromMode &= ~filters[i].mask;\n\n\n\n                filterNameOk=1;\n\n                if(!enable) break; // user wants to disable it\n\n\n\n                if(q >= filters[i].minLumQuality && luma)\n\n                    ppMode->lumMode|= filters[i].mask;\n\n                if(chrom==1 || (chrom==-1 && filters[i].chromDefault))\n\n                    if(q >= filters[i].minChromQuality)\n\n                            ppMode->chromMode|= filters[i].mask;\n\n\n\n                if(filters[i].mask == LEVEL_FIX){\n\n                    int o;\n\n                    ppMode->minAllowedY= 16;\n\n                    ppMode->maxAllowedY= 234;\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        if(  !strcmp(options[o],\"fullyrange\")\n\n                           ||!strcmp(options[o],\"f\")){\n\n                            ppMode->minAllowedY= 0;\n\n                            ppMode->maxAllowedY= 255;\n\n                            numOfUnknownOptions--;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == TEMP_NOISE_FILTER)\n\n                {\n\n                    int o;\n\n                    int numOfNoises=0;\n\n\n\n                    for(o=0; options[o]!=NULL; o++){\n\n                        char *tail;\n\n                        ppMode->maxTmpNoise[numOfNoises]=\n\n                            strtol(options[o], &tail, 0);\n\n                        if(tail!=options[o]){\n\n                            numOfNoises++;\n\n                            numOfUnknownOptions--;\n\n                            if(numOfNoises >= 3) break;\n\n                        }\n\n                    }\n\n                }\n\n                else if(filters[i].mask == V_DEBLOCK   || filters[i].mask == H_DEBLOCK\n\n                     || filters[i].mask == V_A_DEBLOCK || filters[i].mask == H_A_DEBLOCK){\n\n                    int o;\n\n\n\n                    for(o=0; options[o]!=NULL && o<2; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        if(o==0) ppMode->baseDcDiff= val;\n\n                        else ppMode->flatnessThreshold= val;\n\n                    }\n\n                }\n\n                else if(filters[i].mask == FORCE_QUANT){\n\n                    int o;\n\n                    ppMode->forcedQuant= 15;\n\n\n\n                    for(o=0; options[o]!=NULL && o<1; o++){\n\n                        char *tail;\n\n                        int val= strtol(options[o], &tail, 0);\n\n                        if(tail==options[o]) break;\n\n\n\n                        numOfUnknownOptions--;\n\n                        ppMode->forcedQuant= val;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n        if(!filterNameOk) ppMode->error++;\n\n        ppMode->error += numOfUnknownOptions;\n\n    }\n\n\n\n    av_log(NULL, AV_LOG_DEBUG, \"pp: lumMode=%X, chromMode=%X\\n\", ppMode->lumMode, ppMode->chromMode);\n\n    if(ppMode->error){\n\n        av_log(NULL, AV_LOG_ERROR, \"%d errors in postprocess string \\\"%s\\\"\\n\", ppMode->error, name);\n\n        av_free(ppMode);\n\n        return NULL;\n\n    }\n\n    return ppMode;\n\n}\n", "idx": 16452, "substitutes": {"name": ["part", "time", "code", "data", "info", "search", "base", "image", "comment", "ame", "n", "current", "block", "anc", "type", "max", "package", "Name", "filename", "label", "NAME", "alias", "new", "path", "size", "space", "memory", "w", "prefix", "key", "named", "q", "config", "length", "id", "v", "parent", "table", "address", "none", "resource", "names", "word", "version"], "quality": ["scale", "quant", " q", "base", "qual", "quiet", "query", "resolution", "Q", "priority", "Quality", "val", "secure", "format", "grade", " qual", "style", "comp", "q", "qa", "depth", "lock", "level", "weight", "valid", "value", "custom", "version"], "temp": ["pt", "dc", "wp", "Temp", "tem", "content", "t", "data", "base", "wrap", "pool", "buffer", "try", "str", "current", "block", "clean", "type", "method", "var", "cp", "package", "sw", "font", "zip", "mem", "copy", "enc", "fake", "context", "flat", "empty", "format", "path", "pre", "memory", "cel", "tc", "config", "pipe", "ex", "v", "EMP", "tmp", "c", "cur", "table", "emp", "test", "cache", "lock", "null", "output", "col", "form", "storage", "opt", "template", "iter", "source", "params", "input"], "p": ["pc", "m", "offset", "s", "j", "t", "data", "fp", "f", "jp", "sp", "r", "pe", "n", "g", "cp", "lp", "y", "pos", "l", "d", "array", "pp", "path", "pi", "pre", "start", "e", "q", "v", "c", "ps", "b", "pr", "h", "a", "tp", "php", "port", "it", "np", "params", "P"], "filterDelimiters": ["filterDeligniterers", "filterDelimitars", "filterDelimitserers", "filterDelimitearies", "filterDelignitserers", "filterDelimitings", "filterDelimiteings", "filterDelimalaries", "filterDelimiterters", "filterDelititerers", "filterDelititings", "filterDelignitsers", "filterDelimalers", "filterDelimiteters", "filterDelimitizars", "filterDelimalings", "filterDelititters", "filterDelititaries", "filterDelimitters", "filterDelimiteers", "filterDelimalters", "filterDelimitizerers", "filterDelimitears", "filterDelimitizings", "filterDelimitsers", "filterDelimitsings", "filterDelimitizers", "filterDelignitsars", "filterDelignitsings", "filterDelimitsars", "filterDelititers", "filterDelimiterings", "filterDelimitaries", "filterDeligniters", "filterDelignitings", "filterDelititeraries", "filterDelititerings", "filterDelimiterers", "filterDelimiteerers", "filterDelititerters", "filterDelimiteraries", "filterDelignitars"], "optionDelimiters": ["optionDelimimers", "optionDelimitererers", "optionDelititters", "optionDelamiterers", "optionDelimitedERS", "optionDelaritters", "optionDelititereners", "optionDelimITERS", "optionDelimitators", "optionDelimiteners", "optionDelamiters", "optionDelamitators", "optionDelimimerers", "optionDelimitters", "optionDelititerers", "optionDelimitereners", "optionDelimimators", "optionDelamitedERS", "optionDelariters", "optionDelimITers", "optionDelimITeners", "optionDelimitedeners", "optionDelititeners", "optionDelimiterer", "optionDelimiteders", "optionDelimITer", "optionDelititerters", "optionDelimitERS", "optionDelimiteder", "optionDelimimer", "optionDelimiterators", "optionDelimitederers", "optionDelititers", "optionDelariter", "optionDelaritERS", "optionDelititer", "optionDelimimters", "optionDelimiterERS", "optionDelimitedators", "optionDelarITer", "optionDelamiteders", "optionDelarITers", "optionDelamitedators", "optionDelarITERS", "optionDelarITters", "optionDelimitedters", "optionDelimiter", "optionDelititerer", "optionDelamitederers", "optionDelimiterters", "optionDelamitERS", "optionDelimimERS", "optionDelimiterers", "optionDelimITters"], "ppMode": ["ppEngine", " ppStream", "pMo", "ppOwner", "ppaMODE", " ppStatus", "ppStream", " ppModel", "cppEntry", "cppModel", "ppHalf", "wpConfig", "PPCopy", "PPRole", "PPMode", "PPKind", "cppMo", "ppManager", "ppaConfig", "ppConfig", "ppsManager", "wpMODE", "ppStatus", " ppCmd", "plModel", "ppKind", "ppaManager", "phpModule", "ppsMac", "cppSync", " ppDevice", "ppsModule", "ppMac", "ppCmd", "ppModule", "pxInfo", "ppSync", "bbDevice", "ampMode", "phpMo", "bbMode", "bbHalf", "ampEntry", "cppKind", "ppsEngine", "PPCmd", "peBlock", " ppBlock", "wpMode", "peModule", " ppMo", " ppCopy", " ppKind", " ppHalf", "ppsInfo", "ampMo", "pModule", "ppRole", "PPOwner", "wpCmd", "bbModule", "ppInfo", "pKind", "cppInfo", "cppMac", "PPManager", "pMode", "ppModel", " ppModule", " ppMODE", " ppEngine", "cppMask", "ppEntry", "pOwner", "PPMODE", "pCmd", "peMode", "cppMode", "pMech", "cppDevice", "ppaMode", "ppDevice", "ppMo", "phpMech", "bbSync", "PPModule", "pxMode", "plMode", "ppMech", "pStatus", "cppManager", "ppaMo", "ampManager", "ppMask", "pxModule", "ppBlock", "ppsRole", "PPMac", "ppaCmd", "ppMODE", "plStream", "PPEngine", "cppHalf", "cppCmd", " ppOwner", "cppConfig", "plKind", "pCopy", "ppsMask", "PPModel", " ppSync", "ppaEntry", "cppModule", "ppsMode", "peStatus", "pxMask", "pBlock", " ppMech", "cppRole", " ppManager", "ppCopy", "PPStream", "bbCmd", "cppMODE", "phpMode"], "filterToken": ["searchTokens", "filterTokens", "searchByte", "searchoken", "finaltoken", " filtertoken", "filValue", "outputName", "FilterTokens", "filterMin", "sortTokens", "filName", " filterByte", "filtertoken", "filtoken", "filTokens", " filterCode", "filToken", "outputKey", "filterKey", "sortCode", "sortName", " filterMin", "filterByte", " filterKey", "filCode", "searchName", "filoken", "outputValue", "FilterName", "filteroken", "finalToken", " filterTokens", " filterValue", "filKey", "sortToken", " filteroken", "filterCode", "filMin", "searchNode", "filterValue", "searchToken", "outputToken", "filByte", "filNode", "finalName", "finalMin", "FilterToken", " filterNode", "filterNode"], "filterName": ["searchname", "classToken", "formatText", "sortname", "filString", "formatToken", "formatname", " filterNo", "filName", " filterInfo", "filterNo", "FilterInfo", "sortNo", "filname", " filterCode", "channelname", "filToken", "maskCode", "filterText", " filterText", "sortName", " filterString", "channelName", "filtername", "formatName", "searchName", "FilterName", "maskInfo", "FilterPart", "filterString", "filPart", "sortToken", "FilterCode", "filterInfo", "classname", "channelText", " filterPart", "FilterString", "filterCode", "maskName", "channelToken", "searchToken", " filtername", "classNo", "filterPart", "FilterToken", "className", "maskToken"], "option": ["ion", "term", "archive", "user", "optional", "element", "token", "attribute", "op", "comment", "Option", "image", "choice", "color", "block", "cho", "type", "match", "package", "optim", "public", "function", "attr", "object", "equ", "other", "profile", "change", "alias", "original", "event", "text", "value", "key", "open", "update", "position", "argument", "item", "resource", "route", "opt", "connection", "ption", "operation", "section", "custom", "expression"], "options": ["classes", "values", "s", "optional", "settings", "eps", "times", "objects", "files", "ops", "object", "other", "array", "args", "config", "cache", "multiple", "opt", "names", "errors", "groups", "Options", "value", "params"], "OPTIONS_ARRAY_SIZE": ["OPTIONS_AROW_USE", "OPTIONS_AROW_MODE", "OPTIONS_AROW_SIZE", "OPTIONS_AROW_SEC", "OPTIONS_ARRAY_SEC", "OPTIONS_ARRAY_USE", "OPTIONS_ARRAY_MODE"], "i": ["m", "j", "info", "f", "n", "ii", "in", "di", "index", "I", "is", "ip", "l", "d", "pi", "ci", "id", "start", "e", "c", "ni", "b", "h", "it", "li", "u"], "numOfUnknownOptions": ["numOfUnknownOP", "numOfUnknownParts", "numOfKnownOption", "numofunknownOptions", "numofunknownParts", "numofUnknownOP", "numofunknownOption", "numOfunknownParts", "numofUnknownOption", "numofunknownOP", "numOfNewOptions", "numOfUnknownOption", "numOfKnownOptions", "numofUnknownOptions", "numOfNewOP", "numofUnknownParts", "numOfNewParts", "numOfunknownOP", "numOfunknownOptions", "numOfKnownOP", "numOfunknownOption", "numOfNewOption", "numOfKnownParts"], "error": ["code", "data", "info", "err", "call", "comment", "debug", "version", "result", "query", "block", "type", "close", "layer", "grade", "fail", "last", "delay", "batch", "parent", "loss", "patch", "row", "errors", "Error", "progress", "success", "warning", "bug"]}}
{"project": "qemu", "commit_id": "231bb267644ee3a9ebfd9c7f42d5d41610194b45", "target": 1, "func": "int qcow2_write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs,\n\n            QCOW2_OL_DEFAULT & ~QCOW2_OL_ACTIVE_L1,\n\n            s->l1_table_offset + 8 * l1_start_index, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite_sync(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 16465, "substitutes": {"bs": ["ns", "ab", "ros", "eb", "bi", "db", "lbs", "blog", "core", "obj", "ob", "las", "rs", "plugins", "sb", "cb", "bc", "ls", "ss", "src", "pb", "fs", "lb", "bb", "ba", "bid", "cs", "css", "gb", "bos", "ins", "obs", "outs", "BS", "iss", "blocks", "bis", "abi", "bl", "vs", "fb", "bh", "ses", "bas", "js", "rb", "bits", "b", "ks", "ec", "es", "bytes", "os", "state", "bes", "banks", "us", "ds"], "l1_index": ["l2_index", "l2_i", "l1_Index", "l1_i", "l1rindex", "l1roffset", "l2_Index", "l1rIndex", "l1_offset", "l1_length", "l1raddress", "l1_address", "l2_offset", "l2_length", "l2_address"], "s": ["ns", "spec", "session", "ts", "stats", "rs", "uns", "f", "settings", "services", "r", "n", "ubs", "sb", "sl", "ss", "ls", "ops", "fs", "xs", "is", "cs", "d", "su", "ins", "args", "site", "w", "bis", "qs", "e", "ssl", "vs", "ses", "v", "c", "js", "si", "ps", "sym", "p", "S", "b", "ks", "gs", "sys", "its", "es", "os", "state", "us", "sets", "states", "ds"], "buf": ["Buffer", "ab", "bin", "br", "fw", "ff", "db", "data", "af", "func", "base", "fp", "text", "pool", "buffer", "rc", "vec", "fi", "stab", "result", "cf", "block", "cb", "bc", "Buff", "wb", "ctx", "fab", "pb", "bb", "mem", "ba", "cas", "gb", "conv", "bed", "bf", "box", "aux", "img", "config", "queue", "bd", "fd", "buff", "bh", "fb", "cat", "v", "ucc", "tmp", "seq", "cmd", "uc", "rb", "pad", "b", "null", "cap", "alloc", "proc", "bytes", "port", "bag", "uf", "cv"], "l1_start_index": ["l1_start_size", "l1_end_size", "l1_start1size", "l1_start64offset", "l1_start_end", "l1_end_end", "l1_end_value", "l1_end_shape", "l1_start_offset", "l1_start64size", "l1_start_ind", "l1_start1offset", "l1_start_position", "l1_start64index", "l1_end_ind", "l1_startpindex", "l1_end_offset", "l1_startpend", "l1_startpposition", "l1_start64ind", "l1_start1ind", "l1_start1index", "l1_end_index", "l1_start_shape", "l1_end_point", "l1_start_value", "l1_end_position", "l1_start_point"], "i": ["gi", "uri", "ti", "m", "bi", "j", "ji", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "z", "ii", "in", "di", "iu", "index", "I", "zi", "o", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "lc", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "anti", "u", "h", "a", "it", "eni", "fi", "li", "len"], "ret": ["vr", "al", "bit", "ref", "err", "f", "alt", "obj", "reg", "rc", "nt", "mi", "rt", "r", "fun", "result", "num", "lit", "rel", "flag", "match", "bc", "pass", "ext", "run", "rf", "active", "resp", "rets", "en", "def", "get", "out", "arg", "att", "art", "arr", "bad", "val", "re", "Ret", "feat", "bf", "reset", "back", "id", "det", "rev", "cat", "rb", "ur", "repl", "RET", "error", "red", "res", "mt", "ft", "fi", "reply", "success", "len"]}}
{"project": "qemu", "commit_id": "f46e9a0b9911fcfbc13f85f3a8808067990a0f5c", "target": 0, "func": "static void zero_bss(abi_ulong elf_bss, abi_ulong last_bss, int prot)\n\n{\n\n    uintptr_t host_start, host_map_start, host_end;\n\n\n\n    last_bss = TARGET_PAGE_ALIGN(last_bss);\n\n\n\n    /* ??? There is confusion between qemu_real_host_page_size and\n\n       qemu_host_page_size here and elsewhere in target_mmap, which\n\n       may lead to the end of the data section mapping from the file\n\n       not being mapped.  At least there was an explicit test and\n\n       comment for that here, suggesting that \"the file size must\n\n       be known\".  The comment probably pre-dates the introduction\n\n       of the fstat system call in target_mmap which does in fact\n\n       find out the size.  What isn't clear is if the workaround\n\n       here is still actually needed.  For now, continue with it,\n\n       but merge it with the \"normal\" mmap that would allocate the bss.  */\n\n\n\n    host_start = (uintptr_t) g2h(elf_bss);\n\n    host_end = (uintptr_t) g2h(last_bss);\n\n    host_map_start = (host_start + qemu_real_host_page_size - 1);\n\n    host_map_start &= -qemu_real_host_page_size;\n\n\n\n    if (host_map_start < host_end) {\n\n        void *p = mmap((void *)host_map_start, host_end - host_map_start,\n\n                       prot, MAP_FIXED | MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n\n        if (p == MAP_FAILED) {\n\n            perror(\"cannot mmap brk\");\n\n            exit(-1);\n\n        }\n\n\n\n        /* Since we didn't use target_mmap, make sure to record\n\n           the validity of the pages with qemu.  */\n\n        page_set_flags(elf_bss & TARGET_PAGE_MASK, last_bss, prot|PAGE_VALID);\n\n    }\n\n\n\n    if (host_start < host_map_start) {\n\n        memset((void *)host_start, 0, host_map_start - host_start);\n\n    }\n\n}\n", "idx": 16483, "substitutes": {"elf_bss": ["elf_bess", "elf_abSS", "elf_bass", "elf_cbss", "elf_fbass", "elf_abess", "elf_dboss", "elf_goss", "elf_abss", "elf_aboss", "elf_fbSS", "elf_bsl", "elf_abiss", "elf_cbass", "elf_cbSS", "elf_boss", "elf_gss", "elf_biss", "elf_abse", "elf_fbiss", "elf_dbsl", "elf_gsl", "elf_bSS", "elf_dbss", "elf_cboss", "elf_gse", "elf_fboss", "elf_absl", "elf_fbess", "elf_abass", "elf_dbse", "elf_fbss", "elf_bse"], "last_bss": ["last_bbuss", "last_nbiss", "last_fcss", "last_Bess", "last_bbSS", "last_cbiss", "last_lbss", "last_bbss", "last_lbuss", "last_bse", "last_buss", "last_abcss", "last_cboss", "last__bss", "last_Bcss", "last__cbiss", "last_abss", "last__bSS", "last_foss", "last_bbcss", "last_nbSS", "last_bess", "last_biss", "last__cbss", "last_lbse", "last_bbiss", "last_cbse", "last_cbss", "last_bbess", "last_cbSS", "last_nbss", "last_abess", "last_abiss", "last_bboss", "last__biss", "last_bcss", "last_nbess", "last_Bss", "last_fess", "last_bbass", "last_bass", "last__bess", "last_Boss", "last_cbess", "last_aboss", "last_fss", "last__cbSS", "last_bbse", "last_bSS", "last_abass", "last__cbess", "last_lboss", "last_boss", "last_cbuss"], "prot": ["status", "stat", "pattern", "ret", "txt", "rog", "ocol", "mode", "pred", "ref", "platform", "conn", " protocols", "ne", "io", "type", "ext", "termin", "def", "en", "fen", "dim", "nat", "prop", "gap", " proto", "fl", "header", "conv", "format", "path", "pre", "pri", "reset", "prefix", "rot", "config", "primary", "chron", " protocol", "comb", "cli", "neg", "seq", "afi", "rin", "two", "next", "col", "opt", "pro", "Prot", "period", "transfer", "typ"], "host_start": ["server_range", "host__end", "host_part", "host_count", "host__search", "hostPstate", "hostsstart", "server_count", "host_shift", "hostPstart", "server_part", "page_shift", "host00start", "host__start", "host___end", "host_info", "hostsend", "server_min", "server_end", "host_state", "server_size", "host___start", "hostsmin", "host_search", "server_start", "hostPend", "server_search", "server_info", "host_min", "host8start", "hostPsize", "host_size", "host_range", "host_starting", "host___count", "host8size", "host__starting", "host00starting", "hostsinfo", "server_starting", "server_state", "page_size", "host00search", "page_start", "host8shift", "host00end", "host8starting", "page_starting", "host___part"], "host_map_start": ["host_data_id", "host_list_id", "host_block_start", "host_block_length", "host_list_start", "host_block_ish", "host_map_ish", "host_block_left", "host_map_length", "host_data_start", "host_list_max", "host_map_size", "host_data_size", "host_map_end", "host_map_int", "host_map_max", "host_map_cost", "host_map_range", "host_block_range", "host_block_stop", "host_data_end", "host_block_end", "host_map_id", "host_block_int", "host_map_stop", "host_map_next", "host_data_stop", "host_data_next", "host_block_cost", "host_map_left", "host_block_id", "host_list_end"], "host_end": ["host2ending", "host2offset", "hostsstart", "host_End", "port_end", "server_length", "host_offset", "host0End", "hostsend", "server_end", "host_ended", "host0ended", "hostsstop", " host_ended", "host0start", "server_start", "port_start", "host_id", "host_length", "port_stop", "server_id", "host2start", "host2end", "server_ending", "host0end", "server_offset", " host_End", "host_stop", "host_ending"], "p": ["pc", "per", "wp", "m", "s", "t", "f", "jp", "op", "sp", "vp", "pe", "n", "pm", "g", "i", "cp", "lp", "ap", "o", "po", "pg", "l", "d", "pp", "pi", "pre", "e", "pa", "v", "c", "ps", "b", "api", "tp", "np", "P", "u"]}}
{"project": "FFmpeg", "commit_id": "bcd7bf7eeb09a395cc01698842d1b8be9af483fc", "target": 0, "func": "static void avc_biwgt_4x4multiple_msa(uint8_t *src,\n\n                                      int32_t src_stride,\n\n                                      uint8_t *dst,\n\n                                      int32_t dst_stride,\n\n                                      int32_t height,\n\n                                      int32_t log2_denom,\n\n                                      int32_t src_weight,\n\n                                      int32_t dst_weight,\n\n                                      int32_t offset_in)\n\n{\n\n    uint8_t cnt;\n\n    uint32_t load0, load1, load2, load3;\n\n    v16i8 src_wgt, dst_wgt, wgt;\n\n    v16i8 src0, src1, src2, src3;\n\n    v16i8 dst0, dst1, dst2, dst3;\n\n    v8i16 temp0, temp1, temp2, temp3;\n\n    v8i16 denom, offset, add_val;\n\n    int32_t val = 128 * (src_weight + dst_weight);\n\n\n\n    offset_in = ((offset_in + 1) | 1) << log2_denom;\n\n\n\n    src_wgt = __msa_fill_b(src_weight);\n\n    dst_wgt = __msa_fill_b(dst_weight);\n\n    offset = __msa_fill_h(offset_in);\n\n    denom = __msa_fill_h(log2_denom + 1);\n\n    add_val = __msa_fill_h(val);\n\n    offset += add_val;\n\n\n\n    wgt = __msa_ilvev_b(dst_wgt, src_wgt);\n\n\n\n    for (cnt = height / 4; cnt--;) {\n\n        LOAD_4WORDS_WITH_STRIDE(src, src_stride, load0, load1, load2, load3);\n\n        src += (4 * src_stride);\n\n\n\n        src0 = (v16i8) __msa_fill_w(load0);\n\n        src1 = (v16i8) __msa_fill_w(load1);\n\n        src2 = (v16i8) __msa_fill_w(load2);\n\n        src3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        LOAD_4WORDS_WITH_STRIDE(dst, dst_stride, load0, load1, load2, load3);\n\n\n\n        dst0 = (v16i8) __msa_fill_w(load0);\n\n        dst1 = (v16i8) __msa_fill_w(load1);\n\n        dst2 = (v16i8) __msa_fill_w(load2);\n\n        dst3 = (v16i8) __msa_fill_w(load3);\n\n\n\n        XORI_B_4VECS_SB(src0, src1, src2, src3, src0, src1, src2, src3, 128);\n\n\n\n        XORI_B_4VECS_SB(dst0, dst1, dst2, dst3, dst0, dst1, dst2, dst3, 128);\n\n\n\n        ILVR_B_4VECS_SH(src0, src1, src2, src3, dst0, dst1, dst2, dst3,\n\n                        temp0, temp1, temp2, temp3);\n\n\n\n        temp0 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp0);\n\n        temp1 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp1);\n\n        temp2 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp2);\n\n        temp3 = __msa_dpadd_s_h(offset, wgt, (v16i8) temp3);\n\n\n\n        SRA_4VECS(temp0, temp1, temp2, temp3,\n\n                  temp0, temp1, temp2, temp3, denom);\n\n\n\n        temp0 = CLIP_UNSIGNED_CHAR_H(temp0);\n\n        temp1 = CLIP_UNSIGNED_CHAR_H(temp1);\n\n        temp2 = CLIP_UNSIGNED_CHAR_H(temp2);\n\n        temp3 = CLIP_UNSIGNED_CHAR_H(temp3);\n\n\n\n        PCKEV_B_STORE_4_BYTES_4(temp0, temp1, temp2, temp3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n    }\n\n}\n", "idx": 16498, "substitutes": {"src": ["stat", "sup", "rs", "dest", "ctr", "RC", "scene", "rc", "sb", "stream", "sl", "cb", "loc", "sel", "ctx", "filename", "low", "gb", "rob", "secure", "feat", "stack", "rib", "comp", "sil", "img", "config", "sc", "ssl", "gl", "send", "sync", "scl", "cur", "req", "rb", "seq", "uc", "url", "sci", "depth", "sys", "inst", "transform", "desc", "sq", "source", "dist"], "src_stride": ["src_strided", "src_STRride", "src_Stride", "src_brine", "src_strides", "src_trride", "src_bride", "src_STRided", "src_brIDE", "src_rride", "src_tride", "src_striided", "src_strine", "src_brided", "src_Strided", "src_Strride", "src_trides", "src_trided", "src_rides", "src_STRine", "src_ride", "src_STRide", "src_rided", "src_strride", "src_brides", "src_brride", "src_StrIDE", "src_trIDE", "src_striride", "src_striine", "src_strIDE", "src_striide"], "dst": ["dsrc", " dsts", "Dsc", "sdsc", "Dsrc", " dsc", "Dst", "sdsrc", "sdsts", "dsts", " dsrc", "dsc", "Dsts", "sdst"], "dst_stride": ["dst_ride", "dst_tride", "dst_rides", "dst_striides", "dst_trided", "dst_trider", "dst_striide", "dst_trides", "dst_rided", "dst_striided", "dst_strided", "dst_strides", "dst_rider", "dst_strider", "dst_striider"], "height": ["thin", "shape", "data", "input", "window", "block", "top", "resolution", "y", "th", "padding", "index", "above", "xy", "dim", "def", "count", "upper", "bottom", "gap", "size", "build", "style", "dy", "img", "length", "config", "gpu", "id", "high", "deep", "layout", "history", "rows", "Height", "depth", "level", "row", "repeat", "grow", "version", "dist"], "log2_denom": ["log2_pronOM", "log2_denot", "log2_denorm", "log2_denoc", "log2_Denoc", "log2_nanoc", "log2_pronomal", "log2_nanom", "log2_Denomal", "log2_Denoms", "log2_denoms", "log2_nanot", "log2_DENOM", "log2_nanoms", "log2_danOM", "log2_Denom", "log2_danot", "log2_danom", "log2_DenOM", "log2_denow", "log2_DENom", "log2_danoc", "log2_Denot", "log2_pronow", "log2_pronom", "log2_denomal", "log2_nanorm", "log2_Denorm", "log2_DENoms", "log2_denOM", "log2_nanOM", "log2_DENorm", "log2_Denow"], "src_weight": ["srcPbalance", "sr_pool", "sb_mean", "src_margin", "src64force", "sb64force", "srcPwidth", "source_width", "src_force", "sb64mean", "srPweight", "src_mean", "src_balance", "sb_weight", "src64weight", "src_pool", "srPwidth", "sb_margin", "sr_weight", "sb64weight", "sr_balance", "src_width", "sb64margin", "source_weight", "srPpool", "src64mean", "sb_force", "source_Weight", "srcPpool", "srPbalance", "srcPweight", "src_Weight", "sr_width", "src64margin"], "dst_weight": ["drc_work", "dstallweights", "dst_width", "dstallweight", "dst_weights", "dest_width", "dstallload", "drc_width", "dstalldepth", "dsrcacdepth", "dst_depth", "dsrc_load", "dstacload", "dsrcacweight", "dest_balance", "dst_cost", "dstacweight", "dsrc_weight", "drc_cost", "dsrc_weights", "dstacdepth", "dst_work", "dsrcacload", "dsrc_depth", "dest_max", "dest_weight", "dst_balance", "dst_load", "dsrcacweights", "drc_weight", "dstacweights", "dst_max"], "offset_in": ["offsetPinc", "reference_win", "offset_min", "offset67ini", "error_ins", "offset_out", "reference67ini", "offset_inner", "offsetPout", "offset_bin", "reference67win", "align_i", "offsetPin", "offset_left", "offset_ini", "attributePout", "offsetPleft", "offset_i", "offset_inc", "offset67t", "reference_ini", "offset_ins", "attributePin", "attribute_left", "error_in", "attribute_inc", "align_inner", "offset_win", "reference_t", "attribute_in", "offset67in", "reference67t", "attributePinc", "error_min", "offset67win", "error_out", "reference_in", "align_bin", "offset_t", "attributePleft", "attribute_out", "reference67in", "align_in"], "cnt": ["scnt", "acnc", "cnd", "acnt", "ncnt", "dcnt", " cNT", " cnc", "dcnd", " cnd", "gnt", "ncNT", "dcant", "fcnd", "count", "ncount", "fcnt", "fcnc", "cont", "acnd", "gant", " count", "scant", "scnd", "fcount", "gont", "cNT", "ncnd", "acount", "gnd", "cant", "acNT", "dcont", "scont", "cnc"], "load0": ["read8", "call0", "read0", "Load1", "Load88", "load8", " load8", "loading1", "read2", "call2", "loading2", "load88", "call1", "Load2", " load88", "loading0", "read1", "call8", "Load0", "loading88", "Load8"], "load1": ["read0", "Load4", "loaderOne", "Load1", "loader1", "loadOne", "wait01", "wait0", "Load01", " loadOne", "read4", "wait4", "read2", "play2", "play01", "read3", "Load3", "read01", "load4", "play1", "Load2", "read1", "play3", "loader2", "wait1", "Load0", "load01", "LoadOne"], "load2": ["load5", "lock2", "show5", "play8", "Load1", "loader1", "load8", " load8", "show2", " load5", "play2", " loadtwo", "load4", "lock4", "play1", "Load2", "loadtwo", "lock5", "loader0", "showtwo", "play0", "loader2", "Load0", "locktwo", "show4", " load4", "Load8"], "load3": ["lock1", " load03", "loader23", "loadThree", "Load1", "lock3", "load15", "loader1", "lock03", "load03", "Load83", "loader3", "loading1", " load15", " loadThree", "loading2", "loading3", "loadingThree", "lock23", "Load3", "loading15", "loading83", "Load2", "loader15", "load23", "loader03", "load83", "loader2", " load83", "loaderThree", " load23"], "src_wgt": ["src_Want", "src_wgen", "src_wsrt", "src_wsft", "src_wsg", "src_want", "src_Wgd", "src_ewnt", "src_wslt", "src_Wg", "src_sant", "src_sgt", "src_wsgt", "src_walgen", "src_wsnt", "src_walrt", "src_swlt", "src_swft", "src_ewgt", "src_wlt", "src_swgt", "src_srt", "src_wgd", "src_swnt", "src_walgt", "src_wnt", "src_wsant", "src_wsgen", "src_ewft", "src_sgen", "src_walant", "src_wft", "src_ewlt", "src_wrt", "src_Wgt", "src_wsgd", "src_wg"], "dst_wgt": ["dst_wwgt", "dst_iwg", "dst_Wht", "dst_wart", "dst_wsgd", "dst_wgd", "dst_wsht", "dst_wwnt", "dst_ewht", "dst_Wrt", "dst_wwGT", "dst_rgt", "dst_want", "dst_ewnt", "dst_wnt", "dst_iwrt", "dst_wg", "dst_wrt", "dst_wagd", "dst_Wg", "dst_rrt", "dst_rht", "dst_iwht", "dst_Wgd", "dst_ewGT", "dst_Wgt", "dst_wht", "dst_wwht", "dst_wGT", "dst_wsgt", "dst_wsGT", "dst_iwgt", "dst_Wnt", "dst_ewgt", "dst_wsnt", "dst_wagt", "dst_rg", "dst_wsrt"], "wgt": [" wg", "rwgs", " wgs", "fwg", "wg", "swgz", "rwrt", "Wgt", "Wlt", "wgz", "rwgt", "fwgs", "Wgz", " wgz", "wgs", "wGT", "swGT", "swgt", " wrt", "WGT", " wGT", "rwg", "wrt", "wlt", " wlt", "swlt", "fwrt", "fwgt"], "src0": ["loc2", "rc2", "src50", "rc00", "loc1", " src00", "st0", "st1", "loc0", "rc8", "src00", "load00", " src50", "st2", "rc1", "st8", "load50", "rc50", "rc0", "src8", "loc8"], "src1": ["sc01", "loc2", " src01", "rc2", "loc1", "rc3", "loc0", "src01", "rc01", "sc1", "rc1", "loc3", "rc0"], "src2": ["loc2", "send2", "rc2", "loc4", "src4", "source1", "sourcetwo", "loc1", "send4", "loc0", "srctwo", "source2", "source0", "sendtwo", "source4", "rc1", "send0", "rc4", "rctwo", "rc0"], "src3": ["loc2", "load03", " src03", "rc2", "loc4", "src4", "source1", "src03", "loc1", "rc3", "source2", "source3", "source4", "rc03", "rc1", "loc3", "rc4", "rc0"], "dst0": ["dST2", "sost2", "sst1", "dST8", "dst8", "dost0", "dST0", "dost2", "sost0", "sost1", "sst2", "dost1", "dest2", "sst0", "sost8", "dest8", "dST1", "dest0", "dost8", "dest1", "sst8"], "dst1": ["dess0", "Dst8", "Dest0", "dess2", "Dst2", "dst8", "dess1", "dgest1", "Dest1", "dgest0", "Dst0", "dgest2", "dest2", "dest8", "Dst1", "dest0", "Dest2", "Dest8", "dess8", "dest1", "dgest8"], "dst2": ["dsc0", "dst4", "dest4", " dstage2", " dstage0", "dstage1", "dstage0", "dstage2", "dest2", "dsc1", "dstage4", "dsc2", "dsc4", " dst4", "dest0", "dest1", " dstage1", " dstage4"], "dst3": [" dsc3", "dsp1", "dst5", " dsc5", "dsc3", "dest3", "dest5", "dsp3", " dsc2", "dsp5", " dsc1", " dst5", "dsp2", "dest2", "dsc1", "dsc2", "dest1", "dsc5"], "temp0": ["Temp0", "weight0", "Temp1", "Temp2", "temp00", "Temp00", "tem00", "weight00", "tem1", "tem0", "weight2", "tem2", "weight1"], "temp1": ["Temp1", "Temp2", "level3", "Temp3", "level1", "level2"], "temp2": [" temp4", "Temp02", "emp02", "Temp1", "Temp2", "emp1", "emp2", " temp02", "emp4", "Temp4", "temp02", "temp4"], "temp3": ["temp5", "Temp5", "Temp1", "Temp2", "tem3", "Temp3", "tem5", "tem1", " temp5", "tem2"], "denom": [" denog", "denym", "lenomin", "lenog", " denym", "decom", "denomin", "lenym", "decow", "denow", "DENym", "Denom", "decog", "DENog", "lenow", "Denog", "denog", "lenom", "Denym", "DENomin", "Denomin", "decym", " denow", "DENom"], "offset": ["set", "part", "af", "Offset", "eq", "base", "ref", "op", "align", "num", "kl", "loc", "padding", "index", "pos", "slice", "timeout", "o", "range", "val", "balance", "slot", "axis", "alias", "seed", "style", "initial", "reset", "ol", "adjust", "rot", "no", "start", "delay", "unit", "position", "off", "frequency", "error", "split", "et", "origin", "weight", "bal", "alpha", "pt", "len"], "add_val": [" add_vals", "add1val", "add_vals", " add1val", "add__vals", "add1eval", "add_Val", "add_eval", "add__Val", " add1eval", "addAllkey", " add_key", " add_pol", " add_Val", " add_value", "add__val", "add_pol", "addAlleval", "add_value", " add1key", "add1key", " add1vals", "addAllval", "add__pol", "add1vals", " add_eval", "addAllvals", "add_key"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static inline void tcg_out_ld(TCGContext *s, TCGType type, TCGReg ret,\n\n                              TCGReg arg1, intptr_t arg2)\n\n{\n\n    int opi, opx;\n\n\n\n    assert(TCG_TARGET_REG_BITS == 64 || type == TCG_TYPE_I32);\n\n    if (type == TCG_TYPE_I32) {\n\n        opi = LWZ, opx = LWZX;\n\n    } else {\n\n        opi = LD, opx = LDX;\n\n    }\n\n    tcg_out_mem_long(s, opi, opx, ret, arg1, arg2);\n\n}\n", "idx": 16501, "substitutes": {"s": ["ns", "m", "session", "f", "sv", "services", "service", "ions", "r", "n", "sb", "g", "ops", "scope", "fs", "is", "o", "cs", "w", "bis", "e", "ssl", "ses", "sync", "js", "c", "sym", "p", "support", "S", "secondary", "b", "sys", "u", "h", "a", "os", "sets", "sq", "ds", "sf"], "type": ["set", "types", "stat", "code", "t", "info", "x", "name", "op", "lit", "r", "pe", "rel", "i", "block", "match", "model", "date", "link", "class", "re", "format", "Type", "size", "pre", "like", "style", "rule", "use", "key", "id", "open", "parent", "by", "TYPE", "p", "test", "sym", "address", "pr", "resource", "col", "error", "ty", "py", "sy", "prot", "value", "ype", "y", "target", "typ"], "ret": ["pattern", "func", "expr", "obj", "ref", "alt", "buffer", "lit", "proxy", "reg", "fun", "rt", "result", "flag", "match", "ext", "mem", "def", "rets", "arg", "att", "store", "val", "re", "Ret", "back", "det", "rev", "v", "RET", "red", "res", "proc", "len", "prot", "fi", "reply"], "arg1": ["arg3", "argumentone", "argone", "param3", "argument3", "argument1", "Arg01", " arg3", "paramone", "arg01", "Arg1", "par2", "argument2", " argone", "Arg3", "par01", "param1", "par3", "Arg2", "par1", " arg01", "param2"], "arg2": ["Arg4", "param6", "param4", "argument1", "Arg6", "arg5", "Arg1", "argument5", "argument2", "argument4", "param1", "arg4", "arg6", "Arg2", " arg6", "Arg5", " arg5", " arg4", "param2"], "opi": ["optz", "hopi", "ipz", "opz", "operp", "opbi", "OPxi", "hopx", "opti", " opb", "hopxi", "optbi", "optx", "operi", "opp", " opc", " opxi", "operx", "ipp", " opbi", " opz", "OPx", "opb", "OPb", "ipi", "OPc", "hopb", "OPp", "OPi", " opp", "opc", "operz", "ipc", "operbi", "opxi", "ipx"], "opx": [" opy", " opxe", "Opy", "opz", "opy", "OPxi", "hopx", "opg", "ropg", "copx", "ropxe", "Opx", "operxc", " opxi", "hopxe", "operx", "Opz", "OPz", "copz", " opxc", "OPx", " opz", "hopz", "opxe", "copxi", "copxe", "Opxi", "operxe", "copi", "copxc", " opg", "OPi", "ropx", "ropxc", "copg", "operz", "hopxc", "OPy", "opxc", "opxi"]}}
{"project": "qemu", "commit_id": "af957387547b05ed6dc4d84c10cca42700a7aeda", "target": 0, "func": "void do_delvm(Monitor *mon, const QDict *qdict)\n\n{\n\n    BlockDriverState *bs, *bs1;\n\n    Error *err = NULL;\n\n    const char *name = qdict_get_str(qdict, \"name\");\n\n\n\n    bs = find_vmstate_bs();\n\n    if (!bs) {\n\n        monitor_printf(mon, \"No block device supports snapshots\\n\");\n\n        return;\n\n    }\n\n\n\n    bs1 = NULL;\n\n    while ((bs1 = bdrv_next(bs1))) {\n\n        if (bdrv_can_snapshot(bs1)) {\n\n            bdrv_snapshot_delete_by_id_or_name(bs, name, &err);\n\n            if (err) {\n\n                monitor_printf(mon,\n\n                               \"Error while deleting snapshot on device '%s':\"\n\n                               \" %s\\n\",\n\n                               bdrv_get_device_name(bs),\n\n                               error_get_pretty(err));\n\n                error_free(err);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16507, "substitutes": {"mon": ["part", "m", "phys", "mag", "mod", "demon", "un", "base", "login", "ann", "mi", "bm", "mn", "pm", "module", "master", "mun", "mot", "am", "mo", "mc", "mat", "mini", "member", " monitor", "atom", "bro", "bo", "mr", "mos", "dm", "man", "chron", "meter", "dom", "mont", "danger", "mor", "Monitor", "domain", "monitor", "mer", "mm", "MON", "tom", "Mon", "mu"], "qdict": ["queststr", "qdatabase", " qdirectory", "reqds", "qdirectory", "reqdt", " qdatabase", "questdatabase", "sqstr", "qstr", "sqdirectory", "questdict", " qdt", "sqdatabase", "qdt", " qstr", "eqdt", "qds", "reqdict", " qds", "questdirectory", "sqdict", "eqds", "eqdict"], "bs": ["ns", "bugs", "ab", "bi", "s", "db", "rs", "obj", "base", "ob", "las", "ports", "bm", "ubs", "aos", "sb", "bc", "ls", "ss", "pb", "fs", "bb", "lb", "ba", "bid", "cs", "css", "gb", "Bs", "bos", "ins", "obs", "bu", "BS", "iss", "blocks", "bis", "abi", "bl", "vs", "bh", "bas", "fb", "ses", "ps", "js", "bits", "b", "gs", "bytes", "os", "bes", "us", "bal", "conn", "ds", "bing"], "bs1": ["lsone", "ras0", "nsone", "bes0", "psone", "bsone", "besone", "bas3", "rasone", "bes91", "bs0", "BSOne", "b1", "b0", "ps0", "obsOne", "bas1", "ns1", "bone", "ras1", "bes1", "obsone", "bc2", "BS0", "bes3", "bc0", "bs91", "bs2", "obs1", "osone", "osOne", "psOne", "ns91", "bas2", "ls1", "os1", "bs3", "bcone", "bsOne", "ras91", "obs0", "bc1", "bc3", "BS1", "lsOne", "ns0", "ps1", "bas0", "BSone", "bes2"], "err": ["rr", "ner", "fr", "br", "rage", "runner", "cor", "ref", "r", "ar", "str", "result", "arm", "finder", "ext", "ind", "ore", "progress", "resp", "der", "ee", "ger", "arr", "orr", "erer", "fer", "later", "gr", "aster", "order", "mr", "rar", "rn", "id", "ler", "e", "dr", "lr", "cr", "acer", "req", "ir", "fee", "good", "fy", "error", "sys", "Er", "ace", "er", "errors", "res", "iter", "Error", "inner", "attr", "ver", "bug"], "name": ["part", "code", "data", "x", "base", "comment", "ame", "n", "num", "str", "block", "type", "pass", "Name", "min", "description", "label", "nm", "NAME", "alias", "new", "path", "size", "no", "prefix", "id", "key", "parent", "url", "b", "error", "names", "len", "desc", "version"]}}
{"project": "qemu", "commit_id": "64607d088132abdb25bf30d93e97d0c8df7b364c", "target": 0, "func": "void object_property_add(Object *obj, const char *name, const char *type,\n\n                         ObjectPropertyAccessor *get,\n\n                         ObjectPropertyAccessor *set,\n\n                         ObjectPropertyRelease *release,\n\n                         void *opaque, Error **errp)\n\n{\n\n    ObjectProperty *prop;\n\n\n\n    QTAILQ_FOREACH(prop, &obj->properties, node) {\n\n        if (strcmp(prop->name, name) == 0) {\n\n            error_setg(errp, \"attempt to add duplicate property '%s'\"\n\n                       \" to object (type '%s')\", name,\n\n                       object_get_typename(obj));\n\n            return;\n\n        }\n\n    }\n\n\n\n    prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->name = g_strdup(name);\n\n    prop->type = g_strdup(type);\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n    prop->release = release;\n\n    prop->opaque = opaque;\n\n\n\n    QTAILQ_INSERT_TAIL(&obj->properties, prop, node);\n\n}\n", "idx": 16521, "substitutes": {"obj": ["org", "instance", "tree", "j", "mod", "data", "ob", "jp", "ref", "op", "conn", "nt", "adj", "n", "objects", "module", "oa", "node", "ext", "ctx", "pos", "nb", "object", "o", "po", "bo", "class", "bot", "cl", "parent", "js", "lib", "off", "od", "orb", "opt", "inst", "api", "os", "attr", "pt", "Obj"], "name": ["part", "time", "data", "ame", "base", "call", "full", "dot", "property", "n", "family", "option", "on", "block", "package", "node", "ext", "Name", "normal", "min", "object", "description", "create", "label", "o", "NAME", "class", "unknown", "alias", "old", "new", "size", "title", "path", "style", "no", "prefix", "key", "named", "id", "parent", "none", "missing", "null", "field", "names", "word", "value", "version"], "type": ["types", "status", "part", "scale", "time", "t", "where", "info", "call", "comment", "op", "sort", "property", "pe", "family", "ity", "rel", "option", "source", "kind", "index", "copy", "o", "other", "val", "class", "Type", "size", "pre", "style", "rule", "use", "length", "key", "id", "unit", "TYPE", "none", "field", "value", "ype", "y", "version", "target"], "get": ["enable", "init", "view", "call", "all", "sort", "give", "apply", "show", "make", "package", "GET", "Get", "create", "is", "parse", "read", "like", "comp", "use", "gets", "pull", "send", "fix", "update", "invoke", "post", "patch", "access", "del", "cache", "check", "field", "write", "find", "export", "value"], "set": ["enable", "init", "Set", "un", "view", "push", "call", "op", "sort", "apply", "index", "en", "create", "low", "is", "store", "change", "read", "new", "size", "site", "add", "reset", "use", "key", "start", "id", "send", "open", "update", "check", "put", "et", "export", "sign", "write", "cast", "save", "end", "value"], "release": ["require", "move", "raise", "scale", "lease", "enable", "offset", "launch", "leases", "view", "ref", "hide", "released", "delete", "sort", "rel", "package", "loc", "accept", "scope", "Release", "exclusive", "create", "range", "close", "complete", "ignore", "use", "id", "open", "update", "access", "none", "lock", "resource", "rate", "fire", "write", "save", "version"], "opaque": ["copaques", "copasso", "copacity", "operacity", "operaco", "opity", "cataque", "copaque", "spaques", "opac", "opacity", "pacity", "pity", "operaque", "operity", "catque", "paco", "spac", "spaque", "copity", "operque", "opaco", "paque", "copque", "operac", "opaques", "spacity", "operasso", "operaques", "opasso", "copaco", "copac", "cataco", "opque", "catasso"], "errp": [" errP", " errfp", "erfp", "errP", "errpc", "Erpc", "erc", " errc", "rrfp", "erf", "rrc", "erpc", "erp", "rrf", "errfp", "Erc", "rrp", "erP", " errf", " errpc", "errf", "Erp", "errc", "ErP"], "prop": ["plugin", "term", "part", "pot", "cfg", "init", "j", "mod", "data", "info", "pred", "ref", "op", "jp", "f", "dest", "conf", "property", "lit", "pod", "phi", "option", "root", "or", "cp", "node", "var", "pb", "pos", "def", "pointer", "object", "Prop", "val", "class", "pkg", "rop", "comp", "config", "foo", "key", "cop", "buf", "parent", "cat", "ps", "tmp", "meta", "p", "doc", "mp", "b", "pr", "cmp", "gen", "proc", "properties", "opt", "priv", "pro", "project", "peer", "it", "fi", "np", "value", "attr", "target", "typ"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void collie_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    StrongARMState *s;\n\n    DriveInfo *dinfo;\n\n    MemoryRegion *sysmem = get_system_memory();\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"sa1110\";\n\n    }\n\n\n\n    s = sa1110_init(sysmem, collie_binfo.ram_size, cpu_model);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    pflash_cfi01_register(SA_CS0, NULL, \"collie.fl1\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 1);\n\n    pflash_cfi01_register(SA_CS1, NULL, \"collie.fl2\", 0x02000000,\n\n                    dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                    (64 * 1024), 512, 4, 0x00, 0x00, 0x00, 0x00, 0);\n\n\n\n    sysbus_create_simple(\"scoop\", 0x40800000, NULL);\n\n\n\n    collie_binfo.kernel_filename = kernel_filename;\n\n    collie_binfo.kernel_cmdline = kernel_cmdline;\n\n    collie_binfo.initrd_filename = initrd_filename;\n\n    collie_binfo.board_id = 0x208;\n\n    arm_load_kernel(s->cpu, &collie_binfo);\n\n}\n", "idx": 16524, "substitutes": {"machine": ["process", "part", "m", "instance", "session", "data", "mode", "user", "base", "image", "comment", "service", "M", "loader", "cpu", "module", "app", "node", "mc", "sim", "mini", "model", "manager", "mom", "self", "computer", "game", "object", "controller", "sm", "vm", "home", "host", "page", "l", "database", "parse", "space", "mobile", "mount", "device", "slave", "hard", "boot", "Machine", "template", "connection", "state", "project", "mac", "server", "message", "motion", "bug"], "cpu_model": ["cpu_system", "pu_model", "cpu1model", "cpuadmodel", "mem_language", "pu_size", "cpu_Model", "cpuadmode", " cpu_size", "cpu_view", " cpu_address", "gpu_mode", "cpusfile", "cpu1length", " cpu_length", "cpulexaddress", "cpu_file", "pu_mode", "cpu_mode", "cpu_size", "cpussize", "cpu_length", "gpu_system", "cpuadlength", " cpu_file", "cpu_language", "cpu_address", "cpu1system", "cpusmodel", " cpu_mode", "mem_mode", "cpuadsystem", " cpu_Model", "cpulexModel", "gpu_length", "cpu1mode", "mem_model", "cpulexmodel", "pu_view", "gpu_model", "cpulexmode", "cpuslength"], "kernel_filename": ["cachefulllength", "kernellockmaximum", "kernel_username", " kernel_size", "kernelldescription", "kernel_description", "contextmdatabase", "kernelmdescription", "contextmfilename", "interfaceldescription", " kernel_source", "interface_description", "interface_filename", "kernel_directory", "context_directory", "kernel\u00b7label", "kernel_label", "kernel_database", "kernel___filename", "kernelmdatabase", "kernelfulllabel", "interfacelsource", "kernel___size", "kernel___source", "contextmdirectory", "kernelndescription", "kernel_source", "kernellsource", "context_filename", "kernelmfilename", "kernelMfilename", "kernelMdescription", "kernel_size", "kernelfullmaximum", "interfacelname", "cache_label", "cachefullfilename", "contextmdescription", "interfacelfilename", "kernel\u00b7length", "interface_source", "kernelfullfilename", " kernel_username", "kernel\u00b7maximum", "cache_length", "kernel_name", "kernel\u00b7filename", "kernelMdatabase", "cachefulllabel", "kernellocklabel", "kernel___username", "cachefullmaximum", "kernellname", "kernelMdirectory", "kernelfulllength", "kernelmdirectory", "kernelnfilename", "kernel_length", "context_description", "interface_name", "kernellfilename", "kernel_maximum", "kernellockfilename", "cache_filename", "kernellocklength", "kernelnname", "context_database", "cache_maximum", "kernelnsource"], "kernel_cmdline": ["kernel_deflin", "kernel_programlock", "kernel_cmdlin", "kernel_ctxfile", "kernel_commandl", "kernel_ckfile", "kernel_classline", "kernel_rawword", "kernel_defline", "kernel_ckline", "kernel\u00b7cmdstyle", "kernel_ctxue", "kernel_classrange", "kernel_costword", "kernel_gradlock", "kernel_commandside", "kernel_rawline", "kernel_pathne", "kernel_cmdside", "kernel_ctxline", "kernel_costline", "kernel_pathline", "kernel_classlock", "kernel_programside", "kernel_gradl", "kernel_methodrange", "kernel_cmdword", "kernel\u00b7cmdline", "kernel_ckue", "kernel\u00b7cmdword", "kernel_cmdlock", "kernel_cmdue", "kernel_costne", "kernel_cmdstyle", "kernel_gradline", "kernel\u00b7costline", "kernel\u00b7costne", "kernel\u00b7coststyle", "kernel_ctxlin", "kernel_pathstyle", "kernel_cmdrange", "kernel_coststyle", "kernel_programline", "kernel_cmdfile", "kernel_programl", "kernel_commandrange", "kernel_methodline", "kernel_commandlock", "kernel_deffile", "kernel_defue", "kernel_cmdne", "kernel\u00b7cmdne", "kernel_cmdl", "kernel_cklin", "kernel_pathword", "kernel_rawne", "kernel\u00b7costword", "kernel_methodlock", "kernel_commandline", "kernel_gradside", "kernel_rawstyle"], "initrd_filename": ["initrd_width", "initrdxtail", "initrad_Filename", "initrd_username", "initrdJforward", "initdd_username", "initrd_location", "initrdUfilename", "initrdUusername", "initrdPfilename", "initrd_tail", "initrad_location", "initrdUfil", "initrd_fil", "initrt_filename", "initrdJlocation", "initdd_fil", "initrad_filename", "initrd_forward", "initradPforward", "initrdPFilename", "initrd_Filename", "initrdlockfilename", "initrdlockpassword", "initdd_tail", "initrs_password", "initrdPforward", "initrs_filename", "initrdlockFilename", "initrd2filename", "initrd2required", "initrdxusername", "initrt_name", "initrd_name", "initdd_filename", "initrt_width", "initrdxfilename", "initrd_password", "initradPfilename", "initrd2width", "initrs_Filename", "initrdJFilename", "initrdPlocation", "initradPlocation", "initrd_required", "initrdJfilename", "initrdUtail", "initradPFilename", "initrd2name", "initrt_required", "initrdxfil", "initrad_forward"], "s": ["ns", "spec", "m", "session", "sg", "t", "rs", "info", "f", "sp", "services", "service", "n", "sb", "sl", "ss", "y", "fs", "is", "o", "sk", "cs", "su", "e", "ssl", "ses", "sync", "c", "ps", "si", "sym", "p", "S", "b", "ks", "gs", "sys", "states", "os", "state", "server", "se", "sq", "less", "sa", "ds", "sf"], "dinfo": ["derror", "dconf", "dsi", " dconf", "fapi", "dnconf", "ffo", "mdfo", "pfo", "binfo", "dinit", "ddi", "sdignore", "binner", "dhand", "dfo", "nddi", "ndignore", "phand", "dinf", "drapi", "bdi", " dinit", "dinner", "dignore", "dninit", " derror", "dayinf", "binf", "dbignore", "dapi", " dinf", "finf", "dlconf", "drfo", "papi", "dlinfo", "ndinner", "dnsi", "sderror", "pignore", "pinfo", "mdinfo", "dlsi", "dayfo", "dayinfo", "dbinfo", "dbinf", "finfo", "sdinner", "dwork", "mdapi", "pinf", "drinfo", " dapi", "sdinfo", "pwork", " dwork", "dbhand", "sddi", "ndinfo", " dfo", "mdinf", "sdwork", "dayapi", "dninfo", "drinf", " dsi", "dlinit", "bhand", "bignore", "sdinf"], "sysmem": ["sysreg", "sysram", "ssmemory", "sysmemory", "syslim", " syslim", "ssmem", "cslim", "sreg", "csmem", "csdem", "sysdem", "ssreg", "smemory", "systemmemory", "systemram", " sysdem", "systemmem", "systemreg", "sslim", "slim", "systemlim", "systemdem", " sysram", "csram", "smem"]}}
{"project": "FFmpeg", "commit_id": "e45a2872fafe631c14aee9f79d0963d68c4fc1fd", "target": 0, "func": "void avg_pixels16_altivec(uint8_t *block, const uint8_t *pixels, int line_size, int h)\n\n{\n\nPOWERPC_TBL_DECLARE(altivec_avg_pixels16_num, 1);\n\n#ifdef ALTIVEC_USE_REFERENCE_C_CODE\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      op_avg(*((uint32_t*)(block)),(((const struct unaligned_32 *)(pixels))->l));\n\n      op_avg(*((uint32_t*)(block+4)),(((const struct unaligned_32 *)(pixels+4))->l));\n\n      op_avg(*((uint32_t*)(block+8)),(((const struct unaligned_32 *)(pixels+8))->l));\n\n      op_avg(*((uint32_t*)(block+12)),(((const struct unaligned_32 *)(pixels+12))->l));\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#else /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n    register vector unsigned char pixelsv1, pixelsv2, pixelsv, blockv;\n\n    register vector unsigned char perm = vec_lvsl(0, pixels);\n\n    int i;\n\n\n\nPOWERPC_TBL_START_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n    for(i=0; i<h; i++) {\n\n      pixelsv1 = vec_ld(0, (unsigned char*)pixels);\n\n      pixelsv2 = vec_ld(16, (unsigned char*)pixels);\n\n      blockv = vec_ld(0, block);\n\n      pixelsv = vec_perm(pixelsv1, pixelsv2, perm);\n\n      blockv = vec_avg(blockv,pixelsv);\n\n      vec_st(blockv, 0, (unsigned char*)block);\n\n      pixels+=line_size;\n\n      block +=line_size;\n\n    }\n\n\n\nPOWERPC_TBL_STOP_COUNT(altivec_avg_pixels16_num, 1);\n\n\n\n#endif /* ALTIVEC_USE_REFERENCE_C_CODE */\n\n}\n", "idx": 16536, "substitutes": {"block": ["inner", "point", "group", "work", "time", "x", "name", "image", "bit", "buffer", "random", "num", "pixel", "channel", "pack", "square", "type", "year", "month", "loc", "padding", "slice", "index", "pos", "mask", "byte", "wall", "label", "ip", "range", "ack", "keep", "layer", "header", "section", "chain", "no", "Block", "height", "blocks", "length", "network", "limit", "bl", "prefix", "batch", "sync", "cl", "unit", "device", "position", "patch", "line", "off", "address", "none", "lock", "filter", "check", "clock", "row", "number", "frame", "panel", "blocking"], "pixels": ["bixels", "apips", "bonents", "ports", "compixels", "borts", "npixel", "Pixels", " powers", "Pels", "spixels", "pamples", "compows", "apix", "ppixels", "hixels", " pips", "ipores", "Pips", "ppixel", " pels", "ipamples", " pamples", "npix", " pixel", "camples", "Pamples", "npips", "pipes", "compels", "Pipers", "ponents", "ipixels", "npixels", "bores", "cixels", "piles", "apixel", "peters", " pows", "ppiles", "compamples", "pows", "cixel", "pips", "aports", "iponents", "bamples", " pipes", "ciles", "pipers", "apamples", "ppipers", "spowers", "apowers", " peters", " pores", "cips", "ppips", " pipers", "pix", "powers", "hows", "Ponents", " piles", "ppels", "spamples", "pels", "sponents", " ponents", "pores", " ports", "pixel", "hels", "bowers", "apeters", "aponents", "cipes", "speters", "apixels", "spipers", "hamples", "Pipes", "cix"], "line_size": ["fieldLogscale", "line64number", "double_white", "lineLogscale", "line_white", "lineLogshape", "doubleLognumber", "lineLognumber", "page2SIZE", "lineAsize", "field_size", "double_height", "page_small", "line_height", "page2shape", "line2SIZE", "line6size", "lineAwhite", "doubleLogsize", "fieldLogsize", "fieldLogclean", "page_size", "lineLogclean", "field_scale", "lineAheight", "lineAnumber", "line64size", "lineLogsize", "page_SIZE", "line64white", "page2size", "page_shape", "double_size", "double_number", "line2size", "line_small", "line6shape", "doubleLogheight", "field_clean", "line_SIZE", "doubleLogwhite", "lineLogheight", "field_shape", "line2shape", "line6SIZE", "line6small", "line_shape", "page2small", "line_number", "lineLogwhite", "line2small", "fieldLogshape", "line_scale", "line64height", "line_clean"], "h": ["m", "j", "ch", "t", "x", "f", "r", "n", "num", "z", "rh", "en", "o", "l", "d", "header", "HH", "ht", "sh", "height", "w", "length", "k", "e", "q", "bh", "v", "c", "hp", "p", "hm", "b", "hh", "end", "hs", "H", "y", "u"], "i": ["gi", "ti", "uri", "m", "bi", "init", "j", "s", "code", "ami", "ji", "info", "x", "f", "image", "ix", "ini", "qi", "r", "io", "ai", "n", "mi", "phi", "hi", "z", "ii", "in", "ie", "iu", "di", "index", "mini", "I", "dim", "multi", "o", "ip", "chi", "l", "d", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "p", "xi", "b", "lock", "mu", "a", "im", "it", "eni", "my", "fi", "inner", "y", "li", "u"], "pixelsv1": ["pixelsversionron", "pipersV1", "pixelsVron", "pixelssv2", "pixelsv3", "pipersvron", "pipersv2", "pixelsversion1", "pixelsV3", "pixelsversion3", "pipersv3", "pixelsvron", "pixelsV1", "pipersV3", "pixelssv3", "pixelssv1", "pipersV2", "pixelsversion2", "pixelsV2", "pipersVron", "pipersv1"], "pixelsv2": ["pipersV1", "pixelsV8", "pixelsu1", "pixelsu4", "pipersV0", "pixelsV4", "pixelsV0", "pipsV0", "pixelsiv1", "pixelsiv2", "pixelsev1", "pixelsu2", "pipsV4", "pixelsev2", "pipsV1", "pixelsiv4", "pipersv2", "pixelsv8", "pixelsV1", "pipersv4", "pixelsv4", "pipsv4", "pipsv2", "pipsv1", "pipsv0", "pipersv0", "pixelsv0", "pipsv8", "pipersV2", "pipsV2", "pipersV4", "pixelsev4", "pixelsev0", "pixelsu8", "pixelsV2", "pixelsiv0", "pipersv1"], "pixelsv": ["ppagesve", "Pixelsv", " pipsve", "pipsb", " pipsV", "pixelh", "pixelV", "pixelb", "piconsV", "pixelv", "Pipsv", "pipsv", "pixelsve", "pixelsb", "pixelsvi", "ppagesvi", "piconsve", "pixelsh", "pixelsV", "Pipsb", "ppagesv", "ppagesV", "Pixelsh", "pipersv", "pipsvi", "pipersb", "piconsv", "PixelsV", "pipersh", " pipsvi", "piconsvi", "pipsh", " pixelsvi", " pixelsve", " pipsv", "pipsve", "Pixelsb", " pixelsV", "Pipsh", "pipersV", "pipsV", "PipsV"], "blockv": ["maskf", " blockV", "diskv", "Blockv", "wallm", "blockh", " blockf", "blockm", "boxu", "lock\n", "diskc", "maskV", "blockc", " blockm", "lockV", "wallu", "Blockc", "wallv", "maskv", "diskh", "diskV", "lockf", "chain\n", "lockv", "maskc", "BlockV", "blockf", "boxc", " blockc", "blockV", "lockc", "boxm", "blocku", "boxv", " blockh", "Blockh", " blocku", "wallc"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void blk_send_response_all(struct XenBlkDev *blkdev)\n\n{\n\n    struct ioreq *ioreq;\n\n    int send_notify = 0;\n\n\n\n    while (!LIST_EMPTY(&blkdev->finished)) {\n\n        ioreq = LIST_FIRST(&blkdev->finished);\n\n\tsend_notify += blk_send_response_one(ioreq);\n\n\tioreq_release(ioreq);\n\n    }\n\n    if (send_notify)\n\n\txen_be_send_notify(&blkdev->xendev);\n\n}\n", "idx": 16542, "substitutes": {"blkdev": ["Blkprom", "BlkDev", "plkprom", "plktprom", "plktdevice", "Blckdevice", "Blkdiv", "blukprom", "BlbDev", "Blckdev", "plktev", "blbconn", "Blkdevice", "blckdiv", "blkconn", "belkdev", "blckprom", "plkev", "blokev", "blktdevice", "blckdevice", "blkdiv", "Blbconn", "Blkconn", "blokprom", "blokDev", "belkdiv", "blakdevice", "blokdiv", "belkdevice", "plkdev", "blkdevice", "blakconn", "blckdev", "blktprom", "blakdev", "plktdev", "blukdiv", "blokdevice", "blbdev", "belokdevice", "blkprom", "blkDev", "blokconn", "blbdevice", "blktdev", "blktdiv", "blbDev", "Blbdevice", "blokdev", "blukdev", "Blckdiv", "Blbdev", "blktev", "Blkdev", "blkev", "plkdevice", "Blckprom", "blukdevice", "blukev", "blakDev", "belokdev", "belokdiv"], "ioreq": ["iourc", "ioresqual", "ioresv", "ioseqs", "iniorequest", " iorequ", "iouc", "ioorquest", "inioreq", "iouq", "ioyarch", "atioryqs", "ioryqs", "iourv", "iourq", "iorestqs", "ioserq", "inioredq", "iorev", "ioryqual", "ioresq", "iorearch", " ioresq", "ioroqu", "inioreck", " iosequ", "atiorequal", "ioreqs", " ioseq", "iosel", "ioryq", "atioryqual", "inioredck", "ioredquest", "atioryq", "iniorel", " ioresquest", "ioresqs", " ioseqs", "pioserid", "atioryc", "iorestquest", " iorequest", "iosec", "iorequal", "iouqs", "ioorck", "iorequest", "iosequ", "ioredck", "ioserid", " iorec", "iorestq", "ioresc", "ioroquest", "ioryc", "ioreck", "iosev", " ioreqs", " iosequest", "ioredl", "ioseck", "iosequest", "atioreqs", "pioserarch", "iorel", "iouqual", "pioserck", "iorestqu", "ioyid", "ioreid", "inioredl", "ioriq", "inioredquest", "atiorec", "piorearch", "ioorq", "iorequ", "iorick", "iourquest", "atioreq", " ioresv", "ioorl", "pioreq", "ioresquest", "pioreck", "ioseq", "ioroq", " ioresc", "ioriid", "ioserck", "pioserq", "ioyck", "ioyq", "ioroqs", "ioserarch", "ioriarch", "ioredq", "iorec", "pioreid", " iorev"]}}
{"project": "qemu", "commit_id": "6c7565028c272c4c6f2a83c3a90b044eeaf2804a", "target": 0, "func": "static int interface_client_monitors_config(QXLInstance *sin,\n\n                                        VDAgentMonitorsConfig *monitors_config)\n\n{\n\n    PCIQXLDevice *qxl = container_of(sin, PCIQXLDevice, ssd.qxl);\n\n    QXLRom *rom = memory_region_get_ram_ptr(&qxl->rom_bar);\n\n    int i;\n\n    unsigned max_outputs = ARRAY_SIZE(rom->client_monitors_config.heads);\n\n\n\n    if (qxl->revision < 4) {\n\n        trace_qxl_client_monitors_config_unsupported_by_device(qxl->id,\n\n                                                               qxl->revision);\n\n        return 0;\n\n    }\n\n    /*\n\n     * Older windows drivers set int_mask to 0 when their ISR is called,\n\n     * then later set it to ~0. So it doesn't relate to the actual interrupts\n\n     * handled. However, they are old, so clearly they don't support this\n\n     * interrupt\n\n     */\n\n    if (qxl->ram->int_mask == 0 || qxl->ram->int_mask == ~0 ||\n\n        !(qxl->ram->int_mask & QXL_INTERRUPT_CLIENT_MONITORS_CONFIG)) {\n\n        trace_qxl_client_monitors_config_unsupported_by_guest(qxl->id,\n\n                                                            qxl->ram->int_mask,\n\n                                                            monitors_config);\n\n        return 0;\n\n    }\n\n    if (!monitors_config) {\n\n        return 1;\n\n    }\n\n\n\n#if SPICE_SERVER_VERSION >= 0x000c06 /* release 0.12.6 */\n\n    /* limit number of outputs based on setting limit */\n\n    if (qxl->max_outputs && qxl->max_outputs <= max_outputs) {\n\n        max_outputs = qxl->max_outputs;\n\n    }\n\n#endif\n\n\n\n    memset(&rom->client_monitors_config, 0,\n\n           sizeof(rom->client_monitors_config));\n\n    rom->client_monitors_config.count = monitors_config->num_of_monitors;\n\n    /* monitors_config->flags ignored */\n\n    if (rom->client_monitors_config.count >= max_outputs) {\n\n        trace_qxl_client_monitors_config_capped(qxl->id,\n\n                                monitors_config->num_of_monitors,\n\n                                max_outputs);\n\n        rom->client_monitors_config.count = max_outputs;\n\n    }\n\n    for (i = 0 ; i < rom->client_monitors_config.count ; ++i) {\n\n        VDAgentMonConfig *monitor = &monitors_config->monitors[i];\n\n        QXLURect *rect = &rom->client_monitors_config.heads[i];\n\n        /* monitor->depth ignored */\n\n        rect->left = monitor->x;\n\n        rect->top = monitor->y;\n\n        rect->right = monitor->x + monitor->width;\n\n        rect->bottom = monitor->y + monitor->height;\n\n    }\n\n    rom->client_monitors_config_crc = qxl_crc32(\n\n            (const uint8_t *)&rom->client_monitors_config,\n\n            sizeof(rom->client_monitors_config));\n\n    trace_qxl_client_monitors_config_crc(qxl->id,\n\n            sizeof(rom->client_monitors_config),\n\n            rom->client_monitors_config_crc);\n\n\n\n    trace_qxl_interrupt_client_monitors_config(qxl->id,\n\n                        rom->client_monitors_config.count,\n\n                        rom->client_monitors_config.heads);\n\n    qxl_send_events(qxl, QXL_INTERRUPT_CLIENT_MONITORS_CONFIG);\n\n    return 1;\n\n}\n", "idx": 16566, "substitutes": {"monitors_config": ["monetersacoutput", "monitors_conn", "monitorsacconfig", "monitorsureconfig", "monitorsfstorage", "monitorsaccontrol", "monpots_com", "monitors_ref", "moneters_control", "monitorsacfig", "monitorsacconn", "monpotsureconfig", "monitorsacdata", "monors_config", "monetersaccontrol", "monitors_fig", "monitorssconfig", "monitorsscache", "moneters_output", "monitorssservice", "monitors_cache", "monpotsuresource", "monuments_man", "monters_config", "monitors_settings", "monpotsurecom", "monters_fig", "monagers_ref", "monitors_storage", "monors_cache", "monitors2config", "monitors_cfg", "monitors2data", "monitorssconn", "monitors_output", "monitorsurecfg", "monitors_man", "monitors_data", "monpots_cfg", "monpots_source", "monuments_cache", "monitors2conn", "monitors2control", "monors_service", "monitorsfsettings", "monitors_service", "monors_conn", "monitorsallconfig", "monpots_config", "monitors2fig", "monitorsallsettings", "monetersacconn", "monitorsuresource", "monetersacconfig", "monitorsallcom", "monuments_config", "monitorsallcfg", "monitors_control", "monitorsfref", "moneters_conn", "monagers_settings", "monitorsurecom", "monitors_com", "monitorsallstorage", "monagers_config", "monters_data", "monpotsurecfg", "monitorsfconfig", "monitorsallsource", "monitors2output", "monitorsacoutput", "moneters_config", "monitors_source", "monagers_storage", "monitorsallref"], "qxl": ["kxls", "quxll", "qoxell", "qyla", "qxxd", "qmxll", "qaxll", "quxdls", " qxll", "sqvl", "qxxl", "qmxd", "sqxr", "qdxll", " qaxll", "Qtxl", "qxdls", "qpxr", "qxcll", "quxtel", "qwxln", "quxel", "queryxla", "qaxL", "queryxli", "quxls", "queryxll", "qrexli", "queryaxel", "qzxli", "quxtl", "qfxls", "sqxl", "qrexell", "qxesls", "viewxr", "qoxel", "qxxlc", "qwwel", "qexL", "qxxdl", "Qxlc", "sqzl", "viewxl", "qxv", "querypxr", "qexlc", "qoxl", "qaxl", "qzll", "qxddl", "qxxsl", "Qxl", "qlexl", "sqvel", "quxdll", " qpxli", " qpxlc", "qXlc", "quxli", "qxla", "queryzll", "quxl", "qfxle", "qxtli", "qmxv", "qxell", "qxxv", " qxsl", "qvli", "qoxli", "qoxll", "quxtli", "sqxln", "qxln", "viewuxr", "qzxrl", "qxxll", "qxxel", "qxr", "qxesll", "qdxln", "qulexlp", "qpxli", "qyls", "qctll", "qxle", "sqzln", " qaxl", "qwxla", "quxr", "qexls", "qxel", "Qtxls", "viewxli", "qrexll", "sqzll", "qaxli", "qmxel", "qtxlc", "viewxls", "qxcli", "qyll", "qctl", "qvell", "quaxl", "viewuxl", "qwxr", "sqxell", "qulexdl", "quxdl", "qdxl", "sqvell", "qxxr", "qxxlp", "qxsl", "QtxL", "kexl", "qzxll", "qxxle", "qpxlc", " qxL", "qxtrl", "qxeslp", "quxv", " qxli", "sqvli", "qaxr", "kexls", "quaxel", "qctls", "sqxll", "qfxr", "qlexlp", "quaxd", "queryzli", "qxrl", "qXl", "kexlp", "qxL", "qrexel", "querypxli", "queryxel", "queryaxla", "Qxls", "qxd", "qxesle", "qxlp", "qyli", "qxlc", "qtxL", "queryzl", "QxL", "qpxl", "qyl", "qwwl", "qulexle", "qrexrl", "qzli", "queryxle", "qwxll", "qexlp", "quaxv", "qfxli", "qxcl", "quxlp", "qvel", "qxesl", "queryaxl", "viewuxli", "qaxd", "quxddl", "quxtll", "qrexl", " qxlc", "quxd", "viewuxls", "qlexle", "kxl", "qlexdl", "querypxle", "qtxls", "qxtl", "qxxli", "qzxl", "quxrl", "qxll", "Qtxlc", " qaxL", "qxesdl", "qylp", "qmxl", "qzr", "qtxl", "sqzr", "qoxsl", "qwxel", "qtxli", "qaxls", "qzln", "querypxl", "sqxli", "qctdl", "qxcla", "qXL", "qaxel", "qoxL", "quxle", "qvl", "qmxli", "qaxla", " qpxl", "qaxsl", "qxtel", "qfxl", "qwwla", "qwxl", "queryxl", "qexl", "qpxle", " qaxsl", " qxle", "qulexl", " qpxle", "qwxli", "kxlp", "qzla", "sqxel", "quxtrl", "qwwll", "qxtll", "qdxr", "queryzla", "qXls", "qxdl", "qtxle", "qxls", "qxli", "queryxr", "qxxL", "qzl", "qaxv", "qxdll", "queryaxll"], "rom": ["ROM", "rx", "ros", "rock", "gram", "mod", "rog", "mode", "lim", "rc", "iam", "reg", "rm", "cm", "chrome", "ro", "cpu", "coll", "arm", "rg", "sim", "mem", "prom", "RAM", "irm", "container", "rome", "roc", "rec", "ray", "crypt", "rob", "Rom", "prem", "drm", "rim", "camp", "rar", "roy", "com", "rn", "remote", "chrom", "ov", "cr", "client", "sam", "ram", "cmd", "rov", "mor", "resource", "norm", "param", "ra", "dem", "pro", "im", "co", "rum", "mm", "ran", "rem", "roman", "RM"], "i": ["ti", "gi", "uri", "m", "bi", "j", "ji", "t", "ami", "x", "f", "ix", "ini", "qi", "ai", "io", "mi", "phi", "ii", "di", "index", "ind", "slice", "I", "iu", "multi", "zi", "count", "mini", "o", "ip", "chi", "l", "oi", "yi", "pi", "ui", "ci", "abi", "k", "e", "cli", "v", "ni", "si", "ri", "xi", "p", "b", "a", "fi", "attr", "y", "li", "mu"], "monitor": ["program", "record", "metadata", "runner", "service", "report", "block", "type", "control", "manager", "watch", "member", "username", "network", "handler", "client", "meter", "unit", "device", "resource", "Monitor", "param", "number", "connection", "message", "port", "command", "attr"]}}
{"project": "qemu", "commit_id": "9a4c0e220d8a4f82b5665d0ee95ef94d8e1509d5", "target": 0, "func": "static void virtio_pci_realize(PCIDevice *pci_dev, Error **errp)\n\n{\n\n    VirtIOPCIProxy *proxy = VIRTIO_PCI(pci_dev);\n\n    VirtioPCIClass *k = VIRTIO_PCI_GET_CLASS(pci_dev);\n\n\n\n    /*\n\n     * virtio pci bar layout used by default.\n\n     * subclasses can re-arrange things if needed.\n\n     *\n\n     *   region 0   --  virtio legacy io bar\n\n     *   region 1   --  msi-x bar\n\n     *   region 4+5 --  virtio modern memory (64bit) bar\n\n     *\n\n     */\n\n    proxy->legacy_io_bar  = 0;\n\n    proxy->msix_bar       = 1;\n\n    proxy->modern_io_bar  = 2;\n\n    proxy->modern_mem_bar = 4;\n\n\n\n    proxy->common.offset = 0x0;\n\n    proxy->common.size = 0x1000;\n\n    proxy->common.type = VIRTIO_PCI_CAP_COMMON_CFG;\n\n\n\n    proxy->isr.offset = 0x1000;\n\n    proxy->isr.size = 0x1000;\n\n    proxy->isr.type = VIRTIO_PCI_CAP_ISR_CFG;\n\n\n\n    proxy->device.offset = 0x2000;\n\n    proxy->device.size = 0x1000;\n\n    proxy->device.type = VIRTIO_PCI_CAP_DEVICE_CFG;\n\n\n\n    proxy->notify.offset = 0x3000;\n\n    proxy->notify.size =\n\n        QEMU_VIRTIO_PCI_QUEUE_MEM_MULT * VIRTIO_QUEUE_MAX;\n\n    proxy->notify.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    proxy->notify_pio.offset = 0x0;\n\n    proxy->notify_pio.size = 0x4;\n\n    proxy->notify_pio.type = VIRTIO_PCI_CAP_NOTIFY_CFG;\n\n\n\n    /* subclasses can enforce modern, so do this unconditionally */\n\n    memory_region_init(&proxy->modern_bar, OBJECT(proxy), \"virtio-pci\",\n\n                       2 * QEMU_VIRTIO_PCI_QUEUE_MEM_MULT *\n\n                       VIRTIO_QUEUE_MAX);\n\n\n\n    memory_region_init_alias(&proxy->modern_cfg,\n\n                             OBJECT(proxy),\n\n                             \"virtio-pci-cfg\",\n\n                             &proxy->modern_bar,\n\n                             0,\n\n                             memory_region_size(&proxy->modern_bar));\n\n\n\n    address_space_init(&proxy->modern_as, &proxy->modern_cfg, \"virtio-pci-cfg-as\");\n\n\n\n    if (pci_is_express(pci_dev) && pci_bus_is_express(pci_dev->bus) &&\n\n        !pci_bus_is_root(pci_dev->bus)) {\n\n        int pos;\n\n\n\n        pos = pcie_endpoint_cap_init(pci_dev, 0);\n\n        assert(pos > 0);\n\n\n\n        pos = pci_add_capability(pci_dev, PCI_CAP_ID_PM, 0, PCI_PM_SIZEOF);\n\n        assert(pos > 0);\n\n\n\n        /*\n\n         * Indicates that this function complies with revision 1.2 of the\n\n         * PCI Power Management Interface Specification.\n\n         */\n\n        pci_set_word(pci_dev->config + pos + PCI_PM_PMC, 0x3);\n\n    } else {\n\n        /*\n\n         * make future invocations of pci_is_express() return false\n\n         * and pci_config_size() return PCI_CONFIG_SPACE_SIZE.\n\n         */\n\n        pci_dev->cap_present &= ~QEMU_PCI_CAP_EXPRESS;\n\n    }\n\n\n\n    virtio_pci_bus_new(&proxy->bus, sizeof(proxy->bus), proxy);\n\n    if (k->realize) {\n\n        k->realize(proxy, errp);\n\n    }\n\n}\n", "idx": 16585, "substitutes": {"pci_dev": ["pcixdev", "pki_mod", "pci0def", "ppi_div", "pcixorig", "pci_mod", "pki_devices", "pci_ev", "ppi_dev", "pci_def", "pciaddevices", "pci0dev", "pcixdevice", "pki_ev", "pciaddevice", "pciadorig", "pci_div", "pci_dem", "ppi_ev", "pci0mod", "pki_def", "pciaddev", "pki_orig", "pki_dev", "pci_devices", "pki_device", "pci_orig", "pcixev", "pci0device", "pci_device", "ppi_dem"], "errp": ["rorproc", "nerpb", "nerpc", "rorpc", "nerp", "nerproc", " errpc", "rorpb", "errpc", "errproc", "errpb", "rorp", " errproc", " errpb"], "proxy": ["facebook", "shadow", "child", "plus", "service", "library", "reference", "zip", "web", "copy", "reverse", "socket", "pse", "config", "cop", "lib", "p", "resource", "serial", "fax", "plugin", "coe", "engine", "bridge", "query", "force", "linux", "fuel", "queue", "pa", "remote", "play", "route", "connection", "port", "docker", "Proxy", "instance", "base", "image", "ping", "component", "root", "match", "XY", "forward", "phy", "model", "byte", "roxy", "back", "sync", "ghost", "address", "wrapper", "ship", "project", "pin", "session", "request", "pool", "clone", "pe", "module", "PRO", "slice", "index", "ip", "profile", "gp", "alias", "shield", "phone", "client", "oe", "ube", "driver", "que", "cache", "http", "callback", "server"], "k": ["j", "child", "core", "f", "lass", "kin", "g", "module", "K", " c", "kind", " self", "o", "sk", "ko", "key", "cl", "client", "c", "kernel", "ck", "ks", "http", "cache", "ec", "connection", "C", "cc"]}}
{"project": "FFmpeg", "commit_id": "cf6914e27f14cf2b5a66e25f5cf3549ceabb1648", "target": 0, "func": "static int cdxl_decode_frame(AVCodecContext *avctx, void *data,\n\n                             int *data_size, AVPacket *pkt)\n\n{\n\n    CDXLVideoContext *c = avctx->priv_data;\n\n    AVFrame * const p = &c->frame;\n\n    int ret, w, h, encoding, format, buf_size = pkt->size;\n\n    const uint8_t *buf = pkt->data;\n\n\n\n    if (buf_size < 32)\n\n        return AVERROR_INVALIDDATA;\n\n    encoding        = buf[1] & 7;\n\n    format          = buf[1] & 0xE0;\n\n    w               = AV_RB16(&buf[14]);\n\n    h               = AV_RB16(&buf[16]);\n\n    c->bpp          = buf[19];\n\n    c->palette_size = AV_RB16(&buf[20]);\n\n    c->palette      = buf + 32;\n\n    c->video        = c->palette + c->palette_size;\n\n    c->video_size   = buf_size - c->palette_size - 32;\n\n\n\n    if (c->palette_size > 512)\n\n        return AVERROR_INVALIDDATA;\n\n    if (buf_size < c->palette_size + 32)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp < 1)\n\n        return AVERROR_INVALIDDATA;\n\n    if (c->bpp > 8) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel size: %d\\n\", c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n    if (format) {\n\n        av_log_ask_for_sample(avctx, \"unsupported pixel format: %d\\n\", format);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, avctx)) < 0)\n\n        return ret;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n\n\n    if (c->video_size < FFALIGN(avctx->width, 16) * avctx->height * c->bpp / 8)\n\n        return AVERROR_INVALIDDATA;\n\n    if (!encoding && c->palette_size && c->bpp <= 8) {\n\n        avctx->pix_fmt = PIX_FMT_PAL8;\n\n    } else if (encoding == 1 && (c->bpp == 6 || c->bpp == 8)) {\n\n        if (c->palette_size != (1 << (c->bpp - 1)))\n\n            return AVERROR_INVALIDDATA;\n\n        avctx->pix_fmt = PIX_FMT_BGR24;\n\n    } else {\n\n        av_log_ask_for_sample(avctx, \"unsupported encoding %d and bpp %d\\n\",\n\n                              encoding, c->bpp);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    p->reference = 0;\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    if (encoding) {\n\n        av_fast_padded_malloc(&c->new_video, &c->new_video_size,\n\n                              h * w + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!c->new_video)\n\n            return AVERROR(ENOMEM);\n\n        if (c->bpp == 8)\n\n            cdxl_decode_ham8(c);\n\n        else\n\n            cdxl_decode_ham6(c);\n\n    } else {\n\n        cdxl_decode_rgb(c);\n\n    }\n\n    *data_size      = sizeof(AVFrame);\n\n    *(AVFrame*)data = c->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 16602, "substitutes": {"avctx": ["groundcms", "avecp", "afcu", "avc", "ajcontext", "avecf", "avcoll", "AVc", "avctrl", "avhw", "abcontext", "avehw", "vercf", "afcb", "afconfig", "afsync", "afloc", " avconfig", "avsync", "afcci", " avcci", "AVctx", "aucb", " avcontext", "axcontext", "afcoll", "avecv", "navcontext", "afcv", "axconfig", "navconn", " avcms", "alsync", "axcas", "afcas", "avctl", "aveconn", "avectl", "navhw", "afc", "avcb", "afcms", "avcp", "auctx", "ajctrl", "aucontext", "afctrl", " avcas", "auctl", "avcas", "groundcontext", "axctx", "avcci", " avcv", "navctx", "avcv", "afcf", "ajcu", "vercontext", "aveloc", "ajctx", "avconfig", " avcoll", "alctx", "avesync", "avcf", "afcp", "groundctx", "navcp", "avecoll", "avloc", "alcp", "AVcontext", "avectx", "avcms", "afctl", "verctx", "abctrl", "verloc", "afhw", "afcontext", "alcontext", "avconn", "afctx", "abcu", "abctx", "avecontext", "groundcci", "afconn", "AVconn", "avec", "avecb", "avcu", "avcontext"], "data": ["board", "m", "Data", "content", "code", "x", "base", "image", "f", "media", "buffer", "window", "channel", "slice", "pos", "d", "val", "array", "size", "audio", "memory", "config", "start", "ad", "response", "buff", "batch", "v", "device", "da", "video", "pad", "cache", "dat", "body", "a", "DATA", "bytes", "message", "frame", "value", "input"], "data_size": [" data_source", "data_source", "datablocksource", " data_external", "datablockexternal", " data_capacity", "datablocksize", "data_external", "data_capacity", "datablockcapacity"], "pkt": ["Piece", "fkt", "Packet", "fqt", " pct", "cpkg", "packet", "spkt", "spacket", " piece", " packet", "Pft", "pqt", "piece", "facket", "Pkg", "pkg", "cpqt", "cpkt", "pct", " pft", "fkg", "Pkt", "Pct", " pkg", "spft", " pqt", "pft", "cpacket", "cpiece", "spct"], "c": ["ic", "oc", "spec", "x", "cf", "anc", "sec", "enc", "cs", "d", "config", "xc", "cu", "cc", "pc", "m", "content", "vc", "rc", "cm", "bc", "cp", "mc", "self", "o", "container", "sc", "k", "cr", "v", "lc", "cat", "can", "uc", "ec", "unc", "co", "C", "dc", "code", "f", "ct", "current", "or", "coll", "ctrl", "cy", "ca", "arc", "l", "ci", "con", "b", "cd", "s", "ch", "t", "conf", "n", "g", "i", "z", "ctx", "abc", "context", "ce", "nc", "ac", "tc", "e", "cl", "cur", "cache", "col", "u"], "p": ["pc", "m", "t", "fp", "f", "pool", "vp", "r", "pe", "n", "pd", "g", "i", "cp", "pb", "o", "l", "d", "pi", "v", "b", "a", "py", "pt", "P", "u"], "ret": ["status", "code", "info", "al", "f", "ref", "alt", "reg", "nt", "gc", "r", "fun", "rt", "result", "num", "flag", "match", "ut", "ext", "mem", "resp", "def", "rets", "get", "en", "arr", "arg", "att", "bad", "val", "re", "Ret", " RET", "back", "img", "value", "det", "cat", " Ret", "RET", "error", "res", "mt", "ft", "reply", "success", "len"], "w": ["wt", "m", "fw", "s", "work", "t", "x", "f", "r", "n", "wo", "we", "g", "sw", "z", "wb", "ow", "wd", "kw", "ew", "o", "l", "hw", "d", "W", "size", "wal", "height", "q", "e", "k", "v", "b", "win", "wh", "wa", "aw", "weight", "y", "u"], "h": ["t", "x", "f", "oh", "hr", "n", "gh", "hi", "hd", "z", "rh", "uh", "help", "en", "o", "l", "d", "ht", "sh", "size", "height", "q", "e", "k", "bh", "ih", "v", "hm", "b", "ul", "ph", "wa", "ha", "hs", "ah", "H", "y", "u"], "encoding": ["enasing", "Encoding", "enhryption", "engoding", "enhording", "engaming", "ecasing", "enording", "encaming", "encaging", "enhoding", "incasing", "engoder", "encoder", "Encoder", "decasing", "incoding", "Encaming", "encasing", "encaching", "Encasing", "enryption", "Encording", "ecaching", "decoding", "engasing", "incaging", "incaching", "decaming", "decoder", "Encaging", "encryption", "Encaching", "Encryption", "enhasing", "encording", "ecoding", "enoding", "ecaging"], "format": ["at", "html", "term", "scale", "offset", "t", "direction", "mode", "f", "name", "op", "platform", "file", "family", "theme", "option", "quality", "year", "type", "method", "package", "padding", "magic", "filename", "letter", "flat", "size", "feat", "style", "length", "prefix", "language", "qt", "v", "ant", "unit", "layout", "position", "frequency", "area", "support", "crop", "fn", "form", "template", "api", "frame", "Format", "version", "len"], "buf": ["wav", "ab", "br", "grab", "ff", "func", "fp", "f", "lim", "fam", "buffer", "vec", "fun", "coord", "cf", "num", "cb", "block", "bc", "src", "loc", "wb", "ctx", "pb", "count", "cas", "home", "uv", "context", "gb", "header", "array", "conv", "feat", "box", "aux", "bu", "img", "config", "queue", "bd", "utf", "buff", "fb", "v", "batch", "bh", "cur", "rb", "seq", "cmd", "uc", "comb", "pad", "que", "b", "cap", "alloc", "proc", "port", "bag", "uf", "cv", "len"]}}
{"project": "FFmpeg", "commit_id": "9c85329cd02e9284892bf263ce6133b2fc479792", "target": 1, "func": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)\n\n{\n\n    uint32_t opcode_size, offset;\n\n    uint8_t *dst, *dend, mask = 0, color = 0;\n\n    const uint8_t *src, *send, *opcodes;\n\n    int i, j, op = 0;\n\n\n\n    i = bytestream2_get_byte(&c->gb);\n\n    if (i) {\n\n        if (code & 0x10) {\n\n            int align;\n\n\n\n            align = bytestream2_tell(&c->gb) & 3;\n\n            if (align)\n\n                bytestream2_skip(&c->gb, 4 - align);\n\n        }\n\n        do {\n\n            int page, val, x, y;\n\n            val    = bytestream2_get_be16(&c->gb);\n\n            page   = val >> 14;\n\n            x      = (val & 0x7F) * 2;\n\n            y      = ((val >> 7) & 0x7F) * 2;\n\n            dst    = c->frame[page] + x + y * c->width;\n\n            dend   = c->frame[page] + c->frame_size;\n\n            offset = (x & 0x7F) * 2;\n\n            j      = bytestream2_get_le16(&c->gb) + offset;\n\n            do {\n\n                offset++;\n\n                if (dst + 3 * c->width + 4 > dend)\n\n                    return AVERROR_INVALIDDATA;\n\n                read4x4block(c, dst, c->width);\n\n                if ((offset & 0x3F) == 0)\n\n                    dst += c->width * 3;\n\n                dst += 4;\n\n            } while (offset < j);\n\n        } while (--i);\n\n    }\n\n\n\n    dst  = c->frame[c->current_frame];\n\n    dend = c->frame[c->current_frame] + c->frame_size;\n\n    do {\n\n        set_src_position(c, &src, &send);\n\n        if ((src + 3 * c->width + 4 > send) ||\n\n            (dst + 3 * c->width + 4 > dend))\n\n            return AVERROR_INVALIDDATA;\n\n        copy_block4(dst, src, c->width, c->width, 4);\n\n        i++;\n\n        if ((i & 0x3F) == 0)\n\n            dst += c->width * 3;\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 16614, "substitutes": {"c": ["ic", "oc", "center", "cf", "cod", "enc", "cs", "d", "xc", "config", "cu", "p", "h", "icc", "cv", "cc", "pc", "m", "vc", "cm", "cp", "bc", "mc", "self", "k", "sc", "cr", "v", "lc", "uc", "ec", "co", "C", "dc", "core", "f", "ct", "cpp", "cb", "this", "cy", "ctrl", "ca", "arc", "l", "course", "ci", "w", "con", "b", "chart", "s", "ch", "t", "conf", "gc", "n", "g", "z", "ctx", "fc", "ce", "nc", "ac", "com", "tc", "e", "cl", "cur", "video", "cache", "u"], "pkt": ["Pkt", "Pct", "Pk", "Packet", "cpk", "cpct", "pk", " pct", "cpkt", "cpacket", "packet", " pk", "pct", " packet"], "code": ["m", " coding", "ch", " cmd", "data", "bit", "image", "f", "buffer", "rc", "cm", "pack", "num", "cb", "type", "cod", "loc", "bc", " codes", "index", "sec", "zip", "Code", "count", "enc", " Code", " codec", "nc", " co", " encode", "config", "codes", " chunk", "id", "e", "length", "seq", "p", "b", " decode", "ec", "ode", "co", "source", "cc"], "offset": ["set", "entry", "skip", "data", "info", "Offset", "f", "attribute", "alt", "image", "bit", "ne", "adj", "hop", "num", "loc", "ny", "padding", "index", "pos", "slice", "timeout", "online", "o", "ip", "range", "l", "gap", "location", "slot", "axis", "alias", "size", "uni", "style", "adjust", "reset", "ui", "length", "key", "start", "delay", "e", "id", "unk", "update", "position", "si", "off", "p", "address", "shift", "line", "error", "ace", "origin", "api", "a", "end", "alpha", "order", "len"], "dst": ["sdest", "vdst", "pack", "num", "vdost", "odest", "DST", "pos", "sste", "Dsts", "dyest", "sst", "dost", "adsts", " dST", "dnd", "lest", "nost", "dest", "dste", "idsts", "dysts", "odost", "sdste", "adend", " drest", "vdstream", "idost", "idend", "srest", "vdest", "idST", "lost", " dest", "sdstream", "Dst", "lste", "sdend", " dste", "dyend", "idst", " dnd", "idnd", "odst", "Dnd", "sdsts", "lst", " dsts", "nend", " dstream", "nrest", "Dend", "Dstream", "Dste", "s", "all", "dstream", "buffer", "adost", "g", "dyst", " dost", "get", "sdst", "Dost", "adst", "nst", "drest", "_", "odsts", "idest", "dST", "sost", "Dest", "dsts", "dystream", "sest"], "dend": ["Dstart", "dending", "dpend", "jpend", "dEND", "mdend", "ldpend", "lnd", " dends", "bstart", "zended", "zstart", " dnd", "bpend", "xend", " dended", "dends", " dstart", "lense", "zends", "Dends", "mdends", " dEND", "ldend", "xnd", "Dnd", "jend", "dstart", "jends", "zend", "lstart", "dense", "ldended", "xstart", "ldstart", " dense", " dending", " dpend", "zEND", "xense", "dended", "jnd", "dnd", "bend", "bended", "Dended", "lend", "mdEND", "zending", "Dend", "mdending", "Dpend"], "src": ["uri", "spec", "stat", "sup", "sit", "data", "rest", "dest", "settings", "rc", "sb", "stream", "sl", "cb", "loc", "source", "sel", "fc", "slice", "ind", "filename", "low", "setup", "gb", "rob", "rib", "ui", "sn", "sub", "img", "config", "start", "gl", "ssl", "sc", "sync", "hl", "sr", "req", "bis", "rb", "uc", "url", "rin", "gz", "split", "inst", "iv", "desc", "fi", "attr", "download", "dist"], "send": ["set", "uri", "stat", "sex", "init", "nd", "push", "call", "dest", "sort", "rc", "feed", "pack", "see", "eight", "stream", "Send", "control", "slice", "ind", "sec", "en", "get", "speed", "range", "read", "size", "seed", "use", "add", "config", "response", "start", "sc", "sync", "shift", "sent", "kill", "write", "find", "transform", "iv", "end", "se", "scan", "each", "source", "cv", "dist"], "opcodes": ["catcode", "opercodes", "bitcodes", "bitmaps", "catnames", "opercode", "catcodes", "catmaps", "opnames", "opermaps", "opernames", "opmaps", "bitcode", "bitnames"], "i": ["uri", "m", "bi", "init", "ji", "f", "image", "ix", "ini", "qi", "r", "io", "ai", "n", "phi", "z", "ii", "in", "ori", "di", "index", "mini", "iu", "I", "ind", "multi", "o", "ip", "l", "d", "pi", "ui", "ci", "img", "id", "start", "e", "v", "ie", "ni", "si", "ri", "p", "xi", "binary", "b", "anti", "a", "it", "fi", "inner", "source", "li", "u"], "j": ["m", "jl", "ji", "ch", "br", "jp", "note", "f", "uj", "r", "ne", "adj", "n", "jj", "job", "eight", "je", "g", "z", "ii", "ij", "ie", "pos", "aj", "dj", "jump", "o", "l", "d", "w", "J", "start", "k", "q", "bl", "v", "js", "p", "off", "shift", "b"], "align": ["scale", "bin", "work", "skip", "al", "call", "grid", "sort", "border", "rel", "coord", "pixel", "angle", "num", "match", "padding", "aligned", "help", "anch", "label", "range", "gap", "ign", "join", "balance", "lead", "margin", "alias", " alignment", "el", "size", "style", "adjust", "pal", "lace", "il", "bl", "batch", "shake", "sync", "binary", "shift", "lock", "pad", "tail", "middle", "split", "addr", "aff", " aligned", "len"], "page": ["scale", "session", "pid", "pages", "base", "image", "sp", "net", "px", "fe", "pe", "stall", "mark", "inc", "pl", "wait", "num", "pixel", "channel", "phrase", "hop", "year", "block", "month", "max", "loc", "sel", "index", "ip", "gap", "pg", "margin", "pp", "step", "order", "large", "site", "aa", "Page", "length", "key", "limit", "e", "fb", "v", "age", "position", "line", "url", "p", "next", "win", "col", "row", "number", "screen", "frame", "port", "server", "edge", "me", "value", "wave"], "val": ["Val", "bin", "pid", "data", "cal", "f", "ref", "al", "base", "pl", "vals", "year", "sl", "xy", "loc", "sel", "pos", "ind", "vi", "VAL", "gold", "range", "l", "vol", "fl", "grade", "pal", "cel", "key", "bl", "v", "unit", "p", "line", "b", "col", "win", "la", "ul", "eval", "aval", "py", "valid", "el", "value", "pt", "ver", "len"], "x": ["rx", "xx", "wx", "f", "image", "ix", "px", "pe", "n", "xxx", "g", "z", "xy", "loc", "index", "pos", "en", "o", "ip", "xp", "l", "d", "size", "el", "ax", "w", "dx", "ex", "key", "X", "e", "height", "v", "ey", "p", "xi", "area", "b", "win", "col", "h", "xc", "value", "u"], "y": ["m", "s", "ady", "t", "f", "n", "ya", "ym", "g", "z", "ny", "xy", "cy", "o", "Y", "l", "d", "yi", "size", "dy", "height", "w", "ci", "yy", "ey", "yt", "v", "p", "b", "col", "oy", "vy", "h", "yo", "ty", "py", "sy", "my", "value", "wy", "u"], "op": ["oc", "skip", "bit", "sp", "hop", "cp", "oper", "ops", "ap", "zip", "o", "ip", "slot", "pp", "comp", "rot", "prev", "cop", "seq", "p", "lock", "cmp", "opt", "operation"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "static void save_native_fp_fsave(CPUState *env)\n\n{\n\n    int fptag, i, j;\n\n    uint16_t fpuc;\n\n    struct fpstate fp1, *fp = &fp1;\n\n\n\n    asm volatile (\"fsave %0\" : : \"m\" (*fp));\n\n    env->fpuc = fp->fpuc;\n\n    env->fpstt = (fp->fpus >> 11) & 7;\n\n    env->fpus = fp->fpus & ~0x3800;\n\n    fptag = fp->fptag;\n\n    for(i = 0;i < 8; i++) {\n\n        env->fptags[i] = ((fptag & 3) == 3);\n\n        fptag >>= 2;\n\n    }\n\n    j = env->fpstt;\n\n    for(i = 0;i < 8; i++) {\n\n        memcpy(&env->fpregs[j].d, &fp->fpregs1[i * 10], 10);\n\n        j = (j + 1) & 7;\n\n    }\n\n    /* we must restore the default rounding state */\n\n    fpuc = 0x037f | (env->fpuc & (3 << 10));\n\n    asm volatile(\"fldcw %0\" : : \"m\" (fpuc));\n\n}\n", "idx": 16628, "substitutes": {"env": ["enable", "init", "db", "extra", "code", "core", "obj", "err", "jp", "net", "eu", "ne", "engine", "elf", "exc", "cf", "cp", "np", "qv", "environment", "ext", "manager", "console", "en", "her", "enc", "vm", "equ", "context", "hw", "inet", "size", "pkg", "Environment", "w", "ev", "config", "queue", "e", "hl", "ep", "buf", "v", "impl", "ea", "p", "que", "cache", "cmp", "output", "ec", "h", "et", "er", "ef", "export", "eni", "el", "dict", "cv", "conn"], "fptag": ["faptags", "fctag", "fportags", " fptame", "fftags", " fptype", "fppagging", "fptagn", "fppang", "fpertagging", " fstang", "fntag", "fpragn", "fptype", "fftage", "fctad", "fportag", "fptagging", "fprime", "fptub", "xftext", "fportype", " fptags", "fspointime", "fpparg", "fptrag", " faptags", "fiptext", "fptame", "xptext", "fntame", "fftak", "xftub", "fppad", "fftub", "fftype", " fstig", "fspointagn", "fpointagn", " fptig", "fiptub", "xftak", "fstang", "fctang", "faptag", "faptype", "fiptag", "fstag", "fptad", "fptang", "fprag", "fppagged", "fptime", "xftag", " fptad", "fppame", "fppime", "fptext", "fpointime", " faptype", "fpertagged", "fpointarg", " fntagged", " fptagging", "fiptak", " fptang", "fptagged", "fpertag", " fstad", "fptage", " faptag", "fsptag", "xptag", "fsptagn", " faptage", "fftag", "fsptarg", "fptrak", "fftext", "fntagging", "fppig", "fptig", " fntame", "fntagged", "faptage", "fportage", "fstig", " fstag", "fptrub", "fprarg", "fptags", "fspointag", "fstad", "fspointarg", "xptub", "fsptime", " fntag", "fppagn", "xptak", "fpointag", " fptagged", "fctig", "fppag", "fpertame", "fptak", " fntagging", "fptrext", " fptage", "fptarg"], "i": ["gi", "ti", "uri", "m", "bi", "ji", "info", "x", "f", "jp", "ix", "ini", "qi", "ai", "mi", "n", "io", "phi", "g", "z", "ii", "in", "ie", "iu", "ori", "ind", "di", "I", "multi", "zi", "vi", "is", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "e", "k", "v", "ni", "c", "si", "ri", "p", "xi", "b", "mu", "it", "eni", "fi", "y", "li", "u"], "j": ["jo", "jc", "m", "jl", "ji", "x", "jp", "f", "bj", "uj", "jit", "note", "qi", "r", "ne", "adj", "n", "jj", "job", "je", "g", "z", "ii", "jet", "ij", "ie", "pos", "ind", "aj", "dj", "o", "l", "d", "ci", "J", "k", "e", "q", "kj", "v", "c", "js", "si", "p", "b", "ja", "y", "li", "u"], "fpuc": ["puc", "rfsu", "fsuc", "fnsc", "cfuc", "fpud", "printfuc", "vpud", "rfUC", "pusc", "fpcu", "fpasc", "lpsu", "bpul", "fpusc", "fpbc", "tpasc", "cfUC", "lpus", "rfasc", "fpus", "lpuc", "rfuc", "wpus", "FPuc", "printfcu", "fnbc", "vpuc", "fsbc", "lpasc", "bpuc", "pUC", "lpUC", "pcu", "fsus", "lpul", "tpsu", "pus", "fpUC", "bpbc", "fpul", "lpcus", "bpus", "fpcus", "pbc", "FPUC", "fpuu", "fnus", "tpuc", "fpsu", "fpsc", "lpud", "printfus", "vpus", "FPcus", "lpuu", "tpUC", "lpbc", "vpsc", "fsUC", "wpbc", "fnusc", "cfcus", "cfuu", "fncu", "wpuc", "printfusc", "FPuu", "fnul", "fnud", "lpsc", "fnuc", "wpUC"], "fp1": ["puc", "fus", "cfuc", "FP1", "df1", "p2", "cf2", "cpus", "cf1", "dfus", "fpus", "FPuc", "cp1", "fp2", "f1", "FP2", "p1"], "fp": ["wp", "plugin", "fw", "farm", "f", "jp", "vp", "io", "file", "elf", "cf", "bp", "upp", "cp", "lp", "utils", "ctx", "fc", "pb", "fs", "FP", "rf", "filename", "fen", "framework", "gp", "fl", "df", "nil", "inet", "pkg", "bf", "aux", "prefix", "fd", "fb", "processor", "buf", "tmp", "p", "mp", "cmp", "fm", "iper", "tf", "fn", "ec", "proc", "ulp", "tp", "php", "py", "prot", "uf", "np", "sf"]}}
{"project": "FFmpeg", "commit_id": "5dbb63feefb9070d6fbb5fc16406813f14aa7f9b", "target": 0, "func": "static int decode_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic;\n\n    int err, i, ret, video_index, audio_index, subtitle_index;\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    AVFormatParameters params, *ap = &params;\n\n\n\n    video_index = -1;\n\n    audio_index = -1;\n\n    subtitle_index = -1;\n\n    is->video_stream = -1;\n\n    is->audio_stream = -1;\n\n    is->subtitle_stream = -1;\n\n\n\n    global_video_state = is;\n\n    url_set_interrupt_cb(decode_interrupt_cb);\n\n\n\n    memset(ap, 0, sizeof(*ap));\n\n\n\n    ap->width = frame_width;\n\n    ap->height= frame_height;\n\n    ap->time_base= (AVRational){1, 25};\n\n    ap->pix_fmt = frame_pix_fmt;\n\n\n\n    err = av_open_input_file(&ic, is->filename, is->iformat, 0, ap);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if(genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    err = av_find_stream_info(ic);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if(ic->pb)\n\n        ic->pb->eof_reached= 0; //FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < ic->nb_streams; i++) {\n\n        AVCodecContext *enc = ic->streams[i]->codec;\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n        switch(enc->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            if ((audio_index < 0 || wanted_audio_stream-- > 0) && !audio_disable)\n\n                audio_index = i;\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            if ((video_index < 0 || wanted_video_stream-- > 0) && !video_disable)\n\n                video_index = i;\n\n            break;\n\n        case CODEC_TYPE_SUBTITLE:\n\n            if (wanted_subtitle_stream-- >= 0 && !video_disable)\n\n                subtitle_index = i;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    if (show_status) {\n\n        dump_format(ic, 0, is->filename, 0);\n\n        dump_stream_info(ic);\n\n    }\n\n\n\n    /* open the streams */\n\n    if (audio_index >= 0) {\n\n        stream_component_open(is, audio_index);\n\n    }\n\n\n\n    if (video_index >= 0) {\n\n        stream_component_open(is, video_index);\n\n    } else {\n\n        if (!display_disable)\n\n            is->show_audio = 1;\n\n    }\n\n\n\n    if (subtitle_index >= 0) {\n\n        stream_component_open(is, subtitle_index);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    for(;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER\n\n        if (is->paused && !strcmp(ic->iformat->name, \"rtsp\")) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int stream_index= -1;\n\n            int64_t seek_target= is->seek_pos;\n\n\n\n            if     (is->   video_stream >= 0) stream_index= is->   video_stream;\n\n            else if(is->   audio_stream >= 0) stream_index= is->   audio_stream;\n\n            else if(is->subtitle_stream >= 0) stream_index= is->subtitle_stream;\n\n\n\n            if(stream_index>=0){\n\n                seek_target= av_rescale_q(seek_target, AV_TIME_BASE_Q, ic->streams[stream_index]->time_base);\n\n            }\n\n\n\n            ret = av_seek_frame(is->ic, stream_index, seek_target, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            }else{\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (is->audioq.size > MAX_AUDIOQ_SIZE ||\n\n            is->videoq.size > MAX_VIDEOQ_SIZE ||\n\n            is->subtitleq.size > MAX_SUBTITLEQ_SIZE) {\n\n            /* wait 10 ms */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n        if(url_feof(ic->pb)) {\n\n            av_init_packet(pkt);\n\n            pkt->data=NULL;\n\n            pkt->size=0;\n\n            pkt->stream_index= is->video_stream;\n\n            packet_queue_put(&is->videoq, pkt);\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret != AVERROR_EOF && url_ferror(ic->pb) == 0) {\n\n                SDL_Delay(100); /* wait for user event */\n\n                continue;\n\n            } else\n\n                break;\n\n        }\n\n        if (pkt->stream_index == is->audio_stream) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* disable interrupting */\n\n    global_video_state = NULL;\n\n\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        av_close_input_file(is->ic);\n\n        is->ic = NULL; /* safety */\n\n    }\n\n    url_set_interrupt_cb(NULL);\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    return 0;\n\n}\n", "idx": 16651, "substitutes": {"arg": ["pc", "oc", "util", "init", "rc", "ai", "inc", "ar", "g", "flag", "or", "var", "loc", "Arg", "abc", "arr", "arc", "AR", "val", "ac", "args", "ay", "ig", "ax", "ang", "ad", "config", "ag", "par", "lib", "argument", "inter", "play", "param", "ace", "fi", "arp", "amp"], "is": ["oc", "ist", "bi", "ais", "ai", "ar", "ie", "cs", "iso", "pi", "id", "ish", "Is", "p", "next", "us", "it", "isc", "was", "ms", "isa", "init", "ini", "app", "in", "parse", "mis", "kit", "iss", "ri", "can", "iz", "play", "iv", "ib", "core", "view", "or", "as", "oper", "bis", "ics", "vs", "sys", "ace", "isl", "es", "state", "esi", "lis", "pic", "ik", "s", "irc", "info", "has", "ls", "ops", "get", "ip", "ris", "css", "are", "ac", "ui", "il", "iris", "isi", "cache", "http", "pick", "its", "api", "os", "im", "IS"], "ic": ["oc", "bi", "x", "ai", "inc", "aic", "anc", "ie", "exec", "cs", "rec", "ican", "bank", "xc", "cli", "lib", "p", "icc", "isc", "it", "conn", "cc", "pc", "icing", "init", "wx", "cus", "vc", "ix", "ini", "cm", "iac", "app", "bc", "mic", "mc", "ig", "aci", "lc", "ec", "ia", "co", "ib", "cci", "ct", "nic", "ico", "IC", "ry", "cy", "ice", "wic", "ci", "ics", "c", "sci", "cit", "sys", "ace", "voc", "pic", "ik", "irc", "gc", "lic", "ici", "ctx", "acl", "fc", "get", "ip", "ce", "ac", "tc", "cl", "isi", "ill"], "err": ["br", "result", "str", "ar", " er", "nor", "var", " error", "lr", "res", "die", "fi", "gr", "len", "rx", "init", "rc", "hr", "fun", "msg", "resp", "der", "magic", "kr", "arr", "fer", "orr", "mr", "last", "acer", "dev", "ir", "wr", "norm", "pr", "iter", "order", "ver", "status", "ner", "fr", "code", "runner", "fe", "r", "try", "cb", "rh", "orig", "ind", "ry", "erer", "rar", "sr", "yr", "doc", "Er", "er", "Error", "reply", "bug", "rr", "conf", "cor", "g", "aster", "ler", "dr", "e", "req", "error", "usr", "inner"], "i": ["gi", "ti", "uri", "bi", "m", "init", "j", "ik", "ami", "info", "x", "jit", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "g", "hi", "ii", "in", "ori", "iu", "index", "ind", "di", "I", "ie", "multi", "zi", "ip", "chi", "l", "adi", "oi", "yi", "pi", "ui", "isin", "ci", "abi", "id", "il", "e", "start", "cli", "v", "ni", "c", "si", "ri", "p", "xi", "b", "iter", "it", "eni", "end", "fi", "y", "li", "ib", "u"], "ret": ["status", "part", "info", "fat", "ref", "bit", "alt", "let", "reg", "nt", "lit", "hash", "rt", "fun", "result", "str", "flag", "ut", "fin", "resp", "rets", "def", "sat", "count", "arr", "att", "val", "Ret", "feat", "back", "id", "det", "fit", "bot", "rev", "cat", "rl", "rb", "gt", "RET", "error", "res", "et", "mt", "ft", "iter", "usr", "reply", "success", "len"], "video_index": ["frame_level", "video_column", "videoUinfo", "videoUcolumn", "video_number", "video__index", "videoUindex", "videoUcoll", "videoxindex", "videoidinfo", "document_column", "documentIdcolumn", "videoIdindex", "document_info", "videoidcoll", "videoIdinfo", "videoxnumber", "videoIdcoll", "video__number", "frame__index", "video_info", "documentIdinfo", "videoidcolumn", "frame_number", "video__level", "document_index", "video_level", "frame__level", "frame_index", "videoIdcolumn", "videoidindex", "documentIdcoll", "video_coll", "documentIdindex", "frame__number", "document_coll", "videoxlevel"], "audio_index": ["audio_stream", "input_index", "picture_prefix", "audioIdstream", "audioIdsize", "input_size", "audio_prefix", "audio_range", "inputIdsize", "picture_index", "audio_source", "audioIdinc", "input_stream", "picture_source", "inputIdstream", "inputIdindex", "audio_size", "input_inc", "audio_inc", "picture_range", "audioIdindex", "inputIdinc"], "subtitle_index": ["subscript_width", "subtitle_width", "subtitle_length", "subvideo_index", "subscript_index", "subvideo_id", "subtitle_label", "subscript_length", "subtitle_id", "subvideo_label", "subvideo_length"], "pkt1": ["pkt6", " packet4", " pkt2", "pke0", "pqt2", "pkt0", "pqt1", "Packet1", " pkt4", "packet6", "pke6", "pke4", "Pkt0", " pkt6", "pqt0", "Packet0", "pvt4", " packet2", "Packet4", "Pkt4", "packet0", "pvt2", "pke2", "pke1", "Pkt2", "pvt6", "pkt4", "Packet2", "pvt1", " packet1", "packet2", "Pkt1", "pkt2", "packet4", "packet1", " packet6", "pqt4"], "pkt": ["fnt", "Pkt", "fk", "Pct", "Pk", "pnt", "Pnt", "pk", "fkt", " pct", "fct", " pk", "pct", " pnt"], "params": ["ns", "types", "settings", "options", "sp", "ams", "ips", "as", "lp", "ops", "ctx", "acl", "copy", "parser", " pars", "ip", "cs", "aps", "parse", "Parameters", "audio", "pi", "args", "ac", "bps", "config", "processor", "par", "ps", "tmp", "cache", "gs", "sys", "param", "proc", " parameters", "api", "parts", "py", "mac", "np", "attr"], "ap": ["ab", "au", "af", "al", "jp", "op", "sp", "hap", "ape", "ai", "adj", "ar", "hop", "apa", "ams", "app", "am", "apy", "as", "snap", "asp", "aj", "pac", "ip", "art", "gap", "nav", "aps", "AP", "ac", "av", "Ap", "ax", "ang", "pa", "ep", "ak", "apt", "ait", "map", "ps", "imp", "p", "xml", "mp", "cap", "aw", "wa", "rap", "api", "a", "tp", "arp", "amp"], "timestamp": ["Timetz", " Timetz", " timtim", "dimetz", "mometz", " Timestamp", "Timsequence", "lifetz", "tmsequence", "lifsequence", "momeline", "imtim", "momempt", "temeline", "temestamp", "lifestamp", "dimetime", "dimest", " timest", "tmest", " timetz", "temetz", "Timest", "timtim", "tmempt", "timetz", "tmetz", "temest", "imestamp", "timempt", "timetime", "Timetime", "lifest", "dimestamp", "timest", "tmeline", "imest", "timeline", "Timeline", "Timestamp", " Timest", " Timtim", "timsequence", "dimeline", "momestamp", "imetz", "tmestamp", "dimempt", "tmetime"], "enc": ["dc", "Enc", "session", "data", "vc", "rc", "inc", "exc", "coll", "sl", "anc", "loc", "sec", "kw", "exec", "rec", "conv", "nc", "iq", "ac", "config", "ssl", "lib", "cache", "cv", "conn", "voc"]}}
{"project": "FFmpeg", "commit_id": "608708009f69ba4cecebf05120c696167494c897", "target": 1, "func": "static int adpcm_decode_frame(AVCodecContext *avctx, void *data,\n                              int *got_frame_ptr, AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    ADPCMDecodeContext *c = avctx->priv_data;\n    ADPCMChannelStatus *cs;\n    int n, m, channel, i;\n    short *samples;\n    const uint8_t *src;\n    int st; /* stereo */\n    int count1, count2;\n    int nb_samples, coded_samples, ret;\n    nb_samples = get_nb_samples(avctx, buf, buf_size, &coded_samples);\n    if (nb_samples <= 0) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of samples in packet\\n\");\n    }\n    /* get output buffer */\n    c->frame.nb_samples = nb_samples;\n    if ((ret = avctx->get_buffer(avctx, &c->frame)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    }\n    samples = (short *)c->frame.data[0];\n    /* use coded_samples when applicable */\n    /* it is always <= nb_samples, so the output buffer will be large enough */\n    if (coded_samples) {\n        if (coded_samples != nb_samples)\n            av_log(avctx, AV_LOG_WARNING, \"mismatch in coded sample count\\n\");\n        c->frame.nb_samples = nb_samples = coded_samples;\n    }\n    src = buf;\n    st = avctx->channels == 2 ? 1 : 0;\n    switch(avctx->codec->id) {\n    case CODEC_ID_ADPCM_IMA_QT:\n        /* In QuickTime, IMA is encoded by chunks of 34 bytes (=64 samples).\n           Channel data is interleaved per-chunk. */\n        for (channel = 0; channel < avctx->channels; channel++) {\n            int16_t predictor;\n            int step_index;\n            cs = &(c->status[channel]);\n            /* (pppppp) (piiiiiii) */\n            /* Bits 15-7 are the _top_ 9 bits of the 16-bit initial predictor value */\n            predictor = AV_RB16(src);\n            step_index = predictor & 0x7F;\n            predictor &= 0xFF80;\n            src += 2;\n            if (cs->step_index == step_index) {\n                int diff = (int)predictor - cs->predictor;\n                if (diff < 0)\n                    diff = - diff;\n                if (diff > 0x7f)\n                    goto update;\n            } else {\n            update:\n                cs->step_index = step_index;\n                cs->predictor = predictor;\n            }\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            samples = (short *)c->frame.data[0] + channel;\n            for (m = 0; m < 32; m++) {\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] & 0x0F, 3);\n                samples += avctx->channels;\n                *samples = adpcm_ima_qt_expand_nibble(cs, src[0] >> 4  , 3);\n                samples += avctx->channels;\n                src ++;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WAV:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for(i=0; i<avctx->channels; i++){\n            cs = &(c->status[i]);\n            cs->predictor = *samples++ = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            if (cs->step_index > 88){\n                av_log(avctx, AV_LOG_ERROR, \"ERROR: step_index = %i\\n\", cs->step_index);\n                cs->step_index = 88;\n            }\n            if (*src++) av_log(avctx, AV_LOG_ERROR, \"unused byte should be null but is %d!!\\n\", src[-1]); /* unused */\n        }\n        for (n = (nb_samples - 1) / 8; n > 0; n--) {\n            for (i = 0; i < avctx->channels; i++) {\n                cs = &c->status[i];\n                for (m = 0; m < 4; m++) {\n                    uint8_t v = *src++;\n                    *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 3);\n                    samples += avctx->channels;\n                    *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 3);\n                    samples += avctx->channels;\n                }\n                samples -= 8 * avctx->channels - 1;\n            }\n            samples += 7 * avctx->channels;\n        }\n        break;\n    case CODEC_ID_ADPCM_4XM:\n        for (i = 0; i < avctx->channels; i++)\n            c->status[i].predictor= (int16_t)bytestream_get_le16(&src);\n        for (i = 0; i < avctx->channels; i++) {\n            c->status[i].step_index= (int16_t)bytestream_get_le16(&src);\n            c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n        }\n        for (i = 0; i < avctx->channels; i++) {\n            samples = (short *)c->frame.data[0] + i;\n            cs = &c->status[i];\n            for (n = nb_samples >> 1; n > 0; n--, src++) {\n                uint8_t v = *src;\n                *samples = adpcm_ima_expand_nibble(cs, v & 0x0F, 4);\n                samples += avctx->channels;\n                *samples = adpcm_ima_expand_nibble(cs, v >> 4  , 4);\n                samples += avctx->channels;\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_MS:\n    {\n        int block_predictor;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        block_predictor = av_clip(*src++, 0, 6);\n        c->status[0].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n        c->status[0].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        if (st) {\n            block_predictor = av_clip(*src++, 0, 6);\n            c->status[1].coeff1 = ff_adpcm_AdaptCoeff1[block_predictor];\n            c->status[1].coeff2 = ff_adpcm_AdaptCoeff2[block_predictor];\n        }\n        c->status[0].idelta = (int16_t)bytestream_get_le16(&src);\n        if (st){\n            c->status[1].idelta = (int16_t)bytestream_get_le16(&src);\n        }\n        c->status[0].sample1 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample1 = bytestream_get_le16(&src);\n        c->status[0].sample2 = bytestream_get_le16(&src);\n        if (st) c->status[1].sample2 = bytestream_get_le16(&src);\n        *samples++ = c->status[0].sample2;\n        if (st) *samples++ = c->status[1].sample2;\n        *samples++ = c->status[0].sample1;\n        if (st) *samples++ = c->status[1].sample1;\n        for(n = (nb_samples - 2) >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ms_expand_nibble(&c->status[0 ], src[0] >> 4  );\n            *samples++ = adpcm_ms_expand_nibble(&c->status[st], src[0] & 0x0F);\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_DK4:\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n            *samples++ = cs->predictor;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_DK3:\n    {\n        unsigned char last_byte = 0;\n        unsigned char nibble;\n        int decode_top_nibble_next = 0;\n        int end_of_packet = 0;\n        int diff_channel;\n        if (avctx->block_align != 0 && buf_size > avctx->block_align)\n            buf_size = avctx->block_align;\n        c->status[0].predictor  = (int16_t)AV_RL16(src + 10);\n        c->status[1].predictor  = (int16_t)AV_RL16(src + 12);\n        c->status[0].step_index = src[14];\n        c->status[1].step_index = src[15];\n        /* sign extend the predictors */\n        src += 16;\n        diff_channel = c->status[1].predictor;\n        /* the DK3_GET_NEXT_NIBBLE macro issues the break statement when\n         * the buffer is consumed */\n        while (1) {\n            /* for this algorithm, c->status[0] is the sum channel and\n             * c->status[1] is the diff channel */\n            /* process the first predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the diff channel predictor */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[1], nibble, 3);\n            /* process the first pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n            /* process the second predictor of the sum channel */\n            DK3_GET_NEXT_NIBBLE();\n            adpcm_ima_expand_nibble(&c->status[0], nibble, 3);\n            /* process the second pair of stereo PCM samples */\n            diff_channel = (diff_channel + c->status[1].predictor) / 2;\n            *samples++ = c->status[0].predictor + c->status[1].predictor;\n            *samples++ = c->status[0].predictor - c->status[1].predictor;\n        }\n        break;\n    }\n    case CODEC_ID_ADPCM_IMA_ISS:\n        for (channel = 0; channel < avctx->channels; channel++) {\n            cs = &c->status[channel];\n            cs->predictor  = (int16_t)bytestream_get_le16(&src);\n            cs->step_index = *src++;\n            src++;\n        }\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v1, v2;\n            uint8_t v = *src;\n            /* nibbles are swapped for mono */\n            if (st) {\n                v1 = v >> 4;\n                v2 = v & 0x0F;\n            } else {\n                v2 = v >> 4;\n                v1 = v & 0x0F;\n            }\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0 ], v1, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v2, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_WS:\n        while (src < buf + buf_size) {\n            uint8_t v = *src++;\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  v >> 4  , 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], v & 0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_XA:\n        while (buf_size >= 128) {\n            xa_decode(samples, src, &c->status[0], &c->status[1],\n                avctx->channels);\n            src += 128;\n            samples += 28 * 8;\n            buf_size -= 128;\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_EACS:\n        src += 4; // skip sample count (already read)\n        for (i=0; i<=st; i++)\n            c->status[i].step_index = bytestream_get_le32(&src);\n        for (i=0; i<=st; i++)\n            c->status[i].predictor  = bytestream_get_le32(&src);\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],  *src>>4,   3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st], *src&0x0F, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_EA_SEAD:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0], src[0] >> 4, 6);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[st],src[0]&0x0F, 6);\n        }\n        break;\n    case CODEC_ID_ADPCM_EA:\n    {\n        int32_t previous_left_sample, previous_right_sample;\n        int32_t current_left_sample, current_right_sample;\n        int32_t next_left_sample, next_right_sample;\n        int32_t coeff1l, coeff2l, coeff1r, coeff2r;\n        uint8_t shift_left, shift_right;\n        /* Each EA ADPCM frame has a 12-byte header followed by 30-byte pieces,\n           each coding 28 stereo samples. */\n        src += 4; // skip sample count (already read)\n        current_left_sample   = (int16_t)bytestream_get_le16(&src);\n        previous_left_sample  = (int16_t)bytestream_get_le16(&src);\n        current_right_sample  = (int16_t)bytestream_get_le16(&src);\n        previous_right_sample = (int16_t)bytestream_get_le16(&src);\n        for (count1 = 0; count1 < nb_samples / 28; count1++) {\n            coeff1l = ea_adpcm_table[ *src >> 4       ];\n            coeff2l = ea_adpcm_table[(*src >> 4  ) + 4];\n            coeff1r = ea_adpcm_table[*src & 0x0F];\n            coeff2r = ea_adpcm_table[(*src & 0x0F) + 4];\n            src++;\n            shift_left  = 20 - (*src >> 4);\n            shift_right = 20 - (*src & 0x0F);\n            src++;\n            for (count2 = 0; count2 < 28; count2++) {\n                next_left_sample  = sign_extend(*src >> 4, 4) << shift_left;\n                next_right_sample = sign_extend(*src,      4) << shift_right;\n                src++;\n                next_left_sample = (next_left_sample +\n                    (current_left_sample * coeff1l) +\n                    (previous_left_sample * coeff2l) + 0x80) >> 8;\n                next_right_sample = (next_right_sample +\n                    (current_right_sample * coeff1r) +\n                    (previous_right_sample * coeff2r) + 0x80) >> 8;\n                previous_left_sample = current_left_sample;\n                current_left_sample = av_clip_int16(next_left_sample);\n                previous_right_sample = current_right_sample;\n                current_right_sample = av_clip_int16(next_right_sample);\n                *samples++ = (unsigned short)current_left_sample;\n                *samples++ = (unsigned short)current_right_sample;\n            }\n        }\n        if (src - buf == buf_size - 2)\n            src += 2; // Skip terminating 0x0000\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_MAXIS_XA:\n    {\n        int coeff[2][2], shift[2];\n        for(channel = 0; channel < avctx->channels; channel++) {\n            for (i=0; i<2; i++)\n                coeff[channel][i] = ea_adpcm_table[(*src >> 4) + 4*i];\n            shift[channel] = 20 - (*src & 0x0F);\n            src++;\n        }\n        for (count1 = 0; count1 < nb_samples / 2; count1++) {\n            for(i = 4; i >= 0; i-=4) { /* Pairwise samples LL RR (st) or LL LL (mono) */\n                for(channel = 0; channel < avctx->channels; channel++) {\n                    int32_t sample = sign_extend(src[channel] >> i, 4) << shift[channel];\n                    sample = (sample +\n                             c->status[channel].sample1 * coeff[channel][0] +\n                             c->status[channel].sample2 * coeff[channel][1] + 0x80) >> 8;\n                    c->status[channel].sample2 = c->status[channel].sample1;\n                    c->status[channel].sample1 = av_clip_int16(sample);\n                    *samples++ = c->status[channel].sample1;\n                }\n            }\n            src+=avctx->channels;\n        }\n        /* consume whole packet */\n        src = buf + buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_R1:\n    case CODEC_ID_ADPCM_EA_R2:\n    case CODEC_ID_ADPCM_EA_R3: {\n        /* channel numbering\n           2chan: 0=fl, 1=fr\n           4chan: 0=fl, 1=rl, 2=fr, 3=rr\n           6chan: 0=fl, 1=c,  2=fr, 3=rl,  4=rr, 5=sub */\n        const int big_endian = avctx->codec->id == CODEC_ID_ADPCM_EA_R3;\n        int32_t previous_sample, current_sample, next_sample;\n        int32_t coeff1, coeff2;\n        uint8_t shift;\n        unsigned int channel;\n        uint16_t *samplesC;\n        const uint8_t *srcC;\n        const uint8_t *src_end = buf + buf_size;\n        int count = 0;\n        src += 4; // skip sample count (already read)\n        for (channel=0; channel<avctx->channels; channel++) {\n            int32_t offset = (big_endian ? bytestream_get_be32(&src)\n                                         : bytestream_get_le32(&src))\n                           + (avctx->channels-channel-1) * 4;\n            if ((offset < 0) || (offset >= src_end - src - 4)) break;\n            srcC  = src + offset;\n            samplesC = samples + channel;\n            if (avctx->codec->id == CODEC_ID_ADPCM_EA_R1) {\n                current_sample  = (int16_t)bytestream_get_le16(&srcC);\n                previous_sample = (int16_t)bytestream_get_le16(&srcC);\n            } else {\n                current_sample  = c->status[channel].predictor;\n                previous_sample = c->status[channel].prev_sample;\n            }\n            for (count1 = 0; count1 < nb_samples / 28; count1++) {\n                if (*srcC == 0xEE) {  /* only seen in R2 and R3 */\n                    srcC++;\n                    if (srcC > src_end - 30*2) break;\n                    current_sample  = (int16_t)bytestream_get_be16(&srcC);\n                    previous_sample = (int16_t)bytestream_get_be16(&srcC);\n                    for (count2=0; count2<28; count2++) {\n                        *samplesC = (int16_t)bytestream_get_be16(&srcC);\n                        samplesC += avctx->channels;\n                    }\n                } else {\n                    coeff1 = ea_adpcm_table[ *srcC>>4     ];\n                    coeff2 = ea_adpcm_table[(*srcC>>4) + 4];\n                    shift = 20 - (*srcC++ & 0x0F);\n                    if (srcC > src_end - 14) break;\n                    for (count2=0; count2<28; count2++) {\n                        if (count2 & 1)\n                            next_sample = sign_extend(*srcC++,    4) << shift;\n                        else\n                            next_sample = sign_extend(*srcC >> 4, 4) << shift;\n                        next_sample += (current_sample  * coeff1) +\n                                       (previous_sample * coeff2);\n                        next_sample = av_clip_int16(next_sample >> 8);\n                        previous_sample = current_sample;\n                        current_sample  = next_sample;\n                        *samplesC = current_sample;\n                        samplesC += avctx->channels;\n                    }\n                }\n            }\n            if (!count) {\n                count = count1;\n            } else if (count != count1) {\n                av_log(avctx, AV_LOG_WARNING, \"per-channel sample count mismatch\\n\");\n                count = FFMAX(count, count1);\n            }\n            if (avctx->codec->id != CODEC_ID_ADPCM_EA_R1) {\n                c->status[channel].predictor   = current_sample;\n                c->status[channel].prev_sample = previous_sample;\n            }\n        }\n        c->frame.nb_samples = count * 28;\n        src = src_end;\n        break;\n    }\n    case CODEC_ID_ADPCM_EA_XAS:\n        for (channel=0; channel<avctx->channels; channel++) {\n            int coeff[2][4], shift[4];\n            short *s2, *s = &samples[channel];\n            for (n=0; n<4; n++, s+=32*avctx->channels) {\n                for (i=0; i<2; i++)\n                    coeff[i][n] = ea_adpcm_table[(src[0]&0x0F)+4*i];\n                shift[n] = 20 - (src[2] & 0x0F);\n                for (s2=s, i=0; i<2; i++, src+=2, s2+=avctx->channels)\n                    s2[0] = (src[0]&0xF0) + (src[1]<<8);\n            }\n            for (m=2; m<32; m+=2) {\n                s = &samples[m*avctx->channels + channel];\n                for (n=0; n<4; n++, src++, s+=32*avctx->channels) {\n                    for (s2=s, i=0; i<8; i+=4, s2+=avctx->channels) {\n                        int level = sign_extend(*src >> (4 - i), 4) << shift[n];\n                        int pred  = s2[-1*avctx->channels] * coeff[0][n]\n                                  + s2[-2*avctx->channels] * coeff[1][n];\n                        s2[0] = av_clip_int16((level + pred + 0x80) >> 8);\n                    }\n                }\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_IMA_AMV:\n    case CODEC_ID_ADPCM_IMA_SMJPEG:\n        c->status[0].predictor = (int16_t)bytestream_get_le16(&src);\n        c->status[0].step_index = bytestream_get_le16(&src);\n        if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n            src+=4;\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            char hi, lo;\n            lo = *src & 0x0F;\n            hi = *src >> 4;\n            if (avctx->codec->id == CODEC_ID_ADPCM_IMA_AMV)\n                FFSWAP(char, hi, lo);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                lo, 3);\n            *samples++ = adpcm_ima_expand_nibble(&c->status[0],\n                hi, 3);\n        }\n        break;\n    case CODEC_ID_ADPCM_CT:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_ct_expand_nibble(&c->status[0 ], v >> 4  );\n            *samples++ = adpcm_ct_expand_nibble(&c->status[st], v & 0x0F);\n        }\n        break;\n    case CODEC_ID_ADPCM_SBPRO_4:\n    case CODEC_ID_ADPCM_SBPRO_3:\n    case CODEC_ID_ADPCM_SBPRO_2:\n        if (!c->status[0].step_index) {\n            /* the first byte is a raw sample */\n            *samples++ = 128 * (*src++ - 0x80);\n            if (st)\n              *samples++ = 128 * (*src++ - 0x80);\n            c->status[0].step_index = 1;\n            nb_samples--;\n        }\n        if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_4) {\n            for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] >> 4, 4, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x0F, 4, 0);\n            }\n        } else if (avctx->codec->id == CODEC_ID_ADPCM_SBPRO_3) {\n            for (n = nb_samples / 3; n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 5        , 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x07, 3, 0);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    src[0] & 0x03, 2, 0);\n            }\n        } else {\n            for (n = nb_samples >> (2 - st); n > 0; n--, src++) {\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                     src[0] >> 6        , 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    (src[0] >> 4) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[0],\n                    (src[0] >> 2) & 0x03, 2, 2);\n                *samples++ = adpcm_sbpro_expand_nibble(&c->status[st],\n                    src[0] & 0x03, 2, 2);\n            }\n        }\n        break;\n    case CODEC_ID_ADPCM_SWF:\n    {\n        GetBitContext gb;\n        const int *table;\n        int k0, signmask, nb_bits, count;\n        int size = buf_size*8;\n        init_get_bits(&gb, buf, size);\n        //read bits & initial values\n        nb_bits = get_bits(&gb, 2)+2;\n        //av_log(NULL,AV_LOG_INFO,\"nb_bits: %d\\n\", nb_bits);\n        table = swf_index_tables[nb_bits-2];\n        k0 = 1 << (nb_bits-2);\n        signmask = 1 << (nb_bits-1);\n        while (get_bits_count(&gb) <= size - 22*avctx->channels) {\n            for (i = 0; i < avctx->channels; i++) {\n                *samples++ = c->status[i].predictor = get_sbits(&gb, 16);\n                c->status[i].step_index = get_bits(&gb, 6);\n            }\n            for (count = 0; get_bits_count(&gb) <= size - nb_bits*avctx->channels && count < 4095; count++) {\n                int i;\n                for (i = 0; i < avctx->channels; i++) {\n                    // similar to IMA adpcm\n                    int delta = get_bits(&gb, nb_bits);\n                    int step = ff_adpcm_step_table[c->status[i].step_index];\n                    long vpdiff = 0; // vpdiff = (delta+0.5)*step/4\n                    int k = k0;\n                    do {\n                        if (delta & k)\n                            vpdiff += step;\n                        step >>= 1;\n                        k >>= 1;\n                    } while(k);\n                    vpdiff += step;\n                    if (delta & signmask)\n                        c->status[i].predictor -= vpdiff;\n                    else\n                        c->status[i].predictor += vpdiff;\n                    c->status[i].step_index += table[delta & (~signmask)];\n                    c->status[i].step_index = av_clip(c->status[i].step_index, 0, 88);\n                    c->status[i].predictor = av_clip_int16(c->status[i].predictor);\n                    *samples++ = c->status[i].predictor;\n                }\n            }\n        }\n        src += buf_size;\n        break;\n    }\n    case CODEC_ID_ADPCM_YAMAHA:\n        for (n = nb_samples >> (1 - st); n > 0; n--, src++) {\n            uint8_t v = *src;\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[0 ], v & 0x0F);\n            *samples++ = adpcm_yamaha_expand_nibble(&c->status[st], v >> 4  );\n        }\n        break;\n    case CODEC_ID_ADPCM_THP:\n    {\n        int table[2][16];\n        int prev[2][2];\n        int ch;\n        src += 4; // skip channel size\n        src += 4; // skip number of samples (already read)\n        for (i = 0; i < 32; i++)\n            table[0][i] = (int16_t)bytestream_get_be16(&src);\n        /* Initialize the previous sample.  */\n        for (i = 0; i < 4; i++)\n            prev[0][i] = (int16_t)bytestream_get_be16(&src);\n        for (ch = 0; ch <= st; ch++) {\n            samples = (short *)c->frame.data[0] + ch;\n            /* Read in every sample for this channel.  */\n            for (i = 0; i < nb_samples / 14; i++) {\n                int index = (*src >> 4) & 7;\n                unsigned int exp = *src++ & 15;\n                int factor1 = table[ch][index * 2];\n                int factor2 = table[ch][index * 2 + 1];\n                /* Decode 14 samples.  */\n                for (n = 0; n < 14; n++) {\n                    int32_t sampledat;\n                    if(n&1) sampledat = sign_extend(*src++, 4);\n                    else    sampledat = sign_extend(*src >> 4, 4);\n                    sampledat = ((prev[ch][0]*factor1\n                                + prev[ch][1]*factor2) >> 11) + (sampledat << exp);\n                    *samples = av_clip_int16(sampledat);\n                    prev[ch][1] = prev[ch][0];\n                    prev[ch][0] = *samples++;\n                    /* In case of stereo, skip one sample, this sample\n                       is for the other channel.  */\n                    samples += st;\n                }\n            }\n        }\n        break;\n    }\n    default:\n        return -1;\n    }\n    *got_frame_ptr   = 1;\n    *(AVFrame *)data = c->frame;\n    return src - buf;\n}", "idx": 16664, "substitutes": {"avctx": ["evcmp", "afcmp", "avecf", "avcup", "AVcmp", "AVcup", "avctrl", "afcup", "abcontext", "avekb", "afcb", "afconfig", "afsync", "evcontext", "afloc", "AVlc", " avconfig", "avsync", "verconn", "avectrl", "AVctx", " avcontext", "avcca", "afconf", "avecmp", " avqa", "navcontext", "Avctx", "navconn", "avlc", "aveqa", "navcn", "aveconn", "verconf", "akctrl", "avcb", "adcontext", "afctrl", "avalconn", "afxc", "navctx", "afqa", "adloc", "avecca", "avcmp", "afcf", "vercontext", "avconfig", "avalloc", "avalconf", "abcf", "Avcontext", "avxc", "afcca", "avalcup", "avcf", "avconf", "avalcmp", "avloc", "navlc", "akctx", "AVcontext", "avalctx", " avcca", "navxc", "adctx", " avconn", "avalcontext", "avectx", "akcb", "AVcn", "verctx", "adsync", "afcn", "aflc", "avkb", "avcn", "afcontext", "akcontext", "avconn", "afctx", "abctx", "evctx", "avalsync", "avecontext", "Avconfig", "afconn", "evkb", "abxc", "abconn", "avqa", "afkb", "Avconn", "avecb", "avcontext"], "data": ["Data", "bin", "content", "extra", "code", "reader", "base", "image", "media", "buffer", "results", "result", "window", "start", "slice", "done", "after", "head", "load", "d", "header", "to", "size", "memory", "config", "response", "length", "queue", "buff", "batch", "v", "parent", "ad", "open", "map", "da", "p", "address", "ata", "cache", "dat", "next", "body", "a", "DATA", "bytes", "message", "frame", "connection", "list", "alpha", "source", "input"], "got_frame_ptr": ["got_frame_pointer", "got_frames_ptr", "got_frame_ind", "got_frames_ind", "got_frames_pointer", "got_frame_tr", "got_frames_tr"], "avpkt": ["avlpck", "avlpkk", "abcpkt", "avcpkt", "Avpaddr", "Avspfd", "avbpkt", "avPkk", "avspkt", "avpkg", "avcsth", "avput", "avbkg", "Avpkt", "avpfd", "avbpaddr", "avlpaddr", "Avspkt", "avPck", "avbct", "abpkg", "abpkt", "avpkk", "avcpkg", "abpct", " avcacket", "avsput", "avpct", "avbkt", " avckt", "abcpkg", "abcpsth", "avcct", "avspfd", "avpck", "Avsput", " avpck", "Avspaddr", "Avpfd", "avbsth", "avlpkt", "avpacket", "Avput", "avpaddr", "avbpfd", "abcpct", "avlpfd", "avspaddr", "avckg", "avlpacket", "avbput", "abpsth", "avcpsth", " avckk", " avcck", "avpsth", "avckk", "avcck", " avpkk", "avPkt", " avpacket", "avlput", "avcacket", "avcpct", "avPacket", "avckt"], "buf": ["br", "offset", "fp", "ref", "pool", "buffer", "rc", "vec", "cf", "cb", "block", "bc", "msg", "wb", "ctx", "pb", "cas", "array", "box", "img", "queue", "bd", "fd", "buff", "batch", "fb", "tmp", "seq", "cmd", "uc", "rb", "pad", "b", "cache", "alloc", "port", "bag", "uf", "cv", "len"], "c": ["dc", "pc", "ic", "code", "t", "f", "vc", "ct", "conn", "rc", "cm", "cf", "g", "cb", "anc", "bc", "cp", "ctx", "mc", "abc", "cy", "ctrl", "ca", "enc", "l", "d", "ce", "nc", "ac", "ci", "con", "xc", "w", "config", "e", "cu", "k", "sc", "cr", "v", "lc", "cat", "cur", "p", "cache", "b", "cmp", "cit", "ec", "cd", "h", "cn", "co", "C", "cv", "cc"], "cs": ["ns", "pc", "spec", "ts", "bs", "stats", "rs", "cus", "vc", "conn", "rc", "cf", "Cs", "cb", "CS", "ls", "ces", "wcs", "bc", "ctx", "cp", "ss", "fs", "cons", "cas", "sk", "css", "acs", "cms", "nc", "cells", "ac", "args", "qs", "sc", "ics", "vs", "sync", "lc", "ps", "ks", "gs", "ec", "cn", "os", "hs", "cc", "ds"], "n": ["ns", "j", "x", "f", "net", "nt", "num", "N", "z", "nl", "nb", "l", "d", "nc", "w", "k", "v", "ni", "p", "b", "len", "nn", "u"], "m": ["mod", "mode", "f", "r", "mi", "cm", "M", "md", "mn", "g", "um", "mc", "mon", "en", "sm", "l", "d", "dm", "mid", "e", "man", "v", "p", "fm", "h", "rem", "y", "u"], "channel": ["session", "group", "shape", "mode", "core", "name", "category", "component", "rc", "ann", "cm", "type", "bc", "gui", "wan", "an", "en", "game", "range", "context", "broad", "gap", "Channel", "change", "nc", "event", "size", "ko", "chat", "course", "no", "con", "config", "queue", "sc", "open", "chron", "client", "cat", "unit", "chan", "sync", "cl", "can", "video", "p", "uc", "que", "resource", "col", "error", "consumer", "character", "second", "connection", "message", "server", "source", "cv", "version", "target"], "i": ["ti", "j", "x", "f", "ini", "ai", "mi", "ii", "di", "iu", "index", "I", "ip", "d", "pi", "ci", "k", "v", "ni", "si", "p", "b", "im", "li", "u"], "samples": ["svannels", "insamps", "sessions", "samps", "sample", "ssessions", "Samples", "svample", "Sample", "ssannels", "sannels", "dessions", "insessions", "sources", "dources", "damples", "ssamples", "insources", "svamples", "damps", "ssample", "ssources", "ssamps", "svamps", "insamples", "Samps", "Sannels"], "src": ["uri", "spec", "sup", "code", "sample", "dest", "ctr", "component", "RC", "sort", "rc", "supp", "sb", "cb", "sl", "stream", "bc", "loc", "sel", "ctx", "slice", "sec", "filename", "host", "seed", "comp", "sn", "config", "img", "sub", "sc", "bl", "sr", "sync", "chrom", "cur", "rb", "seq", "bg", "url", "video", "inst", "origin", "sq", "source", "dist"], "st": ["set", "nd", "rest", "ct", "sp", "ste", "rc", "nt", "fe", "service", "str", "sb", "ost", "sw", "stream", "ss", "sec", "ST", "ind", "sta", " rest", "store", "d", "std", "step", "nc", "stack", "sn", "start", "sc", "sth", "sync", "si", "stage", "sts", "St", "inst", "u"], "count1": ["sum01", "sum1", "sumone", "code1", "sum2", "code2", "count01", " countone", " count01", "code01", "countone", "codeone"], "count2": ["max2", "max1", "code0", "code1", "code2", "max0", " count0", "count0"], "nb_samples": ["nb\u00b7sympaces", "nb_setsamps", "nb_dources", "nb_isamps", "nb_sample", "nb_ssums", "nb_pums", "nb_scims", "nb_symamples", "nb_sidalls", "nb_sympaces", "nb_servicesocks", "nb_asamps", "nb_Sample", "nb_ssones", "nb_nources", "nb_sessions", "nb_saves", "nb_Sims", "nb_timesamples", "nb_Samps", "nb_symacks", "nb_siblings", "nb\u00b7symores", "nb_dones", "nb_sims", "nb_sources", "nb_shims", "nb_psaves", "nb_setsiblings", "nb_sidamples", "nb_Sessions", "nb_salls", "nb_timesamps", "nb_shamps", "nb_isources", "nb_asaves", "nb_sones", "nb_ssocks", "nb_timesores", "nb_scamps", "nb\u00b7samples", "nb_Siblings", "nb_psamps", "nb_Samples", "nb_psample", "nb_timesacks", "nb_ssalls", "nb_samps", "nb_isamples", "nb_asample", "nb_eventsizes", "nb_sizes", "nb_isizes", "nb_Sones", "nb_timespaces", "nb_Sases", "nb_damples", "nb_namples", "nb_sacks", "nb_setsamples", "nb_eventsocks", "nb_servicesacks", "nb_sums", "nb_psamples", "nb_ssources", "nb\u00b7spaces", "nb_servicesamps", "nb_pamples", "nb_socks", "nb_ssamples", "nb_damps", "nb_servicesores", "nb_Sources", "nb_servicesamples", "nb_servicesizes", "nb_sases", "nb_ssizes", "nb_sidums", "nb_pamps", "nb_setsessions", "nb_shamples", "nb_nizes", "nb_namps", "nb_timesessions", "nb\u00b7symamples", "nb_ssamps", "nb_timesiblings", "nb_scases", "nb_eventsamps", "nb_palls", "nb_sidamps", "nb_symores", "nb_servicespaces", "nb\u00b7symacks", "nb_spaces", "nb_asamples", "nb\u00b7sores", "nb_sores", "nb_Saves", "nb_shases", "nb_scamples", "nb_eventsamples", "nb\u00b7sacks"], "coded_samples": ["coded_insamps", "coded_suamples", "coded_tources", "coded_pamples", "coded_insockets", "coded_summies", "coded_sources", "coded_pamps", "coded_sumodels", "coded_pills", "coded_Samps", "coded_sockets", "coded_salls", "coded_tamples", "coded_pockets", "coded_pmodels", "coded_suills", "coded_asources", "coded_suamps", "coded_syamps", "coded_sualls", "coded_asamples", "coded_ssample", "coded_syents", "coded_bills", "coded_sents", "coded_exources", "coded_exents", "coded_ssamples", "coded_ssockets", "coded_syamples", "coded_Salls", "coded_ssamps", "coded_syources", "coded_bamps", "coded_sample", "coded_Samples", "coded_Smodels", "coded_balls", "coded_smodels", "coded_examps", "coded_sills", "coded_tents", "coded_insamples", "coded_pample", "coded_asamps", "coded_samps", "coded_examples", "coded_insample", "coded_asummies", "coded_tummies", "coded_bamples", "coded_Sills", "coded_tamps"], "ret": ["status", "rs", "info", "obj", "err", "ref", "alt", "buffer", "reg", "r", "lit", "nt", "fun", "rt", "result", "match", "ext", "fin", "rf", "mem", "resp", "rets", "def", "en", "arr", "att", "val", "rec", "re", "nil", "Ret", "empty", "bf", "last", "utf", "det", "rev", "v", "cur", "RET", "error", "rep", "res", "pet", "mt", "rem", "reply", "success", "len"], "predictor": ["tpredictar", "ppredors", "ppredutor", "pvalidable", "predictutor", "pvalidutor", " predictored", "ppredored", "predictable", " pvictors", "procpreditor", "pributier", "predictors", " pveyor", "ppreditor", "pcriptutor", "pveyor", "pvictable", "pveyior", "procpredor", "pesture", "ptestation", " pvictable", "pripttor", "procpredutor", "pvalidor", "procredictable", "priptation", "predictitor", "pributer", "psributors", "psredicttor", "psriptitor", "pcriptable", "psredictier", " predictors", "predicter", "predicttor", "ptestitor", "psripttor", "priptor", "psredictors", "procredictutor", " predictior", "predictior", "psriptation", "predictation", "psredictation", "ptesttor", "pestar", "pestor", "ptestor", "pributitor", " pvictored", "ppredable", "tppecture", "ppredor", "priptitor", "predicture", "tpredictors", "pacherer", "pacherier", "predictored", "tpredicture", "tppectar", " pvictor", " predictutor", "tppector", "tppectors", "pacheror", "ppectar", "ppecture", "pcriptitor", "psributor", "predictar", "pveyutor", "psredictitor", "pvaliditor", "pcriptor", " pveyior", "pributor", " pveyors", "ppectors", "ppector", "pvictors", "pvictored", "procpredable", "pvictor", "pributation", "predictier", "pacherors", "psributier", "procredictor", "pributors", "tpredictor", "procredictitor", " predictable", "psriptor", "pveyors", "psredictor", "pestors", " pveyutor", "psredicter", "psributer", "pributtor"], "step_index": ["group_info", " step_length", "stepblockaddress", "step_offset", "stepoutindex", "step2num", "stepxaction", "step__value", "stepoutoffset", "group_address", "stepxindex", "stepxcount", "step___action", "step_num", "stepoutaddress", "groupxinfo", "group_count", "step_id", "step___align", "groupxaction", "step__index", "groupxcount", "step_action", "stepblockoffset", "step___count", "stepxinfo", "step___info", "group_index", "step__num", " step_align", "step_align", "step___index", "stepoutposition", "step2length", "step2index", "step_info", "step__length", "group_offset", "groupxindex", "stepblockindex", "step_address", "step_value", "step_length", " step_value", "stepblockposition", "step2value", "step_position", "step_count", "group_action", "step___id", " step_id", " step_num", "group_position"]}}
{"project": "qemu", "commit_id": "a38648290ee277c7cb8a53eabdcdb08bb7a9f23f", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666, "substitutes": {"req": ["require", "spec", "grad", "grab", "user", "ref", "inc", "str", "cf", "sec", "release", "exec", "rec", "comp", "tar", "pri", "config", "qt", "test", "resource", "next", "res", "circ", "gr", "conn", "reader", "rx", "rs", "ctr", "hr", "hop", "dq", "query", "app", "sem", "rf", "resp", "load", "fer", "flow", "queue", "pr", "ec", "desc", "download", "ver", "transfer", "org", "required", "fr", "view", "err", "call", "jp", "f", "r", "rt", "worker", "task", "rh", "this", "need", "crit", "iq", "sr", "q", "serv", "qa", "check", "priv", "er", "pro", "sq", "progress", "per", "rr", "request", "data", "tr", "reg", "loader", "module", "ctx", "ext", "low", "pkg", "com", "pull", "client", "cur", "seq", "cmd", "once", "cache", "http", "requ", "wa", "proc", "server"], "i": ["ti", "gi", "uri", "ei", "bi", "j", "ik", "code", "ji", "s", "info", "x", "f", "base", "t", "ix", "ini", "qi", "ai", "io", "n", "phi", "mi", "hi", "z", "ii", "ie", "di", "index", "ind", "iu", "I", "mini", "multi", "zi", "ip", "l", "d", "oi", "pi", "ui", "ci", "id", "k", "e", "v", "c", "ni", "si", "ri", "p", "xi", "mu", "eni", "fi", "y", "li", "u"], "sign": ["set", "spec", "scale", "shape", "shadow", "x", "name", "call", "err", "push", "sp", "kick", "plus", "code", "ai", "n", "inc", "feed", "wait", "pack", "align", "script", "type", "SIGN", "in", "pass", "sem", "Sign", "ind", "pos", "min", "act", "enc", "sk", "load", "ign", "d", "close", "change", "parse", "sh", "draw", "w", "length", "id", "pull", "sc", "send", "fix", "shift", "sum", "dig", "check", "weight", "save", "se", "pay", "scan", "connect"], "tmp": ["pty", "obj", "nt", "result", "ie", "ptr", "zip", "po", "stuff", "buff", "temp", "tv", "p", "vt", "test", "pad", "mp", "output", "beta", "part", "tt", "sup", "txt", "j", "ff", "acc", "app", "cp", "resp", "tab", "v", "gz", "null", "kk", "amp", "fp", "f", "sb", "wb", "mmm", "appy", "page", "buf", "fb", "emp", "b", "ppa", "py", "np", "db", "t", "data", "sp", "nm", "pp", "tc", "img", "st", "map", "rb", "cache", "cmp", "tf", "proc", "api", "diff", "attr"]}}
{"project": "FFmpeg", "commit_id": "fc49f22c3b735db5aaac5f98e40b7124a2be13b8", "target": 1, "func": "static char *choose_pixel_fmts(OutputStream *ost)\n\n{\n\n    if (ost->keep_pix_fmt) {\n\n        if (ost->filter)\n\n            avfilter_graph_set_auto_convert(ost->filter->graph->graph,\n\n                                            AVFILTER_AUTO_CONVERT_NONE);\n\n        if (ost->st->codec->pix_fmt == PIX_FMT_NONE)\n\n            return NULL;\n\n        ost->pix_fmts[0] = ost->st->codec->pix_fmt;\n\n        return ost->pix_fmts;\n\n    }\n\n    if (ost->st->codec->pix_fmt != PIX_FMT_NONE) {\n\n        return av_strdup(av_get_pix_fmt_name(choose_pixel_fmt(ost->st, ost->enc, ost->st->codec->pix_fmt)));\n\n    } else if (ost->enc->pix_fmts) {\n\n        const enum PixelFormat *p;\n\n        AVIOContext *s = NULL;\n\n        uint8_t *ret;\n\n        int len;\n\n\n\n        if (avio_open_dyn_buf(&s) < 0)\n\n            exit_program(1);\n\n\n\n        p = ost->enc->pix_fmts;\n\n        if (ost->st->codec->strict_std_compliance <= FF_COMPLIANCE_UNOFFICIAL) {\n\n            if (ost->st->codec->codec_id == CODEC_ID_MJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUV420P, PIX_FMT_YUV422P, PIX_FMT_NONE };\n\n            } else if (ost->st->codec->codec_id == CODEC_ID_LJPEG) {\n\n                p = (const enum PixelFormat[]) { PIX_FMT_YUVJ420P, PIX_FMT_YUVJ422P, PIX_FMT_YUVJ444P, PIX_FMT_YUV420P,\n\n                                                    PIX_FMT_YUV422P, PIX_FMT_YUV444P, PIX_FMT_BGRA, PIX_FMT_NONE };\n\n            }\n\n        }\n\n\n\n        for (; *p != PIX_FMT_NONE; p++)\n\n            avio_printf(s, \"%s:\", av_get_pix_fmt_name(*p));\n\n        len = avio_close_dyn_buf(s, &ret);\n\n        ret[len - 1] = 0;\n\n        return ret;\n\n    } else\n\n        return NULL;\n\n}\n", "idx": 16693, "substitutes": {"ost": ["oc", "ist", "dd", "rost", "ob", "op", "pod", "nt", "gg", "ut", "ST", "iol", "design", "ont", "irst", "osta", "od", "boot", "opt", "word", "est", "tt", "rest", "ot", "hop", "ocr", "ld", "object", "o", "art", "tto", "rob", "obs", "rot", "ober", "OST", "oy", "et", "ood", "ft", "org", "oh", "mot", "src", "oper", "node", "hyd", "sta", "oop", "host", "ott", "oid", "ad", "post", "rss", "ust", "ogg", "ud", "orb", "inst", "\u00f3", " nost", "boost", "oss", "rog", "ort", "ord", "feed", "ast", "ods", "rod", "otype", "roc", "old", "add", "st", "lov", "osc", "http", "os", "oster", "server", "sty"], "p": ["pc", "per", "wp", "m", "t", "fp", "x", "f", "jp", "sp", "pn", "vp", "r", "pe", "n", "i", "bp", "cp", "lp", "pb", "o", "l", "d", "pp", "pi", "q", "pa", "e", "v", "c", "ps", "mp", "b", "pr", "h", "tp", "py", "port", "np", "pt", "P", "u"], "s": ["ns", "spec", "m", "ts", "sg", "session", "f", "settings", "services", "r", "n", "g", "i", "sb", "ss", "ctx", "o", "cs", "socket", "w", "e", "ssl", "ses", "v", "c", "ps", "si", "S", "b", "gs", "sys", "sq", "ds", "u"], "ret": ["code", "rs", "data", "al", "sp", "buffer", "nt", "r", "result", "num", "mem", "resp", "out", "att", "val", "re", "Ret", "back", "q", "seq", "RET", "res", "proc", "opt", "Len"], "len": ["per", "bin", " n", "net", "lit", "nt", "fun", "fin", "pos", "mem", " l", "en", "count", "resp", " el", "L", "lf", "ln", "val", "size", "length", " length", "rev", "seq", " clen", "Len"]}}
{"project": "FFmpeg", "commit_id": "5e2202d6f3ac2f3afd714a62437ca6b24f75c09f", "target": 1, "func": "static void mov_metadata_creation_time(AVMetadata **metadata, time_t time)\n\n{\n\n    char buffer[32];\n\n    if (time) {\n\n        time -= 2082844800;  /* seconds between 1904-01-01 and Epoch */\n\n        strftime(buffer, sizeof(buffer), \"%Y-%m-%d %H:%M:%S\", gmtime(&time));\n\n        av_metadata_set2(metadata, \"creation_time\", buffer, 0);\n\n    }\n\n}\n", "idx": 16700, "substitutes": {"metadata": ["uri", "m", "archive", "ami", "data", "info", "name", "attribute", "shadow", "media", "component", "service", "md", "document", "module", "communication", "package", "node", "source", "manager", "username", "parser", "definition", "database", "header", "summary", "adata", "memory", "ui", "handler", "meta", "tm", "binary", "cache", "timer", "storage", "wrapper", "message", "attr", "mo"], "time": ["ime", "m", "tim", "content", "hour", "code", "data", "info", "name", "image", "call", "comment", "t", "x", "user", "mi", "duration", "money", "times", "window", "year", "block", "method", "type", "am", "TIME", "timeout", "self", "date", "count", " Time", "home", "space", "cost", " times", "event", "size", "tc", "length", "delay", "c", "url", "frequency", "depth", "cache", "now", "rate", "timer", "clock", "h", "etime", "message", "im", "port", "Time", "value", "runtime", "sleep"], "buffer": ["Buffer", "offset", "code", "data", "text", "base", "image", "token", "thread", "duration", "feed", "result", "window", "document", "block", "cb", "reference", "raw", "bb", "timeout", "byte", "exec", "context", "bar", "header", "array", "event", "stack", "memory", "queue", "length", "wave", "delay", "buff", "buf", "handler", "batch", "temp", "variable", "binary", "url", "pad", "table", "cache", "append", "resource", "message", "iter", "server", "writer", "source", "transfer", "reader"]}}
{"project": "qemu", "commit_id": "6982d6647ea98544f76d5ef40ddc23115ff44a77", "target": 1, "func": "static uint32_t hpet_ram_readl(void *opaque, target_phys_addr_t addr)\n\n{\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            printf(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                return timer->config;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                return timer->config >> 32;\n\n            case HPET_TN_CMP: // comparator register\n\n                return timer->cmp;\n\n            case HPET_TN_CMP + 4:\n\n                return timer->cmp >> 32;\n\n            case HPET_TN_ROUTE:\n\n                return timer->fsb >> 32;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return s->capability;\n\n            case HPET_PERIOD:\n\n                return s->capability >> 32;\n\n            case HPET_CFG:\n\n                return s->config;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl \\n\");\n\n                return 0;\n\n            case HPET_COUNTER:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick;\n\n            case HPET_COUNTER + 4:\n\n                if (hpet_enabled())\n\n                    cur_tick = hpet_get_ticks();\n\n                else\n\n                    cur_tick = s->hpet_counter;\n\n                DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n                return cur_tick >> 32;\n\n            case HPET_STATUS:\n\n                return s->isr;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n                break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16708, "substitutes": {"opaque": ["octaque", " opacity", "opac", "opec", "operec", "opacity", " opac", " opacle", "operaque", "octacle", "opsaques", "opsac", "opsec", " opec", "OPaque", "OPacity", "operac", "opaques", "opsaque", "operaques", "OPacle", " opaques", "opacle", "octacity"], "addr": ["rx", "offset", "extra", "data", "x", "base", "ref", "alt", "ix", "tick", "r", "ord", "md", "rt", "coord", "align", "hop", "rc", "arm", "src", "node", "localhost", "player", "ctx", "ext", "ptr", "pos", "slice", "dim", "pointer", "arity", "sta", "np", "host", "fx", "slot", "nr", "tx", "add", "config", "ad", "start", "dr", "prefix", "asm", "id", "mid", "seq", "p", "url", "address", "pad", "inter", "cmp", "adr", "clock", "ace", "amd", "oster", "mac", "end", "order", "conn", "amp", "len"], "s": ["ns", "words", "settings", "irs", "service", "ions", "sie", "ers", "ss", "als", "cs", "d", "ims", "qs", "ments", "sym", "p", "ks", "sets", "m", "ts", "sg", "rs", "aws", "times", "in", "scope", "self", "o", "ing", "v", "si", "S", "ings", "ds", "bs", "f", "r", "results", "sb", "or", "l", "ins", "sers", "w", "sync", "c", "secondary", "b", "er", "es", "states", "sq", "ies", "sf", "session", "stats", "t", "rates", "services", "n", "g", "i", "sl", "ls", "ops", "xs", "is", "ed", "args", "e", "ssl", "ses", "js", "gs", "its", "os", "south", "y"], "cur_tick": ["curJick", "Cur_ick", "Cur_rx", "ser_spin", "curxbug", "Cur_icks", " cur_clock", "curxspin", " cur_trial", "curJbug", "cur_bug", " cur_ick", " cur_bug", " cur_butt", "cur_time", "curRtrial", " cur_exc", "curJclock", "cur_trial", "curamtick", "cur_nice", "cur_tz", "curRtick", "cur_tip", " cur_nick", "ser_ick", "cur_spin", "curamtime", "Cur_tick", "curxtick", "ser_bug", "Cur_tz", "cur_token", "curxnice", "curJtick", " cur_hop", "curRnick", "Cur_time", "cur_cookie", "curamrx", "curRick", "cur_kick", "cur_ick", "cur_butt", "Cur_tip", "cur_clock", " cur_nice", " cur_kick", " cur_token", "cur_exc", "cur_nick", "cur_hop", " cur_cookie", "curamicks", "curxexc", "cur_rx", "ser_tick", "curJkick", "cur_icks", "curxick"], "index": ["part", "point", "offset", "loop", "code", "x", "search", "name", "ix", "bridge", "inc", "align", "hop", "num", "i", "type", "match", "loc", "node", "ind", "slice", "Index", "dim", "pos", "active", "pointer", "host", "axis", "xxxx", "diff", "socket", "height", "length", "id", "key", "prefix", "xxx", "position", "si", "fff", "address", "test", "route", "ace", "len", "weight", "find", "connection", "nn", "number", "alpha", "value", "conn", "amp", "input"], "timer": ["term", "m", "tim", "time", "tr", "ipper", "runner", "buffer", "ester", "service", "duration", "counter", "trace", "worker", "loader", "imer", "roller", "icer", "match", "task", "trial", "player", "sim", "timeout", "watch", "manager", "cer", "ger", "parser", "ter", "header", "later", "event", "size", "mr", "tc", "browser", "delay", "handler", "meter", "Timer", "driver", "monitor", "clock", "er", "peer", "message", "iter", "trigger", "server", "writer", "inner", "tm", "amer", "reader"]}}
{"project": "qemu", "commit_id": "bd8b92d5c8387c2c94f06665514c05000169fafd", "target": 1, "func": "void usb_claim_port(USBDevice *dev, Error **errp)\n\n{\n\n    USBBus *bus = usb_bus_from_device(dev);\n\n    USBPort *port;\n\n\n\n    assert(dev->port == NULL);\n\n\n\n    if (dev->port_path) {\n\n        QTAILQ_FOREACH(port, &bus->free, next) {\n\n            if (strcmp(port->path, dev->port_path) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (port == NULL) {\n\n            error_setg(errp, \"usb port %s (bus %s) not found (in use?)\",\n\n                       dev->port_path, bus->qbus.name);\n\n            return;\n\n        }\n\n    } else {\n\n        if (bus->nfree == 1 && strcmp(object_get_typename(OBJECT(dev)), \"usb-hub\") != 0) {\n\n            /* Create a new hub and chain it on */\n\n            usb_create_simple(bus, \"usb-hub\");\n\n        }\n\n        if (bus->nfree == 0) {\n\n            error_setg(errp, \"tried to attach usb device %s to a bus \"\n\n                       \"with no free ports\", dev->product_desc);\n\n            return;\n\n        }\n\n        port = QTAILQ_FIRST(&bus->free);\n\n    }\n\n    trace_usb_port_claim(bus->busnr, port->path);\n\n\n\n    QTAILQ_REMOVE(&bus->free, port, next);\n\n    bus->nfree--;\n\n\n\n    dev->port = port;\n\n    port->dev = dev;\n\n\n\n    QTAILQ_INSERT_TAIL(&bus->used, port, next);\n\n    bus->nused++;\n\n}\n", "idx": 16717, "substitutes": {"dev": ["dd", "user", "child", "obj", " def", "comment", "ref", "md", "gu", "debug", "pack", "var", "pos", "d", "new", "ev", "temp", "lib", "p", "test", "pad", "od", "next", "serial", "end", "valid", "die", "ve", "conn", "Dev", "mod", "pub", "name", "de", "rad", "app", "der", "self", "development", "sk", "adv", "flow", "v", "dom", "plug", "iv", "ver", "ds", "block", "root", "di", "prom", "sd", "home", "host", "w", "ad", " device", "serv", "private", "device", "priv", "dem", "pro", "bug", "prov", "data", "info", "conf", "def", "av", "cam", "client", "driver", "error", "api", "pu", "diff", "dist"], "errp": ["errsp", " errP", "ierpr", " errpa", "krpc", "krsp", "errP", "iersp", "errpr", "errpc", "krpr", "erps", "lrp", "nerps", "cerpa", "krpa", "cersp", "erp", "ierp", "lrpc", "krps", "nerp", "errpa", "lrpa", "cerpr", "krp", "errps", "lrps", "erP", " errps", " errpc", "ierpa", "cerp", "nerP"], "bus": ["bi", "obj", "bit", "comment", "usb", "service", "pl", "pack", "hub", "pos", "lo", "config", "id", "lib", "p", "gen", "boot", "serial", "loop", "us", "die", "miss", "lab", "board", "plugin", "bin", "bridge", "bc", "self", "class", "su", "kit", "cat", "plug", "product", "ash", "band", "bs", "view", "base", "f", "Bus", "block", "cb", "root", "ass", "home", "host", "l", "back", "bis", "sync", "device", "c", "lock", "BUS", "b", "ban", "bug", "session", "data", "io", "feed", "pass", "def", "is", "bo", "build", "use", "mount", "front", "driver", "cache", "http", "proc", "local", "os", "pu", "se"], "port": ["point", "child", "user", "comment", "op", "pod", "ports", "service", "report", "machine", "package", "pos", "contract", "select", "path", "import", "config", "id", "slave", "p", "test", "next", " sport", "interface", "end", "pt", "target", "pc", "plugin", "m", "fat", "name", "rest", "hop", "app", "cp", "self", "object", "PORT", "key", "v", "parent", "patch", "export", "iv", "connection", "ver", "native", "text", "component", "proxy", "type", "match", "function", "nat", "host", "device", "post", "position", "address", "Port", "allow", "project", "state", "version", "bug", "per", "pid", "data", "ort", "pool", "option", "module", "month", "pass", "tag", "ip", "prop", "use", "mount", "client", "driver", "form", "number", "api", "server"], "nfree": ["Navailable", "cfree", "lcomplete", "Ncomplete", "lused", "ncvalid", " nrelease", "Nvalid", "Nrelease", "Nused", "nvalid", "ncomplete", " navailable", " nvalid", "cavailable", "ncfree", " ncomplete", "Nfree", "nrelease", "navailable", "cused", "cvalid", "lvalid", "lfree", "ncrelease", "lavailable"], "nused": ["cfree", "navailable", "nuse", "pavailable", "cused", "cuse", " nuse", "cavailable", " navailable", "pused", "pfree", "puse"]}}
{"project": "qemu", "commit_id": "d6085e3ace20bc9b0fa625d8d79b22668710e217", "target": 0, "func": "static void vmxnet3_update_features(VMXNET3State *s)\n\n{\n\n    uint32_t guest_features;\n\n    int rxcso_supported;\n\n\n\n    guest_features = VMXNET3_READ_DRV_SHARED32(s->drv_shmem,\n\n                                               devRead.misc.uptFeatures);\n\n\n\n    rxcso_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXCSUM);\n\n    s->rx_vlan_stripping = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_RXVLAN);\n\n    s->lro_supported = VMXNET_FLAG_IS_SET(guest_features, UPT1_F_LRO);\n\n\n\n    VMW_CFPRN(\"Features configuration: LRO: %d, RXCSUM: %d, VLANSTRIP: %d\",\n\n              s->lro_supported, rxcso_supported,\n\n              s->rx_vlan_stripping);\n\n    if (s->peer_has_vhdr) {\n\n        qemu_peer_set_offload(qemu_get_queue(s->nic),\n\n                        rxcso_supported,\n\n                        s->lro_supported,\n\n                        s->lro_supported,\n\n                        0,\n\n                        0);\n\n    }\n\n}\n", "idx": 16723, "substitutes": {"s": ["ns", "spec", "full", "settings", "options", "service", "details", "ss", "cs", "d", "new", "ims", "qs", "sym", "p", "ks", "us", "sets", "m", "ts", "sg", "rs", "aws", "self", "o", "su", "si", "S", "ds", "native", "status", "uns", "f", "sb", "sports", "l", "ins", "serv", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "state", "states", "sq", "params", "session", "stats", "t", "conf", "services", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "storage", "its", "os", "server", "u"], "guest_features": ["guest_feat", "guestingfeatures", "guesting_features", "guesting_products", "guesting_events", "guest_words", "guestingresults", "guess_needs", "guester_features", "guest_classes", "guist_features", "guist_faces", "guest_products", "guest_needs", "guestingfeat", "guest_results", "guestingproducts", "guestingfeature", "guestingflows", "guist_words", "guestingevents", "guest_plugins", "guest_events", "guest_feature", "guist_facts", "guest_facts", "guested_flows", "guester_plugins", "guest_flows", "guested_features", "guester_classes", "guesting_feature", "guested_results", "guess_events", "guest_faces", "guess_features", "guested_feat", "guester_feature"], "rxcso_supported": ["rxcfo_supported", "rxcco_supported", "rxcsoxsupport", "rxclo_support", "rxcso_disabled", "rxcsoxsupported", "rxcco_support", "rxcco_successful", "rxcfo_support", "rxcfo_successful", "rxcsoxsuccessful", "rxcso_support", "rxcfo_protected", "rxcso_successful", "rxcsoxdisabled", "rxclo_successful", "rxclo_supported", "rxcso_published", "rxcco_published", "rxcso_protected", "rxclo_protected"]}}
{"project": "qemu", "commit_id": "f8b6cc0070aab8b75bd082582c829be1353f395f", "target": 0, "func": "static int virtio_blk_exit_pci(PCIDevice *pci_dev)\n\n{\n\n    VirtIOPCIProxy *proxy = DO_UPCAST(VirtIOPCIProxy, pci_dev, pci_dev);\n\n\n\n    blockdev_mark_auto_del(proxy->block.dinfo->bdrv);\n\n    return virtio_exit_pci(pci_dev);\n\n}\n", "idx": 16724, "substitutes": {"pci_dev": ["pki_private", "pci2ev", "pciamprivate", "pki_rad", "pci_ev", "pci__dev", "pci_ver", "pci2device", "pci_rad", "pciamdevice", "pki_ev", "pki_ver", "pci__device", "pki_dev", "pci2dev", "pki_device", "pci__rad", "pci_private", "pciamdev", "pci_device"], "proxy": ["pc", "Proxy", "instance", "super", " proxies", "pid", "child", "core", "base", "ref", "pool", "buffer", "clone", "rc", "service", "io", "bridge", "library", "block", "root", "phy", "web", "copy", "ip", "ca", "gp", "pse", "config", "pipe", "cop", "buf", "client", "sync", "parent", "slave", "driver", "cache", "proc", "wrapper", "connection", "port", "server", "bus"]}}
{"project": "FFmpeg", "commit_id": "7cf22c79706d23d40d16cee37eb32d5797adcc2c", "target": 0, "func": "yuv2rgba64_full_1_c_template(SwsContext *c, const int32_t *buf0,\n\n                       const int32_t *ubuf[2], const int32_t *vbuf[2],\n\n                       const int32_t *abuf0, uint16_t *dest, int dstW,\n\n                       int uvalpha, int y, enum AVPixelFormat target, int hasAlpha, int eightbytes)\n\n{\n\n    const int32_t *ubuf0 = ubuf[0], *vbuf0 = vbuf[0];\n\n    int i;\n\n    int A = 0xffff<<14;\n\n\n\n    if (uvalpha < 2048) {\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]) >> 2;\n\n            int U  = (ubuf0[i] + (-128 << 11)) >> 2;\n\n            int V  = (vbuf0[i] + (-128 << 11)) >> 2;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    } else {\n\n        const int32_t *ubuf1 = ubuf[1], *vbuf1 = vbuf[1];\n\n        int A = 0xffff<<14;\n\n        for (i = 0; i < dstW; i++) {\n\n            int Y  = (buf0[i]    ) >> 2;\n\n            int U  = (ubuf0[i] + ubuf1[i] + (-128 << 12)) >> 3;\n\n            int V  = (vbuf0[i] + vbuf1[i] + (-128 << 12)) >> 3;\n\n            int R, G, B;\n\n\n\n            Y -= c->yuv2rgb_y_offset;\n\n            Y *= c->yuv2rgb_y_coeff;\n\n            Y += 1 << 13;\n\n\n\n            if (hasAlpha) {\n\n                A = abuf0[i] << 11;\n\n\n\n                A += 1 << 13;\n\n            }\n\n\n\n            R = V * c->yuv2rgb_v2r_coeff;\n\n            G = V * c->yuv2rgb_v2g_coeff + U * c->yuv2rgb_u2g_coeff;\n\n            B =                            U * c->yuv2rgb_u2b_coeff;\n\n\n\n            output_pixel(&dest[0], av_clip_uintp2(R_B + Y, 30) >> 14);\n\n            output_pixel(&dest[1], av_clip_uintp2(  G + Y, 30) >> 14);\n\n            output_pixel(&dest[2], av_clip_uintp2(B_R + Y, 30) >> 14);\n\n            if (eightbytes) {\n\n                output_pixel(&dest[3], av_clip_uintp2(A, 30) >> 14);\n\n                dest += 4;\n\n            } else {\n\n                dest += 3;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16727, "substitutes": {"ubuf0": ["ubbuff8", "ubbuf1", "abbuf1", "abbuf2", "ubbuf8", "ubbuff2", "ubuf2", "ubuf3", "ubuf00", "ubbuf0", "ubf1", "ubbuff0", "abuf1", "ubbuff3", "ubbuf2", "ubimg3", "abbuf8", "abuf0", "ubuf8", "abbuf0", "abuf00", "ubf0", "abuf2", "abbuf00", "ubf8", "abbuf3", "ubimg0", "ubimg1", "ubbuff00", "ubf2", "abuf8", "ubbuf3", "ubimg00", "abuf3", "ubbuf00", "ubbuff1"], "vbuf0": ["fbuf1", "vbcee", "vbc2", "fbuff1", "vbc1", "vbuffer2", "vuf2", "vbuffk", "vbuff2", "vbufk", "fbuf2", "fbuff0", "fbufee", "vbuf2", " vbuffer2", "fbuf0", "vufee", " vbuf2", "vufk", "vbuffer1", "vuf0", " vbuffer0", "vbuff1", " vbufk", "fbuffee", "fbuff2", "vbuffee", " vbufferk", "vbuff0", "vbufferk", " vbuffer1", "vbc0", "vuf1", "vbufee", "vbuffer0"], "i": ["ti", "uri", "gi", "m", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "ii", "ie", "iu", "di", "index", "slice", "I", "multi", "zi", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "abi", "w", "id", "e", "k", "v", "c", "ni", "si", "ri", "xi", "p", "b", "mu", "it", "eni", "my", "fi", "inner", "source", "y", "li", "u"], "R": ["E", "V", "RO", "GR", "RC", "r", "RP", "M", "RH", "A", "N", "Q", "I", "L", "RR", "Y", "U", "RS", "RA", "W", "Rh", "X", "SR", "DR", "D", "Rs", "O", "UR", "C", "H", "P", "Ra"], "G": ["E", "GD", "GN", "GC", "PG", "V", "GB", "GM", "GV", "GR", "GW", "M", "GA", "N", "g", "A", "SG", "Q", "GH", "I", "L", "Y", "U", "W", "Ge", "MG", "J", "X", "F", "D", "GE", "S", "Group", "O", "GP", "GF", "LG", "Gr", "C", "Gu", "H", "P", "GG"], "B": ["E", "V", "GB", "BO", "BF", "MB", "M", "A", "Q", "BY", "I", "Bo", "L", "Y", "U", "Bs", "BC", "NB", "W", "IB", "BI", "BG", "J", "F", "D", "WB", "BL", "DB", "b", "O", "H", "BE", "AB", "CB", "C", "BA", "P"], "ubuf1": ["ubbufp", "abbufp", "ubbuf1", "abbuf1", "ubimgp", "ubbuffp", "ubbuf0", "ubbuff0", "abuf1", "abuf0", "abbuf0", "abufp", "abbufs", "abufs", "ubufs", "ubimg0", "ubimg1", "ubimgs", "ubbufs", "ubufp", "ubbuffs", "ubbuff1"]}}
{"project": "qemu", "commit_id": "8e65b7c04965c8355e4ce43211582b6b83054e3d", "target": 0, "func": "static void uhci_async_complete(USBPacket *packet, void *opaque)\n\n{\n\n    UHCIState *s = opaque;\n\n    UHCIAsync *async = (UHCIAsync *) packet;\n\n\n\n    DPRINTF(\"uhci: async complete. td 0x%x token 0x%x\\n\", async->td, async->token);\n\n\n\n    async->done = 1;\n\n\n\n    uhci_process_frame(s);\n\n}\n", "idx": 16728, "substitutes": {"packet": ["ppet", "packel", "aset", "packsinet", "payet", "encet", "asacket", "packsacket", "ackacket", "encacket", "ackel", "packetter", "packhole", "encel", "ppinet", "payel", "ppetter", "payacket", "ppacket", "enchole", "packinet", "acket", "asinet", "packset", "payhole", "ackhole", "asetter", "packacket", "packsetter"], "opaque": ["openque", " opque", "oponymous", "openaque", "copaque", " opacity", "iopque", "compaque", "openicit", "opacity", "iopaque", "operaque", "ioponymous", "compque", "coponymous", "openacity", "operque", "operonymous", "copque", "compicit", "opicit", "compacity", "opque", " opicit"], "s": ["ns", "spec", "m", "sg", "stats", "f", "settings", "services", "service", "n", "sb", "g", "sw", "sl", "ss", "ops", "fs", "o", "submit", "args", "socket", "e", "ssl", "ses", "c", "slave", "sym", "p", "secondary", "S", "b", "sys", "os", "server", "states", "sq", "south", "params", "sf"], "async": ["assynchronous", "rasync", "nasynchronous", "nasync", " asynchronous", "acync", "Asynchron", " asyn", "rassync", "asynchron", " asynchron", "nasyn", "asyn", "assAsync", "acynchronous", "acsync", "Asyn", "asAsync", "Async", "asynchronous", "rasyn", "assync", "asssync", "rasynchronous", "assyn", "acyn", "rasAsync", "Asynchronous", " assync", " asAsync", "nasynchron"]}}
{"project": "qemu", "commit_id": "02acedf93da420713a0c4bbeaf32ce9d734a4332", "target": 0, "func": "static void gen_neon_unzip(int reg, int q, int tmp, int size)\n\n{\n\n    int n;\n\n    TCGv t0, t1;\n\n\n\n    for (n = 0; n < q + 1; n += 2) {\n\n        t0 = neon_load_reg(reg, n);\n\n        t1 = neon_load_reg(reg, n + 1);\n\n        switch (size) {\n\n        case 0: gen_neon_unzip_u8(t0, t1); break;\n\n        case 1: gen_neon_zip_u16(t0, t1); break; /* zip and unzip are the same.  */\n\n        case 2: /* no-op */; break;\n\n        default: abort();\n\n        }\n\n        neon_store_scratch(tmp + n, t0);\n\n        neon_store_scratch(tmp + n + 1, t1);\n\n    }\n\n}\n", "idx": 16735, "substitutes": {"reg": ["m", "pattern", "bin", "mod", "data", "Reg", "rc", "r", "debug", "num", "g", "region", "loc", "orig", "greg", "rg", "ind", "mem", "min", "tag", "arr", "xp", "rec", "re", "gr", "pre", "memory", "rar", "ru", "config", "map", "req", "c", "p", "cache", "REG", "rem", "np", "order", "dist", "round"], "q": ["quant", "ch", "t", "x", "f", "eq", "qi", "g", "query", "i", "z", "Q", "count", "o", "qu", "iq", "w", "queue", "qs", "k", "qt", "v", "c", "req", "qq", "qa", "p", "depth", "h", "sq", "order", "u"], "tmp": ["sup", "txt", "offset", "fp", "obj", "sample", "ctr", "buffer", "rc", "num", "i", "cb", "app", "cp", "loc", "ctx", "pb", "mini", "bb", "mem", "nb", "zip", "tab", "nm", "array", "nr", "pre", "xt", "img", "config", "mb", "tc", "prefix", "buff", "buf", "comb", "temp", "c", "sam", "rb", "crop", "p", "test", "mp", "pad", "cache", "cmp", "prep", "storage", "proc", "beta", "mm", "np", "now"], "size": ["gn", "scale", "j", "ch", "shape", "small", "code", "mode", "x", "core", "SIZE", "rc", "ne", "num", "i", "z", "loc", "sec", "en", "enc", "sh", "use", "sn", "ize", "k", "e", "sync", "c", "p", "shift", "form", "cn", "Size", "sq", "len"], "n": ["ns", "na", "m", "dn", "j", "un", "t", "inn", "x", "f", "name", "pn", "net", "nt", "r", "ne", "num", "mn", "N", "g", "i", "z", "ny", "nb", "min", "en", "nat", "o", "l", "d", "nr", "nc", "no", "sn", "w", "nu", "rn", "k", "e", "network", "v", "one", "c", "ni", "nw", "p", "none", "b", "fn", "cn", "len", "nn", "np", "an", "y", "conn", "u"], "t0": [" t100", "Tk", " tee", " tk", " t8", "T2", "T100", "T0", "p0", "p2", "pt00", "pt0", "t100", "t2", "ty1", "tt0", "pt2", " t2", "T00", "Tee", "t00", "ttk", "T50", "p50", "ttee", "T8", "t50", "tee", "p00", "pt1", "T1", "tt1", "ty0", "tk", " t50", "ty50", "p1", "p100", "ty8", "t8"], "t1": ["t5", "p4", "taOne", "T2", " t4", "T0", "p0", "p2", "t2", " tOne", "t7", "t4", "pone", "at1", "Tb", " t2", "pb", " t7", "tOne", "Tone", "ta0", "T5", "at5", "tb", " t5", "at2", "ta7", " tone", "atone", "TOne", " tb", "T1", "ta1", "tone", "T4", "T7", "p1"]}}
{"project": "qemu", "commit_id": "f892291eee376505cfec8b6cade7ccf952a6d3e0", "target": 0, "func": "static void parse_numa_distance(NumaDistOptions *dist, Error **errp)\n\n{\n\n    uint16_t src = dist->src;\n\n    uint16_t dst = dist->dst;\n\n    uint8_t val = dist->val;\n\n\n\n    if (src >= MAX_NODES || dst >= MAX_NODES) {\n\n        error_setg(errp,\n\n                   \"Invalid node %\" PRIu16\n\n                   \", max possible could be %\" PRIu16,\n\n                   MAX(src, dst), MAX_NODES);\n\n        return;\n\n    }\n\n\n\n    if (!numa_info[src].present || !numa_info[dst].present) {\n\n        error_setg(errp, \"Source/Destination NUMA node is missing. \"\n\n                   \"Please use '-numa node' option to declare it first.\");\n\n        return;\n\n    }\n\n\n\n    if (val < NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"NUMA distance (%\" PRIu8 \") is invalid, \"\n\n                   \"it shouldn't be less than %d.\",\n\n                   val, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    if (src == dst && val != NUMA_DISTANCE_MIN) {\n\n        error_setg(errp, \"Local distance of node %d should be %d.\",\n\n                   src, NUMA_DISTANCE_MIN);\n\n        return;\n\n    }\n\n\n\n    numa_info[src].distance[dst] = val;\n\n    have_numa_distance = true;\n\n}\n", "idx": 16752, "substitutes": {"dist": ["ist", "grad", "sup", "dd", "txt", "work", "nd", "data", "Dist", "info", "obj", "dest", "dir", "md", "ord", "src", "ext", "dt", "ld", "ctx", "dj", "def", "multi", "sd", "d", "df", "std", "draw", "grade", "transfer", "ui", "config", "det", "dr", "cli", "private", "req", "dev", "missing", "dat", "inst", "desc", "distance", "diff", "np", "progress", "conn"], "errp": ["asterfp", "serg", "reqp", "errsp", "errg", " errP", " errfp", "acerp", "erfp", " errg", "acerr", " errpa", "err", "errP", "erpe", "astb", "errper", "errorc", "errorpc", "errpc", "errt", "reqb", " errt", "serpa", "Erpc", " errc", "asterpc", "errorP", "reqg", "terper", "terb", "tert", "astp", "acersp", "errorp", "rrc", " errsp", "astt", "acerfp", "ersp", "erpc", "reqpa", "erp", " errb", "errr", "errpe", "errfp", "errpa", " errr", "rrp", "serb", "astper", "Erfp", "errb", " errper", "terp", "asterpe", "asterp", "serp", "rrP", " errpc", "Erpe", "Erp", "errc", "rrpc"]}}
{"project": "FFmpeg", "commit_id": "d0dce15da34c0e4eee6c683be299de0221db00d3", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755, "substitutes": {"avctx": ["gcp", "ajctx", "akloc", "avctl", "awctx", "ajcontext", "awcp", "airloc", "AVctl", "awcontext", "airctl", "avcp", "aircli", "akcli", "AVloc", "avcli", "gcontext", "AVcli", "gmc", "avloc", "awmc", "AVctx", "akctl", "akctx", "ajmc", "ajcp", "avcontext", "airctx", "avmc", "gctx"], "gbc": ["ggc", "glic", "ggbc", "gencb", " guc", "gpc", " gcms", "aguc", " grc", "reglic", "hcms", "agcms", "aggcms", " gpc", "genfc", "gsuc", "blc", "ggpc", "gmcb", "lpc", " gc", "gscf", "gguc", "rgpc", " gcb", "gglic", "gslc", "genpc", "gcms", "blic", "gsfc", "lfc", "garc", "gencms", "Gbc", "gglc", "hlic", "igbc", "Grc", "Gcb", "regcms", "iguc", "Gfc", "lcb", "ggcb", " gec", "ggcf", "gmbc", "gfc", "aggcb", "agec", "ggec", "ggcms", " gfc", "rguc", "gmfc", "rgbc", " gcf", "garuc", " glic", "gslic", "hec", "igec", "garbc", "glc", "gsbc", "guc", "gec", "regec", "regbc", "bbc", "igcms", "lbc", "gcb", "grc", "rgfc", "gc", "ggfc", "garfc", "gmrc", "genbc", "hbc", "gcf", "buc", "agbc", "aggbc", "aggpc"], "pal": ["ab", "opal", "bin", "Pal", "pill", "cal", "al", "base", "color", "pl", "align", "pan", "plan", "pixel", "app", "chal", "ap", "pol", "arr", "chi", "nav", "val", "array", "pel", "wal", "style", "ol", "white", "par", "span", "p", "pad", "area", "cell", "ph", "ace", "isal", "pro", "list", "py", "panel", "el", "attr", "li"], "colors": ["colores", "colORS", "ColORS", "collors", " recolons", "Colories", " recolores", "collORS", "Colores", "Colors", "colories", "collores", "colorors", "colorores", "filores", "colons", "colorORS", "colorlections", "filors", "filories", "filons", " recolors", " recolories", "Collections", "colllections", "collections", "Colons"], "i": ["ti", "m", "bi", "j", "x", "f", "ini", "qi", "io", "ai", "mi", "phi", "n", "hi", "ii", "ori", "iu", "di", "index", "slice", "I", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "e", "v", "cli", "c", "ni", "si", "xi", "p", "mu", "a", "eni", "fi", "y", "li", "u"], "r": ["rx", "m", "rr", "fr", "br", "rs", "vr", "x", "err", "rc", "hr", "rt", "R", "n", "ar", "ro", "rh", "rg", "l", "d", "gb", "re", "nr", "mr", "ru", "w", "sr", "e", "dr", "lr", "k", "v", "c", "rb", "rl", "p", "ur", "pr", "er", "a", "gr", "u"], "g": ["gi", "gn", "m", "eg", "sg", "group", "s", "gar", "f", "gre", "x", "gu", "gc", "n", "gg", "gh", "ge", "gam", "rg", "mg", "pg", "l", "d", "gb", "gp", "G", "ig", "w", "e", "ga", "v", "c", "erg", "bg", "p", "gen", "gs", "gas", "gy", "gm", "a", "gr", "u"], "b": ["ab", "eb", "db", "bs", "t", "x", "ob", "f", "n", "sb", "cb", "wb", "B", "xb", "lb", "bb", "abb", "nb", "ba", "o", "l", "d", "bar", "gb", "bf", "w", "bd", "mb", "e", "bl", "fb", "v", "c", "rb", "bg", "p", "beta", "a", "y", "ib", "u"]}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n", "idx": 16767, "substitutes": {"a": ["ab", "au", "f", "n", "A", "i", "am", "as", "ae", "ba", "ca", "d", "ac", "ama", "aa", "aaa", "ad", "asa", "e", "ga", "pa", "c", "da", "p", "area", "va", "la", "aw", "ma", "alpha", "an", "sa"], "b": ["ab", "eb", "db", "bs", "x", "f", "base", "ob", "sb", "g", "i", "as", "wb", "B", "pb", "abb", "lb", "bb", "ba", "other", "l", "d", "bar", "bf", "bd", "e", "fb", "v", "emb", "c", "be", "rb", "p", "y", "ib"]}}
{"project": "qemu", "commit_id": "94a8d39afd8ccfdbf578af04c3385fdb5f545af1", "target": 1, "func": "uint32_t kvm_arch_get_supported_cpuid(CPUState *env, uint32_t function,\n\n                                      uint32_t index, int reg)\n\n{\n\n    struct kvm_cpuid2 *cpuid;\n\n    int i, max;\n\n    uint32_t ret = 0;\n\n    uint32_t cpuid_1_edx;\n\n\n\n    if (!kvm_check_extension(env->kvm_state, KVM_CAP_EXT_CPUID)) {\n\n        return -1U;\n\n    }\n\n\n\n    max = 1;\n\n    while ((cpuid = try_get_cpuid(env->kvm_state, max)) == NULL) {\n\n        max *= 2;\n\n    }\n\n\n\n    for (i = 0; i < cpuid->nent; ++i) {\n\n        if (cpuid->entries[i].function == function &&\n\n            cpuid->entries[i].index == index) {\n\n            switch (reg) {\n\n            case R_EAX:\n\n                ret = cpuid->entries[i].eax;\n\n                break;\n\n            case R_EBX:\n\n                ret = cpuid->entries[i].ebx;\n\n                break;\n\n            case R_ECX:\n\n                ret = cpuid->entries[i].ecx;\n\n                break;\n\n            case R_EDX:\n\n                ret = cpuid->entries[i].edx;\n\n                switch (function) {\n\n                case 1:\n\n                    /* KVM before 2.6.30 misreports the following features */\n\n                    ret |= CPUID_MTRR | CPUID_PAT | CPUID_MCE | CPUID_MCA;\n\n                    break;\n\n                case 0x80000001:\n\n                    /* On Intel, kvm returns cpuid according to the Intel spec,\n\n                     * so add missing bits according to the AMD spec:\n\n                     */\n\n                    cpuid_1_edx = kvm_arch_get_supported_cpuid(env, 1, 0, R_EDX);\n\n                    ret |= cpuid_1_edx & 0x183f7ff;\n\n                    break;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    qemu_free(cpuid);\n\n\n\n    return ret;\n\n}\n", "idx": 16771, "substitutes": {"env": ["org", "viron", "session", "db", "init", "code", "core", "conf", "eve", "net", "eye", "eu", "engine", "worker", "exc", "loader", "cf", "window", "ou", "np", "erv", "environment", "scope", "manager", "en", "self", "eng", "enc", "exec", "context", "ce", "event", "ev", "config", "e", "ep", "esm", "vs", "emb", "inv", "ea", "dev", "osc", "que", "ec", "proc", "inst", "ef", "export", "er", "api", "state", "end", "eni", "server", "esi", "ah", "conn"], "function": ["program", "native", "global", "code", "func", "mode", "name", "f", "action", "service", "library", "r", "fun", "family", "role", "document", "module", "method", "region", "package", "public", "loc", "type", "run", "functional", "replace", "object", "exec", "range", "class", "array", "event", "future", "rule", "activation", "value", "handler", "man", "parent", "unit", "lambda", "feature", "Function", "resource", "fn", "form", "unc", "interface", "number", "connection", "sequence", "callback", "word", "reason", "command", "operation", "section", "operator", "version", "expression"], "index": ["ion", "part", "pattern", "instance", "info", "x", "search", "name", "call", "image", "ix", "ini", "action", "pin", "inc", "version", "num", "type", "loc", "in", "Index", "slice", "ind", "pointer", "object", "is", "val", "axis", "location", "original", "column", "length", "id", "start", "key", "fix", "update", "position", "address", "error", "row", "number", "find", "weight", "connection", "end", "valid", "diff", "value", "custom", "scan", "connect", "expression"], "reg": ["rx", "ret", "pattern", "init", "mod", "func", "rest", "thread", "rc", "r", "debug", "fun", "result", "num", "g", "flag", "region", "match", "loc", "rg", "sec", "def", "tag", "range", "rec", "re", "rule", "config", "feature", "REG", "res", "row", "proc", "addr", "Reg", "len"], "cpuid": [" cpnum", "cpudi", "cpuser", "compuri", " cpsid", " cpuint", " cpuser", "CPuu", "chuu", "copnum", "cppid", "cppupid", "cpsid", " cpuda", "cppuser", "ppupid", "cfupid", " cpudi", "cfudi", "copuu", "compuu", "chuid", "cpu", "copdu", "copudi", "chid", "cpnum", "cpuri", "CPupid", "cpuda", "chupid", " cpuu", "ppuid", "ppid", "pupid", "cppdu", "cppuid", "cppnum", "cppsid", "copuri", "copid", "compuint", "cpuu", "ppuu", "ppuri", "ppuda", "copuser", "cppu", "cppuri", " cpdu", "copuint", "cppuda", " cpid", "cpid", " cpu", "cpdu", "copuda", "cpuint", "cfuu", "cppuu", " cpuri", "CPuri", "CPuid", "puid", "pu", "cpupid", "copuid", "compid", "cfuid", " cpupid", "copupid", "compuid", "psid"], "i": ["gi", "ti", "uri", "status", "ret", "m", "j", "info", "x", "f", "base", "image", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "phi", "g", "or", "in", "ii", "ie", "di", "ind", "iu", "I", "ori", "min", "ip", "l", "d", "oi", "yi", "pi", "ui", "isin", "ci", "id", "start", "k", "e", "v", "lc", "c", "cli", "si", "ri", "p", "xi", "b", "uli", "interface", "iv", "api", "im", "end", "it", "eni", "fi", "source", "y", "li", "u"], "max": ["est", "rank", "ret", "custom", "work", "mod", "x", "rest", "conf", "wrap", "r", "num", "orig", "min", "count", "range", "rec", "re", "chain", "step", "size", "ax", "w", "last", "key", "id", "limit", "cr", "cl", "parent", "c", "p", "can", "total", "res", "row", "end", "Max", "mac", "MAX", "co"], "cpuid_1_edx": ["cpuid_1_adX", "cpuid_1_idx", "cpuid_1_idw", "cpuid_1_hedx", "cpuid_1_eedf", "cpuid_1_eedw", "cpuid_1_ledf", "cpuid_1_hedX", "cpuid_1_ledw", "cpuid_1_Edex", "cpuid_1_endedX", "cpuid_1_edxa", "cpuid_1_eedex", "cpuid_1_Edb", "cpuid_1_idex", "cpuid_1_endedx", "cpuid_1_idb", "cpuid_1_endedex", "cpuid_1_Edx", "cpuid_1_endedxa", "cpuid_1_ledx", "cpuid_1_adxa", "cpuid_1_edb", "cpuid_1_edX", "cpuid_1_eedx", "cpuid_1_adx", "cpuid_1_edw", "cpuid_1_idX", "cpuid_1_endedb", "cpuid_1_idf", "cpuid_1_edf", "cpuid_1_ledex", "cpuid_1_hedxa", "cpuid_1_EdX", "cpuid_1_edex"]}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static bool get_next_page(GuestPhysBlock **blockptr, uint64_t *pfnptr,\n\n                          uint8_t **bufptr, DumpState *s)\n\n{\n\n    GuestPhysBlock *block = *blockptr;\n\n    hwaddr addr;\n\n    uint8_t *buf;\n\n\n\n    /* block == NULL means the start of the iteration */\n\n    if (!block) {\n\n        block = QTAILQ_FIRST(&s->guest_phys_blocks.head);\n\n        *blockptr = block;\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        if (bufptr) {\n\n            *bufptr = block->host_addr;\n\n        }\n\n        return true;\n\n    }\n\n\n\n    *pfnptr = *pfnptr + 1;\n\n    addr = pfn_to_paddr(*pfnptr);\n\n\n\n    if ((addr >= block->target_start) &&\n\n        (addr + s->page_size <= block->target_end)) {\n\n        buf = block->host_addr + (addr - block->target_start);\n\n    } else {\n\n        /* the next page is in the next block */\n\n        block = QTAILQ_NEXT(block, next);\n\n        *blockptr = block;\n\n        if (!block) {\n\n            return false;\n\n        }\n\n        assert(block->target_start % s->page_size == 0);\n\n        assert(block->target_end % s->page_size == 0);\n\n        *pfnptr = paddr_to_pfn(block->target_start);\n\n        buf = block->host_addr;\n\n    }\n\n\n\n    if (bufptr) {\n\n        *bufptr = buf;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 16780, "substitutes": {"blockptr": ["lockpointer", "lockptr", "pluginptr", "Blockpointer", " blockpt", "pluginpointer", "blockPtr", "Blockaddr", "blockPo", "lockPtr", "pluginPtr", "boxPo", " blockPtr", "lockpt", "lockaddr", "blockpt", "blockaddr", "BlockPtr", "blockpointer", "Blockptr", " blockpointer", "boxpt", "BlockPo", "boxpointer", " blockPo", "boxPtr", "boxptr", " blockaddr"], "pfnptr": ["pdnPtr", "pfnattr", "ppfcaddr", " pdnptr", "pknPtr", "pdnpointer", "pdnptr", " pfnattr", "Pnmpointer", "pdnaddr", "pfpattr", "pfdaddr", "pknpointer", "pknctr", "pbnpointer", "pnmpointer", "cfnptr", "ppfnptr", "pfdptr", "pfunater", " pfnaddr", "pconnrect", "lpfnPtr", "pknattr", "pfnsize", "cfnater", "Pnmctr", " pfpaddr", "pfcaddr", " pdnpointer", "pfunpointer", " pfpattr", "pnmattr", "pbnater", "pfnaddr", "cfnaddr", "cknpointer", "pnmctr", "pnmPtr", "pfcsize", "pfdctr", "lpfnrect", " pfnctr", " pfnpointer", "cknaddr", "pknater", "ppfcptr", " pdnctr", "lpformatptr", "pdnctr", "Pfnptr", "pbnaddr", "pfpctr", "pconnPtr", "lpformatrect", "pfnctr", "cknater", "pformatrect", "Pnmptr", "pfcctr", "pfdsize", "pformatptr", "pformatPtr", "pnmptr", "pknsize", "pnmaddr", " pfpctr", "PnmPtr", "cfnpointer", "ppfnctr", "PfnPtr", "ppfnaddr", "pfpaddr", "pfpptr", "pfnater", "cknptr", "pfunaddr", "lpformatPtr", "Pfnctr", "pfnrect", "Pfnpointer", " pdnaddr", "pfcptr", "ppfcctr", "ppfcsize", "ppfnsize", "pfnpointer", "pbnptr", "pconnptr", "pfunptr", " pfpptr", "pknptr", "pknaddr", "lpfnptr", "pfnPtr"], "bufptr": ["seqptr", "ufPtr", "bufdr", "seqaddr", "cvPtr", "ctxref", "buffpointer", "cbPtr", "seqpointer", " bufdr", "ufpointer", "ufaddr", "cbaddr", "cvpointer", " bufaddr", "bufPtr", "ufptr", "bufferPtr", "cbpointer", "ctxptr", "bufferpointer", "bufferptr", "cbptr", "cvaddr", "buffdr", "ctxaddr", "ctxpointer", "cvptr", "cvref", "bufaddr", "buffPtr", "ufdr", "bufpointer", "ufref", "buffptr", "bufferaddr", "bufref", "seqPtr", " bufpointer", "buffaddr"], "s": ["ns", "set", "spec", "settings", "ares", "service", "comm", "ss", "d", "sh", "new", "ims", "id", "qs", "ments", "sym", "p", "h", "groups", "sets", "m", "ts", "sg", "rs", "ips", "scope", "o", "su", "side", "v", "si", "S", "a", "an", "ches", "ds", "status", "time", "f", "r", "sb", "l", "w", "features", "q", "sync", "c", "ps", "address", "b", "sys", "ship", "es", "state", "states", "sq", "session", "request", "t", "info", "conf", "services", "n", "has", "g", "i", "sl", "ops", "slice", "fs", "en", "is", "views", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"], "block": ["set", "spec", "point", "un", "user", "full", "comment", "ref", "pack", "num", "run", "label", "exec", "new", "tx", "box", "config", "layout", "p", "none", "next", "loop", "end", "blocking", "board", "plugin", "init", "work", "name", "query", "clean", "bc", "bb", "self", "object", "flow", "blocks", "key", "bl", "open", "update", "inv", "off", "null", "row", "list", "an", "down", "view", "base", "call", "image", "tick", "script", "type", "node", "loc", "model", "wall", "page", "ack", "close", "chain", "network", "Block", "batch", "sync", "line", "address", "lock", "b", "ban", "check", "frame", "session", "group", "record", "info", "buffer", "n", "module", "month", "index", "slice", "day", "out", "ip", "join", "link", "bo", "header", "event", "limit", "cl", "map", "unit", "cache", "error", "clock", "number"], "addr": ["grad", "spec", "offset", "Address", "x", "obj", "ref", "align", "ar", "str", "adder", "ptr", "pos", "ress", "id", "pad", "adr", "alloc", "conn", "len", "au", "name", "ix", "rc", "hop", "pointer", "arr", "size", "ha", "aug", "ady", "amp", "hash", "rt", "type", "ril", "src", "loc", "byte", "sta", "host", "ack", "val", "nr", "ad", "address", "doc", "inter", "ace", "az", "amd", "alpha", "rr", "info", "mode", "ord", "coord", "ast", "oa", "index", "slice", "ip", " address", "alias", "pkg", "ac", "add", "dr", "seq", "url", "cmp", "attr"], "buf": ["ab", "bin", "offset", "br", "ff", "text", "lim", "func", "af", "runner", "pool", "buffer", "rc", "vec", "coord", "border", "result", "brace", "cf", "cb", "bc", "src", "loc", "holder", "ctx", "pb", "byte", "cas", "prop", "pkg", "feat", "aux", "bu", "box", "img", "queue", "config", "fd", "buff", "batch", "fb", "rb", "seq", "cmd", "tmp", "off", "cap", "alloc", "port", "bag", "uf", "len"]}}
{"project": "qemu", "commit_id": "280d373579558f73a8b70e329d9a6206933d3809", "target": 0, "func": "static coroutine_fn int qcow2_co_writev(BlockDriverState *bs,\n\n                           int64_t sector_num,\n\n                           int remaining_sectors,\n\n                           QEMUIOVector *qiov)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    int n_end;\n\n    int ret;\n\n    int cur_nr_sectors; /* number of sectors in current iteration */\n\n    uint64_t cluster_offset;\n\n    QEMUIOVector hd_qiov;\n\n    uint64_t bytes_done = 0;\n\n    uint8_t *cluster_data = NULL;\n\n    QCowL2Meta *l2meta;\n\n\n\n    trace_qcow2_writev_start_req(qemu_coroutine_self(), sector_num,\n\n                                 remaining_sectors);\n\n\n\n    qemu_iovec_init(&hd_qiov, qiov->niov);\n\n\n\n    s->cluster_cache_offset = -1; /* disable compressed cache */\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    while (remaining_sectors != 0) {\n\n\n\n        l2meta = NULL;\n\n\n\n        trace_qcow2_writev_start_part(qemu_coroutine_self());\n\n        index_in_cluster = sector_num & (s->cluster_sectors - 1);\n\n        n_end = index_in_cluster + remaining_sectors;\n\n        if (s->crypt_method &&\n\n            n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors) {\n\n            n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n        }\n\n\n\n        ret = qcow2_alloc_cluster_offset(bs, sector_num << 9,\n\n            index_in_cluster, n_end, &cur_nr_sectors, &cluster_offset, &l2meta);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta->nb_clusters > 0 &&\n\n            (s->compatible_features & QCOW2_COMPAT_LAZY_REFCOUNTS)) {\n\n            qcow2_mark_dirty(bs);\n\n        }\n\n\n\n        assert((cluster_offset & 511) == 0);\n\n\n\n        qemu_iovec_reset(&hd_qiov);\n\n        qemu_iovec_concat(&hd_qiov, qiov, bytes_done,\n\n            cur_nr_sectors * 512);\n\n\n\n        if (s->crypt_method) {\n\n            if (!cluster_data) {\n\n                cluster_data = qemu_blockalign(bs, QCOW_MAX_CRYPT_CLUSTERS *\n\n                                                 s->cluster_size);\n\n            }\n\n\n\n            assert(hd_qiov.size <=\n\n                   QCOW_MAX_CRYPT_CLUSTERS * s->cluster_size);\n\n            qemu_iovec_to_buf(&hd_qiov, 0, cluster_data, hd_qiov.size);\n\n\n\n            qcow2_encrypt_sectors(s, sector_num, cluster_data,\n\n                cluster_data, cur_nr_sectors, 1, &s->aes_encrypt_key);\n\n\n\n            qemu_iovec_reset(&hd_qiov);\n\n            qemu_iovec_add(&hd_qiov, cluster_data,\n\n                cur_nr_sectors * 512);\n\n        }\n\n\n\n        qemu_co_mutex_unlock(&s->lock);\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        trace_qcow2_writev_data(qemu_coroutine_self(),\n\n                                (cluster_offset >> 9) + index_in_cluster);\n\n        ret = bdrv_co_writev(bs->file,\n\n                             (cluster_offset >> 9) + index_in_cluster,\n\n                             cur_nr_sectors, &hd_qiov);\n\n        qemu_co_mutex_lock(&s->lock);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        if (l2meta != NULL) {\n\n            ret = qcow2_alloc_cluster_link_l2(bs, l2meta);\n\n            if (ret < 0) {\n\n                goto fail;\n\n            }\n\n\n\n            run_dependent_requests(s, l2meta);\n\n            g_free(l2meta);\n\n            l2meta = NULL;\n\n        }\n\n\n\n        remaining_sectors -= cur_nr_sectors;\n\n        sector_num += cur_nr_sectors;\n\n        bytes_done += cur_nr_sectors * 512;\n\n        trace_qcow2_writev_done_part(qemu_coroutine_self(), cur_nr_sectors);\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    if (l2meta != NULL) {\n\n        run_dependent_requests(s, l2meta);\n\n        g_free(l2meta);\n\n    }\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n\n\n    qemu_iovec_destroy(&hd_qiov);\n\n    qemu_vfree(cluster_data);\n\n    trace_qcow2_writev_done_req(qemu_coroutine_self(), ret);\n\n\n\n    return ret;\n\n}\n", "idx": 16783, "substitutes": {"bs": ["ns", "ab", "org", "bi", "db", "lbs", "base", "ob", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "cs", "gb", "bos", "bps", "ins", "obs", "outs", "BS", "iss", "bis", "qs", "bl", "vs", "bas", "ses", "bh", "fb", "js", "bits", "ps", "sync", "b", "ks", "its", "bytes", "os", "bes", "banks", "us", "ds"], "sector_num": ["axis_index", "section_mult", "sector6number", "sector_name", "sector_number", "sector_range", "sector6offset", "sector6num", "section_offset", "section_num", "sector_no", "sector_offset", "section_start", "axis_num", "sectorPnumber", "axis_number", "section_no", "sector_index", "section_number", "section_name", "sector_start", "sectorPoffset", "axis_range", "sectorPnum", "sector_mult", "sector6start", "sectorPstart"], "remaining_sectors": ["remaining_SErets", "remaining_secxes", "remaining_surets", "remaining_ceivers", "remaining_seivers", "remaining_secgments", "remaining_seonents", "remaining_veriers", "remaining_pseonents", "remaining_SEctors", "remaining_sexes", "remaining_persegments", "remaining_kellor", "remaining_secctors", "remaining_cegments", "remaining_SEcs", "remaining_segments", "remaining_cecs", "remaining_specs", "remaining_secs", "remaining_syctors", "remaining_sygments", "remaining_syllor", "remaining_vegments", "remaining_vectors", "remaining_sellor", "remaining_veonents", "remaining_perseriers", "remaining_cectors", "remaining_kegments", "remaining_pseriers", "remaining_seriers", "remaining_persectors", "remaining_perseonents", "remaining_spegments", "remaining_SEgments", "remaining_spectors", "remaining_psectors", "remaining_suctors", "remaining_syxes", "remaining_kectors", "remaining_secllor", "remaining_serets", "remaining_speivers", "remaining_kexes", "remaining_SEivers", "remaining_sugments", "remaining_psegments", "remaining_psecs", "remaining_sucs", "remaining_pserets"], "qiov": ["qqiov", "sqicho", " qoyer", "qqiev", "zilo", "sqoyer", "ziov", "qilo", "zoyer", "qimoto", "sqimoto", "quiov", " qimoto", "qicho", "qqilo", "quicho", "qoyer", "qqoyer", "quimoto", " qiev", "quoyer", "sqiov", "ziev", " qilo", " qicho", "qiev"], "s": ["ns", "set", "spec", "stat", "words", "full", "settings", "service", "sie", "files", "ss", "cs", "qs", "sym", "p", "ks", "groups", "sets", "comments", "sa", "m", "ts", "sg", "rs", "aws", "self", "lines", "o", "su", "tests", "side", "si", "S", "members", "hs", "ds", "f", "sv", "sb", "utils", "ins", "sync", "c", "ps", "secondary", "b", "sys", "state", "states", "sq", "less", "session", "stats", "t", "conf", "services", "n", "g", "sl", "ls", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "support", "http", "gs", "storage", "its", "os", "parts", "server"], "index_in_cluster": ["index_in_scluster", "index_in_veluster", "index_in_oclusters", "index_in_comburation", "index_in_velrome", "index_in_quica", "index_in_clrome", "index_in_clivery", "index_in_Clica", "index_in_CLuster", "index_in_CLorer", "index_in_combusters", "index_in_Cliton", "index_in_Clrome", "index_in_clause", "index_in_chusters", "index_in_sclause", "index_in_Clancer", "index_in_velusters", "index_in_wausters", "index_in_combuster", "index_in_waivery", "index_in_Clusters", "index_in_clorer", "index_in_quause", "index_in_velivery", "index_in_CLusters", "index_in_Clivery", "index_in_chuster", "index_in_quusters", "index_in_CLuration", "index_in_Clorer", "index_in_sclica", "index_in_chancer", "index_in_clica", "index_in_ocluster", "index_in_oclancer", "index_in_cluration", "index_in_clusters", "index_in_wauster", "index_in_Clause", "index_in_warome", "index_in_chiton", "index_in_clancer", "index_in_comborer", "index_in_sclusters", "index_in_quuster", "index_in_Cluster", "index_in_Cluration", "index_in_cliton", "index_in_ocliton"], "n_end": ["nsend", "N_end", "sn_END", " n_ended", " n_ends", "n__ending", "nIPpost", "N_start", "nIPEND", "n_post", "n_ended", "n2end", "n_ends", "nsset", "n_offset", "nxEND", "n00set", "nIPend", "n_start", "n00ended", "n_END", "e_set", "nxend", "e_ended", "sn_end", "nxstart", "n2ended", " n_start", "sn_post", "nsended", "n_ending", "n2ending", " n_ending", "N_ends", "nsoffset", "n_set", "n00end", "e_end", "sn_start", "n00offset", "nIPstart", "n__end", "n2ends", "n__ends", "e_offset", "nxpost", "n2start"], "ret": ["part", "group", "code", "bit", "ref", "alt", "rc", "nt", "reg", "hash", "rt", "fun", "lit", "result", "num", "flag", "match", "ext", "fin", "rets", "arg", "att", "val", "re", "Ret", "bf", " RET", "no", "back", "id", "det", "rev", "success", "seq", " Ret", "gt", "RET", "total", "res", "mt", "ft", "conn", "len"], "cur_nr_sectors": ["cur_nr_vevers", "cur_nr_severs", "cur_nr_tections", "cur_nr_vectors", "cur_nr_sctors", "cur_nr_verets", "cur_nr_vegments", "cur_nr_sgments", "cur_nr_segments", "cur_nr_tegments", "cur_nr_secrets", "cur_nr_secctors", "cur_nr_tevers", "cur_nr_serets", "cur_nr_vections", "cur_nr_secvers", "cur_nr_tectors", "cur_nr_sections", "cur_nr_secgments", "cur_nr_srets", "cur_nr_secctions"], "cluster_offset": ["cluster_index", "clica_number", "clica_offset", "cluster_end", "cluster_done", "cluster2offset", "clica2index", "clusters_end", "cluster___offset", "cluster___index", "clusters_offset", "cluster2number", "cluster___number", "cluster2done", "cluster_num", "clusters_size", "clusteringindex", "clica2number", "cluster2index", "clusteringnumber", "clica2offset", "clica_index", "clica_done", "clusteringdone", "clusteringoffset", "clusters_num", "cluster_start", "cluster_number", "cluster___done", "cluster_size", "clica2done"], "hd_qiov": ["hd_Qiop", "hd_shiop", "hd_Qoyer", "hd_quiov", "hd_sqoyer", "hd_qoyer", "hd_\n", "xd_\t", "hd_seq", "hd_\t", "hd_shiov", "hd_shoyer", "hd_shrolet", "hd_quiop", "hd_qrolet", "hd___\t", "hd___seq", "hd_Qiov", "xd_\n", "hd_sqrolet", "hd_sqiov", "hd_qiop", "hd_Qrolet", "hd_quoyer", "hd_sqiop", "hd___\n", "xd_seq", "hd_qurolet"], "cluster_data": ["cluster2offset", "clusters_info", "clusters_offset", "cluster_info", "cluster2info", "clusters_size", "clusters_data", "cluster2size", "cluster2data", "cluster_size"], "l2meta": [" l4meta", "l3Meta", "l3magic", "d2meta", " l6meta", " l2eta", " l2Meta", " l6metadata", "l6data", "l2magic", "l6meta", "l5eta", "d3metadata", "loudmeta", "l1data", "l1mic", " l6Meta", " l4metadata", "l1eta", "loudmagic", "l6Meta", "d3meta", " l3mic", "l3mic", "l1meta", " l3eta", "l5meta", "d2eta", "l3metadata", "l2mic", " l6data", " l2data", "loudmetadata", "l4meta", "l2Meta", " l2magic", "l5metadata", "l5mic", "d2metadata", "l6metadata", "d3eta", " l3metadata", "l2metadata", "l2eta", "l3eta", "l4eta", "l1Meta", "l4Meta", "d2Meta", "l1metadata", " l2mic", "l3meta", "l2data", " l3meta", "l4metadata", "loudeta", " l2metadata", " l4eta", "l4data", "l4magic", " l4magic", "d3Meta"]}}
{"project": "qemu", "commit_id": "a980a065fb5e86d6dec337e6cb6ff432f1a143c9", "target": 0, "func": "int usb_desc_get_descriptor(USBDevice *dev, int value, uint8_t *dest, size_t len)\n\n{\n\n    const USBDesc *desc = dev->info->usb_desc;\n\n    uint8_t buf[256];\n\n    uint8_t type = value >> 8;\n\n    uint8_t index = value & 0xff;\n\n    int ret = -1;\n\n\n\n    switch(type) {\n\n    case USB_DT_DEVICE:\n\n        ret = usb_desc_device(&desc->id, desc->full, buf, sizeof(buf));\n\n        trace_usb_desc_device(dev->addr, len, ret);\n\n        break;\n\n    case USB_DT_CONFIG:\n\n        if (index < desc->full->bNumConfigurations) {\n\n            ret = usb_desc_config(desc->full->confs + index, buf, sizeof(buf));\n\n        }\n\n        trace_usb_desc_config(dev->addr, index, len, ret);\n\n        break;\n\n    case USB_DT_STRING:\n\n        ret = usb_desc_string(dev, index, buf, sizeof(buf));\n\n        trace_usb_desc_string(dev->addr, index, len, ret);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: %d unknown type %d (len %zd)\\n\", __FUNCTION__,\n\n                dev->addr, type, len);\n\n        break;\n\n    }\n\n\n\n    if (ret > 0) {\n\n        if (ret > len) {\n\n            ret = len;\n\n        }\n\n        memcpy(dest, buf, ret);\n\n    }\n\n    return ret;\n\n}\n", "idx": 16787, "substitutes": {"dev": ["dc", "Dev", "dd", "mod", "data", "info", "pub", "name", "dep", "comment", "conf", "md", "nt", "debug", "de", "gu", "ver", "pack", "rad", "app", "package", "di", "dt", "wd", "index", "mem", "ind", "def", "self", "sd", "prom", "home", "d", "adv", "fail", "w", "ev", "ad", "dm", "img", "id", "cam", "config", "client", "cur", "device", "dom", "temp", "cmd", "p", "off", "doc", "test", "cache", "dist", "error", "dem", "priv", "DEV", "pro", "end", "die", "diff", "conn", "ds", "bug"], "value": ["values", "ret", "content", "Value", "offset", "data", "name", "image", "buffer", "result", "num", "option", "current", "type", "max", "index", "mem", "byte", "min", "count", "val", "size", "no", "length", "id", "start", "key", "amount", "v", "device", "VALUE", "off", "address", "total", "number", "weight", "port", "valid", "version"], "dest": ["dc", "data", "destroy", "dep", "obj", "ref", "de", "result", "pack", "src", "orig", "wb", "des", "mem", "dim", "def", "home", "prop", "path", "img", "bd", "config", "sub", "buff", "temp", "tmp", "trans", "cmd", "uc", "doc", "dist", "gen", "output", "route", "opt", "Dest", "end", "source", "target"], "len": ["ref", "str", "pos", "ln", "length", "id", "rev", "repl", "gen", "lin", "valid", "lang", "lon", "part", "bin", "name", "fun", "fin", "min", "count", "arg", "size", "last", "lc", "iter", "ret", "base", "f", "err", "alt", "net", "type", "loc", " ret", "l", "val", "line", "fn", "split", " length", "Len", "db", "data", "all", "n", "index", "en", "lt", "lf", "format", "args", "limit", "seq", "ll", "url", "el", "li"], "desc": ["dc", "code", "data", "info", "esc", "dep", "obj", "name", "dir", "td", "conf", "de", "acc", "bc", "src", "ext", "pb", "des", "sec", "def", "description", "enc", "design", "val", "rec", "df", "disc", "sub", "config", "sc", "req", "cmd", "uc", "Desc", "doc", "pro", "decl", "diff", "asc", "conn", "dist"], "buf": ["br", "extra", "ff", "db", "data", "text", "func", "lim", "ref", "pool", "buffer", "rc", "vec", "fun", "result", "cf", "exc", "cb", "cp", "src", "bc", "raw", "ctx", "wb", "pb", "pos", "fab", "bb", "lb", "index", "mem", "prop", "val", "array", "begin", "path", "feat", "bf", "config", "bd", "fd", "queue", "buff", "fb", "v", "map", "comb", "loc", "rb", "seq", "cmd", "uc", "msg", "b", "cmp", "null", "cap", "alloc", "bag", "uf", "bus", "cv"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void connex_init(MachineState *machine)\n\n{\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t connex_rom = 0x01000000;\n\n    uint32_t connex_ram = 0x04000000;\n\n\n\n    cpu = pxa255_init(address_space_mem, connex_ram);\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"connext.rom\", connex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, connex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 36 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 36));\n\n}\n", "idx": 16792, "substitutes": {"machine": ["process", "m", "instance", "session", "image", "loader", "master", "node", "manager", "mem", "computer", "vm", "host", "linux", "config", "processor", "parent", "device", "slave", "VM", "cache", "boot", "Machine", "proc", "connection", "state", "mac"], "cpu": ["pc", "pty", "process", "instance", "core", "component", "conn", "net", "thread", "proxy", "ro", "loader", "cp", "node", "mem", "computer", "bench", "vm", "setup", "GPU", "hw", "linux", "disk", " CPU", "memory", "CPU", "gpu", "config", "processor", "device", "kernel", "cache", "cmp", "sys", "clock", "proc", "uca", "boot", "pu", "eni", "prem", "ilo", "chip"], "dinfo": ["rdstate", "Dopen", "einf", "pInfo", "dbInfo", "dsinfo", "fcheck", "fInfo", "dInfo", "dlinf", "dfo", " dopen", "dsindex", "popen", "Dinfo", "dopen", "dinf", "dscheck", "dsfo", "echeck", "dcheck", " dinf", "dsstate", "finf", "dindex", " dcheck", "dlinfo", "dslink", "pinfo", "dbinf", "dlink", "dstate", "finfo", "rdindex", "rdinf", " dlink", "einfo", " dfo", " dstate", " dInfo", "dllink", " dindex", "dsInfo", "eInfo", "dlfo", "dsinf", "dbinfo", "rdinfo", "DInfo", "dbcheck"], "be": ["enable", "scale", "eb", "ere", "obe", "ste", "ine", "hide", "fe", "ne", " Be", "pe", "beat", "trace", " probe", "ro", "de", "ble", "sb", "see", "ver", "ave", "ge", "ate", "te", "leave", "byte", "replace", "ee", "ae", "ze", "ome", "is", "range", "Be", "are", " BE", "ce", "le", "ignore", "bf", "stop", "use", "fore", "ride", "bis", "e", "abe", "bre", "none", "b", "ben", "ke", "ace", "bee", "BE", "bes", "se", "me", "ve", "ose", "by"], "address_space_mem": ["address_space__ram", "address_space2ram", "address_space2memory", "address_system_mem", "address_system_lim", "address_space2dem", "address_space__mem", "address_pace_dem", "address_space2mem", "address_space_lim", "address_pace_ram", "address_pace_mem", "address_space__memory", "address_space__dem", "address_space_space", "address_space_memory", "address_space_ram", "address_system_space", "address_pace_memory", "address_space_dem"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void aio_set_event_notifier(AioContext *ctx,\n\n                            EventNotifier *notifier,\n\n                            bool is_external,\n\n                            EventNotifierHandler *io_read,\n\n                            AioPollFn *io_poll)\n\n{\n\n    aio_set_fd_handler(ctx, event_notifier_get_fd(notifier), is_external,\n\n                       (IOHandler *)io_read, NULL, io_poll, notifier);\n\n}\n", "idx": 16794, "substitutes": {"ctx": ["pc", "cc", "fp", "obj", "cca", "rc", "gc", "io", "cm", "cf", "cb", "cp", "loc", "bc", "cas", "Context", "ca", "context", "pkg", "nc", "tx", "ci", "tc", "config", "xc", "sc", "cam", "client", "cli", "lc", "cr", "c", "qa", "cmp", "connection", "cv", "conn", "reader"], "notifier": ["notifer", "signification", "butification", "annifer", "notify", "annotifer", "netify", "notification", "annotizer", "signifer", "butifer", "netifier", "noticator", "butifier", "annifier", "signifier", "ntizer", "notizer", "netification", "annotifier", "annoticator", "toolification", "buticator", "nticator", " notizer", "annicator", "toolify", "toolifer", "ntifier", "toolifier", "annification", "netifer", "signicator", "annify", "ntifer", " notifer", " noticator"], "is_external": ["is_internal", "isingexternal", "isingExternal", " is_https", "isinghttps", " is_internal", "isingglobal", "is_https", "is_External", " is_global", " is_External", "is_global"], "io_read": [" io_run", "iopreader", " io_reader", "iopread", "event_poll", "ioseach", "iosrun", "iosread", "io_each", "event_read", "iosreader", "io_reader", "ioppoll", " io_each", "io_run", "event_reader"], "io_poll": ["iofselect", "io_select", "iofpoll", "iofwait", "io2poll", "io67wait", "io2install", "io67install", "io_scan", "io\u00b7scan", "io\u00b7wait", "io\u00b7select", " io_wait", "io_install", " io_select", "io_wait", " io_scan", "io2wait", "io67poll", "iofscan", " io_install", "io\u00b7poll"]}}
{"project": "FFmpeg", "commit_id": "f6687bf5f8989d397cdef6d9d05bcb13a7ef8c4f", "target": 0, "func": "void av_xtea_crypt(AVXTEA *ctx, uint8_t *dst, const uint8_t *src, int count,\n\n                   uint8_t *iv, int decrypt)\n\n{\n\n    int i;\n\n\n\n    while (count > 0) {\n\n        if (decrypt) {\n\n            xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = dst[i] ^ iv[i];\n\n                memcpy(iv, src, 8);\n\n            }\n\n        } else {\n\n            if (iv) {\n\n                for (i = 0; i < 8; i++)\n\n                    dst[i] = src[i] ^ iv[i];\n\n                xtea_crypt_ecb(ctx, dst, dst, decrypt);\n\n                memcpy(iv, dst, 8);\n\n            } else {\n\n                xtea_crypt_ecb(ctx, dst, src, decrypt);\n\n            }\n\n        }\n\n\n\n        src   += 8;\n\n        dst   += 8;\n\n        count -= 8;\n\n    }\n\n}\n", "idx": 16795, "substitutes": {"ctx": ["fw", "fp", "obj", "cca", "cus", "vc", "conn", "concept", "rc", "cm", "cf", "cb", "anc", "coll", "cp", "loc", "bc", "wcs", "gru", "ocr", "kw", "cas", "ca", "exec", "context", "hw", "linux", "conv", "pkg", "tx", "ci", "tc", "config", "xc", "sc", "cu", "cam", "buf", "cli", "lc", "c", "qa", "cmd", "ck", "sci", "que", "cmp", "cn", "mac", "progress", "cv", "cc", "voc"], "dst": ["dssc", "idrc", "cdst", "isdput", "ndsc", "ndrc", "sdrest", " dstore", "dedST", "pdst", "udsc", "pdsc", "dsst", "dsc", "ndrest", "ddst", "cdsp", "idsc", "sst", "cdsc", "dssts", " dST", "ydsc", "lest", "pdstore", "ndsts", "dsp", "udput", " dsp", "lrest", "dest", "ydstore", "dsrc", "sdsp", "dsput", " drest", "sdsc", " dsc", "adput", "adrest", "srest", "ydsta", "udsts", " dest", "adsc", "drc", "idrest", "pdsta", "ssc", "dedst", "idst", "dsrest", "dedsc", "dedsts", "ndst", " dput", "udst", "sdsts", "lst", " drc", "dput", "ydst", " dsts", "isdst", "lsc", "isdsc", "isdrest", "sdST", "dsest", "ndput", "ddest", "dsta", "sdst", "ddsc", "ssts", "adst", " dsta", "drest", "ddput", "cdsts", "dstore", "dST", "lrc", "dsts"], "src": ["sup", "init", "core", "rest", "dest", "ctr", "rc", "r", "sb", "sl", "usr", "loc", "sel", "slice", "ind", "sec", "liv", "rob", "secure", "stack", "comp", "sn", "st", "img", "sub", "sr", "sc", "ssl", "ruby", "buf", "sync", "config", "cur", "start", "rb", "seq", "rss", "uc", "url", "support", "sci", "obl", "cmp", "depth", "inst", "send", "riv", "desc", "sq", "source", "dist"], "count": ["process", "ch", "code", "child", "data", "conf", "err", "ctr", "call", "base", "n", "counter", "num", "coll", "current", "Count", "th", "ind", "head", "low", "other", "force", "l", "keep", "found", "size", "length", "id", "start", "config", "gl", "deep", "c", "catch", "seq", "p", "depth", "cache", "cmp", "b", "col", "sum", "allow", "repeat", "list", "len"], "iv": ["rx", "oc", "app", "iii", "init", "irc", "vr", "ctr", "ith", "vc", "op", "rc", "inc", "rel", "coll", "or", "ou", "bc", "loc", "ii", "ocr", "ext", "ipher", "sel", "ind", "Iv", "ie", "erv", "vi", "act", "lv", "enc", "IV", "ip", "uv", "equ", "hw", "liv", "secure", "chain", "ipp", "rol", "iq", "av", "uint", "rib", "ci", "img", "ev", "ival", "ov", "iver", "v", "ih", "ract", "lib", "ir", "protect", "cmp", "adr", "oy", "ec", "ivari", "iov", "inst", "riv", "cv", "ib", "voc"], "decrypt": [" decure", "deryption", " decipher", "desccrypt", "ecipher", "derupt", "descrypt", "negrupt", "negipher", "ecrypted", "defryption", "descryption", "decure", " decract", "ecryption", "decryption", "enccrypt", " deccrypt", "deflect", "eccrypt", "decipher", "encrypted", "negcrypt", "encure", "derypt", "negrypt", " decrupt", "defrypt", "descract", "encrypt", "descipher", "derypted", "deipher", "descure", "decract", "decrypted", "deccrypt", "negract", "defipher", "encryption", "eclect", "declect", "desclect", " decryption", "encipher", "negryption", "decrupt", "ecrypt"], "i": ["ti", "gi", "uri", "m", "bi", "init", "j", "ji", "info", "x", "f", "name", "ix", "ini", "qi", "ai", "io", "n", "phi", "hi", "z", "ii", "ie", "ori", "di", "index", "ind", "iu", "I", "in", "multi", "zi", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "e", "k", "v", "cli", "c", "ni", "si", "lc", "ri", "xi", "p", "b", "uli", "col", "anti", "mu", "api", "it", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "6241e8a3821d971755217652dff01f3a45580820", "target": 0, "func": "static void read_chapter(AVFormatContext *s, AVIOContext *pb, int len, char *ttag, ID3v2ExtraMeta **extra_meta)\n\n{\n\n    AVRational time_base = {1, 1000};\n\n    uint32_t start, end;\n\n    AVChapter *chapter;\n\n    uint8_t *dst = NULL;\n\n    int taglen;\n\n    char tag[5];\n\n\n\n    decode_str(s, pb, 0, &dst, &len);\n\n    if (len < 16)\n\n        return;\n\n\n\n    start = avio_rb32(pb);\n\n    end   = avio_rb32(pb);\n\n    avio_skip(pb, 8);\n\n\n\n    chapter = avpriv_new_chapter(s, s->nb_chapters + 1, time_base, start, end, dst);\n\n    if (!chapter) {\n\n        av_free(dst);\n\n        return;\n\n    }\n\n\n\n    len -= 16;\n\n    while (len > 10) {\n\n        avio_read(pb, tag, 4);\n\n        tag[4] = 0;\n\n        taglen = avio_rb32(pb);\n\n        avio_skip(pb, 2);\n\n        len -= 10;\n\n        if (taglen < 0 || taglen > len) {\n\n            av_free(dst);\n\n            return;\n\n        }\n\n        if (tag[0] == 'T')\n\n            read_ttag(s, pb, taglen, &chapter->metadata, tag);\n\n        else\n\n            avio_skip(pb, taglen);\n\n        len -= taglen;\n\n    }\n\n\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_34_metadata_conv);\n\n    ff_metadata_conv(&chapter->metadata, NULL, ff_id3v2_4_metadata_conv);\n\n    av_free(dst);\n\n}\n", "idx": 16808, "substitutes": {"s": ["ns", "pc", "types", "spec", "m", "sup", "ts", "sg", "session", "ab", "stats", "rs", "t", "f", "sv", "settings", "services", "series", "n", "plugins", "sb", "g", "i", "cpp", "sl", "ss", "ls", "utils", "ops", "ctx", "fs", "self", "parser", "context", "space", "sub", "bis", "qs", "sc", "ssl", "e", "ses", "sync", "v", "c", "ps", "si", "p", "support", "sci", "b", "http", "gs", "sys", "storage", "proc", "es", "api", "os", "tp", "us", "se", "sq", "ds", "sf"], "pb": ["pc", "wp", "ab", "plugin", "eb", "db", "bs", "fp", "typ", "jp", "platform", "vp", "pd", "pl", "phrase", "bm", "sb", "pm", "bp", "cb", "cpp", "cp", "bc", "hub", "lp", "wb", "ctx", "fc", "xb", "lb", "bb", "PB", "parser", "dp", "pg", "gb", "pp", "summary", "pkg", "bps", "bf", "mb", "bh", "fb", "rb", "p", "mp", "b", "ppa", "proc", "api", "tp", "py", "prot", "uf", "np", "lab", "sf"], "len": ["html", "offset", "lim", "nt", "ann", "duration", "str", "num", "lp", "pos", "enc", "ln", "feat", "length", "elt", "lib", "lan", "lin", "lang", "lon", "part", "ell", "fun", "fin", "ld", "min", "count", "fl", "size", "span", "lc", "la", "tail", "mer", "list", "ver", "alt", "lit", "loc", "dl", "l", "val", "line", "del", "split", "Len", "pid", "data", "all", "n", "syn", "sl", "ls", "en", "lt", "low", "lf", "hl", "ler", "limit", "seq", "ll", "url", "body", "el", "li"], "ttag": ["tttag", "ntag", "ntar", "otttag", "nttag", "tagger", "tar", "ottar", "ttagger", "ottag", "ntagger", "ottagger", "ttar"], "extra_meta": [" extra_config", "extra__config", "extra_config", "extra_data", "extra__meta", "extra__data", " extra_data", "extra_metadata", "extra__metadata", " extra_metadata"], "start": ["set", "part", "offset", "skip", "init", "time", "info", "name", "op", "sp", "from", "Start", "type", "in", "ind", "pos", "min", "count", "get", "art", "range", "d", "parse", "read", "old", "step", "size", "first", "pre", "starting", "stop", "style", "use", "length", "ad", "mid", "id", "open", "span", "patch", "p", "next", "se"], "end": ["set", "est", "offset", "nd", "eff", "from", "END", "max", "index", "pos", "ind", "en", "after", "vert", "enc", "until", "range", "End", "event", "size", "stop", "add", "last", "length", "ad", "e", "limit", "send", "open", "mid", "post", "off", "append", "ension", "ase", "edge", "ending", "ended"], "chapter": ["entry", "plugin", "part", "plot", "session", "Chapter", "vision", "record", "time", "archive", "child", "episode", "CHAPTER", "name", "finished", "ch", "volume", "component", "trip", "metadata", "leaf", "job", "story", "assembled", "channel", "month", "year", "type", "toc", "phase", "trial", "slice", "joined", "parser", "page", "prop", "join", "pair", "gap", "wiki", "title", "feat", "seed", "comp", "config", "apter", "hip", "ler", "prev", "cop", "chron", "span", "parent", "man", "patch", "slave", "meta", "draft", "proc", " section", "project", "chart", "paragraph", "podcast", "connection", "section", "voice", "book", "reader"], "dst": ["sdost", "ndsts", "Dste", "edsth", " ddr", "ddr", "bdst", "ndost", "dsp", "Dst", " dsp", "dste", "domsth", "sdST", "Dsp", "idsth", "ddsts", "ndST", " dsth", "domst", "Dsc", "pdst", " dste", "bdsts", "ddST", "idst", "DST", "Ddr", "dsth", " dost", "domsc", "dsc", "Dsts", "ndst", "sdst", "pdsp", "Dost", "ssts", "idost", "bdST", "bdsth", "pdsts", "ddst", "idsc", "sst", "sdsts", "dost", "edsts", "pdste", "Dsth", "sdr", " dsts", "edST", "dST", "sost", " dST", "dsts", "edst", "domost", "ddost"], "taglen": ["wordli", "blocklength", "blocklen", "keyli", "agref", "wordLen", "taglength", " taglength", "commentlen", " tagref", "agLen", " tagnum", "commentrel", "taskLen", "tagln", "catlen", "tagrel", "tagLen", "rowlength", "aglen", " tagl", "taglin", " tagrel", "rowLen", "tagnum", "agrel", "tasklength", "blockLen", "wordlength", " taglf", "taglf", "commentlength", "tasklf", "modln", "blocknum", "agli", "wordlon", "keylength", "taglon", "rowlf", "tagref", "keyl", " taglon", "matchlen", "tasklen", "wordref", "matchln", "tagli", "keylen", "catlon", "modl", " tagli", "modlin", "wordl", " tagLen", "agnum", " taglin", "catlength", " tagln", "matchlin", "aglength", "matchl", "modlen", "agl", "wordlen", "commentl", "tagl", "rowlen"], "tag": ["stat", "part", "code", "text", "bit", "token", "comment", "attribute", "agg", "name", "reg", "pl", "option", "tags", "month", "year", "match", "block", "type", "loc", "date", "count", "Tag", "bad", "prop", "ack", "gap", "class", "feat", "pre", "rule", "length", "key", "id", "TAG", "ag", "cat", "post", "patch", "line", "doc", "cache", "col", "tail", "field", "row", "word", "desc", "bag", "section", "attr", "bug"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_modify_page(CPUState *env, ram_addr_t ram_addr)\n\n{\n\n    unsigned long page_index;\n\n    int ret;\n\n#ifdef _WIN32\n\n    DWORD temp;\n\n#endif\n\n\n\n    page_index = ram_addr >> TARGET_PAGE_BITS;\n\n    if (!modified_ram_pages_table[page_index]) {\n\n#if 0\n\n        printf(\"%d: modify_page=%08lx\\n\", nb_modified_ram_pages, ram_addr);\n\n#endif\n\n        modified_ram_pages_table[page_index] = 1;\n\n        modified_ram_pages[nb_modified_ram_pages++] = ram_addr;\n\n        if (nb_modified_ram_pages >= KQEMU_MAX_MODIFIED_RAM_PAGES) {\n\n            /* flush */\n\n#ifdef _WIN32\n\n            ret = DeviceIoControl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                                  &nb_modified_ram_pages,\n\n                                  sizeof(nb_modified_ram_pages),\n\n                                  NULL, 0, &temp, NULL);\n\n#else\n\n            ret = ioctl(kqemu_fd, KQEMU_MODIFY_RAM_PAGES,\n\n                        &nb_modified_ram_pages);\n\n#endif\n\n            kqemu_reset_modified_ram_pages();\n\n        }\n\n    }\n\n}\n", "idx": 16812, "substitutes": {"env": ["cfg", "data", "f", "settings", "tty", "eth", "rc", "buffer", "environment", "en", "enc", "exec", "context", "path", "tx", "ev", "config", "e", "buf", "v", "ea", "vt", "ec", "proc", "et", "opt", "fi", "conn"], "ram_addr": ["ram_adr", "ramlmode", "ramamaddr", "ram_slice", "ramwadr", "ramladdress", "ramamurl", "ramamaddress", "ram_url", "gram_addr", "gram_slice", "ramlarm", "gram_mode", "gram_adr", "ram_arm", "ram67address", "ram67addr", "ram_ref", "gram_address", "ramladdr", "ramamslice", "ram67mode", "gram_ref", "ramwaddress", "gram_url", "ramwoffset", "gram_offset", "ramwaddr", "ram_address", "ram_offset", "ram67arm", "gram_arm", "gram_host", "ram_host", "ram_mode"], "page_index": ["page_position", "page_span", "pagefindex", "change_index", "change67design", "page_design", "pagefposition", "page_length", "page67index", " page_action", "change67span", "pageflength", " page_ind", "page__index", " page_Index", "page_action", " page_position", " page_ticket", "page__action", "change_design", "page67action", "change_span", " page_length", "page_ticket", "page67design", "change67index", "page67span", "page__ind", "page67ind", "page_Index", "page_ind"], "ret": ["part", "data", "al", "bit", "obj", "Result", "alt", "ct", "ref", "conn", "let", "reg", "nt", "rc", "rt", "fun", "result", "job", "match", "ut", "mem", "resp", "rets", "def", "out", "arg", "att", "val", "re", "Ret", " RET", "back", "id", "det", " Ret", "RET", "ure", "res", "proc", "et", "mt", "valid", "reply", "success", "len"], "temp": ["dc", "Temp", "IT", "t", "err", "f", "CC", "buffer", "result", "num", "stable", "current", "i", " temporary", "mem", "timeout", "magic", "count", "exec", "fake", "Ret", "tc", "fd", " output", "EMP", "tmp", "test", "fff", " proc", "cache", "null", "output", "ec", "proc", "EC", "iter", "valid", "cond", "input"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "static bool aio_epoll_check_poll(AioContext *ctx, GPollFD *pfds,\n\n                                 unsigned npfd, int64_t timeout)\n\n{\n\n    if (!ctx->epoll_available) {\n\n        return false;\n\n    }\n\n    if (aio_epoll_enabled(ctx)) {\n\n        return true;\n\n    }\n\n    if (npfd >= EPOLL_ENABLE_THRESHOLD) {\n\n        if (aio_epoll_try_enable(ctx)) {\n\n            return true;\n\n        } else {\n\n            aio_epoll_disable(ctx);\n\n        }\n\n    }\n\n    return false;\n\n}\n", "idx": 16829, "substitutes": {"ctx": ["pc", "dc", "cc", "txt", "fw", "fp", "obj", "cca", "jp", "cus", "ct", "cor", "vc", "ctr", "cm", "cf", "cpp", "cb", "coll", "bc", "loc", "cp", "src", "this", "scope", "ctrl", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "ce", "pkg", "nc", "tx", "ci", "tc", "xc", "config", "sc", "cu", "cam", "cl", "cli", "lc", "c", "cr", "req", "qa", "kt", "client", "cmd", "cmp", "cn", "cv", "conn", "cci"], "pfds": ["pfda", "pfdc", "pfd", " pfd", " pfsda", "pcfds", "pfsd", " pfsd", "pfsds", "pfsda", " pfda", "pcfd", " pfsds", "pcfda", " pfdc", " pfsdc", "pfsdc", "pcfdc"], "npfd": [" tcpfc", "wpdf", "NPdf", "npf", "wpbf", "wpdc", " tcpfd", "NPdc", "NPfc", "vpFD", "fpf", "npfc", "npFD", "wpFD", "fpbf", "vpbf", "vpfd", "wpf", "wpfc", "NPfd", "fpFD", "wpfd", " tcpdc", "fpfd", "npbf", "npdc", " tcpdf", "npdf", "vpf"], "timeout": ["time", "name", "call", "base", "options", "err", "pool", "duration", "wait", "block", "cb", "max", "sec", "after", "out", "val", " max", "size", "args", "outs", "delay", "Timeout", "unit", "cache", "conn"]}}
{"project": "qemu", "commit_id": "83e6813a93e38976391b8c382c3375e3e188df3e", "target": 0, "func": "static void aarch64_cpu_register_types(void)\n\n{\n\n    int i;\n\n\n\n    type_register_static(&aarch64_cpu_type_info);\n\n    for (i = 0; i < ARRAY_SIZE(aarch64_cpus); i++) {\n\n        aarch64_cpu_register(&aarch64_cpus[i]);\n\n    }\n\n}\n", "idx": 16842, "substitutes": {"i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "code", "info", "x", "f", "ix", "ini", "qi", "io", "mi", "n", "ai", "phi", "g", "block", "hi", "z", "ii", "in", "di", "index", "iu", "slice", "I", "multi", "zi", "count", "o", "l", "d", "val", "oi", "diff", "pi", "ui", "ci", "abi", "length", "id", "start", "e", "k", "v", "lc", "c", "ni", "si", "ri", "p", "xi", "b", "u", "h", "fi", "li", "mu"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void musicpal_lcd_write(void *opaque, target_phys_addr_t offset,\n\n                               uint64_t value, unsigned size)\n\n{\n\n    musicpal_lcd_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_LCD_IRQCTRL:\n\n        s->irqctrl = value;\n\n        break;\n\n\n\n    case MP_LCD_SPICTRL:\n\n        if (value == MP_LCD_SPI_DATA || value == MP_LCD_SPI_CMD) {\n\n            s->mode = value;\n\n        } else {\n\n            s->mode = MP_LCD_SPI_INVALID;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_INST:\n\n        if (value >= MP_LCD_INST_SETPAGE0 && value <= MP_LCD_INST_SETPAGE7) {\n\n            s->page = value - MP_LCD_INST_SETPAGE0;\n\n            s->page_off = 0;\n\n        }\n\n        break;\n\n\n\n    case MP_LCD_DATA:\n\n        if (s->mode == MP_LCD_SPI_CMD) {\n\n            if (value >= MP_LCD_INST_SETPAGE0 &&\n\n                value <= MP_LCD_INST_SETPAGE7) {\n\n                s->page = value - MP_LCD_INST_SETPAGE0;\n\n                s->page_off = 0;\n\n            }\n\n        } else if (s->mode == MP_LCD_SPI_DATA) {\n\n            s->video_ram[s->page*128 + s->page_off] = value;\n\n            s->page_off = (s->page_off + 1) & 127;\n\n        }\n\n        break;\n\n    }\n\n}\n", "idx": 16862, "substitutes": {"opaque": ["copaques", "ipec", "operacity", "oponymous", "ipque", "copaque", "copec", "pque", "OPonymous", "opec", "opacity", "OPque", "operaque", "ospacity", "ipaques", "paques", "operque", "paque", "OPaque", "operonymous", "copque", "ipaque", "pec", "OPacity", "opaques", "ospaque", "osponymous", "opque", "ospque"], "offset": ["set", "scale", "skip", "data", "mode", "Offset", "bit", "fp", "f", "attribute", "from", "align", "option", "num", "reference", "padding", "index", "pos", "timeout", "pointer", "o", "ip", "location", "slot", "aque", "alias", "oid", "seed", "reset", "prefix", "length", "start", "parent", "position", "p", "off", "address", "pad", "shift", "error", "addr", "port", "operation"], "value": ["set", "element", "volume", "comment", "service", "money", "num", "max", "reference", "padding", "always", "non", "no", "length", "id", "VALUE", "total", "area", "feature", "resource", "none", "va", "end", "valid", "command", "values", "m", "scale", "Value", "name", "media", "done", "timeout", "description", "style", "flow", "key", "when", "v", "off", "null", "iv", "port", "expression", "native", "image", "current", "block", "ou", "type", "node", "function", "vi", "home", "page", "gap", "val", "array", "email", "memory", "w", "ue", "start", "amount", "selected", "address", "fee", "version", "hello", "data", "mode", "info", "buffer", "option", "i", "index", "member", "create", "format", "complete", "unit", "wa", "number", "message", "server"], "size": ["set", "scale", "data", "SIZE", "buffer", "type", "padding", " amount", " bytes", "count", " address", " error", "ize", "length", "address", "fee", " buffer", "bytes", "Size", " length", "len"], "s": ["ns", "spec", "strings", "settings", "service", "ss", "copy", "cs", "d", "new", "sym", "p", "h", "us", "sets", "comments", "source", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "a", "hs", "port", "ds", "status", "uns", "f", "r", "sb", "uploads", "this", "l", "ins", "sync", "c", "ps", "secondary", "sum", "sys", "your", "es", "state", "states", "sq", "params", "sf", "session", "t", "data", "conf", "services", "n", "plugins", "g", "sl", "ls", "ops", "fs", "is", "sites", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"]}}
{"project": "qemu", "commit_id": "3b2e934463121f06d04e4d17658a9a7cdc3717b0", "target": 0, "func": "static inline uint32_t nvic_gprio_mask(NVICState *s)\n\n{\n\n    return ~0U << (s->prigroup + 1);\n\n}\n", "idx": 16870, "substitutes": {"s": ["types", "m", "ts", "session", "stats", "rates", "request", "rs", "f", "t", "settings", "services", "input", "sb", "ss", "ops", "sec", "self", "cs", "args", "qs", "ssl", "sync", "ses", "private", "c", "sym", "p", "secondary", "S", "gs", "sys", "es", "sets", "states", "sq", "south", "ds", "u"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "int qemu_eventfd(int fds[2])\n\n{\n\n#ifdef CONFIG_EVENTFD\n\n    int ret;\n\n\n\n    ret = eventfd(0, 0);\n\n    if (ret >= 0) {\n\n        fds[0] = ret;\n\n        qemu_set_cloexec(ret);\n\n        if ((fds[1] = dup(ret)) == -1) {\n\n            close(ret);\n\n            return -1;\n\n        }\n\n        qemu_set_cloexec(fds[1]);\n\n        return 0;\n\n    }\n\n\n\n    if (errno != ENOSYS) {\n\n        return -1;\n\n    }\n\n#endif\n\n\n\n    return qemu_pipe(fds);\n\n}\n", "idx": 16879, "substitutes": {"fds": ["fordds", " fns", "dd", "cfks", "dds", "rfdr", "cdds", "Fdds", "forls", "fks", "fdds", "fls", " fDS", "cfDS", "rfipes", "fns", " fdb", "rfds", " fd", "afks", "cfds", " fks", "fdr", "dfdb", "forda", " fdds", "fdd", "fords", "ffds", "afls", "FDS", "ffls", "ffda", "ddds", "Fds", "cns", "dns", "dfipes", "cds", "fd", "dfds", " fipes", "fdb", "rfls", "ffdds", "rfdb", "afdd", "rfdd", "afds", "Fks", " fda", "rfks", "cd", "fDS", "fda", " fls", "fipes", " fdr", "cfdds", "dfdr", " fdd"], "ret": ["status", "part", "code", "data", "info", "obj", "f", "ref", "bit", "alt", "reg", "nt", "rc", "rt", "fun", "result", "num", "str", "job", "sb", "flag", "ext", "fin", "done", "run", "active", "def", "rets", "art", "att", "arr", "exec", "arg", "val", "re", "linux", "Ret", "format", "fail", "back", "no", "id", "det", "sr", "fd", "rev", "cat", "temp", "lib", "repl", "RET", "next", "pet", "res", "rep", "mt", "ft", "valid", "reply", "success", "len"]}}
{"project": "qemu", "commit_id": "77a5a0001bd9eaee9da7dc8f0b69702d56b0cc67", "target": 0, "func": "static int bdrv_qed_truncate(BlockDriverState *bs, int64_t offset)\n\n{\n\n    return -ENOTSUP;\n\n}\n", "idx": 16888, "substitutes": {"bs": ["ns", "ts", "lbs", "rs", "obj", "sb", "ss", "bc", "ls", "bt", "fs", "pb", "bb", "ba", "bid", "cs", "bos", "BS", "iss", "bis", "vs", "bh", "ses", "ps", "gs", "os", "sa", "ds"], "offset": ["data", "fp", "Offset", "base", "ref", "f", "num", "block", "padding", "index", "pos", "timeout", "count", "pointer", "bound", "ip", "slot", "reset", "length", "start", "limit", "position", "off", "p", "address", "shift", "addr", "len"]}}
{"project": "qemu", "commit_id": "3d0be8a5c135dadcfbd68ed354007a8cece98849", "target": 0, "func": "void HELPER(wsr_ibreakenable)(uint32_t v)\n\n{\n\n    uint32_t change = v ^ env->sregs[IBREAKENABLE];\n\n    unsigned i;\n\n\n\n    for (i = 0; i < env->config->nibreak; ++i) {\n\n        if (change & (1 << i)) {\n\n            tb_invalidate_phys_page_range(\n\n                    env->sregs[IBREAKA + i], env->sregs[IBREAKA + i] + 1, 0);\n\n        }\n\n    }\n\n    env->sregs[IBREAKENABLE] = v & ((1 << env->config->nibreak) - 1);\n\n}\n", "idx": 16890, "substitutes": {"v": ["m", "V", "s", "t", "x", "f", "sv", "r", "n", "g", "lv", "uv", "l", "val", "d", "change", "conv", "w", "ev", "e", "k", "vs", "q", "c", "tv", "p", "vt", "b", "vv", "h", "iv", "env", "value", "version", "u"], "i": ["gi", "uri", "ti", "m", "bi", "j", "t", "x", "f", "jp", "ix", "ini", "qi", "ai", "io", "phi", "g", "hi", "z", "ii", "ie", "di", "index", "iu", "slice", "I", "o", "ip", "page", "chi", "l", "d", "change", "oi", "pi", "ui", "ci", "abi", "id", "start", "e", "k", "c", "si", "ri", "p", "xi", "b", "a", "li", "u"]}}
{"project": "qemu", "commit_id": "ce5b1bbf624b977a55ff7f85bb3871682d03baff", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924, "substitutes": {"oc": ["pc", "org", "rog", "ob", "rc", "inc", "acc", "oca", "anc", "toc", "loc", "ocr", "aco", "oper", "fc", "mc", "abc", "object", "o", "auc", "roc", "usc", "nc", "ac", "oid", "oci", "config", "soc", "ucc", "c", "uc", "oco", "ec", "alloc", "oo", "OC", "co", "voc"], "data": ["Data", "dd", "record", "func", "inc", "coll", "di", "bb", "def", "ee", "design", "d", "config", "ad", "da", "doc", "cache", "fee", "dat", "cd", "DATA", "co", "desc", "ds"], "occ": ["org", "ct", "coe", "rc", "ai", "cm", "inc", "bec", "acc", "exc", "oca", "nec", "cf", "coll", "anc", "bc", "loc", "aco", "fc", "mc", "abc", "ae", "auc", "ca", "roc", "rec", "usc", "nc", "ac", "oci", "aa", "rn", "xc", "ucc", "cl", "oe", "c", "account", "uc", "misc", "ec", "proc", "ace", "OC", "co", "circ", "Occ", "cci"], "cc": ["pc", "ect", "code", "func", "che", "cca", "cus", "vc", "CC", "ct", "rc", "gc", "cm", "inc", "bec", "cf", "acc", "coll", "bc", "cp", "PC", "fc", "mc", "ctx", "abc", "self", "ctrl", "ca", "cs", "pg", "roc", "cms", "ce", "nc", "ac", "go", "cel", "DC", "ci", "con", "xc", "tc", "config", "sc", "cu", "ga", "ucc", "client", "cl", "c", "lc", " gcc", "uc", "ck", "cache", "ec", "cd", "WC", "cn", "cast", "co", " CC", "kk", "cci"], "dc": ["pc", "dn", "db", "cdn", "cca", "vc", "rc", "duc", "inc", "de", "cf", "acc", "anc", "bc", "dt", "fc", "mc", "di", "design", "d", "df", "nc", "ac", "disc", "DC", "tc", "bd", "fd", "ga", "ucc", "c", "da", "uc", "cmd", "doc", "ck", "dat", "ec", "cd", "conn", "ds", "director"]}}
{"project": "qemu", "commit_id": "d99598cc9929ad6993ad3d19d9b1ec1d891f0d7f", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930, "substitutes": {"opaque": ["oppacs", "operacity", "oponymous", "oopac", "oppac", "OPonymous", "opac", "opacity", "ipac", "oppaque", "ooponymous", "OPacs", "operaque", "oopacity", "OPaques", "opacs", "ipaques", "oppaques", "OPaque", "operonymous", "ipaque", "OPac", "OPacity", "operac", "opaques", "oopaque", "ipacs"], "addr": ["set", "offset", "s", "code", "Address", "data", "rs", "mode", "base", "ref", "name", "eth", "r", "align", "str", "ast", "oa", "src", "localhost", "ctx", "ptr", "pos", "pointer", "ip", "enc", "host", "inet", "array", " address", "alias", "nc", "size", "ac", "args", "socket", "config", "ad", "prefix", "dr", "id", "asm", "buf", "start", "seq", "p", "address", "adr", "alloc", "proc", "ace", "opt", "ha", "mac", "server", "attr", "conn", "amp", "len"], "f": ["m", "fr", "fw", "s", "j", "t", "fp", "info", "af", "fe", "r", "file", "fun", "fa", "n", "feed", "cf", "g", "i", "z", "fc", "fs", "rf", "fen", "o", "fo", "l", "fx", "d", "inf", "bf", "w", "fd", "e", "fb", "v", "F", "p", "b", "tf", "fn", "u", "h", "form", "fi", "sf"], "c": ["dc", "pc", "m", " C", "s", "ch", "code", "t", "x", "call", "ct", "conn", "rc", "r", "n", "cm", "cf", "i", "cb", "z", "bc", "ctx", "fc", "mc", "count", "cy", "o", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "tc", "xc", "w", "e", "k", "con", "cr", "cl", "lc", "v", "p", "uc", "b", "cache", "col", "ec", " rc", "unc", "cd", "a", "C", "cc", "u"]}}
{"project": "qemu", "commit_id": "a9db86b223030bd40bdd81b160788196bc95fe6f", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933, "substitutes": {"dest": ["dc", "txt", "outer", "nexus", "text", "destroy", "rest", " destination", "delete", "result", "master", "usr", "src", "node", "loc", "orig", "wb", "this", "slice", "done", "package", "self", "object", "home", "class", "later", "cont", "new", "diff", "feat", "img", "config", "remote", "temp", "parent", "tmp", "trans", "access", "dist", "resource", "route", "folder", "opt", "inst", "Dest", "origin", "end", "desc", "transfer", "target"], "source": ["uri", "spec", "session", "s", "request", "info", "core", "SOURCE", "google", "text", "component", "plus", "sort", "scene", "service", "from", "result", "current", "package", "src", "reference", "ie", "this", "effect", "scope", "slice", "self", "Source", "object", "other", "range", "secure", "new", "size", "grade", "seed", "ui", "site", "use", "comp", "config", "id", "start", "e", "sc", "remote", "parent", "ource", "unit", "feature", "resource", "subject", "interface", "origin", "project", "iter", "server", "inner", "target"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "t", "info", "x", "f", "jp", "name", "ix", "ini", "qi", "io", "ai", "n", "z", "ii", "ie", "iu", "index", "di", "I", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "e", "k", "v", "cli", "ni", "c", "si", "isi", "ri", "p", "xi", "lc", "b", "uli", "a", "api", "iv", "it", "eni", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "b00fb157bae79f9735910064585fd95b8c123003", "target": 0, "func": "static int decode_sgirle8(AVCodecContext *avctx, uint8_t *dst, const uint8_t *src, int src_size, int width, int height, int linesize)\n\n{\n\n    const uint8_t *src_end = src + src_size;\n\n    int x = 0, y = 0;\n\n\n\n#define INC_XY(n) \\\n\n    x += n; \\\n\n    if (x >= width) { \\\n\n        y++; \\\n\n        if (y >= height) \\\n\n            return 0; \\\n\n        x = 0; \\\n\n    }\n\n\n\n    while (src_end - src >= 2) {\n\n        uint8_t v = *src++;\n\n        if (v > 0 && v < 0xC0) {\n\n            do {\n\n                int length = FFMIN(v, width - x);\n\n                memset(dst + y*linesize + x, RGB332_TO_BGR8(*src), length);\n\n                INC_XY(length);\n\n                v   -= length;\n\n            } while (v > 0);\n\n            src++;\n\n        } else if (v >= 0xC1) {\n\n            v -= 0xC0;\n\n            do {\n\n                int length = FFMIN3(v, width - x, src_end - src);\n\n                if (src_end - src < length)\n\n                    break;\n\n                memcpy_rgb332_to_bgr8(dst + y*linesize + x, src, length);\n\n                INC_XY(length);\n\n                src += length;\n\n                v   -= length;\n\n            } while (v > 0);\n\n        } else {\n\n            avpriv_request_sample(avctx, \"opcode %d\", v);\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 16984, "substitutes": {"avctx": ["Avcoll", "avca", "awctx", "afca", "avcoll", "avpkg", "aircontext", "awcontext", "akcontext", "afcontext", "Avcontext", "awca", "avconn", "afctx", "airconn", "awconn", "afconn", "akpkg", "akcoll", "airca", "Avpkg", "akctx", "afcoll", "afpkg", "Avctx", "avcontext", "airctx"], "dst": ["sdost", "bST", "dsp", "Dst", " dsp", "fdost", "bst", "birst", "datsrc", "datost", "dsrc", " dcp", "fdsp", "Dsc", "Dsrc", "sdsp", "DST", "Ddest", "Dirst", " dost", "ddest", "dsc", "sdst", "Dost", "datst", "lst", " ddest", "fdst", " dsrc", "dost", "dcp", "sdcp", "lST", "lsc", "datdest", "bsc", "dST", "lirst", "dirst", "fdcp"], "src": ["x", "vr", "pl", "supp", "sec", "uv", "gb", "stack", "rib", "comp", "config", "length", "gl", "lib", "rect", "source", "cv", "sup", "sur", "rs", "rest", "dest", "rc", "stream", "bc", "inf", "sub", "sc", "v", "uc", "gz", "iv", "image", "sv", "https", "sb", "cb", "loc", "sel", "ind", "host", "go", "sn", "sr", "start", "buf", "sync", "rl", "rss", "b", "inst", "ser", "sq", "s", "syn", "sl", "z", "fc", "slice", "en", "conv", "seed", "st", "hl", "img", "ssl", "cur", "insert", "rb", "seq", "support", "url", "ur", "server", "attr", "dist"], "src_size": ["source_size", " src_len", "src_scale", "source_scale", "source_len", "src_len", " src_scale"], "height": ["thin", "work", "shape", "view", "x", "window", "max", "padding", "dim", "d", "size", "dy", "w", "length", "flow", "img", "high", "rows", "Height", "pad", "depth", "h", "level", "row", "y"], "linesize": ["odesized", " linesiz", "worksize", "worksizes", " linesizing", "nosiz", " linespace", "rulesizes", "pagesizer", "rowssize", "nosized", "odesize", "nosizing", "pagesize", "rowsizing", "odesiz", "linessize", " linesizes", "pagesizing", "linespace", "worksizing", "rowsize", " linesized", "nosize", "rulespace", "linesizer", "linesizing", "odesizing", "linesized", " linessize", "rulesizing", "pagessize", "linesiz", " linesizer", "rulesize", "linesizes", "rowsizer", "workspace"], "src_end": ["source_start", "src_ends", "src_begin", "source_end", "src_ending", "source_begin", "src_start", "rc_ending", "source_ends", "rc_end", "rc_ends", "source_ending", "rc_start"]}}
{"project": "FFmpeg", "commit_id": "9aa0606e87a221eba935ed675c1cd5ca94832e28", "target": 0, "func": "static int hls_read_seek(AVFormatContext *s, int stream_index,\n\n                               int64_t timestamp, int flags)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i;\n\n    int64_t seek_timestamp;\n\n    int valid_for = -1;\n\n\n\n    if ((flags & AVSEEK_FLAG_BYTE) || !c->variants[0]->playlists[0]->finished)\n\n        return AVERROR(ENOSYS);\n\n\n\n    seek_timestamp = stream_index < 0 ? timestamp :\n\n                     av_rescale_rnd(timestamp, AV_TIME_BASE,\n\n                                    s->streams[stream_index]->time_base.den,\n\n                                    flags & AVSEEK_FLAG_BACKWARD ?\n\n                                    AV_ROUND_DOWN : AV_ROUND_UP);\n\n\n\n    if (s->duration < seek_timestamp)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* check first that the timestamp is valid for some playlist */\n\n        struct playlist *pls = c->playlists[i];\n\n        int seq_no;\n\n        if (find_timestamp_in_playlist(c, pls, seek_timestamp, &seq_no)) {\n\n            /* set segment now so we do not need to search again below */\n\n            pls->cur_seq_no = seq_no;\n\n            valid_for = i;\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (valid_for < 0)\n\n        return AVERROR(EIO);\n\n\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        /* Reset reading */\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->input) {\n\n            ffurl_close(pls->input);\n\n            pls->input = NULL;\n\n        }\n\n        av_free_packet(&pls->pkt);\n\n        reset_packet(&pls->pkt);\n\n        pls->pb.eof_reached = 0;\n\n        /* Clear any buffered data */\n\n        pls->pb.buf_end = pls->pb.buf_ptr = pls->pb.buffer;\n\n        /* Reset the pos, to let the mpegts demuxer know we've seeked. */\n\n        pls->pb.pos = 0;\n\n\n\n        pls->seek_timestamp = seek_timestamp;\n\n        pls->seek_flags = flags;\n\n\n\n        /* set closest segment seq_no for playlists not handled above */\n\n        if (valid_for != i)\n\n            find_timestamp_in_playlist(c, pls, seek_timestamp, &pls->cur_seq_no);\n\n    }\n\n\n\n    c->cur_timestamp = seek_timestamp;\n\n\n\n    return 0;\n\n}\n", "idx": 16986, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "t", "rs", "aws", "conf", "f", "sv", "settings", "services", "r", "service", "n", "sb", "g", "sl", "ss", "ls", "fs", "xs", "o", "cs", "l", "d", "su", "e", "ssl", "sc", "ses", "v", "sync", "js", "si", "p", "S", "ks", "b", "cache", "gs", "params", "sys", "u", "es", "sets", "sq", "sa", "ds", "sf"], "stream_index": ["streamidcolumn", "streamingmodule", "stream_offset", "draftersize", "streamerindex", "channel_column", "drafterindex", "stream_column", "draft_index", "streamidmodule", "streamingposition", "streamidpath", "streamsindex", "streamingcount", "draft_key", "streamidindex", "streamerkey", "stream_Index", "streamingIndex", "streamidposition", "stream_position", "seqingIndex", "streamskey", "seq_path", "channelingindex", "streamidcount", "channel_module", "stream_key", "stream_path", "streamingpath", "streameroffset", "drafterkey", "streamsoffset", "stream_module", "streamidIndex", "streamingcolumn", "stream_size", "streamingindex", "seq_Index", "channel_position", "streamssize", "seqingcount", "channelingcolumn", "seq_index", "seqingindex", "drafteroffset", "draft_offset", "channel_index", "seq_count", "channelingposition", "seqingpath", "stream_count", "draft_size", "streamersize", "channelingmodule"], "timestamp": ["nameto", "timeest", " Timestamp", "Timoffset", "simoffset", "namestamp", " Timetime", "simest", "momeline", "simeline", "timeto", "timeestamp", "dimest", "mometime", "Timest", " Timeline", "Timetime", "timetime", "nameline", "timoffset", "dimestamp", "timest", "timeetime", "timeline", "Timeline", "Timestamp", "mometo", "nametime", " Timest", "simestamp", "momestamp", "dimoffset", "dimeline", "timeeline", "Timeto"], "flags": ["types", "status", "strings", "ts", "offset", "planes", "fps", "stats", "FLAG", "f", "fields", "settings", "options", "faces", "Flags", "details", "vals", "forces", "flag", "ips", "files", "ats", "ints", "utils", "ops", "items", "fs", "mask", "xs", "mods", "lf", "links", "fl", "offs", "args", "features", "fts", "fd", "vs", "sf", "frames", "alls", "bits", "atts", "lag", "fee", "events", "ids", "ants", "reads", "rules", "bytes", "groups", "parts", "locks"], "c": ["dc", "pc", "ic", "m", "ch", "t", "conf", "f", "ct", "vc", "r", "cm", "n", "cf", "g", "coll", "bc", "cp", "z", "ctx", "fc", "mc", "self", "ctrl", "cy", "ca", "enc", "cs", "context", "l", "d", "ce", "nc", "ac", "ci", "com", "con", "config", "e", "cu", "k", "sc", "cr", "v", "lc", "cl", "cur", "client", "p", "cache", "b", "ec", "cd", "h", "co", "C", "cc", "u"], "i": ["ti", "uri", "gi", "m", "bi", "init", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "io", "phi", "hi", "z", "ii", "ie", "ski", "iu", "index", "pos", "di", "I", "ind", "multi", "zi", "count", "min", "my", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "no", "id", "key", "e", "start", "v", "lc", "ni", "si", "ri", "p", "xi", "b", "mu", "anti", "field", "u", "eni", "me", "fi", "inner", "y", "li", "len"], "seek_timestamp": ["seek_romework", "seek_timeto", "seek_tmestamp", "seek_stimestamp", "seek_comestamp", "seek_stimperature", "seek___timeline", "seek_soundestamp", "seek_metest", "seek_tmeto", "seek_timension", "seek_typeno", "seek_stimetz", "seek_tunestamp", "seek_framperature", "seek_tmment", "seek_timment", "seek_metestamp", "seek_timest", "seek_Timeline", "seek___soundetr", "seek___soundeline", "seek_rimination", "seek_imeline", "seek_soundetr", "seek_Timeno", "seek_gamment", "seek_tuneline", "seek_rimestamp", "seek_stimetr", "seek_framestamp", "seek_tmetr", "seek_meteto", "seek_Timination", "seek_tunetime", "seek_cometo", "seek_tmeline", "seek_timperature", "seek_framest", "seek_tmest", "seek_tmetz", "seek_tmeno", "seek_timetime", "seek_Timension", "seek_Timest", "seek_Timework", "seek_typestamp", "seek___soundestamp", "seek_timination", "seek_rimework", "seek_typest", "seek_romestamp", "seek_Timperature", "seek_tmetime", "seek_timework", "seek_romest", "seek_soundetz", "seek___soundetz", "seek_timeline", "seek_typeline", "seek_imetz", "seek_rimest", "seek_Timetz", "seek_gametz", "seek_metension", "seek___timetr", "seek_stimest", "seek_imestamp", "seek_timetr", "seek_stimeline", "seek_imment", "seek_comension", "seek_tuneto", "seek___timestamp", "seek_gameline", "seek___timetz", "seek_soundeline", "seek_timetz", "seek_timeno", "seek_stimetime", "seek_Timestamp", "seek_gamestamp", "seek_romination", "seek_comest", "seek_frametz", "seek_Timeto", "seek_stimeto"], "pls": ["phs", "PLs", "flf", "splcs", "plses", "plns", "plcs", "fls", "Plf", "pulld", "PLsets", "Plds", "vels", "Plp", "Pljs", " pli", "ppses", "otherp", "plf", "velabs", "celp", " plgs", "cli", "phds", "flc", "plds", "cols", "PLcs", "platforms", "pgsets", "pers", "putb", "ucds", "velsets", "plis", "platformp", "putcs", "pgp", "impls", "others", "Plses", "putsg", "velp", "peri", "splsets", "slp", "slis", "PLt", " plns", "ucs", "plsg", "cels", "implp", "ledses", "colches", "otherns", "clb", " plabs", "splp", " pljs", "perches", "plabs", " plsets", "PLses", "prs", "splgs", "cls", "phsets", "bls", "flses", "spljs", "plsets", "controlt", "PLd", "ucp", "coli", "plgs", "ledi", "Plc", "plp", " plb", "plt", "ppd", "splds", "implns", "prd", "celi", "ppf", "pps", " plis", "pgs", " plp", "plb", "splf", "compls", "controlsets", "PLb", " plds", "celses", "pld", " plf", " pld", "Pls", " plches", "phgs", "pullf", "puti", "complses", " plses", "sls", "prb", "bli", "fli", "leds", "pulls", "pljs", "spls", "splb", "celis", "pht", "compld", "splabs", "controls", "spld", "plc", " plc", "platformsets", "blsg", "plches", "php", "pli", " plsg", "flb"], "seq_no": ["seqIDlength", "seqsNo", " seq_number", "seqingnumber", "seqingmax", "sequence_no", " seq_No", "seqIDfrom", "seqgno", "seqsno", "seqingfrom", "seq_from", "seq_max", "seqgfrom", "sequence_length", "seqJfrom", "seqingno", "seq_No", "seqJmax", "sequence_max", "seqsnumber", "sequence_number", "seqglength", "seqIDno", "seqJnumber", "seqJno", "sequence_from", "seq_length", "seq_number"]}}
{"project": "qemu", "commit_id": "6877cff044cdf6da66885eab62363baf98bb39ee", "target": 0, "func": "static int assigned_initfn(struct PCIDevice *pci_dev)\n\n{\n\n    AssignedDevice *dev = DO_UPCAST(AssignedDevice, dev, pci_dev);\n\n    uint8_t e_intx;\n\n    int r;\n\n    Error *local_err = NULL;\n\n\n\n    if (!kvm_enabled()) {\n\n        error_report(\"pci-assign: error: requires KVM support\");\n\n        return -1;\n\n    }\n\n\n\n    if (!dev->host.domain && !dev->host.bus && !dev->host.slot &&\n\n        !dev->host.function) {\n\n        error_report(\"pci-assign: error: no host device specified\");\n\n        return -1;\n\n    }\n\n\n\n    /*\n\n     * Set up basic config space access control. Will be further refined during\n\n     * device initialization.\n\n     */\n\n    assigned_dev_emulate_config_read(dev, 0, PCI_CONFIG_SPACE_SIZE);\n\n    assigned_dev_direct_config_read(dev, PCI_STATUS, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_REVISION_ID, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CLASS_PROG, 3);\n\n    assigned_dev_direct_config_read(dev, PCI_CACHE_LINE_SIZE, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_LATENCY_TIMER, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_BIST, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_CARDBUS_CIS, 4);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_VENDOR_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_SUBSYSTEM_ID, 2);\n\n    assigned_dev_direct_config_read(dev, PCI_CAPABILITY_LIST + 1, 7);\n\n    assigned_dev_direct_config_read(dev, PCI_MIN_GNT, 1);\n\n    assigned_dev_direct_config_read(dev, PCI_MAX_LAT, 1);\n\n    memcpy(dev->emulate_config_write, dev->emulate_config_read,\n\n           sizeof(dev->emulate_config_read));\n\n\n\n    get_real_device(dev, &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    if (assigned_device_pci_cap_init(pci_dev, &local_err) < 0) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* intercept MSI-X entry page in the MMIO */\n\n    if (dev->cap.available & ASSIGNED_DEVICE_CAP_MSIX) {\n\n        assigned_dev_register_msix_mmio(dev, &local_err);\n\n        if (local_err) {\n\n            qerror_report_err(local_err);\n\n            error_free(local_err);\n\n            goto out;\n\n        }\n\n    }\n\n\n\n    /* handle real device's MMIO/PIO BARs */\n\n    assigned_dev_register_regions(dev->real_device.regions,\n\n                                  dev->real_device.region_number, dev,\n\n                                  &local_err);\n\n    if (local_err) {\n\n        qerror_report_err(local_err);\n\n        error_free(local_err);\n\n        goto out;\n\n    }\n\n\n\n    /* handle interrupt routing */\n\n    e_intx = dev->dev.config[PCI_INTERRUPT_PIN] - 1;\n\n    dev->intpin = e_intx;\n\n    dev->intx_route.mode = PCI_INTX_DISABLED;\n\n    dev->intx_route.irq = -1;\n\n\n\n    /* assign device to guest */\n\n    r = assign_device(dev);\n\n    if (r < 0) {\n\n        goto out;\n\n    }\n\n\n\n    /* assign legacy INTx to the device */\n\n    r = assign_intx(dev);\n\n    if (r < 0) {\n\n        goto assigned_out;\n\n    }\n\n\n\n    assigned_dev_load_option_rom(dev);\n\n\n\n    add_boot_device_path(dev->bootindex, &pci_dev->qdev, NULL);\n\n\n\n    return 0;\n\n\n\nassigned_out:\n\n    deassign_device(dev);\n\nout:\n\n    free_assigned_device(dev);\n\n    return -1;\n\n}\n", "idx": 16999, "substitutes": {"pci_dev": ["pki2ev", "pci2ev", "pci_ev", "pcli_device", "pki_div", "pki2div", "pci2device", "pki2device", "pki_ev", "pci2div", "pci_div", "pcli_dev", "pki2dev", "pcli_div", "pcli_ev", "pki_dev", "pci2dev", "pki_device", "pci_device"], "dev": ["grad", "spec", "dd", "user", "gd", "comment", "gu", "debug", "result", "gh", "var", "enc", "exec", "d", "ev", "config", "prof", "ov", "p", "od", "h", "boot", "serial", "end", "valid", "die", "ve", "conn", "Dev", "mod", "pub", "engine", "de", "rad", "devices", "app", "nov", "wd", "develop", "development", "self", "hw", "vol", "adv", "v", "dom", "dis", "off", "ver", "dc", "err", "f", "block", "root", "this", "di", "model", "prom", "home", "host", "compl", "w", "ad", "device", "inst", "dem", "priv", "pro", "bug", "ch", "data", "info", "conf", "g", "module", "ow", "def", "cam", "client", "req", "cmd", "driver", "error", "DEV", "diff"], "e_intx": ["e_id32", "e_ind32", "e_intX", "e_idX", "e_indx", "e_idx", "e_int32", "e_ntX", "e_indX", "e_nt32", "e_ntx"], "r": ["ror", "m", "s", "rs", "f", "err", "rc", "n", "R", "trace", "or", "ptr", "ry", "l", "d", "w", "e", "lr", "cr", "c", "p", "error", "h", "a", "Error"], "local_err": ["remote_exc", "local_", " local\n", "Local\n", "local2err", "local2error", "local\n", "remote_err", "global\n", " local_", "local2rr", "local2exc", "local_exc", "remote_rr", "Local_", "remote_error", "global_", "local_error", "local_rr"]}}
{"project": "qemu", "commit_id": "a2db2a1edd06a50b8a862c654cf993368cf9f1d9", "target": 0, "func": "int xen_be_send_notify(struct XenDevice *xendev)\n\n{\n\n    return xc_evtchn_notify(xendev->evtchndev, xendev->local_port);\n\n}\n", "idx": 17004, "substitutes": {"xendev": ["xendedev", "xndew", "xendedenc", "wxendedev", "exendew", "wxendev", "wxendenc", "xstartew", "xndev", "xendedep", "xndep", "xendedew", "exndew", "xdov", "exendov", "exendev", "exnddev", "xstartov", "exendever", "xdever", "xendep", "xstartdev", "xendenc", "wxendedenc", "xendingev", "xendedever", "wxendep", "xendew", "xndenc", "xndov", "wxenddev", "xendever", "exndov", "exndever", "wxendedep", "xenddev", "xnddev", "wxendeddev", "xddev", "xendingenc", "xendeddev", "exndev", "exenddev", "xendov", "xendingep", "xdev", "xstartev", "xendedov", "xndever", "xendingdev"]}}
{"project": "FFmpeg", "commit_id": "1e901ffc619459944ae7102428f48972cd899caa", "target": 0, "func": "static int64_t wrap_timestamp(AVStream *st, int64_t timestamp)\n\n{\n\n    if (st->pts_wrap_behavior != AV_PTS_WRAP_IGNORE && st->pts_wrap_bits < 64 &&\n\n        st->pts_wrap_reference != AV_NOPTS_VALUE && timestamp != AV_NOPTS_VALUE) {\n\n        if (st->pts_wrap_behavior == AV_PTS_WRAP_ADD_OFFSET &&\n\n            timestamp < st->pts_wrap_reference)\n\n            return timestamp + (1ULL<<st->pts_wrap_bits);\n\n        else if (st->pts_wrap_behavior == AV_PTS_WRAP_SUB_OFFSET &&\n\n            timestamp >= st->pts_wrap_reference)\n\n            return timestamp - (1ULL<<st->pts_wrap_bits);\n\n    }\n\n    return timestamp;\n\n}\n", "idx": 17009, "substitutes": {"st": ["ist", "est", "ts", "s", "nd", "t", "data", "rest", "ct", "ste", "td", "str", "stable", "sb", "ost", "stream", "sl", "ast", "ss", "src", "ut", "public", "upt", "this", "th", "ld", "gest", "ST", "sd", "sta", "sm", "art", "rd", "class", "std", "sh", "first", "stack", "stop", "sed", "back", "ad", "start", "sc", "bl", "sth", "cl", "vest", "stage", "support", "ust", "sts", "St", "inst", "sign", "cast", "end", "ft", "asts", "sa"], "timestamp": ["timcision", "timtime", "imension", "semestamp", "mompoint", "timporal", "stimuntil", "imetime", "uuessed", "magpoint", "semempt", "Timeless", "timuntil", "nampoint", "mometime", "sequessed", "timempt", "nametime", "serveless", "momestamp", "timeest", "timension", "numestamp", "timeeless", "numporal", "stimestamp", "temuration", "numeline", "magcision", "semetime", "timeestamp", "sequeless", "sequpoint", "uuestamp", "servestamp", "timeless", "numest", "tmeline", "timeline", "stimetz", "metension", "temcision", "semension", "uueless", "imeline", "imtime", "namestamp", "Timessed", "semcision", "servuntil", "tempoint", "temestamp", "sempoint", "timpoint", "tmest", "uupoint", "Timest", "magempt", "timepoint", "timetz", "imestamp", "Timpoint", "timuration", "servetz", "metpoint", "magestamp", "temetime", "temempt", "impoint", "tmporal", "timessed", "sequestamp", "metetime", "timeetz", "metestamp", "timeuntil", "timetime", "timest", "namuration", "imest", "imporal", "stimeless", "Timestamp", "Timtime", "momuration", "tmestamp"]}}
{"project": "qemu", "commit_id": "41a2b9596c9ed2a827e16e749632752dd2686647", "target": 0, "func": "static void ide_atapi_cmd_reply_end(IDEState *s)\n\n{\n\n    int byte_count_limit, size, ret;\n\n#ifdef DEBUG_IDE_ATAPI\n\n    printf(\"reply: tx_size=%d elem_tx_size=%d index=%d\\n\",\n\n           s->packet_transfer_size,\n\n           s->elementary_transfer_size,\n\n           s->io_buffer_index);\n\n#endif\n\n    if (s->packet_transfer_size <= 0) {\n\n        /* end of transfer */\n\n        ide_transfer_stop(s);\n\n        s->status = READY_STAT;\n\n        s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO | ATAPI_INT_REASON_CD;\n\n        ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n        printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n    } else {\n\n        /* see if a new sector must be read */\n\n        if (s->lba != -1 && s->io_buffer_index >= s->cd_sector_size) {\n\n            ret = cd_read_sector(s->bs, s->lba, s->io_buffer, s->cd_sector_size);\n\n            if (ret < 0) {\n\n                ide_transfer_stop(s);\n\n                ide_atapi_io_error(s, ret);\n\n                return;\n\n            }\n\n            s->lba++;\n\n            s->io_buffer_index = 0;\n\n        }\n\n        if (s->elementary_transfer_size > 0) {\n\n            /* there are some data left to transmit in this elementary\n\n               transfer */\n\n            size = s->cd_sector_size - s->io_buffer_index;\n\n            if (size > s->elementary_transfer_size)\n\n                size = s->elementary_transfer_size;\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n        } else {\n\n            /* a new transfer is needed */\n\n            s->nsector = (s->nsector & ~7) | ATAPI_INT_REASON_IO;\n\n            byte_count_limit = s->lcyl | (s->hcyl << 8);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"byte_count_limit=%d\\n\", byte_count_limit);\n\n#endif\n\n            if (byte_count_limit == 0xffff)\n\n                byte_count_limit--;\n\n            size = s->packet_transfer_size;\n\n            if (size > byte_count_limit) {\n\n                /* byte count limit must be even if this case */\n\n                if (byte_count_limit & 1)\n\n                    byte_count_limit--;\n\n                size = byte_count_limit;\n\n            }\n\n            s->lcyl = size;\n\n            s->hcyl = size >> 8;\n\n            s->elementary_transfer_size = size;\n\n            /* we cannot transmit more than one sector at a time */\n\n            if (s->lba != -1) {\n\n                if (size > (s->cd_sector_size - s->io_buffer_index))\n\n                    size = (s->cd_sector_size - s->io_buffer_index);\n\n            }\n\n            ide_transfer_start(s, s->io_buffer + s->io_buffer_index,\n\n                               size, ide_atapi_cmd_reply_end);\n\n            s->packet_transfer_size -= size;\n\n            s->elementary_transfer_size -= size;\n\n            s->io_buffer_index += size;\n\n            ide_set_irq(s);\n\n#ifdef DEBUG_IDE_ATAPI\n\n            printf(\"status=0x%x\\n\", s->status);\n\n#endif\n\n        }\n\n    }\n\n}\n", "idx": 17012, "substitutes": {"s": ["ns", "set", "spec", "full", "settings", "options", "service", "ions", "ss", "cs", "d", "new", "ims", "qs", "sym", "p", "ks", "us", "sets", "comments", "ms", "m", "ts", "sg", "rs", "aws", "times", "ips", "in", "self", "o", "su", "side", "v", "si", "S", "uses", "a", "hs", "ches", "ds", "ans", "native", "status", "uns", "f", "sv", "r", "as", "this", "sports", "l", "ins", "sync", "c", "ps", "secondary", "sys", "your", "es", "states", "params", "session", "stats", "t", "conf", "data", "services", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "parts", "south", "server", "se", "y", "u"], "byte_count_limit": ["byte_length_limit", "byte_countprevalue", "byte_length_limited", "byte_count_lim", "byte_limitprelen", "byte_length_limits", "byte_countprelimit", "byte_countinglen", "byte_countlexlimit", "byte_limit_limit", "byte_count_no", "byte_length_lim", "byte_limitprevalue", "byte_limit_len", "byte_count_position", "byte_length_position", "byte_countlexset", "byte_count_value", "byte_count_limits", "byte_limit_limited", "byte_count_match", "byte_length_match", "byte_limit_value", "byte_countlexmatch", "byte_limitprelimited", "byte_countprelen", "byte_count_set", "byte_countlexlimited", "byte_countprelimited", "byte_count_len", "byte_countinglimited", "byte_countlexposition", "byte_count_limited", "byte_limitprelimit", "byte_length_set", "byte_countingvalue", "byte_length_no", "byte_countinglimit"], "size": ["offset", "full", "max", "sec", "score", "empty", "new", "large", "length", "send", "don", "Size", "source", "len", "scale", "content", "name", "ix", "clean", "done", "timeout", "count", "style", "key", "si", "shift", "weight", "grow", "status", "time", "code", "SIZE", "sized", "type", "loc", "mini", "speed", "nice", "go", "sn", "security", "ize", "c", "address", "sum", "fee", "value", "now", "small", "shape", "capacity", "data", "esc", "feed", "g", "z", "day", "en", "member", "complete", "ui", "use", "e", "limit", "unit", "form", "storage", "number", "y"], "ret": ["status", "db", "code", "obj", "err", "ref", "bit", "alt", "al", "let", "reg", "rc", "lit", "rt", "fun", "result", "num", "job", "flag", "cb", "match", "ext", "sec", "done", "mem", "rf", "resp", "rets", "count", "en", "ry", "arg", "bad", "att", "val", "re", "Ret", "feat", "bf", "fail", "value", "back", "no", "det", "sr", "cat", "rb", "url", "repl", "RET", "error", "pet", "res", "mt", "ft", "iter", "usr", "reply", "success", "len"], "lba": ["Laba", "lbc", "dlfa", "nbc", " laba", "Lva", "Lbas", " lfa", "npa", " lbas", "Lbc", "dlbo", "gbas", " lbo", "Lfa", "gva", "laba", "lbo", "Lbo", "lpa", "dlba", " lpa", "Lpa", "lfa", "gaba", "lva", "nba", " lva", "gba", "Lba", "nva", " lbc", "dlva", "lbas"]}}
{"project": "qemu", "commit_id": "7c560456707bfe53eb1728fcde759be7d9418b62", "target": 0, "func": "static void slavio_led_mem_writes(void *opaque, target_phys_addr_t addr,\n\n                                  uint32_t val)\n\n{\n\n    MiscState *s = opaque;\n\n    uint32_t saddr;\n\n\n\n    saddr = addr & LED_MAXADDR;\n\n    MISC_DPRINTF(\"Write diagnostic LED reg 0x\" TARGET_FMT_plx \" =  %x\\n\", addr,\n\n                 val);\n\n    switch (saddr) {\n\n    case 0:\n\n        s->leds = val;\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n}\n", "idx": 17021, "substitutes": {"opaque": ["Opaque", " opacity", "Opac", "Opaques", "opatile", "oppacity", "opac", "OPatile", "opacity", " opac", "oppaque", " opc", "OPaques", " opatile", "oppaques", "OPc", "oppatile", "OPaque", "OPac", "OPacity", "opaques", "opc", " opaques", "Opc"], "addr": ["pc", "rx", "point", "dd", "offset", "code", "data", "mode", "x", "base", "ref", "alt", "ord", "rt", "align", "hop", "ar", "oa", "src", "loc", "node", "ctx", "ld", "ptr", "pos", "index", "pointer", "arg", "host", "slot", " address", "alias", "nc", "add", "ad", "start", "dr", "address", "pad", "cmp", "adr", "la", "ace", "amd", "mt", "mac", "attr", "amp", "len"], "val": ["Val", "ret", "grad", "data", "x", "al", "ref", "base", "all", "vals", "loc", "sel", "mem", "count", "ee", "VAL", "arg", "arr", "enc", "vol", "slot", "ol", "ival", "bl", "v", "unit", "b", "fee", "eval", "len", "aval", "end", "valid", "el", "value", "pt"], "s": ["ns", "m", "session", "t", "rs", "aws", "x", "f", "settings", "r", "sie", "sb", "sl", "ips", "ls", "fs", "is", "o", "l", "d", "socket", "e", "ssl", "ses", "sync", "c", "ps", "si", "sym", "p", "S", "b", "sys", "es", "os", "state", "sq", "an", "sa", "sf"], "saddr": ["sadr", "daddr", "palign", " sdb", "Smd", "wsarr", " smd", "sesval", "shareattr", "wsaddr", "sharedb", "wsaddress", " sarr", " salign", "daddress", "wsval", "dval", "dadr", "Saddress", "sesaddr", "salign", "saddress", "sattr", "paddress", "paddr", " sattr", "sharearr", "wsdb", "shareaddr", "sdb", "sesadr", " saddress", "sval", "smd", "wsattr", "pmd", "Saddr", "wsadr", "sesaddress", "sarr", "Salign"]}}
{"project": "qemu", "commit_id": "7ce21016b69b512bf4777965a4292318f2bc7544", "target": 0, "func": "int coroutine_fn bdrv_co_discard(BlockDriverState *bs, int64_t sector_num,\n\n                                 int nb_sectors)\n\n{\n\n    int max_discard;\n\n\n\n    if (!bs->drv) {\n\n        return -ENOMEDIUM;\n\n    } else if (bdrv_check_request(bs, sector_num, nb_sectors)) {\n\n        return -EIO;\n\n    } else if (bs->read_only) {\n\n        return -EROFS;\n\n    }\n\n\n\n    bdrv_reset_dirty(bs, sector_num, nb_sectors);\n\n\n\n    /* Do nothing if disabled.  */\n\n    if (!(bs->open_flags & BDRV_O_UNMAP)) {\n\n        return 0;\n\n    }\n\n\n\n    if (!bs->drv->bdrv_co_discard && !bs->drv->bdrv_aio_discard) {\n\n        return 0;\n\n    }\n\n\n\n    max_discard = bs->bl.max_discard ?  bs->bl.max_discard : MAX_DISCARD_DEFAULT;\n\n    while (nb_sectors > 0) {\n\n        int ret;\n\n        int num = nb_sectors;\n\n\n\n        /* align request */\n\n        if (bs->bl.discard_alignment &&\n\n            num >= bs->bl.discard_alignment &&\n\n            sector_num % bs->bl.discard_alignment) {\n\n            if (num > bs->bl.discard_alignment) {\n\n                num = bs->bl.discard_alignment;\n\n            }\n\n            num -= sector_num % bs->bl.discard_alignment;\n\n        }\n\n\n\n        /* limit request size */\n\n        if (num > max_discard) {\n\n            num = max_discard;\n\n        }\n\n\n\n        if (bs->drv->bdrv_co_discard) {\n\n            ret = bs->drv->bdrv_co_discard(bs, sector_num, num);\n\n        } else {\n\n            BlockDriverAIOCB *acb;\n\n            CoroutineIOCompletion co = {\n\n                .coroutine = qemu_coroutine_self(),\n\n            };\n\n\n\n            acb = bs->drv->bdrv_aio_discard(bs, sector_num, nb_sectors,\n\n                                            bdrv_co_io_em_complete, &co);\n\n            if (acb == NULL) {\n\n                return -EIO;\n\n            } else {\n\n                qemu_coroutine_yield();\n\n                ret = co.ret;\n\n            }\n\n        }\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        sector_num += num;\n\n        nb_sectors -= num;\n\n    }\n\n    return 0;\n\n}\n", "idx": 17030, "substitutes": {"bs": ["ns", "org", "ros", "bi", "ts", "bin", "s", "lbs", "db", "blog", "rs", "obj", "base", "las", "ob", "ras", "eb", "ubs", "sb", "cb", "bc", "ls", "ss", "nas", "pb", "fs", "lb", "bb", "bles", "ba", "bid", "cs", "css", "gb", "bos", "bot", "bps", "ins", "obs", "bu", "outs", "BS", "iss", "blocks", "bis", "qs", "ab", "bl", "vs", "bas", "fb", "ses", "bh", "sync", "js", "bits", "ps", "bf", "b", "http", "null", "gs", "its", "bytes", "os", "bes", "banks", "ds", "bing"], "sector_num": ["tier_num", "sector_number", "sector6name", " sector_nam", "sector___ul", "sector___num", "tier_sum", " sector_name", "sector6ul", "sectoringnum", "sector_info", "tieringsum", "sector_ul", "tieringnumber", " sector_span", "sector_begin", "sectoringcommon", "sector_name", "sector6num", " sector_common", "sector_sum", " sector_sum", "sector_node", "tieringnode", "tieringnum", "sector6info", "sector_span", "sector_sim", " sector_ul", "sector___name", "sectoringnumber", " sector_sim", "sectoringname", " sector_number", " sector_info", "sector_nam", "tier_number", "sector___info", "sectoringsum", " sector_begin", "sector_common", "tier_node", "sectoringnode"], "nb_sectors": ["nb_sergments", "nb_SEctors", "nb_pectors", "nb_seors", "nb_vevers", "nb_pements", "nb_sector", "nb_pecs", "nb_severs", "nb_sedctors", "nb_sedgments", "nb_secgments", "nb_persekt", "nb_semctors", "nb_sedors", "nb_psector", "nb_sogments", "nb_sactors", "nb_secctors", "nb_sperets", "nb_semvers", "nb_sokt", "nb_persegments", "nb_pector", "nb_segments", "nb_SEkt", "nb_sasections", "nb_serets", "nb_serctor", "nb_secs", "nb_serors", "nb_vecs", "nb_serments", "nb_semsections", "nb_sekers", "nb_peors", "nb_perets", "nb_soctors", "nb_psegments", "nb_SEcs", "nb_SEgments", "nb_spectors", "nb_verets", "nb_SEkers", "nb_sesections", "nb_savers", "nb_pegments", "nb_sekt", "nb_sedvers", "nb_psectors", "nb_servers", "nb_specs", "nb_sokers", "nb_psements", "nb_sagments", "nb_spegments", "nb_semgments", "nb_veors", "nb_vegments", "nb_serctors", "nb_secvers", "nb_SEors", "nb_persectors", "nb_secsections", "nb_vectors", "nb_persekers", "nb_sements"], "max_discard": ["max2discward", "max_iscard", "max_discward", "max_diffenter", "max_diffward", "max_descards", "max2discorder", "max2discard", "max_distort", "max_iscignment", "max_secard", "max_recards", "max_discarding", "max_distenter", "max_diffard", "max_disarded", "max_Discarded", "max2discignment", "max_disards", "max_regarding", "max_guort", "max_discignment", "max_discussion", "max_guard", "max_secward", "max_regard", "max_dcenter", "max_diffignment", "max_recarded", "max_secord", "max2iscard", "max_contward", "max_discort", "max_descarded", "max_dcward", "max_discarded", "max_distard", "max_disenter", "max_secussion", "max_contard", "max2iscorder", "max2iscignment", "max_diffarded", "max_iscorder", "max2iscward", "max_recard", "max_discord", "max_disward", "max_contignment", "max_dcard", "max_discards", "max_iscward", "max_Discord", "max_disussion", "max_regussion", "max_guarded", "max_difforder", "max_disarding", "max_discenter", "max_descarding", "max_descard", "max_distarded", "max_disard", "max_Discward", "max_recarding", "max_regarded", "max_discorder", "max_secarding", "max_Discenter", "max_Discard", "max_secarded", "max_contorder", "max_disort", "max_dcarded", "max_guenter", "max_disord"], "ret": ["grad", "bin", "part", "group", "code", "info", "bit", "ref", "alt", "let", "rc", "reg", "lit", "ann", "fun", "rt", "nt", "result", "str", "job", "flag", "match", "usr", "ut", "orig", "ext", "fin", "mem", "def", "rets", "count", "sat", "out", "arg", "att", "val", "re", "Ret", "feat", "order", "back", "id", "det", "cat", "lib", "gt", "RET", "pat", "error", "res", "iter", "valid", "ft", "fi", "reply", "success", "len"], "acb": [" lacl", "ACsb", " acB", " acsb", "ecp", "Acp", "ecf", "ancB", "acbl", "acB", "ecsb", "rcl", "rcbl", "acl", "ancl", "ancbl", "ancsb", "acp", "rcbb", "ancb", "acf", "acsb", " acl", " lacb", "Acf", "ACB", "rcb", "acbb", " lacbl", "ancp", "ancf", "Acb", "ACl", "ecb", "ACb", " lacbb", "Acsb", "ancbb"]}}
{"project": "qemu", "commit_id": "aff3f0f150769ec4f97c6e2cefe91c4a0377b548", "target": 0, "func": "static void xlnx_ep108_machine_init(MachineClass *mc)\n\n{\n\n    mc->desc = \"Xilinx ZynqMP EP108 board\";\n\n    mc->init = xlnx_ep108_init;\n\n    mc->block_default_type = IF_IDE;\n\n    mc->units_per_default_bus = 1;\n\n    mc->ignore_memory_transaction_failures = true;\n\n}\n", "idx": 17043, "substitutes": {"mc": ["pc", "dc", "oc", "spec", "m", "cfg", "cca", "cus", "conn", "rc", "md", "mi", "cm", "bm", "inc", "mn", "cf", "coll", "bc", "mot", "PC", "mic", "fc", "di", "cycle", "acl", "cy", "ee", "ca", "ml", "cs", "arc", "nc", "ac", "mr", "DC", "tc", "lc", "c", "mx", "uc", " MC", "xml", "ec", "Mc", "cn", "co", "mac", "mm", "MC", "cc", "cci"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_logicali(TCGContext *s, AArch64Insn insn, TCGType ext,\n\n                             TCGReg rd, TCGReg rn, uint64_t limm)\n\n{\n\n    unsigned h, l, r, c;\n\n\n\n    assert(is_limm(limm));\n\n\n\n    h = clz64(limm);\n\n    l = ctz64(limm);\n\n    if (l == 0) {\n\n        r = 0;                  /* form 0....01....1 */\n\n        c = ctz64(~limm) - 1;\n\n        if (h == 0) {\n\n            r = clz64(~limm);   /* form 1..10..01..1 */\n\n            c += r;\n\n        }\n\n    } else {\n\n        r = 64 - l;             /* form 1....10....0 or 0..01..10..0 */\n\n        c = r - h - 1;\n\n    }\n\n    if (ext == TCG_TYPE_I32) {\n\n        r &= 31;\n\n        c &= 31;\n\n    }\n\n\n\n    tcg_out_insn_3404(s, insn, ext, rd, rn, ext, r, c);\n\n}\n", "idx": 17048, "substitutes": {"s": ["ns", "native", "spec", "ts", "t", "f", "settings", "services", "ions", "n", "g", "fs", "xs", "o", "cs", "outs", "w", "bis", "qs", "e", "ssl", "ses", "sync", "ps", "si", "p", "secondary", "S", "b", "sys", "es", "groups", "os", "opens", "south", "sets", "sq", "sf"], "insn": ["opensns", "Inssn", "inn", "Insp", "insna", "inna", "intsn", " insns", "insc", "Insn", "openssn", " inssn", " insp", "inp", "intsns", "insns", "inssn", " insc", "opensn", "opensc", "insp", "intssn", " insna", "intsc", "Insna"], "ext": ["rx", "ret", "init", "txt", "extra", "EXT", "t", "data", "text", "obj", "f", "ctr", "rest", "dep", "x", "err", "core", "prot", "reg", "ord", " Ext", "str", "type", "z", "ie", "orig", "ind", "ptr", "rf", "dim", "def", "Ext", "vert", "enc", "xp", "exec", "class", "format", "feat", "xt", "ch", "ex", "config", "e", "cl", "rev", " extend", "req", "lib", "ir", "test", "external", "arch", "ec", "opt", "inst", "im", "desc"], "rd": ["rx", "dra", "erd", "rr", "dd", "rs", "vr", "err", "rc", "hr", "rm", "rt", "mn", "ril", "rh", "ld", "rf", "abc", "rod", "RR", "rob", "nr", "mr", "rar", "ru", "dr", "lr", "cr", "xd", "rus", "rl", "rb", "rss", "rw", "rin", "ud", "RD", "adr", "ra", "rect", "usr", "ds"], "rn": ["rx", "rr", "RN", "dn", "cdn", "vr", "err", "pn", "rc", "rm", "rt", "ro", "mn", "ril", "anc", "nl", "rh", "rg", "rf", "abc", "roc", "nr", "nc", "rar", "ru", "sr", "ron", "ern", "cr", "nw", "rb", "rw", "rin", "fn", "cn", "nv"], "limm": ["linma", " limn", "palf", "palma", "glms", "glma", "logn", "limn", "memm", " limp", "comm", "lame", "logM", "Limm", "comms", "logp", "limp", "Limi", "meme", "gln", "glm", "memf", "limms", "Limf", "logms", " limi", " limM", "linm", "lime", "logna", "limf", "memi", "limM", "limi", "comp", "palms", "glp", "logm", "lamp", "LimM", " limf", "glf", "comn", "memna", "lamm", "memM", "linms", "memn", " lime", "palm", "limma", "limna", " limna", "lamn", "memp", "lamM", "linf"], "h": ["m", "j", "t", "x", "err", "f", "oh", "hr", "n", "g", "i", "sl", "z", "rh", "en", "o", "d", "sh", "w", "hl", "e", "k", "q", "bh", "v", "cl", "ih", "ir", "p", "hm", "b", "hh", "ul", "ph", "a", "hs", "H", "y", "u"], "l": ["m", "j", "x", "f", "n", "g", "i", "kl", "sl", "z", "nl", "lp", "ld", "dl", "o", "L", "ln", "d", "ol", "w", "e", "k", "cl", "v", "lc", "rl", "ll", "p", "ur", "b", "ul", "el", "y", "li", "u"], "r": ["m", "rr", "fr", "j", "rs", "x", "f", "err", "rc", "hr", "n", "R", "ro", "ar", "rt", "g", "or", "rh", "rg", "rf", "o", "range", "d", "re", "nr", "mr", "ru", "w", "sr", "dr", "e", "lr", "k", "cr", "v", "cur", "rb", "rl", "ir", "p", "ur", "b", "pr", "er", "u"], "c": ["dc", "pc", "m", "ch", "t", "x", "f", "ct", "rc", "n", "ar", "g", "i", "or", "z", "loc", "cy", "o", "enc", "cs", "d", "ce", "ci", "w", "k", "e", "cu", "q", "cr", "v", "lc", "cur", "sc", "p", "ur", "b", "col", "ec", "C", "y", "u"]}}
{"project": "qemu", "commit_id": "80db0e7822962554c91bef05d784c898e8ab1c3c", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  bool smm_enabled,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->disable_s3, pm->disable_s4,\n\n                      pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->smm_enabled = smm_enabled;\n\n\n\n    pm->enable_tco = true;\n\n    acpi_pm_tco_init(&pm->tco_regs, &pm->io);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    legacy_acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci),\n\n        OBJECT(lpc_pci), &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 17072, "substitutes": {"lpc_pci": ["lpc_lpcm", "lpc_vci", "lpc_lki", "lpc_dki", "lpc_ccm", "lpc_pcm", "lpc_loco", "lpc_fci", "lpc_cdi", "lpc_ddi", "lpc_mki", "lpc_lpi", "lpc_mci", "lpc_pcr", "lpc_lca", "lpc_vcu", "lpc_cca", "lpc_ppcm", "lpc_lpci", "lpc_phpku", "lpc_pcu", "lpc_ccr", "lpc_lcu", "lpc_dcr", "lpc_phpcm", "lpc_fki", "lpc_lku", "lpc_ldi", "lpc_ppcr", "lpc_pca", "lpc_coco", "lpc_ccu", "lpc_fdi", "lpc_cci", "lpc_pku", "lpc_lpku", "lpc_fcr", "lpc_vdi", "lpc_phpci", "lpc_lcm", "lpc_lci", "lpc_dci", "lpc_pdi", "lpc_mcm", "lpc_lppi", "lpc_pki", "lpc_ppoco", "lpc_poco", "lpc_vcm", "lpc_lcr", "lpc_cki", "lpc_ppci", "lpc_mca", "lpc_phppi", "lpc_ppi"], "pm": ["gem", "service", "pl", "bm", "mn", "num", "ams", "lp", "pb", "po", "vm", "PM", "pi", "vim", "asm", "cli", "lam", "p", "mp", "fm", "rpm", "mand", "mm", "pt", "pc", "program", "plugin", "m", "mod", "iam", "px", "cm", "am", "cp", "sem", "manager", "lv", "pg", "mr", "pa", "lc", "ram", "param", "period", "gm", "rem", "prem", "tm", "amp", "wp", "gram", "jp", "rm", "pd", "mi", "model", "git", "ml", "dm", "imm", "dem", "mail", "py", "db", "gmail", "ym", "module", "km", "em", "um", "dim", "member", "nm", "gp", "pp", "pkg", "wm", "hm", "api", "im", "mo"], "smm_enabled": ["smm_disabled", "spm_powered", "smm_used", "smm_enable", "scm_enabled", "smmfenable", "scm_Enabled", "spm_disabled", "scm_disabled", "scm_used", "smm_powered", "smm_Enabled", "spm_enabled", "smmfdisabled", "scm_enable", "smmfenabled", "smmfEnabled"], "sci_irq": ["sci_iriquire", "sci_irque", "sci_rinq", "sci_irequire", "sci_ireq", "sci_irquire", "sci_irv", "sci_irtv", "sci_rg", "sci_mirg", "sci_irce", "sci_mirv", "sci_rince", "sci_rque", "sci_irtg", "sci_mirce", "sci_irg", "sci_rinv", "sci_rq", "sci_ring", "sci_irtq", "sci_irig", "sci_ireque", "sci_iriq", "sci_mirq", "sci_irique", "sci_ireg", "sci_rquire", "sci_irtce"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void handle_sys(DisasContext *s, uint32_t insn, bool isread,\n\n                       unsigned int op0, unsigned int op1, unsigned int op2,\n\n                       unsigned int crn, unsigned int crm, unsigned int rt)\n\n{\n\n    const ARMCPRegInfo *ri;\n\n    TCGv_i64 tcg_rt;\n\n\n\n    ri = get_arm_cp_reginfo(s->cp_regs,\n\n                            ENCODE_AA64_CP_REG(CP_REG_ARM64_SYSREG_CP,\n\n                                               crn, crm, op0, op1, op2));\n\n\n\n    if (!ri) {\n\n        /* Unknown register; this might be a guest error or a QEMU\n\n         * unimplemented feature.\n\n         */\n\n        qemu_log_mask(LOG_UNIMP, \"%s access to unsupported AArch64 \"\n\n                      \"system register op0:%d op1:%d crn:%d crm:%d op2:%d\\n\",\n\n                      isread ? \"read\" : \"write\", op0, op1, crn, crm, op2);\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    /* Check access permissions */\n\n    if (!cp_access_ok(s->current_el, ri, isread)) {\n\n        unallocated_encoding(s);\n\n        return;\n\n    }\n\n\n\n    if (ri->accessfn) {\n\n        /* Emit code to perform further access permissions checks at\n\n         * runtime; this may result in an exception.\n\n         */\n\n        TCGv_ptr tmpptr;\n\n        TCGv_i32 tcg_syn;\n\n        uint32_t syndrome;\n\n\n\n        gen_a64_set_pc_im(s->pc - 4);\n\n        tmpptr = tcg_const_ptr(ri);\n\n        syndrome = syn_aa64_sysregtrap(op0, op1, op2, crn, crm, rt, isread);\n\n        tcg_syn = tcg_const_i32(syndrome);\n\n        gen_helper_access_check_cp_reg(cpu_env, tmpptr, tcg_syn);\n\n        tcg_temp_free_ptr(tmpptr);\n\n        tcg_temp_free_i32(tcg_syn);\n\n    }\n\n\n\n    /* Handle special cases first */\n\n    switch (ri->type & ~(ARM_CP_FLAG_MASK & ~ARM_CP_SPECIAL)) {\n\n    case ARM_CP_NOP:\n\n        return;\n\n    case ARM_CP_NZCV:\n\n        tcg_rt = cpu_reg(s, rt);\n\n        if (isread) {\n\n            gen_get_nzcv(tcg_rt);\n\n        } else {\n\n            gen_set_nzcv(tcg_rt);\n\n        }\n\n        return;\n\n    case ARM_CP_CURRENTEL:\n\n        /* Reads as current EL value from pstate, which is\n\n         * guaranteed to be constant by the tb flags.\n\n         */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        tcg_gen_movi_i64(tcg_rt, s->current_el << 2);\n\n        return;\n\n    case ARM_CP_DC_ZVA:\n\n        /* Writes clear the aligned block of memory which rt points into. */\n\n        tcg_rt = cpu_reg(s, rt);\n\n        gen_helper_dc_zva(cpu_env, tcg_rt);\n\n        return;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        gen_io_start();\n\n    }\n\n\n\n    tcg_rt = cpu_reg(s, rt);\n\n\n\n    if (isread) {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            tcg_gen_movi_i64(tcg_rt, ri->resetvalue);\n\n        } else if (ri->readfn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_get_cp_reg64(tcg_rt, cpu_env, tmpptr);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_ld_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    } else {\n\n        if (ri->type & ARM_CP_CONST) {\n\n            /* If not forbidden by access permissions, treat as WI */\n\n            return;\n\n        } else if (ri->writefn) {\n\n            TCGv_ptr tmpptr;\n\n            tmpptr = tcg_const_ptr(ri);\n\n            gen_helper_set_cp_reg64(cpu_env, tmpptr, tcg_rt);\n\n            tcg_temp_free_ptr(tmpptr);\n\n        } else {\n\n            tcg_gen_st_i64(tcg_rt, cpu_env, ri->fieldoffset);\n\n        }\n\n    }\n\n\n\n    if (use_icount && (ri->type & ARM_CP_IO)) {\n\n        /* I/O operations must end the TB here (whether read or write) */\n\n        gen_io_end();\n\n        s->is_jmp = DISAS_UPDATE;\n\n    } else if (!isread && !(ri->type & ARM_CP_SUPPRESS_TB_END)) {\n\n        /* We default to ending the TB on a coprocessor register write,\n\n         * but allow this to be suppressed by the register definition\n\n         * (usually only necessary to work around guest bugs).\n\n         */\n\n        s->is_jmp = DISAS_UPDATE;\n\n    }\n\n}\n", "idx": 17082, "substitutes": {"s": ["ns", "spec", "ts", "session", "sg", "stats", "request", "t", "f", "rs", "sv", "settings", "services", "service", "r", "ions", "n", "sie", "sb", "g", "i", "ss", "ls", "ops", "ctx", "sim", "fs", "scope", "self", "xs", "is", "o", "sk", "cs", "d", "su", "qs", "e", "ssl", "sc", "ses", "cli", "client", "c", "js", "si", "sync", "p", "S", "sci", "b", "ks", "http", "gs", "sys", "h", "storage", "es", "os", "us", "sets", "south", "sq", "server", "less", "conn", "ds", "sf"], "insn": ["INSN", "nsn", "consn", "INSn", "nsN", "consN", "INSl", "conssn", "nsl", "INSsn", "nssn", "inssn", "consl", "insN", "insl"], "isread": ["isireadable", " isride", "ISplay", " isplay", "iwrite", "isRead", "misreader", " isRead", "ISride", "isplay", "asRead", "isride", "isreading", "isiread", "iread", "ISwrite", "isload", "Isride", "usload", "isiwrite", "Isload", "isoRead", "iswrite", "misplay", "Isreading", "misread", " isload", "ISread", "usread", "asread", " isreader", "Iswrite", "asbroken", "isoread", " isbroken", "iplay", " isreading", "Isplay", " isreadable", "usreading", "miswrite", "isreader", "Isread", "isreadable", "ireadable", "ireader", "uswrite", " iswrite", "isbroken", "isobroken"], "op0": [" op3", "opt0", "ip0", "ip4", "opt3", "Op1", "OP3", "opt1", "opt4", "ip1", "Op2", " op4", "Op00", "op4", "op3", "opt2", "OP0", " op00", "OP2", "Op0", "OP1", "op00", "OP00", "ip2", "ip00"], "op1": ["cop3", " op3", "oper0", "hop4", "ip0", "cop2", "cop1", "cop4", "ip4", "hop0", "OP3", "hop2", "oper4", "ip1", "hop1", "oper1", "cop0", "op4", "op3", "OP0", "OP4", "oper2", "OP2", "OP1", "ip2"], "op2": ["cop2", "cop02", "cop1", "ip4", "op02", "hop0", "hop2", "oper4", "ip1", "hop1", "oper1", "hop02", "ip02", " op4", " op02", "op4", "OP0", "OP4", "OP02", "oper2", "OP2", "OP1", "oper02", "ip2"], "crn": [" cr1", "CRd", " crN", "prp", "CRp", "Crm", "pr1", "crb", "CRb", "Crn", " crd", " crl", "crN", "crw", "cr1", " crb", "prd", "Crl", "Crw", "prm", "crl", "CRl", " crp", "crd", "CrN", "CRw", "crp", "Crb", "CRn", "prn", "CR1", "CRm", " crw", "CRN"], "crm": ["crv", "crM", "prf", "CRp", "crf", " crv", "Crm", "prmn", " crmn", "Crn", " cr2", "CRmn", "cfm", "CRM", " crl", "cfn", "CR2", "CRv", "Crl", "prm", "cfv", "crl", "CRl", " crp", "CRf", " crf", "crp", " crM", "crmn", "CRn", "prn", "cr2", "CRm", "Cr2", "CrM", "cfp"], "rt": ["rx", "ti", "grad", "RT", "tt", "wt", "offset", "rr", "ret", "fr", "t", "NT", "vr", "ot", "ort", "rs", "alt", "rc", "nt", "rid", "rm", "r", "reg", "rh", "bt", "ptr", "irt", "ry", "rf", "lt", "rat", "rd", "ru", "sn", "rot", "rn", "sr", "dr", "qt", "ant", "yt", "cr", "rl", "rb", "vt", "gt", "adr", "error", "mt", "addr", "ft", "rect", "it", "lat", "attr", "pt"], "ri": ["RI", "uri", "gi", "ti", "rx", "ic", "rr", "rs", "udi", "ini", "qi", "rc", "r", "rid", "ai", "mi", "ro", "ar", "ani", "i", "rh", "dri", "ii", "ori", "ski", "di", "rg", "stri", "li", "loc", "ry", "vi", "rf", "rio", "ris", "adi", "rob", "pi", "rie", "rib", "ci", "rit", "abi", "rn", "sn", "sr", "dr", "cr", "ni", "si", "ki", "xi", "ir", "ior", "rin", "rb", "ra", "rip", "eni", "fi", "iri", "ari"], "tcg_rt": ["tcg7rt", "tcg_rot", "tcg_opt", "tcg_dr", "tcg_la", "tcj_rx", "tcgg7rit", "tcg7rit", "tcG_rn", "tcj_rt", "tcg7rs", "tcG_rt", "tcgg7RT", "tcg__dr", "tcg_rn", "tcgg_RT", "tcg7RT", "tcg_rx", "tcG_rx", "tcj_dr", "tcgg7rt", "tcg__la", "tcg_rit", "tcgg_rt", "tcgg_rit", "tcgg7rs", "tcg__rx", "tcj_la", "tcg_rs", "tcg_RT", "tcG_opt", "tcg__rt", "tcG_RT", "tcG_rot", "tcgg_rs"], "tmpptr": ["tmpppr", "TMplsr", "tmplort", "tmptr", "TMpletr", "tompsptr", "tomptr", "tmparetr", "tompsr", "TMpppr", "tompport", "TMptr", "tmppetr", "tmppsr", "tmplptr", "tmpgtr", "tmpsr", "TMppcr", "tmoppr", "tmppr", "tmopptr", "tmpTR", "tmopppr", "tmpstr", "tmplrom", "TMppsr", "tmpsptr", "TMpltr", "tmpltr", "tmpTr", "tmpgr", "tmplsr", "tmapprom", "tmpcr", "tmplr", "tmpsort", "TMppetr", "tomptTR", "tmappetr", "tmpgort", "TMpr", "tmppptr", "TMppr", "TMpprom", "tompptr", "tomppr", "tmoppcr", "tmpartr", "tmappTR", "tmparrom", "tmpprom", "tomptTr", "tomppTr", "tmpgptr", "tmptcr", "tmppTR", "tomppptr", "tmparsr", "tmappTr", "tmappsr", "tmptTr", "tmppcr", "tmpletr", "tompsort", "tmpttr", "tmappr", "TMpcr", "TMplrom", "tompstr", "tompttr", "tmapptr", "tmptpr", "tomppTR", "TMpptr", "tmppTr", "tmpport", "tmpr", "tmptTR"], "tcg_syn": ["tcg_sync", "tcg__syn", "tcg_poly", "tcgm_syn", "tcg__sync", "tcG_sn", "tcgm_sys", "tcg__poly", "tcG_rin", "tcg_opt", "tcgm_opt", "tcgpyopt", "tcgmpysyn", "tcg__sn", "tcg__Syn", "tcgmpysync", "tcg_special", "tcg_rin", "tcg_Syn", "tcG_syn", "tcG_sync", "tcg__rin", "tcG_special", "tcgpysys", "tcgmpyopt", "tcg_sys", "tcgm_sync", "tcG_poly", "tcG_Syn", "tcg_sn", "tcg__special", "tcgpysync", "tcgmpysys", "tcgpysyn"], "syndrome": ["cyndroma", "syddrom", "syngrom", "Syntrome", "syddrome", "sydrim", "Syndroma", "cyndrim", "cyndrom", "syntrome", "syndrom", "cyntroma", "syundroma", "cyndchrome", "Syndchrome", "syundrome", "Syndrom", "Syntrom", "Syndrome", "syntrom", "cyntchrome", "cyntrom", "cyndrome", "syundrom", "syundchrome", "syntchrome", "syndroma", "syddrim", "syntroma", "syngrome", "sydchrome", "sydrome", "syddchrome", "sydrom", "syntrim", "cyntrim", "syddroma", "cyntrome", "Syntchrome", "syngchrome", "syndrim", "syngroma", "syndchrome", "Syntroma"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static Visitor *visitor_input_test_init_raw(TestInputVisitorData *data,\n\n                                            const char *json_string)\n\n{\n\n    return visitor_input_test_init_internal(data, json_string, NULL);\n\n}\n", "idx": 17085, "substitutes": {"data": ["Data", "init", "view", "text", "base", "image", "json", "buffer", "input", "result", "window", "type", "raw", "model", "alpha", "self", "parser", "object", "empty", "database", "config", "start", "batch", "client", "parent", "da", "test", "cache", "dat", "null", "a", "DATA", "valid", "writer", "reader"], "json_string": ["json1list", "json_version", "query_text", "json2string", " json_data", "json1type", "json_type", " json_type", "json_data", "json1string", "json_list", "json1data", "json2strings", "query_strings", "json_strings", "query_string", "query_version", "json2version", " json_list", "json_text", "json2text"]}}
{"project": "qemu", "commit_id": "4a19f1eced611e7c3a0fba07d13515cbc73da09f", "target": 0, "func": "static void do_info_version(Monitor *mon)\n\n{\n\n    monitor_printf(mon, \"%s\\n\", QEMU_VERSION);\n\n}\n", "idx": 17092, "substitutes": {"mon": ["m", "mag", "demon", "pid", "eor", "md", "ann", "mi", "mn", "channel", "comm", "module", "master", "arm", "mun", "mc", "dim", "bean", " monitor", "atom", "dog", "bo", "com", "con", "mons", "man", "chron", "meter", "chan", "mor", "don", "Monitor", "domain", "monitor", "MON", "an", "conn", "Mon", "mu"]}}
{"project": "qemu", "commit_id": "0072d2a9fce4835ab2b9ee70aaca0169fb25fa0c", "target": 1, "func": "static int qcrypto_ivgen_essiv_init(QCryptoIVGen *ivgen,\n\n                                    const uint8_t *key, size_t nkey,\n\n                                    Error **errp)\n\n{\n\n    uint8_t *salt;\n\n    size_t nhash;\n\n    size_t nsalt;\n\n    QCryptoIVGenESSIV *essiv = g_new0(QCryptoIVGenESSIV, 1);\n\n\n\n    /* Not necessarily the same as nkey */\n\n    nsalt = qcrypto_cipher_get_key_len(ivgen->cipher);\n\n\n\n    nhash = qcrypto_hash_digest_len(ivgen->hash);\n\n    /* Salt must be larger of hash size or key size */\n\n    salt = g_new0(uint8_t, MAX(nhash, nsalt));\n\n\n\n    if (qcrypto_hash_bytes(ivgen->hash, (const gchar *)key, nkey,\n\n                           &salt, &nhash,\n\n                           errp) < 0) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n    /* Now potentially truncate salt to match cipher key len */\n\n    essiv->cipher = qcrypto_cipher_new(ivgen->cipher,\n\n                                       QCRYPTO_CIPHER_MODE_ECB,\n\n                                       salt, MIN(nhash, nsalt),\n\n                                       errp);\n\n    if (!essiv->cipher) {\n\n        g_free(essiv);\n\n\n        return -1;\n\n    }\n\n\n\n\n    ivgen->private = essiv;\n\n\n\n    return 0;\n\n}", "idx": 17101, "substitutes": {"ivgen": ["ivneg", "ervgen", "avgen", " ivgener", "evneg", "ocrgen", " ivgeneration", "hrGen", "ervlif", "ivercon", "ivergeneration", "ocrGen", "avgener", "ihget", "ivergener", "vgen", "ervgener", "ihGen", "ivergen", "ocGen", "ivGen", "irgeneration", "ocrgeneration", "occon", "eccon", "ocgen", "evgener", "ihgin", "hrgin", "vgener", "ervGen", "hrget", "evgeneration", "ivlif", "ecGen", "ecgate", "vgeneration", "avgeneration", "ovneg", "evget", "ihgen", "ocrgener", "evgin", "evGen", "hrgen", "ivcon", "ivergate", "ovgener", "ovGen", "ervgeneration", "avGen", "vlif", "ivget", "evgen", "ivgener", "ivgin", " ivlif", "irgen", "ivgeneration", "irgener", "ecgen", "ervneg", "irGen", "iverGen", "ivgate", "ocgate", "ovgen"], "key": ["code", "data", "x", "base", "image", "name", "hash", "block", "type", "match", "password", "cert", "copy", "ip", "secret", "crypt", "pair", "change", "ce", "size", "seed", "wire", "id", "k", "v", "private", "temp", "address", "fee", "sum", "cache", "Key", "row", "sign", "connection", "message", "KEY", "value"], "nkey": ["Nmac", "nchash", "nhex", "nsmix", "nmac", "nskey", "nmix", "Nhex", " nmix", " nmac", "ncmac", "nshash", "nckey", " nhex", "Nkey", "Nmix", "Nhash", "nchex", "nsmac"], "errp": [" errfp", "acerp", "erfp", "dangerp", "acerb", "erpre", "arrpy", "dangerpre", " errc", "errc", "acerpre", "errpre", "acerfp", "erp", " errpy", " errb", " erp", "errr", "dangerpat", "errpat", " erpy", "errfp", "dangerpp", " errr", "errb", " erc", "errpy", " errpat", "eorpre", "arrc", "eorpat", "arrp", "eorpp", " err", "erb", "eorp", " errpp", "arrr", "errpp", " errpre"], "salt": ["watt", "sysalt", "wash", "ssash", "osatt", "walt", "pssecret", "sALT", "nsodium", "nsALT", "nssecret", "osash", "psass", "syssecret", "ssALT", "ssass", "nsass", "satt", " sass", "sash", " sodium", "osALT", "sodium", " ssecret", "sysodium", "sysALT", "sssecret", "sass", "osalt", "ssatt", "psalt", "ssalt", "psALT", "wALT", "ssecret", " sALT"], "nhash": ["cnhash", "rnhash", " nbuild", "rnh", "chex", "ch", "sbuild", "nih", "cnblock", " nblock", "neurl", "cnkey", "nchash", "nhex", "neh", "nhost", "nheader", "Nheader", "cnhex", "nsum", "rnsum", "noh", "ncsum", "nohost", "nch", " nurl", "nsh", "Nh", "nehash", "shost", "shash", "Nhex", "nohash", "nihash", "chash", " nh", "nblock", "sh", "nikey", "nobuild", "nshash", "nurl", "niurl", " nhost", "cheader", "nckey", " nsum", " nhex", "nh", "nsheader", "Nhash", "nekey", "nchex", "rnhex", "ncblock", "nshex", "nbuild"], "nsalt": ["gsert", " nsul", " nsort", "sort", "ainsert", "ssodium", "netshash", "sALT", "gsalt", "nsol", "nsodium", "ainsalt", "ainsodium", "namesol", "nsul", "nsALT", "nasALT", "nasalt", "netsalt", "namesALT", "nsert", "nsort", "sol", "ssALT", "nasort", "nsass", "ainshash", "safe", "NSodium", "ssafe", "nshash", " nsol", "sodium", "namesalt", "nsafe", "netsert", "nasul", "sass", " nsass", "ssalt", "gshash", "netsodium", "gsodium", "NSALT", " nsALT", "namesass", "sul", "NSafe", "NSalt"], "essiv": ["cessiver", "esseserv", "assivation", "esiv", "issiver", "essenc", "essesiver", "assiver", "esliv", "issiv", "hesserv", "ossiv", "asserv", "esivation", "esiver", "essesenc", "cessive", "cessenc", "essesort", "ossrc", "ossiver", "assiv", "esrc", "issliv", "esive", "cessiv", "essiver", "ossort", "ssort", "ssiver", "osserv", "lessiv", "cessient", "sserv", "essient", "cesserv", "eserv", "lessliv", "hessiver", "essesient", "essivation", "issivation", "essesive", "essesrc", "ssiv", "essesiv", "esenc", "lessivation", "hessivation", "ossivation", "esient", "essive", "hessiv", "essliv", "lessiver", "essrc", "essort", "esserv"]}}
{"project": "FFmpeg", "commit_id": "bb6f51aeab88a252cf08f5a0ec26ab41ae2d74a2", "target": 1, "func": "static void mpeg1_encode_sequence_header(MpegEncContext *s)\n\n{\n\n        unsigned int vbv_buffer_size;\n\n        unsigned int fps, v;\n\n        int n;\n\n        UINT64 time_code;\n\n        \n\n        if ((s->picture_number % s->gop_size) == 0) {\n\n            /* mpeg1 header repeated every gop */\n\n            put_header(s, SEQ_START_CODE);\n\n            \n\n            /* search closest frame rate */\n\n            {\n\n                int i, dmin, d;\n\n                s->frame_rate_index = 0;\n\n                dmin = 0x7fffffff;\n\n                for(i=1;i<9;i++) {\n\n                    d = abs(s->frame_rate - frame_rate_tab[i]);\n\n                    if (d < dmin) {\n\n                        dmin = d;\n\n                        s->frame_rate_index = i;\n\n                    }\n\n                }\n\n            }\n\n \n\n            put_bits(&s->pb, 12, s->width);\n\n            put_bits(&s->pb, 12, s->height);\n\n            put_bits(&s->pb, 4, 1); /* 1/1 aspect ratio */\n\n            put_bits(&s->pb, 4, s->frame_rate_index);\n\n            v = s->bit_rate / 400;\n\n            if (v > 0x3ffff)\n\n                v = 0x3ffff;\n\n            put_bits(&s->pb, 18, v);\n\n            put_bits(&s->pb, 1, 1); /* marker */\n\n            /* vbv buffer size: slightly greater than an I frame. We add\n\n               some margin just in case */\n\n            vbv_buffer_size = (3 * s->I_frame_bits) / (2 * 8);\n\n            put_bits(&s->pb, 10, (vbv_buffer_size + 16383) / 16384); \n\n            put_bits(&s->pb, 1, 1); /* constrained parameter flag */\n\n            put_bits(&s->pb, 1, 0); /* no custom intra matrix */\n\n            put_bits(&s->pb, 1, 0); /* no custom non intra matrix */\n\n\n\n            put_header(s, GOP_START_CODE);\n\n            put_bits(&s->pb, 1, 0); /* do drop frame */\n\n            /* time code : we must convert from the real frame rate to a\n\n               fake mpeg frame rate in case of low frame rate */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            time_code = s->fake_picture_number * FRAME_RATE_BASE;\n\n            s->gop_picture_number = s->fake_picture_number;\n\n            put_bits(&s->pb, 5, (UINT32)((time_code / (fps * 3600)) % 24));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / (fps * 60)) % 60));\n\n            put_bits(&s->pb, 1, 1);\n\n            put_bits(&s->pb, 6, (UINT32)((time_code / fps) % 60));\n\n            put_bits(&s->pb, 6, (UINT32)((time_code % fps) / FRAME_RATE_BASE));\n\n            put_bits(&s->pb, 1, 1); /* closed gop */\n\n            put_bits(&s->pb, 1, 0); /* broken link */\n\n        }\n\n\n\n        if (s->frame_rate < (24 * FRAME_RATE_BASE) && s->picture_number > 0) {\n\n            /* insert empty P pictures to slow down to the desired\n\n               frame rate. Each fake pictures takes about 20 bytes */\n\n            fps = frame_rate_tab[s->frame_rate_index];\n\n            n = ((s->picture_number * fps) / s->frame_rate) - 1;\n\n            while (s->fake_picture_number < n) {\n\n                mpeg1_skip_picture(s, s->fake_picture_number - \n\n                                   s->gop_picture_number); \n\n                s->fake_picture_number++;\n\n            }\n\n\n\n        }\n\n        s->fake_picture_number++;\n\n}\n", "idx": 17113, "substitutes": {"s": ["ns", "set", "spec", "strings", "words", "x", "full", "settings", "service", "sie", "comm", "ss", "cs", "new", "qs", "sym", "p", "ks", "us", "sets", "comments", "ms", "m", "ts", "sg", "sis", "rs", "aws", "lines", "self", "o", "side", "k", "si", "S", "a", "hs", "an", "ds", "bs", "uns", "f", "r", "sb", "as", "this", "sports", "l", "ins", "features", "w", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "sq", "params", "sf", "session", "t", "stats", "request", "conf", "services", "plugins", "g", "sl", "ls", "ops", "fs", "xs", "is", "sites", "site", "com", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "parts", "se", "server", "y"], "vbv_buffer_size": ["vbv_byte_size", "vbv_byte_capacity", "vbv_byte_left", "vbv_buffer_left", "vbv_byte_number", "vbv_buffer6num", "vbv_byte_num", "vbv_byte_length", "vbv_buffer_capacity", "vbv_buffer_num", "vbv_buffer6capacity", "vbv_buffer6size", "vbv_buffer_number", "vbv_buffer_length"], "fps": ["Hz", "values", " frames", "fp", "x", "f", "ports", "vp", "life", "hz", "details", "vals", "seconds", "photos", "cpu", "ips", "ss", "ls", "resolution", "ops", "fs", "lines", "xp", "val", "bps", "bis", "vs", "frames", "bits", "ps", "seq", "p", "frequency", "versions", "b", "fee", "live", "bytes", "frame", "flags", "hops", "eps", "params"], "v": ["m", "vid", "V", "vr", "x", "f", "volume", "sv", "ve", "vp", "ver", "g", "z", "resolution", "vi", "lv", "vert", "uv", "l", "val", "vol", "conv", "av", "w", "ev", "q", "e", "vs", "ov", "k", "c", "tv", "p", "vt", "video", "volt", "b", "vv", "va", "h", "iv", "nv", "value", "cv", "version", "u"], "n": ["ns", "j", "x", "f", "ng", "num", "N", "g", "nl", " fn", " f", "nb", "l", " N", "nc", "sn", "w", "e", "vs", "ni", "p", "b", "fn", "nn", "len"], "time_code": ["time_coded", "time_range", "time_num", "time54coded", " time_coded", "time__coded", "time__codes", " time_codes", "time__index", "time2rate", " time_range", "time54codes", "time2Code", " time_num", "time_codes", " time_rate", " time_index", "time_rate", "time_zone", "time_index", "time2code", " time_zone", "time2codes", " time_Code", "time__code", "time54index", "time_Code", "time2zone", "time2range", "time2num", "time54code"], "i": ["ti", "gi", "uri", "m", "bi", "init", "j", "ji", "info", "x", "f", "ix", "ini", "qi", "ai", "io", "mi", "phi", "ii", "in", "di", "index", "ind", "iu", "I", "multi", "zi", "o", "l", "oi", "pi", "ui", "ci", "id", "e", "k", "c", "ni", "si", "ki", "ri", "p", "xi", "b", "u", "h", "a", "it", "eni", "fi", "y", "li", "mu"], "dmin": ["pMIN", " dMin", "fmid", "sdminimum", " din", "dMin", "din", "dmid", "bminimum", "Din", " dunit", "pmini", "bmin", "cdmax", "dmini", "cdmid", "fin", " dMIN", "fmin", "fMin", "plimit", "bunit", " dmid", "dmax", "dMIN", "sdunit", " dminimum", "pmin", "DMin", "sdmin", " dmini", " dlimit", " dmax", "cdmin", "dunit", "Dmin", "fmax", "sdmini", "dminimum", "dlimit", "Dmax", "sdMIN", "sdlimit"], "d": ["dc", "m", "dn", "dd", "j", "nd", "t", "gd", "f", "md", "dh", "dos", "g", "z", "dt", "di", "ld", "dl", "done", "wd", "ind", "min", "def", "sd", "dp", "l", "rd", "ed", "did", "dy", "dx", "dm", "ad", "fd", "e", "bd", "id", "length", "xd", "dom", "D", "da", "p", "ded", "b", "dist", "dat", "dad", "diff", "ds"], "fake_picture_number": ["fake_image_size", "fake_image_rate", "fake_picture\u00b7no", "fake_picture_rate", "fake_image_sum", "fake_picture\u00b7rate", "fake_image_number", "fake_picture\u00b7num", "fake_picture\u00b7number", "fake_picture_sum", "fake_picture_no", "fake_picture_num", "fake_image_no", "fake_picture_size", "fake_image_num"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel4_mc33_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_4w_msa(src + stride - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 4);\n\n}\n", "idx": 17118, "substitutes": {"dst": ["dsl", "dssl", "Dst", "fedsl", "dssrc", "dsrc", "fedsrc", "Dsrc", "dsst", "Dsts", "Drc", "fedst", " dsrc", " drc", "fedrc", " dsts", "dsts", " dsl", "drc"], "src": ["grad", "sup", "sur", "rest", "dest", "ctr", "rc", "lit", "rt", "supp", "sb", "cb", "sl", "stream", "attr", "bc", "loc", "sel", "sec", "low", "gb", "rd", "size", "rib", "st", "config", "img", "sr", "sc", "ssl", "gl", "buf", "start", "sync", "cur", "rb", "rl", "lib", "bg", "url", "b", "gz", "sub", "inst", "source", "dist"], "stride": ["drider", "strride", "ptIDE", "Strided", "Strride", "Stride", "grider", "brided", "hrIDE", "ctrone", "ctride", "hrided", "arride", " strride", "drided", "serviden", "servider", "stider", "strone", "yride", "servided", "ptided", "briden", "striden", " strided", "stide", "arrone", "hriden", "arrider", "strided", "Strider", "yrride", "ptiden", "stides", "grided", "strides", "Strides", " strider", "yrider", "grides", "Strone", "ctrided", "servide", "dride", "hride", "ptide", "strider", "brIDE", "stiden", "strIDE", "ctrider", "gride", "arrided", "driden", "bride", "yrided", "stided"]}}
{"project": "FFmpeg", "commit_id": "57cd2f7777a316a447301a7d4b5d1c01da200661", "target": 0, "func": "static av_cold int mpeg_mux_init(AVFormatContext *ctx)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    int bitrate, i, mpa_id, mpv_id, h264_id, mps_id, ac3_id, dts_id, lpcm_id, j;\n\n    AVStream *st;\n\n    StreamInfo *stream;\n\n    int audio_bitrate;\n\n    int video_bitrate;\n\n\n\n    s->packet_number = 0;\n\n    s->is_vcd   =  (CONFIG_MPEG1VCD_MUXER  && ctx->oformat == &ff_mpeg1vcd_muxer);\n\n    s->is_svcd  =  (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer);\n\n    s->is_mpeg2 = ((CONFIG_MPEG2VOB_MUXER  && ctx->oformat == &ff_mpeg2vob_muxer) ||\n\n                   (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer) ||\n\n                   (CONFIG_MPEG2SVCD_MUXER && ctx->oformat == &ff_mpeg2svcd_muxer));\n\n    s->is_dvd   =  (CONFIG_MPEG2DVD_MUXER  && ctx->oformat == &ff_mpeg2dvd_muxer);\n\n\n\n    if (ctx->packet_size) {\n\n        if (ctx->packet_size < 20 || ctx->packet_size > (1 << 23) + 10) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Invalid packet size %d\\n\",\n\n                   ctx->packet_size);\n\n            goto fail;\n\n        }\n\n        s->packet_size = ctx->packet_size;\n\n    } else\n\n        s->packet_size = 2048;\n\n    if (ctx->max_delay < 0)     /* Not set by the caller */\n\n        ctx->max_delay = AV_TIME_BASE*7/10;\n\n\n\n    s->vcd_padding_bytes_written = 0;\n\n    s->vcd_padding_bitrate_num   = 0;\n\n\n\n    s->audio_bound = 0;\n\n    s->video_bound = 0;\n\n\n\n    mpa_id  = AUDIO_ID;\n\n    ac3_id  = AC3_ID;\n\n    dts_id  = DTS_ID;\n\n    mpv_id  = VIDEO_ID;\n\n    h264_id = H264_ID;\n\n    mps_id  = SUB_ID;\n\n    lpcm_id = LPCM_ID;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        st     = ctx->streams[i];\n\n        stream = av_mallocz(sizeof(StreamInfo));\n\n        if (!stream)\n\n            goto fail;\n\n        st->priv_data = stream;\n\n\n\n        avpriv_set_pts_info(st, 64, 1, 90000);\n\n\n\n        switch (st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if (!s->is_mpeg2 &&\n\n                (st->codec->codec_id == AV_CODEC_ID_AC3 ||\n\n                 st->codec->codec_id == AV_CODEC_ID_DTS ||\n\n                 st->codec->codec_id == AV_CODEC_ID_PCM_S16BE))\n\n                 av_log(ctx, AV_LOG_WARNING,\n\n                        \"%s in MPEG-1 system streams is not widely supported, \"\n\n                        \"consider using the vob or the dvd muxer \"\n\n                        \"to force a MPEG-2 program stream.\\n\",\n\n                        avcodec_get_name(st->codec->codec_id));\n\n            if (st->codec->codec_id == AV_CODEC_ID_AC3) {\n\n                stream->id = ac3_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_DTS) {\n\n                stream->id = dts_id++;\n\n            } else if (st->codec->codec_id == AV_CODEC_ID_PCM_S16BE) {\n\n                stream->id = lpcm_id++;\n\n                for (j = 0; j < 4; j++) {\n\n                    if (lpcm_freq_tab[j] == st->codec->sample_rate)\n\n                        break;\n\n                }\n\n                if (j == 4)\n\n                    goto fail;\n\n                if (st->codec->channels > 8)\n\n                    return -1;\n\n                stream->lpcm_header[0] = 0x0c;\n\n                stream->lpcm_header[1] = (st->codec->channels - 1) | (j << 4);\n\n                stream->lpcm_header[2] = 0x80;\n\n                stream->lpcm_align     = st->codec->channels * 2;\n\n            } else {\n\n                stream->id = mpa_id++;\n\n            }\n\n\n\n            /* This value HAS to be used for VCD (see VCD standard, p. IV-7).\n\n             * Right now it is also used for everything else. */\n\n            stream->max_buffer_size = 4 * 1024;\n\n            s->audio_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (st->codec->codec_id == AV_CODEC_ID_H264)\n\n                stream->id = h264_id++;\n\n            else\n\n                stream->id = mpv_id++;\n\n            if (st->codec->rc_buffer_size)\n\n                stream->max_buffer_size = 6 * 1024 + st->codec->rc_buffer_size / 8;\n\n            else {\n\n                av_log(ctx, AV_LOG_WARNING,\n\n                       \"VBV buffer size not set, using default size of 130KB\\n\"\n\n                       \"If you want the mpeg file to be compliant to some specification\\n\"\n\n                       \"Like DVD, VCD or others, make sure you set the correct buffer size\\n\");\n\n                // FIXME: this is probably too small as default\n\n                stream->max_buffer_size = 230 * 1024;\n\n            }\n\n            if (stream->max_buffer_size > 1024 * 8191) {\n\n                av_log(ctx, AV_LOG_WARNING, \"buffer size %d, too large\\n\", stream->max_buffer_size);\n\n                stream->max_buffer_size = 1024 * 8191;\n\n            }\n\n            s->video_bound++;\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            stream->id              = mps_id++;\n\n            stream->max_buffer_size = 16 * 1024;\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n        stream->fifo = av_fifo_alloc(16);\n\n        if (!stream->fifo)\n\n            goto fail;\n\n    }\n\n    bitrate       = 0;\n\n    audio_bitrate = 0;\n\n    video_bitrate = 0;\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        int codec_rate;\n\n        st     = ctx->streams[i];\n\n        stream = (StreamInfo *)st->priv_data;\n\n\n\n        if (st->codec->rc_max_rate ||\n\n            st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            codec_rate = st->codec->rc_max_rate;\n\n        else\n\n            codec_rate = st->codec->bit_rate;\n\n\n\n        if (!codec_rate)\n\n            codec_rate = (1 << 21) * 8 * 50 / ctx->nb_streams;\n\n\n\n        bitrate += codec_rate;\n\n\n\n        if ((stream->id & 0xe0) == AUDIO_ID)\n\n            audio_bitrate += codec_rate;\n\n        else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            video_bitrate += codec_rate;\n\n    }\n\n\n\n    if (s->user_mux_rate) {\n\n        s->mux_rate = (s->user_mux_rate + (8 * 50) - 1) / (8 * 50);\n\n    } else {\n\n        /* we increase slightly the bitrate to take into account the\n\n         * headers. XXX: compute it exactly */\n\n        bitrate    += bitrate / 20;\n\n        bitrate    += 10000;\n\n        s->mux_rate = (bitrate + (8 * 50) - 1) / (8 * 50);\n\n        if (s->mux_rate >= (1<<22)) {\n\n            av_log(ctx, AV_LOG_WARNING, \"mux rate %d is too large\\n\", s->mux_rate);\n\n            s->mux_rate = (1<<22) - 1;\n\n        }\n\n    }\n\n\n\n    if (s->is_vcd) {\n\n        int64_t overhead_rate;\n\n\n\n        /* The VCD standard mandates that the mux_rate field is 3528\n\n         * (see standard p. IV-6).\n\n         * The value is actually \"wrong\", i.e. if you calculate\n\n         * it using the normal formula and the 75 sectors per second transfer\n\n         * rate you get a different value because the real pack size is 2324,\n\n         * not 2352. But the standard explicitly specifies that the mux_rate\n\n         * field in the header must have this value. */\n\n        // s->mux_rate = 2352 * 75 / 50;    /* = 3528 */\n\n\n\n        /* The VCD standard states that the muxed stream must be\n\n         * exactly 75 packs / second (the data rate of a single speed cdrom).\n\n         * Since the video bitrate (probably 1150000 bits/sec) will be below\n\n         * the theoretical maximum we have to add some padding packets\n\n         * to make up for the lower data rate.\n\n         * (cf. VCD standard p. IV-6 ) */\n\n\n\n        /* Add the header overhead to the data rate.\n\n         * 2279 data bytes per audio pack, 2294 data bytes per video pack */\n\n        overhead_rate  = audio_bitrate * 2294LL * (2324 - 2279);\n\n        overhead_rate += video_bitrate * 2279LL * (2324 - 2294);\n\n\n\n        /* Add padding so that the full bitrate is 2324*75 bytes/sec */\n\n        s->vcd_padding_bitrate_num = (2324LL * 75 * 8 - bitrate) * 2279 * 2294 - overhead_rate;\n\n#define VCD_PADDING_BITRATE_DEN (2279 * 2294)\n\n    }\n\n\n\n    if (s->is_vcd || s->is_mpeg2)\n\n        /* every packet */\n\n        s->pack_header_freq = 1;\n\n    else\n\n        /* every 2 seconds */\n\n        s->pack_header_freq = 2 * bitrate / s->packet_size / 8;\n\n\n\n    /* the above seems to make pack_header_freq zero sometimes */\n\n    if (s->pack_header_freq == 0)\n\n        s->pack_header_freq = 1;\n\n\n\n    if (s->is_mpeg2)\n\n        /* every 200 packets. Need to look at the spec.  */\n\n        s->system_header_freq = s->pack_header_freq * 40;\n\n    else if (s->is_vcd)\n\n        /* the standard mandates that there are only two system headers\n\n         * in the whole file: one in the first packet of each stream.\n\n         * (see standard p. IV-7 and IV-8) */\n\n        s->system_header_freq = 0x7fffffff;\n\n    else\n\n        s->system_header_freq = s->pack_header_freq * 5;\n\n\n\n    for (i = 0; i < ctx->nb_streams; i++) {\n\n        stream                = ctx->streams[i]->priv_data;\n\n        stream->packet_number = 0;\n\n    }\n\n    s->system_header_size = get_system_header_size(ctx);\n\n    s->last_scr           = AV_NOPTS_VALUE;\n\n    return 0;\n\n\n\nfail:\n\n    for (i = 0; i < ctx->nb_streams; i++)\n\n        av_freep(&ctx->streams[i]->priv_data);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 17120, "substitutes": {"ctx": ["cfg", "so", "settings", "cf", "anc", " context", "console", "cas", "Context", "cs", "tx", "config", "xc", "qs", "cu", "general", "cli", "ck", "cv", "cc", "conn", "pc", "cal", "cca", "cus", "vc", "rc", "cm", "cp", "bc", "wcs", "kw", "hw", "cms", "sc", "lc", "connection", "hs", "ds", "na", "fp", "jp", "ct", "cpp", "cb", "coll", "loc", "ctrl", "ca", "kb", "ci", "buf", "sync", "c", "qa", "sci", "sys", "fn", "cn", "sq", "np", "conf", "CV", "ls", "xs", "css", "context", "conv", "nc", "pkg", "event", "tc", "cam", "client", "cl", "cmd", "support", "cmp", "gs"], "s": ["ns", "set", "ans", "spec", "m", "session", "sg", "ts", "t", "rs", "rates", "conf", "f", "sv", "settings", "services", "service", "r", "n", "sb", "g", "sl", "ss", "ls", "utils", "ops", "fs", "xs", "self", "sk", "cs", "context", "l", "d", "su", "args", "qs", "e", "sc", "ssl", "ses", "client", "sync", "c", "ps", "si", "js", "v", "p", "S", "b", "ks", "gs", "sys", "storage", "a", "es", "os", "hs", "us", "sets", "se", "sq", "sa", "ds", "u"], "bitrate": ["bitcount", " bitcount", "audcount", "comprate", "audrate", "audrates", " bitrates", "comprates", "compcount", "bitrates"], "i": ["uri", "m", "info", "f", "ini", "io", "mi", "n", "ai", "g", "ii", "iu", "I", "ip", "d", "pi", "ci", "id", "k", "c", "ni", "si", "p", "xi", "b", "li", "u"], "mpa_id": ["mpa__id", "mpba_key", "mpa_kid", "mpa_name", "mpca_sid", "mpa_type", "mpba_name", "mpa_pid", "mpa__sid", "mpa__pid", "mpa_key", "mpca_type", "mpa_sid", "mpba_kid", "mpca_id", "mpba_id", "mpa__type", "mpca_pid"], "mpv_id": ["mpv__id", "mpv_source", "mpv__source", "mpf_source", "mpf_sid", "mpv_sid", "mpf_id", "mpv__type", "mpv_type", "mpf_type", "mpv__sid"], "h264_id": ["h264appmin", "hvr_source", "h264_source", "h264_name", "hvrappid", "hvrappmin", "hvrappname", "hvr_min", "h264_min", "hvrappsource", "h264appsource", "h264appname", "hvr_name", "h264appid", "hvr_id"], "mps_id": ["mpsOCKkid", "mps_source", "mpsOCKtype", "mds_source", "mps_type", "mds_id", "mds_kid", "mpsOCKsource", "mps_kid", "mds_type", "mpsOCKid"], "ac3_id": ["ac3_ip", "acway_link", "acway_path", "ac3uuaid", "ac3uuid", "acway_id", "ac3__ip", "ac3__id", "acwd_ident", "ac3_ident", "ac3__ids", "acwd_ip", "ac3_ids", "acwd_ids", "acwd_id", "acway_aid", "ac3_link", "ac3_aid", "ac3uupath", "ac3_path", "ac3__ident", "ac3uulink"], "dts_id": ["dtz_id", "dtz_kid", "all", "g", "src", "dts_oid", "_", "dtz_oid", "c", "url", "dts_name", "dtz_name", "dts_kid"], "lpcm_id": ["pcmacheident", "pmediaacheident", "pcmPid", "pmediaacheerror", "pcm_id", "pcmPident", "pcmPerror", "pcmacheerror", "pcm_ids", "pmediaacheids", "pmedia_ident", "pcmPids", "pmedia_ids", "pmedia_id", "pcm_ident", "pcmacheid", "pmediaacheid", "pcmacheids", "pmedia_error", "pcm_error"], "j": ["m", "jl", "ji", "vision", "obj", "jp", "jit", "uj", "note", "f", "io", "jj", "job", "g", "z", "ij", "pos", "aj", "dj", "o", "J", "k", "kj", "q", "v", "js", "jam"], "st": ["ist", "nd", "ct", "sp", "ste", "sb", "ost", "sw", "sl", "ast", "src", "ST", "sta", "sm", "std", "sn", "sc", "bl", "sth", "cr", "sam", "tmp", "stage", "sts", "St", "inst", "sa", "amp"], "stream": ["m", "gram", "data", "media", "service", "cm", "channel", "upload", "sw", "sl", "src", "Stream", "pg", "path", "w", "sc", "e", "ssl", "sync", "uc", "video", "resource", "output", "iv", "source", "cv", "input"], "audio_bitrate": ["audio_bandrate", "audio_bitssize", "audio_bitspeed", "audio_bandsize", "audio_bitsize", "audio_bitsrate", "audio_bitsspeed", "audio_binsize", "audio_binspeed", "audio_bandspeed", "audio_binrate"], "video_bitrate": ["video_bandsync", "video_audsize", "video_bandrate", "video_bitsize", "video_bandsize", "video_audrate", "video_audspeed", "video_bandspeed", "video_bitsync", "video_audsync", "video_bitspeed"], "audio_bound": ["audio_range", "video_limit", "video_bind", "audio_bind", "video_range", "audio_limit"], "video_bound": ["audio_range", "video___bound", "video___end", "video_end", "video_bind", "video___bind", "audio_bind", "video_range", "video___range", "audio_end"]}}
{"project": "FFmpeg", "commit_id": "28f9ab7029bd1a02f659995919f899f84ee7361b", "target": 0, "func": "static void dsputil_init_mmx2(DSPContext *c, AVCodecContext *avctx,\n\n                              int mm_flags)\n\n{\n\n    const int bit_depth      = avctx->bits_per_raw_sample;\n\n    const int high_bit_depth = bit_depth > 8;\n\n\n\n    c->prefetch = prefetch_mmx2;\n\n\n\n    if (!high_bit_depth) {\n\n        c->put_pixels_tab[0][1] = put_pixels16_x2_mmx2;\n\n        c->put_pixels_tab[0][2] = put_pixels16_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[0][0] = avg_pixels16_mmx2;\n\n        c->avg_pixels_tab[0][1] = avg_pixels16_x2_mmx2;\n\n        c->avg_pixels_tab[0][2] = avg_pixels16_y2_mmx2;\n\n\n\n        c->put_pixels_tab[1][1] = put_pixels8_x2_mmx2;\n\n        c->put_pixels_tab[1][2] = put_pixels8_y2_mmx2;\n\n\n\n        c->avg_pixels_tab[1][0] = avg_pixels8_mmx2;\n\n        c->avg_pixels_tab[1][1] = avg_pixels8_x2_mmx2;\n\n        c->avg_pixels_tab[1][2] = avg_pixels8_y2_mmx2;\n\n    }\n\n\n\n    if (!(avctx->flags & CODEC_FLAG_BITEXACT)) {\n\n        if (!high_bit_depth) {\n\n            c->put_no_rnd_pixels_tab[0][1] = put_no_rnd_pixels16_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[0][2] = put_no_rnd_pixels16_y2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_mmx2;\n\n            c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_mmx2;\n\n\n\n            c->avg_pixels_tab[0][3] = avg_pixels16_xy2_mmx2;\n\n            c->avg_pixels_tab[1][3] = avg_pixels8_xy2_mmx2;\n\n        }\n\n\n\n        if (CONFIG_VP3_DECODER && HAVE_YASM) {\n\n            c->vp3_v_loop_filter = ff_vp3_v_loop_filter_mmx2;\n\n            c->vp3_h_loop_filter = ff_vp3_h_loop_filter_mmx2;\n\n        }\n\n    }\n\n    if (CONFIG_VP3_DECODER && HAVE_YASM)\n\n        c->vp3_idct_dc_add = ff_vp3_idct_dc_add_mmx2;\n\n\n\n    if (CONFIG_VP3_DECODER && (avctx->codec_id == CODEC_ID_VP3 ||\n\n                               avctx->codec_id == CODEC_ID_THEORA)) {\n\n        c->put_no_rnd_pixels_tab[1][1] = put_no_rnd_pixels8_x2_exact_mmx2;\n\n        c->put_no_rnd_pixels_tab[1][2] = put_no_rnd_pixels8_y2_exact_mmx2;\n\n    }\n\n\n\n    if (CONFIG_H264QPEL) {\n\n        SET_QPEL_FUNCS(put_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_qpel,        1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_no_rnd_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_qpel,        1,  8, mmx2, );\n\n\n\n        if (!high_bit_depth) {\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2,  4, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, mmx2, );\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2,  4, mmx2, );\n\n        } else if (bit_depth == 10) {\n\n#if HAVE_YASM\n\n#if !ARCH_X86_64\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 0, 16, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(put_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 1,  8, 10_mmxext, ff_);\n\n#endif\n\n            SET_QPEL_FUNCS(put_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n            SET_QPEL_FUNCS(avg_h264_qpel, 2, 4,  10_mmxext, ff_);\n\n#endif\n\n        }\n\n\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(put_2tap_qpel, 1,  8, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 0, 16, mmx2, );\n\n        SET_QPEL_FUNCS(avg_2tap_qpel, 1,  8, mmx2, );\n\n    }\n\n\n\n#if HAVE_YASM\n\n    if (!high_bit_depth && CONFIG_H264CHROMA) {\n\n        c->avg_h264_chroma_pixels_tab[0] = ff_avg_h264_chroma_mc8_mmx2_rnd;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_mmx2;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_mmx2;\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_mmx2;\n\n    }\n\n    if (bit_depth == 10 && CONFIG_H264CHROMA) {\n\n        c->put_h264_chroma_pixels_tab[2] = ff_put_h264_chroma_mc2_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[2] = ff_avg_h264_chroma_mc2_10_mmxext;\n\n        c->put_h264_chroma_pixels_tab[1] = ff_put_h264_chroma_mc4_10_mmxext;\n\n        c->avg_h264_chroma_pixels_tab[1] = ff_avg_h264_chroma_mc4_10_mmxext;\n\n    }\n\n\n\n    c->add_hfyu_median_prediction   = ff_add_hfyu_median_prediction_mmx2;\n\n\n\n    c->scalarproduct_int16          = ff_scalarproduct_int16_mmx2;\n\n    c->scalarproduct_and_madd_int16 = ff_scalarproduct_and_madd_int16_mmx2;\n\n\n\n    if (avctx->flags & CODEC_FLAG_BITEXACT) {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext_ba;\n\n    } else {\n\n        c->apply_window_int16 = ff_apply_window_int16_mmxext;\n\n    }\n\n#endif\n\n}\n", "idx": 17124, "substitutes": {"c": ["dc", "oc", "pc", "ic", "spec", "cc", "s", "ch", "t", "conf", "f", "x", "vc", "ct", "rc", "r", "w", "cm", "n", "cf", "g", "i", "coll", "bc", "cp", "ctx", "fc", "mc", "self", "ctrl", "cy", "o", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "xc", "config", "e", "cu", "sc", "k", "cr", "cl", "lc", "cur", "v", "p", "uc", "b", "cache", "cit", "ec", "h", "co", "C", "conn", "u"], "avctx": ["aphcontext", "afcmp", "AVscl", "apcmp", "apcp", "apcontext", "avcb", "aircontext", "Avscl", "avcp", "afcontext", "Avcontext", "apctx", "AVcb", "abctx", "afctx", "abcontext", "abcmp", "AVcca", "abcp", "avscl", "aircca", "afcp", "aphcca", "apcca", "aphscl", "aircb", "apcb", "AVctx", "avcca", "AVcontext", "aphctx", "avcmp", "avcontext", "Avctx", "airctx", "Avcca"], "mm_flags": [" pixel_settings", " pixel_data", " pixel_flags", "mm_data", " pixel_planes", "mm_settings", "mm_planes"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static int vaapi_encode_h264_init_sequence_params(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext                 *ctx = avctx->priv_data;\n\n    VAEncSequenceParameterBufferH264  *vseq = ctx->codec_sequence_params;\n\n    VAEncPictureParameterBufferH264   *vpic = ctx->codec_picture_params;\n\n    VAAPIEncodeH264Context            *priv = ctx->priv_data;\n\n    VAAPIEncodeH264MiscSequenceParams *mseq = &priv->misc_sequence_params;\n\n    int i;\n\n\n\n    {\n\n        vseq->seq_parameter_set_id = 0;\n\n\n\n        vseq->level_idc = avctx->level;\n\n\n\n        vseq->max_num_ref_frames = 2;\n\n\n\n        vseq->picture_width_in_mbs  = priv->mb_width;\n\n        vseq->picture_height_in_mbs = priv->mb_height;\n\n\n\n        vseq->seq_fields.bits.chroma_format_idc = 1;\n\n        vseq->seq_fields.bits.frame_mbs_only_flag = 1;\n\n        vseq->seq_fields.bits.direct_8x8_inference_flag = 1;\n\n        vseq->seq_fields.bits.log2_max_frame_num_minus4 = 4;\n\n        vseq->seq_fields.bits.pic_order_cnt_type = 0;\n\n\n\n        if (ctx->input_width  != ctx->aligned_width ||\n\n            ctx->input_height != ctx->aligned_height) {\n\n            vseq->frame_cropping_flag = 1;\n\n\n\n            vseq->frame_crop_left_offset   = 0;\n\n            vseq->frame_crop_right_offset  =\n\n                (ctx->aligned_width - ctx->input_width) / 2;\n\n            vseq->frame_crop_top_offset    = 0;\n\n            vseq->frame_crop_bottom_offset =\n\n                (ctx->aligned_height - ctx->input_height) / 2;\n\n        } else {\n\n            vseq->frame_cropping_flag = 0;\n\n        }\n\n\n\n        vseq->vui_parameters_present_flag = 1;\n\n        if (avctx->sample_aspect_ratio.num != 0) {\n\n            vseq->vui_fields.bits.aspect_ratio_info_present_flag = 1;\n\n            // There is a large enum of these which we could support\n\n            // individually rather than using the generic X/Y form?\n\n            if (avctx->sample_aspect_ratio.num ==\n\n                avctx->sample_aspect_ratio.den) {\n\n                vseq->aspect_ratio_idc = 1;\n\n            } else {\n\n                vseq->aspect_ratio_idc = 255; // Extended SAR.\n\n                vseq->sar_width  = avctx->sample_aspect_ratio.num;\n\n                vseq->sar_height = avctx->sample_aspect_ratio.den;\n\n            }\n\n        }\n\n        if (avctx->color_primaries != AVCOL_PRI_UNSPECIFIED ||\n\n            avctx->color_trc       != AVCOL_TRC_UNSPECIFIED ||\n\n            avctx->colorspace      != AVCOL_SPC_UNSPECIFIED) {\n\n            mseq->video_signal_type_present_flag = 1;\n\n            mseq->video_format             = 5; // Unspecified.\n\n            mseq->video_full_range_flag    = 0;\n\n            mseq->colour_description_present_flag = 1;\n\n            // These enums are derived from the standard and hence\n\n            // we can just use the values directly.\n\n            mseq->colour_primaries         = avctx->color_primaries;\n\n            mseq->transfer_characteristics = avctx->color_trc;\n\n            mseq->matrix_coefficients      = avctx->colorspace;\n\n        }\n\n\n\n        vseq->bits_per_second = avctx->bit_rate;\n\n\n\n        vseq->vui_fields.bits.timing_info_present_flag = 1;\n\n        if (avctx->framerate.num > 0 && avctx->framerate.den > 0) {\n\n            vseq->num_units_in_tick = avctx->framerate.num;\n\n            vseq->time_scale        = 2 * avctx->framerate.den;\n\n            mseq->fixed_frame_rate_flag = 1;\n\n        } else {\n\n            vseq->num_units_in_tick = avctx->time_base.num;\n\n            vseq->time_scale        = 2 * avctx->time_base.den;\n\n            mseq->fixed_frame_rate_flag = 0;\n\n        }\n\n\n\n        if (ctx->va_rc_mode == VA_RC_CBR) {\n\n            priv->send_timing_sei = 1;\n\n            mseq->nal_hrd_parameters_present_flag = 1;\n\n\n\n            mseq->cpb_cnt_minus1 = 0;\n\n\n\n            // Try to scale these to a sensible range so that the\n\n            // golomb encode of the value is not overlong.\n\n            mseq->bit_rate_scale =\n\n                av_clip_uintp2(av_log2(avctx->bit_rate) - 15 - 6, 4);\n\n            mseq->bit_rate_value_minus1[0] =\n\n                (avctx->bit_rate >> mseq->bit_rate_scale + 6) - 1;\n\n\n\n            mseq->cpb_size_scale =\n\n                av_clip_uintp2(av_log2(priv->hrd_params.hrd.buffer_size) - 15 - 4, 4);\n\n            mseq->cpb_size_value_minus1[0] =\n\n                (priv->hrd_params.hrd.buffer_size >> mseq->cpb_size_scale + 4) - 1;\n\n\n\n            // CBR mode isn't actually available here, despite naming.\n\n            mseq->cbr_flag[0] = 0;\n\n\n\n            mseq->initial_cpb_removal_delay_length_minus1 = 23;\n\n            mseq->cpb_removal_delay_length_minus1         = 23;\n\n            mseq->dpb_output_delay_length_minus1          = 7;\n\n            mseq->time_offset_length = 0;\n\n\n\n            // This calculation can easily overflow 32 bits.\n\n            mseq->initial_cpb_removal_delay = 90000 *\n\n                (uint64_t)priv->hrd_params.hrd.initial_buffer_fullness /\n\n                priv->hrd_params.hrd.buffer_size;\n\n\n\n            mseq->initial_cpb_removal_delay_offset = 0;\n\n        } else {\n\n            priv->send_timing_sei = 0;\n\n            mseq->nal_hrd_parameters_present_flag = 0;\n\n        }\n\n\n\n        vseq->intra_period     = ctx->p_per_i * (ctx->b_per_p + 1);\n\n        vseq->intra_idr_period = vseq->intra_period;\n\n        vseq->ip_period        = ctx->b_per_p + 1;\n\n    }\n\n\n\n    {\n\n        vpic->CurrPic.picture_id = VA_INVALID_ID;\n\n        vpic->CurrPic.flags      = VA_PICTURE_H264_INVALID;\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(vpic->ReferenceFrames); i++) {\n\n            vpic->ReferenceFrames[i].picture_id = VA_INVALID_ID;\n\n            vpic->ReferenceFrames[i].flags      = VA_PICTURE_H264_INVALID;\n\n        }\n\n\n\n        vpic->coded_buf = VA_INVALID_ID;\n\n\n\n        vpic->pic_parameter_set_id = 0;\n\n        vpic->seq_parameter_set_id = 0;\n\n\n\n        vpic->num_ref_idx_l0_active_minus1 = 0;\n\n        vpic->num_ref_idx_l1_active_minus1 = 0;\n\n\n\n        vpic->pic_fields.bits.entropy_coding_mode_flag =\n\n            ((avctx->profile & 0xff) != 66);\n\n        vpic->pic_fields.bits.weighted_pred_flag = 0;\n\n        vpic->pic_fields.bits.weighted_bipred_idc = 0;\n\n        vpic->pic_fields.bits.transform_8x8_mode_flag =\n\n            ((avctx->profile & 0xff) >= 100);\n\n\n\n        vpic->pic_init_qp = priv->fixed_qp_idr;\n\n    }\n\n\n\n    {\n\n        mseq->profile_idc = avctx->profile & 0xff;\n\n\n\n        if (avctx->profile & FF_PROFILE_H264_CONSTRAINED)\n\n            mseq->constraint_set1_flag = 1;\n\n        if (avctx->profile & FF_PROFILE_H264_INTRA)\n\n            mseq->constraint_set3_flag = 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17128, "substitutes": {"avctx": ["avectx", "devctx", "avconfig", "Avkb", "AVconfig", "varcm", "afcu", "varcmp", "aveconn", "devkb", "avkb", "avcm", "vcm", "abctrl", "AVkb", "AVcmp", "AVcu", "avctrl", "afcontext", " avcu", "AVcm", "Avcontext", "devconfig", "Avcu", "avconn", "afctx", "abctx", "abcontext", "afctrl", "vcmp", "abkb", "abconfig", "avecontext", " avkb", "varctx", "afconn", "avectrl", "AVctx", " avcontext", "AVconn", "abconn", "AVcontext", "Avconn", "avcmp", "vctx", "avcu", "vcontext", "Avctx", "avcontext", "varcontext", "devcontext"], "ctx": ["pc", "rx", "instance", "cfg", "cdn", "fp", "cca", "cus", "vc", "conn", "concept", "rc", "cm", "cf", "cb", "anc", "bc", "cp", "loc", "wcs", "utils", "mc", "scope", "ctrl", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "conv", "kb", "pkg", "common", "tx", "nc", "ci", "tc", "config", "xc", "qs", "sc", "cu", "cam", "client", "cli", "lc", "c", "req", "sync", "qa", "cmd", "uc", "lib", "ck", "sci", "cmp", "fn", "sys", "cn", "sq", "cv", "cc"], "vseq": [" vsequ", "variseq", "Vsequ", "revsequ", " vsequence", "nsequence", "lzip", "vstruct", "Vclus", "vref", "voltseq", "fvec", "evclus", "nvsequence", "revna", "guvec", "msequence", "tvseq", "ssequ", "gumodel", " vzip", "mfeat", "lvec", "vna", "varimodel", "svsequ", "revvec", "lparent", "voltsequ", "Vsequence", "fsequence", "tvzip", "vctx", "svstruct", "sref", "lseq", "lvcomplete", "guiq", "msequ", "lref", " vctx", "revseq", "vsequ", " vstruct", "lcomplete", "nseq", "varisem", "nstruct", " viq", "hsem", "vsem", "lvsequence", "mclus", "voltsequence", "vbuf", "svsem", "fctx", "lsequence", "svsequence", "wsequ", "ssequence", "nvvec", "lsequ", "voltsem", "fsequ", "evfeat", "sseq", "revscript", "tvsequence", " vna", "wseq", "psequence", "Vseq", "guseq", "Vvec", "versequ", "wsem", "wsequence", "versequence", "evsequence", "Vbuf", "viq", "tvclus", "evframe", "svbuf", "psequ", "svseq", "liq", "lclus", "vscript", "hscript", "hseq", "fseq", "vervec", "revfile", "fsem", "lna", "varivec", "hclus", "vframe", "svclus", "Vfeat", "fstruct", "nvfile", " vref", "evsequ", "Vmodel", "vgen", "vparent", "vmodel", "Vframe", " vgen", " vfeat", "pscript", "vcomplete", "vclus", " vframe", "pseq", "hsequ", "verseq", "vsequence", "lvseq", "Vfile", " vparent", "vfeat", "gusequence", "revsequence", "vvec", "nvseq", " vvec", "hgen", " vclus", "varisequence", "Vctx", "Vstruct", "lvsequ", "evseq", "variclus", "vfile", "vzip", "revparent", " vcomplete", "nbuf", "mgen", " vsem", "hsequence"], "vpic": [" vstruct", "mpic", "vstruct", "svmac", "mstruct", "svctx", "mmac", "vctx", "svstruct", "vmac", " vmac", " vctx", "mctx", "svpic"], "priv": ["util", "cfg", "txt", "ch", "data", "pub", "conf", "obj", "cca", "vc", "reader", "rc", "Priv", "acc", "cb", "anc", "auth", "cp", "loc", "ocr", "fac", "utils", "mc", "sec", "pb", "kw", "sk", "ca", "auc", "roc", "gb", "pkg", "tx", "aux", "pri", "ci", "config", "soc", "prof", "cam", "voc", "client", "private", "req", "lc", "ki", "ram", "uc", "access", "cache", "cmp", "rate", "sys", "proc", "riv", "prem", "conn", "cci"], "mseq": ["vmsequ", "mmsequ", "fmsequ", "mmsequence", "fmseq", "vmsel", "fmsequence", "mmseq", "msel", "msequ", "mmsel", "vmseq", "vmsequence", "msequence", "fmsel"], "i": ["ti", "m", "bi", "j", "x", "f", "qi", "ai", "n", "ii", "iu", "index", "I", "count", "ip", "d", "pi", "ui", "ci", "id", "k", "batch", "v", "c", "si", "p", "a", "li"]}}
{"project": "qemu", "commit_id": "0d6ff71ae3c7ac3a446d295ef71884a05093b37c", "target": 0, "func": "void if_start(Slirp *slirp)\n\n{\n\n    uint64_t now = qemu_clock_get_ns(QEMU_CLOCK_REALTIME);\n\n    bool from_batchq, next_from_batchq;\n\n    struct mbuf *ifm, *ifm_next, *ifqt;\n\n\n\n    DEBUG_CALL(\"if_start\");\n\n\n\n    if (slirp->if_start_busy) {\n\n        return;\n\n    }\n\n    slirp->if_start_busy = true;\n\n\n\n    if (slirp->if_fastq.ifq_next != &slirp->if_fastq) {\n\n        ifm_next = slirp->if_fastq.ifq_next;\n\n        next_from_batchq = false;\n\n    } else if (slirp->next_m != &slirp->if_batchq) {\n\n        /* Nothing on fastq, pick up from batchq via next_m */\n\n        ifm_next = slirp->next_m;\n\n        next_from_batchq = true;\n\n    } else {\n\n        ifm_next = NULL;\n\n    }\n\n\n\n    while (ifm_next) {\n\n        ifm = ifm_next;\n\n        from_batchq = next_from_batchq;\n\n\n\n        ifm_next = ifm->ifq_next;\n\n        if (ifm_next == &slirp->if_fastq) {\n\n            /* No more packets in fastq, switch to batchq */\n\n            ifm_next = slirp->next_m;\n\n            next_from_batchq = true;\n\n        }\n\n        if (ifm_next == &slirp->if_batchq) {\n\n            /* end of batchq */\n\n            ifm_next = NULL;\n\n        }\n\n\n\n        /* Try to send packet unless it already expired */\n\n        if (ifm->expiration_date >= now && !if_encap(slirp, ifm)) {\n\n            /* Packet is delayed due to pending ARP resolution */\n\n            continue;\n\n        }\n\n\n\n        if (ifm == slirp->next_m) {\n\n            /* Set which packet to send on next iteration */\n\n            slirp->next_m = ifm->ifq_next;\n\n        }\n\n\n\n        /* Remove it from the queue */\n\n        ifqt = ifm->ifq_prev;\n\n        remque(ifm);\n\n\n\n        /* If there are more packets for this session, re-queue them */\n\n        if (ifm->ifs_next != ifm) {\n\n            struct mbuf *next = ifm->ifs_next;\n\n\n\n            insque(next, ifqt);\n\n            ifs_remque(ifm);\n\n\n\n            if (!from_batchq) {\n\n                /* Next packet in fastq is from the same session */\n\n                ifm_next = next;\n\n                next_from_batchq = false;\n\n            } else if (slirp->next_m == &slirp->if_batchq) {\n\n                /* Set next_m and ifm_next if the session packet is now the\n\n                 * only one on batchq */\n\n                slirp->next_m = ifm_next = next;\n\n            }\n\n        }\n\n\n\n        /* Update so_queued */\n\n        if (ifm->ifq_so && --ifm->ifq_so->so_queued == 0) {\n\n            /* If there's no more queued, reset nqueued */\n\n            ifm->ifq_so->so_nqueued = 0;\n\n        }\n\n\n\n        m_free(ifm);\n\n    }\n\n\n\n    slirp->if_start_busy = false;\n\n}\n", "idx": 17133, "substitutes": {"slirp": ["llairpc", "skirdpad", "slrisp", "ellrisp", "slirer", "pullirper", "slarenapp", "slairpi", "splirmpatch", "ylearpa", "ylearpc", "delirap", "delirper", "slearpa", "ylirpc", "sliroc", "slurpi", "helirap", "spliroper", "slyrpo", "slwerper", "slearp", "slirtpad", "llirp", "slaripc", "blirc", "slirr", "selirc", "ellrisc", "slairc", "slyrpa", "ellirc", "ellrispre", "swurr", "slairpc", "sloirp", "pullwerp", "seloirpo", "hellirapp", "slwerpi", "blirpc", "sliverp", " slirf", "slirtcp", "helliralph", "slarip", "slpirc", "Slir\n", "llirpc", "ylirpa", "Slirall", "slirdpad", "deliraping", "slarenp", "slirall", "sliverpc", "spliroc", "sliroper", "Slirn", "slirper", "helirapo", "sliripi", "splirl", "slirpress", "slairpress", "sliripre", "sliralper", "slpirp", "slirapo", "splirc", "sliripo", "sliralapp", "selirf", "sliperp", "seliperp", "slurpe", "skirpad", " slirping", "Slmirn", "slirepc", "slirtpc", "slirepe", "slearpi", "slirpatch", "blirp", "pullwerpc", "sliriper", "splirmp", "slirpy", "splirpatch", "seloirpc", "blairc", "slirlpi", "slrisc", "slirapp", "slirl", "sliralpi", "shirpc", "seliperc", "spliropy", "slpirpo", "slirpad", "slrispc", "slaril", "slirop", "slirpe", "splirper", "slivern", "delirpa", "slirapy", "skirdp", "slwerp", "slariall", "sliralpa", "skirb", "shirtpc", "slirpre", "pullwerpi", "slrisn", "slirph", "sliperpc", "slurb", "slirping", "skirdcp", "helirpo", "ylirpi", "slirlper", "delirping", "shirtr", "sliroping", "slaripe", "sliropy", "splirpy", "sliraf", "pullirpi", "slpirpc", "shirp", "llirpress", "blirl", "shirr", "hellirph", "slpirpy", "swirp", "slirmp", "splirp", "ellirpe", "Slmir\n", "selirpc", "ylirp", "slrisl", "sliralph", "slirlp", "slrisall", "sliropa", "sliverping", "seliperf", "slirf", " slirap", "swirpc", "delirp", "slris\n", " slirapy", "ellrispe", "slirpo", "slairapp", "sliripad", "sliverpy", "slirec", "slirc", "skirdb", "sliren", "llairpress", "blirpi", "slurc", "sliralping", "pullirpc", "slirb", "blrispc", "helliralapp", "Slmirall", "seliperpc", "slirapa", "slpirpe", "sliverf", "helliralp", " sliraf", "slurp", "swirpe", "slyrper", "ylearpi", "sliarper", "slearpc", "slirtp", "deliraper", "slairph", "slir\n", "sliraper", "blairpi", "skirp", "slmirn", "slirmpatch", "slirn", "slirtpatch", "llairp", "slirep", "sliripa", "slirapi", "slairb", "slirtn", "shirtn", "sliripress", "sliricp", "slyrp", "selirp", "sliarpress", "helirapc", "sliripe", "sliperf", "splirop", "sliripy", "selirpo", "swirr", "slarenph", "slirdp", "seloirp", "splirml", "sliperpatch", "slarir", "slirlpc", "slireb", "llirper", "sliraping", "blairb", "skircp", "sliperc", "slurr", "slpirl", "swurp", "ellirp", "swurpe", "sliralp", "ellirpre", "pullwerper", "delirapa", "slirdb", " sliraping", "splirmpc", "slirpc", "slmirall", "pullirp", "blirb", "slpirf", "slurpc", " slirpy", "sliverr", "splirpc", "slwerpc", "helirapi", "slarin", "slyrpi", "helirpc", "hellirpi", "slirap", "helliralpi", "slrispe", "slirepi", "slirib", "slairp", "blrispe", "slirip", "slairper", "sliric", "sliperl", "slari\n", "blairp", "slearpo", "slirapc", "blirpe", "slyrpc", "slircp", "shirtp", "shirn", "slirtl", "slarenpi", "sloirpc", "sliarp", "slirpa", "slirml", "helirpi", "slirpi", "hellirp", "sloirpo", "slpirping", "helirp", "sliref", "slirmpc", "llairper", "slirtb", "sliarpc", "slirtr", "blrisl", "slmir\n", "slrispre", "slirdcp", "swurpc", "seloirc", "blrisp", "slpirpre", "sliripc", "sloirc", "ylearp", "slpirper"], "from_batchq": ["from_broadQ", "from_batchQ", "from_banq", "from_fastq", "from_queueq", "from_banp", "from_banquest", "from_broadp", "from_batchp", "from_batchquery", "from_broadquery", "from_queuequery", "from_fastr", "from_batQ", "from_batr", "from_broadr", "from_batq", "from_fastqu", "from_catchQ", "from_queuep", "from_batchquest", "from_broadquest", "from_batchr", "from_banquery", "from_catchqu", "from_queuequest", "from_broadqu", "from_catchq", "from_broadq", "from_batchqu", "from_fastQ"], "next_from_batchq": ["next_from_batchquery", "next_from_blockqu", "next_from_broadw", "next_from_groupq", "next_from_groupg", "next_from_fastq", "next_from_sessionqu", "next_from_batchg", "next_from_workq", "next_from_broadf", "next_from_broadq", "next_from_fastw", "next_from_batchqs", "next_from_fastqu", "next_from_groupqa", "next_from_batq", "next_from_combw", "next_from_sessionqs", "next_from_blockp", "next_from_groupqu", "next_from_combqu", "next_from_batu", "next_from_combq", "next_from_batchqa", "next_from_broadqa", "next_from_workqs", "next_from_combp", "next_from_fastp", "next_from_sessionp", "next_from_sessionu", "next_from_bareg", "next_from_sessionqa", "next_from_fastg", "next_from_batchu", "next_from_bareqa", "next_from_broadqu", "next_from_bareq", "next_from_sessionquery", "next_from_batchw", "next_from_batp", "next_from_broadu", "next_from_batchqu", "next_from_fastqa", "next_from_batqu", "next_from_broadquery", "next_from_broadqs", "next_from_barequ", "next_from_batchf", "next_from_workqa", "next_from_sessionq", "next_from_blockq", "next_from_batf", "next_from_workp", "next_from_sessionf", "next_from_batchp", "next_from_broadp", "next_from_batquery"], "ifm": ["itermr", "IFmi", "actm", "actp", " ifym", "libM", " iff", "evp", "itM", "elf", "forz", "itr", "ofm", "iff", "ift", " ifmi", "forn", "elm", "itern", "ipp", "ifmr", "ifmi", "itv", "libdm", "ilrm", "ifM", "expM", "ifn", "ifym", "fm", "itermt", " ifp", "iterm", "ilr", "immr", "ipM", "itmt", "ibmt", "iterdm", "Ifdm", "ifc", "iterp", "itdm", "ifz", "ifrm", "ifr", "ifh", "ibmi", " ifrm", "actM", "expmi", "Ifm", "fdm", "ifdm", " ifdm", "IFf", "IFmt", " ifM", " ifmr", "Ifn", "evmt", "imfm", "fmi", "imn", "iterc", "expp", "IFym", "ilm", "elv", "ith", "Ifnm", "IFm", "itn", "libm", "ofc", "Ifp", "itf", "fmt", "evf", "actym", "ibm", "evdm", "ibdm", " ifz", "IFdm", "ifp", "itnm", "iffm", "itert", "ipmi", "itm", "ifnm", "imm", "elh", "IFv", "evmi", "IfM", "expm", "Ift", "iterfm", "ofdm", "itrm", " ift", " ifn", "IFp", "itp", "libp", "Ifmi", " ifmt", "itc", "ilf", "ofmt", "ifv", "IFh", " ifr", "IFM", "form", "forp", " ifnm", "ipm", "ifmt", "Ifz", "evm", " iffm"], "ifm_next": ["ifp__close", "ifmacskip", "ifp_next", "ifm___prev", "ifn_Next", "ifm___next", "ifmacprev", "ifm_conn", "ifm_parent", "ifcm_next", "ifp_future", "ifp__next", "ifp_last", "ifp__current", "iffm_page", "ifcm_start", "ifm_seen", "ifm__future", "ifm_sen", "ifm__sen", "ifcm_skip", "ifcm__start", "ifp__prev", "ifp_current", "ifcm__next", "iffm_seen", "ifm__current", "ifsm_current", "ifgm_conn", "ifgm_next", "iffm_next", "ifm_adj", "ifm__close", "ifm__last", "ifm_start", "ifdm_future", "ifp_prev", "ifmacnext", "ifm__next", "ifmacfuture", "ifcm__new", "ifp_new", "ifcm_prev", "ifm___current", "ifm__start", "ifm_current", "ifsm_next", "ifsm_post", "ifm___adj", "ifn_last", "ifdm_prev", "ifp_close", "ifdm_next", "ifcm_future", "ifm__prev", "ifm_post", "ifn_new", "ifm_last", "ifm_page", "ifcm_new", "ifcm_sen", "ifcm_current", "ifm_prev", "ifdm_new", "ifn_next", "ifm_close", "ifm_skip", "ifm_future", "ifcm__prev", "ifm__Next", "ifsm_parent", "ifm__new", "ifgm_new", "ifcm_adj", "ifm_Next", "ifgm_last", "ifm_new"], "ifqt": [" ifqi", "Ifqi", "affqt", "ifqa", "ifqq", "Ifchid", "fqt", "Ifqt", "Iftxt", "flyqt", "afftxt", "affchid", " ifquick", "ifquick", " ifqq", "affqq", "libqt", "Ifqq", "ifchid", "flytxt", "libqa", "libquick", "libqq", "flychid", "fquick", " ifqa", "fqa", "libqi", "fqq", "flyqq", "Ifqa", "ifqi", "iftxt"], "next": ["skip", "code", "dot", "image", "full", "then", "more", "version", "job", "current", "max", "sec", "gov", "page", "again", "later", "new", "first", "future", "step", "style", "flow", "last", "foo", "prev", "start", "open", "primary", "latest", "client", "follow", "doc", "shift", "missing", "good", "Next", "second", "sequence", "valid", "frame", "reply", "now", "success"]}}
{"project": "qemu", "commit_id": "926cde5f3e4d2504ed161ed0cb771ac7cad6fd11", "target": 0, "func": "static void handle_ti(ESPState *s)\n\n{\n\n    uint32_t dmalen, minlen;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_ti;\n\n        return;\n\n    }\n\n\n\n    dmalen = s->rregs[ESP_TCLO];\n\n    dmalen |= s->rregs[ESP_TCMID] << 8;\n\n    dmalen |= s->rregs[ESP_TCHI] << 16;\n\n    if (dmalen==0) {\n\n      dmalen=0x10000;\n\n    }\n\n    s->dma_counter = dmalen;\n\n\n\n    if (s->do_cmd)\n\n        minlen = (dmalen < 32) ? dmalen : 32;\n\n    else if (s->ti_size < 0)\n\n        minlen = (dmalen < -s->ti_size) ? dmalen : -s->ti_size;\n\n    else\n\n        minlen = (dmalen < s->ti_size) ? dmalen : s->ti_size;\n\n    trace_esp_handle_ti(minlen);\n\n    if (s->dma) {\n\n        s->dma_left = minlen;\n\n        s->rregs[ESP_RSTAT] &= ~STAT_TC;\n\n        esp_do_dma(s);\n\n    }\n\n    if (s->do_cmd) {\n\n        trace_esp_handle_ti_cmd(s->cmdlen);\n\n        s->ti_size = 0;\n\n        s->cmdlen = 0;\n\n        s->do_cmd = 0;\n\n        do_cmd(s, s->cmdbuf);\n\n    }\n\n}\n", "idx": 17141, "substitutes": {"s": ["ns", "spec", "stat", "full", "settings", "service", "ss", "cs", "d", "new", "ims", "qs", "sym", "p", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "in", "self", "lines", "o", "changes", "su", "side", "v", "si", "S", "uses", "a", "ds", "ans", "status", "bs", "uns", "f", "sv", "r", "sb", "as", "sports", "l", "ins", "serv", "sync", "c", "ps", "secondary", "b", "sys", "es", "state", "states", "sq", "params", "session", "t", "stats", "rates", "conf", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "se", "server", "y", "u"], "dmalen": ["dmlener", "dbilened", "dpalzen", "dmaeno", "dpalen", "davalenn", "admadzen", "admadener", "dmcfen", "dmaleni", " dnamzen", "dmaclen", "dallen", "odmalened", "dbroadener", "odmallen", "dmlens", "ldalen", "dataleen", "dgaleen", "dmileni", "dalen", "cmalfen", "dbilender", "dmaenn", "dmlfen", "cstalfen", "davalfen", "dstalened", "dmalena", "odmlening", "dmalenn", "dstalien", "dbalien", " dmalena", "dglens", "dbaleng", "dstalfen", "dmadene", " dmalzen", "Dmalien", "dstalener", "dgalien", "dalens", "Dmalener", "dmafen", "dmacening", "dbroaden", "odmalening", "daleni", " dnamener", "admalene", "admalzen", "dmadzen", "dmaceni", "dglener", "dalleng", " dmalens", "admaden", "dbilzen", " davalen", "ldalened", "dmcen", "Dmaleng", "dmilien", " dmalener", "odmlened", "dstalena", "dmlening", "dbalener", "dmclen", "cmalen", "dmadener", "ldmalen", "davalpen", "dallien", "dmllen", "dmasen", "dpalener", "cmalened", " davalener", "dstallen", "dmaleno", "Dmalens", " dmaleno", "dgalening", "dgalena", "davalener", "dmalened", "Dmileng", "dglen", "ddmalens", "dmalpen", "dmaens", "dmaener", "Dmilens", " dgleno", "dmalene", "Dmilien", "Dmilen", "ldmalens", "dstalens", "dphalene", "dnamzen", " dglen", "dmilener", "datalens", "dalened", "dbroadzen", " dgalena", "dgalen", "admadene", "dmacen", "dbilen", "dmlened", "dbalpen", " dnamender", "dmilened", "ddataleen", "ddmalen", "ldalens", "dphalen", "dgalened", "dmilening", "ddatalener", "dnamener", "dmaden", "dmlan", "dmcened", "dstalening", "dmacens", "dmaen", "dmalender", "datalen", "Dmalan", "dmasan", " dmalien", "dphalener", "dgalpen", "dmilens", "dmallen", "ddmaleen", "dnamen", " davalenn", "dmalzen", "dmlen", " davalfen", " dgalened", "dmalan", " dgalening", "dgleno", "dbalened", "dmalfen", "ldmalened", "dmileno", "dmilena", "cstalen", " dmalenn", "dpalene", "dmasens", "dmlenn", "ddatalens", "admalener", " dnamen", "cstallen", "ldaleni", "dstalen", "admalen", " dglens", " davalpen", "datalener", " dmalening", "dmalien", "dmalener", "dmacened", "ldmaleni", " dgalen", "cstalened", "dbilien", "dbilener", " dmalpen", " dmalender", "dmaleen", "odmlen", "dbalen", "dmileen", " dgalener", "dallens", "odmllen", " dglener", "dmalening", "dgalener", " dmalfen", "Dmilener", "dmilan", "davalen", "dnamender", " davalened", "ddatalen", " dgalens", " dmalened", "Dmalen", "dmasener", "odmalen", "dbalens", "dmileng", "dphalzen", "davalened", "dmalens", "cmallen", "dbroadender", "dmilen", "dmaleng", "dgalens", " dgalien", "Dmilan", "ddmalener"], "minlen": ["Minrel", "miniLen", "minln", "olden", "minien", "MINlen", "Minlen", "minrel", "MINval", "minval", "Minen", "unlin", "oldlen", "MinLen", "Minlin", "Minpos", " minLen", "smalllen", " minlon", "oldln", "minpos", "minilen", "minilon", "oldlin", "minipos", "minen", " minpos", "unlen", "MINLen", "Minlon", "aminlen", "aminen", "smallen", "Minln", "unln", "minLen", " minen", "minilin", " minval", "Minval", "unen", "minlon", "minlin", " minrel", "smallval", " minlin", "aminrel"]}}
{"project": "qemu", "commit_id": "6acbe4c6f18e7de00481ff30574262b58526de45", "target": 0, "func": "static void lsi53c895a_register_devices(void)\n\n{\n\n    type_register_static(&lsi_info);\n\n    type_register_static_alias(&lsi_info, \"lsi\");\n\n}\n", "idx": 17152, "substitutes": {}}
{"project": "qemu", "commit_id": "b074e6220542107afb9fad480a184775be591d2a", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172, "substitutes": {"scon": ["suc", "Scon", "ssco", " sconf", "sct", " src", "sincn", "cscan", " suc", " scc", "Scan", " sct", "Src", " sca", "Sconf", "nscon", "sscon", " sban", "sban", "cCON", "wscc", "scan", " sCON", "Sbc", "sca", "csct", "sincon", "cca", "ssCON", " sco", "tscon", "ssuc", "Sco", "tsun", "vesco", "socon", "tsbc", "scc", "tsca", " sbn", "sinconference", " sconference", " sbc", "lsco", "sbn", "ssbn", " socon", "rsct", "src", "vescon", "scn", "Sct", "vesocon", "csocon", "Sbn", "nsocon", " sun", "wsocon", "rsocon", "Sun", "ccon", "sconf", "csconf", "cscon", "nsbc", "wsco", "lscon", "rscon", " scn", "sinocon", "ssban", "sCON", "sco", "SCON", "crc", "sbc", "nsct", "wscon", "Sca", "csbc", " scan", "rsbc", "lsuc", "sconference", "vescc", "lsban", "sun"], "buf": ["ff", "data", "func", "fp", "ref", "pool", "buffer", "rc", "vec", "feed", "fi", "cb", "bc", "src", "ctx", "pb", "mem", "cas", "context", "fl", "conv", "img", "queue", "config", "fd", "buff", "batch", "fb", "rb", "seq", "cmd", "b", "alloc", "port", "bag", "uf", "cv", "conn"], "size": ["scale", "content", "offset", "capacity", "code", "small", "core", "SIZE", "name", "x", "esc", "n", "sized", "g", "i", "z", "loc", "max", "source", "done", "password", "en", "count", "model", "eng", "speed", "enc", "empty", "ce", "grade", "large", "ize", "length", "e", "send", "sync", "c", "unit", "si", "needed", "iz", "p", "address", "fee", "gz", "sum", "cache", "form", "storage", "number", "Size", "message", "end", "grow", "len"]}}
{"project": "qemu", "commit_id": "d3aea641a4002e0abe940c65d318ef38eda245df", "target": 1, "func": "static void usbredir_do_attach(void *opaque)\n\n{\n\n    USBRedirDevice *dev = opaque;\n\n\n\n    /* In order to work properly with XHCI controllers we need these caps */\n\n    if ((dev->dev.port->speedmask & USB_SPEED_MASK_SUPER) && !(\n\n\n                                    usb_redir_cap_ep_info_max_packet_size) &&\n\n\n\n\n                                    usb_redir_cap_64bits_ids))) {\n\n        ERROR(\"usb-redir-host lacks capabilities needed for use with XHCI\\n\");\n\n        usbredir_reject_device(dev);\n\n        return;\n\n    }\n\n\n\n    if (usb_device_attach(&dev->dev) != 0) {\n\n        WARNING(\"rejecting device due to speed mismatch\\n\");\n\n        usbredir_reject_device(dev);\n\n    }\n\n}", "idx": 17199, "substitutes": {"opaque": ["opga", "Opaque", " opga", "Opaya", "Opcontainer", "OPcontainer", "OPec", "opedcontainer", "opaya", "opcontainer", "opec", "opedec", "opwebkit", "opusga", "ocwebkit", "opedaque", "opedaya", "Opec", "ocga", "ocaque", "opusaque", " opwebkit", "OPaque", "opuswebkit", "OPaya"], "dev": ["dc", "grad", "prov", "Dev", "mod", "ch", "data", "info", "conf", "user", "pub", "obj", "comment", "google", "reg", "ver", "gu", "md", "de", "debug", "pack", "rad", "app", "var", "ow", "di", "mem", "def", "prom", "self", "enc", "home", "prop", "link", "d", "hw", "adv", "av", "img", "ev", "ad", "serv", "mount", "w", "cam", "v", "dom", "device", "req", "cmd", "off", "driver", "pad", "plug", "p", "od", "cmp", "error", "cd", "proc", "boot", "dem", "api", "DEV", "priv", "h", "port", "die", "mac", "diff", "ve", "conn", "bug"]}}
{"project": "FFmpeg", "commit_id": "e62ef8f2dbf1ac0a197310f2be69c93b89f838c2", "target": 0, "func": "static av_cold void set_bandwidth(AC3EncodeContext *s, int cutoff)\n\n{\n\n    int ch, bw_code;\n\n\n\n    if (cutoff) {\n\n        /* calculate bandwidth based on user-specified cutoff frequency */\n\n        int fbw_coeffs;\n\n        cutoff         = av_clip(cutoff, 1, s->sample_rate >> 1);\n\n        fbw_coeffs     = cutoff * 2 * AC3_MAX_COEFS / s->sample_rate;\n\n        bw_code        = av_clip((fbw_coeffs - 73) / 3, 0, 60);\n\n    } else {\n\n        /* use default bandwidth setting */\n\n        /* XXX: should compute the bandwidth according to the frame\n\n           size, so that we avoid annoying high frequency artifacts */\n\n        bw_code = 50;\n\n    }\n\n\n\n    /* set number of coefficients for each channel */\n\n    for (ch = 0; ch < s->fbw_channels; ch++) {\n\n        s->bandwidth_code[ch] = bw_code;\n\n        s->nb_coefs[ch]       = bw_code * 3 + 73;\n\n    }\n\n    if (s->lfe_on)\n\n        s->nb_coefs[s->lfe_channel] = 7; /* LFE channel always has 7 coefs */\n\n}\n", "idx": 17203, "substitutes": {"s": ["ns", "ans", "spec", "m", "ts", "sg", "t", "rs", "conf", "f", "sv", "settings", "services", "comments", "service", "n", "sb", "g", "i", "ss", "ls", "ctx", "fs", "xs", "self", "is", "o", "cs", "l", "d", "su", "ins", "sites", "site", "features", "w", "qs", "e", "ssl", "side", "ses", "v", "sync", "c", "js", "si", "ps", "sym", "p", "S", "b", "gs", "sys", "u", "h", "its", "a", "es", "states", "os", "parts", "hs", "us", "south", "sets", "sq", "an", "ds", "sf"], "cutoff": [" cutback", "rubback", " cutOff", "catoffset", "Cutoffs", "cutcut", "caseoffs", "cutoffset", "catchcut", "Cutdown", " cutoffs", "contractoff", "cutback", "crophalf", "Cutoffset", "ruboffs", "cropback", "falloff", "catright", "caseoff", "rubdown", "ruboff", "cropoff", "rubhalf", "catchup", "CutOFF", " cuthalf", "cutOFF", " cutup", "cuthalf", "contractoffset", " cutcut", "rubOff", "Cutright", "catchoff", "fallup", " cutdown", "cutoffs", "cutup", "cropOff", "Cutoff", "caseOFF", "catoffs", "cutdown", " cutOFF", "cutright", "contractright", "fallcut", "contractoffs", "cutOff", "catoff"], "ch": ["work", "code", "cry", "cht", "che", "och", "f", "base", "cor", "core", "conn", "rc", "ver", "hop", "cf", "cha", "channel", "CH", "i", "cho", "coll", "cp", "mot", "th", "app", "ctx", "chid", "ich", "count", "game", "ech", "sk", "chi", "change", "ach", "cher", "zh", "chat", "cel", "Ch", "chu", "sch", "k", "q", " chunk", "bh", "client", "cat", "chan", "c", "v", "cur", "cl", "p", "b", "pr", "arch", "col", "oy", "h", "ph", "chart", "chn", "el", "chip"], "bw_code": ["bw_length", "bww_codes", "bwa_code", "bw_cod", "bw_coded", "bw_call", "bw2length", "bwd_one", "bwa_count", "bwd_code", "bwscoded", "bww64length", "bwprecodes", "bw_Code", "bww_length", "bwd_cod", "bwpreloc", "bwa_call", "bw2code", "bww64rate", "bwhscode", "bw_one", "bww64codes", "bw64length", "bwa_Code", "bww_rate", "bwa_loc", "bwa_codes", "bwh_code", "bwh_codes", "bwhscoded", "bwa_rate", "bwscodes", "bw_codes", "bwh_coded", "bw2codes", "bww_code", "bw_count", "bww64code", "bw64rate", "bwhscodes", "bw64code", "bw64codes", "bwscode", "bw2rate", "bwprecode", "bw_rate", "bw_loc", "bwprecall"], "fbw_coeffs": ["fbw_coefficientsits", "fbw_coEFFes", "fbw_coefficienti", "fbw_coeffits", "fbw_coEFFits", "fbw_coEFFs", "fbw_coffs", "fbw_coffits", "fbw_coefi", "fbw_coefficientsp", "fbw_coefficientsn", "fbw_coeffes", "fbw_coefficientss", "fbw_coefficients", "fbw_coeffi", "fbw_coefn", "fbw_coefficientsi", "fbw_coeffp", "fbw_coffp", "fbw_coffi", "fbw_coefits", "fbw_coefficientn", "fbw_coefficientits", "fbw_coefs", "fbw_coEFFi", "fbw_coeffn", "fbw_coffes", "fbw_coefp", "fbw_coefes"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, const uint8_t *src1, const uint8_t *src2, long width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"movq \"MANGLE(bm01010101)\", %%mm4           \\n\\t\"\n\n        \"mov                    %0, %%\"REG_a\"       \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq    (%1, %%\"REG_a\",4), %%mm0           \\n\\t\"\n\n        \"movq   8(%1, %%\"REG_a\",4), %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"psrlw                  $8, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm0           \\n\\t\"\n\n        \"movq                %%mm0, %%mm1           \\n\\t\"\n\n        \"psrlw                  $8, %%mm0           \\n\\t\"\n\n        \"pand                %%mm4, %%mm1           \\n\\t\"\n\n        \"packuswb            %%mm0, %%mm0           \\n\\t\"\n\n        \"packuswb            %%mm1, %%mm1           \\n\\t\"\n\n        \"movd                %%mm0, (%3, %%\"REG_a\") \\n\\t\"\n\n        \"movd                %%mm1, (%2, %%\"REG_a\") \\n\\t\"\n\n        \"add                    $4, %%\"REG_a\"       \\n\\t\"\n\n        \" js                    1b                  \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++) {\n\n        dstU[i]= src1[4*i + 1];\n\n        dstV[i]= src1[4*i + 3];\n\n    }\n\n#endif\n\n    assert(src1 == src2);\n\n}\n", "idx": 17206, "substitutes": {"dstU": ["dstP", "dstsUR", "dSTG", "drcCU", "drcP", "dstUR", "srcP", "DSTUR", "DstM", "DSTM", "dSTU", "srcI", "dsrcUV", "dblUV", "dsrcM", "dstUV", "ddestU", "dsrcI", "dSTUV", "sstP", "dsrcO", "dstsU", "DstO", "dSTM", "DSTUV", "DstI", "srcCU", "dsrcU", "DSTG", "dsrcG", "dSTO", "dstG", "sstI", "dblM", "DSTU", "dstM", "DstUR", "dstCU", "ddestP", "drcU", "dblU", "dstsO", "dstsI", "DSTI", "DstG", "srcU", "DSTO", "sstCU", "dstI", "dsrcUR", "drcI", "ddestCU", "dspI", "dspP", "dSTI", "dSTUR", "dspCU", "DstU", "dblG", "dstO", "dspU", "ddestI", "sstU", "DstUV"], "dstV": ["dsrcV", "dstP", "destR", " dSTU", "dstsV", "dostV", " destV", "dstsNV", "dconstU", "dsrcI", "dSTU", "dconstV", "DstV", "dblV", " dSTI", "dstsU", "dstR", "DstI", " dstR", " dstI", " dstNV", "dSTV", "dostU", "dsrcU", " dstP", "dblNV", "destV", "DSTV", "dsrcP", "DSTU", "dostP", "DstP", "dstsR", "DSTP", "dSTP", "dstNV", "dconstP", "dstsI", "dblU", " destNV", " destU", "DSTI", " dSTV", "dstI", "dostI", " destR", "dSTI", " dSTP", "DstU", "dstsP", "destNV", "dblR", "dconstI", "destU"], "src1": ["srcN", "rcOne", " src01", "rc2", "src3", "distone", "sur2", "srcone", "source1", "rc3", "sourceOne", " src3", "sur1", "host1", "hostN", "source2", "src01", "sur3", "rc01", "config2", "dist1", "host2", "source3", "rc1", "rcone", "configone", "rcN", "config1", "sur01", "dist2", "srcOne", " srcN", " srcOne"], "src2": [" src0", "srcTwo", "rc2", "src0", "src4", "source1", "rcTwo", " src4", "rc02", "source2", " src02", "source0", "sourceTwo", "source4", "rc1", "source02", "rc4", "src02", "rc0", " srcTwo"], "unused": ["unaligned", "unainitialized", "Unused", "untchecked", "unaused", "unaaligned", "Uninitialized", "unchecked", "Unchecked", "untaligned", "untinitialized", "unachecked", "uninitialized", "Unaligned", "untused"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "s", "info", "x", "ix", "ini", "qi", "ai", "io", "n", "phi", "fi", "hi", "block", "z", "var", "ii", "di", "index", "ind", "slice", "I", "mini", "multi", "zi", "count", "vi", "ip", "l", "oi", "pi", "ui", "ci", "abi", "id", "k", "e", "v", "lc", "c", "si", "ri", "xi", "p", "b", "mu", "col", "uli", "h", "it", "eni", "diff", "li", "u"]}}
{"project": "qemu", "commit_id": "68931a4082812f56657b39168e815c48f0ab0a8c", "target": 0, "func": "static void xtensa_kc705_init(MachineState *machine)\n\n{\n\n    static const LxBoardDesc kc705_board = {\n\n        .flash_base = 0xf0000000,\n\n        .flash_size = 0x08000000,\n\n        .flash_boot_base = 0x06000000,\n\n        .flash_sector_size = 0x20000,\n\n        .sram_size = 0x2000000,\n\n    };\n\n    lx_init(&kc705_board, machine);\n\n}\n", "idx": 17240, "substitutes": {"machine": ["process", "m", "instance", "data", "mode", "base", "image", "net", "engine", "service", "M", "loader", "node", "mc", "manager", "model", "computer", "controller", "vm", "link", "database", "mobile", "mount", "parent", "device", "cache", "interface", "monitor", "Machine", "agent", "connection", "state", "mac", "server", "port", "motion"]}}
{"project": "qemu", "commit_id": "8607f5c3072caeebbe0217df28651fffd3a79fd9", "target": 0, "func": "static void virtqueue_unmap_sg(VirtQueue *vq, const VirtQueueElement *elem,\n\n                               unsigned int len)\n\n{\n\n    unsigned int offset;\n\n    int i;\n\n\n\n    offset = 0;\n\n    for (i = 0; i < elem->in_num; i++) {\n\n        size_t size = MIN(len - offset, elem->in_sg[i].iov_len);\n\n\n\n        cpu_physical_memory_unmap(elem->in_sg[i].iov_base,\n\n                                  elem->in_sg[i].iov_len,\n\n                                  1, size);\n\n\n\n        offset += size;\n\n    }\n\n\n\n    for (i = 0; i < elem->out_num; i++)\n\n        cpu_physical_memory_unmap(elem->out_sg[i].iov_base,\n\n                                  elem->out_sg[i].iov_len,\n\n                                  0, elem->out_sg[i].iov_len);\n\n}\n", "idx": 17242, "substitutes": {"vq": ["pqt", " vqt", "vg", "uque", "ug", "vque", " vg", "vqt", "pq", "uqt", " vque", "uq", "pg", "pque"], "elem": ["enle", "eles", "ehem", "element", "Elem", "playles", "zelegate", "Ele", "jehem", "aehem", "felem", "elegate", "evallems", "feel", "tembol", "aeject", "ezer", "playlegate", "embol", "eel", "eelem", "nelem", "oezer", "meolean", "peject", "eeject", "fehem", "ielem", "nelev", " elements", "oelements", "Element", "zelem", "zelems", "enlement", " elegate", "eolean", "pelements", "ele", " ezer", "ielev", " eles", "eehem", "ielement", "elements", "enlem", "elev", "jelems", "enject", "telem", "notehem", "edeolean", "playlem", "zeles", "evalhem", "jelect", "tehem", "oehem", "ieel", "oelem", "eele", "melete", "evallect", "eelev", "edelem", " ehem", "edelete", "oeler", "Eject", "aelement", "neler", "elems", "melem", "eject", "aeler", "aelements", "iehem", "fembol", "eezer", "enghem", "pelem", "elete", "notelete", "englect", "nelement", "oelev", "aelem", "eler", "eelement", "englems", "eelements", "jelem", "englem", "mehem", "aelev", "playlems", "elect", "teel", "iembol", "pelement", "nehem", " elems", "evallem", "noteolean", "notelem", "edehem"], "len": ["lon", "lim", "name", "base", "n", "lu", "ls", "loc", "pos", "mem", "min", "en", "lt", "count", "lf", "ln", "l", "val", "fl", "le", "length", "limit", "lc", "elt", "seq", "ll", "lib", "Len", "lock", "lan", "fn", "split", "lin", "list", "el", "li", " length"], "offset": ["set", "uri", "entry", "extra", "fp", "Offset", "base", "f", "align", "type", "loc", "padding", "index", "pos", "slice", "count", "pointer", "online", "o", "l", "location", "axis", "alias", "size", "zero", "uni", "ui", "adjust", "reset", "length", "prefix", "start", "e", "fit", "limit", "delay", "parent", "position", "p", "off", "address", "shift", "area", "next", "enabled", "number", "origin", "addr"], "i": ["uri", "bi", "x", "qi", "ai", "phi", "result", "hi", "ie", "ori", "d", "pi", "id", "cli", "ni", "p", "xi", "resource", "h", "it", "fi", "source", "gi", "m", "j", "name", "ix", "ini", "in", "iu", "I", "o", "load", "key", "v", "lc", "si", "ri", "iv", "a", "ti", "f", "base", "mi", "type", "ii", "di", "multi", "zi", "l", "oi", "yi", "ci", "start", "c", "b", " ii", "eni", "reply", "mu", "data", "info", "io", "n", "module", "index", "is", "ip", "ui", "isin", "e", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "67251a311371c4d22e803f151f47fe817175b6c3", "target": 0, "func": "static int vmdk_reopen_prepare(BDRVReopenState *state,\n\n                               BlockReopenQueue *queue, Error **errp)\n\n{\n\n    BDRVVmdkState *s;\n\n    int ret = -1;\n\n    int i;\n\n    VmdkExtent *e;\n\n\n\n    assert(state != NULL);\n\n    assert(state->bs != NULL);\n\n\n\n    if (queue == NULL) {\n\n        error_setg(errp, \"No reopen queue for VMDK extents\");\n\n        goto exit;\n\n    }\n\n\n\n    s = state->bs->opaque;\n\n\n\n    assert(s != NULL);\n\n\n\n    for (i = 0; i < s->num_extents; i++) {\n\n        e = &s->extents[i];\n\n        if (e->file != state->bs->file) {\n\n            bdrv_reopen_queue(queue, e->file, state->flags);\n\n        }\n\n    }\n\n    ret = 0;\n\n\n\nexit:\n\n    return ret;\n\n}\n", "idx": 17246, "substitutes": {"state": ["set", "stat", "session", "j", "code", "t", "data", "core", "element", "err", "f", "settings", "r", "pe", "str", "or", "ss", "scope", "slice", "manager", "self", "out", "is", "o", "State", "store", "parse", "sh", "new", "the", "seed", "style", "rule", "pse", "st", "config", "key", "start", "q", "k", "sync", "v", "private", "parent", "c", "STATE", "p", "address", "cache", "resource", "ace", "body", "local", "os", "er", "port", "se", "states", "a", "conn"], "queue": ["status", "group", "fp", "f", "pool", "buffer", "proxy", "r", "file", "job", "block", "Q", "manager", "Que", "ack", "array", "menu", "event", "ue", "pipe", "prefix", "q", "config", "buf", "sync", "v", "c", "seq", "lib", "line", "p", "que", "cache", "next", "route", "message", "sequence", "port", "server", "list", "command", "Queue", "callback", "progress", "collection"], "errp": [" errP", "ertp", " errcp", "err", "errP", "errpc", "rarps", "erpc", "rarp", "erp", " erp", "errr", " errr", "rrp", " erpc", "errps", "rrps", "rrcp", " errtp", " ertp", "rarP", " errps", "errtp", "rrP", "rarcp", " errpc", " err", "errcp"], "s": ["ns", "status", "spec", "m", "session", "sg", "ts", "bs", "stats", "rs", "f", "settings", "services", "ares", "service", "sb", "g", "ges", "sl", "ss", "ls", "as", "fs", "xs", "is", "o", "cs", "als", "l", "d", "su", "ins", "site", "qs", "ssl", "ses", "c", "ps", "si", "js", "p", "S", "b", "gs", "sys", "its", "es", "os", "us", "server", "states", "sq", "se", "ds", "u"], "i": ["ti", "uri", "gi", "wei", "m", "bi", "j", "ji", "t", "info", "x", "f", "err", "ini", "qi", "r", "io", "ai", "n", "phi", "g", "hi", "ii", "ie", "iu", "di", "ind", "index", "I", "multi", "zi", "o", "l", "adi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "v", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "a", "eni", "fi", "esi", "y", "li", "u"], "e": ["E", "m", "ei", "eb", "element", "f", "ine", "fe", "eu", "pe", "ne", "n", "g", "em", "je", "ge", "ie", "entity", "en", "ae", "ee", "o", "ze", "l", "d", "ce", "ed", "pse", "ue", "ev", "ep", "be", "oe", "c", "ea", "ade", "p", "line", "ele", "ec", "er", "es", "edge", "end", "se", "me", "el", "esi"]}}
{"project": "qemu", "commit_id": "bec1631100323fac0900aea71043d5c4e22fc2fa", "target": 0, "func": "static inline void tcg_out_goto_label(TCGContext *s, int label_index)\n\n{\n\n    TCGLabel *l = &s->labels[label_index];\n\n\n\n    if (!l->has_value) {\n\n        tcg_out_reloc(s, s->code_ptr, R_AARCH64_JUMP26, label_index, 0);\n\n        tcg_out_goto_noaddr(s);\n\n    } else {\n\n        tcg_out_goto(s, l->u.value_ptr);\n\n    }\n\n}\n", "idx": 17258, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "session", "t", "rs", "x", "f", "sv", "settings", "services", "service", "r", "n", "details", "sb", "g", "i", "sl", "ss", "src", "as", "in", "ops", "scope", "fs", "self", "xs", "lines", "is", "o", "cs", "d", "su", "space", "site", "e", "ssl", "ses", "sync", "private", "c", "js", "si", "ps", "sym", "p", "S", "b", "ks", "gs", "sys", "u", "a", "es", "os", "us", "sets", "se", "sq", "south", "ds", "sf"], "label_index": ["label_Index", "displayIdlocation", "labelIdind", " label_Index", "labelIdlength", "labelingindex", "label_start", "label_location", "labelingpos", "abel_index", "label__Index", "label_length", "displayIdind", "labelinglength", "displayIdlength", "display_location", "display_index", " label_pos", "labelIdlocation", "label__number", "display_ind", "labelinglocation", "labellenstart", "labelingind", "label__pos", " label_number", "labellenIndex", "displayIdindex", "labellenindex", "abel_start", "display_length", "label_ind", "label_number", "label__index", "abel_Index", "labelIdindex", "labelingnumber", "labelingIndex", "label_pos"], "l": ["jl", "ell", "al", "n", "pl", "lu", "g", "kl", "i", "sl", "nl", "ls", "lp", "loc", "sel", "dl", "lb", "o", "L", "ln", "lo", "fl", "le", "ol", "il", "e", "bl", "v", "lc", "rl", "ll", "p", "b", "la", "el", "li", "u"]}}
{"project": "qemu", "commit_id": "10ee2aaa417d8d8978cdb2bbed55ebb152df5f6b", "target": 0, "func": "static void ac97_map (PCIDevice *pci_dev, int region_num,\n\n                      uint32_t addr, uint32_t size, int type)\n\n{\n\n    PCIAC97LinkState *d = (PCIAC97LinkState *) pci_dev;\n\n    AC97LinkState *s = &d->ac97;\n\n\n\n    if (!region_num) {\n\n        s->base[0] = addr;\n\n        register_ioport_read (addr, 256 * 1, 1, nam_readb, d);\n\n        register_ioport_read (addr, 256 * 2, 2, nam_readw, d);\n\n        register_ioport_read (addr, 256 * 4, 4, nam_readl, d);\n\n        register_ioport_write (addr, 256 * 1, 1, nam_writeb, d);\n\n        register_ioport_write (addr, 256 * 2, 2, nam_writew, d);\n\n        register_ioport_write (addr, 256 * 4, 4, nam_writel, d);\n\n    }\n\n    else {\n\n        s->base[1] = addr;\n\n        register_ioport_read (addr, 64 * 1, 1, nabm_readb, d);\n\n        register_ioport_read (addr, 64 * 2, 2, nabm_readw, d);\n\n        register_ioport_read (addr, 64 * 4, 4, nabm_readl, d);\n\n        register_ioport_write (addr, 64 * 1, 1, nabm_writeb, d);\n\n        register_ioport_write (addr, 64 * 2, 2, nabm_writew, d);\n\n        register_ioport_write (addr, 64 * 4, 4, nabm_writel, d);\n\n    }\n\n}\n", "idx": 17266, "substitutes": {"pci_dev": ["pdi_dev", "pci_ev", "pcli_device", "pci_grad", "pcli_dev", "pcli_ev", "pdi_grad", "pdi_device", "pci_device"], "region_num": ["region__sym", " region_id", "region4name", "region_id", " region_sym", " region_name", "region4id", "region_number", "region__NUM", " region_NUM", "region__number", "region_NUM", "region_name", "region4NUM", "region_sym", "region__name", "region__num", "region__id", " region_number", "region4num"], "addr": ["grad", "offset", "Address", "x", "align", "ar", "region", "adder", "ptr", "pos", "layer", "config", "prefix", "id", "asm", "p", "pad", "od", "adr", "mt", "conn", "len", "work", "name", "rc", "bridge", "hop", "ld", "wd", "class", "route", "port", "mac", "amp", "dc", "code", "base", "r", "rt", "src", "loc", "node", "byte", "xp", "host", "l", "nr", "ad", "device", "address", "ace", "amd", "flags", "rr", "shape", "data", "mode", "ord", "coord", "channel", "g", "ost", "ast", "oa", "ext", "acl", "slice", "index", "en", "ip", "alias", "pkg", "nc", "add", "dr", "e", "map", "req", "seq", "kt", "cmd", "url", "cmp", "cap", "error", "nn", "server", "el", "attr", "butt"], "size": ["scale", "offset", "extra", "capacity", "small", "mode", "name", "g", "max", "loc", "sec", "pos", "enc", "args", "large", "ize", "length", "unit", "c", "address", "cap", "bytes", "Size", "len"], "type": ["types", "offset", "shape", "t", "info", "name", "ref", "buffer", "pe", "block", "val", "class", "format", "Type", "style", "length", "config", "unit", "TYPE", "p", "address", "ty", "weight", "state", "port", "ype", " typ", "typ"], "d": ["dc", "m", "dn", "dd", "db", "j", "t", "data", "gd", "x", "f", "dB", "md", "r", "pd", "de", "n", "dh", "dos", "g", "i", "z", "dt", "di", "ld", "dl", "done", "dj", "dim", "day", "sd", "o", "dp", "l", "did", "dy", "w", "bd", "dm", "ad", "e", "fd", "dr", "id", "k", "v", "c", "dom", "dis", "D", "ded", "p", "da", "b", "dat", "cd", "h", "dad", "diff", "dict", "y", "ds", "u"], "s": ["ns", "spec", "m", "session", "sg", "stats", "rs", "t", "f", "sv", "services", "r", "service", "n", "sb", "g", "i", "sl", "z", "ss", "this", "self", "is", "o", "l", "w", "e", "ssl", "ses", "v", "sync", "c", "js", "si", "p", "S", "b", "gs", "sys", "h", "os", "state", "server", "states", "sq", "sa", "ds", "u"]}}
{"project": "qemu", "commit_id": "ef1e1e0782e99c9dcf2b35e5310cdd8ca9211374", "target": 0, "func": "void vmstate_unregister(DeviceState *dev, const VMStateDescription *vmsd,\n\n                        void *opaque)\n\n{\n\n    SaveStateEntry *se, *new_se;\n\n\n\n    QTAILQ_FOREACH_SAFE(se, &savevm_state.handlers, entry, new_se) {\n\n        if (se->vmsd == vmsd && se->opaque == opaque) {\n\n            QTAILQ_REMOVE(&savevm_state.handlers, se, entry);\n\n            if (se->compat) {\n\n                g_free(se->compat);\n\n            }\n\n            g_free(se);\n\n        }\n\n    }\n\n}\n", "idx": 17267, "substitutes": {"dev": ["Dev", "dd", "mod", "ch", "tr", "gd", "conf", "pub", "reg", "debug", "de", "pack", "def", "der", "enc", "ev", "ad", "serv", "private", "device", "trans", "od", "proc", "pro", "gr", "ver"], "vmsd": ["vnsD", " vnsD", "vcsd", " vmsdt", " vmsdy", "lmsds", "vmesdt", "vmsds", "vMSdt", "vcsdn", "vMSdn", "vmesd", " vnsdt", "vMSdl", "vmesD", "vMSdy", "vmsdl", "vimsdl", " vnsd", "vmesdn", " vnsdd", "vmsD", "vmsdt", " vmsdl", "vMSdd", "vMSd", "vimsdy", "vmesdx", "vmesdd", "lmesd", "lmesdx", "vMSde", "vmsdy", "vmmde", "vnsdd", " vmsdd", "lmsdx", "vcsds", "vmsdx", " vimsde", "vmsdd", "vcsdx", "lmesds", "vnsd", " vimsdl", " vimsd", "vmmdl", "vMSdx", "lmsdn", "vmsde", "vMSD", "vMSds", " vimsdy", "vmmd", "vimsd", "vmsdn", "vmesds", " vmsde", "vnsdt", "lmesdn", " vmsD", "vmmdy", "vimsde", "lmsd"], "opaque": ["ompula", "copacity", "oppity", "operacity", "opity", "oppac", "copaque", " opacity", "compaque", "oppacity", "opac", "efficit", "opacity", "copula", " opac", "oppaque", "effaque", "operaque", "operity", "effaques", "operula", "effacity", "opula", " opity", "compaques", "compicit", "opicit", "operac", "opaques", "ompac", "operaques", "ompaque", "opericit", "copac", "ompacity", "compacity"], "se": ["entry", "per", "session", "s", "ede", "so", "sp", "ste", "ne", "pe", "de", "see", "sl", "SE", "ge", "isse", "as", "ie", "sel", "sem", "lex", "sea", "te", "sec", "sd", "ae", "ze", "sk", "su", "parse", "ce", "le", "seed", "sed", "use", "pse", "cel", "e", "ses", "Se", "sle", "be", "si", "ade", "cle", "sche", "ke", "ace", "es", "ser", "ase", "ve", "sa"], "new_se": ["new_parse", "new_entry", "newfparse", "new_sem", " new_sem", "newfentry", " new_parse", "newfSE", " new_entry", "newfse", "new_SE", " new_SE"]}}
{"project": "qemu", "commit_id": "47d3df2387ed6927732584ffa4159c26d9f4dee8", "target": 0, "func": "static int xenfb_send_motion(struct XenInput *xenfb,\n\n\t\t\t     int rel_x, int rel_y, int rel_z)\n\n{\n\n    union xenkbd_in_event event;\n\n\n\n    memset(&event, 0, XENKBD_IN_EVENT_SIZE);\n\n    event.type = XENKBD_TYPE_MOTION;\n\n    event.motion.rel_x = rel_x;\n\n    event.motion.rel_y = rel_y;\n\n#if __XEN_LATEST_INTERFACE_VERSION__ >= 0x00030207\n\n    event.motion.rel_z = rel_z;\n\n#endif\n\n\n\n    return xenfb_kbd_event(xenfb, &event);\n\n}\n", "idx": 17274, "substitutes": {"xenfb": ["xenef", " xeenfe", "xennbf", "xennfb", "exeenf", "xeenfe", "xennfe", "exenbridge", " xeenbf", "xeenf", "xeenfab", "exenf", "xenerfab", " xenfe", "xennfab", " xenbf", "exeenfb", " xeenfab", "exenfb", "xenerfe", "xenbridge", "xeenbridge", " xenfab", "exeenbridge", "xenbf", "xennf", "xenefb", "exenfe", "xenfab", "xenfe", "xenefe", " xeenfb", "xenerbf", "xenf", "xeenbf", "xenebridge", "xenerfb", "exeenfe", "xeenfb", "xennbridge"], "rel_x": ["rel_color", "rel_xy", " rel_lat", " rel_min", "relPx", "relqmin", " rel_xy", "relPlat", "rel_lat", "relPy", " rel_color", "relPz", "relqx", "relSpoint", " rel_point", "relSx", "rel_min", "relqcolor", "relSy", "rel_point", "relSxy", "relqy"], "rel_y": ["ref_x", " rel_r", "relvely", "relvelz", " rel_yo", "ref_y", "rel2Y", "rel2y", "rel_yo", "relvelx", "rel2x", "ref_Y", "rel_Y", "ref_z", "rel2z", "rel_r", "relvelr"], "rel_z": ["rel_tz", "rel_zone", "rel64zone", "rel64z", "rel_style", " rel_style", "rel64tz", "relFy", "relNzen", "rel64y", " rel_tz", " rel_zen", "relNwindow", "relFwindow", "relFzen", "relNy", " rel_window", "rel_zen", "relNz", " rel_zone", "relFz", "rel_window"], "event": ["move", "instance", "session", "content", "global", "shape", "request", "data", "ent", "view", "name", "image", "element", "comment", "text", "press", "script", "result", "window", "show", "document", "type", "method", "node", "package", "function", "this", "effect", "date", "game", "ee", "object", "Event", "container", "other", "context", "empty", "class", "ce", "new", "bug", "style", " Event", "advert", "ev", "config", "wave", "e", " events", "send", "record", "update", "parent", "test", "address", "xml", "vent", "feature", "events", "resource", "condition", "error", "ec", "character", "message", "end", "connection", "command", "source", " EVENT", "input"]}}
{"project": "FFmpeg", "commit_id": "435535e41159fbe7423a12078d684329a554776d", "target": 1, "func": "static int read_header(AVFormatContext *s,\n\n                       AVFormatParameters *ap)\n\n{\n\n    JVDemuxContext *jv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *vst, *ast;\n\n    int64_t audio_pts = 0;\n\n    int64_t offset;\n\n    int i;\n\n\n\n    avio_skip(pb, 80);\n\n\n\n    ast = av_new_stream(s, 0);\n\n    vst = av_new_stream(s, 1);\n\n    if (!ast || !vst)\n\n        return AVERROR(ENOMEM);\n\n\n\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n\n    vst->codec->codec_id    = CODEC_ID_JV;\n\n    vst->codec->codec_tag   = 0; /* no fourcc */\n\n    vst->codec->width       = avio_rl16(pb);\n\n    vst->codec->height      = avio_rl16(pb);\n\n    vst->nb_frames          =\n\n    ast->nb_index_entries   = avio_rl16(pb);\n\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n\n\n\n    avio_skip(pb, 4);\n\n\n\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}", "idx": 17280, "substitutes": {"s": ["ns", "ans", "spec", "sup", "ts", "sg", "t", "aws", "f", "services", "sp", "service", "sb", "g", "sl", "ss", "ls", "in", "sim", "fs", "cs", "sports", "su", "aps", "bis", "serv", "sc", "ssl", "ses", "v", "c", "js", "si", "ps", "p", "S", "sci", "b", "gs", "sys", "its", "a", "os", "us", "se", "south", "sq", "asts", "an", "sa", "ds", "sf"], "ap": ["wp", "ab", "au", "al", "op", "sp", "pl", "ar", "ams", "cp", "am", "np", "pac", "att", "aps", "pp", "AP", "ac", "pi", "ax", "pa", "mp", "cap", "api", "tp", "arp", "amp"], "jv": [" jvc", " jvt", "kjvs", "kjvc", "jf", "jj", "jaf", "jaj", "zv", "ojf", "ojv", "jvr", "zvs", "javs", "ojvs", " jvr", "arkV", " jf", "arkvr", " jj", "yvr", "jvs", "kjv", " jV", "arkvt", "ojvc", "kjf", "jav", "yvt", "yv", "jV", "jvt", "jvc", "zj", "zf", " jvs", "yV", "arkv"], "pb": ["ab", "ob", "ref", "bm", "pl", "phrase", "bp", "hub", "lp", "xb", "gb", "asm", "afi", "p", "mp", "orp", "prot", "cv", "typ", "pc", "verb", "plugin", "eb", "txt", "platform", "vp", "cp", "bc", "bb", "PB", "pg", "rob", "summary", "bf", "mb", "pa", "param", "ib", "amp", "wp", "fp", "pd", "sb", "cpp", "bsp", "wb", "dp", "bps", "fb", "b", "ppa", "np", "ub", "params", "db", "aph", "pm", "fc", "lb", "ba", "prop", "gp", "pp", "pkg", "bot", "bh", "rb", "api", "tp"], "vst": ["svst", "gstd", "vsts", " vsth", "vsth", "evust", "hsts", "hld", "hest", "uust", "Vst", "evld", "avst", " vust", "avsth", "avse", "gst", "evest", "ovST", "evst", "wst", "evste", "svsp", " vest", "ovcc", "vste", "avsp", "wsts", "svsts", "wsl", " vinst", "avstd", "ovst", "VST", "evstr", "avST", "gse", "avste", "vsp", "wste", " vsp", "usts", "svste", "vST", "evsts", "Vrest", "hst", "wsp", "vist", "wstr", "vinst", "ovrest", "vise", "vstd", " vste", "vists", "svST", "Vcc", "ust", "vld", "gsts", "vust", "gST", " vsl", "hsth", "vistd", "vsl", "winst", "evsp", "hST", "avsts", "svsl", "gste", "svstr", " vcc", "hste", " vstr", "hsp", "vest", "svinst", " vST", " vsts", " vrest", "vrest", "vcc", "ustr", "vse", "vstr", " vld"], "ast": ["ist", "ab", "stat", "ref", "op", "nt", "ann", "ar", "ams", "master", "ST", "adapt", "exec", "att", "ta", "sh", "asm", "ant", "ka", "test", "od", "mt", "end", "sa", "est", "tt", "rest", "aste", "ape", "hop", "am", "ld", "art", "tta", "sth", "mast", "a", "ft", "apache", "an", "amp", "ans", "at", "na", "esp", "ct", "ess", "asted", "node", "as", "act", "sta", "host", "std", "Ast", "ad", "post", "rss", "ust", "aw", "ace", "inst", "amd", "ma", "esi", "t", "af", "all", "aid", "ost", "AST", "asp", "parser", "old", "aster", "ac", "st", "il", "best", "asting", "api", "ard", "cast", "blast", "el", "asts"], "offset": ["entry", "part", "skip", "data", "info", "Offset", "base", "image", "annot", "align", "abyte", "padding", "slice", "pos", "index", "timeout", "ptr", "pointer", "o", "ip", "range", "location", "slot", "alias", "format", "length", "rot", "start", "parent", "position", "seq", "off", "shift", "pad", "area", "address", "url", "error", "origin", "bytes", "alpha", "order", "len"], "i": ["ti", "at", "j", "t", "x", "f", "ix", "r", "ai", "n", "num", "z", "ii", "in", "iu", "index", "ind", "I", "is", "ip", "l", "d", "pi", "ui", "ci", "id", "start", "k", "span", "c", "ni", "si", "p", "b", "a", "end", "it", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "4fb3efd2c17c419cb7a170e5438b35453ceaaf30", "target": 0, "func": "static int mov_write_colr_tag(AVIOContext *pb, MOVTrack *track)\n\n{\n\n    // Ref (MOV): https://developer.apple.com/library/mac/technotes/tn2162/_index.html#//apple_ref/doc/uid/DTS40013070-CH1-TNTAG9\n\n    // Ref (MP4): ISO/IEC 14496-12:2012\n\n\n\n    if (track->enc->color_primaries == AVCOL_PRI_UNSPECIFIED &&\n\n        track->enc->color_trc == AVCOL_TRC_UNSPECIFIED &&\n\n        track->enc->colorspace == AVCOL_SPC_UNSPECIFIED) {\n\n        if ((track->enc->width >= 1920 && track->enc->height >= 1080)\n\n          || (track->enc->width == 1280 && track->enc->height == 720)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt709\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT709;\n\n        } else if (track->enc->width == 720 && track->height == 576) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming bt470bg\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_BT470BG;\n\n        } else if (track->enc->width == 720 &&\n\n                   (track->height == 486 || track->height == 480)) {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, assuming smpte170\\n\");\n\n            track->enc->color_primaries = AVCOL_PRI_SMPTE170M;\n\n        } else {\n\n            av_log(NULL, AV_LOG_WARNING, \"color primaries unspecified, unable to assume anything\\n\");\n\n        }\n\n        switch (track->enc->color_primaries) {\n\n        case AVCOL_PRI_BT709:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_BT709;\n\n            break;\n\n        case AVCOL_PRI_SMPTE170M:\n\n        case AVCOL_PRI_BT470BG:\n\n            track->enc->color_trc = AVCOL_TRC_BT709;\n\n            track->enc->colorspace = AVCOL_SPC_SMPTE170M;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* We should only ever be called by MOV or MP4. */\n\n    av_assert0(track->mode == MODE_MOV || track->mode == MODE_MP4);\n\n\n\n    avio_wb32(pb, 18 + (track->mode == MODE_MP4));\n\n    ffio_wfourcc(pb, \"colr\");\n\n    if (track->mode == MODE_MP4)\n\n        ffio_wfourcc(pb, \"nclx\");\n\n    else\n\n        ffio_wfourcc(pb, \"nclc\");\n\n    switch (track->enc->color_primaries) {\n\n    case AVCOL_PRI_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_PRI_SMPTE170M:\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_BT470BG:   avio_wb16(pb, 5); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->color_trc) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_TRC_SMPTE170M: avio_wb16(pb, 1); break; // remapped\n\n    case AVCOL_TRC_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n    switch (track->enc->colorspace) {\n\n    case AVCOL_TRC_BT709:     avio_wb16(pb, 1); break;\n\n    case AVCOL_SPC_BT470BG:\n\n    case AVCOL_PRI_SMPTE170M: avio_wb16(pb, 6); break;\n\n    case AVCOL_PRI_SMPTE240M: avio_wb16(pb, 7); break;\n\n    default:                  avio_wb16(pb, 2);\n\n    }\n\n\n\n    if (track->mode == MODE_MP4) {\n\n        int full_range = track->enc->color_range == AVCOL_RANGE_JPEG;\n\n        avio_w8(pb, full_range << 7);\n\n        return 19;\n\n    } else {\n\n        return 18;\n\n    }\n\n}\n", "idx": 17288, "substitutes": {"pb": ["pc", "wp", "plugin", "eb", "txt", "db", "fp", "jp", "platform", "vp", "pit", "pd", "pl", "bm", "pm", "sb", "bp", "cpp", "cb", "bc", "cp", "hub", "lp", "fc", "xb", "lb", "PB", "dp", "pg", "pp", "pkg", "bps", "bf", "dm", "pa", "sth", "fb", "bh", "rb", "tmp", "hp", "p", "b", "ppa", "api", "tp", "uf", "pt", "lab"], "track": ["skip", "user", "comment", "trip", "thread", "gg", "report", "toggle", "rack", "package", "trial", "run", "rec", "layer", "path", "config", "test", "tt", "work", "metadata", "token", "sort", "hop", "gro", "stream", "tab", "sound", "audio", "stage", "table", "route", "field", "tracks", "tax", "row", "port", "order", "tm", "round", "view", "call", "song", "component", "r", "current", "coll", "type", "match", "node", "model", "ack", "gap", "grade", "ride", "sync", "post", "ogg", "transform", "Track", "project", "tracking", "progress", "rank", "rr", "session", "rock", "record", "tr", "request", "mode", "note", "trace", "module", "tag", "step", "event", "rule", "roll", "add", "cur", "driver", "cache", "form"]}}
{"project": "qemu", "commit_id": "eaf136f9a21e02a2f55346e44d2d88df37b2cde3", "target": 0, "func": "static int slirp_socket_load(QEMUFile *f, struct socket *so)\n\n{\n\n    if (tcp_attach(so) < 0)\n\n        return -ENOMEM;\n\n\n\n    so->so_urgc = qemu_get_be32(f);\n\n    so->so_ffamily = qemu_get_be16(f);\n\n    switch (so->so_ffamily) {\n\n    case AF_INET:\n\n        so->so_faddr.s_addr = qemu_get_be32(f);\n\n        so->so_fport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_faddr and so_lport\\n\");\n\n    }\n\n    so->so_lfamily = qemu_get_be16(f);\n\n    switch (so->so_lfamily) {\n\n    case AF_INET:\n\n        so->so_laddr.s_addr = qemu_get_be32(f);\n\n        so->so_lport = qemu_get_be16(f);\n\n        break;\n\n    default:\n\n        error_report(\n\n                \"so_ffamily unknown, unable to restore so_laddr and so_lport\\n\");\n\n    }\n\n    so->so_iptos = qemu_get_byte(f);\n\n    so->so_emu = qemu_get_byte(f);\n\n    so->so_type = qemu_get_byte(f);\n\n    so->so_state = qemu_get_be32(f);\n\n    if (slirp_sbuf_load(f, &so->so_rcv) < 0)\n\n        return -ENOMEM;\n\n    if (slirp_sbuf_load(f, &so->so_snd) < 0)\n\n        return -ENOMEM;\n\n    slirp_tcp_load(f, so->so_tcpcb);\n\n\n\n    return 0;\n\n}\n", "idx": 17301, "substitutes": {"f": ["m", "fr", "xf", "fw", "s", "t", "fp", "conf", "info", "af", "of", "fe", "file", "fun", "elf", "fa", "feed", "cf", "g", "i", "uf", "fac", "fc", "fs", "rf", "def", "fen", "fed", "o", "lf", "fo", "l", "fx", "d", "flat", "df", "inf", "bf", "w", "fore", "fd", "e", "handler", "fb", "sf", "v", "c", "F", "p", "b", "fm", "tf", "fn", "form", "h", "fi", "u"], "so": ["obj", "plus", "cf", "li", "po", "cs", "lo", "iso", "sh", "to", " co", "no", "since", "cu", "cli", "p", "ku", "ke", "oo", "So", "sa", "pc", "coe", "ne", "from", "osi", "ge", "za", "ld", "oso", "o", "sk", "pg", "su", "inf", "ko", "style", "sc", "ao", "si", "ki", "flo", "how", "la", "co", "an", "ds", "oh", "fe", "sb", "or", "ou", "te", "this", "di", "sm", "fo", "l", "le", "go", "sync", "vo", "b", "py", "one", "shi", "s", "ch", "info", "sp", "pe", " si", "sw", "sl", "oa", "ski", "fs", "bo", "ce", "ui", "SO", "ssl", "client", "oe", "isi", "os", "se", "mo", "kee"]}}
{"project": "qemu", "commit_id": "22f2e344748370b2e13888ba1057ebea2579970c", "target": 0, "func": "static int qdev_print_devinfo(DeviceInfo *info, char *dest, int len)\n\n{\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos, \"name \\\"%s\\\", bus %s\",\n\n                    info->name, info->bus_info->name);\n\n    if (info->alias)\n\n        pos += snprintf(dest+pos, len-pos, \", alias \\\"%s\\\"\", info->alias);\n\n    if (info->desc)\n\n        pos += snprintf(dest+pos, len-pos, \", desc \\\"%s\\\"\", info->desc);\n\n    if (info->no_user)\n\n        pos += snprintf(dest+pos, len-pos, \", no-user\");\n\n    return pos;\n\n}\n", "idx": 17307, "substitutes": {"info": ["Info", "thin", "init", "extra", "work", "fw", "data", "conf", "name", "f", "obj", "full", "op", "of", "plus", "service", "from", "cf", "show", "i", "hi", "type", "INFO", "app", "ii", "kind", "ie", "ext", "def", "is", "ip", "fo", "parse", "inf", "event", "args", "ui", "aux", "config", "id", "start", "prev", "handler", "open", "update", "si", "qa", "off", "http", "next", "check", "error", "tf", "api", "end", "py", "die", "diff", "hand", "inner", "source", "now"], "dest": ["dc", "grad", "sup", "txt", "data", "text", "rest", "dir", "options", "lit", "fun", "coord", "de", "result", "pack", "usr", "src", "loc", "wb", "done", "zip", "wd", "home", "prop", "flat", "cont", "path", "feat", "ident", "style", "sub", "buff", "buf", "cli", "temp", "target", "tmp", "lib", "del", "shift", "dat", "output", "gen", "route", "wh", "opt", "Dest", "priv", "proc", "end", "desc", "die", "source", "dist"], "len": ["spec", "part", "offset", "ell", "data", "user", "un", "err", "full", "alt", "sp", "lit", "nt", "ann", "n", "fun", "pl", "rel", "str", "num", "mun", "ls", "loc", "Pos", "fin", "pos", "ind", "min", "en", "count", "resp", "lt", "enc", "lf", "ln", "l", "non", "val", "layer", "size", "fail", "length", "il", "limit", "blank", "span", "seq", "ll", "line", "url", "Len", "gen", "la", "fn", "field", "lin", "list", "el", " length"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static int get_last_needed_nal(H264Context *h, const uint8_t *buf, int buf_size)\n\n{\n\n    int next_avc    = h->is_avc ? 0 : buf_size;\n\n    int nal_index   = 0;\n\n    int buf_index   = 0;\n\n    int nals_needed = 0;\n\n\n\n    while(1) {\n\n        int nalsize = 0;\n\n        int dst_length, bit_length, consumed;\n\n        const uint8_t *ptr;\n\n\n\n        if (buf_index >= next_avc) {\n\n            nalsize = get_avc_nalsize(h, buf, buf_size, &buf_index);\n\n            if (nalsize < 0)\n\n                break;\n\n            next_avc = buf_index + nalsize;\n\n        } else {\n\n            buf_index = find_start_code(buf, buf_size, buf_index, next_avc);\n\n            if (buf_index >= buf_size)\n\n                break;\n\n        }\n\n\n\n        ptr = ff_h264_decode_nal(h, buf + buf_index, &dst_length, &consumed,\n\n                                 next_avc - buf_index);\n\n\n\n        if (ptr == NULL || dst_length < 0)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        buf_index += consumed;\n\n\n\n        bit_length = get_bit_length(h, buf, ptr, dst_length,\n\n                                    buf_index, next_avc);\n\n        nal_index++;\n\n\n\n        /* packets can sometimes contain multiple PPS/SPS,\n\n         * e.g. two PAFF field pictures in one packet, or a demuxer\n\n         * which splits NALs strangely if so, when frame threading we\n\n         * can't start the next thread until we've read all of them */\n\n        switch (h->nal_unit_type) {\n\n        case NAL_SPS:\n\n        case NAL_PPS:\n\n            nals_needed = nal_index;\n\n            break;\n\n        case NAL_DPA:\n\n        case NAL_IDR_SLICE:\n\n        case NAL_SLICE:\n\n            init_get_bits(&h->gb, ptr, bit_length);\n\n            if (!get_ue_golomb(&h->gb))\n\n                nals_needed = nal_index;\n\n        }\n\n    }\n\n\n\n    return nals_needed;\n\n}\n", "idx": 17308, "substitutes": {"h": ["m", "ch", "t", "eh", "f", "oh", "hr", "hz", "gh", "g", "hi", "z", "rh", "ctx", "uh", "help", "self", "o", "home", "host", "context", "l", "hw", "d", "header", "ht", "him", "sh", "hu", "img", "hl", "q", "e", "buff", "bh", "ih", "v", "c", "hp", "p", "hm", "b", "http", "hh", "ph", "ha", "hs", "he", "enh", "hand", "ah", "H", "u"], "buf": ["Buffer", "br", "grab", "ff", "data", "fp", "f", "buffer", "usb", "vec", "rc", "cf", "cb", "bc", "src", "Buff", "loc", "wb", "ctx", "pb", "abb", "cas", "auc", "home", "prop", "gb", "box", "img", "queue", "fd", "buff", "fb", "v", "comb", "cur", "rb", "seq", "cmd", "uc", "tmp", "que", "b", "la", "alloc", "proc", "bag", "uf", "cv"], "buf_size": ["uf_design", "buf_speed", "bufjdepth", " buf_length", "uf_depth", "buf_scale", "uf_index", "uf_scale", "buf6design", "bufjsize", "bufjscale", "buf_length", "bufallweight", "bufallspeed", "bufallsize", " buf_scale", "buf6size", "buf_index", " buf_index", "buf_depth", "bufallindex", "buf_weight", "uf_speed", "buf6scale", "buf_ize", "uf_weight", "uf_size", "buf_design", "uf_ize", "bufjindex"], "dst_length": ["dst_size", "dest_width", "dest_length", "dstxbreak", "dst_ength", "dst_path", "dfront_shape", "dst_len", "dfront_len", "dsts_shape", "dsts_ength", "dsts_length", "dsts_width", "dest_size", "dst__length", "dst_width", "dsts_path", "dst_break", "dstxsize", "dest_break", "dst__path", "dstfwidth", "dstfshape", "dstflength", "dst__ength", "dstxlength", "dst_shape", "dstxwidth", "dfront_length"], "bit_length": [" bit_duration", "bit_limit", " bit_class", "bit_count", "bitnduration", "bit___len", " bit_count", "bit_number", "bitnlimit", " bit_limit", " bit_type", "bitlenlength", "bit___length", " bit_len", "bitlenduration", "bit_class", "bit_Length", "bitlenlimit", "bit___type", "bitnlength", "bit_type", "bit_duration", " bit_Length", " bit_number", "bit_len", "bit___number"], "consumed": ["consided", "Consored", "assided", " unconsumes", "Conserved", "completed", "asserved", "continided", " unconsided", "continerved", "cosided", "continumed", "continumption", " unconsumption", "assumed", "cosumption", "resumed", "consumes", "compumed", "resided", "assumption", "conserved", "consored", "conspleted", "consumption", " unconsumed", "reserved", "cosumes", "comppleted", "resumption", "comumed", "assumes", "comored", "cosumed", "Conspleted", "Consumed", "compored", "comerved", "comperved"], "ptr": ["pt", "offset", "br", "ff", "code", "tr", "ped", "fp", "push", "dep", "ref", "td", "buffer", "rc", "late", "cb", "loc", "src", "ctx", "pb", "pos", "ind", "slice", "pointer", "lf", "prop", "pair", "prim", "pend", "length", "pull", "fd", "start", "buff", "cur", "temp", "post", "tmp", "p", "shift", "address", "pad", "plug", "cache", "cmp", "pr", "alloc", "proc", "inst", "addr", "Ptr", "rect", "port", "prot", "fi", "attr", "cv", "butt"], "nal_index": ["natal_size", "nal_size", "naval_length", "nabal67needed", "nal67length", "nali_index", "nabal_length", "nal___index", "nali_offset", "nali_path", "natal_needed", "nal_path", "natal_index", "nal___size", "naval_available", "natal_di", "nal_di", "naval_index", "nal67needed", "nal___di", "nal_offset", "nabal67location", "nalklength", "nal_length", "nabal_needed", "nalkposition", "nabal_index", "nal67location", "nabal67length", "nabal67index", "nal67index", "nalkavailable", "nal_location", "nal___needed", "nal_position", "nal_available", "nabal_location", "nal_needed", "naval_position", "nalkindex"]}}
{"project": "qemu", "commit_id": "e514fc7e1231c6d95011e448e6c626f2bb6f3cd8", "target": 0, "func": "e1000e_write_packet_to_guest(E1000ECore *core, struct NetRxPkt *pkt,\n\n                             const E1000E_RxRing *rxr,\n\n                             const E1000E_RSSInfo *rss_info)\n\n{\n\n    PCIDevice *d = core->owner;\n\n    dma_addr_t base;\n\n    uint8_t desc[E1000_MAX_RX_DESC_LEN];\n\n    size_t desc_size;\n\n    size_t desc_offset = 0;\n\n    size_t iov_ofs = 0;\n\n\n\n    struct iovec *iov = net_rx_pkt_get_iovec(pkt);\n\n    size_t size = net_rx_pkt_get_total_len(pkt);\n\n    size_t total_size = size + e1000x_fcs_len(core->mac);\n\n    const E1000E_RingInfo *rxi;\n\n    size_t ps_hdr_len = 0;\n\n    bool do_ps = e1000e_do_ps(core, pkt, &ps_hdr_len);\n\n\n\n    rxi = rxr->i;\n\n\n\n    do {\n\n        hwaddr ba[MAX_PS_BUFFERS];\n\n        e1000e_ba_state bastate = { { 0 } };\n\n        bool is_last = false;\n\n        bool is_first = true;\n\n\n\n        desc_size = total_size - desc_offset;\n\n\n\n        if (desc_size > core->rx_desc_buf_size) {\n\n            desc_size = core->rx_desc_buf_size;\n\n        }\n\n\n\n        base = e1000e_ring_head_descr(core, rxi);\n\n\n\n        pci_dma_read(d, base, &desc, core->rx_desc_len);\n\n\n\n        trace_e1000e_rx_descr(rxi->idx, base, core->rx_desc_len);\n\n\n\n        e1000e_read_rx_descr(core, desc, &ba);\n\n\n\n        if (ba[0]) {\n\n            if (desc_offset < size) {\n\n                static const uint32_t fcs_pad;\n\n                size_t iov_copy;\n\n                size_t copy_size = size - desc_offset;\n\n                if (copy_size > core->rx_desc_buf_size) {\n\n                    copy_size = core->rx_desc_buf_size;\n\n                }\n\n\n\n                /* For PS mode copy the packet header first */\n\n                if (do_ps) {\n\n                    if (is_first) {\n\n                        size_t ps_hdr_copied = 0;\n\n                        do {\n\n                            iov_copy = MIN(ps_hdr_len - ps_hdr_copied,\n\n                                           iov->iov_len - iov_ofs);\n\n\n\n                            e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                      iov->iov_base, iov_copy);\n\n\n\n                            copy_size -= iov_copy;\n\n                            ps_hdr_copied += iov_copy;\n\n\n\n                            iov_ofs += iov_copy;\n\n                            if (iov_ofs == iov->iov_len) {\n\n                                iov++;\n\n                                iov_ofs = 0;\n\n                            }\n\n                        } while (ps_hdr_copied < ps_hdr_len);\n\n\n\n                        is_first = false;\n\n                    } else {\n\n                        /* Leave buffer 0 of each descriptor except first */\n\n                        /* empty as per spec 7.1.5.1                      */\n\n                        e1000e_write_hdr_to_rx_buffers(core, &ba, &bastate,\n\n                                                       NULL, 0);\n\n                    }\n\n                }\n\n\n\n                /* Copy packet payload */\n\n                while (copy_size) {\n\n                    iov_copy = MIN(copy_size, iov->iov_len - iov_ofs);\n\n\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                                            iov->iov_base + iov_ofs, iov_copy);\n\n\n\n                    copy_size -= iov_copy;\n\n                    iov_ofs += iov_copy;\n\n                    if (iov_ofs == iov->iov_len) {\n\n                        iov++;\n\n                        iov_ofs = 0;\n\n                    }\n\n                }\n\n\n\n                if (desc_offset + desc_size >= total_size) {\n\n                    /* Simulate FCS checksum presence in the last descriptor */\n\n                    e1000e_write_to_rx_buffers(core, &ba, &bastate,\n\n                          (const char *) &fcs_pad, e1000x_fcs_len(core->mac));\n\n                }\n\n            }\n\n            desc_offset += desc_size;\n\n            if (desc_offset >= total_size) {\n\n                is_last = true;\n\n            }\n\n        } else { /* as per intel docs; skip descriptors with null buf addr */\n\n            trace_e1000e_rx_null_descriptor();\n\n        }\n\n\n\n        e1000e_write_rx_descr(core, desc, is_last ? core->rx_pkt : NULL,\n\n                           rss_info, do_ps ? ps_hdr_len : 0, &bastate.written);\n\n        pci_dma_write(d, base, &desc, core->rx_desc_len);\n\n\n\n        e1000e_ring_advance(core, rxi,\n\n                            core->rx_desc_len / E1000_MIN_RX_DESC_LEN);\n\n\n\n    } while (desc_offset < total_size);\n\n\n\n    e1000e_update_rx_stats(core, size, total_size);\n\n}\n", "idx": 17314, "substitutes": {"d": ["dc", "board", "dn", "dd", "db", "s", "t", "data", "core", "gd", "f", "component", "pd", "cm", "dh", "dos", "g", "ide", "dl", "ind", "ci", "w", "bd", "dm", "ad", "e", "id", "client", "sync", "c", "dom", "D", "da", "p", "ded", "b", "dat", "cd", "dad", "conn", "ds"], "base": ["dc", "na", "bi", "bin", "scale", "extra", "db", "bat", "data", "info", "core", "name", "bit", "Base", "buffer", "hide", "full", "i", "root", "master", "type", "bc", "index", "byte", "def", "create", "bid", "ca", "home", "store", "bar", "size", "bf", "kit", "pre", "bu", "last", "prefix", "id", "pa", "bas", "buf", "bot", "ka", "unit", "c", "meta", "p", "da", "address", "area", "bre", "cache", "b", "la", "beta", "ase", "api", "ha", "end", "server", "se"], "desc": ["dc", "ros", "code", "info", "esc", "name", "ctr", "dir", " description", "dest", "rc", "anc", "bc", "src", "loc", "ext", "des", "sec", "def", "description", "ca", "design", "rec", "disc", "aux", "rib", "sub", "config", "sc", "buf", "comb", "req", "seq", "meta", "uc", "Desc", "doc", "dist", "beta", "decl", "asc"], "desc_size": ["description_size", "descetunit", "descaclen", "descacbody", "doc_len", "description_offset", "doc_size", "sub_unit", "doc_body", "descetscale", "desc_unit", "desc_offset", "description_loc", "doc_offset", "descetclean", "sub_clean", "descacsize", "sub_size", "desc_len", " desc_len", "desc_body", "desc_loc", "descetsize", "desc_clean", " desc_offset", "desc_num", "sub_scale", "description_len", "descacoffset", "desc_scale", " desc_num"], "iov": ["ei", "irc", "io", "dq", "ii", "iop", "ctx", "iu", "iol", "abc", "pai", "rob", "nr", "ahi", "uga", "igi", "ru", "ci", "vre", "gra", "mx", "rb", "odi", "ia", "uno", "fi", "ilo", "ib", "mu"], "rxi": ["prxa", "RXi", " rfi", "rgxi", "pfi", "prpi", "rci", "Rpi", "rbi", "Rxi", "pXi", "ppi", "prxi", "rfi", "pci", " rdi", " rXi", "rXi", "rpi", " rpi", "rgxa", " rri", "rgci", "rri", "prdi", " rci", "prri", "prbi", "rgpi", "Rri", "rdi", " rxa", "rxa", "Rci", " rbi", "rgfi", "pxi", "rgbi", "Rdi"], "ba": ["na", "aba", "ab", "bi", "au", "bs", " bo", " buf", "ai", "fa", "bc", "pb", "abc", " bc", "ae", " ac", "xa", "ca", "ta", "bu", "aa", "bd", "tta", "asa", "pa", "buf", "ga", "ka", " ab", "ea", "da", " ca", "ada", "area", "b", "va", "la", "wa", "a", "ha", "ja", "Ba", "BA", "sa", " b"], "fcs_pad": ["fcsbpad", "fcs_init", "fcs_count", "fcsbcount", "ffs_init", "ffs_pad", "fcs_pos", "fcsbpos", "ffs_count", "ffs_pos", "fcsbinit"], "iov_copy": ["iov__copy", "oren_shared", "iov__shared", "oren__shared", "oren__copy", "oren_size", "oren_copy", "iov__size", "iov__data", "oren__size", "oren__data", "iov_size", "oren_data", "iov_shared", "iov_data"]}}
{"project": "qemu", "commit_id": "026aeffcb4752054830ba203020ed6eb05bcaba8", "target": 0, "func": "static int cirrus_do_copy(CirrusVGAState *s, int dst, int src, int w, int h)\n\n{\n\n    int sx = 0, sy = 0;\n\n    int dx = 0, dy = 0;\n\n    int depth = 0;\n\n    int notify = 0;\n\n\n\n    /* make sure to only copy if it's a plain copy ROP */\n\n    if (*s->cirrus_rop == cirrus_bitblt_rop_fwd_src ||\n\n        *s->cirrus_rop == cirrus_bitblt_rop_bkwd_src) {\n\n\n\n        int width, height;\n\n\n\n        depth = s->vga.get_bpp(&s->vga) / 8;\n\n        if (!depth) {\n\n            return 0;\n\n        }\n\n        s->vga.get_resolution(&s->vga, &width, &height);\n\n\n\n        /* extra x, y */\n\n        sx = (src % ABS(s->cirrus_blt_srcpitch)) / depth;\n\n        sy = (src / ABS(s->cirrus_blt_srcpitch));\n\n        dx = (dst % ABS(s->cirrus_blt_dstpitch)) / depth;\n\n        dy = (dst / ABS(s->cirrus_blt_dstpitch));\n\n\n\n        /* normalize width */\n\n        w /= depth;\n\n\n\n        /* if we're doing a backward copy, we have to adjust\n\n           our x/y to be the upper left corner (instead of the lower\n\n           right corner) */\n\n        if (s->cirrus_blt_dstpitch < 0) {\n\n            sx -= (s->cirrus_blt_width / depth) - 1;\n\n            dx -= (s->cirrus_blt_width / depth) - 1;\n\n            sy -= s->cirrus_blt_height - 1;\n\n            dy -= s->cirrus_blt_height - 1;\n\n        }\n\n\n\n        /* are we in the visible portion of memory? */\n\n        if (sx >= 0 && sy >= 0 && dx >= 0 && dy >= 0 &&\n\n            (sx + w) <= width && (sy + h) <= height &&\n\n            (dx + w) <= width && (dy + h) <= height) {\n\n            notify = 1;\n\n        }\n\n    }\n\n\n\n    (*s->cirrus_rop) (s, s->vga.vram_ptr + s->cirrus_blt_dstaddr,\n\n                      s->vga.vram_ptr + s->cirrus_blt_srcaddr,\n\n\t\t      s->cirrus_blt_dstpitch, s->cirrus_blt_srcpitch,\n\n\t\t      s->cirrus_blt_width, s->cirrus_blt_height);\n\n\n\n    if (notify) {\n\n        dpy_gfx_update(s->vga.con, dx, dy,\n\n                       s->cirrus_blt_width / depth,\n\n                       s->cirrus_blt_height);\n\n    }\n\n\n\n    /* we don't have to notify the display that this portion has\n\n       changed since qemu_console_copy implies this */\n\n\n\n    cirrus_invalidate_region(s, s->cirrus_blt_dstaddr,\n\n\t\t\t\ts->cirrus_blt_dstpitch, s->cirrus_blt_width,\n\n\t\t\t\ts->cirrus_blt_height);\n\n\n\n    return 1;\n\n}\n", "idx": 17325, "substitutes": {"s": ["ns", "spec", "full", "service", "sie", "ss", "cs", "qs", "sym", "p", "ks", "us", "sets", "m", "ts", "sg", "sis", "rs", "self", "o", "su", "obs", "tests", "side", "v", "si", "S", "uses", "a", "hs", "an", "ds", "native", "status", "uns", "f", "r", "sb", "sports", "l", "bis", "sync", "private", "c", "ps", "secondary", "b", "sys", "your", "es", "state", "states", "sq", "less", "session", "stats", "t", "conf", "services", "n", "plugins", "g", "i", "ls", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "south", "se", "y", "u"], "dst": ["Dcr", "dsp", "Dst", "hsc", " dsp", "hsta", "Dsp", "hst", " dbl", "fst", "fsc", "dcr", "Dsc", "hbl", " dost", "adsta", "dsc", "Dsts", "host", "dsta", "Dost", "adst", "fcr", " dsc", " dsta", "fsp", "hsts", "adbl", "dost", " dsts", " dcr", "dsts", "dbl", "adsc"], "src": ["rx", "sup", "rs", "dest", "rc", "sb", "cb", "sl", "stream", "loc", "sel", "ctx", "low", "sta", "head", "gb", "hw", "rob", "sh", "sn", "img", "sub", "config", "sr", "sc", "st", "sth", "sync", "rb", "bg", "rss", "uc", "url", "sci", "depth", "b", "gz", "sid", "obl", "sys", "sq", "kk", "source", "dist"], "w": ["wt", "fw", "work", "wx", "x", "f", "wi", "r", "n", "hop", "wl", "we", "g", "window", "sw", "z", "max", "wb", "ow", "wd", "kw", "ew", "l", "d", "hw", "sh", "W", "ww", "flow", "q", "v", "p", "rw", "b", "win", "wh", "wa", "aw", "row", "weight", "u", "end", "H", "y", "wave"], "h": ["m", "x", "f", "oh", "r", "hr", "n", "hy", "hop", "g", "gh", "hi", "hd", "z", "rh", "th", "en", "o", "l", "d", "ht", "sh", "hl", "q", "v", "ih", "c", "p", "hm", "b", "depth", "hh", "ul", "ph", "ha", "hs", "ah", "H", "y", "u"], "height": ["rank", "thin", "shape", "time", "direction", "view", "volume", "image", "ows", "window", "gh", "quality", "hd", "max", "th", "padding", "resolution", "dim", "inches", " heights", "size", "hang", "style", "hor", "dy", "length", "chrom", "arrow", "deep", "device", "ths", "crop", "rows", "Height", "driver", "depth", "row", "ty", "weight", "grow", "distance", "density", "value", "y", "dist"]}}
{"project": "qemu", "commit_id": "8b3b720620a1137a1b794fc3ed64734236f94e06", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328, "substitutes": {"bs": ["ns", "org", "ros", "bi", "ab", "lbs", "base", "ob", "bridge", "ubs", "sb", "cb", "bc", "ss", "ls", "pb", "fs", "lb", "bb", "cs", "css", "als", "cms", "bos", "ins", "obs", "outs", "BS", "abi", "blocks", "bis", "iss", "bl", "bas", "ses", "vs", "fb", "bh", "js", "rb", "bits", "b", "bytes", "os", "bes", "us", "ds", "bing"], "l1_index": ["l21_start", "l4_offset", "l1_start", "l4_Index", "l4_position", "l21_width", "l1_Index", "l1swidth", "l1pposition", "l4_index", "l1pIndex", "l1nstart", "l1_width", "l1selement", "l21_element", "l1_element", "l1sstart", "l1_offset", "l1pindex", "l1sindex", "l1poffset", "l1nindex", "l1nwidth", "l21_index", "l1nelement", "l1_position"], "s": ["ns", "spec", "session", "stats", "rs", "uns", "f", "sv", "settings", "services", "service", "sie", "sl", "bc", "ls", "ss", "as", "fs", "is", "cs", "su", "ins", "args", "site", "iss", "bis", "qs", "e", "ssl", "ses", "sync", "c", "ps", "js", "si", "p", "S", "b", "gs", "sys", "os", "state", "server", "states", "ds"], "buf": ["Buffer", "ab", "br", "db", "ff", "grab", "data", "af", "base", "ref", "buffer", "rc", "vec", "fi", "stab", "result", "block", "cb", "bc", "Buff", "src", "wb", "ctx", "fab", "pb", "bb", "cas", "arr", "tab", "gb", "header", "array", "conv", "box", "aux", "img", "config", "queue", "bd", "fd", "buff", "bh", "fb", "map", "rb", "seq", "tmp", "uc", "cmd", "pad", "mp", "b", "append", "cap", "alloc", "bytes", "bag", "uf", "cv"], "l1_start_index": ["l1_data_index", "l1_end_ind", "l1_data_end", "l1_start_length", "l1_end_length", "l1_data_point", "l1_start_address", "l1_end_index", "l1_start_offset", "l1_end_part", "l1_start_ind", "l1_end_offset", "l1_start_position", "l1_start_part", "l1_end_position", "l1_end_address", "l1_start_point", "l1_start_end"], "i": ["gi", "ti", "uri", "bi", "m", "j", "ji", "t", "x", "f", "ini", "qi", "r", "ai", "io", "n", "hi", "ii", "in", "di", "index", "ind", "iu", "I", "en", "zi", "o", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "u", "h", "a", "end", "eni", "li", "len"], "ret": ["j", "db", "code", "fat", "f", "bit", "ref", "err", "alt", "reg", "r", "nt", "rc", "rt", "fun", "lit", "result", "num", "flag", "cb", "match", "ext", "mem", "resp", "rets", "arg", "att", "art", "bad", "val", "re", "Ret", "pre", "back", "xt", "id", "det", "rev", "rb", "RET", "b", "red", "res", "mt", "fi", "reply", "success", "len"]}}
{"project": "qemu", "commit_id": "2ce68e4cf5be9b5176a3c3c372948d6340724d2d", "target": 1, "func": "int vhost_dev_init(struct vhost_dev *hdev, void *opaque,\n                   VhostBackendType backend_type)\n{\n    uint64_t features;\n    int i, r;\n    if (vhost_set_backend_type(hdev, backend_type) < 0) {\n        close((uintptr_t)opaque);\n        return -1;\n    }\n    if (hdev->vhost_ops->vhost_backend_init(hdev, opaque) < 0) {\n        close((uintptr_t)opaque);\n        return -errno;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_SET_OWNER, NULL);\n    if (r < 0) {\n        goto fail;\n    }\n    r = hdev->vhost_ops->vhost_call(hdev, VHOST_GET_FEATURES, &features);\n    if (r < 0) {\n        goto fail;\n    }\n    for (i = 0; i < hdev->nvqs; ++i) {\n        r = vhost_virtqueue_init(hdev, hdev->vqs + i, hdev->vq_index + i);\n        if (r < 0) {\n            goto fail_vq;\n        }\n    }\n    hdev->features = features;\n    hdev->memory_listener = (MemoryListener) {\n        .begin = vhost_begin,\n        .commit = vhost_commit,\n        .region_add = vhost_region_add,\n        .region_del = vhost_region_del,\n        .region_nop = vhost_region_nop,\n        .log_start = vhost_log_start,\n        .log_stop = vhost_log_stop,\n        .log_sync = vhost_log_sync,\n        .log_global_start = vhost_log_global_start,\n        .log_global_stop = vhost_log_global_stop,\n        .eventfd_add = vhost_eventfd_add,\n        .eventfd_del = vhost_eventfd_del,\n        .priority = 10\n    };\n    hdev->migration_blocker = NULL;\n    if (!(hdev->features & (0x1ULL << VHOST_F_LOG_ALL))) {\n        error_setg(&hdev->migration_blocker,\n                   \"Migration disabled: vhost lacks VHOST_F_LOG_ALL feature.\");\n        migrate_add_blocker(hdev->migration_blocker);\n    }\n    hdev->mem = g_malloc0(offsetof(struct vhost_memory, regions));\n    hdev->n_mem_sections = 0;\n    hdev->mem_sections = NULL;\n    hdev->log = NULL;\n    hdev->log_size = 0;\n    hdev->log_enabled = false;\n    hdev->started = false;\n    hdev->memory_changed = false;\n    memory_listener_register(&hdev->memory_listener, &address_space_memory);\n    return 0;\nfail_vq:\n    while (--i >= 0) {\n        vhost_virtqueue_cleanup(hdev->vqs + i);\n    }\nfail:\n    r = -errno;\n    hdev->vhost_ops->vhost_backend_cleanup(hdev);\n    QLIST_REMOVE(hdev, entry);\n    return r;\n}", "idx": 17329, "substitutes": {"hdev": [" hhost", "fdev", "herhost", "hrdf", "hdd", "hlgu", "hmhost", "rhdiff", "vdi", " hconn", "ohdi", " happ", "shev", "hdc", "hddev", " hgu", "hrdd", " hdef", "vev", "hldef", "hdevice", " hpad", "hldevice", " hvalid", "cdc", " hdie", "kdevice", "adhrad", "rhvalid", " hev", "Hdevelopment", "rhapp", "hdata", "ehvar", "vdef", "fvar", "Hdiv", "fdevice", " hdc", "hdhost", "ohdevice", "hostdiff", "cdev", " hdata", "hengine", "shdc", "hdod", "hldev", "herdev", " hdriver", "happ", "bhdef", "hldevelopment", "rhpad", "hrad", "fdriver", "hgu", "ohvalid", "ohvar", "rhdev", " hvar", "hydi", " hdd", "hydev", "ohdev", "ohdef", "ehdev", "hvalid", "Hdi", "vdevice", "hrrad", "cdevice", "hod", "ohdata", "rhconn", "shdiff", "hdf", " hdevelopment", "rhdie", "ehdef", "rhhost", "shapp", "ohdevelopment", "adhdf", "Hev", "kdev", "hdi", "hyerror", "Hdevice", "hdevelopment", "hostdev", "hypad", "hvar", " hod", "ohhost", "hrdev", "hlhost", "hhost", "hdriver", "fhost", "hldiff", "shdev", "rhdi", "hrdiv", "hostdevelopment", " hrad", "bhdevice", "ehev", "rhdd", " herror", "hde", "hdiff", "hdiv", "herror", "rherror", "herconn", " hdi", "rhev", "Hvalid", "bhgu", "hdef", "vhost", "herdi", "hmengine", "Hdev", "kdriver", "shdi", "hdie", "hmod", " hdevice", "rhdata", "ohev", "adhde", "hrde", "shdevice", "fdc", " hdf", " hdiv", "hlvar", "bhdev", "hmdev", "hpad", "hostgu", "rhdevice", "adhdev", "vdev", " hdiff", "Hdef", "rhdiv", "bhvalid", "vvar", " hde", "bhdiv", "hdengine", "hrdie", "hconn", " hengine", "cdi", "hev", "kdc"], "opaque": [" openabled", "ipenabled", "operacity", "operaco", "Opaque", "opercode", "operivalent", "Opacity", " opacity", "Opivalent", "operacle", "Opacle", "OPaco", " opaco", "opac", "opacity", " opac", " opacle", "ipac", "operaque", " opcode", "ipcode", " opivalent", "operenabled", "opcode", "ipacity", "opaco", "OPaque", "ipaque", "OPacity", "operac", "opivalent", "OPacle", "openabled", "opacle"], "backend_type": ["backendalformat", "backendalclass", "backender_type", "backended_class", "backend_class", "backender_types", "backend_types", "backend_key", "backended_format", "backendaltype", "backendaltypes", "backender_name", "backended_types", "backender_key", "backend_name", "backend_format", "backended_type"], "features": ["strings", "pieces", "words", "fields", "options", "settings", "requires", "result", "details", "files", "resources", "Features", "feat", "config", "lib", "afi", "protection", "reports", "feature", "products", "bytes", "groups", "classes", "rs", "issues", "ips", "devices", "ints", "models", "nets", "ffff", "tests", "includes", "versions", "license", "facts", "eatures", "works", "ATURES", "modules", "results", "sections", "items", " interfaces", "ga", "events", "measures", "fn", "rules", "flags", "params", "bugs", "types", "fixes", "s", "stats", "effects", "services", "faces", "n", "plugins", "forms", "g", "tags", "ops", " f", "fc", "xs", "args", "bits", "properties", "os"], "i": ["ti", "gi", "uri", "m", "bi", "j", "t", "x", "err", "f", "ix", "ini", "qi", "ai", "mi", "n", "phi", "g", "type", "z", "ii", "ie", "iu", "index", "di", "I", "zi", "o", "ip", "l", "d", "yi", "pi", "ui", "ci", "id", "k", "e", "q", "v", "ni", "c", "si", "ri", "p", "xi", "b", "h", "er", "api", "it", "eni", "fi", "y", "li", "u"], "r": ["m", "rr", "fr", "br", "j", "t", "rs", "f", "err", "rc", "hr", "rt", "R", "result", "ar", "str", "g", "or", "nor", "rh", "function", "rg", "run", "rf", "kr", "o", "arr", "l", "d", "rd", "re", "rec", "nr", "mr", "rar", "ru", "sr", "e", "dr", "lr", "k", "cr", "v", "q", "c", "rb", "rl", "ir", "p", "ur", "b", "pr", "error", "h", "er", "u"]}}
{"project": "qemu", "commit_id": "71d0770c4cec9f1dc04f4dadcbf7fd6c335030a9", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337, "substitutes": {"bs": ["ns", "ab", "eb", "s", "lbs", "rs", "obj", "las", "ob", "base", "ubs", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "bid", "cs", "css", "als", "gb", "bos", "bps", "ins", "obs", "outs", "BS", "iss", "blocks", "bis", "abi", "bl", "vs", "fb", "ses", "bas", "js", "ps", "rb", "bits", "b", "ks", "gs", "es", "bytes", "os", "bes", "banks", "ds", "bing"], "sector_num": [" sector_number", "sectoringrange", "section_count", "sector_param", "sector_name", "sector_range", "sector_number", "section_num", " sector_param", "section_number", "sectoringnumber", "section_name", " sector_nom", " sector_name", "sectoringnom", "sector_count", "sectoringnum", " sector_range", "sector_nom"], "buf": ["ff", "data", "fp", "base", "buffer", "rc", "vec", "fi", "bridge", "num", "cf", "exc", "cb", "block", "bc", "src", "msg", "wb", "ctx", "fab", "pb", "bb", "lb", "cas", "bags", "prop", "bf", "queue", "blocks", "config", "fd", "buff", "batch", "fb", "rb", "seq", "cmd", "pad", "que", "b", "alloc", "port", "bag", "uf", "bus", "cv"], "nb_sectors": ["nb_nectors", "nb_vellers", "nb_sergments", "nb_SEctor", "nb_vekers", "nb_SEctors", "nb_SEctions", "nb_persegments", "nb_serctions", "nb_gekers", "nb_sellers", "nb_vector", "nb_spellers", "nb_nekers", "nb_gerets", "nb_SEgments", "nb_gegments", "nb_spectors", "nb_secctor", "nb_segments", "nb_persector", "nb_sector", "nb_verets", "nb_serets", "nb_spector", "nb_secgments", "nb_spegments", "nb_persellers", "nb_serctor", "nb_vegments", "nb_serctors", "nb_gectors", "nb_secctions", "nb_persectors", "nb_sections", "nb_secctors", "nb_negments", "nb_vectors", "nb_sekers", "nb_nerets"], "drv": ["srf", "hrb", "Druv", "DRver", "hrf", "yrf", " drp", "srvs", "rdvs", " drvs", "DRv", "drver", "drV", "frf", "truv", "drvs", "srv", "Drb", "rdv", "rdp", "yrvv", "driv", "hrp", " drver", "drb", " drb", "drif", "drvv", "rrf", "DRf", "frv", "srb", "rdb", "druv", "drf", "trv", "rrv", "hrv", "Drf", "trb", "drvr", "frvv", "rrp", " drvv", "driver", "drp", "trf", "yrvr", " drf", " druv", "frvr", "yrv", "rdf", "Drv", "driV", "rrb", " drV", "DRV", " drvr"], "ret": ["code", "data", "f", "base", "ref", "alt", "err", "net", "bit", "lit", "nt", "rc", "rt", "fun", "result", "num", "fin", "run", "def", "en", "rets", "lt", "count", "out", "art", "lf", "l", "val", "re", "Ret", "fail", "id", "fit", "length", "rev", "cur", "req", "elt", "seq", " Ret", "repl", "RET", "error", "pet", "res", "el", "reply", "conn", "Len"], "len": ["lon", "part", "fat", "f", "ref", "lif", "alt", "err", "base", "lit", "nt", "ann", "rt", "fun", "n", "rel", "sl", "ls", "ie", "led", "fin", "pos", "ld", "min", "en", "lt", "count", "lf", "ln", "l", "val", "le", "sil", "length", "ler", "il", "rev", "elt", "lc", "seq", "repl", "lan", "split", "lin", "el", "li", "Len"], "rd_ops": ["rd_bits", "dr_proc", "dr_bytes", "rd_proc", "rd_bytes", "dr_ops", "dr_bits"]}}
{"project": "FFmpeg", "commit_id": "cf818be4f2f1e06bf63da3a6b55a4c3620952070", "target": 1, "func": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n", "idx": 17341, "substitutes": {"p1": ["p7", "pcOne", "pc1", "P1", " pOne", "point1", "P2", "c1", "pc2", " p3", "p3", "pOne", "P3", " p7", "P7", "c7", "point2", "c2", "pointOne", "c3"], "p2": ["p0", "P1", "point1", "P2", "cp8", "P0", "cp1", "p8", "P02", " p0", "point02", "cp0", " p8", " ptwo", "P8", "Ptwo", " p02", "ptwo", "point2", "pointtwo", "cp2", "p02"], "cdt": ["cdpt", "cft", "cdp", "ndrt", "cftr", "cdrt", " cdpt", " cdtree", " cdrt", "patchrt", "patchtree", " cdtr", "ndc", "CDtr", "CDp", "ndtree", "ndp", " cdp", "idc", "cdtree", "cfpt", "cdc", "idp", "patcht", "idtree", "cdtr", " cdc", "CDpt", "idt", "patchp", "ndt", "CDt", "cfp"], "r": ["m", "fr", "rr", "j", "rs", "x", "f", "err", "hr", "n", "R", "rt", "ar", "g", "i", "or", "var", "rh", "o", "l", "d", "nr", "ru", "w", "sr", "e", "k", "v", "c", "rb", "ri", "p", "ur", "pr", "ra", "h", "a", "er", "u"], "b": ["ab", "eb", "bin", "br", "db", "bs", "x", "f", "base", "ob", "reb", "n", "sb", "i", "cb", "wb", "B", "pb", "lb", "bb", "nb", "abc", "ba", "l", "d", "bar", "w", "mb", "e", "k", "fb", "bh", "v", "emb", "c", "rb", "p", "binary", "h", "a", "body", "y", "u"]}}
{"project": "FFmpeg", "commit_id": "ae4c9ddebc32eaacbd62681d776881e59ca6e6f7", "target": 1, "func": "static AVFrame *do_psnr(AVFilterContext *ctx, AVFrame *main,\n\n                        const AVFrame *ref)\n\n{\n\n    PSNRContext *s = ctx->priv;\n\n    double comp_mse[4], mse = 0;\n\n    int j, c;\n\n    AVDictionary **metadata = avpriv_frame_get_metadatap(main);\n\n\n\n    s->compute_mse(s, (const uint8_t **)main->data, main->linesize,\n\n                      (const uint8_t **)ref->data, ref->linesize,\n\n                       main->width, main->height, comp_mse);\n\n\n\n    for (j = 0; j < s->nb_components; j++)\n\n        mse += comp_mse[j] * s->planeweight[j];\n\n\n\n    s->min_mse = FFMIN(s->min_mse, mse);\n\n    s->max_mse = FFMAX(s->max_mse, mse);\n\n\n\n    s->mse += mse;\n\n    for (j = 0; j < s->nb_components; j++)\n\n        s->mse_comp[j] += comp_mse[j];\n\n    s->nb_frames++;\n\n\n\n    for (j = 0; j < s->nb_components; j++) {\n\n        c = s->is_rgb ? s->rgba_map[j] : j;\n\n        set_meta(metadata, \"lavfi.psnr.mse.\", s->comps[j], comp_mse[c]);\n\n        set_meta(metadata, \"lavfi.psnr.psnr.\", s->comps[j], get_psnr(comp_mse[c], 1, s->max[c]));\n\n    }\n\n    set_meta(metadata, \"lavfi.psnr.mse_avg\", 0, mse);\n\n    set_meta(metadata, \"lavfi.psnr.psnr_avg\", 0, get_psnr(mse, 1, s->average_max));\n\n\n\n    if (s->stats_file) {\n\n        fprintf(s->stats_file, \"n:%\"PRId64\" mse_avg:%0.2f \", s->nb_frames, mse);\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"mse_%c:%0.2f \", s->comps[j], comp_mse[c]);\n\n        }\n\n        for (j = 0; j < s->nb_components; j++) {\n\n            c = s->is_rgb ? s->rgba_map[j] : j;\n\n            fprintf(s->stats_file, \"psnr_%c:%0.2f \", s->comps[j],\n\n                    get_psnr(comp_mse[c], 1, s->max[c]));\n\n        }\n\n        fprintf(s->stats_file, \"\\n\");\n\n    }\n\n\n\n    return main;\n\n}\n", "idx": 17350, "substitutes": {"ctx": ["cal", "core", "conf", "cca", "gc", "cm", "cf", "comm", "cb", "anc", "bc", "src", "cp", "bt", "scope", "ctrl", "cas", "Context", "ca", "setup", "cs", "context", "acs", "cms", "conv", "tx", "tc", "config", "sc", "q", "cam", "client", "cmd", "support", "sci", "cmp", "mac", "sq", "cv", "conn"], "ref": ["part", "ab", "fr", "m", "db", "info", "conf", "base", "ob", "f", "obj", "alt", "af", "full", "reg", "Ref", "rel", "block", "reference", "pb", "mem", "def", "range", "arc", "rec", "re", "old", "diff", "fact", "pre", "comp", "img", "config", "id", "remote", "primary", "parent", "req", "p", "external", "b", "cache", "wa", "local", "aff", "end", " reference", "rem", "source", "REF"], "s": ["ns", "set", "spec", "full", "settings", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "sa", "m", "ts", "sg", "sis", "rs", "aws", "self", "lines", "o", "su", "sc", "v", "si", "S", "single", "a", "hs", "ds", "ans", "f", "sv", "shared", "r", "sb", "ys", "src", "as", "l", "ins", "w", "sync", "ps", "secondary", "b", "sys", "es", "states", "sq", "sf", "session", "stats", "t", "conf", "data", "services", "n", "plugins", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "parts", "tp", "server", "y", "u"], "comp_mse": ["comp_kmse", "comp_rmce", "comp_amme", "comp_nke", "comp_magge", "comp_nso", "comp_amce", "comp_mpe", "comp_magme", "comp_cze", "comp_nse", "comp_amte", "comp_magse", "comp_rce", "comp_ampe", "comp_Mpe", "comp_mce", "comp_mese", "comp_cpe", "comp_Mge", "comp_rmte", "comp_cmso", "comp_cmce", "comp_mbe", "comp_rmse", "comp_rmze", "comp_misse", "comp_amse", "comp_mrese", "comp_cisse", "comp_nte", "comp_amesh", "comp_nge", "comp_mrse", "comp_rmbe", "comp_amese", "comp_cse", "comp_mge", "comp_mesh", "comp_Mse", "comp_amge", "comp_rmesh", "comp_MSE", "comp_mke", "comp_rso", "comp_cmse", "comp_mSE", "comp_rmSE", "comp_nce", "comp_npe", "comp_rke", "comp_cmke", "comp_Mte", "comp_ambe", "comp_kmisse", "comp_mte", "comp_Mze", "comp_mme", "comp_mrge", "comp_kmze", "comp_mso", "comp_rse", "comp_kmpe", "comp_mze", "comp_magese", "comp_mrme"], "j": ["jo", "jc", "m", "fr", "jl", "ji", "code", "t", "br", "ch", "x", "jp", "f", "uj", "jit", "obj", "json", "bj", "note", "err", "r", "adj", "n", "syn", "jj", "job", "qi", "g", "i", "je", "z", "ie", "ij", "jet", "pos", "aj", "dj", " l", "o", "l", "d", "jen", "w", "oj", "J", "key", "k", "e", "q", "kj", "v", "js", "p", "off", "b", " i", "h", "er", "ja", " ii", "im", "jam", "it", "el", "section", "y", "li", "u"], "c": ["dc", "m", "ch", "code", "t", "x", "f", "err", "vc", "r", "n", "cm", "cf", "g", "i", "coll", "cb", "z", "mc", "count", "cy", "o", "ca", "sc", "cs", "arc", "l", "d", "ac", "ci", "con", "w", "e", "k", "cu", "q", "cr", "v", "lc", "cat", "cl", "p", "uc", "b", "cache", "col", "cell", "ec", "h", "cn", "co", "C", "y", "cc", "u"], "metadata": ["uri", "wp", "m", "session", "metal", "stats", "data", "info", "cookie", "note", "archive", "annot", "shared", "json", "track", "md", "ann", "bm", "details", "java", "document", "communication", "package", "utils", "zip", "filename", "magic", "parser", "nm", "generic", "database", "sound", "header", "summary", "adata", "carbon", "memory", "args", "met", "config", "general", "mx", "meta", "binary", "xml", "metry", "music", "storage", "properties", "gm", "template", "mt", "message", "notes", "mm", "valid", "np", "tm", "collection"], "nb_frames": ["ni_images", "num_steps", "nbCimages", "nb__lines", "nb_images", "nb_frame", "num_points", "nb_steps", "nbCshots", "ni_shots", "nb__frames", "num_frames", "nb__images", "nbofpoints", "nb_lines", "nbCframes", "nbClines", "nbofsteps", "nb_shots", "nb__shots", "ni_lines", "nbofframe", "nb_points", "ni_frames", "num_frame", "nbofframes"]}}
{"project": "FFmpeg", "commit_id": "eb9fb508b0e09d85d234fe694333b2005e1d7a7e", "target": 1, "func": "static void matroska_add_index_entries(MatroskaDemuxContext *matroska)\n\n{\n\n    EbmlList *index_list;\n\n    MatroskaIndex *index;\n\n    int index_scale = 1;\n\n    int i, j;\n\n\n\n    if (matroska->ctx->flags & AVFMT_FLAG_IGNIDX)\n\n        return;\n\n\n\n    index_list = &matroska->index;\n\n    index      = index_list->elem;\n\n    if (index_list->nb_elem &&\n\n        index[0].time > 1E14 / matroska->time_scale) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING, \"Working around broken index.\\n\");\n\n        index_scale = matroska->time_scale;\n\n    }\n\n    for (i = 0; i < index_list->nb_elem; i++) {\n\n        EbmlList *pos_list    = &index[i].pos;\n\n        MatroskaIndexPos *pos = pos_list->elem;\n\n        for (j = 0; j < pos_list->nb_elem; j++) {\n\n            MatroskaTrack *track = matroska_find_track_by_num(matroska,\n\n                                                              pos[j].track);\n\n            if (track && track->stream)\n\n                av_add_index_entry(track->stream,\n\n                                   pos[j].pos + matroska->segment_start,\n\n                                   index[i].time / index_scale, 0, 0,\n\n                                   AVINDEX_KEYFRAME);\n\n        }\n\n    }\n\n}\n", "idx": 17353, "substitutes": {"matroska": ["catrosku", "matrosca", "metrsya", "matronesla", "macroky", "matrowoa", "matrskee", "matrocki", "matrooa", "Matroskee", "Matrocca", "Matrola", "Matroka", "catrasla", "matrasla", "matrusla", "Matrosaka", "matroaka", "matrowla", "matroseky", "matrusqua", "matroky", "matlosaka", "Matrosla", "macrola", "matloska", "matrocka", "matrosoa", "matraski", "catroska", " matrosaka", "matronesya", "metrsoa", " matrosya", "matrosha", "metrosla", " matrosga", "matlosya", "matrockee", "macroka", "matrosga", "metrsla", "matroya", "catroski", "matrocla", "matroskee", "Matrocku", "catrasku", "matroneska", "matroseha", "matrsoa", "matrowya", "macrosaka", "matroseka", "matroku", "matrsca", "matroka", "macrosky", "matrokee", "matrosaka", "macrosla", "macrosha", "matroqua", "matrosya", " matrasga", "Matroku", "Matrokee", "matraska", "matrasga", "macroha", "matrosela", "matrsku", "matrola", " matrasya", "matrsya", "Matrockee", "matrosekee", "matroseca", " matrasaka", "Matrosca", "matroki", "matronesga", "matrosla", "macroska", "matrasku", "matruska", "matrocaka", "catraski", "matroski", "Matrosku", "metrska", "matroseku", "metroska", "matrusky", "macroaka", "matrocca", "matraskee", "matrocha", "matroneskee", "matrosqua", "metrosya", "macroqua", "matrowka", "matrasaka", "matrska", "matrosequa", "catrosla", "catraska", "matrsla", "metrosoa", "Matroaka", "matroseaka", "matrocku", "Matrocka", "matrasya", "matrosky", "macrosqua", " matraska", "matrosku", "matroha", "matlosga", "Matroska", "matronesaka"], "index_list": ["pos_loop", " indexinglist", "indexingtree", "pos_info", " index_source", "posinglist", "num_queue", "indexensource", "num_list", "numerlists", " index_cont", "pos_lc", "posinginfo", "indexertree", "index_loop", " indexingtree", "indexentable", "indexingcont", "index_tree", "indexingloop", "num_List", " index_base", "index_List", "numerList", "index_lc", "index_source", " index_lc", "index_cont", "index_table", "index_info", "index_queue", "indexingtable", "indexinginfo", " index_pair", "indexerqueue", "indexingbase", "indexingList", " indexingsource", "indexerlists", " indexingtable", "indexerlist", "posingloop", "indexerList", "index_lists", " index_table", "indexinglists", "indexinglist", "indexinglc", "num_lists", "numerlist", "indexentree", "indexingpair", "posinglc", "indexertable", "index_base", "indexenlist", "indexingsource", "numerqueue", "index_pair", " index_tree", "indexersource", "indexingqueue"], "index": ["entry", "point", "x", "comment", "edit", "thread", "inc", "num", "master", "Index", "zip", "stack", "config", "output", "write", "end", "word", "source", "input", "example", "search", "action", "sort", "document", "query", "object", "change", "summary", "queue", "key", "open", "update", "include", "table", "route", "find", "weight", "connection", "list", "order", "instance", "view", "image", "call", "current", "block", "match", "type", "ind", "model", "multi", "date", "page", "array", "sync", "position", "address", "project", "frame", "value", "connect", "version", "record", "data", "office", "module", "pass", "slice", "link", "header", "draw", "event", "unit", "cache", "body", "server", "diff", "press"], "i": ["gi", "uri", "m", "bi", "ji", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "io", "z", "ii", "ie", "di", "iu", "I", "zi", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "k", "e", "v", "c", "ni", "si", "ki", "ri", "p", "xi", "b", "a", "iv", "im", "eni", "fi", "y", "li", "u"], "j": ["gi", "jo", "jc", "m", "fr", "jl", "ji", "br", "t", "x", "jp", "bj", "uj", "obj", "f", "note", "qi", "r", "adj", "n", "jj", "job", "je", "g", "z", "ii", "ij", "jet", "ie", "ind", "aj", "dj", "o", "l", "w", "oj", "J", "key", "k", "kj", "q", "e", "v", "js", "p", "xi", "b", "pr", "cell", "h", "ja", "y", "li", "u"], "pos_list": [" posingList", "posestable", " pos_table", "poseslc", "pos_status", " pos_List", "object_lists", " pos_status", "posllists", " posinglist", "posllist", "pos2List", "pos_listed", "pos_table", "pos2listed", "pos2list", "poseslist", "object_l", "object_listed", " pos_lc", "posll", " pos_listed", "posinglist", " posinglisted", "pos_lists", "object_list", "objectll", "objectllisted", "pos_List", "objectllists", "posllisted", "posingList", "posinglisted", "objectllist", "pos_l", "pos_lc", "posesstatus"], "pos": ["pc", "part", "spec", "point", "offset", "pid", "time", "t", "data", "obj", "x", "ref", "all", "sort", "r", "press", "coord", "rel", "pack", "block", "sl", "type", "z", "loc", "points", "pass", "Pos", "ass", "min", "tag", "def", "pointer", "POS", "object", "po", "range", "prop", "ack", "val", "slot", "axis", "to", "comp", "no", "rot", "zone", "start", "length", "unit", "ps", "position", "neg", "patch", "line", "p", "seq", "pose", "depth", "col", "param", "form", "field", "os", "end", "list", "port", "pres", "diff", "source", "pt", "len"], "track": ["contact", "rank", "rr", "session", "group", "work", "record", "skip", "tr", "song", "token", "trip", "thread", "comment", "sort", "r", "trace", "road", "hop", "rack", "module", "stream", "coll", "match", "type", "package", "zip", "progress", "tag", "ack", "host", "gap", "sound", "rec", "path", "step", "cost", "roll", "comp", "dr", "strip", "stage", "play", "route", "field", "tracks", "form", "tax", "row", "transform", "Track", "project", "port", "tracking", "source", "seek", "round"]}}
{"project": "FFmpeg", "commit_id": "0058584580b87feb47898e60e4b80c7f425882ad", "target": 0, "func": "static inline void downmix_3f_2r_to_mono(float *samples)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        samples[i] += (samples[i + 256] + samples[i + 512] + samples[i + 768] + samples[i + 1024]);\n\n        samples[i + 256] = samples[i + 512] = samples[i + 768] = samples[i + 1024] = 0;\n\n    }\n\n}\n", "idx": 17357, "substitutes": {"samples": ["ismodels", "says", "asamps", "sample", " sample", "samp", "Saces", "Sample", "Samp", "piments", "isamples", " schanges", "asages", "hesamples", " sacks", "pamples", "ssample", "Sacks", " smodels", "famps", "pamps", "samps", "hesays", "sipes", "fongs", "sacks", " songs", "ssiments", "suppamps", "psample", "schanges", " siments", "pample", " samp", " sances", "ssages", "sifiers", "suppifiers", "usamp", " sipes", "suppiments", " sages", "isances", "Samps", "hesamps", "pummies", "iamps", "asipes", "iiments", "iummies", "sages", "Samples", "asample", "summies", "suppamples", "iamples", "asiments", " saces", "ssamples", "songs", "imodels", "fample", "isiments", "ssamp", "asamples", "ssipes", "usamps", " ssample", "usamples", "saces", "sances", "pchanges", " samps", "ssifiers", "ussample", "heschanges", "ssaces", "pamp", "siments", "pongs", "ssamps", "pays", " says", "packs", "smodels", "famples", "iances"], "i": ["gi", "ti", "uri", "m", "bi", "init", "j", "ami", "info", "x", "f", "ix", "ini", "qi", "ai", "io", "mi", "phi", "g", "hi", "ii", "in", "ie", "di", "index", "iu", "slice", "I", "mini", "multi", "zi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "id", "key", "e", "v", "cli", "c", "si", "ki", "ri", "p", "xi", "b", "mu", "uli", "anti", "h", "a", "api", "iv", "it", "my", "fi", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "fb506e701e9bafa3e0685747c1c98962c52d1962", "target": 1, "func": "static bool vtd_decide_config(IntelIOMMUState *s, Error **errp)\n\n{\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(s);\n\n\n\n    /* Currently Intel IOMMU IR only support \"kernel-irqchip={off|split}\" */\n\n    if (x86_iommu->intr_supported && kvm_irqchip_in_kernel() &&\n\n        !kvm_irqchip_is_split()) {\n\n        error_setg(errp, \"Intel Interrupt Remapping cannot work with \"\n\n                         \"kernel-irqchip=on, please use 'split|off'.\");\n\n        return false;\n\n    }\n\n    if (s->intr_eim == ON_OFF_AUTO_ON && !x86_iommu->intr_supported) {\n\n        error_setg(errp, \"eim=on cannot be selected without intremap=on\");\n\n        return false;\n\n    }\n\n\n\n    if (s->intr_eim == ON_OFF_AUTO_AUTO) {\n\n        s->intr_eim = x86_iommu->intr_supported ?\n\n                                              ON_OFF_AUTO_ON : ON_OFF_AUTO_OFF;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 17362, "substitutes": {"s": ["ns", "spec", "m", "ts", "session", "t", "rs", "f", "services", "r", "service", "plugins", "details", "sb", "g", "i", "ips", "ss", "ls", "ops", "fs", "self", "is", "o", "cs", "l", "d", "ins", "tests", "e", "ssl", "ses", "sync", "private", "c", "js", "ps", "p", "secondary", "S", "ks", "gs", "sys", "its", "a", "es", "parts", "state", "hs", "os", "sets", "states", "sq", "params", "ds", "sf"], "errp": ["verf", " errP", "irc", "rrpre", "errP", "err", "irP", "errpc", "erps", "verp", " errc", "resultr", "resultp", "errc", "erf", "rrc", "errpre", "irp", "erpc", "verps", "erp", "irpre", "verr", "errr", "resultpc", " errr", "rrp", "errps", " errps", " errf", "rrP", " errpc", "errf", "resultps", " errpre"], "x86_iommu": ["x86_iommus", "x86_iormo", "x86_uiomur", "x86_uomo", "x86_iromur", "x86_iompU", "x86_iammur", "x86_iormbu", "x86_iommui", "x86_irombu", "x86_iommuit", "x86_iombo", "x86_komui", "x86_kommui", "x86_komu", "x86_uommur", "x86_komU", "x86_iomu", "x86_iCommU", "x86_kommu", "x86_iomo", "x86_iomur", "x86_iompu", "x86_uiomuit", "x86_iromu", "x86_uommbu", "x86_iommur", "x86_iammu", "x86_iomuit", "x86_uiomu", "x86_iormus", "x86_komur", "x86_komo", "x86_iammuit", "x86_iommo", "x86_uommu", "x86_iombuit", "x86_iompo", "x86_kommU", "x86_komuit", "x86_uiommu", "x86_iommbu", "x86_iormu", "x86_iCommur", "x86_uomur", "x86_iompui", "x86_iromo", "x86_kommur", "x86_iormuit", "x86_iompuit", "x86_iommU", "x86_uiomus", "x86_uomu", "x86_iomui", "x86_iomU", "x86_uiommuit", "x86_iCommu", "x86_kommo", "x86_iompur", "x86_iammus", "x86_iombu", "x86_kommuit", "x86_uiommur", "x86_iCommui", "x86_iomus", "x86_uiommus", "x86_uommo", "x86_iombur", "x86_uombu", "x86_iormur"]}}
{"project": "qemu", "commit_id": "5706db1deb061ee9affdcea81e59c4c2cad7c41e", "target": 1, "func": "static int no_init_in (HWVoiceIn *hw, struct audsettings *as)\n\n{\n\n    audio_pcm_init_info (&hw->info, as);\n\n    hw->samples = 1024;\n\n    return 0;\n\n}\n", "idx": 17370, "substitutes": {"hw": ["wav", "fw", "wx", "vc", "gio", "eth", "gg", "hz", "wo", "hop", "sw", "rh", " HW", "ow", "wb", "iw", "ctx", "kw", "lv", "ew", "craft", "hhh", "gp", "him", "ht", "drm", "w", "haw", "ih", "nw", "wm", "hp", "rw", "gt", "hm", "tw", "igh", "hh", "wu", "how", "aw", "h", "inst", "mm"], "as": ["asu", "was", "ans", "au", "ras", "las", "aws", "ays", "ais", "ai", "ar", "As", "ams", "ast", "am", "nas", "ap", "ass", "asse", "is", "acs", "ach", "ac", "ay", "asa", "inas", "ars", "AS", "gs", "aw", "a", "os", "pas", "an", "sa", "asc"]}}
{"project": "FFmpeg", "commit_id": "fe6eea99efac66839052af547426518efd970b24", "target": 1, "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n\n{\n\n    NSVContext *nsv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st[2] = {NULL, NULL};\n\n    NSVStream *nst;\n\n    AVPacket *pkt;\n\n    int i, err = 0;\n\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n\n    uint32_t vsize;\n\n    uint16_t asize;\n\n    uint16_t auxsize;\n\n\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\n\n\nnull_chunk_retry:\n\n    if (pb->eof_reached)\n\n        return -1;\n\n\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n\n        err = nsv_resync(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state == NSV_FOUND_NSVS)\n\n        err = nsv_parse_NSVs_header(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n\n        return -1;\n\n\n\n    auxcount = avio_r8(pb);\n\n    vsize = avio_rl16(pb);\n\n    asize = avio_rl16(pb);\n\n    vsize = (vsize << 4) | (auxcount >> 4);\n\n    auxcount &= 0x0f;\n\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n\n           auxcount, vsize, asize);\n\n    /* skip aux stuff */\n\n    for (i = 0; i < auxcount; i++) {\n\n        uint32_t av_unused auxtag;\n\n        auxsize = avio_rl16(pb);\n\n        auxtag = avio_rl32(pb);\n\n        avio_skip(pb, auxsize);\n\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n\n    }\n\n\n\n    if (pb->eof_reached)\n\n        return -1;\n\n    if (!vsize && !asize) {\n\n        nsv->state = NSV_UNSYNC;\n\n        goto null_chunk_retry;\n\n    }\n\n\n\n    /* map back streams to v,a */\n\n    if (s->nb_streams > 0)\n\n        st[s->streams[0]->id] = s->streams[0];\n\n    if (s->nb_streams > 1)\n\n        st[s->streams[1]->id] = s->streams[1];\n\n\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n\n        nst = st[NSV_ST_VIDEO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n\n        av_get_packet(pb, pkt, vsize);\n\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n\n        pkt->dts = nst->frame_offset;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        for (i = 0; i < FFMIN(8, vsize); i++)\n\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n\n                   i, pkt->data[i]);\n\n    }\n\n    if(st[NSV_ST_VIDEO])\n\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n\n\n    if (asize && st[NSV_ST_AUDIO]) {\n\n        nst = st[NSV_ST_AUDIO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n\n        /* read raw audio specific header on the first audio chunk... */\n\n        /* on ALL audio chunks ?? seems so! */\n\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n\n            uint8_t bps;\n\n            uint8_t channels;\n\n            uint16_t samplerate;\n\n            bps = avio_r8(pb);\n\n            channels = avio_r8(pb);\n\n            samplerate = avio_rl16(pb);\n\n            if (!channels || !samplerate)\n\n                return AVERROR_INVALIDDATA;\n\n            asize-=4;\n\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                   bps, channels, samplerate);\n\n            if (fill_header) {\n\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n\n                if (bps != 16) {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n", "idx": 17381, "substitutes": {"s": ["ns", "native", "spec", "sup", "ts", "sg", "session", "t", "f", "sv", "services", "service", "r", "plugins", "n", "sie", "sb", "g", "sl", "ss", "ctx", "sim", "xs", "self", "parser", "is", "o", "cs", "su", "space", "bis", "qs", "sc", "ssl", "e", "sr", "ses", "v", "span", "c", "client", "si", "ps", "sym", "p", "support", "S", "sci", "b", "http", "gs", "sys", "storage", "proc", "us", "se", "server", "sq", "south", "sa", "ds", "sf"], "fill_header": ["v_version", "v_channel", "v_header", " enc_header", "v_back", " enc_back", " enc_version", " enc_channel"], "nsv": ["snvp", "tsv", "lsvp", "xsver", "netsvs", "ksf", "netssv", "NSvs", "kssv", "nsvs", "xsf", "lsf", "xsv", "csk", "NSvc", "nstv", "msvs", "csvi", "nssv", "ysvp", "netsv", "xsvs", "csvin", "nesf", "nesv", "xsvc", " nsvp", "tsf", "NSf", "csV", "sntv", "msvp", "lssv", " nsf", "ksv", "nesvi", "nsver", "ysvs", " nstv", "snv", "tsvs", "nsV", "nsf", "msv", "csver", "nsvi", "csvc", "consv", "nasv", "consk", "nasvp", "consvc", "nsk", "lsvi", "csf", "csv", "snf", "nsvin", "tsvp", "ksvs", "ysvin", "nsvc", "lsV", "lsvc", "csvp", "nastv", "consver", "ssvp", "xsk", "NSv", "nesV", "ysv", "ssv", "ssvs", "msf", "netsf", "nasf", "lsvs", "csvs", "ssvin", "lsv", "nsvp"], "pb": ["pc", "pt", "types", "wp", "plugin", "ab", "eb", "phys", "db", "bs", "fp", "typ", "pub", "jp", "obj", "platform", "vp", "pd", "pl", "bm", "phrase", "sb", "pm", "bp", "cb", "cpp", "bc", "hub", "lp", "wb", "ctx", "fc", "utils", "lb", "bb", "nb", "PB", "parser", "dp", "pg", "prop", "gb", "rob", "pp", "summary", "kb", "pkg", "bf", "queue", "pa", "ssl", "bh", "fb", "ses", "asm", "rb", "si", "p", "mp", "b", "ppa", "proc", "api", "pro", "tp", "py", "port", "prot", "uf", "np", "ub", "cv", "sf"], "st": ["pc", "rest", "ct", "sp", "fe", "sb", "ost", "sw", "sl", "ast", "ss", "src", "ST", "store", "std", "sn", "sc", "sth", "cr", "stage", "sts", "St", "storage", "inst", "ft", "se", "sa"], "nst": ["pste", "nct", "nsc", "nsste", " nsc", "nsst", "pst", "pct", "nste", "nssc", "psc", " nste", " nct", "nsct"], "pkt": ["Pkt", "ppkg", "Pct", "Pkg", " pkg", "ppct", "Pst", "pkg", " pst", " pct", "pst", "pct", "ppst", "ppkt"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "code", "t", "ami", "info", "x", "f", "err", "base", "ix", "ini", "qi", "r", "ai", "mi", "n", "phi", "hi", "type", "z", "ii", "ie", "di", "index", "iu", "ind", "I", "mini", "multi", "zi", "count", "slice", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "start", "e", "k", "v", "cli", "c", "ni", "si", "ki", "ri", "p", "xi", "b", "it", "eni", "fi", "esi", "y", "li", "mu"], "auxcount": ["aultdepth", "auxall", " auxlast", "ausize", " auxcheck", "auxCount", "aultcount", " auxdepth", "afCount", " auxiliarycount", "aucount", "auCount", "aulength", " auxsum", "uxall", "afcount", " auxiliarydepth", "cfsize", " auxiliaryCount", "auxsum", " auxall", " auxiliarycheck", " auxiliarysum", "afsize", " auxiliaryall", "auxdepth", "auxlast", " auxCount", " auxiliarysize", "uxCount", " auxiliarylength", "cfcount", "uxcount", "uxlast", " auxiliarylast", "aultsum", "auxlength", "uxsize", "aultsize", "cfCount", "auxcheck", " auxlength", "uxcheck"], "vsize": ["lvsize", "cvname", "avscale", "vcount", "vpgrade", "svcapacity", "vpname", " vwidth", " vSize", "nvsize", "vname", " vshape", "vSize", " vcenter", " vize", "tvname", "auxwidth", "vpscale", "cvsmall", " vsmall", "svsmall", "auxgrow", "vcize", "tvsize", "vshape", "vscale", "auxize", "cvsize", "nvwidth", "avsize", "avize", "Vscale", "lvshape", "vcscale", "tvscale", "evSize", "cvgrade", " vscale", "evcount", "vgrade", "evsize", "vpsize", "svsize", "cvscale", "lvscale", "vsmall", " vname", " vgrow", "avcenter", "tvwidth", "vbytes", "vgrow", "svbytes", "svscale", "evscale", "vize", "nvgrade", " vbytes", "lvcapacity", "nvize", "nvscale", "vwidth", "VSize", "svshape", "nvname", " vcount", " vcapacity", "vcenter", "vcsize", "Vcount", "cvbytes", "vccenter", "nvgrow", "vcapacity", "Vsize"], "asize": ["aspect", "all", "askssize", "rasize", "ansize", "r", "ASizable", "arsize", "asiz", "Assize", "Asized", " asIZE", "asized", "g", "arspect", "asIZE", "this", "ASiz", "rasizable", "anssize", " assize", "ASize", "rasIZE", "ansized", "ASsize", "rassize", "asizable", "id", "Aspect", " asizable", "_", "c", "Asize", " aspect", "ansiz", "arssize", "asksiz", "arsized", "ASized", "asksized", " asized", "assize", "asksize", "write", "end", "ASIZE"], "auxsize": [" auxiliaryhandle", "auxSize", "ausize", "luxshell", "auxhandle", "aultcount", "aucount", "uxsum", "luxcount", " auxcore", " auxsum", "afize", "vcore", " auxshell", "auxize", "aultize", "auxstyle", "afcount", "auxcore", " auxize", " auxiliarystyle", "auxsum", " auxiliarysum", "afsize", "auSize", "aushell", "vhandle", " auxiliarycore", " auxiliaryize", " auxiliarysize", "luxsize", "auxshell", "afsum", "aultsum", "actualsize", "vize", "uxsize", "uxstyle", "actualstyle", "luxSize", " auxhandle", "aultsize", "actualsum", " auxSize"], "av_unused": ["av_uncuse", "av_uncsec", "av_uncused", "av_lenused", "av_unssec", "av_leninitialized", "av_unsused", "av_lensec", "av_lenuse", "av_unsuse", "av_unsinitialized", "av_unsec", "av_uncinitialized", "av_uninitialized", "av_unuse"], "NSVStream": ["NSVConnection", "NSVLConnection", "NSVTChannel", "NSVLObject", "NSVTObject", "NSVAConnection", "CSVLStream", "CSVChannel", "CSVLChannel", "CSVLObject", "NSVAObject", "NSVTConnection", "NSVAStream", "CSVStream", "NSVLStream", "NSVLChannel", "CSVConnection", "CSVObject", "NSVAChannel", "CSVLConnection", "NSVObject", "NSVTStream", "NSVChannel"], "priv_data": ["privpredata", "priv2txt", "private_record", "privprectx", "priv_ctx", "priv2ctx", "priv_txt", "priv_record", "privpretxt", "privprerecord", "private_data", "private_ctx", "priv2data", "priv2record", "private_txt"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411, "substitutes": {"f": ["m", "fr", "xf", "fw", "t", "fp", "x", "ref", "info", "fe", "r", "file", "elf", "fa", "feed", "cf", "g", "i", "fc", "fs", "rf", "self", "fen", "o", "fo", "fx", "l", "d", "df", "bf", "w", "fd", "e", "k", "fb", "front", "v", "c", "F", "p", "b", "fm", "tf", "fn", "form", "h", "sf"], "opaque": ["ipoc", "ipaque", "obhole", "Ohole", "Ofac", "obfac", "ipfac", "opfac", "iphole", "opoc", "ophole", "oboc", "obaque", "Ooc", "Oaque"], "ret": ["part", "db", "code", "data", "ref", "alt", "true", "let", "lit", "nt", "reg", "rt", "fun", "result", "num", "flag", "match", "bare", "pass", "orig", "ext", "fin", "run", "rf", "active", "def", "rets", "en", "out", "art", "att", "arg", "bad", "val", "re", "Ret", "bf", "fail", "back", "reset", "value", "det", "fit", "sr", "rev", "cat", "post", "rb", "hard", "url", "gt", "RET", "pat", "error", "red", "rep", "res", "pet", "mt", "ft", "valid", "iter", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "51e1cc16d3e89a785f3231065c4eb898a0401a93", "target": 1, "func": "matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            assert(size>0); // size <=3 is checked before size-=3 above\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n                uint8_t *pkt_data = data;\n                if (matroska->tracks[track]->encoding_scope & 1) {\n                    switch (matroska->tracks[track]->encoding_algo) {\n                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n                        offset = matroska->tracks[track]->encoding_settings_len;\n                        break;\n                    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n                        pkt_data = NULL;\n                        do {\n                            ilen = lace_size[n];\n                            olen = pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data,\n                                                  pkt_size+LZO_OUTPUT_PADDING);\n                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);\n                        if (result) {\n                            continue;\n                        }\n                        pkt_size -= olen;\n                        break;\n#ifdef CONFIG_ZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n                        z_stream zstream = {0};\n                        pkt_data = NULL;\n                        if (inflateInit(&zstream) != Z_OK)\n                            continue;\n                        zstream.next_in = data;\n                        zstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            zstream.avail_out = pkt_size - zstream.total_out;\n                            zstream.next_out = pkt_data + zstream.total_out;\n                            result = inflate(&zstream, Z_NO_FLUSH);\n                        } while (result==Z_OK && pkt_size<10000000);\n                        pkt_size = zstream.total_out;\n                        inflateEnd(&zstream);\n                        if (result != Z_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n#ifdef CONFIG_BZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n                        bz_stream bzstream = {0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "idx": 17412, "substitutes": {"track": ["m", "tt", "session", "rank", "skip", "quant", "time", "tr", "record", "info", "mode", "work", "token", "call", "trip", "thread", "train", "sort", "trace", "report", "hop", "road", "gro", "rack", "stream", "coll", "type", "month", "match", "index", "claim", "tag", "ack", "gap", "host", "rec", "step", "path", "cost", "event", "roll", "course", "sn", "dr", "group", "sync", "strip", "patch", "stage", "play", "check", "route", "form", "tracks", "tax", "field", "transform", "Track", "nn", "project", "port", "tracking", "mm", "race", "order", "seek", "dist", "round"], "st": ["pt", "ist", "est", "tt", "fr", "session", "s", "nd", "stim", "t", "rest", "ct", "sp", "ste", "fe", "nt", "service", "stab", "str", "sb", "ost", "stream", "sl", "sw", "station", "src", "ast", "ss", "ptr", "ST", "sta", "art", "rec", "d", "std", "step", "stack", "stop", "sn", "start", "sc", "sth", "tmp", "stage", "sts", "play", "St", "inst", "state", "end", "sa", "dist"], "pkt": ["Pkt", "Pct", "Pkg", " pkg", "pkg", "Pst", "apct", " pst", "apst", "apkg", " pct", "pst", "pct", "apkt"], "origdata": ["margdat", "realData", "Origdat", "origdat", " origData", "origData", "Origfile", " origata", " origmedia", "Origwindow", " origwindow", " origfile", "originaldata", " origdat", "realdata", "realdat", "margfile", "originalData", "origfile", "margData", "Origdata", "Origata", "origwindow", "margdata", "originaldat", "originalwindow", "origata", "realata", "Origmedia", "origmedia", "margmedia", "OrigData"], "block_time": ["block\u00b7time", "block_rate", "block\u00b7value", "update_size", "lock_time", "update_value", "update\u00b7time", "block_speed", "lock_speed", "lock_length", "update\u00b7rate", "update_time", "update\u00b7value", "block_length", "block_times", "lock_times", "block_size", "block\u00b7rate", "block_value", "update_rate", "update\u00b7size", "block\u00b7size"], "lace_size": ["lace_len", "blockmaxsize", "blockmaxlen", "blockmaxstyle", "lace_style", "blockmaxtime", "lace_time", "block_style", "block_len", "block_size"], "n": ["ns", " ng", "m", "dn", "s", "j", "t", "name", "f", "nt", "ne", "mn", "N", "g", "i", "z", "ny", "pos", "nb", "en", "count", "o", "l", "d", "nr", "nc", "size", "no", "sn", "nu", "k", "span", "v", "c", "ni", " ni", "p", "b", "u", "cn", "number", "nn", "y", "len"], "flags": ["types", "status", "strings", "stats", "data", "FLAG", "fields", "settings", "options", "Flags", "dates", "details", "vals", "times", "flag", "ips", "files", "ints", "utils", "ops", "ags", "fs", "mask", "locks", "lines", "checks", "mods", "links", "feat", "args", "tests", "acks", "features", "codes", "fd", "alls", "frames", "steps", "bits", "atts", "lag", "rows", "ids", "tracks", "errors", "reads", "bytes", "parts", "states", "members", "comments", "ds", "len"], "num": ["bin", "offset", "f", "name", "net", "mult", "du", "sort", "inc", "coord", "NUM", "tu", "loc", "node", "max", "orig", "index", "pos", "mon", "dim", "nb", "multi", "count", "nm", "su", "nc", "uu", "common", "uni", "no", "con", "nu", "id", "nom", "batch", "ni", "unit", "position", "umi", "sum", "norm", "b", "Num", "fn", "form", "number", "len", "mu"], "stream_index": ["pipe_target", "streamingposition", "streamsindex", "streamsinstance", "stream_ind", "streamskey", "record_conn", "streamingindex", "streamxprefix", "flow_index", "stream_instance", "streamxnumber", "track_index", "streamingprefix", " stream_prefix", "track_position", "flow_address", "streamingind", "pipeflowtarget", "stream_num", "streamflowindex", "flow_target", "track_ind", "track_key", "stream_conn", "pipe_num", "tracksinstance", "record_loc", "streamerindex", "stream_target", "streamflownum", "record_index", "streamingnumber", "tracksindex", "stream_loc", "flow_key", "stream_address", "pipeflowind", "record_id", "trackskey", "streamertarget", "stream_number", "stream_id", "streamerind", "pipeflownum", "streamflowtarget", "stream_prefix", " stream_number", "stream_position", "streamernum", "pipe_ind", "track_instance", "streamflowind", "stream_key", "pipeflowindex", "pipe_index", "streamxindex"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "void ff_vp56_init_range_decoder(VP56RangeCoder *c, const uint8_t *buf, int buf_size)\n\n{\n\n    c->high = 255;\n\n    c->bits = -16;\n\n    c->buffer = buf;\n\n    c->end = buf + buf_size;\n\n    c->code_word = bytestream_get_be24(&c->buffer);\n\n}\n", "idx": 17413, "substitutes": {"c": ["pc", "dc", "ic", "oc", "m", "ch", "t", "f", "call", "cus", "ct", "vc", "rc", "gc", "cm", "n", "cf", "g", "i", "ctx", "fc", "mc", "cy", "o", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "tc", "xc", "con", "e", "cu", "sc", "cr", "v", "lc", "cur", "p", "b", "cache", "ec", "unc", "C", "cc", "u"], "buf": ["Buffer", "ab", "bin", "br", "data", "fp", "text", "ref", "dest", "pool", "buffer", "rc", "vec", "feed", "cf", "num", "sb", "cb", "bc", "src", "cp", "wb", "padding", "pb", "bb", "count", "xff", "home", "gb", "array", "box", "img", "queue", "bd", "length", "utf", "fd", "buff", "batch", "fb", "cur", "rb", "seq", "uc", "binary", "cache", "b", "alloc", "port", "uf", "cv"], "buf_size": ["queue_low", "buf__size", "buf_len", "queue_len", "queue_size", "buf__low", " buf_len", "buf_sum", " buf_sum", "buf_low", "buf__len"]}}
{"project": "qemu", "commit_id": "f897bf751fbd95e4015b95d202c706548586813a", "target": 1, "func": "int vring_pop(VirtIODevice *vdev, Vring *vring,\n\n              VirtQueueElement **p_elem)\n\n{\n\n    struct vring_desc desc;\n\n    unsigned int i, head, found = 0, num = vring->vr.num;\n\n    uint16_t avail_idx, last_avail_idx;\n\n    VirtQueueElement *elem = NULL;\n\n    int ret;\n\n\n\n    /* If there was a fatal error then refuse operation */\n\n    if (vring->broken) {\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* Check it isn't doing very strange things with descriptor numbers. */\n\n    last_avail_idx = vring->last_avail_idx;\n\n    avail_idx = vring->vr.avail->idx;\n\n    barrier(); /* load indices now and not again later */\n\n\n\n    if (unlikely((uint16_t)(avail_idx - last_avail_idx) > num)) {\n\n        error_report(\"Guest moved used index from %u to %u\",\n\n                     last_avail_idx, avail_idx);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    /* If there's nothing new since last we looked. */\n\n    if (avail_idx == last_avail_idx) {\n\n        ret = -EAGAIN;\n\n        goto out;\n\n    }\n\n\n\n    /* Only get avail ring entries after they have been exposed by guest. */\n\n    smp_rmb();\n\n\n\n    /* Grab the next descriptor number they're advertising, and increment\n\n     * the index we've seen. */\n\n    head = vring->vr.avail->ring[last_avail_idx % num];\n\n\n\n    elem = g_slice_new(VirtQueueElement);\n\n    elem->index = head;\n\n    elem->in_num = elem->out_num = 0;\n\n    \n\n    /* If their number is silly, that's an error. */\n\n    if (unlikely(head >= num)) {\n\n        error_report(\"Guest says index %u > %u is available\", head, num);\n\n        ret = -EFAULT;\n\n        goto out;\n\n    }\n\n\n\n    if (vdev->guest_features & (1 << VIRTIO_RING_F_EVENT_IDX)) {\n\n        vring_avail_event(&vring->vr) = vring->vr.avail->idx;\n\n    }\n\n\n\n    i = head;\n\n    do {\n\n        if (unlikely(i >= num)) {\n\n            error_report(\"Desc index is %u > %u, head = %u\", i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        if (unlikely(++found > num)) {\n\n            error_report(\"Loop detected: last one at %u vq size %u head %u\",\n\n                         i, num, head);\n\n            ret = -EFAULT;\n\n            goto out;\n\n        }\n\n        desc = vring->vr.desc[i];\n\n\n\n        /* Ensure descriptor is loaded before accessing fields */\n\n        barrier();\n\n\n\n        if (desc.flags & VRING_DESC_F_INDIRECT) {\n\n            ret = get_indirect(vring, elem, &desc);\n\n            if (ret < 0) {\n\n                goto out;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        ret = get_desc(vring, elem, &desc);\n\n        if (ret < 0) {\n\n            goto out;\n\n        }\n\n\n\n        i = desc.next;\n\n    } while (desc.flags & VRING_DESC_F_NEXT);\n\n\n\n    /* On success, increment avail index. */\n\n    vring->last_avail_idx++;\n\n    *p_elem = elem;\n\n    return head;\n\n\n\nout:\n\n    assert(ret < 0);\n\n    if (ret == -EFAULT) {\n\n        vring->broken = true;\n\n    }\n\n    if (elem) {\n\n        vring_unmap_element(elem);\n\n        g_slice_free(VirtQueueElement, elem);\n\n    }\n\n    *p_elem = NULL;\n\n    return ret;\n\n}\n", "idx": 17428, "substitutes": {"vdev": ["ldev", "evbus", " vde", "lcam", " vpack", "vde", "gcam", "lpack", "hbus", "hdevice", "evdevice", "gpack", "vcam", " vdevice", " vcam", "evdev", "ldevice", "hde", " vbus", "vdevice", "vbus", "evde", "gdevice", "vpack", "hdev", "gdev"], "vring": ["vtesting", "psetting", "avray", " vringe", "flling", "plic", "varding", "lping", " vlic", "avring", "svray", "svping", "avding", "gstring", "varring", "avping", "vlic", " vining", "Vstring", " vsetting", "evray", "avining", "lrings", "evding", "svtesting", "gray", "Vsetting", "gping", "pping", "evling", "Vring", "varringe", "Vtesting", "vling", "lstring", "flray", "flring", "evring", "lding", "varining", "pray", "flding", "lsetting", "grings", "vringe", "vding", "vining", "Vray", "avtesting", "Vping", "pring", " vstring", "lray", " vping", "pding", "svring", "vrings", "vsetting", "Vlic", "avringe", " vrings", "lring", " vray", "gring", "vray", " vding", "gding", "lling", "vping", "vstring"], "p_elem": ["p_eelev", "p_eelement", "p_belem", "p_eelem", "p_element", "p_belements", "p_selev", "p_eelements", "p_elev", "p_elements", "p_selement", "p_belement", "p_selem", "p_belev", "p_selements"], "desc": ["entry", "dc", "code", "text", "info", "esc", "name", "dep", "dir", "obj", "dest", "comment", "child", "rc", "reg", "de", "loc", "src", "sel", "ext", "des", "ind", "def", "description", "rec", "class", "Description", "summary", "disc", "sub", "config", "prev", "sc", "id", "rev", "oe", "req", "seq", "meta", "Desc", "doc", "sum", "dist", "next", "ec", "ript", "end", "diff", "dict", "cv", "asc"], "i": ["uri", "bi", "j", "t", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "io", "phi", "num", "hi", "type", "ii", "in", "ie", "iu", "index", "ind", "di", "I", "multi", "zi", "ip", "l", "d", "yi", "pi", "ui", "ci", "id", "start", "e", "c", "ni", "si", "ri", "p", "xi", "b", "eni", "fi", "y", "li", "u"], "head": ["set", "dc", "init", "view", "rest", "name", "x", "call", "ix", "commit", "push", "f", "Head", "du", "rc", "thread", "n", "then", "inc", "num", "root", "block", "max", "in", "index", "pos", "run", "ind", "count", "ack", "load", "header", "HEAD", "back", "length", "id", "start", "front", "client", "fix", "cur", "c", "post", "position", "off", "doc", "ck", "none", "depth", "gen", "check", "tail", "h", "heads", "row", "form", "find", "body", "end", "us", "before", "miss", "reason", "inner", "mm", "conn", "target", "input"], "avail_idx": ["avail_endX", "avail_endxs", "avail_endx", "avail_countpe", "avail_IdX", "avail_midy", "avail_idxs", "avail_ipy", "avail_timexx", "avail_idsX", "avail_Idx", "avail_idex", "avail_idpe", "avail_idxc", "avail_idxx", "avail_Idy", "avail_idX", "avail_ipx", "avail_Idpe", "avail_endy", "avail_midx", "avail_countz", "avail_idsxc", "avail_countX", "avail_idec", "avail_idexc", "avail_idsx", "avail_Idz", "avail_endz", "avail_idsc", "avail_endc", "avail_Idc", "avail_endxx", "avail_timexs", "avail_midxx", "avail_timey", "avail_countx", "avail_idc", "avail_timex", "avail_ipz", "avail_idz", "avail_midxs", "avail_ideX", "avail_ipX", "avail_idy"], "last_avail_idx": ["last_avail_idc", "last_avail_idex", "last_avail_Idz", "last_avail_Idx", "last_avail_idz", "last_avail_idew", "last_avail_inz", "last_avail_endz", "last_avail_ideX", "last_avail_Idc", "last_avail_Idy", "last_avail_idy", "last_avail_endc", "last_avail_idec", "last_avail_idX", "last_avail_inw", "last_avail_idez", "last_avail_endy", "last_avail_endX", "last_avail_IdX", "last_avail_idey", "last_avail_idw", "last_avail_iny", "last_avail_endx", "last_avail_inx", "last_avail_inc", "last_avail_inX"], "elem": ["Elev", "selee", "selev", "elev", "jelegate", "nelee", "gelement", " eleg", " elee", "element", "Elem", "Eli", "nelement", "nelev", "geject", "elde", "aelem", "oeject", "eler", "Eleg", "Element", "oelem", "jeler", " elev", "seject", "gelem", "elegate", " eject", " eler", "jelem", "eli", "seli", "selem", "aelev", "oelee", "seleg", "Elee", " elegate", " elde", "oelement", "eleg", " eli", "oeler", "aeject", "elee", "aelement", "gelev", "selement", "eject", "selde", "jeject", "oelde", "nelem", "oelegate", " element"], "ret": ["part", "info", "fat", "bit", "ref", "alt", "ct", "let", "conn", "reg", "rc", "lit", "nt", "fun", "rt", "result", "num", "vet", "match", "ut", "pass", "fin", "mem", "resp", "rets", "def", "lt", "art", "att", "arg", "val", "re", "Ret", "feat", "det", "fit", "rev", "cat", "req", "gt", "RET", "red", "res", "opt", "mt", "ft", "pt", "success", "len"], "found": ["f", "search", "fe", "confirmed", "inc", "current", "loc", "given", "Found", "finder", "index", "done", "pos", "count", "loaded", "old", "new", "defined", "first", "length", "seen", "received", "fd", "front", "finding", "used", "sent", "expected", "missing", "failed", "find", "number", "lost", "iter", "fi", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "bc29acdc76fdbf70700cdc2f85fc2afb46e19e47", "target": 0, "func": "static int ftp_connect_control_connection(URLContext *h)\n\n{\n\n    char buf[CONTROL_BUFFER_SIZE], opts_format[20];\n\n    int err;\n\n    AVDictionary *opts = NULL;\n\n    FTPContext *s = h->priv_data;\n\n    const int connect_codes[] = {220, 0};\n\n\n\n    s->conn_control_block_flag = 0;\n\n\n\n    if (!s->conn_control) {\n\n        ff_url_join(buf, sizeof(buf), \"tcp\", NULL,\n\n                    s->hostname, s->server_control_port, NULL);\n\n        if (s->rw_timeout != -1) {\n\n            snprintf(opts_format, sizeof(opts_format), \"%d\", s->rw_timeout);\n\n            av_dict_set(&opts, \"timeout\", opts_format, 0);\n\n        } /* if option is not given, don't pass it and let tcp use its own default */\n\n        err = ffurl_open(&s->conn_control, buf, AVIO_FLAG_READ_WRITE,\n\n                         &s->conn_control_interrupt_cb, &opts);\n\n        av_dict_free(&opts);\n\n        if (err < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"Cannot open control connection\\n\");\n\n            return err;\n\n        }\n\n\n\n        /* consume all messages from server */\n\n        if (!ftp_status(s, NULL, connect_codes)) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP server not ready for new users\\n\");\n\n            err = AVERROR(EACCES);\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_auth(s)) < 0) {\n\n            av_log(h, AV_LOG_ERROR, \"FTP authentication failed\\n\");\n\n            return err;\n\n        }\n\n\n\n        if ((err = ftp_type(s)) < 0) {\n\n            av_dlog(h, \"Set content type failed\\n\");\n\n            return err;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17439, "substitutes": {"h": ["m", "t", "eh", "f", "oh", "hr", "r", "dh", "gh", "g", "hi", "hd", "rh", "th", "uh", "o", "home", "host", "l", "d", "hw", "ht", "kh", "him", "sh", "w", "hl", "q", "e", "handler", "bh", "k", "ih", "v", "c", "history", "hp", "p", "hm", "b", "http", "hh", "ph", "ha", "hs", "he", "hand", "ah", "H", "u"], "buf": ["Buffer", "ab", "br", "ff", "func", "text", "data", "fp", "buffer", "rc", "vec", "fun", "cb", "block", "bc", "loc", "msg", "raw", "src", "wb", "pb", "ctx", "lb", "prop", "array", "conv", "pkg", "path", "bf", "box", "img", "queue", "config", "fd", "buff", "fb", "bh", "batch", "v", "rb", "seq", "cmd", "uc", "off", "pad", "tmp", "binary", "b", "la", " buffer", "addr", "port", "bag", "uf", "cv"], "opts_format": ["opcs_Format", "opts_type", "opt_type", "opts_form", "opts_printf", "opt_format", "opts_Format", "opt_space", "opts_length", "opters_form", "optr_format", "optr_form", "opts_space", "opters_format", "opcs_format", "optr_function", "opts_function", "opters_length", "opcs_printf"], "err": ["user", "result", "str", "num", "ar", "late", "far", "nor", "var", " self", " error", "ev", "id", "lr", "temp", "test", "fy", "gr", "len", "reader", "content", "orer", "more", "msg", "resp", "der", "count", "magic", "kr", "arr", "orr", "mr", "rag", "cr", "acer", "dev", "ir", "off", "pr", "ec", "iter", "order", "ver", " len", "ner", "code", "runner", "r", " Err", "try", "icer", "or", "type", "rh", "loc", "orig", "ind", "ise", "ee", "val", "erer", "later", " result", "nr", "go", "yr", "doc", "fee", " rc", "Er", "er", "Error", "ah", "bug", "rr", "hide", "her", "aster", "notice", "ler", "dr", "e", "req", "url", "error", " resp", "message", "server", "inner", "attr"], "opts": [" copt", "opttd", "otts", "opter", " opters", "OPtd", "roptd", "OPts", "OPt", "optd", "ropts", "opert", " copts", "opters", "ops", "OPtr", "ropt", "opcs", "opls", " copls", "operters", "optts", "optr", "ott", "operts", "optls", "ottr", "OPters", "otcs", "rops", " copters", "optters", " opls", " opt", "optcs", "OPs", "optter", "opttr", "optt", "opt", "OPter", "OPcs", "operter"], "s": ["ns", "spec", "m", "sg", "j", "t", "rs", "stats", "aws", "f", "conf", "x", "settings", "services", "service", "r", "n", "sb", "g", "i", "sl", "ss", "ls", "ops", "ctx", "fs", "xs", "self", "is", "o", "home", "cs", "l", "d", "su", "sh", "ssh", "args", "site", "w", "qs", "e", "ssl", "ses", "sync", "v", "c", "ps", "si", "js", "sym", "p", "S", "b", "http", "gs", "sys", "a", "es", "os", "us", "sets", "sq", "an", "y", "ds"], "connect_codes": ["conn_status", "connectionchains", "connectallids", "conn_chains", "conn_code", "conn_errors", "connect_errors", "conn_ids", "connect_code", "connectioncode", "connectallcodes", "connectallstatus", "connect_ids", "connectioncodes", "conn_codes", "connectallcode", "connect_chains", "connect_status", "connectionerrors"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449, "substitutes": {"dev": ["grad", "Dev", "dd", "mod", "gd", "info", "conf", "pub", "comment", "engine", "gu", "debug", "de", "rad", "app", "var", "di", "mem", "def", "enc", "d", "hw", "adv", "w", "ev", "ad", "img", "cam", "temp", "device", "driver", "test", "plug", "pad", "error", "dem", "priv", "DEV", "end", "valid", "die", "diff", "bus", "ver", "bug"], "data": ["Data", "offset", "reader", "base", "buffer", "window", "src", "index", "pos", "def", "arr", "d", "val", "empty", "read", "size", "zero", "img", "ad", "start", "parent", "device", "da", "shift", "address", "pad", "cache", "dat", "next", "a", "DATA", "addr", "bytes", "bus", "input"], "buf": ["db", "ff", "fp", "func", "base", "ref", "lim", "buffer", "vec", "window", "cb", "bc", "src", "loc", "orig", "ctx", "raw", "lb", "mem", "bound", "aux", "length", "queue", "config", "fd", "buff", "batch", "v", "rb", "seq", "cmd", "off", "b", "cap", "alloc", "bytes", "addr", "bag", "uf"], "len": ["bin", "offset", "ff", "lim", "base", "name", "f", "all", "nt", "n", "fun", "num", "str", "block", "z", "fin", "pos", "ind", "mem", "en", "enc", "lf", "ln", "l", "val", "fl", "size", "length", "fd", "cl", "seq", "off", "line", "lan", "cap", "fn", "la", "addr", "el", "Len"]}}
{"project": "FFmpeg", "commit_id": "cf1e0786ed64e69614760bfb4ecd7adbde8e6094", "target": 0, "func": "static int is_intra_more_likely(ERContext *s)\n\n{\n\n    int is_intra_likely, i, j, undamaged_count, skip_amount, mb_x, mb_y;\n\n\n\n    if (!s->last_pic.f || !s->last_pic.f->data[0])\n\n        return 1; // no previous frame available -> use spatial prediction\n\n\n\n    undamaged_count = 0;\n\n    for (i = 0; i < s->mb_num; i++) {\n\n        const int mb_xy = s->mb_index2xy[i];\n\n        const int error = s->error_status_table[mb_xy];\n\n        if (!((error & ER_DC_ERROR) && (error & ER_MV_ERROR)))\n\n            undamaged_count++;\n\n    }\n\n\n\n    if (s->avctx->codec_id == AV_CODEC_ID_H264 && s->ref_count <= 0)\n\n        return 1;\n\n\n\n    if (undamaged_count < 5)\n\n        return 0; // almost all MBs damaged -> use temporal prediction\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    // prevent dsp.sad() check, that requires access to the image\n\n    if (CONFIG_MPEG_XVMC_DECODER    &&\n\n        s->avctx->xvmc_acceleration &&\n\n        s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I)\n\n        return 1;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    skip_amount     = FFMAX(undamaged_count / 50, 1); // check only up to 50 MBs\n\n    is_intra_likely = 0;\n\n\n\n    j = 0;\n\n    for (mb_y = 0; mb_y < s->mb_height - 1; mb_y++) {\n\n        for (mb_x = 0; mb_x < s->mb_width; mb_x++) {\n\n            int error;\n\n            const int mb_xy = mb_x + mb_y * s->mb_stride;\n\n\n\n            error = s->error_status_table[mb_xy];\n\n            if ((error & ER_DC_ERROR) && (error & ER_MV_ERROR))\n\n                continue; // skip damaged\n\n\n\n            j++;\n\n            // skip a few to speed things up\n\n            if ((j % skip_amount) != 0)\n\n                continue;\n\n\n\n            if (s->cur_pic.f->pict_type == AV_PICTURE_TYPE_I) {\n\n                int *linesize = s->cur_pic.f->linesize;\n\n                uint8_t *mb_ptr      = s->cur_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n                uint8_t *last_mb_ptr = s->last_pic.f->data[0] +\n\n                                       mb_x * 16 + mb_y * 16 * linesize[0];\n\n\n\n                if (s->avctx->codec_id == AV_CODEC_ID_H264) {\n\n                    // FIXME\n\n                } else {\n\n                    ff_thread_await_progress(s->last_pic.tf, mb_y, 0);\n\n                }\n\n                is_intra_likely += s->mecc->sad[0](NULL, last_mb_ptr, mb_ptr,\n\n                                                   linesize[0], 16);\n\n                is_intra_likely -= s->mecc->sad[0](NULL, last_mb_ptr,\n\n                                                   last_mb_ptr + linesize[0] * 16,\n\n                                                   linesize[0], 16);\n\n            } else {\n\n                if (IS_INTRA(s->cur_pic.mb_type[mb_xy]))\n\n                   is_intra_likely++;\n\n                else\n\n                   is_intra_likely--;\n\n            }\n\n        }\n\n    }\n\n    return is_intra_likely > 0;\n\n}\n", "idx": 17452, "substitutes": {"s": ["ns", "spec", "m", "sup", "ts", "sg", "session", "stats", "rs", "t", "conf", "f", "sv", "settings", "services", "aws", "service", "r", "n", "sb", "g", "ss", "ls", "ops", "this", "fs", "self", "xs", "is", "o", "cs", "als", "l", "su", "ins", "site", "qs", "e", "ssl", "vs", "ses", "sync", "js", "ps", "si", "c", "sym", "p", "secondary", "S", "uses", "ks", "http", "b", "gs", "sys", "its", "es", "os", "hs", "us", "sets", "comments", "sq", "se", "ds", "sf"], "is_intra_likely": ["is_intras_available", "is_intra_large", "is_intra_available", "is_intras_like", "is_intras_certain", "is_intra_certain", "is_intra_recent", "is_intras_likely", "is_intras_large", "is_intras_recent", "is_intra_like"], "i": ["gi", "ti", "uri", "m", "bi", "ik", "ji", "ami", "info", "x", "f", "jit", "ix", "ini", "qi", "ai", "mi", "n", "io", "z", "ii", "ori", "ie", "iu", "di", "mini", "ski", "I", "index", "multi", "zi", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "key", "k", "e", "v", "ih", "ni", "si", "ki", "ri", "p", "xi", "b", "eni", "fi", "y", "li", "u"], "j": ["jo", "jc", "m", "br", "ji", "ch", "jl", "offset", "obj", "jp", "f", "jit", "uj", "bj", "note", "adj", "n", "jj", "job", "num", "z", "ii", "ij", "ie", "jet", "index", "ind", "aj", "dj", "count", "jump", "o", "l", "d", "w", "J", "key", "k", "q", "kj", "bl", "v", "span", "si", "p", "shift", "b", "h", "ja", "im", "it", "section", "y", "li"], "undamaged_count": ["undamamped_count", "undamaged_counter", "undamamped64count", "undamaged64counter", "undamaged__size", "undamamped64length", "undamagedqcounter", "undamaged64count", "undamaged_sum", "undamaded_limit", "undamaged__length", "undamaded_count", "undamaging_weight", "undamaged_cache", "undamagedqtime", "undamaged64length", "undamaged___count", "undamaged_weight", "undamaged_ind", "undamaged_time", "undamamped_length", "undamaged64weight", "undamagededcount", "undamaging_time", "undamagededtime", "undamaged_length", "undamaged__cache", "undamage_length", "undamaged___ind", "undamadedqlimit", "undamagedqweight", "undamaged_limit", "undamadedqcounter", "undamaging_sum", "undamaging_count", "undamagededweight", "undamaged_size", "undamaged__weight", "undamagedqlimit", "undamaging_ind", "undamaged___sum", "undamamped64size", "undamadedqcount", "undamaded_counter", "undamagedqcount", "undamamped_weight", "undamage_cache", "undamaged64limit", "undamamped_size", "undamaged__count", "undamaged64size", "undamamped64weight", "undamage_count"], "skip_amount": [" skip_factor", "skip___amount", " skip_number", "skip2factor", " skip_portion", "skip_factor", "skip___money", "skipingfactor", "skip2number", "skip_portion", "skip_number", "skip_money", "skip2amount", "skip2length", "skip2Amount", " skip_money", "skipingamount", "skip___portion", " skip_Amount", "skip___Amount", "skipingAmount", "skip_length", "skip_frequency", " skip_frequency", "skip_Amount", " skip_length", "skipinglength", "skip2frequency"], "mb_x": ["mp_wy", "mb_name", "mb_cy", "bb_x", "mb9cy", "MB_name", "mp_y", "mc_index", "mb_wy", "mb6x", "bb_ya", "mp_h", "mb33name", "bb_y", "mb_xy", "mb_h", "mb33y", "mb9y", "mb6num", "mb_yk", "mb33cy", "mc6num", "mbPx", "MB_cy", "mc_xy", "mp_xy", "mb_xi", "mp_xi", "mc_x", "mb6xy", "bb_wy", "mbPxy", "mb_ya", "MB_x", "mb_num", "mp_x", "MB_y", "mb_index", "mb33x", "mb6index", "mc6x", "mc6xy", "mbPwy", "mc6index", "mc_num", "mb9x", "mb9name", "mbPxi", "mp_yk"], "mb_y": ["mb__y", "mb__wy", "mp_wy", "mb_dy", "mp_zy", "mb_hy", "mp_y", "mb_wy", "MB_height", "mp_hy", "mb_zy", "mb_xy", "mb__z", "mb67y", "mb__xy", "mb67x", "mb67z", "mp_xy", "mp_dy", "MB_z", "mb67height", "MB_x", "mp_z", "mb_z", "mp_asy", "mp_x", "MB_y", "mb_height", "mp_yl", "mb_yl", "mb_asy"], "AV_PICTURE_TYPE_I": ["AV_PICTURE_TYPE_II", "AV_PICTURE_MODE_NI", "AV_PICTURE_TYPE_IJ", "AV_PICTURE_Type_IJ", "AV_PICTURE_Type_I", "AV_PICTURE_Type_II", "AV_PICTURE_TYPE_INT", "AV_PICTURE_MODE_I", "AV_PICTURE_MODE_INT", "AV_PICTURE_Type_N", "AV_PICTURE_TYPE_NI", "AV_PICTURE_TYPE_N", "AV_PICTURE_MODE_II"], "error": ["ror", "rr", "rage", "extra", "code", "data", "info", "element", "err", "attribute", "comment", "image", "op", "call", "f", "name", "debug", "result", "query", "root", "block", "type", "node", "ception", "slice", "user", "active", "magic", "ise", "date", "ee", "object", " Error", "ack", "layer", "original", "ERROR", "grade", "complete", "event", "no", "back", "key", "id", "e", "danger", "patch", "line", "p", "none", "missing", "resource", "route", "errors", "number", "serial", "message", "connection", "valid", "server", "callback", "Error", "order", "operator", "success", "warning", "bug"], "linesize": [" linesz", " linesiz", "linesz", "pointsscale", "pointsiz", "pointssize", " linescale", "pagesize", "pagescale", "linessize", "inssize", "pointsize", " linesscale", "inscale", "insize", "linescale", "insz", " linessize", "lineiz", "pagesz", "pagessize", "lineize", "linesiz", "linesscale"]}}
{"project": "FFmpeg", "commit_id": "4d321bff85cf1e9b6a18b915af185494b5ea94b6", "target": 1, "func": "void Release(void *ctx)\n\n{\n\n    ContextInfo *ci;\n\n    ci = (ContextInfo *) ctx;\n\n\n\n    if (ci->cache) {\n\n        imlib_context_set_image(ci->cache->image);\n\n        imlib_free_image();\n\n        av_free(ci->cache);\n\n    }\n\n    if (ctx) {\n\n        if (ci->imageOverlaid) {\n\n            imlib_context_set_image(ci->imageOverlaid);\n\n            imlib_free_image();\n\n        }\n\n        ff_eval_free(ci->expr_x);\n\n        ff_eval_free(ci->expr_y);\n\n        ff_eval_free(ci->expr_R);\n\n        ff_eval_free(ci->expr_G);\n\n        ff_eval_free(ci->expr_B);\n\n        sws_freeContext(ci->toRGB_convert_ctx);\n\n        sws_freeContext(ci->fromRGB_convert_ctx);\n\n        av_free(ctx);\n\n    }\n\n}\n", "idx": 17480, "substitutes": {"ctx": ["pc", "fw", "fp", "x", "cca", "jp", "cus", "ct", "vc", "conn", "rc", "cm", "cf", "cb", "anc", "cp", "bc", "loc", "src", "fc", "mc", "cas", "Context", "ca", "cs", "context", "qu", "pkg", "tx", "tc", "xc", "config", "cu", "sync", "cli", "lc", "c", "parent", "qa", "sci", "cmp", "unc", "cn", "co", "cv", "cc", "cci"], "ci": ["ic", "pc", "uri", "jc", "reci", "cca", "cor", "cus", "vc", "uci", "ini", "conn", "qi", "coe", "CI", "ai", "ct", "cm", "osi", "cf", "ani", "i", "cp", "cod", "loc", "ii", "di", "li", "zi", "cy", "ca", "ce", "pi", "ui", "oci", "aci", "config", "sc", "cu", "cli", "lc", "c", "ni", "si", "ki", "isi", "xi", "cia", "ku", "sci", "que", "cache", "cit", "odi", "cgi", "eni", "co", "cc", "cci"]}}
{"project": "qemu", "commit_id": "6e5d97d01d9da6f295f9888d4b34e29fd737861a", "target": 1, "func": "void qemu_aio_flush(void)\n\n{\n\n    AioHandler *node;\n\n    int ret;\n\n\n\n    do {\n\n        ret = 0;\n\n\n\n\t/*\n\n\t * If there are pending emulated aio start them now so flush\n\n\t * will be able to return 1.\n\n\t */\n\n        qemu_aio_wait();\n\n\n\n        LIST_FOREACH(node, &aio_handlers, node) {\n\n            ret |= node->io_flush(node->opaque);\n\n        }\n\n    } while (ret > 0);\n\n}\n", "idx": 17482, "substitutes": {"node": ["native", "tree", "Node", "content", "cdn", "child", "core", "name", "call", "ref", "annot", "op", "n", "worker", "result", "hop", "num", "document", "root", "block", "master", "holder", "function", "this", "tag", "self", "object", "anch", "enc", "load", "nm", "host", "path", "event", "id", "remote", "handler", "open", "parent", "nw", "post", "slave", "none", "missing", "od", "null", "gen", "route", "fn", "wrapper", "live", "nn", "edge", "valid", "server", "inner", "source", "outer", "target"], "ret": ["part", "code", "data", "obj", "bit", "ref", "alt", "lit", "nt", "rt", "fun", "result", "num", "wait", "flag", "type", "match", "pass", "ext", "en", "rets", "lt", "out", "art", "att", "arg", "flat", "val", "re", "Ret", " RET", "rot", "id", "det", "sr", "ait", "rb", "gt", "RET", "pat", "pet", "res", "opt", "mt", "iter", "valid", "ft", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513, "substitutes": {"s": ["m", "session", "settings", "services", "service", "r", "sb", "ss", "ops", "cs", "bis", "sac", "sc", "ssl", "e", "fts", "ses", "c", "ps", "p", "b", "params", "sys", "os", "sets", "sq", "sa", "sf"], "pb": ["pc", "wp", "ab", "fp", "vp", "pd", "pl", "pm", "sb", "bp", "cpp", "cp", "bc", "lp", "PC", "wb", "abc", "PB", " p", "bps", "pa", "bh", "fb", "rb", "p", "ppa", "proc", "ub"], "in": ["m", "bin", "IN", "data", "x", "f", "image", "ref", "r", "inc", "query", "In", "min", "d", "inf", "ins", "id", "c", "p", "a", "inner", "source", "input"], "out": ["at", "part", "m", "point", "group", "work", "extra", "init", "data", "name", "image", "err", "bit", "call", "plus", "scroll", "r", "io", "inc", "result", "option", "Out", "query", "block", "raw", "pass", "index", "timeout", "password", "copy", "object", "o", "again", "flat", "array", "up", "new", "outs", "no", "hidden", "w", "prefix", "sync", "only", "update", "parent", "post", "p", "binary", "line", "off", "OUT", "b", "cache", "output", "error", "check", "project", "into", "word", "one", "inner", "source", "params", "outer", "wave"], "scaled": ["scased", " scaling", "shaling", "scitched", "escitched", "shaled", "escaling", "escased", "shased", "escaled", " scased", "shitched", " scitched", "scaling"], "size": ["scale", "shape", "code", "small", "mode", "SIZE", "name", "capacity", "time", "cm", "six", "loc", "resolution", "sec", "large", "ize", "sc", "c", "unit", "si", "crop", "shift", "address", "norm", "weight", "Size", "len"], "scale_idx": ["scale_indxs", "scale_ridx", "scale_indx", "scale_Idxs", "scale_Idg", "scale_Idr", "scale_idg", "scale_ridg", "scale_Idx", "scale_idr", "scale_indr", "scale_indg", "scale_idxs", "scale_ridr", "scale_ridxs"], "cb": ["dc", "code", "core", "ctr", "ref", "buffer", "rc", "confirmed", "cf", "bc", "quad", "bb", "nb", " bc", "cond", "nc", "bf", "blocks", "batch", "cl", "b", "fn", "cd", "loop", "repeat", "callback", "CB", "circ", "cc"], "lambda": ["LA", "dc", "func", "fun", "phi", "lu", "mega", "phase", "function", "abc", "appa", "std", "partial", "cl", "lam", "inv", "da", "shift", "pad", "la", " lam", "wa", "beta", "pha", "alpha", " omega", "mu"], "uplim": ["Uplime", "uselime", "uflims", "Uflime", "uplig", "Uplim", "Uflig", "uselims", "uclig", "uclims", "uplime", "uflig", "Uflims", "uflime", "uselim", "Uflim", "uplims", "uselig", "Uplims", "uflim", "uclime", "uclim", "Uplig"], "bits": ["ns", "bugs", "cycles", "planes", "fps", "bs", "pieces", "jobs", "bit", "settings", "weights", "plugins", "dates", "details", "forces", "ips", "ints", "ops", "pos", "offs", "ins", "outs", "gets", "features", "blocks", "bis", "codes", "pins", "batch", "frames", "steps", "acts", "bands", "rows", "b", "hours", "lins", "its", "reads", "bytes", "parts", "groups", "flags", "locks"], "ROUNDING": ["RANGED", "WRECTING", "RANGLESS", "RRECTLESS", "RRECTATING", "RoundingING", "WOUNDLESS", "ROUNDED", "ROUNDATING", "RoundingED", "WOUNDING", "RoundingLESS", "ROUNDLESS", "RANGATING", "RRECTED", "RANGING", "RRECTING", "WRECTATING", "WRECTED", "WRECTLESS", "WOUNDED", "RoundingATING", "WOUNDATING"], "i": ["gi", "ti", "at", "uri", "bi", "iii", "init", "j", "t", "data", "info", "x", "f", "base", "ix", "ini", "qi", "io", "ai", "n", "phi", "ii", "ie", "di", "slice", "ind", "pass", "I", "zi", "is", "o", "ip", "l", "d", "oi", "diff", "pi", "uni", "ui", "ci", "abi", "last", "id", "e", "cli", "v", "c", "ni", "si", "temp", "p", "xi", "b", "uli", "interface", "a", "api", "list", "it", "fi", "inner", "li", "u"]}}
{"project": "qemu", "commit_id": "dbb7405d8caad0814ceddd568cb49f163a847561", "target": 1, "func": "static int xen_platform_initfn(PCIDevice *dev)\n{\n    PCIXenPlatformState *d = XEN_PLATFORM(dev);\n    uint8_t *pci_conf;\n    pci_conf = dev->config;\n    pci_set_word(pci_conf + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY);\n    pci_config_set_prog_interface(pci_conf, 0);\n    pci_conf[PCI_INTERRUPT_PIN] = 1;\n    platform_ioport_bar_setup(d);\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &d->bar);\n    /* reserve 16MB mmio address for share memory*/\n    platform_mmio_setup(d);\n    pci_register_bar(dev, 1, PCI_BASE_ADDRESS_MEM_PREFETCH,\n                     &d->mmio_bar);\n    platform_fixed_ioport_init(d);\n    return 0;\n}", "idx": 17518, "substitutes": {"dev": ["dc", "grad", "Dev", "dn", "dd", "mod", "ch", "data", "gd", "info", "conf", "comment", "conn", "md", "r", "debug", "de", "rad", "devices", "app", "nov", "var", "dim", "development", "der", "def", "self", "adv", "ev", "dm", "ad", "ga", "cam", "dom", "device", "driver", "p", "error", "dem", "priv", "DEV", "serial", "die", "diff", "ve", "ver", "bug"], "d": ["dc", "grad", "m", "dn", "dd", "db", "s", "nd", "t", "mod", "gd", "f", "td", "md", "r", "debug", "de", "pd", "n", "dh", "g", "i", "rad", "dt", "di", "ld", "dl", "done", "sd", "l", "draw", "dy", "w", "bd", "dm", "ad", "e", "fd", "dr", "id", "v", "c", "dom", "device", "D", "p", "ded", "driver", "da", "b", "od", "dat", "cd", "dad", "die", "diff", "ds"], "pci_conf": ["pdi_config", "pcifConf", "pci2config", "pcm_conf", "pci2cfg", "pcifconfig", "pcu_Conf", "pcm_com", "pcm_Conf", "pdi_cfg", "pci_conn", "pca_conn", "pcu_conf", "pcu_cfg", "pci_config", "pcifcom", "pca_cfg", "pcu_config", "pcm_config", "pcu_con", "pca_config", "pci_Conf", "pca_conf", "pci_com", "pci2conn", "pcu_conn", "pci2conf", "pdi_conf", "pci_cfg", "pcifconf", "pci_con"]}}
{"project": "FFmpeg", "commit_id": "b6db385922b79939b0dc124d53ddb4824afac040", "target": 0, "func": "static void mmap_release_buffer(AVPacket *pkt)\n\n{\n\n    struct v4l2_buffer buf;\n\n    int res, fd;\n\n    struct buff_data *buf_descriptor = pkt->priv;\n\n\n\n    if (pkt->data == NULL)\n\n        return;\n\n\n\n    memset(&buf, 0, sizeof(struct v4l2_buffer));\n\n    buf.type = V4L2_BUF_TYPE_VIDEO_CAPTURE;\n\n    buf.memory = V4L2_MEMORY_MMAP;\n\n    buf.index = buf_descriptor->index;\n\n    fd = buf_descriptor->fd;\n\n    av_free(buf_descriptor);\n\n\n\n    res = ioctl(fd, VIDIOC_QBUF, &buf);\n\n    if (res < 0)\n\n        av_log(NULL, AV_LOG_ERROR, \"ioctl(VIDIOC_QBUF): %s\\n\",\n\n               strerror(errno));\n\n\n\n    pkt->data = NULL;\n\n    pkt->size = 0;\n\n}\n", "idx": 17534, "substitutes": {"pkt": ["tkg", "tacket", "fkt", "gpkt", "ppkg", "packer", "gpacket", "Packet", "tkt", "ppct", " pct", "packet", "Pcht", " packet", "ppkt", "pwk", "ppacket", "Pwk", " pcht", "facket", "Pkg", "pkg", "ppwk", " pwk", " packer", "fct", "pct", "fkg", "pcht", "Pkt", "Pct", " pkg", "Packer", "tacker", "gpkg", "gpcht"], "buf": ["Buffer", "br", "fw", "ff", "db", "func", "fp", "data", "base", "obj", "fam", "ref", "f", "pool", "buffer", "vec", "fi", "feed", "cf", "cb", "block", "bc", "src", "cp", "msg", "wb", "ctx", "Buff", "pb", "fab", "cas", "fx", "conv", "path", "pkg", "box", "aux", "flow", "img", "queue", "bd", "buff", "fb", "bh", "raf", "rb", "tmp", "cmd", "seq", "b", "cache", "cap", "fn", "alloc", " buffer", "bag", "uf", "cv"], "res": ["rx", "ret", "func", "rs", "obj", "err", "ras", "core", "reg", "results", "r", "rc", "result", "str", "rel", "nos", "rh", "resolution", "Res", "des", "RES", "resp", "arr", "ris", "css", "sol", "val", "re", "ress", "mr", "pre", "rar", "ex", "response", "rev", "cr", " Res", "js", "req", "rus", "rss", "Rs", "rez", "error", "red", "rep", "pres", "rem", "gr", "ver"], "fd": ["dc", "dd", "draft", "fw", "db", "pid", "ff", "func", "fp", "data", "f", "dir", "buffer", "fe", "md", "io", "file", "fun", "fa", "fi", "cf", "cb", "director", "fc", " fid", "fs", "dl", "ptr", "ind", "writer", "ld", "pointer", "lf", "cond", "exec", "fx", "d", "fl", "df", "format", "socket", "bd", "length", "id", "handler", "fb", "raf", "temp", "position", "flo", "fff", "driver", "fn", "cd", "connection", "port", "die", "uf", "FD", "sf"], "buf_descriptor": ["buf_descstructor", "buf_desriptractor", "buf_descriptour", "buf_desccriptor", "buf_desccriptractor", "buf_desriptore", "buf_descriptore", "buf_descriptors", "buf_deccriptors", "buf_descryptors", "buf_descryptractor", "buf_descributractor", "buf_descruction", "buf_descructor", "buf_desriptors", "buf_descryptour", "buf_desccriptors", "buf_decriptor", "buf_descributor", "buf_deccriptore", "buf_descryptor", "buf_descstructore", "buf_deccription", "buf_descributore", "buf_descorore", "buf_desccription", "buf_desccriptour", "buf_descoror", "buf_descorors", "buf_descriptractor", "buf_descributour", "buf_descructors", "buf_descstruction", "buf_desriptour", "buf_deccriptor", "buf_decription", "buf_description", "buf_descributors", "buf_decriptore", "buf_decriptors", "buf_descstructour", "buf_desriptor", "buf_descorractor", "buf_desccriptore", "buf_descstructors", "buf_descructore"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548, "substitutes": {"opaque": ["copaques", "octaque", "copacity", "ipec", "oponymous", "iponymous", "openaque", "octaques", "copaque", " opacity", "opatile", "opec", "opacity", "openec", "octatile", " opatile", "ipacity", " oponymous", "openacity", " opec", "ipaque", "opaques", "copatile", "openonymous", " opaques", "octacity"], "c2": ["cSecond", "arcSecond", "arcTwo", "ac2", "ac1", "C2", "cp02", "C1", "f2", "c1", "cpSecond", "b2", "f1", "arc2", "C0", "ac0", "cpTwo", "c0", "c02", "bSecond", "arc02", "cTwo", "f0", "b02", "cp2", "bTwo"]}}
{"project": "qemu", "commit_id": "9217e26f43df4aab7deaea35b21caacc1f1f854b", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553, "substitutes": {"bs": ["ns", "ts", "fps", "rs", "las", "ubs", "sb", "bc", "ls", "ss", "pb", "fs", "bb", "cs", "gb", "bos", "obs", "BS", "iss", "blocks", "bis", "bl", "vs", "fb", "bh", "bits", "ps", "rb", "js", "b", "gs", "es", "bytes", "os", "state", "bes", "sa", "ds"], "sector_num": ["sector1id", " sector_number", "sector1num", " sector_info", "sector_number", " sector_id", "sector1number", "sector_id", "sector1info", "sector_info"], "buffer": ["Buffer", "bin", "data", "ref", "comment", "window", "block", "padding", "bb", "timeout", "header", "array", "seed", "queue", "buff", "buf", "batch", "device", "slave", "binary", "address", "iter", "port", "writer", "source", "transfer", "input"], "nb_sectors": ["nb_semissions", "nb_secmissions", "nb_sygment", "nb_sigments", "nb_segments", "nb_secgments", "nb_secgment", "nb_sictors", "nb_sigment", "nb_simissions", "nb_secctors", "nb_segment", "nb_symissions", "nb_syctors", "nb_sygments"], "s": ["ns", "status", "ts", "t", "rs", "rates", "stats", "settings", "services", "r", "n", "sb", "g", "sl", "as", "ops", "is", "o", "iss", "e", "ssl", "ses", "sync", "c", "ps", "p", "secondary", "S", "b", "gs", "sys", "es", "os", "state", "us", "states", "sq", "sa", "u"]}}
{"project": "FFmpeg", "commit_id": "f0ca6ffa0ae5d5564516ee7a18aa1e234751444a", "target": 1, "func": "static void show_packets(AVFormatContext *fmt_ctx)\n\n{\n\n    AVPacket pkt;\n\n\n\n    av_init_packet(&pkt);\n\n    probe_array_header(\"packets\", 0);\n\n    while (!av_read_frame(fmt_ctx, &pkt))\n\n        show_packet(fmt_ctx, &pkt);\n\n    probe_array_footer(\"packets\", 0);\n\n}\n", "idx": 17554, "substitutes": {"fmt_ctx": ["fmt_context", "fmt_cm", "fmtfpkg", "fmtfctx", "frt_cm", "fmt_conn", "fmt_lc", "fmtfsci", "frt_sci", "fmtfcm", "frt_context", "fmtflc", "frt_conn", "fmt_sci", "frt_cp", "fmt_pkg", "frt_pkg", "frt_lc", "fmt_cp", "frt_ctx", "fmtfcontext", "fmtfconn", "fmtfcp"], "pkt": ["bpkt", "pnt", "Pnt", "wkg", "wacket", "bpnt", "fkt", "Pett", "Pet", "fet", "pett", "bpacket", "wkt", "Packet", "ppct", " pct", "packet", " pet", " packet", " pnt", "ppkt", "ppacket", "facket", "Pkg", "pkg", "fct", "pct", "fkg", "Pkt", "bpct", "Pct", "pet", "ppett", "fett", "wct"]}}
{"project": "qemu", "commit_id": "d368ba4376b2c1c24175c74b3733b8fe64dbe8a6", "target": 0, "func": "static void sdhci_write_dataport(SDHCIState *s, uint32_t value, unsigned size)\n\n{\n\n    unsigned i;\n\n\n\n    /* Check that there is free space left in a buffer */\n\n    if (!(s->prnsts & SDHC_SPACE_AVAILABLE)) {\n\n        ERRPRINT(\"Can't write to data buffer: buffer full\\n\");\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < size; i++) {\n\n        s->fifo_buffer[s->data_count] = value & 0xFF;\n\n        s->data_count++;\n\n        value >>= 8;\n\n        if (s->data_count >= (s->blksize & 0x0fff)) {\n\n            DPRINT_L2(\"write buffer filled with %u bytes of data\\n\",\n\n                    s->data_count);\n\n            s->data_count = 0;\n\n            s->prnsts &= ~SDHC_SPACE_AVAILABLE;\n\n            if (s->prnsts & SDHC_DOING_WRITE) {\n\n                SDHCI_GET_CLASS(s)->write_block_to_card(s);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17576, "substitutes": {"s": ["ns", "ms", "status", "m", "ts", "rates", "rs", "t", "stats", "f", "conf", "uns", "settings", "services", "service", "r", "n", "sie", "sb", "g", "current", "ss", "ls", "ops", "this", "fs", "self", "xs", "is", "o", "changes", "cs", "l", "d", "new", "args", "qs", "e", "ssl", "ses", "sync", "c", "ps", "js", "si", "sym", "p", "S", "b", "ks", "gs", "sys", "storage", "its", "a", "es", "os", "state", "us", "hs", "sets", "states", "sq", "parts", "south", "php", "ds", "u"], "value": ["set", "values", "status", "scale", "content", "Value", "offset", "data", "info", "text", "name", "image", "buffer", "money", "result", "current", "type", "max", "index", "timeout", "byte", "range", "store", "val", "d", "balance", "array", "flow", "w", "length", "response", "key", "start", "id", "v", "VALUE", "si", "shift", "address", "total", "fee", "u", "number", "message", "state", "end", "version", "expression"], "size": ["set", "scale", "offset", "code", "small", "data", "capacity", "SIZE", "name", "time", "from", "sized", "g", "type", "z", "six", "sec", "timeout", "ui", "style", "ci", "security", "ize", "length", "ish", "c", "unit", "si", "shift", "address", "fee", "storage", "Size", "now", "len"], "i": ["ti", "m", "bi", "j", "ji", "t", "data", "x", "f", "ix", "ini", "r", "io", "ai", "n", "mi", "z", "ie", "ii", "iu", "index", "di", "I", "multi", "zi", "is", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "length", "id", "e", "k", "v", "c", "ni", "si", "p", "b", "iv", "a", "ia", "it", "eni", "fi", "li", "u"], "data_count": ["data_size", " data_cache", " data_size", " data_length", "data_width", " data_offset", "dataacdata", " data_data", "data\u00b7current", "data\u00b7count", "data_counter", "data_current", "dataarddepth", "data\u00b7depth", "data_cache", "dataardsize", "dataardcount", "data\u00b7size", " data_width", " data_depth", "dataaccount", "dataacdepth", "data_length", " data_current", " data_counter", "dataacsize", "data_depth", "dataarddata", "data_offset", "data_data"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "static uint64_t omap_ulpd_pm_read(void *opaque, target_phys_addr_t addr,\n\n                                  unsigned size)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *) opaque;\n\n    uint16_t ret;\n\n\n\n    if (size != 2) {\n\n        return omap_badwidth_read16(opaque, addr);\n\n    }\n\n\n\n    switch (addr) {\n\n    case 0x14:\t/* IT_STATUS */\n\n        ret = s->ulpd_pm_regs[addr >> 2];\n\n        s->ulpd_pm_regs[addr >> 2] = 0;\n\n        qemu_irq_lower(s->irq[1][OMAP_INT_GAUGE_32K]);\n\n        return ret;\n\n\n\n    case 0x18:\t/* Reserved */\n\n    case 0x1c:\t/* Reserved */\n\n    case 0x20:\t/* Reserved */\n\n    case 0x28:\t/* Reserved */\n\n    case 0x2c:\t/* Reserved */\n\n        OMAP_BAD_REG(addr);\n\n    case 0x00:\t/* COUNTER_32_LSB */\n\n    case 0x04:\t/* COUNTER_32_MSB */\n\n    case 0x08:\t/* COUNTER_HIGH_FREQ_LSB */\n\n    case 0x0c:\t/* COUNTER_HIGH_FREQ_MSB */\n\n    case 0x10:\t/* GAUGING_CTRL */\n\n    case 0x24:\t/* SETUP_ANALOG_CELL3_ULPD1 */\n\n    case 0x30:\t/* CLOCK_CTRL */\n\n    case 0x34:\t/* SOFT_REQ */\n\n    case 0x38:\t/* COUNTER_32_FIQ */\n\n    case 0x3c:\t/* DPLL_CTRL */\n\n    case 0x40:\t/* STATUS_REQ */\n\n        /* XXX: check clk::usecount state for every clock */\n\n    case 0x48:\t/* LOCL_TIME */\n\n    case 0x4c:\t/* APLL_CTRL */\n\n    case 0x50:\t/* POWER_CTRL */\n\n        return s->ulpd_pm_regs[addr >> 2];\n\n    }\n\n\n\n    OMAP_BAD_REG(addr);\n\n    return 0;\n\n}\n", "idx": 17581, "substitutes": {"opaque": ["operace", " opque", "operacity", "ipopaques", "oponymous", "oclonymous", "operaya", "ipque", "ipace", " opacity", "iopaya", "oclaya", "opaya", " opace", "operec", "opec", "opacity", "iopaque", "operaque", "ioponymous", "ipacity", "ipopec", "oclacity", " opec", "operque", "ipopacity", "opace", "iopacity", "operonymous", "ipaque", "opaques", "operaques", "ipopaque", "oclaque", "opque", " opaques"], "addr": ["offset", "x", "ref", "align", "ar", "adder", "padding", "ptr", "pos", "empty", "layer", "anne", "config", "length", "prefix", "id", "asm", "p", "pad", "adr", "conn", "target", "len", "rx", "part", "work", "name", "eth", "hop", "pointer", "arity", "arg", "slot", "route", "ha", "mac", "port", "order", "amp", "code", "alt", "r", "rt", "cb", "src", "node", "byte", "host", "ack", "fx", "nr", "grade", "ad", "address", "ace", "amd", "edge", "data", "mode", "buffer", "reg", "ord", "coord", "oa", "ext", "index", "en", "ip", "alias", "args", "add", "dr", "seq", "cmd", "kt", "url", "cmp", "error", "server", "attr"], "size": ["scale", "offset", "small", "shape", "data", "capacity", "SIZE", "name", "err", "x", "code", "rc", "from", "n", "align", "sized", "g", "type", "six", "loc", "timeout", "en", "empty", " address", "large", "sn", "ize", "length", "e", "send", "c", "address", "shift", "bytes", "Size", "len"], "s": ["ns", "spec", "m", "session", "sg", "ts", "t", "rs", "uns", "aws", "f", "conf", "services", "service", "r", "results", "ions", "g", "sb", "i", "sl", "ss", "ls", "ops", "scope", "fs", "self", "is", "o", "cs", "als", "l", "su", "ins", "socket", "w", "qs", "e", "ssl", "comments", "sync", "ses", "v", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "support", "rows", "b", "ks", "gs", "sys", "u", "its", "a", "es", "os", "sq", "south", "states", "sets", "ings", "ds", "sf"], "ret": ["part", "code", "t", "data", "al", "bit", "ref", "f", "alt", "buffer", "reg", "nt", "lit", "rc", "fun", "rt", "r", "result", "num", "flag", "ext", "def", "rets", "en", "out", "arg", "att", "art", "val", "re", "Ret", "feat", "det", "rev", "v", "repl", "RET", "red", "rep", "res", "desc", "value", "success", "len"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int milkymist_memcard_init(SysBusDevice *dev)\n\n{\n\n    MilkymistMemcardState *s = MILKYMIST_MEMCARD(dev);\n\n    DriveInfo *dinfo;\n\n    BlockDriverState *bs;\n\n\n\n    dinfo = drive_get_next(IF_SD);\n\n    bs = dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL;\n\n    s->card = sd_init(bs, false);\n\n    if (s->card == NULL) {\n\n        return -1;\n\n    }\n\n\n\n    s->enabled = bs && bdrv_is_inserted(bs);\n\n\n\n    memory_region_init_io(&s->regs_region, OBJECT(s), &memcard_mmio_ops, s,\n\n            \"milkymist-memcard\", R_MAX * 4);\n\n    sysbus_init_mmio(dev, &s->regs_region);\n\n\n\n    return 0;\n\n}\n", "idx": 17587, "substitutes": {"dev": ["dc", "spec", "Dev", "dn", "dd", "mod", "ch", "data", "gd", "conf", "md", "de", "rad", "devices", "app", "dt", "di", "des", "def", "self", "d", "hw", "w", "ev", "dm", "prof", "cam", "v", "device", "dom", "ded", "driver", "p", "od", "dem", "priv", "pro", "serial", "pu", "os", "valid", "fi", "bus", "ve", "ver", "ds"], "s": ["ns", "spec", "m", "session", "sg", "ts", "t", "rs", "f", "sv", "settings", "services", "r", "service", "plugins", "n", "sb", "g", "i", "sl", "ss", "ls", "fs", "self", "sd", "is", "o", "cs", "css", "l", "d", "su", "w", "blocks", "bis", "e", "ssl", "vs", "ses", "sync", "v", "js", "ps", "si", "c", "p", "S", "b", "gs", "sys", "u", "es", "os", "us", "sets", "south", "sq", "server", "sa", "ds", "sf"], "dinfo": ["dsid", "dsinfo", "dInfo", "odinfo", "odINFO", "ldinfo", "mdfo", "mdfi", "dfo", "ldinf", "Dinfo", "dinf", "adstate", " did", "odInfo", " dinf", "vdinfo", "vdfo", "ldfi", "Dfi", "adinfo", "dstate", "vdfi", "mdinfo", "did", "dsfi", "dINFO", " dfi", "Did", "adInfo", "Dinf", "odstate", " dfo", "mdinf", " dstate", " dInfo", "vdinf", "adINFO", " dINFO", "dfi"], "bs": ["ns", "ab", "bi", "db", "rs", "base", "ob", "ubs", "sb", "cb", "ss", "bc", "ls", "ops", "pb", "fs", "bb", "lb", "des", "ba", "bid", "cs", "gb", "android", "Bs", "bos", "bf", "BS", "iss", "bd", "blocks", "bis", "bl", "vs", "bh", "fb", "sync", "js", "bas", "ps", "ses", "lib", "b", "ks", "gs", "bytes", "os", "banks", "bes", "bus", "uds", "ds"]}}
{"project": "qemu", "commit_id": "3b098d56979d2f7fd707c5be85555d114353a28d", "target": 0, "func": "static void visitor_output_setup_internal(TestOutputVisitorData *data,\n\n                                          bool human)\n\n{\n\n    data->human = human;\n\n    data->sov = string_output_visitor_new(human);\n\n    g_assert(data->sov);\n\n    data->ov = string_output_get_visitor(data->sov);\n\n    g_assert(data->ov);\n\n}\n", "idx": 17596, "substitutes": {"data": ["na", "Data", "init", "extra", "work", "code", "info", "reader", "base", "media", "results", "feed", "script", "result", "window", "g", "i", "root", "as", "pass", "this", "di", "model", "alpha", "self", "parser", "exec", "d", "database", "empty", "parse", "change", "final", "first", "and", "style", "ui", "aa", "fail", "rule", "config", "ad", "id", "last", "ga", "client", "parent", "cat", "post", "qa", "da", "p", "test", "builder", "missing", "dat", "next", "la", "wa", "a", "api", "DATA", "end", "valid", "it", "writer", "one", "dict", "li", "input"], "human": ["sov", "native", "reach", "mother", "veh", "small", "user", "name", "full", "json", "humans", "woman", "hou", "ouch", "huge", "urn", "family", "clean", "method", "public", "raw", "person", "username", "upper", "head", "low", "home", "han", "host", "cover", "liv", "father", "path", "modern", "large", "individual", "utf", "high", "remote", "ov", "hello", "client", "man", "parent", "dom", "ghost", "uc", "liter", "external", "http", "serial", "local", "Human", "valid", "canon", "own", "custom", "author", "pure"]}}
{"project": "FFmpeg", "commit_id": "570a4a0189946c2c983da41d37fdd67fa13266e7", "target": 0, "func": "static int get_riff(AVFormatContext *s, AVIOContext *pb)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    char header[8];\n\n    int i;\n\n\n\n    /* check RIFF header */\n\n    avio_read(pb, header, 4);\n\n    avi->riff_end = avio_rl32(pb);  /* RIFF chunk size */\n\n    avi->riff_end += avio_tell(pb); /* RIFF chunk end */\n\n    avio_read(pb, header+4, 4);\n\n\n\n    for(i=0; avi_headers[i][0]; i++)\n\n        if(!memcmp(header, avi_headers[i], 8))\n\n            break;\n\n    if(!avi_headers[i][0])\n\n        return -1;\n\n\n\n    if(header[7] == 0x19)\n\n        av_log(s, AV_LOG_INFO, \"This file has been generated by a totally broken muxer.\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 17597, "substitutes": {"s": ["ns", "spec", "ts", "bs", "t", "stats", "f", "sv", "settings", "services", "service", "n", "sie", "sb", "sl", "ss", "ctx", "fs", "self", "parser", "o", "cs", "su", "e", "ssl", "sc", "ses", "v", "c", "js", "si", "p", "sci", "b", "u", "storage", "a", "es", "os", "server", "se", "sq", "an", "sa", "ds", "sf"], "pb": ["pc", "ab", "eb", "db", "bs", "fp", "jp", "platform", "vp", "usb", "pd", "pl", "bm", "sb", "pm", "bp", "cpp", "cb", "cp", "bc", "hub", "lp", "wb", "ctx", "fc", "xb", "lb", "fab", "abb", "pai", "PB", "parser", "dp", "pg", "gb", "rob", "summary", "bps", "config", "pa", "bh", "fb", "rb", "p", "mp", "b", "ppa", "fm", "api", "tp", "py", "prot", "np"], "avi": ["wav", "bi", "archive", "ami", "media", "ai", "mi", "airo", "sb", "ani", "ave", "ii", "ori", "mini", "opus", "aj", "vi", "multi", "oga", "adi", "oi", "av", "audio", "pi", "vim", "ac", "abi", "aaa", "avia", "ci", "ui", "cam", "si", "afi", "umi", "audi", "video", "ati", "iv", "api", "jam", "fi", "sa", "avan"], "header": ["offset", "extra", "phrase", "num", "padding", "Header", "layer", "config", "meta", "next", "output", "h", "quarter", "end", "column", "pc", "reader", "content", "fourth", "metadata", "name", "document", "holder", "rf", "summary", "title", "table", "tail", "code", "text", "fp", "border", "block", "four", "forward", "head", "page", "back", "buf", "line", "character", "frame", "writer", "version", "record", "request", "data", "info", "buffer", "channel", "headers", "index", "tag", "parser", "context", "cover", "response", "dr", "bh", "rb", "body", "message", "server", "section"], "i": ["ti", "gi", "uri", "m", "bi", "j", "t", "x", "f", "ix", "ini", "qi", "ai", "io", "phi", "ii", "ie", "iu", "di", "index", "I", "multi", "zi", "o", "ip", "adi", "d", "axis", "oi", "yi", "pi", "ui", "ci", "id", "e", "v", "lc", "ni", "c", "si", "ri", "xi", "p", "b", "uli", "mu", "iv", "eni", "fi", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "b2caa3b82edca29ccb5e7d6311ffcf841b9b7786", "target": 1, "func": "_eth_get_rss_ex_src_addr(const struct iovec *pkt, int pkt_frags,\n\n                        size_t dsthdr_offset,\n\n                        struct ip6_ext_hdr *ext_hdr,\n\n                        struct in6_address *src_addr)\n\n{\n\n    size_t bytes_left = (ext_hdr->ip6r_len + 1) * 8 - sizeof(*ext_hdr);\n\n    struct ip6_option_hdr opthdr;\n\n    size_t opt_offset = dsthdr_offset + sizeof(*ext_hdr);\n\n\n\n    while (bytes_left > sizeof(opthdr)) {\n\n        size_t input_size = iov_size(pkt, pkt_frags);\n\n        size_t bytes_read, optlen;\n\n\n\n        if (input_size < opt_offset) {\n\n            return false;\n\n        }\n\n\n\n        bytes_read = iov_to_buf(pkt, pkt_frags, opt_offset,\n\n                                &opthdr, sizeof(opthdr));\n\n\n\n        if (bytes_read != sizeof(opthdr)) {\n\n            return false;\n\n        }\n\n\n\n        optlen = (opthdr.type == IP6_OPT_PAD1) ? 1\n\n                                               : (opthdr.len + sizeof(opthdr));\n\n\n\n        if (optlen > bytes_left) {\n\n            return false;\n\n        }\n\n\n\n        if (opthdr.type == IP6_OPT_HOME) {\n\n            size_t input_size = iov_size(pkt, pkt_frags);\n\n\n\n            if (input_size < opt_offset + sizeof(opthdr)) {\n\n                return false;\n\n            }\n\n\n\n            bytes_read = iov_to_buf(pkt, pkt_frags,\n\n                                    opt_offset + sizeof(opthdr),\n\n                                    src_addr, sizeof(*src_addr));\n\n\n\n            return bytes_read == sizeof(src_addr);\n\n        }\n\n\n\n        opt_offset += optlen;\n\n        bytes_left -= optlen;\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 17611, "substitutes": {"pkt": ["pmt", "paacket", "Pett", "ipacket", "Pet", "kacket", "bkt", "pett", "rkt", "Packet", " pett", "rct", "pamt", "pelt", " pct", "cpkg", "packet", " pet", " packet", "belt", "bet", "ipet", "ipett", "Pkg", "pkg", "backet", "kmt", "cpkt", "Pmt", " pelt", "pct", "rkg", "paelt", "racket", "kelt", "Pkt", "Pct", " pkg", "cpet", "pet", "kkt", "cpacket", "Pelt", "pakt", "ipkt"], "pkt_frags": ["pkt_drages", "pkt_grag", "pkt_grats", "pkt_rangeackets", "pkt_rangeags", "pkt_brags", "pkt_frats", "pkt_brats", "pkt_drackets", "pkt_frag", "pkt_drags", "pkt_grags", "pkt_brages", "pkt_brag", "pkt_rangeats", "pkt_frackets", "pkt_rangeages", "pkt_grages", "pkt_drats", "pkt_drag", "pkt_frages"], "dsthdr_offset": ["dsthr_len", "dsthdr_entry", "dsthr_index", "dsthr_off", "dsthr_offset", "dsthdr_index", "dsthr_size", "dsthr_entry", "dsthdr_addr", "dsthdr_off", "dsthdr_size", "dsthdr_len", "dsthr_addr"], "ext_hdr": ["ext__hhder", "ext_hder", "ext__hhdr", "ext_vdr", "ext__hr", "ext_ghrr", "ext_phst", "ext__hder", "ext_bhder", "ext_phdr", "ext_ghder", "ext_khdr", "ext_ghard", "ext_hhdr", "extshtr", "ext_fDR", "ext_thtr", "ext_khrr", "ext_hsard", "ext_htr", "ext_hsder", "ext_hsrr", "extshdr", "ext_vder", "ext__hhr", "ext_ghdr", "extshrs", "ext_hDR", "ext_phder", "ext_hrs", "ext_hst", "extsthdr", "extsthder", "ext_hsdr", "ext_hr", "ext_hrr", "ext_bhr", "ext_phr", "ext__hdr", "ext_wdr", "ext_wrs", "ext_fst", "ext_phDR", "ext_khder", "ext_khard", "ext_hhder", "extshder", "ext_thder", "extsthrs", "ext_fdr", "ext_hhr", "ext_vrs", "extsthtr", "ext_wder", "ext_vtr", "ext_thdr", "ext_bhdr", "ext_hard", "ext_thrs", "ext_wtr"], "opthdr": ["opathdr", "optthdr", "OPthstr", "OPsthstr", "opthsdr", "ophgr", "opphDR", "opthsDR", "opphrin", "OPphDR", "OPther", "opTHdr", " copsthstr", "ipthDR", "opthsr", "hopthadr", "opghgr", "opkhrim", "hoputhsr", "OPsthdr", "opether", "OPphrim", "opthadr", "opTHDR", "oputhrim", "opithDR", "opther", "opethar", "optsthrid", "opshdr", "copghrin", "oputhsr", "oppthdr", "opTHadr", "oppthsDr", "opsthdr", "oppthDr", "opghicit", "opTHrid", "opshadr", "oputhicit", "opthsrid", "opthDr", "opkhstr", "copghicit", "optthicit", "optthhr", " copthr", "optuthdr", "ophstr", "hopthsr", "oppher", "OPthdr", "OPthDR", "hopthdr", "optrrim", " opthstr", "ipthar", "opithicit", "ipethDR", "oppthsdr", "opethDR", " opghdr", "optthDR", "opphdr", "opphstr", "optuthrid", "oputhhr", "opthrim", " opthadr", " copsthr", "optsthDR", "optrsr", "oputhrid", "opTHicit", "opthinicit", "opathrid", "OPphdr", "opithar", "opphrid", "opthstr", "ipethdr", "opkhdr", "OPthrim", "opethstr", "copthdr", "copthrin", " opghadr", " copsthgr", "opsther", "optuthicit", "opthicit", "opathicit", "opghrin", "ophr", "opkhar", "opsthstr", "opsthDr", "opsthhr", "opphicit", "opithdr", "opsthDR", "opghr", "opethdr", "oppthDR", " copthstr", "oputhdr", "opithrid", "oputhadr", "opkhadr", "optrdr", " copsthdr", "hopthrim", "opphDr", "opythdr", " copthgr", "opTHsr", "OPphicit", "copthicit", "oppthsDR", "hoputhrim", "opsthicit", "optthrid", "opthr", "opshstr", "opsthgr", "opythrim", "optsthdr", "opthsDr", " copthdr", "opythstr", "opkhDR", "opthrin", "opathhr", "hoputhdr", "opthar", "optuthhr", "opthDR", "opghstr", "optsthicit", "opythicit", "ipethar", "oppthrid", "opghadr", "opsthr", "hoputhadr", "ipthdr", "opphrim", "oppthsrid", "OPphstr", "opthgr", "opthrid", "OPthicit", "OPpher", "ophdr", "opkhicit", "opghdr", " opghstr", "opsthrid", "optradr", "opthindr", "opthhr", "OPsthDR", "opthinrin", "copghdr", "opTHrim"], "bytes_read": ["ops_write", "ns_read", "seconds2find", "ns_left", "bytesfstart", "seconds2start", "bytes___length", "seconds2read", "lines_add", "bytes_ok", "bytes2start", "bytes2find", "seconds_length", " bytes_add", "bytes___need", " bytes_write", "bytes_write", "bytes2read", "bytes_need", "ns_ok", "bytes_find", "bytes_add", "bytes_start", "lines_need", "bytes_length", "seconds_start", "bytes_left", "bytesflength", "bytes___add", "bytes_end", "ns_end", "bytes_feed", "ops_left", " bytes_feed", "lines_length", "bytesffind", "seconds2length", "bytes___read", "bytes2length", "ops_read", "lines_read", "bytesfread", "seconds_find", "seconds_read"], "optlen": [" optln", "ortpos", "templc", "optel", "optl", "iterln", "ossln", "ortsl", "optlin", "oplan", "altl", "optimel", "oplin", "optionlen", "optionel", " optlan", "optLen", "optimlan", "iterlc", "logline", " optpos", "loglen", "iterlen", "opline", "optionLen", "loglin", "ortl", "optimlen", "iterl", "logl", " optrel", "templn", "ortln", "optionlan", "ortlan", "opln", "oplc", "templ", "altline", "altlin", "optlan", "optrel", "optsl", "ortlen", "ossrel", "altlen", "osslen", "osspos", "opsl", "ortrel", "optline", " optel", "oplen", "optln", " optLen", "optimLen", " optl", " optsl", "optlc", "opl", "optpos", "templen"]}}
{"project": "FFmpeg", "commit_id": "582552fb56ba6559cb1d094a7e7ae5dde3073c5c", "target": 0, "func": "static int altivec_uyvy_rgb32 (SwsContext *c,\n\n\t\t\t       unsigned char **in, int *instrides,\n\n\t\t\t       int srcSliceY,\tint srcSliceH,\n\n\t\t\t       unsigned char **oplanes, int *outstrides)\n\n{\n\n  int w = c->srcW;\n\n  int h = srcSliceH;\n\n  int i,j;\n\n  vector unsigned char uyvy;\n\n  vector signed   short Y,U,V;\n\n  vector signed   short vx,ux,uvx;\n\n  vector signed   short R0,G0,B0,R1,G1,B1;\n\n  vector unsigned char  R,G,B;\n\n  vector unsigned char *out;\n\n  ubyte *img;\n\n\n\n  img = in[0];\n\n  out = (vector unsigned char *)(oplanes[0]+srcSliceY*outstrides[0]);\n\n\n\n  for (i=0;i<h;i++) {\n\n    for (j=0;j<w/16;j++) {\n\n      uyvy = vec_ld (0, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R0,&G0,&B0);\n\n\n\n      uyvy = vec_ld (16, img);\n\n      U = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_u);\n\n\n\n      V = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_v);\n\n\n\n      Y = (vector signed short)\n\n\tvec_perm (uyvy, (vector unsigned char)(0), demux_y);\n\n\n\n      cvtyuvtoRGB (c, Y,U,V,&R1,&G1,&B1);\n\n\n\n      R  = vec_packclp (R0,R1);\n\n      G  = vec_packclp (G0,G1);\n\n      B  = vec_packclp (B0,B1);\n\n\n\n      //      vec_mstbgr24 (R,G,B, out);\n\n      out_rgba (R,G,B,out);\n\n\n\n      img += 32;\n\n    }\n\n  }\n\n  return srcSliceH;\n\n}\n", "idx": 17615, "substitutes": {"c": ["dc", "pc", "oc", "m", "ch", "t", "f", "ct", "vc", "rc", "gc", "cm", "cf", "g", "cp", "ctx", "mc", "self", "ca", "cs", "context", "l", "d", "ce", "nc", "ac", "ci", "com", "tc", "xc", "con", "config", "e", "k", "cu", "sc", "cr", "w", "lc", "cur", "p", "b", "cache", "cit", "ec", "cd", "h", "cn", "co", "icc", "C", "y", "cc"], "in": ["m", "bin", "IN", "data", "inn", "din", "ini", "login", "ine", "r", "pin", "cm", "inc", "In", "pass", "index", "min", "inside", "up", "ins", "ac", "isin", "con", "config", "id", "cli", "include", "nin", "win", "a", "lin", "connection", "inner", "source", "conn", "input"], "instrides": ["inputstrides", "instiders", "inputstriders", "instrided", "inputstiders", "inputstide", "instide", "instride", "inStride", "inbrided", "inStrided", "inputstrided", "inputstided", "inputstides", "instriders", "inputstride", "inbriders", "inbrides", "instides", "inStrides", "instided", "inStriders", "inbride"], "srcSliceY": ["srcSlaceG", "srcSlaceY", "srcFliceW", "srcFliceG", "srcSlideG", "srcSlineG", "srcFlaceX", "srcFliceY", "srcSlideW", "srcFlaceY", "srcSliceX", "srcSliseW", "srcSliseX", "srcSlineY", "srcSlaceH", "srcSlaceW", "srcSlineW", "srcSlideX", "srcSlineH", "srcFlaceW", "srcSlideY", "srcSliseH", "srcFlaceG", "srcSliceG", "srcSlaceX", "srcSliseY", "srcFliceX", "srcSlineX", "srcSliceW"], "srcSliceH": ["srcSlaceY", "srcPlineH", "srcSlideN", "srcPliceH", "srcPliceY", "srcPlineW", "srcSlideW", "srcSlideH", "srcSliseW", "srcPliceN", "srcPliceL", "srcPliceW", "srcPlineL", "srcSlineY", "srcSliceL", "srcSlaceH", "srcSlaceW", "srcSlaceL", "srcSlaceN", "srcSlineW", "srcPlineY", "srcSliceN", "srcSlineH", "srcSlideY", "srcSlineN", "srcSliseH", "srcSliseL", "srcSliseY", "srcPlineN", "srcSliceW", "srcSlineL"], "oplanes": ["dylipes", "oplipes", "planes", "ospanes", "ospades", "ospides", "oplane", "oplides", "oclades", "oplips", "dylanes", "oblanes", "oclane", "plips", "oclides", "plane", "oblades", "oblides", "oblipes", "oblane", "plipes", "ospane", "oplades", "oblips", "dylane", "oclanes", "dylips"], "outstrides": ["Outstases", "Outstiding", "Outstades", "outSTRases", "outdrides", "outstriding", "outStriders", "outbrases", "outstides", "outbrides", "outbriders", "OutStriders", "Outstrades", "outbrades", "outStrides", "outStriding", "outSTRides", "outSTRiding", "Outstriders", "outbriding", "Outstrided", "outSTRades", "OutStrided", "outdriders", "Outstrides", "Outstriding", "outbrided", "outdrided", "OutStrides", "Outstrases", "outstrided", "outstrases", "outstiding", "outstases", "outStrided", "outstriders", "outstrades", "outstades", "outdriding", "Outstides", "OutStriding"], "i": ["gi", "m", "bi", "ji", "ami", "x", "f", "ini", "qi", "r", "ai", "mi", "n", "phi", "io", "z", "ii", "ori", "iu", "di", "index", "ie", "I", "vi", "zi", "is", "ip", "chi", "l", "d", "yi", "pi", "ui", "ci", "k", "e", "v", "ni", "si", "p", "xi", "b", "h", "a", "im", "eni", "y", "li", "u"], "j": ["jc", "jl", "ji", "ch", "t", "x", "jp", "f", "jit", "uj", "qi", "r", "n", "jj", "g", "je", "z", "ii", "jet", "ij", "ie", "di", "aj", "o", "l", "d", "dy", "w", "J", "k", "e", "v", "js", "p", "b", "h", "ja", "jam", "im", "y", "li", "u"], "uyvy": ["yuny", "ouppy", " blahny", "gyyo", "chyvy", "oyny", "kyvy", "uezy", "yuy", " uoy", "kydy", "ugdy", "hubzy", "yourvy", "uuoy", "uyvette", "hubny", "ugvey", " uvy", "zyzy", "chydy", "gyny", "youry", "uuzy", "zydy", "gycy", "uuvette", "uuny", "gyvy", "uevy", " blahvette", "chyzy", " uny", "zytsy", "hubtsy", "ouy", "uycy", "uyoy", "uyyo", "oyvey", "zyyo", "uytsy", "zyny", "ouvey", "ugvy", "ouny", "gruvy", "oyvy", "udvette", " blahvy", "kyvey", "gyvey", "ugy", "udvy", "uyvey", "ueny", " uvette", "zyvette", "kycy", "gruny", "uypine", "uetsy", "hubvy", "udzy", "ouvy", "kyy", "kyzy", "oyzy", "yourvey", "oypine", "gruovy", "uyovy", "hubvey", "uuyo", "uevey", "uyny", "oycy", "gyzy", "uyy", "uydy", "uupine", "uyppy", "zyvey", "hubppy", "ueppy", "gruy", "zypine", "uyzy", " blahoy", "ouovy", "yuovy", "chyvette", "yourdy", "yuvy", "uddy", "uuvy", "zyvy"], "Y": ["E", "IE", "Z", "My", "NY", "Up", "Hy", "Col", "T", "YC", "M", "YA", " y", "A", "N", "CH", "K", "YP", "Cy", "XY", "Q", "BY", "SH", "IO", "OU", "I", "IP", "cy", "Ty", "L", "Bu", "YY", "W", "Gy", "Yu", "Ni", "Ch", "YE", "J", "X", "Ky", "F", "D", "Py", "S", "MY", "O", "Year", "IA", "C", "H", "y", "P"], "U": ["UL", "LU", "UC", "Up", "US", "T", "Us", "M", "Su", "UP", "A", "N", "CU", "Q", "OU", "UU", "I", "UD", "L", "W", "Ut", "Lu", "UX", "X", "F", "D", "S", "O", "UV", "UR", "UID", "Ub", "Tu", "UI", " u", "C", "Cu", "H", "P", "MU", "u"], "V": ["E", "Val", "UL", "VA", "AV", "GV", "VT", "M", "CV", "N", "GU", "Q", "OU", "Iv", "I", "UD", "VER", "L", "W", "Vari", "Vs", "UX", "J", "X", "TV", "VC", "v", "F", "D", "VW", "S", "UV", "VK", "C", "H", "P", "VL"], "vx": ["Vy", "Vx", " vX", " vz", "VX", "vy", "uvz", "vX", "vz", "uvX", "Vz", " vy", "uvy"], "ux": ["rx", "au", "xx", "UC", "RGB", "wx", "vc", "RC", "vec", "src", "xy", "uz", "lux", "uu", "ww", "aux", "ru", "XX", " x", "foo", "UX", "xxx", "ue", "X", "VC", "uc", "ud", " u", "sq"], "uvx": ["vpX", "cvx", "cvX", "vpy", "vy", "vX", "uvX", "vpx", "cvy", "uvy"], "R0": [" R2", "G00", "G2", "R2", "V00", "G18", "V0", "B18", " ROrigin", "R00", "V18", "B10", "R10", "R18", "V1", "B2", " GOrigin", "GOrigin", "G10", "B00", "ROrigin", " R10"], "G0": ["B25", "G00", "R8", "B30", "U3", "B000", "U000", " G25", "G3", "U0", "G000", "B8", "G25", "R25", "U30", "R00", "R3", "R000", "G30", "U1", "B3", "G8", "U00", "B00", "R30", " G8"], "B0": ["N00", "G2", "B000", "V3", "N0", "V00", "L00", "G18", "F18", "V0", "B00", "V2", "B18", "N1", "F2", "R00", "V18", "R3", "V1", "R000", "B2", "B3", "F0", "F1", "L3", "L000", "L1", "L0", "V000"], "R1": ["AId", "R8", " RPU", "AOne", "BOne", " ROne", "A1", "ROne", " RK", "A0", "C1", " RId", "GId", "GPU", "GK", "U0", "UK", "B8", "UPU", "C8", "COne", "GOne", "V1", "RK", "V8", "VOne", "U1", "RPU", "RId"], "G1": ["B5", "GName", "Ge1", " G81", " GAP", "R81", "G6", "GIT", "ROne", " GOne", "GAP", "V6", "Gone", "UOne", "G81", "RAP", " GName", " G6", "U81", "V5", "VName", " Gone", "VIT", " GIT", "UAP", " G5", "B6", "G5", "GeIT", "Bone", "GeOne", "GOne", "V1", "Vone", "VOne", "GeName", "U1"], "B1": ["VOnce", "B61", "GOnce", " B2", "L001", "Y81", "BOne", "G2", "R001", "ROne", "YOnce", "B001", "R2", " B001", "R61", "G81", "Y1", "LOne", "J61", "BOnce", "V81", "J2", "G61", "J1", "V1", "B2", " BOne", "B81", "L2", "L1"], "R": ["E", "RGB", "RL", "T", "GR", "RC", "r", "M", "RH", "A", "N", "K", "Q", "I", "L", "RR", "W", "RA", "J", "X", "SR", "F", "D", "S", "Rs", "O", "C", "H", "P"], "G": ["E", "GN", "PG", "VG", "GB", "GV", "GR", "M", "GA", "A", "g", "GL", "Q", "I", "GI", "L", "W", "Ge", "J", "X", "F", "D", "GE", "GP", "GF", "LG", "IG", "C", "Gu", "H", "GS", "GG"], "B": ["E", "Bi", "GB", "BF", "BA", "MB", "N", "A", "Q", "EB", "HB", "I", "L", "BC", "Bs", "W", "BI", "BG", "BS", "J", "X", "F", "D", "WB", "DB", "BL", "b", "O", "SB", "AB", "C", "H", "BM"], "out": ["bin", "extra", "IN", "err", "call", "ref", "image", "Output", "bit", "io", "n", "result", "Out", "In", "o", "again", "flat", "array", "draw", "new", "outs", "prefix", "Image", "buf", "tmp", "lib", "cmd", "p", "OUT", "cache", "output", "opt", "transform", "inner", "input"], "img": ["br", "ch", "small", "ff", "gif", "gd", "image", "ref", "f", "ng", "ctr", "rc", "hr", "io", "cm", "cb", "upp", "z", "src", "ii", "ie", "orig", "dim", "tif", "imag", "irm", "arr", "big", "uv", "gb", "conv", "up", "medium", "config", "bl", "buf", "imp", "bg", "tmp", "inv", "rb", "norm", "picture", "im", "aff", "aug", "input"]}}
{"project": "qemu", "commit_id": "713d9675e0e31c627d08b6a33d3a92e4b8505b40", "target": 0, "func": "static void inc_refcounts(BlockDriverState *bs,\n\n                          BdrvCheckResult *res,\n\n                          uint16_t *refcount_table,\n\n                          int refcount_table_size,\n\n                          int64_t offset, int64_t size)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t start, last, cluster_offset, k;\n\n\n\n    if (size <= 0)\n\n        return;\n\n\n\n    start = start_of_cluster(s, offset);\n\n    last = start_of_cluster(s, offset + size - 1);\n\n    for(cluster_offset = start; cluster_offset <= last;\n\n        cluster_offset += s->cluster_size) {\n\n        k = cluster_offset >> s->cluster_bits;\n\n        if (k >= refcount_table_size) {\n\n            fprintf(stderr, \"Warning: cluster offset=0x%\" PRIx64 \" is after \"\n\n                \"the end of the image file, can't properly check refcounts.\\n\",\n\n                cluster_offset);\n\n            res->check_errors++;\n\n        } else {\n\n            if (++refcount_table[k] == 0) {\n\n                fprintf(stderr, \"ERROR: overflow cluster offset=0x%\" PRIx64\n\n                    \"\\n\", cluster_offset);\n\n                res->corruptions++;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17627, "substitutes": {"bs": ["ns", "ms", "ts", "rs", "base", "las", "sb", "cb", "bc", "ls", "ss", "src", "ops", "pb", "fs", "bb", "cs", "gb", "bos", "ins", "outs", "BS", "blocks", "bis", "qs", "bl", "vs", "sync", "ses", "bits", "ps", "js", "b", "gs", "es", "os", "ds"], "res": ["ms", "ros", "ret", "spec", "rs", "ras", "err", "rc", "results", "r", "reg", "report", "result", "vals", "details", "nos", "rh", "resolution", "Res", "des", "RES", "resp", "def", "cons", "arr", "cs", "val", "re", "ress", "RS", "args", "ex", "response", "rev", "req", "rus", "ps", "ours", "rss", "js", "rez", "ons", "sys", "pers", "pres", "rem", "gr"], "refcount_table": ["refCount_list", "refCount_file", "refcountingtype", "refCount_type", "refcountedfile", "refcount2tab", "refcount2array", "refcountingtree", "refcounterarray", "refcountedtable", "refcount_array", "refCount_array", "refcount2list", "refcount2table", "refcountedtype", "refCount_tab", "refcountertable", "refcount_file", "refCount_table", "refcountedtree", "refCountingtree", "refcountntype", "refCountingtable", "refcountntree", "refcountertab", "refCountingfile", "refcount_list", "refcountingtable", "refcountingfile", "refcountntable", "refcount_tree", "refCount_tree", "refcountnfile", "refcount_tab", "refcounterlist", "refcount_type", "refCountingtype"], "refcount_table_size": ["refcount_cache_capacity", "refcount_table_scale", "refcount_window_size", "refcount_table_capacity", "refcount_table_len", "refcount_table_small", "refcount_table_name", "refcount_window_small", "refcount_window_scale", "refcount_window_name", "refcount_cache_size", "refcount_cache_len"], "offset": ["set", "entry", "part", "Offset", "base", "ref", "align", "i", "loc", "padding", "slice", "pos", "index", "timeout", "count", "pointer", "range", "location", "slot", "format", "first", "initial", "reset", "prefix", "length", "limit", "position", "off", "shift", "address", "p", "error", "tail", "origin", "number", "addr", "end", "edge", "len"], "size": ["set", "scale", "small", "code", "capacity", "time", "SIZE", "name", "fe", "cm", "n", "sized", "year", "six", "max", "sec", "timeout", "count", "after", "cs", "score", "range", "empty", "args", "use", "ize", "length", "ey", "sc", "e", "send", "sync", "unit", "c", "needed", "p", "shift", "address", "sum", "storage", "Size", "end", "se", "len"], "s": ["ns", "spec", "sup", "ts", "stats", "rs", "t", "f", "sv", "settings", "services", "sb", "g", "i", "sl", "ss", "ls", "ops", "xs", "self", "is", "o", "cs", "l", "d", "site", "w", "qs", "ssl", "e", "side", "ses", "sync", "c", "js", "si", "ps", "sym", "p", "S", "b", "http", "gs", "sys", "its", "es", "os", "state", "south", "states", "sq", "se", "less", "server", "sa", "sets", "ds"], "start": ["set", "part", "scale", "init", "skip", "work", "info", "base", "f", "from", "n", "Start", "max", "slice", "pos", "index", "min", "count", "after", "get", "art", "range", "old", "step", "first", "starting", "pre", "stop", "add", "back", "st", "id", "ish", "cur", "off", "shift", "next", "check", "error", "state", "end", "before", "se"], "last": ["est", "j", "nd", "small", "ort", "full", "so", "base", "ultimate", "from", "max", "loc", "scope", "cycle", "after", "count", "range", "close", "final", "empty", "later", "old", "first", "cost", "zero", "use", "since", "length", "prev", "sync", "latest", "cur", "parent", "needed", "total", "Last", "next", "end", "se", "before", "ending", "bottom"], "cluster_offset": ["clustereroff", "cluster_limit", "clard_Offset", "cluster__off", "clusteralleft", "clusteracprefix", "clusteringalign", "clusterxoffset", "clustereroffset", "cluster__offset", "clusteraloffset", "clusteracoffset", "clusteripoffset", "clustererorigin", "cluster_align", "clusterxaddress", "cluster_end", "clion_prefix", "clion_offset", "clion_address", "clure_end", "cluster_Offset", "clard_error", "clusteracaddress", "cluster_left", "clard_offset", "cluster__origin", "clust_off", "clusteringoffset", "clionacaddress", "clust_offset", "clancer_optional", "clusteringoptional", "clusteringentry", "cluster_size", "clard_left", "clusterxprefix", "clure_size", "cluster_error", "cluster_count", "clusteripoptional", "clancer_offset", "cluster_off", "clust_origin", "clancer_align", "cluster__size", "clure_offset", "clusteralOffset", "cluster_origin", "clionacprefix", "clusteringsize", "clusteripsize", "cluster_prefix", "clard_count", "clusterersize", "clusteripalign", "cluster_entry", "clure_off", "clusteringoff", "cluster_optional", "clust_size", "cluster_address", "clionacoffset", "clancer_size", "clusteringlimit"], "k": ["j", "ik", "work", "x", "kick", "f", "ek", "r", "n", "g", "i", "K", "ok", "max", "z", "kid", "kw", "count", "o", "sk", "range", "ask", "d", "ko", "kn", "length", "key", "q", "unk", "id", "kat", "v", "c", "p", "ck", "ku", "b", "ks", "ke", "number", "end", "kk", "y", "u"], "check_errors": ["test_error", "test__steps", "test__errors", "test_errors", "check__errors", "check_steps", "checkoutfailed", "check__error", "test_failed", "test__error", "check_error", "test_steps", "check__steps", "check_failed", "test__failed", "check__failed", "checkouterror", "checkouterrors", "checkoutsteps"], "corruptions": ["corruptibles", "corritions", "coremptions", "corritures", "cremptibles", "cremptures", "corrites", "corributions", "coremptures", "coremptibles", "coremptes", "cremptes", "cremptions", "corributures", "crruptions", "crruptures", "crruptes", "corributibles", "corruptes", "corritibles", "crruptibles", "corruptures", "corributes"]}}
{"project": "qemu", "commit_id": "733f0b02c80c3a7106d8327a83948ab68db10ea7", "target": 0, "func": "void stw_phys(target_phys_addr_t addr, uint32_t val)\n\n{\n\n    uint16_t v = tswap16(val);\n\n    cpu_physical_memory_write(addr, (const uint8_t *)&v, 2);\n\n}\n", "idx": 17641, "substitutes": {"addr": ["pc", "grad", "point", "offset", "Address", "data", "x", "base", "ref", "eth", "rt", "align", "cpu", "node", "src", "index", "ptr", "pointer", "host", "layer", "slot", "alias", "ad", "fd", "dr", "device", "kt", "p", "address", "pad", "inter", "adr", "intel", "proc", "ace", "amd", "port", "attr", "target"], "val": ["Val", "m", "ret", "bin", "V", "data", "x", "f", "base", "al", "all", "ref", "r", "vals", "sl", "sel", "index", "sec", "count", "VAL", "arr", "arg", "l", "vol", "d", "slot", "xxx", "v", "unit", "p", "test", "b", "fee", "eval", "valid", "el", "value", "len"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_branch(DisasContext *ctx, int insn_bytes)\n\n{\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK) {\n\n        int proc_hflags = ctx->hflags & MIPS_HFLAG_BMASK;\n\n        /* Branches completion */\n\n        ctx->hflags &= ~MIPS_HFLAG_BMASK;\n\n        ctx->bstate = BS_BRANCH;\n\n        save_cpu_state(ctx, 0);\n\n        /* FIXME: Need to clear can_do_io.  */\n\n        switch (proc_hflags & MIPS_HFLAG_BMASK_BASE) {\n\n        case MIPS_HFLAG_FBNSLOT:\n\n            MIPS_DEBUG(\"forbidden slot\");\n\n            gen_goto_tb(ctx, 0, ctx->pc + insn_bytes);\n\n            break;\n\n        case MIPS_HFLAG_B:\n\n            /* unconditional branch */\n\n            MIPS_DEBUG(\"unconditional branch\");\n\n            if (proc_hflags & MIPS_HFLAG_BX) {\n\n                tcg_gen_xori_i32(hflags, hflags, MIPS_HFLAG_M16);\n\n            }\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BL:\n\n            /* blikely taken case */\n\n            MIPS_DEBUG(\"blikely branch taken\");\n\n            gen_goto_tb(ctx, 0, ctx->btarget);\n\n            break;\n\n        case MIPS_HFLAG_BC:\n\n            /* Conditional branch */\n\n            MIPS_DEBUG(\"conditional branch\");\n\n            {\n\n                int l1 = gen_new_label();\n\n\n\n                tcg_gen_brcondi_tl(TCG_COND_NE, bcond, 0, l1);\n\n                gen_goto_tb(ctx, 1, ctx->pc + insn_bytes);\n\n                gen_set_label(l1);\n\n                gen_goto_tb(ctx, 0, ctx->btarget);\n\n            }\n\n            break;\n\n        case MIPS_HFLAG_BR:\n\n            /* unconditional branch to register */\n\n            MIPS_DEBUG(\"branch to register\");\n\n            if (ctx->insn_flags & (ASE_MIPS16 | ASE_MICROMIPS)) {\n\n                TCGv t0 = tcg_temp_new();\n\n                TCGv_i32 t1 = tcg_temp_new_i32();\n\n\n\n                tcg_gen_andi_tl(t0, btarget, 0x1);\n\n                tcg_gen_trunc_tl_i32(t1, t0);\n\n                tcg_temp_free(t0);\n\n                tcg_gen_andi_i32(hflags, hflags, ~(uint32_t)MIPS_HFLAG_M16);\n\n                tcg_gen_shli_i32(t1, t1, MIPS_HFLAG_M16_SHIFT);\n\n                tcg_gen_or_i32(hflags, hflags, t1);\n\n                tcg_temp_free_i32(t1);\n\n\n\n                tcg_gen_andi_tl(cpu_PC, btarget, ~(target_ulong)0x1);\n\n            } else {\n\n                tcg_gen_mov_tl(cpu_PC, btarget);\n\n            }\n\n            if (ctx->singlestep_enabled) {\n\n                save_cpu_state(ctx, 0);\n\n                gen_helper_0e0i(raise_exception, EXCP_DEBUG);\n\n            }\n\n            tcg_gen_exit_tb(0);\n\n            break;\n\n        default:\n\n            MIPS_DEBUG(\"unknown branch\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 17653, "substitutes": {"ctx": ["grad", "cfg", "concept", "cf", "anc", "cas", "Context", "cs", "exec", "tx", "config", "xc", "gpu", "cu", "cli", "ck", "cv", "conn", "cc", "input", "pc", "txt", "wx", "cca", "cus", "vc", "cm", "bc", "cp", "ocr", "wcs", "msg", "scope", "kw", "hw", "linux", "cms", "sc", "lc", "uc", "connection", "mac", "cci", "wp", "fp", "jp", "ct", "cpu", "cpp", "cb", "loc", "src", "git", "ctrl", "ca", "kb", "ci", "sync", "c", "history", "qa", "sci", "fn", "sys", "cn", "cases", "np", "conf", "fc", "xs", "css", "context", "conv", "nc", "pkg", "tc", "cam", "cl", "client", "req", " cx", "chan", "cmd", "que", "cmp", "proc"], "insn_bytes": ["insc__bytes", "insc__seconds", "insc_seconds", "insc_blocks", "insc_byte", "insn__seconds", "insn__lines", "insc_lines", "insn_byte", "insn__bits", "insc__byte", "insc_bytes", "insn_bits", "insn__blocks", "insn_lines", "insn__bytes", "insn__byte", "insn_seconds", "insc_bits", "insn_blocks", "insc__bits"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "void slirp_cleanup(Slirp *slirp)\n\n{\n\n    TAILQ_REMOVE(&slirp_instances, slirp, entry);\n\n\n\n    unregister_savevm(\"slirp\", slirp);\n\n\n\n    qemu_free(slirp->tftp_prefix);\n\n    qemu_free(slirp->bootp_filename);\n\n    qemu_free(slirp);\n\n}\n", "idx": 17664, "substitutes": {"slirp": ["plpirp", "plpirb", "slirsp", "clirpc", "plpirpc", "slirlpi", "slibrper", "slibru", "sloref", "clirc", "slireq", "slirpc", "slirtc", "shirpc", "slirec", "slirc", "clirp", "urrpa", "sliren", "plirp", "plirtp", "urru", "plirpc", "slorep", "slirspa", "plirtf", "slirln", "slirb", "plirn", "slirsper", "slirap", "slirtq", "slirapd", "slirtpd", "slrrper", "plirb", "slirepi", "plirf", "uiru", "clirpi", "slirlc", "clirtp", "clirtpi", "slrpc", "slirtpi", "slirsu", "slirtp", "plirtpc", "slirlP", "slirapc", "slpirc", "urrper", "slpirb", "slrru", "shirapi", "plirc", "slrp", "slirpa", "shirap", "slirP", "slironp", "slironpi", "plirq", "plirP", "slpirpc", "plirtP", "shirp", "slirn", "slirep", "plirtn", "slirper", "slrc", "sliru", "slirpi", "slirapi", "slibrp", "plirtq", "clirtpc", "sliref", "slibrpa", "plpirc", "slrrp", "slirtn", "slorepc", "slironpd", "slpirp", "slirpd", "shirapd", "slirq", "clirtc", "uirpa", "uirper", "slirlp", "slrrpa", "slironpc", "sloreq", "shirpi", "slirepc", "slireP", "slirlpc", "urrp", "slirtpc", "slireb", "slirf", "slirtf", "shirapc", "uirp", "slirtP", "slrb", "shirpd"]}}
{"project": "qemu", "commit_id": "eda470e41a753070e057380a9a71e2ad7347f667", "target": 0, "func": "void scsi_req_abort(SCSIRequest *req, int status)\n\n{\n\n    if (!req->enqueued) {\n\n        return;\n\n    }\n\n    scsi_req_ref(req);\n\n    scsi_req_dequeue(req);\n\n    req->io_canceled = true;\n\n    if (req->ops->cancel_io) {\n\n        req->ops->cancel_io(req);\n\n    }\n\n    scsi_req_complete(req, status);\n\n    scsi_req_unref(req);\n\n}\n", "idx": 17670, "substitutes": {"req": ["require", "spec", "grad", "user", "ref", "op", "str", "cf", "sec", "exec", "comp", "tar", "qt", "needed", "p", "resource", "next", "gr", "conn", "rx", "mod", "rs", "wx", "ctr", "hr", "dq", "sem", "rf", "mr", "flow", "pr", "cgi", "desc", "ver", "required", "fr", "quest", "err", "call", "jp", "f", "r", "rt", "cb", "task", "rh", "this", "crit", "iq", "ru", "q", "qa", "check", "pro", "sq", "progress", "rr", "request", "tr", "conf", "loader", "ok", "ext", "ctx", "def", "pkg", "fail", "pull", "dr", "cur", "rb", "seq", "cmd", "http", "requ", "error", "wa", "proc"], "status": ["stat", "skip", "code", "stats", "err", "name", "full", "service", "ity", "result", "wait", "str", "worker", "current", "STAT", "msg", "source", "sec", "fs", "resp", "score", "security", "response", "Status", "sr", "received", "sync", "access", "uses", "error", "sys", "state", "server", "progress", "success"]}}
{"project": "FFmpeg", "commit_id": "202a6697ba54293235ce2d7bd5724f4f461e417f", "target": 0, "func": "rdt_free_extradata (PayloadContext *rdt)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < MAX_STREAMS; i++)\n\n        if (rdt->rmst[i]) {\n\n            ff_rm_free_rmstream(rdt->rmst[i]);\n\n            av_freep(&rdt->rmst[i]);\n\n        }\n\n    if (rdt->rmctx)\n\n        av_close_input_stream(rdt->rmctx);\n\n    av_freep(&rdt->mlti_data);\n\n    av_free(rdt);\n\n}\n", "idx": 17678, "substitutes": {"i": ["ti", "gi", "uri", "part", "m", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "io", "ai", "mi", "n", "hi", "z", "ii", "ie", "in", "di", "index", "iu", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "yi", "diff", "pi", "ui", "ci", "id", "start", "e", "k", "v", "c", "si", "ri", "p", "xi", "b", "mu", "a", "fi", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "0e9b9edae7bebfd31fdbead4ccbbce03876a7edd", "target": 0, "func": "build_dsdt(GArray *table_data, GArray *linker,\n\n           AcpiPmInfo *pm, AcpiMiscInfo *misc,\n\n           PcPciInfo *pci, MachineState *machine)\n\n{\n\n    CrsRangeEntry *entry;\n\n    Aml *dsdt, *sb_scope, *scope, *dev, *method, *field, *pkg, *crs;\n\n    GPtrArray *mem_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    GPtrArray *io_ranges = g_ptr_array_new_with_free_func(crs_range_free);\n\n    PCMachineState *pcms = PC_MACHINE(machine);\n\n    uint32_t nr_mem = machine->ram_slots;\n\n    int root_bus_limit = 0xFF;\n\n    PCIBus *bus = NULL;\n\n    int i;\n\n\n\n    dsdt = init_aml_allocator();\n\n\n\n    /* Reserve space for header */\n\n    acpi_data_push(dsdt->buf, sizeof(AcpiTableHeader));\n\n\n\n    build_dbg_aml(dsdt);\n\n    if (misc->is_piix4) {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_piix4_pm(dsdt);\n\n        build_piix4_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_piix4_pci_hotplug(dsdt);\n\n        build_piix4_pci0_int(dsdt);\n\n    } else {\n\n        sb_scope = aml_scope(\"_SB\");\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCST\", AML_SYSTEM_IO, aml_int(0xae00), 0x0c));\n\n        aml_append(sb_scope,\n\n            aml_operation_region(\"PCSB\", AML_SYSTEM_IO, aml_int(0xae0c), 0x01));\n\n        field = aml_field(\"PCSB\", AML_ANY_ACC, AML_NOLOCK, AML_WRITE_AS_ZEROS);\n\n        aml_append(field, aml_named_field(\"PCIB\", 8));\n\n        aml_append(sb_scope, field);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        sb_scope = aml_scope(\"_SB\");\n\n        dev = aml_device(\"PCI0\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A08\")));\n\n        aml_append(dev, aml_name_decl(\"_CID\", aml_eisaid(\"PNP0A03\")));\n\n        aml_append(dev, aml_name_decl(\"_ADR\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"_UID\", aml_int(1)));\n\n        aml_append(dev, aml_name_decl(\"SUPP\", aml_int(0)));\n\n        aml_append(dev, aml_name_decl(\"CTRL\", aml_int(0)));\n\n        aml_append(dev, build_q35_osc_method());\n\n        aml_append(sb_scope, dev);\n\n        aml_append(dsdt, sb_scope);\n\n\n\n        build_hpet_aml(dsdt);\n\n        build_q35_isa_bridge(dsdt);\n\n        build_isa_devices_aml(dsdt);\n\n        build_q35_pci0_int(dsdt);\n\n    }\n\n\n\n    build_legacy_cpu_hotplug_aml(dsdt, machine, pm->cpu_hp_io_base);\n\n    build_memory_hotplug_aml(dsdt, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n    scope =  aml_scope(\"_GPE\");\n\n    {\n\n        aml_append(scope, aml_name_decl(\"_HID\", aml_string(\"ACPI0006\")));\n\n\n\n        if (misc->is_piix4) {\n\n            method = aml_method(\"_E01\", 0, AML_NOTSERIALIZED);\n\n            aml_append(method,\n\n                aml_acquire(aml_name(\"\\\\_SB.PCI0.BLCK\"), 0xFFFF));\n\n            aml_append(method, aml_call0(\"\\\\_SB.PCI0.PCNT\"));\n\n            aml_append(method, aml_release(aml_name(\"\\\\_SB.PCI0.BLCK\")));\n\n            aml_append(scope, method);\n\n        }\n\n\n\n        method = aml_method(\"_E03\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_call0(MEMORY_HOTPLUG_HANDLER_PATH));\n\n        aml_append(scope, method);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    bus = PC_MACHINE(machine)->bus;\n\n    if (bus) {\n\n        QLIST_FOREACH(bus, &bus->child, sibling) {\n\n            uint8_t bus_num = pci_bus_num(bus);\n\n            uint8_t numa_node = pci_bus_numa_node(bus);\n\n\n\n            /* look only for expander root buses */\n\n            if (!pci_bus_is_root(bus)) {\n\n                continue;\n\n            }\n\n\n\n            if (bus_num < root_bus_limit) {\n\n                root_bus_limit = bus_num - 1;\n\n            }\n\n\n\n            scope = aml_scope(\"\\\\_SB\");\n\n            dev = aml_device(\"PC%.02X\", bus_num);\n\n            aml_append(dev, aml_name_decl(\"_UID\", aml_int(bus_num)));\n\n            aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0A03\")));\n\n            aml_append(dev, aml_name_decl(\"_BBN\", aml_int(bus_num)));\n\n\n\n            if (numa_node != NUMA_NODE_UNASSIGNED) {\n\n                aml_append(dev, aml_name_decl(\"_PXM\", aml_int(numa_node)));\n\n            }\n\n\n\n            aml_append(dev, build_prt(false));\n\n            crs = build_crs(PCI_HOST_BRIDGE(BUS(bus)->parent),\n\n                            io_ranges, mem_ranges);\n\n            aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n            aml_append(scope, dev);\n\n            aml_append(dsdt, scope);\n\n        }\n\n    }\n\n\n\n    scope = aml_scope(\"\\\\_SB.PCI0\");\n\n    /* build PCI0._CRS */\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_word_bus_number(AML_MIN_FIXED, AML_MAX_FIXED, AML_POS_DECODE,\n\n                            0x0000, 0x0, root_bus_limit,\n\n                            0x0000, root_bus_limit + 1));\n\n    aml_append(crs, aml_io(AML_DECODE16, 0x0CF8, 0x0CF8, 0x01, 0x08));\n\n\n\n    aml_append(crs,\n\n        aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                    AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                    0x0000, 0x0000, 0x0CF7, 0x0000, 0x0CF8));\n\n\n\n    crs_replace_with_free_ranges(io_ranges, 0x0D00, 0xFFFF);\n\n    for (i = 0; i < io_ranges->len; i++) {\n\n        entry = g_ptr_array_index(io_ranges, i);\n\n        aml_append(crs,\n\n            aml_word_io(AML_MIN_FIXED, AML_MAX_FIXED,\n\n                        AML_POS_DECODE, AML_ENTIRE_RANGE,\n\n                        0x0000, entry->base, entry->limit,\n\n                        0x0000, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    aml_append(crs,\n\n        aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                         AML_CACHEABLE, AML_READ_WRITE,\n\n                         0, 0x000A0000, 0x000BFFFF, 0, 0x00020000));\n\n\n\n    crs_replace_with_free_ranges(mem_ranges, pci->w32.begin, pci->w32.end - 1);\n\n    for (i = 0; i < mem_ranges->len; i++) {\n\n        entry = g_ptr_array_index(mem_ranges, i);\n\n        aml_append(crs,\n\n            aml_dword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_NON_CACHEABLE, AML_READ_WRITE,\n\n                             0, entry->base, entry->limit,\n\n                             0, entry->limit - entry->base + 1));\n\n    }\n\n\n\n    if (pci->w64.begin) {\n\n        aml_append(crs,\n\n            aml_qword_memory(AML_POS_DECODE, AML_MIN_FIXED, AML_MAX_FIXED,\n\n                             AML_CACHEABLE, AML_READ_WRITE,\n\n                             0, pci->w64.begin, pci->w64.end - 1, 0,\n\n                             pci->w64.end - pci->w64.begin));\n\n    }\n\n\n\n    if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n        aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                   TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n    }\n\n    aml_append(scope, aml_name_decl(\"_CRS\", crs));\n\n\n\n    /* reserve GPE0 block resources */\n\n    dev = aml_device(\"GPE0\");\n\n    aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n    aml_append(dev, aml_name_decl(\"_UID\", aml_string(\"GPE0 resources\")));\n\n    /* device present, functioning, decoding, not shown in UI */\n\n    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n    crs = aml_resource_template();\n\n    aml_append(crs,\n\n        aml_io(AML_DECODE16, pm->gpe0_blk, pm->gpe0_blk, 1, pm->gpe0_blk_len)\n\n    );\n\n    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n    aml_append(scope, dev);\n\n\n\n    g_ptr_array_free(io_ranges, true);\n\n    g_ptr_array_free(mem_ranges, true);\n\n\n\n    /* reserve PCIHP resources */\n\n    if (pm->pcihp_io_len) {\n\n        dev = aml_device(\"PHPR\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"PNP0A06\")));\n\n        aml_append(dev,\n\n            aml_name_decl(\"_UID\", aml_string(\"PCI Hotplug resources\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, pm->pcihp_io_base, pm->pcihp_io_base, 1,\n\n                   pm->pcihp_io_len)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n        aml_append(scope, dev);\n\n    }\n\n    aml_append(dsdt, scope);\n\n\n\n    /*  create S3_ / S4_ / S5_ packages if necessary */\n\n    scope = aml_scope(\"\\\\\");\n\n    if (!pm->s3_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(1)); /* PM1a_CNT.SLP_TYP */\n\n        aml_append(pkg, aml_int(1)); /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S3\", pkg));\n\n    }\n\n\n\n    if (!pm->s4_disabled) {\n\n        pkg = aml_package(4);\n\n        aml_append(pkg, aml_int(pm->s4_val)); /* PM1a_CNT.SLP_TYP */\n\n        /* PM1b_CNT.SLP_TYP, FIXME: not impl. */\n\n        aml_append(pkg, aml_int(pm->s4_val));\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(pkg, aml_int(0)); /* reserved */\n\n        aml_append(scope, aml_name_decl(\"_S4\", pkg));\n\n    }\n\n\n\n    pkg = aml_package(4);\n\n    aml_append(pkg, aml_int(0)); /* PM1a_CNT.SLP_TYP */\n\n    aml_append(pkg, aml_int(0)); /* PM1b_CNT.SLP_TYP not impl. */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(pkg, aml_int(0)); /* reserved */\n\n    aml_append(scope, aml_name_decl(\"_S5\", pkg));\n\n    aml_append(dsdt, scope);\n\n\n\n    /* create fw_cfg node, unconditionally */\n\n    {\n\n        /* when using port i/o, the 8-bit data register *always* overlaps\n\n         * with half of the 16-bit control register. Hence, the total size\n\n         * of the i/o region used is FW_CFG_CTL_SIZE; when using DMA, the\n\n         * DMA control register is located at FW_CFG_DMA_IO_BASE + 4 */\n\n        uint8_t io_size = object_property_get_bool(OBJECT(pcms->fw_cfg),\n\n                                                   \"dma_enabled\", NULL) ?\n\n                          ROUND_UP(FW_CFG_CTL_SIZE, 4) + sizeof(dma_addr_t) :\n\n                          FW_CFG_CTL_SIZE;\n\n\n\n        scope = aml_scope(\"\\\\_SB.PCI0\");\n\n        dev = aml_device(\"FWCF\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0002\")));\n\n\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, FW_CFG_IO_BASE, FW_CFG_IO_BASE, 0x01, io_size)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->applesmc_io_base) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n        dev = aml_device(\"SMC\");\n\n\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"APP0001\")));\n\n        /* device present, functioning, decoding, not shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xB)));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->applesmc_io_base, misc->applesmc_io_base,\n\n                   0x01, APPLESMC_MAX_DATA_LENGTH)\n\n        );\n\n        aml_append(crs, aml_irq_no_flags(6));\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    if (misc->pvpanic_port) {\n\n        scope = aml_scope(\"\\\\_SB.PCI0.ISA\");\n\n\n\n        dev = aml_device(\"PEVT\");\n\n        aml_append(dev, aml_name_decl(\"_HID\", aml_string(\"QEMU0001\")));\n\n\n\n        crs = aml_resource_template();\n\n        aml_append(crs,\n\n            aml_io(AML_DECODE16, misc->pvpanic_port, misc->pvpanic_port, 1, 1)\n\n        );\n\n        aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n\n\n        aml_append(dev, aml_operation_region(\"PEOR\", AML_SYSTEM_IO,\n\n                                              aml_int(misc->pvpanic_port), 1));\n\n        field = aml_field(\"PEOR\", AML_BYTE_ACC, AML_NOLOCK, AML_PRESERVE);\n\n        aml_append(field, aml_named_field(\"PEPT\", 8));\n\n        aml_append(dev, field);\n\n\n\n        /* device present, functioning, decoding, shown in UI */\n\n        aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n\n\n        method = aml_method(\"RDPT\", 0, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_name(\"PEPT\"), aml_local(0)));\n\n        aml_append(method, aml_return(aml_local(0)));\n\n        aml_append(dev, method);\n\n\n\n        method = aml_method(\"WRPT\", 1, AML_NOTSERIALIZED);\n\n        aml_append(method, aml_store(aml_arg(0), aml_name(\"PEPT\")));\n\n        aml_append(dev, method);\n\n\n\n        aml_append(scope, dev);\n\n        aml_append(dsdt, scope);\n\n    }\n\n\n\n    sb_scope = aml_scope(\"\\\\_SB\");\n\n    {\n\n        build_memory_devices(sb_scope, nr_mem, pm->mem_hp_io_base,\n\n                             pm->mem_hp_io_len);\n\n\n\n        {\n\n            Object *pci_host;\n\n            PCIBus *bus = NULL;\n\n\n\n            pci_host = acpi_get_i386_pci_host();\n\n            if (pci_host) {\n\n                bus = PCI_HOST_BRIDGE(pci_host)->bus;\n\n            }\n\n\n\n            if (bus) {\n\n                Aml *scope = aml_scope(\"PCI0\");\n\n                /* Scan all PCI buses. Generate tables to support hotplug. */\n\n                build_append_pci_bus_devices(scope, bus, pm->pcihp_bridge_en);\n\n\n\n                if (misc->tpm_version != TPM_VERSION_UNSPEC) {\n\n                    dev = aml_device(\"ISA.TPM\");\n\n                    aml_append(dev, aml_name_decl(\"_HID\", aml_eisaid(\"PNP0C31\")));\n\n                    aml_append(dev, aml_name_decl(\"_STA\", aml_int(0xF)));\n\n                    crs = aml_resource_template();\n\n                    aml_append(crs, aml_memory32_fixed(TPM_TIS_ADDR_BASE,\n\n                               TPM_TIS_ADDR_SIZE, AML_READ_WRITE));\n\n                    /*\n\n                        FIXME: TPM_TIS_IRQ=5 conflicts with PNP0C0F irqs,\n\n                        Rewrite to take IRQ from TPM device model and\n\n                        fix default IRQ value there to use some unused IRQ\n\n                     */\n\n                    /* aml_append(crs, aml_irq_no_flags(TPM_TIS_IRQ)); */\n\n                    aml_append(dev, aml_name_decl(\"_CRS\", crs));\n\n                    aml_append(scope, dev);\n\n                }\n\n\n\n                aml_append(sb_scope, scope);\n\n            }\n\n        }\n\n        aml_append(dsdt, sb_scope);\n\n    }\n\n\n\n    /* copy AML table into ACPI tables blob and patch header there */\n\n    g_array_append_vals(table_data, dsdt->buf->data, dsdt->buf->len);\n\n    build_header(linker, table_data,\n\n        (void *)(table_data->data + table_data->len - dsdt->buf->len),\n\n        \"DSDT\", dsdt->buf->len, 1, NULL, NULL);\n\n    free_aml_allocator();\n\n}\n", "idx": 17682, "substitutes": {"entry": ["plugin", "spec", "session", "data", "mode", "info", "comment", "engine", "debug", "result", "module", "index", "sec", "def", "parser", "parse", "path", "Entry", "config", "line", "cache", "cmp", "cell", "row", "se", "card", "reader"], "dsdt": ["jstd", "jsdt", "vsdt", "desdm", "sdt", "ksdat", "ksdt", "dsds", "nastd", "nsdt", "jskt", "nasdt", "ststd", "desdt", "nscb", "ddds", "DSdat", "dsdat", "osdt", "vsds", "dddm", "stskt", "dddt", "dsdl", "dlecd", "dsqt", "nskt", "psdt", "dtd", "skt", "DSDT", "dsDT", "fsdt", "ddtd", "dltd", "dscb", "fstd", "dlDT", "nasdm", "DSdh", "psdat", "dsecd", "vsDT", "nstd", "kstd", "psDT", "ddm", "dstd", "vskt", "std", "pskt", "dqt", "DSkt", "ysdt", "stsdh", "kskt", "vstd", "ysqt", "stsds", "oskt", "DSecd", "DSdt", "ddt", "sskt", "ksDT", "fsdl", "stsdt", "dkt", "yskt", "ddDT", "destd", "osqt", "ksdm", "desdl", "pscb", "ddecd", "sstd", "naskt", "jsdat", "ystd", "nsdh", "ssdt", "dldm", "pstd", "dldt", "dskt", "fsdm", "ddkt", "ssdl", "dsdh", "ssdm", "dcb", "dlkt", "dsdm", "DStd", "sdat", "ostd"], "sb_scope": ["sb_module", "www67spec", "lb_secret", "www67scope", "www_module", "lb_sc", "www_spec", "sbthescope", "sb_project", "sb_window", "blog_session", "gb_depth", "gb_module", "blog_secret", "bs_project", "gb_region", "sb_scale", "sbthescale", "sb__scope", "sb67scope", "blog_stack", "sb__module", "lb_module", "sb__secret", "gb_scope", "sbthespec", "www_scale", "sb67scale", "www_scope", "sb__region", "sb__sc", "sb_sc", "sb_stack", "sb_region", "sb_context", "sb_session", "sb67spec", "sb_depth", "www67module", "bs_spec", "sb_parent", "sb_secret", "bs_scope", "sbthemodule", "lb_context", "bs_window", "www67scale", "sb_spec", "sb67module", "blog_scope", "lb_parent", "lb_scope", "sb__depth"], "scope": ["spec", "scale", "code", "core", "mode", "engine", "module", "root", "loc", "environment", "index", "model", "tag", "ope", "controller", "range", "context", "path", "style", "prefix", "sc", "device", "depth", "resource", "error", "project", "source"], "dev": ["dc", "Dev", "dd", "data", "mode", "conf", "err", "dep", "comment", "pub", "push", "engine", "gu", "md", "debug", "de", "loader", "block", "devices", "app", "package", "var", "kind", "di", "develop", "def", "der", "development", "prom", "self", "home", "d", "adv", "ev", " device", "v", "private", "device", "cmd", "driver", "test", "pad", "depth", "error", "serial", "priv", "DEV", "dem", "project", "end", "die", "diff", "env", "ve", "ver", "dist", "bug"], "method": ["plugin", "session", "mod", "time", "tr", "user", "mode", "comment", "op", "module", "block", "package", "auth", "app", "raw", "prop", "METHOD", "class", "path", "roll", "prefix", "cmd", "url", "depth", "serial", "port", "school"], "field": ["plugin", "Field", "instance", "time", "f", "fields", "comment", "file", "debug", "loader", "module", "coll", "package", "var", "def", "tag", "path", "style", "rule", "prefix", "mount", "cache", "message", "port", "mm", "input"], "pkg": ["plugin", "packages", "spec", "prov", "mag", "mod", "fp", "pub", "dir", "pool", "install", "pack", "loader", "module", "app", "package", "cp", "utils", "comp", "prefix", "mount", "lib", "cmd", "kg", "cmp", "arch", "proc", "lang"], "crs": ["grs", "Crs", " cris", "gris", "grc", "Crc", "crd", "grd", "crc", " crc", "Crd", "cris", " crd", "Cris"], "mem_ranges": ["mem_brange", "mem_range", "mem_branges", "mem_rebaps", "mem_raps", "mem_rebange", "mem_rebays", "mem_braps", "mem_bange", "mem_banges", "mem_rays", "mem_baps", "mem_bays", "mem_brays", "mem_rebanges"], "io_ranges": ["ioingranges", "ioingralls", "io_banges", "ioingregalls", "io_regounds", "io_brange", "io_rounds", "io_balls", "io_tanges", "io_reganges", "ioingrounds", "io_regrange", "ioingregounds", "ioingreganges", "ioingregrange", "ioingrrange", "io_talls", "io_tounds", "io_regalls", "io_bounds", "io_trange", "io_ralls", "io_rrange"], "pcms": ["mcms", "mcma", "dcps", "mcMS", "dcms", "dcma", "bcms", "mcps", "pcps", "pcma", "dcMS", "bcps", "pcMS", "bcma", "bcMS"], "bus": ["board", "plugin", "bin", "session", "engine", "usb", "service", "bridge", "Bus", "cpu", "block", "machine", "disk", "config", "mount", "device", "unit", "driver", "cache", "BUS", "lock", "boot", "serial", "connection", "port", "bug"], "i": ["m", "bi", "j", "info", "f", "r", "io", "n", "z", "ii", "in", "iu", "I", "is", "ip", "l", "pi", "e", "v", "c", "si", "p", "b", "a", "it", "li", "u"]}}
{"project": "qemu", "commit_id": "3d6f761713745dfed7d2ccfe98077d213a6a6eba", "target": 0, "func": "static void arm_cpu_do_interrupt_aarch64(CPUState *cs)\n\n{\n\n    ARMCPU *cpu = ARM_CPU(cs);\n\n    CPUARMState *env = &cpu->env;\n\n    unsigned int new_el = env->exception.target_el;\n\n    target_ulong addr = env->cp15.vbar_el[new_el];\n\n    unsigned int new_mode = aarch64_pstate_mode(new_el, true);\n\n\n\n    if (arm_current_el(env) < new_el) {\n\n        if (env->aarch64) {\n\n            addr += 0x400;\n\n        } else {\n\n            addr += 0x600;\n\n        }\n\n    } else if (pstate_read(env) & PSTATE_SP) {\n\n        addr += 0x200;\n\n    }\n\n\n\n    switch (cs->exception_index) {\n\n    case EXCP_PREFETCH_ABORT:\n\n    case EXCP_DATA_ABORT:\n\n        env->cp15.far_el[new_el] = env->exception.vaddress;\n\n        qemu_log_mask(CPU_LOG_INT, \"...with FAR 0x%\" PRIx64 \"\\n\",\n\n                      env->cp15.far_el[new_el]);\n\n        /* fall through */\n\n    case EXCP_BKPT:\n\n    case EXCP_UDEF:\n\n    case EXCP_SWI:\n\n    case EXCP_HVC:\n\n    case EXCP_HYP_TRAP:\n\n    case EXCP_SMC:\n\n        env->cp15.esr_el[new_el] = env->exception.syndrome;\n\n        break;\n\n    case EXCP_IRQ:\n\n    case EXCP_VIRQ:\n\n        addr += 0x80;\n\n        break;\n\n    case EXCP_FIQ:\n\n    case EXCP_VFIQ:\n\n        addr += 0x100;\n\n        break;\n\n    case EXCP_SEMIHOST:\n\n        qemu_log_mask(CPU_LOG_INT,\n\n                      \"...handling as semihosting call 0x%\" PRIx64 \"\\n\",\n\n                      env->xregs[0]);\n\n        env->xregs[0] = do_arm_semihosting(env);\n\n        return;\n\n    default:\n\n        cpu_abort(cs, \"Unhandled exception 0x%x\\n\", cs->exception_index);\n\n    }\n\n\n\n    if (is_a64(env)) {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = pstate_read(env);\n\n        aarch64_save_sp(env, arm_current_el(env));\n\n        env->elr_el[new_el] = env->pc;\n\n    } else {\n\n        env->banked_spsr[aarch64_banked_spsr_index(new_el)] = cpsr_read(env);\n\n        if (!env->thumb) {\n\n            env->cp15.esr_el[new_el] |= 1 << 25;\n\n        }\n\n        env->elr_el[new_el] = env->regs[15];\n\n\n\n        aarch64_sync_32_to_64(env);\n\n\n\n        env->condexec_bits = 0;\n\n    }\n\n    qemu_log_mask(CPU_LOG_INT, \"...with ELR 0x%\" PRIx64 \"\\n\",\n\n                  env->elr_el[new_el]);\n\n\n\n    pstate_write(env, PSTATE_DAIF | new_mode);\n\n    env->aarch64 = 1;\n\n    aarch64_restore_sp(env, new_el);\n\n\n\n    env->pc = addr;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"...to EL%d PC 0x%\" PRIx64 \" PSTATE 0x%x\\n\",\n\n                  new_el, env->pc, pstate_read(env));\n\n}\n", "idx": 17699, "substitutes": {"cs": ["pc", "ns", "spec", "s", "rs", "ras", "cus", "vc", "ix", "conn", "rc", "cf", "Cs", "cp", "CS", "bc", "ls", "ocr", "ctx", "ss", "wcs", "fs", "cons", "cas", "enc", "sk", "css", "acs", "ce", "args", "ci", "qs", "sc", "ics", "vs", "codes", "ses", "cli", "lc", "c", "sync", "js", "ck", "pec", "ks", "cache", "ec", "sys", "cn", "cc", "ds"], "cpu": ["pc", "dc", "cal", "core", "coe", "component", "cm", "cf", "cpp", "anc", "cp", "bc", "ctx", "fc", "en", "bench", "vm", "nc", "gpu", "CPU", "sc", "processor", "cli", "lc", "c", "ea", "cache", "cmp", "intel", "ec", "clock", "boot", "cn", "pu", "eni", "np", "cow", "cv", "conn"], "env": ["viron", "cfg", "extra", "forge", "cf", "anc", "gui", "environment", "console", "fen", "energy", "enc", "vm", "equ", "exec", "kn", "config", "ev", "qt", "cli", "ea", "output", "end", "cv", "conn", "enable", "init", "cal", "eve", "eye", "eu", "engine", "ne", " environment", "bc", "qv", "erv", "dt", "scope", "eng", "pect", "ench", "exe", "v", "nw", "stage", "ec", "export", "org", "core", "err", "estate", "net", "icer", "cb", "inet", "network", "vs", "csv", "c", "ace", "cn", "er", "edge", "eni", "np", "Environment", "esi", "session", "db", "global", "conf", "skin", "exc", "loader", "oa", "ctx", "ext", "en", "her", "context", "ce", "nc", "event", "args", "site", "e", "esm", "req", "osc", "cache", "que", "agent", "server", "el"]}}
{"project": "qemu", "commit_id": "5fe79386ba3cdc86fd808dde301bfc5bb7e9bded", "target": 0, "func": "static bool pc_machine_get_nvdimm(Object *obj, Error **errp)\n\n{\n\n    PCMachineState *pcms = PC_MACHINE(obj);\n\n\n\n    return pcms->nvdimm;\n\n}\n", "idx": 17700, "substitutes": {"obj": ["org", "instance", "j", "data", "ob", "ref", "jp", "so", "base", "conn", "nt", "pl", "office", "objects", "module", "cb", "src", "ctx", "pos", "nb", "self", "act", "object", "arr", "o", "po", "art", "id", "bot", "emb", "tmp", "p", "proc", "inst", "boot", "api", "os", "py", "pt", "Obj"], "errp": ["errpp", "armpp", "armr", "armp", "errr", "arrp", "arrpb", "armpb", "errpb", " errr", "arrpp", " errpp", "arrr", " errpb"], "pcms": [" pcMS", "lcMs", "pcps", "pcems", "cps", "lcems", " pcems", " pcMs", "pcMS", "lcms", "fcps", "fcns", "pcns", "cms", " pcns", "cems", "pcMs", "cns", "cMS", "cMs", "lcps", "fcms", " pcps", "fcMS"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_header(GArray *linker, GArray *table_data,\n\n             AcpiTableHeader *h, const char *sig, int len, uint8_t rev,\n\n             const char *oem_table_id)\n\n{\n\n    memcpy(&h->signature, sig, 4);\n\n    h->length = cpu_to_le32(len);\n\n    h->revision = rev;\n\n    memcpy(h->oem_id, ACPI_BUILD_APPNAME6, 6);\n\n\n\n    if (oem_table_id) {\n\n        strncpy((char *)h->oem_table_id, oem_table_id, sizeof(h->oem_table_id));\n\n    } else {\n\n        memcpy(h->oem_table_id, ACPI_BUILD_APPNAME4, 4);\n\n        memcpy(h->oem_table_id + 4, sig, 4);\n\n    }\n\n\n\n    h->oem_revision = cpu_to_le32(1);\n\n    memcpy(h->asl_compiler_id, ACPI_BUILD_APPNAME4, 4);\n\n    h->asl_compiler_revision = cpu_to_le32(1);\n\n    h->checksum = 0;\n\n    /* Checksum to be filled in by Guest linker */\n\n    bios_linker_loader_add_checksum(linker, ACPI_BUILD_TABLE_FILE,\n\n                                    table_data->data, h, len, &h->checksum);\n\n}\n", "idx": 17710, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "3dfbdb328ed9e88cebc6462c56cfe61e55850b2e", "target": 0, "func": "static int read_quant_table(RangeCoder *c, int16_t *quant_table, int scale)\n\n{\n\n    int v;\n\n    int i = 0;\n\n    uint8_t state[CONTEXT_SIZE];\n\n\n\n    memset(state, 128, sizeof(state));\n\n\n\n    for (v = 0; i < 128; v++) {\n\n        unsigned len = get_symbol(c, state, 0) + 1;\n\n\n\n        if (len > 128 - i)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        while (len--) {\n\n            quant_table[i] = scale * v;\n\n            i++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < 128; i++)\n\n        quant_table[256 - i] = -quant_table[i];\n\n    quant_table[128] = -quant_table[127];\n\n\n\n    return 2 * v - 1;\n\n}\n", "idx": 17723, "substitutes": {"c": ["dc", "pc", "oc", "ic", "m", "ch", "code", "f", "cus", "ct", "rc", "r", "cm", "cf", "cb", "bc", "cp", "fc", "mc", "cy", "cs", "l", "d", "ce", "nc", "ac", "xc", "e", "sc", "cr", "lc", "p", "b", "ec", "unc", "icc", "C", "cc", "u"], "quant_table": ["quant_tree", "quant_module", "quantsbuffer", "quantisttest", "user_bottom", "quant_TABLE", "volumeisttable", "volume_test", "user_part", "quant_source", "quantitytree", "queryitymodule", "quant_cache", "quant_scale", "querystable", "queryityheader", "quant0cache", "quantscount", "querystree", "useritytable", "component_table", "quantitypart", "componentingtable", "useritycache", "volumeistTABLE", "componentingcache", "quant_count", "component_source", "quantityheader", "quant_header", "useritypart", "query_cache", "qual_list", "quantstree", "quantitytable", "quantsscale", "query_tree", "quantscache", "querysbuffer", "quantentree", "queryscache", "quantistcache", "componentingiterator", "quantingcache", "quant_list", "quant0iterator", "queryitytable", "quantitycache", "query_header", "query_buffer", "query_module", "quantstable", "queryitytree", "useritybottom", "quantingsource", "query_table", "quantentable", "quantisttable", "component_iterator", "quant_buffer", "user_table", "quantslist", "quantingiterator", "qual_table", "volume_table", "quant_bottom", "quant_iterator", "quantitybottom", "quant0table", "qual_count", "quantenmodule", "component_cache", "user_cache", "componentingsource", "quant_test", "quant_part", "quantistTABLE", "volumeistcache", "quantingtable", "quantenheader", "quant0source", "quantitymodule", "volumeisttest", "volume_cache", "volume_TABLE", "qual_scale"], "scale": ["Scale", "sup", "offset", "shape", "data", "mode", "base", "cale", "slice", "range", "gain", "alias", " Scale", "grade", "size", "pi", "seed", "rule", "adjust", "value", "ize", "start", "delay", "e", "unit", "ale", "si", "shift", "norm", "rate", "fee", "error", "beta", "transform", "repeat", "co", "se", "alpha", "order", "factor", "u"], "v": ["m", "vid", "V", "j", "s", "t", "x", "f", "sv", "vc", "vp", "ver", "n", "g", "z", "ii", "vi", "lv", "count", "o", "uv", "l", "val", "conv", "size", "pi", "ui", "ci", "w", "length", "id", "k", "e", "q", "limit", "vs", "si", "p", "b", "va", "h", "iv", "a", "nv", "value", "li", "u"], "state": ["instance", "session", "stat", "j", "ch", "code", "data", "core", "err", "buffer", "r", "trace", "result", "channel", "g", "block", "ctx", "scope", "slice", "pointer", "is", "State", "range", "context", "store", "size", "memory", "seed", "style", "use", "config", "length", "start", "e", "sync", "private", "cur", "parent", "STATE", "p", "address", "cache", "resource", "output", "param", "connection", "states", "value", "source", "conn"], "len": ["j", "code", "base", "lit", "vec", "n", "pl", "lu", "sl", "ie", "ii", "dl", "pos", "ind", " l", "en", "count", "min", "L", "lf", "ln", "l", "val", "fl", "le", "size", "length", "hl", "il", "limit", "ler", "e", "id", "rev", "lc", "line", "split", "lin", "iter", "el", "li", "Len"], "i": ["gi", "uri", "m", "bi", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "phi", "mi", "z", "ii", "ie", "iu", "di", "index", "I", "vi", "o", "ip", "l", "d", "yi", "pi", "ui", "ci", "length", "id", "k", "q", "e", "limit", "lc", "ni", "si", "xi", "p", "line", "b", "h", "a", "api", "iter", "it", "fi", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "1eb57e1d9b59db0aa63348c21bf3290bd3f5efcb", "target": 0, "func": "static int tb_unreliable(AVCodecContext *c)\n\n{\n\n    if (c->time_base.den >= 101L * c->time_base.num ||\n\n        c->time_base.den <    5L * c->time_base.num ||\n\n        // c->codec_tag == AV_RL32(\"DIVX\") ||\n\n        // c->codec_tag == AV_RL32(\"XVID\") ||\n\n        c->codec_id == AV_CODEC_ID_MPEG2VIDEO ||\n\n        c->codec_id == AV_CODEC_ID_H264)\n\n        return 1;\n\n    return 0;\n\n}\n", "idx": 17735, "substitutes": {"c": ["dc", "pc", "oc", "ic", "m", "s", "ch", "t", "f", "call", "vc", "ct", "rc", "cm", "n", "cf", "g", "coll", "anc", "cp", "ctx", "fc", "mc", "ca", "enc", "cs", "exec", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "e", "cu", "sc", "k", "client", "lc", "p", "uc", "cmp", "cit", "ec", "unc", "a", "co", "C", "cv", "cc", "u"]}}
{"project": "FFmpeg", "commit_id": "0232f788b6b0855db1771dbf8d7174e2eda2ff45", "target": 1, "func": "int swr_init(struct SwrContext *s){\n\n    s->in_buffer_index= 0;\n\n    s->in_buffer_count= 0;\n\n    s->resample_in_constraint= 0;\n\n    free_temp(&s->postin);\n\n    free_temp(&s->midbuf);\n\n    free_temp(&s->preout);\n\n    free_temp(&s->in_buffer);\n\n    swri_audio_convert_free(&s-> in_convert);\n\n    swri_audio_convert_free(&s->out_convert);\n\n    swri_audio_convert_free(&s->full_convert);\n\n\n\n    s-> in.planar= av_sample_fmt_is_planar(s-> in_sample_fmt);\n\n    s->out.planar= av_sample_fmt_is_planar(s->out_sample_fmt);\n\n    s-> in_sample_fmt= av_get_alt_sample_fmt(s-> in_sample_fmt, 0);\n\n    s->out_sample_fmt= av_get_alt_sample_fmt(s->out_sample_fmt, 0);\n\n\n\n    if(s-> in_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->in_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n    if(s->out_sample_fmt >= AV_SAMPLE_FMT_NB){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is invalid\\n\", av_get_sample_fmt_name(s->out_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if(   s->int_sample_fmt != AV_SAMPLE_FMT_S16\n\n        &&s->int_sample_fmt != AV_SAMPLE_FMT_FLT){\n\n        av_log(s, AV_LOG_ERROR, \"Requested sample format %s is not supported internally, only float & S16 is supported\\n\", av_get_sample_fmt_name(s->int_sample_fmt));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    //FIXME should we allow/support using FLT on material that doesnt need it ?\n\n    if(s->in_sample_fmt <= AV_SAMPLE_FMT_S16 || s->int_sample_fmt==AV_SAMPLE_FMT_S16){\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_S16;\n\n    }else\n\n        s->int_sample_fmt= AV_SAMPLE_FMT_FLT;\n\n\n\n\n\n    if (s->out_sample_rate!=s->in_sample_rate || (s->flags & SWR_FLAG_RESAMPLE)){\n\n        s->resample = swri_resample_init(s->resample, s->out_sample_rate, s->in_sample_rate, 16, 10, 0, 0.8);\n\n    }else\n\n        swri_resample_free(&s->resample);\n\n    if(s->int_sample_fmt != AV_SAMPLE_FMT_S16 && s->resample){\n\n        av_log(s, AV_LOG_ERROR, \"Resampling only supported with internal s16 currently\\n\"); //FIXME\n\n        return -1;\n\n    }\n\n\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n\n\n    if(s->used_ch_count && s-> in_ch_layout && s->used_ch_count != av_get_channel_layout_nb_channels(s-> in_ch_layout)){\n\n        av_log(s, AV_LOG_WARNING, \"Input channel layout has a different number of channels than the number of used channels, ignoring layout\\n\");\n\n        s-> in_ch_layout= 0;\n\n    }\n\n\n\n    if(!s-> in_ch_layout)\n\n        s-> in_ch_layout= av_get_default_channel_layout(s->used_ch_count);\n\n    if(!s->out_ch_layout)\n\n        s->out_ch_layout= av_get_default_channel_layout(s->out.ch_count);\n\n\n\n    s->rematrix= s->out_ch_layout  !=s->in_ch_layout || s->rematrix_volume!=1.0;\n\n\n\n#define RSC 1 //FIXME finetune\n\n    if(!s-> in.ch_count)\n\n        s-> in.ch_count= av_get_channel_layout_nb_channels(s-> in_ch_layout);\n\n    if(!s->used_ch_count)\n\n        s->used_ch_count= s->in.ch_count;\n\n    if(!s->out.ch_count)\n\n        s->out.ch_count= av_get_channel_layout_nb_channels(s->out_ch_layout);\n\n\n\nav_assert0(s-> in.ch_count);\n\nav_assert0(s->used_ch_count);\n\nav_assert0(s->out.ch_count);\n\n    s->resample_first= RSC*s->out.ch_count/s->in.ch_count - RSC < s->out_sample_rate/(float)s-> in_sample_rate - 1.0;\n\n\n\n    s-> in.bps= av_get_bytes_per_sample(s-> in_sample_fmt);\n\n    s->int_bps= av_get_bytes_per_sample(s->int_sample_fmt);\n\n    s->out.bps= av_get_bytes_per_sample(s->out_sample_fmt);\n\n\n\n    if(!s->resample && !s->rematrix && !s->channel_map){\n\n        s->full_convert = swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                                   s-> in_sample_fmt, s-> in.ch_count, NULL, 0);\n\n        return 0;\n\n    }\n\n\n\n    s->in_convert = swri_audio_convert_alloc(s->int_sample_fmt,\n\n                                             s-> in_sample_fmt, s->used_ch_count, s->channel_map, 0);\n\n    s->out_convert= swri_audio_convert_alloc(s->out_sample_fmt,\n\n                                             s->int_sample_fmt, s->out.ch_count, NULL, 0);\n\n\n\n\n\n    s->postin= s->in;\n\n    s->preout= s->out;\n\n    s->midbuf= s->in;\n\n    s->in_buffer= s->in;\n\n    if(s->channel_map){\n\n        s->postin.ch_count=\n\n        s->midbuf.ch_count=\n\n        s->in_buffer.ch_count= s->used_ch_count;\n\n    }\n\n    if(!s->resample_first){\n\n        s->midbuf.ch_count= s->out.ch_count;\n\n        s->in_buffer.ch_count = s->out.ch_count;\n\n    }\n\n\n\n    s->in_buffer.bps = s->postin.bps = s->midbuf.bps = s->preout.bps =  s->int_bps;\n\n    s->in_buffer.planar = s->postin.planar = s->midbuf.planar = s->preout.planar =  1;\n\n\n\n\n\n    if(s->rematrix)\n\n        return swri_rematrix_init(s);\n\n\n\n    return 0;\n\n}\n", "idx": 17737, "substitutes": {"s": ["ns", "spec", "strings", "user", "settings", "service", "ions", "details", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "m", "ts", "sg", "rs", "in", "su", "si", "S", "uses", "a", "hs", "an", "ds", "native", "phys", "f", "r", "sb", "as", "this", "l", "w", "serv", "vs", "sync", "c", "ps", "b", "sys", "es", "states", "sq", "params", "sf", "session", "t", "request", "conf", "services", "n", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "parts", "se", "server", "u"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "static int svq1_decode_init(AVCodecContext *avctx)\n\n{\n\n    MpegEncContext *s = avctx->priv_data;\n\n    int i;\n\n\n\n    MPV_decode_defaults(s);\n\n\n\n    s->avctx = avctx;\n\n    s->width = (avctx->width+3)&~3;\n\n    s->height = (avctx->height+3)&~3;\n\n    s->codec_id= avctx->codec->id;\n\n    avctx->pix_fmt = PIX_FMT_YUV410P;\n\n    avctx->has_b_frames= 1; // not true, but DP frames and these behave like unidirectional b frames\n\n    s->flags= avctx->flags;\n\n    if (MPV_common_init(s) < 0) return -1;\n\n\n\n    init_vlc(&svq1_block_type, 2, 4,\n\n        &svq1_block_type_vlc[0][1], 2, 1,\n\n        &svq1_block_type_vlc[0][0], 2, 1);\n\n\n\n    init_vlc(&svq1_motion_component, 7, 33,\n\n        &mvtab[0][1], 2, 1,\n\n        &mvtab[0][0], 2, 1);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        init_vlc(&svq1_intra_multistage[i], 3, 8,\n\n            &svq1_intra_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_intra_multistage_vlc[i][0][0], 2, 1);\n\n        init_vlc(&svq1_inter_multistage[i], 3, 8,\n\n            &svq1_inter_multistage_vlc[i][0][1], 2, 1,\n\n            &svq1_inter_multistage_vlc[i][0][0], 2, 1);\n\n    }\n\n\n\n    init_vlc(&svq1_intra_mean, 8, 256,\n\n        &svq1_intra_mean_vlc[0][1], 4, 2,\n\n        &svq1_intra_mean_vlc[0][0], 4, 2);\n\n\n\n    init_vlc(&svq1_inter_mean, 9, 512,\n\n        &svq1_inter_mean_vlc[0][1], 4, 2,\n\n        &svq1_inter_mean_vlc[0][0], 4, 2);\n\n\n\n    return 0;\n\n}\n", "idx": 17742, "substitutes": {"avctx": ["avecp", "afconv", "AVcv", "awcf", "afcu", "ajcontext", "avecf", "avcoll", "afcfg", "svcontext", "avhw", "ovcli", " avhw", "aircli", "svconv", " avcp", "ovcontext", "afsync", "AVlc", "avsync", "AVctx", " avcontext", "mpci", "mpcam", "afcoll", "navcontext", "avvoc", "airctx", "avcfg", "macctx", "avlc", "aveconn", "ajcv", " avloc", "avecu", "avcp", "ajcfg", "mpcf", "AVloc", " avcf", "maccontext", "afvoc", "ajlc", " avcv", "machw", "navctx", "svctx", "avcv", "afcf", "avcam", "avcli", "ajctx", " avcoll", "ajconv", "airsync", "AVsync", " avci", "awctx", "ajloc", "avconv", "navcf", "svcfg", "ajsync", "avcf", "ovctx", "afcp", "afci", "avecoll", "avloc", " avvoc", "AVcontext", "ovsync", "mpconn", "mpcontext", "avectx", "afcam", "mpctx", "aflc", "aircontext", "awcontext", "afhw", "navcu", "afcontext", "avconn", "afctx", "avci", "avecontext", "afconn", "maccf", "awvoc", "afcli", " avcam", "avcu", "avcontext"], "s": ["ns", "spec", "m", "sup", "session", "sg", "ts", "t", "data", "stats", "aws", "f", "conf", "services", "service", "n", "sb", "g", "ss", "ls", "ops", "ctx", "sec", "fs", "xs", "o", "cs", "l", "d", "bis", "qs", "e", "ssl", "ses", "sync", "v", "c", "js", "private", "si", "sym", "p", "secondary", "S", "b", "http", "gs", "sys", "h", "storage", "a", "es", "os", "server", "sq", "an", "ds", "sf"], "i": ["ti", "gi", "uri", "ic", "bi", "j", "ik", "t", "info", "x", "f", "image", "ix", "ini", "qi", "ai", "mi", "io", "phi", "g", "hi", "type", "ii", "ie", "ori", "iu", "di", "slice", "ind", "I", "multi", "zi", "ip", "chi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "key", "e", "q", "v", "cli", "ni", "lc", "si", "ki", "ri", "xi", "p", "b", "uli", "a", "iv", "ia", "api", "it", "eni", "fi", "inner", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "bf87908cd8da31e8f8fe75c06577170928ea70a8", "target": 1, "func": "static int rm_read_audio_stream_info(AVFormatContext *s, AVIOContext *pb,\n\n                                     AVStream *st, RMStream *ast, int read_all)\n\n{\n\n    char buf[256];\n\n    uint32_t version;\n\n    int ret;\n\n\n\n    /* ra type header */\n\n    version = avio_rb16(pb); /* version */\n\n    if (version == 3) {\n\n        unsigned bytes_per_minute;\n\n        int header_size = avio_rb16(pb);\n\n        int64_t startpos = avio_tell(pb);\n\n        avio_skip(pb, 8);\n\n        bytes_per_minute = avio_rb16(pb);\n\n        avio_skip(pb, 4);\n\n        rm_read_metadata(s, 0);\n\n        if ((startpos + header_size) >= avio_tell(pb) + 2) {\n\n            // fourcc (should always be \"lpcJ\")\n\n            avio_r8(pb);\n\n            get_str8(pb, buf, sizeof(buf));\n\n        }\n\n        // Skip extra header crap (this should never happen)\n\n        if ((startpos + header_size) > avio_tell(pb))\n\n            avio_skip(pb, header_size + startpos - avio_tell(pb));\n\n        if (bytes_per_minute)\n\n            st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        st->codec->sample_rate = 8000;\n\n        st->codec->channels = 1;\n\n        st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_id = AV_CODEC_ID_RA_144;\n\n        ast->deint_id = DEINT_ID_INT0;\n\n    } else {\n\n        int flavor, sub_packet_h, coded_framesize, sub_packet_size;\n\n        int codecdata_length;\n\n        unsigned bytes_per_minute;\n\n        /* old version (4) */\n\n        avio_skip(pb, 2); /* unused */\n\n        avio_rb32(pb); /* .ra4 */\n\n        avio_rb32(pb); /* data size */\n\n        avio_rb16(pb); /* version2 */\n\n        avio_rb32(pb); /* header size */\n\n        flavor= avio_rb16(pb); /* add codec info / flavor */\n\n        ast->coded_framesize = coded_framesize = avio_rb32(pb); /* coded frame size */\n\n        avio_rb32(pb); /* ??? */\n\n        bytes_per_minute = avio_rb32(pb);\n\n        if (version == 4) {\n\n            if (bytes_per_minute)\n\n                st->codec->bit_rate = 8LL * bytes_per_minute / 60;\n\n        }\n\n        avio_rb32(pb); /* ??? */\n\n        ast->sub_packet_h = sub_packet_h = avio_rb16(pb); /* 1 */\n\n        st->codec->block_align= avio_rb16(pb); /* frame size */\n\n        ast->sub_packet_size = sub_packet_size = avio_rb16(pb); /* sub packet size */\n\n        avio_rb16(pb); /* ??? */\n\n        if (version == 5) {\n\n            avio_rb16(pb); avio_rb16(pb); avio_rb16(pb);\n\n        }\n\n        st->codec->sample_rate = avio_rb16(pb);\n\n        avio_rb32(pb);\n\n        st->codec->channels = avio_rb16(pb);\n\n        if (version == 5) {\n\n            ast->deint_id = avio_rl32(pb);\n\n            avio_read(pb, buf, 4);\n\n            buf[4] = 0;\n\n        } else {\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n            ast->deint_id = AV_RL32(buf);\n\n            get_str8(pb, buf, sizeof(buf)); /* desc */\n\n        }\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(buf);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n\n\n        switch (st->codec->codec_id) {\n\n        case AV_CODEC_ID_AC3:\n\n            st->need_parsing = AVSTREAM_PARSE_FULL;\n\n            break;\n\n        case AV_CODEC_ID_RA_288:\n\n            st->codec->extradata_size= 0;\n\n            ast->audio_framesize = st->codec->block_align;\n\n            st->codec->block_align = coded_framesize;\n\n            break;\n\n        case AV_CODEC_ID_COOK:\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        case AV_CODEC_ID_ATRAC3:\n\n        case AV_CODEC_ID_SIPR:\n\n            if (read_all) {\n\n                codecdata_length = 0;\n\n            } else {\n\n                avio_rb16(pb); avio_r8(pb);\n\n                if (version == 5)\n\n                    avio_r8(pb);\n\n                codecdata_length = avio_rb32(pb);\n\n                if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                    av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                    return -1;\n\n                }\n\n            }\n\n\n\n            ast->audio_framesize = st->codec->block_align;\n\n            if (st->codec->codec_id == AV_CODEC_ID_SIPR) {\n\n                if (flavor > 3) {\n\n                    av_log(s, AV_LOG_ERROR, \"bad SIPR file flavor %d\\n\",\n\n                           flavor);\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ff_sipr_subpk_size[flavor];\n\n            } else {\n\n                if(sub_packet_size <= 0){\n\n                    av_log(s, AV_LOG_ERROR, \"sub_packet_size is invalid\\n\");\n\n                    return -1;\n\n                }\n\n                st->codec->block_align = ast->sub_packet_size;\n\n            }\n\n            if ((ret = rm_read_extradata(pb, st->codec, codecdata_length)) < 0)\n\n                return ret;\n\n\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            avio_rb16(pb); avio_r8(pb);\n\n            if (version == 5)\n\n                avio_r8(pb);\n\n            codecdata_length = avio_rb32(pb);\n\n            if(codecdata_length + FF_INPUT_BUFFER_PADDING_SIZE <= (unsigned)codecdata_length){\n\n                av_log(s, AV_LOG_ERROR, \"codecdata_length too large\\n\");\n\n                return -1;\n\n            }\n\n            if (codecdata_length >= 1) {\n\n                avio_r8(pb);\n\n                if ((ret = rm_read_extradata(pb, st->codec, codecdata_length - 1)) < 0)\n\n                    return ret;\n\n            }\n\n            break;\n\n        default:\n\n            av_strlcpy(st->codec->codec_name, buf, sizeof(st->codec->codec_name));\n\n        }\n\n        if (ast->deint_id == DEINT_ID_INT4 ||\n\n            ast->deint_id == DEINT_ID_GENR ||\n\n            ast->deint_id == DEINT_ID_SIPR) {\n\n            if (st->codec->block_align <= 0 ||\n\n                ast->audio_framesize * sub_packet_h > (unsigned)INT_MAX ||\n\n                ast->audio_framesize * sub_packet_h < st->codec->block_align)\n\n                return AVERROR_INVALIDDATA;\n\n            if (av_new_packet(&ast->pkt, ast->audio_framesize * sub_packet_h) < 0)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n        switch (ast->deint_id) {\n\n        case DEINT_ID_INT4:\n\n            if (ast->coded_framesize > ast->audio_framesize ||\n\n                sub_packet_h <= 1 ||\n\n                ast->coded_framesize * sub_packet_h > (2 + (sub_packet_h & 1)) * ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_GENR:\n\n            if (ast->sub_packet_size <= 0 ||\n\n                ast->sub_packet_size > ast->audio_framesize)\n\n                return AVERROR_INVALIDDATA;\n\n            break;\n\n        case DEINT_ID_SIPR:\n\n        case DEINT_ID_INT0:\n\n        case DEINT_ID_VBRS:\n\n        case DEINT_ID_VBRF:\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"Unknown interleaver %X\\n\", ast->deint_id);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (read_all) {\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            avio_r8(pb);\n\n            rm_read_metadata(s, 0);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17752, "substitutes": {"s": ["ns", "types", "spec", "session", "bs", "t", "rs", "f", "sv", "settings", "sb", "sl", "ss", "ls", "ops", "fs", "parser", "cs", "bis", "sc", "ssl", "e", "ses", "cli", "scl", "c", "sync", "ps", "client", "p", "support", "b", "sys", "es", "os", "se", "sq", "sa", "ds", "sf"], "pb": ["pc", "wp", "plugin", "ab", "eb", "txt", "db", "phys", "fp", "jp", "platform", "vp", "usb", "pd", "pl", "bm", "sb", "pm", "bp", "cpp", "cb", "um", "bc", "src", "hub", "lp", "cp", "ctx", "fc", "xb", "lb", "wb", "nb", "fab", "posts", "PB", "parser", "dp", "pg", "prop", "gb", "rob", "summary", "pkg", "bps", "bf", "bot", "bh", "fb", "lc", "loc", "rb", "hp", "p", "plug", "mp", "b", "ppa", "SB", "proc", "api", "pro", "tp", "prot", "uf", "wikipedia", "pt", "lab", "typ"], "st": ["pt", "set", "ist", "est", "tt", "ts", "fr", "nd", "rest", "ct", "ess", "ste", "td", "str", "sb", "ost", "sl", "ss", "src", "ut", "th", "vd", "ld", "ST", "sd", "sta", "art", "l", "rd", "std", "sh", "stop", "sn", "sc", "bl", "sth", "cl", "kt", "sts", "St", "put", "inst", "et", "cast", "ft", "sa"], "ast": ["ans", "at", "ist", "est", "ab", "na", "ts", "nd", "af", "rest", "ref", "ct", "ess", "ar", "ost", "AST", "am", "master", "as", "node", "ST", "sta", "art", "att", "host", "ta", "aps", "aster", "Ast", "ac", "oid", "ad", "tta", "asm", "sam", "post", "rss", "test", "doc", "od", "dist", "asting", "ace", "a", "addr", "cast", "amd", "ma", "end", "asts", "an", "sa", "amp"], "read_all": ["read_data", "reader_all", "reader_total", "readbytotal", "reader_raw", "read_raw", "reader_data", "read_total", "readbydata", "readbyall", "readbyraw"], "buf": ["Buffer", "bin", "br", "db", "ff", "txt", "data", "fp", "text", "buffer", "rc", "feed", "block", "cb", "bc", "loc", "src", "cp", "wb", "ctx", "pos", "bb", "ba", "xff", "prop", "bo", "queue", "config", "bd", "fd", "buff", "fb", "v", "map", "batch", "rb", "seq", "tmp", "uc", "binary", "pad", "cmd", "b", "cap", " buffer", "bytes", "bag", "uf", "cv", " b"], "version": ["tun", "VERSION", "plugin", "brand", "vision", "shape", "code", "info", "mode", "name", "f", "platform", "option", "channel", "type", "available", "package", "python", "ception", "tag", "description", "release", "class", "format", "size", "Version", "length", "v", "position", "stage", "generation", "versions", "support", "driver", "feature", "depth", "beta", "number", "compatible", "message", "project", "connection", "server", "software", "section", "cv", "ver"], "ret": ["status", "info", "rc", "result", "quiet", "num", "max", "resp", "val", "final", "class", "Ret", "conv", "complete", "no", "con", "rev", "dev", "seq", "RET", "gen", "error", "res", " resp", " success", "lang", "success"], "bytes_per_minute": ["bytes_per_double", "bytes_PER_second", "bytes_Per_double", "bytes_PER_minute", "bytes_Per_min", "bytes_Per_minute", "bytes_per_month", "bytes_Per_month", "bytes_per_mand", "bytes_PER_day", "bytes_Per_second", "bytes_per_min", "bytes_per_second", "bytes_per_day"], "flavor": ["fluendor", "flavored", " flavored", "Flavored", "fluavorite", "fluavour", "FLavour", "Flavorite", "flavorite", " flendor", " flavour", "Flendor", "flavour", "FLavor", "FLavored", "Flavor", "Flavour", "FLendor", "fluavor", " flavorite", "flendor"], "sub_packet_h": ["sub_packacket_h", "sub_packet_length", "sub_packacket_size", "sub_packacket_length", "sub_packacket_count", "sub_packet_count"], "coded_framesize": ["coded_wordsize", "coded_filesizable", "coded_boardssize", "coded_timessize", "coded_framized", "coded_frameization", "coded_capsize", "coded_boardsized", "coded_boardsize", "coded_filesized", "coded_timesizable", "coded_capsized", "coded_frameize", "coded_framesizing", "coded_flowsize", "coded_flowssize", "coded_framessize", "coded_flowsization", "coded_filessize", "coded_wordsizing", "coded_filesize", "coded_framesization", "coded_capsizable", "coded_flowsizable", "coded_boardsizable", "coded_framize", "coded_timesize", "coded_framesizable", "coded_frameizable", "coded_framsize", "coded_wordssize", "coded_framizing", "coded_capssize", "coded_framesized", "coded_wordsized", "coded_timesization"], "sub_packet_size": ["sub_packetlistsized", "sub_packacket_sized", "sub_packetlistsize", "sub_packacket_size", "sub_packet_name", "sub_packacket_name", "sub_packet_sized", "sub_packetlistname"], "codecdata_length": ["codecdata_type", "codecdataqtype", "codecframe_type", "codecframeaclength", "codecdataaclength", "codecdata_capacity", "codecdataaccapacity", "codecdataactotal", "codecdata_total", "codecframe_total", "codecframeaccapacity", "codecdataqlength", "codecframe_capacity", "codecdataactype", "codecframe_length", "codecframeactype", "codecdataqtotal", "codecdataqcapacity", "codecframeactotal"]}}
{"project": "FFmpeg", "commit_id": "c5be6192f0a50eb8a2134c32b7d57f1d88736adf", "target": 1, "func": "int show_license(void *optctx, const char *opt, const char *arg)\n\n{\n\n    printf(\n\n#if CONFIG_NONFREE\n\n    \"This version of %s has nonfree parts compiled in.\\n\"\n\n    \"Therefore it is not legally redistributable.\\n\",\n\n    program_name\n\n#elif CONFIG_GPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_GPL\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 2 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU General Public License\\n\"\n\n    \"along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#elif CONFIG_LGPLV3\n\n    \"%s is free software; you can redistribute it and/or modify\\n\"\n\n    \"it under the terms of the GNU Lesser General Public License as published by\\n\"\n\n    \"the Free Software Foundation; either version 3 of the License, or\\n\"\n\n    \"(at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\\n\"\n\n    \"GNU Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public License\\n\"\n\n    \"along with %s.  If not, see <http://www.gnu.org/licenses/>.\\n\",\n\n    program_name, program_name, program_name\n\n#else\n\n    \"%s is free software; you can redistribute it and/or\\n\"\n\n    \"modify it under the terms of the GNU Lesser General Public\\n\"\n\n    \"License as published by the Free Software Foundation; either\\n\"\n\n    \"version 2.1 of the License, or (at your option) any later version.\\n\"\n\n    \"\\n\"\n\n    \"%s is distributed in the hope that it will be useful,\\n\"\n\n    \"but WITHOUT ANY WARRANTY; without even the implied warranty of\\n\"\n\n    \"MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\\n\"\n\n    \"Lesser General Public License for more details.\\n\"\n\n    \"\\n\"\n\n    \"You should have received a copy of the GNU Lesser General Public\\n\"\n\n    \"License along with %s; if not, write to the Free Software\\n\"\n\n    \"Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA\\n\",\n\n    program_name, program_name, program_name\n\n#endif\n\n    );\n\n\n\n    return 0;\n\n}\n", "idx": 17765, "substitutes": {"optctx": [" optcb", "optionctx", " optcontext", "optioncontext", "propcontext", "optioncb", "optcontext", "optcas", "propcb", " optcas", "optioncas", "propcas", "propctx", "optcb"], "opt": ["program", "text", "expr", "dest", "image", "op", "options", "color", "Option", "job", "option", "type", "optim", "ext", "mem", "crit", "Opt", "prop", "path", "config", "asm", "cat", "parent", "mp", "param", "cut", "value", "target"], "arg": ["func", "call", "reg", "inc", "ar", "flag", "var", "Arg", "enc", "exec", "prop", "arc", "val", "path", "args", "ax", "asm", "par", "lib", "argument", "doc", "gen", "param", "proc", "amd", "word", "mac", "amp"]}}
{"project": "FFmpeg", "commit_id": "62c3c8ca78ee2da7dc20c2d6371866266c82966d", "target": 1, "func": "int ff_rtsp_make_setup_request(AVFormatContext *s, const char *host, int port,\n\n                              int lower_transport, const char *real_challenge)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    int rtx = 0, j, i, err, interleave = 0, port_off;\n\n    RTSPStream *rtsp_st;\n\n    RTSPMessageHeader reply1, *reply = &reply1;\n\n    char cmd[2048];\n\n    const char *trans_pref;\n\n\n\n    if (rt->transport == RTSP_TRANSPORT_RDT)\n\n        trans_pref = \"x-pn-tng\";\n\n    else\n\n        trans_pref = \"RTP/AVP\";\n\n\n\n    /* default timeout: 1 minute */\n\n    rt->timeout = 60;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n     * RTSP stream */\n\n\n\n    /* Choose a random starting offset within the first half of the\n\n     * port range, to allow for a number of ports to try even if the offset\n\n     * happens to be at the end of the random range. */\n\n    port_off = av_get_random_seed() % ((rt->rtp_port_max - rt->rtp_port_min)/2);\n\n    /* even random offset */\n\n    port_off -= port_off & 0x01;\n\n\n\n    for (j = rt->rtp_port_min + port_off, i = 0; i < rt->nb_rtsp_streams; ++i) {\n\n        char transport[2048];\n\n\n\n        /*\n\n         * WMS serves all UDP data over a single connection, the RTX, which\n\n         * isn't necessarily the first in the SDP but has to be the first\n\n         * to be set up, else the second/third SETUP will fail with a 461.\n\n         */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP &&\n\n             rt->server_type == RTSP_SERVER_WMS) {\n\n            if (i == 0) {\n\n                /* rtx first */\n\n                for (rtx = 0; rtx < rt->nb_rtsp_streams; rtx++) {\n\n                    int len = strlen(rt->rtsp_streams[rtx]->control_url);\n\n                    if (len >= 4 &&\n\n                        !strcmp(rt->rtsp_streams[rtx]->control_url + len - 4,\n\n                                \"/rtx\"))\n\n                        break;\n\n                }\n\n                if (rtx == rt->nb_rtsp_streams)\n\n                    return -1; /* no RTX found */\n\n                rtsp_st = rt->rtsp_streams[rtx];\n\n            } else\n\n                rtsp_st = rt->rtsp_streams[i > rtx ? i : i - 1];\n\n        } else\n\n            rtsp_st = rt->rtsp_streams[i];\n\n\n\n        /* RTP/UDP */\n\n        if (lower_transport == RTSP_LOWER_TRANSPORT_UDP) {\n\n            char buf[256];\n\n\n\n            if (rt->server_type == RTSP_SERVER_WMS && i > 1) {\n\n                port = reply->transports[0].client_port_min;\n\n                goto have_port;\n\n            }\n\n\n\n            /* first try in specified port range */\n\n            while (j <= rt->rtp_port_max) {\n\n                ff_url_join(buf, sizeof(buf), \"rtp\", NULL, host, -1,\n\n                            \"?localport=%d\", j);\n\n                /* we will use two ports per rtp stream (rtp and rtcp) */\n\n                j += 2;\n\n                if (!ffurl_open(&rtsp_st->rtp_handle, buf, AVIO_FLAG_READ_WRITE,\n\n                               &s->interrupt_callback, NULL))\n\n                    goto rtp_opened;\n\n            }\n\n\n\n            av_log(s, AV_LOG_ERROR, \"Unable to open an input RTP port\\n\");\n\n            err = AVERROR(EIO);\n\n            goto fail;\n\n\n\n        rtp_opened:\n\n            port = ff_rtp_get_local_rtp_port(rtsp_st->rtp_handle);\n\n        have_port:\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;\", trans_pref);\n\n            if (rt->server_type != RTSP_SERVER_REAL)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                     \"client_port=%d\", port);\n\n            if (rt->transport == RTSP_TRANSPORT_RTP &&\n\n                !(rt->server_type == RTSP_SERVER_WMS && i > 0))\n\n                av_strlcatf(transport, sizeof(transport), \"-%d\", port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_TCP) {\n\n            /* For WMS streams, the application streams are only used for\n\n             * UDP. When trying to set it up for TCP streams, the server\n\n             * will return an error. Therefore, we skip those streams. */\n\n            if (rt->server_type == RTSP_SERVER_WMS &&\n\n                (rtsp_st->stream_index < 0 ||\n\n                 s->streams[rtsp_st->stream_index]->codec->codec_type ==\n\n                    AVMEDIA_TYPE_DATA))\n\n                continue;\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/TCP;\", trans_pref);\n\n            if (rt->transport != RTSP_TRANSPORT_RDT)\n\n                av_strlcat(transport, \"unicast;\", sizeof(transport));\n\n            av_strlcatf(transport, sizeof(transport),\n\n                        \"interleaved=%d-%d\",\n\n                        interleave, interleave + 1);\n\n            interleave += 2;\n\n        }\n\n\n\n        else if (lower_transport == RTSP_LOWER_TRANSPORT_UDP_MULTICAST) {\n\n            snprintf(transport, sizeof(transport) - 1,\n\n                     \"%s/UDP;multicast\", trans_pref);\n\n        }\n\n        if (s->oformat) {\n\n            av_strlcat(transport, \";mode=receive\", sizeof(transport));\n\n        } else if (rt->server_type == RTSP_SERVER_REAL ||\n\n                   rt->server_type == RTSP_SERVER_WMS)\n\n            av_strlcat(transport, \";mode=play\", sizeof(transport));\n\n        snprintf(cmd, sizeof(cmd),\n\n                 \"Transport: %s\\r\\n\",\n\n                 transport);\n\n        if (rt->accept_dynamic_rate)\n\n            av_strlcat(cmd, \"x-Dynamic-Rate: 0\\r\\n\", sizeof(cmd));\n\n        if (i == 0 && rt->server_type == RTSP_SERVER_REAL && CONFIG_RTPDEC) {\n\n            char real_res[41], real_csum[9];\n\n            ff_rdt_calc_response_and_checksum(real_res, real_csum,\n\n                                              real_challenge);\n\n            av_strlcatf(cmd, sizeof(cmd),\n\n                        \"If-Match: %s\\r\\n\"\n\n                        \"RealChallenge2: %s, sd=%s\\r\\n\",\n\n                        rt->session_id, real_res, real_csum);\n\n        }\n\n        ff_rtsp_send_cmd(s, \"SETUP\", rtsp_st->control_url, cmd, reply, NULL);\n\n        if (reply->status_code == 461 /* Unsupported protocol */ && i == 0) {\n\n            err = 1;\n\n            goto fail;\n\n        } else if (reply->status_code != RTSP_STATUS_OK ||\n\n                   reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].lower_transport != rt->lower_transport ||\n\n                reply->transports[0].transport != rt->transport) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->lower_transport = reply->transports[0].lower_transport;\n\n            rt->transport = reply->transports[0].transport;\n\n        }\n\n\n\n        /* Fail if the server responded with another lower transport mode\n\n         * than what we requested. */\n\n        if (reply->transports[0].lower_transport != lower_transport) {\n\n            av_log(s, AV_LOG_ERROR, \"Nonmatching transport in server reply\\n\");\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        switch(reply->transports[0].lower_transport) {\n\n        case RTSP_LOWER_TRANSPORT_TCP:\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n\n\n        case RTSP_LOWER_TRANSPORT_UDP: {\n\n            char url[1024], options[30] = \"\";\n\n\n\n            if (rt->rtsp_flags & RTSP_FLAG_FILTER_SRC)\n\n                av_strlcpy(options, \"?connect=1\", sizeof(options));\n\n            /* Use source address if specified */\n\n            if (reply->transports[0].source[0]) {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL,\n\n                            reply->transports[0].source,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            } else {\n\n                ff_url_join(url, sizeof(url), \"rtp\", NULL, host,\n\n                            reply->transports[0].server_port_min, \"%s\", options);\n\n            }\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) &&\n\n                ff_rtp_set_remote_url(rtsp_st->rtp_handle, url) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            /* Try to initialize the connection state in a\n\n             * potential NAT router by sending dummy packets.\n\n             * RTP/RTCP dummy packets are used for RDT, too.\n\n             */\n\n            if (!(rt->server_type == RTSP_SERVER_WMS && i > 1) && s->iformat &&\n\n                CONFIG_RTPDEC)\n\n                ff_rtp_send_punch_packets(rtsp_st->rtp_handle);\n\n            break;\n\n        }\n\n        case RTSP_LOWER_TRANSPORT_UDP_MULTICAST: {\n\n            char url[1024], namebuf[50], optbuf[20] = \"\";\n\n            struct sockaddr_storage addr;\n\n            int port, ttl;\n\n\n\n            if (reply->transports[0].destination.ss_family) {\n\n                addr      = reply->transports[0].destination;\n\n                port      = reply->transports[0].port_min;\n\n                ttl       = reply->transports[0].ttl;\n\n            } else {\n\n                addr      = rtsp_st->sdp_ip;\n\n                port      = rtsp_st->sdp_port;\n\n                ttl       = rtsp_st->sdp_ttl;\n\n            }\n\n            if (ttl > 0)\n\n                snprintf(optbuf, sizeof(optbuf), \"?ttl=%d\", ttl);\n\n            getnameinfo((struct sockaddr*) &addr, sizeof(addr),\n\n                        namebuf, sizeof(namebuf), NULL, 0, NI_NUMERICHOST);\n\n            ff_url_join(url, sizeof(url), \"rtp\", NULL, namebuf,\n\n                        port, \"%s\", optbuf);\n\n            if (ffurl_open(&rtsp_st->rtp_handle, url, AVIO_FLAG_READ_WRITE,\n\n                           &s->interrupt_callback, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            break;\n\n        }\n\n        }\n\n\n\n        if ((err = rtsp_open_transport_ctx(s, rtsp_st)))\n\n            goto fail;\n\n    }\n\n\n\n    if (reply->timeout > 0)\n\n        rt->timeout = reply->timeout;\n\n\n\n    if (rt->server_type == RTSP_SERVER_REAL)\n\n        rt->need_subscription = 1;\n\n\n\n    return 0;\n\n\n\nfail:\n\n    ff_rtsp_undo_setup(s);\n\n    return err;\n\n}\n", "idx": 17766, "substitutes": {"s": ["ns", "spec", "ts", "sg", "sit", "t", "rs", "sv", "services", "service", "sb", "sl", "ss", "ls", "sec", "fs", "cs", "su", "acs", "sed", "ssl", "ses", "private", "c", "sam", "si", "S", "sci", "ks", "gs", "sys", "storage", "os", "server", "se", "sq", "sa", "ds", "sf"], "host": ["uri", "component", "proxy", "service", "auth", "method", "node", "localhost", "nick", "username", "ip", "link", "header", "path", "socket", "prefix", "remote", "ssl", "address", "test", "http", "domain", "Host", "server", "mac", "conn"], "port": ["uri", "plugin", "point", "code", "ort", "pod", "ports", "file", "hop", "channel", "stream", "type", "method", "cp", "ip", "profile", "path", "PORT", "pipe", "phone", "p", "address", "Port", "route", "message", "server"], "lower_transport": ["lower_transports", "lower_transpt", "lower_streampt", "lower_ranspt", "lower_transsource", "lower_ransource", "lower_ransp", "lower_transort", "lower_transrule", "lower_ranrule", "lower_transpace", "lower_ransort", "lower_userrule", "lower_hostports", "lower_mailort", "lower_usersource", "lower_streampace", "lower_middlePort", "lower_transPort", "lower_streamort", "lower_mailport", "lower_middleports", "lower_streamport", "lower_ranport", "lower_ranspace", "lower_userp", "lower_ransPort", "lower_mailpace", "lower_ranssource", "lower_transp", "lower_hostport", "lower_middlefile", "lower_ransfile", "lower_ransrule", "lower_hostfile", "lower_middleport", "lower_mailpt", "lower_hostPort", "lower_ransport", "lower_ransports", "lower_transfile", "lower_userport", "lower_ranp"], "real_challenge": ["real_dupe", "real_duplay", "real_challplay", "realparentchallpe", "real_openplay", "real_challonge", "real_protonge", "realparentopenplay", "real_protenge", "real_challpe", "realparentopenpe", "realparentopenenge", "real_protpe", "real_duenge", "real_duonge", "real_openonge", "real_openpe", "real_openenge", "realparentchallplay", "real_protplay", "realparentchallenge", "realparentopenonge", "realparentchallonge"], "rt": ["rx", "grad", "RT", "rr", "tt", "ret", "txt", "fr", "nd", "tr", "rs", "vr", "t", "NT", "ot", "ort", "ct", "gd", "rc", "r", "nt", "sett", "hd", "mot", "rh", "ut", "dt", "bt", "rf", "irt", "rat", "art", "att", "rd", "ott", "ht", "feat", "tx", "urt", "ru", "rn", "rot", "sr", "dr", "qt", "ant", "yt", "apt", "rl", "rb", "kt", "vt", "gt", "od", "dat", "adr", "error", "boot", "rect", "mt", "ft", "tp", "tm", "pt"], "j": ["jc", "m", "jl", "ji", "t", "x", "jp", "jit", "f", "uj", "qi", "r", "adj", "n", "jj", "job", "g", "z", "ii", "ij", "jet", "index", "ind", "aj", "dj", "o", "l", "d", "w", "J", "k", "q", "v", "si", "p", "xi", "b", "h", "ja", "y", "li"], "i": ["ti", "gi", "uri", "m", "bi", "ei", "ji", "x", "f", "jit", "ini", "qi", "r", "ai", "mi", "n", "io", "phi", "hi", "z", "ii", "ie", "ori", "iu", "index", "di", "ij", "I", "zi", "o", "ip", "l", "d", "yi", "pi", "uni", "ui", "ci", "id", "e", "v", "cli", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "api", "it", "eni", "fi", "y", "li", "u"], "err": ["status", "fr", "rr", "init", "ini", "ai", "result", "str", "ie", "ind", "ry", "resp", "out", "nil", "go", "aa", "aaa", "dr", "e", "req", "next", "error", "er", "server", "y"], "port_off": ["portenoa", "port___off", "port_data", "port67left", "key67left", "key_length", "port_pos", "port___max", "port_id", "port67name", "port_oa", "port2diff", "key_left", "key_and", "portfleft", "port67and", "port_Off", "key67off", "port64off", "port_length", "post_offset", "portenoff", "port_offset", "portenlength", "port6pos", "port67id", "portendata", "port67length", "port64name", "ort_max", "portflength", " port_id", "port___on", "portaldata", "portenand", "port_name", "ort_on", " port_data", "port6off", "portaloa", "ort_off", "post_pos", "portfoff", "key_off", "port_max", "port2off", "port_diff", "key67length", "port6offset", "portaloff", "portfand", "port___Off", "port2pos", "port64id", "portenleft", "port_and", " port_oa", "key67and", "ort_Off", "port6diff", "port67off", " port_name", "port_on", "post_off", "post_diff", "port_left", "port2offset"], "rtsp_st": ["rtsnp_ST", "rtspec_stream", "rtsp_sl", "rtsnp_sl", "rtsnp_stream", "rtsper_st", "rtsp_se", "rtsnp_se", "rtspec_est", "rtsnp_st", "rtsp_sts", "rtsper_sts", "rtsnp_str", "rtsp__se", "rtsp__str", "rtspec_stim", "rtsp_const", "rtsp_ST", "rtsp_stream", "rtsp_est", "rtsp__stream", "rtsper_const", "rtsp_stack", "rtspec_st", "rtsp__st", "rtsp_stim", "rtsper_stack", "rtsp_str"], "reply1": ["response2", "response1", "Reply2", "next0", "Reply1", " reply0", "response3", " reply2", "next1", "answer3", " reply3", "answer1", "Reply0", "reply2", "answer2", "next2", "reply3", "reply0"], "reply": ["entry", "code", "comment", "respond", "proxy", "result", "pack", "match", "msg", "resp", "ack", "flash", "link", "answer", "prefix", "response", "send", "respons", "address", " replies", "next", "route", "write", "connection", "frame", "reason", "Reply", "transfer"], "cmd": ["bin", "mode", " mac", " req", "rc", "comm", "root", "auth", "loc", "msg", "ctx", "bid", " auth", "Cmd", "box", "config", "buff", "batch", "req", "unit", "seq", "cap", "alloc", "opt", " command", "proc", "mac", "command"], "trans_pref": ["trans_perfor", "trans_rec", "trans_preef", "trans_Pref", "trans_Prec", "trans_ref", "trans_reef", "trans_perf", "trans_profor", "trans_foreef", "trans_prof", "trans_perfer", "trans_prefs", "trans_Prefs", "trans_forefer", "trans_brefs", "trans_profer", "trans_Prefer", "trans_proc", "trans_prefor", "trans_perc", "trans_prec", "trans_bref", "trans_brefer", "trans_prefer", "trans_brec", "trans_forec", "trans_forefor", "trans_peref", "trans_foref", "trans_perfs", "trans_refer"], "transport": ["ranstext", "Transtext", "Transp", "ransporter", "transporter", "interporter", " transform", "interports", "Transform", "transort", " transp", "ransports", "ransp", "Transport", "teleports", "teleport", "transtext", "interort", "teleporter", "teleort", "transp", "ransport", "transports", " transtext", "transform", "ransort", "interport", "ransform"], "rtx": ["retxp", "RTfx", "ttX", "retex", "rdX", "rotX", "rtz", "rotx", "rtex", "ntxs", "rtxp", "rtX", "retX", "rcxp", "rtxa", "ttz", "rotwy", "qtxes", "rotxb", "dtX", "ntxc", "aptX", "ortxs", "ttxb", "rtc", "rtwx", "ntX", "rtwy", "gtx", "ntz", "retx", "rrxc", "RTwy", "rdc", "drfx", "rtix", "vrX", "rtxs", "ttwy", "ttxs", "RTwx", "retxc", "rrwork", "RTxes", "retc", "rtxc", "dtx", "RTfe", "vrfx", "ttx", "drxc", "RTwork", "retxa", "ytex", "aptfe", "gtxy", "drx", "qtx", "rrx", "rdxc", "rcxa", "rcix", "retix", "rdx", "ytxc", "RTxc", "rtxes", "dtxy", "rcfx", "rotix", "rtxb", "dtv", "retfx", "ytx", "rtfx", "aptx", "ntx", "RTc", "aptxes", "ntwork", "RTv", "rtfe", "rcx", "RTX", "RTxy", "rtv", "rrX", "rotxa", "rtwork", "rcX", "rtxy", "vrx", "rotxp", "rcwx", "gtX", "ttxc", "ytfx", "ortxc", "qtfe", "gtv", "RTx", "RTxb", "vrwx", "ortz", "drex", "qtX", "ortx"], "buf": ["Buffer", "bin", "br", "func", "base", "pool", "buffer", "num", "block", "cb", "bc", "Buff", "wb", "mem", "ba", "conv", "box", "queue", "buff", "batch", "map", "pad", "b", "cap", "alloc", "proc", "bag", "uf"]}}
{"project": "FFmpeg", "commit_id": "24130234cd9dd733116d17b724ea4c8e12ce097a", "target": 0, "func": "static int parse_fmtp(AVFormatContext *s,\n\n                      AVStream *stream, PayloadContext *data,\n\n                      const char *attr, const char *value)\n\n{\n\n    AVCodecParameters *par = stream->codecpar;\n\n    int res, i;\n\n\n\n    if (!strcmp(attr, \"config\")) {\n\n        res = parse_fmtp_config(par, value);\n\n\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (par->codec_id == AV_CODEC_ID_AAC) {\n\n        /* Looking for a known attribute */\n\n        for (i = 0; attr_names[i].str; ++i) {\n\n            if (!av_strcasecmp(attr, attr_names[i].str)) {\n\n                if (attr_names[i].type == ATTR_NAME_TYPE_INT) {\n\n                    *(int *)((char *)data+\n\n                        attr_names[i].offset) = atoi(value);\n\n                } else if (attr_names[i].type == ATTR_NAME_TYPE_STR)\n\n                    *(char **)((char *)data+\n\n                        attr_names[i].offset) = av_strdup(value);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 17786, "substitutes": {"s": ["spec", "m", "session", "rs", "f", "sv", "r", "n", "g", "src", "fs", "parser", "o", "cs", "d", "w", "sc", "e", "v", "c", "ps", "p", "sys", "a", "server", "sq"], "stream": ["spec", "fr", "view", "reader", "feed", "ream", "document", "coll", "sw", "src", "raw", "ctx", "Stream", "object", "ack", "context", "rec", "cont", "path", "w", "config", "sc", "cur", "trans", "resource", "form", "row", "transform", "iv", "port", "server", "writer", "source", "input"], "data": ["uri", "na", "Data", "session", "offset", "extra", "record", "name", "base", "media", "shared", "buffer", "reg", "input", "type", "ctx", "this", "di", "def", "alpha", "parser", "context", "database", "d", "rec", "array", "size", "pre", "memory", "ui", "style", "aa", "config", "length", "parent", "req", "da", "p", "xml", "ada", "address", "cache", "resource", "dat", "ata", "la", "error", "api", "DATA", "addr", "decl", "ma", "bytes", "writer", "li", "reader"], "attr": ["uri", "at", "spec", "rr", "offset", "code", "expr", "name", "attribute", "op", "property", "r", "ann", "rt", "rel", "str", "option", "acc", "type", "method", "var", "kr", "tag", "arr", "arg", "att", "prop", "val", "format", "feat", "ac", "style", "config", "prefix", "apt", "atts", "url", "address", "pr", "cmp", "adr", "spr", "opt", "api", "air", "addr", "asc", "typ"], "value": ["uri", "values", "content", "Value", "request", "text", "func", "name", "attribute", "reader", "image", "media", "sv", "buffer", "info", "property", "r", "service", "option", "type", "var", "reference", "function", "model", "description", "parser", "object", "context", "pair", "val", "array", "format", "comp", "key", "pa", "v", "parent", "VALUE", "p", "variable", "address", "feature", "resource", "null", "param", "field", "write", "expression", "number", "message", "valid", "server", "version", "target"], "par": ["pc", "per", "spec", "jp", "sp", "r", "pe", "ar", "car", "rel", "cp", "var", "pol", "parser", "arg", "arr", "po", "pair", "parse", "pp", "pre", "pi", "pal", "comp", "serv", "pa", "dr", "parent", "cur", "ps", "cat", "Par", "req", "p", "mp", "prep", "pr", "cmp", "cap", "param", "proc", "peer", "pro", "params", "reader"], "res": ["ms", "ret", "rs", "core", "ras", "err", "rest", "ares", "rc", "results", "r", "reg", "result", "vals", "reed", "nos", "rh", "resolution", "Res", "RES", "resp", "cons", "min", "arr", "cs", "css", "sol", "ris", "val", "re", "ress", "gr", "resh", " results", "rar", "reset", "id", "ries", "rev", " Res", "req", "ps", "js", "rss", "rows", "p", "ids", "powers", "rep", "errors", "es", "os", "pres", "rem", "eps"], "i": ["ti", "uri", "gi", "bi", "init", "j", "ji", "t", "info", "f", "ix", "ini", "qi", "io", "mi", "ii", "ori", "ie", "di", "index", "ind", "iu", "I", "multi", "o", "ip", "l", "adi", "d", "oi", "yi", "idi", "pi", "ui", "ci", "id", "key", "e", "k", "v", "lc", "ni", "c", "si", "cli", "ri", "p", "xi", "b", "uli", "anti", "iv", "it", "eni", "fi", "source", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "4c8ca76965b1c29758246624940cbc529e7141f0", "target": 0, "func": "static int ffserver_set_int_param(int *dest, const char *value, int factor,\n\n                                  int min, int max, FFServerConfig *config,\n\n                                  const char *error_msg, ...)\n\n{\n\n    int tmp;\n\n    char *tailp;\n\n    if (!value || !value[0])\n\n        goto error;\n\n    errno = 0;\n\n    tmp = strtol(value, &tailp, 0);\n\n    if (tmp < min || tmp > max)\n\n        goto error;\n\n    if (factor) {\n\n        if (FFABS(tmp) > INT_MAX / FFABS(factor))\n\n            goto error;\n\n        tmp *= factor;\n\n    }\n\n    if (tailp[0] || errno)\n\n        goto error;\n\n    if (dest)\n\n        *dest = tmp;\n\n    return 0;\n\n  error:\n\n    if (config) {\n\n        va_list vl;\n\n        va_start(vl, error_msg);\n\n        vreport_config_error(config->filename, config->line_num, AV_LOG_ERROR,\n\n                &config->errors, error_msg, vl);\n\n        va_end(vl);\n\n    }\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 17787, "substitutes": {"dest": ["dc", "sup", "txt", "data", "rest", "name", "trip", "result", "option", "master", "src", "loc", "node", "orig", "wb", "di", "done", "dim", "prop", "later", "std", "cont", "path", "feat", "buf", "comb", "target", "temp", "trans", "dev", "output", "route", "opt", "proc", "Dest", "transform", "desc", "source", "dist", "len"], "value": ["values", "part", "content", "Value", "data", "element", "name", "attribute", "anything", "property", "input", "num", "type", "function", "object", "range", "vector", "val", "array", "format", "size", "key", "start", "wave", "prefix", "amount", "v", "temp", "parent", "unit", "VALUE", "test", "address", "null", "number", "message", "end", "valid", "diff", "source", "version", "target"], "factor": ["per", "part", "scale", "frac", "base", "f", "mult", "fe", "currency", "fac", "fc", "actor", "tier", "rf", "prop", "force", "cover", "std", "format", "cost", "size", "fact", "bf", "ffff", "fort", "length", "fd", "limit", "amount", "digit", "span", "unit", "frequency", "Factor", "total", "multipl", "rate", "feature", " factors", "radius", "period", "character", "number", "weight", "operator", "version", "round"], "min": ["init", "skip", "mod", "small", "mins", "from", "just", "lower", "little", "in", "pos", "count", "po", "range", "low", "val", "up", "first", "size", "pre", "pri", "start", "mid", "limit", "only", "span", "unit", "minimum", "Min", "mean", "MIN", "number", "diff", "len"], "max": ["part", "scale", "mod", "frac", "x", "base", "n", "alpha", "count", "out", "range", "val", "final", "d", "std", "up", "size", "step", "ax", "height", "last", "flow", "w", "q", "limit", "length", "v", "p", "total", "gen", "ension", "az", "end", "Max", "MAX", "ver"], "config": ["plugin", "cfg", "init", "content", "data", "text", "conf", "core", "comment", "settings", "attribute", "ini", "ct", "reg", "service", "inc", "channel", "cb", "bc", "gui", "src", "control", "ext", "fc", "acl", "ctx", "manager", "console", "ca", "exec", "design", "context", "contract", "fig", "path", "ci", "network", "queue", "Config", "front", "sc", "client", "lc", "c", "req", "qa", "lib", "driver", "test", "que", "cache", "subject", "output", "param", "storage", "proc", "connection", "project", "license", "source", "conn"], "error_msg": [" error_html", "ror_cmd", "ror_message", "error2msg", "error2message", " error_doc", "error_cmd", "error2Msg", " error_message", "error_doc", " error_Msg", "error_err", "error_message", "error2doc", "ror_msg", "ror_err", "error_Msg", "error_html"], "tmp": ["obj", "ref", "duration", "var", "fac", " temporary", "pb", "ptr", " src", " proto", "stuff", "prefix", "temp", "elt", "vt", "pad", "mp", "test", "area", "beta", "opt", "mm", "target", "Temp", "part", "tt", "sup", "txt", " property", "frac", " backup", "TB", "mult", "cp", "done", "bb", "perm", "force", "bf", "route", "kk", "amp", " len", "wp", "term", "fp", " temp", "f", " obj", " buf", " amp", "sb", "cb", "src", "loc", "abb", "nb", " result", "bps", "buf", "nom", "amount", "fb", "emp", "fee", "np", " addr", "now", "t", " ff", "ext", "bt", "prop", "treatment", "tc", "foo", "rb", "cmp", "tf", "storage", "proc", " resp", "api", " param", "tp", "diff", "attr", "dist"], "tailp": ["pullp", "letterp", "footp", "pullf", " tailbp", "letterpart", "terminpoint", "terminf", "leadP", " tailpart", "ailp", "tailbp", "ailpart", "tailpo", "tailprop", "leadbp", "tailpart", " tailP", "ailprop", "footar", "ailpo", "terminar", "fatpo", "letterprop", "tailar", "terminp", "pullar", " tailpo", "letterpo", "tailP", "leadpo", "pullpoint", "fatP", "footpoint", "footf", "leadp", " tailprop", "tailf", "tailpoint", "fatbp", "fatp"], "vl": ["vel", "fp", "las", "sv", "vc", "vp", " ls", "wl", "kl", "bp", "sl", "nl", "ls", "lp", "var", "pb", "dl", "owl", " l", "lv", "ml", "lf", "vm", "uv", "l", "tl", "LV", " li", "vol", "liv", "fl", "ln", "kb", "le", "aml", "cel", "ue", "hl", "lr", "ql", "lc", "rl", "ll", "lvl", "vv", "lan", "la", "adr", "isl", "ve", "li"]}}
{"project": "FFmpeg", "commit_id": "dc2e4c2e532b80565f5fbacd3a24a6db7567c257", "target": 0, "func": "static int64_t find_tag(AVIOContext *pb, uint32_t tag1)\n\n{\n\n    unsigned int tag;\n\n    int64_t size;\n\n\n\n    for (;;) {\n\n        if (url_feof(pb))\n\n            return AVERROR_EOF;\n\n        size = next_tag(pb, &tag);\n\n        if (tag == tag1)\n\n            break;\n\n        wav_seek_tag(pb, size, SEEK_CUR);\n\n    }\n\n    return size;\n\n}\n", "idx": 17792, "substitutes": {"pb": ["pc", "ab", "eb", "db", "bs", "fp", "obj", "jp", "platform", "pl", "sb", "pm", "bp", "cpp", "cb", "bc", "hub", "lp", "ctx", "fc", "xb", "lb", "abb", "PB", "dp", "pg", "rob", "bos", "pkg", "bps", "tc", "pa", "bh", "fb", "lc", "rb", "hp", "p", "mp", "peg", "b", "ppa", "proc", "api", "prot", "uf", "np", "cv", "ib"], "tag1": [" tag0", "tag11", "name2", " tag2", "codeOne", "code11", "nameOne", "tag2", "TAG2", "type2", "type1", "name1", "TAG0", "tag0", "tagOne", "type0", "TAG1", "code1", " tagOne", "code2", "name11", " tag11"], "tag": ["offset", "code", "name", "token", "image", "comment", "category", "reg", "pe", "or", "year", "type", "match", "loc", "month", "pos", " type", "count", "ee", "date", "head", "Tag", "bug", "feat", "ac", " match", " count", "style", "use", "length", "key", "id", "e", " format", "ag", " version", "age", "c", "TAG", "patch", "p", "peg", "tail", "number", "sign", "word", " bug", "attr", " length", "len"], "size": ["scale", "offset", "content", "capacity", "shape", "small", "code", "SIZE", "name", "time", "n", "sized", "g", "year", "type", "z", "loc", "six", "index", "pos", "slice", "timeout", "sec", "count", "speed", "empty", "style", "ize", "length", "id", "start", "e", "send", "sync", "c", "unit", "address", "fee", "cache", "sum", "ec", "body", "number", "weight", "Size", "bytes", "len"]}}
{"project": "FFmpeg", "commit_id": "d68c05380cebf563915412182643a8be04ef890b", "target": 0, "func": "av_cold void ff_float_dsp_init_x86(AVFloatDSPContext *fdsp)\n\n{\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n#if HAVE_6REGS && HAVE_INLINE_ASM\n\n    if (INLINE_AMD3DNOWEXT(cpu_flags)) {\n\n        fdsp->vector_fmul_window  = vector_fmul_window_3dnowext;\n\n    }\n\n    if (INLINE_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul_window = vector_fmul_window_sse;\n\n    }\n\n#endif\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_sse;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_sse;\n\n        fdsp->vector_fmul_scalar = ff_vector_fmul_scalar_sse;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_sse;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_sse;\n\n        fdsp->scalarproduct_float = ff_scalarproduct_float_sse;\n\n        fdsp->butterflies_float   = ff_butterflies_float_sse;\n\n    }\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_sse2;\n\n    }\n\n    if (EXTERNAL_AVX(cpu_flags)) {\n\n        fdsp->vector_fmul = ff_vector_fmul_avx;\n\n        fdsp->vector_fmac_scalar = ff_vector_fmac_scalar_avx;\n\n        fdsp->vector_dmul_scalar = ff_vector_dmul_scalar_avx;\n\n        fdsp->vector_fmul_add    = ff_vector_fmul_add_avx;\n\n        fdsp->vector_fmul_reverse = ff_vector_fmul_reverse_avx;\n\n    }\n\n}\n", "idx": 17803, "substitutes": {"fdsp": ["fedscope", "dlsp", "fcsb", "fedsb", "dfapp", "FDspe", "fdpy", "fdserv", "dfspe", "dlservice", "FDsk", "fxspace", "fdbc", "fcspec", "fxsr", "fcsr", "fxhtml", "fdso", "FDserv", "dlsb", "fcsp", "dlsh", "pdhtml", "fdst", "fxsp", "cfspec", "lfsp", "ffservice", "dlspec", "dfss", "fedss", "dlst", "fordsh", "fedsk", "dfsb", "fdsk", "fedsp", "fdsync", "dfsi", "dlsync", "fdapp", "lfsh", "fcsup", "fordsp", "fdhtml", "dlstatic", "fordsup", "fxspe", "fdsym", "fedsh", "dfhtml", "FDsp", "fdsi", "dfst", "ffscope", "dcst", "dfSp", "fxsync", "fcstatic", "ffsup", "FDSp", "pdsp", "fcsh", "dfbc", "dfsk", "fxscope", "fcserv", "fxspec", "ddso", "FDsr", "FDss", "fdsup", "lfscope", "cfsp", "dfsh", "fordsr", "dfscope", "dcsp", "FDscope", "dlapp", "FDsh", "ffspace", "ffpy", "dlbc", "fedSp", "ffsp", "ffsr", "dfcp", "fxsh", "fxserv", "pdapp", "fdSp", "fwsym", "fedpy", "ddsp", "fedspe", "ddspe", "fdsr", "dfserv", "fdsh", "dlhtml", "ddsync", "dlsi", "fxsb", "fdspe", "dlspe", "fedservice", "fdsb", "fcscope", "fxsk", "fdspace", "dfsr", "dfsync", "dlcp", "fdss", "dlsr", "fxsi", "dlpy", "fxso", "fxbc", "dcserv", "fwsp", "dlserv", "dfsp", "pdsi", "fxcp", "fcsi", "fdstatic", "fxsym", "cfscope", "ffsym", "FDbc", "dcbc", "ffsh", "dfspec", "lfstatic", "dlso", "dfso", "fedsi", "fdscope", "fcsk", "dlscope", "fwsh", "cfserv", "fdcp", "fwspace", "fdspec", "fdservice"]}}
{"project": "qemu", "commit_id": "096685fc2a955ea17d5363ab452e301be2b43873", "target": 1, "func": "static uint64_t omap2_inth_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    struct omap_intr_handler_s *s = (struct omap_intr_handler_s *) opaque;\n\n    int offset = addr;\n\n    int bank_no, line_no;\n\n    struct omap_intr_handler_bank_s *bank = NULL;\n\n\n\n    if ((offset & 0xf80) == 0x80) {\n\n        bank_no = (offset & 0x60) >> 5;\n\n        if (bank_no < s->nbanks) {\n\n            offset &= ~0x60;\n\n            bank = &s->bank[bank_no];\n\n\n\n\n        }\n\n    }\n\n\n\n    switch (offset) {\n\n    case 0x00:\t/* INTC_REVISION */\n\n        return s->revision;\n\n\n\n    case 0x10:\t/* INTC_SYSCONFIG */\n\n        return (s->autoidle >> 2) & 1;\n\n\n\n    case 0x14:\t/* INTC_SYSSTATUS */\n\n        return 1;\t\t\t\t\t\t/* RESETDONE */\n\n\n\n    case 0x40:\t/* INTC_SIR_IRQ */\n\n        return s->sir_intr[0];\n\n\n\n    case 0x44:\t/* INTC_SIR_FIQ */\n\n        return s->sir_intr[1];\n\n\n\n    case 0x48:\t/* INTC_CONTROL */\n\n        return (!s->mask) << 2;\t\t\t\t\t/* GLOBALMASK */\n\n\n\n    case 0x4c:\t/* INTC_PROTECTION */\n\n\n\n\n    case 0x50:\t/* INTC_IDLE */\n\n        return s->autoidle & 3;\n\n\n\n    /* Per-bank registers */\n\n    case 0x80:\t/* INTC_ITR */\n\n        return bank->inputs;\n\n\n\n    case 0x84:\t/* INTC_MIR */\n\n        return bank->mask;\n\n\n\n    case 0x88:\t/* INTC_MIR_CLEAR */\n\n    case 0x8c:\t/* INTC_MIR_SET */\n\n\n\n\n    case 0x90:\t/* INTC_ISR_SET */\n\n        return bank->swi;\n\n\n\n    case 0x94:\t/* INTC_ISR_CLEAR */\n\n\n\n\n    case 0x98:\t/* INTC_PENDING_IRQ */\n\n        return bank->irqs & ~bank->mask & ~bank->fiq;\n\n\n\n    case 0x9c:\t/* INTC_PENDING_FIQ */\n\n        return bank->irqs & ~bank->mask & bank->fiq;\n\n\n\n    /* Per-line registers */\n\n    case 0x100 ... 0x300:\t/* INTC_ILR */\n\n        bank_no = (offset - 0x100) >> 7;\n\n        if (bank_no > s->nbanks)\n\n            break;\n\n        bank = &s->bank[bank_no];\n\n        line_no = (offset & 0x7f) >> 2;\n\n        return (bank->priority[line_no] << 2) |\n\n                ((bank->fiq >> line_no) & 1);\n\n    }\n\n\n\n}", "idx": 17805, "substitutes": {"opaque": [" opque", "copaque", "obaques", "obaque", "OPaco", "pque", " opaco", "OPque", " opcode", "opcode", "paques", "opaco", "paque", "OPaque", "copque", "obque", "obcode", "opaques", "pcode", "copaco", "opque", " opaques"], "addr": ["point", "offset", "ocol", "Address", "data", "code", "x", "mode", "ref", "eth", "rc", "r", "align", "hop", "src", "node", "ptr", "pos", "byte", "pointer", "setup", " address", "nr", "alias", "oid", "ock", "prefix", "ad", "mid", "dr", "asm", "seq", "afi", "address", "pad", "ada", "adr", "sid", "ace", "amd", "mt", "mac", "amp", "len"], "size": ["offset", "data", "SIZE", "align", "block", "type", " bytes", "args", "ize", "length", "blocks", "address", "number", "a", "bytes", "Size", "len"], "s": ["ns", "ic", "spec", "words", "sky", "settings", "service", "ions", "ers", "ss", "als", "cs", "d", "new", "socket", "acks", "ant", "ments", "sym", "p", "ks", "h", "banks", "sets", "comments", "sa", "m", "ts", "sg", "rs", "aws", "self", "lines", "o", "sk", "su", "ing", "outs", "sc", " services", "v", "si", "S", "single", "a", "ings", "an", "ches", "ds", "f", "sv", "r", "sb", "or", "this", "l", "ins", "w", "sync", "c", "ps", "b", "sys", "your", "er", "es", "sq", "ies", "sf", "t", "rates", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "is", "parser", "ed", "space", "sites", "e", "ssl", "ses", "client", "support", "http", "gs", "storage", "its", "os", "south", "server", "se", "y", "u"], "bank_no": ["codeIDno", "bank_id", "bankJstate", "rule_number", "rule_code", "code_yes", "codeIDyes", "bank_eno", "bank_count", "code_nor", "bankJno", " bank_num", "bankIDmo", "code_no", "bank_mo", "bank_num", " bank_state", "work_yes", "bank_code", "Bank_no", "bank_name", "work_number", "bankJnumber", "bankIDyes", "bank_nor", "rule_no", "rule_note", " bank_NO", "bankFid", "bankIDcount", "bank_NO", "bankFcode", "bank_yes", "Bank_id", "codeIDname", "line_count", "bankFno", "Bank_code", " bank_number", "bankJeno", "bankIDnor", "bankIDname", "bankFyes", " bank_eno", "line_name", "bank_note", "Bank_yes", "codeIDnor", "line_mo", "bank_number", "bankIDno", "bank_state", "work_no", "work_nor", "code_name"], "line_no": ["flow_num", "Line_no", "Line_number", "flow_size", "block_number", "line_size", "line_No", "block_num", "bank_name", "line_num", "line_nr", "flow_no", "bank_na", "Line_eno", "block_no", "line_na", "line_sn", "line_name", "block_nr", "bank_number", "Line_sn", "flow_No", "line_eno", "line_number"], "bank": ["ic", "spec", "bi", "issue", "shadow", "child", "sky", "comment", "service", "library", "file", "bm", "pack", "anc", "Bank", "package", "machine", "rec", "prefix", "config", "ant", "account", "p", "feature", "banks", "scan", "command", "ve", "sa", "input", "board", "plugin", "bin", "work", "ank", "name", "bridge", "acc", "query", "app", "bb", "bird", "sk", "parse", "camp", "ay", "key", "sc", "pa", "k", "parent", "table", "can", "field", "order", "an", "view", "core", "base", "cookie", "plan", "sb", "root", "block", "type", "match", "node", "model", "byte", "bid", "ca", "go", "sn", "abi", "q", "ga", "b", "ban", "rate", "project", "pay", "book", "rank", "session", "group", "record", "data", "conf", "buffer", "feed", "g", "module", "parser", "bo", "gp", "rule", "pal", "com", "support", "bn", "cache", "error", "storage", "se", "u"]}}
{"project": "FFmpeg", "commit_id": "ebbcdc9ac0ea190748a1605bda86ce84466c8b4e", "target": 0, "func": "static inline void get_limits(MpegEncContext *s, int *range, int *xmin, int *ymin, int *xmax, int *ymax, int f_code)\n\n{\n\n    *range = 8 * (1 << (f_code - 1));\n\n    /* XXX: temporary kludge to avoid overflow for msmpeg4 */\n\n    if (s->out_format == FMT_H263 && !s->h263_msmpeg4)\n\n\t*range *= 2;\n\n\n\n    if (s->unrestricted_mv) {\n\n        *xmin = -16;\n\n        *ymin = -16;\n\n        if (s->h263_plus)\n\n            *range *= 2;\n\n        if(s->avctx->codec->id!=CODEC_ID_MPEG4){\n\n            *xmax = s->mb_width*16;\n\n            *ymax = s->mb_height*16;\n\n        }else {\n\n            *xmax = s->width;\n\n            *ymax = s->height;\n\n        }\n\n    } else {\n\n        *xmin = 0;\n\n        *ymin = 0;\n\n        *xmax = s->mb_width*16 - 16;\n\n        *ymax = s->mb_height*16 - 16;\n\n    }\n\n}\n", "idx": 17807, "substitutes": {"s": ["ns", "spec", "sky", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "sim", "self", "o", "su", "si", "S", "an", "ds", "f", "sb", "as", "l", "same", "w", "features", "bis", "sync", "c", "ps", "b", "sys", "your", "es", "states", "sq", "sf", "session", "t", "stats", "conf", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "is", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "parts", "se", "y", "u"], "range": ["scale", "fr", "offset", "cal", "lim", "view", "err", "call", "f", "base", "hide", "r", "ne", "role", "num", "query", "type", "Range", "max", "ge", " Range", "scope", "timeout", "date", "low", "gap", "force", "val", "array", "chain", "grade", "rule", "dy", "use", "no", "length", "ang", "ranged", "limit", "side", "span", "update", "line", "binary", "cache", "resource", "route", "domain", "row", "ange", "live", "repeat", "end", "diff", "version"], "xmin": ["xid", " xid", "Xstart", "ixmax", "Xmin", "axmin", "ixspan", "ystart", " xMin", "xspan", "Xid", "ixmin", "yMin", " xstart", "axmax", " xpart", "axstart", " xspan", "xstart", "xpart", "yid", "axpart", "yspan", "xMin", "Xmax", "ixMin", "ypart"], "ymin": ["rymon", "ymon", "ymit", "eymin", "Ymin", "mymid", "Ystart", "rymin", "xmid", " ymid", " ystart", "xmit", "ystart", "eymon", " ymon", "chmit", "chmin", "Ymon", "Ymini", "mystart", " ymit", "rystart", "ymid", "eymini", "chmon", "mymin", "xstart", "eystart", "rymini", "mymax", "chmax", "ymini", "xmon"], "xmax": ["yMAX", "Xend", "rxmin", "fxmin", "hmax", "Xmin", "hlast", "hmin", "Xdev", "rxlast", "yend", "mxmax", "fxlast", "xend", "xxend", "xxmax", "xxdev", "xxmin", "hend", "fxmax", "ylast", "xlast", "Xlast", "XMAX", "mxlast", "rxdev", "rxmax", "mxdev", "xdev", " xMAX", "fxend", "Xmax", "mxmin", "mxend", "xMAX"], "ymax": ["immax", "ymmase", "ymit", "ymaz", "ymase", "tmazon", "smaz", "smase", "mxax", "ymmatch", "mxatch", "immaz", "ymmax", "smazon", "ymmad", "ymad", "mxazon", "emmax", "emand", "pmand", "pmad", "iemase", "ymmand", "tmit", "emax", "iemoo", "tmatch", "ymoo", "dimatch", "ymazon", "mxase", "dimax", "iemax", "immase", "smax", "pmax", "ymmit", "dimazon", "dimit", "emad", "pmmax", "iemaz", "ymatch", "ymmmax", "ymand", "ymmazon", "smoo", "immoo", "tmax", "smatch"], "f_code": [" f_cod", "f_codes", "f6code", "f__codes", "c_id", "fqcode", "f__count", "fqid", "f__id", "f__code", "f_id", "c_count", "f6count", "f6codes", "c_codes", "f6cod", "c_code", "fqcodes", "fqcount", "f_cod", " f_count", " f_codes", "f_count"]}}
{"project": "FFmpeg", "commit_id": "931da6a5e9dd54563fe5d4d30b7bd4d0a0218c87", "target": 0, "func": "static int device_try_init(AVFormatContext *ctx,\n\n                           enum AVPixelFormat pix_fmt,\n\n                           int *width,\n\n                           int *height,\n\n                           uint32_t *desired_format,\n\n                           enum AVCodecID *codec_id)\n\n{\n\n    int ret, i;\n\n\n\n    *desired_format = avpriv_fmt_ff2v4l(pix_fmt, ctx->video_codec_id);\n\n\n\n    if (*desired_format) {\n\n        ret = device_init(ctx, width, height, *desired_format);\n\n        if (ret < 0) {\n\n            *desired_format = 0;\n\n            if (ret != AVERROR(EINVAL))\n\n                return ret;\n\n        }\n\n    }\n\n\n\n    if (!*desired_format) {\n\n        for (i = 0; avpriv_fmt_conversion_table[i].codec_id != AV_CODEC_ID_NONE; i++) {\n\n            if (ctx->video_codec_id == AV_CODEC_ID_NONE ||\n\n                avpriv_fmt_conversion_table[i].codec_id == ctx->video_codec_id) {\n\n                av_log(ctx, AV_LOG_DEBUG, \"Trying to set codec:%s pix_fmt:%s\\n\",\n\n                       avcodec_get_name(avpriv_fmt_conversion_table[i].codec_id),\n\n                       (char *)av_x_if_null(av_get_pix_fmt_name(avpriv_fmt_conversion_table[i].ff_fmt), \"none\"));\n\n\n\n                *desired_format = avpriv_fmt_conversion_table[i].v4l2_fmt;\n\n                ret = device_init(ctx, width, height, *desired_format);\n\n                if (ret >= 0)\n\n                    break;\n\n                else if (ret != AVERROR(EINVAL))\n\n                    return ret;\n\n                *desired_format = 0;\n\n            }\n\n        }\n\n\n\n        if (*desired_format == 0) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Cannot find a proper format for \"\n\n                   \"codec '%s' (id %d), pixel format '%s' (id %d)\\n\",\n\n                   avcodec_get_name(ctx->video_codec_id), ctx->video_codec_id,\n\n                   (char *)av_x_if_null(av_get_pix_fmt_name(pix_fmt), \"none\"), pix_fmt);\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n    }\n\n\n\n    *codec_id = avpriv_fmt_v4l2codec(*desired_format);\n\n    av_assert0(*codec_id != AV_CODEC_ID_NONE);\n\n    return ret;\n\n}\n", "idx": 17808, "substitutes": {"ctx": ["dc", "na", "wp", "grad", "instance", "cc", "session", "txt", "fw", "cal", "wx", "cca", "jp", "cor", "vc", "media", "component", "concept", "gc", "cm", "cf", "cpp", "coll", "anc", "cb", "cp", "loc", "bc", " context", "wcs", "git", "kw", "ctrl", "cas", "Context", "ca", "exec", "cs", "context", "hw", "cms", "conv", "kb", "pkg", "event", "tx", "ce", "ci", "tc", "config", "xc", "sc", "ga", "cam", "qt", "client", "cli", "sync", "c", "lc", "qa", "kt", "support", "uc", "ck", "sci", "cmp", "cn", "api", "connection", "mac", "progress", "cv", "conn"], "pix_fmt": ["pix_defwt", "pix_fformat", "pix_formmt", "pix_bMT", "pix_fMT", "pix_formMT", "pix_btt", "pix_formwt", "pix_bmt", "pix_bformat", "pix_tfformat", "pix_bfm", "pix_deftt", "pix_formfm", "pix_formtt", "pix_defmt", "pix_fwt", "pix_formformat", "pix_tffm", "pix_ffm", "pix_tfmt", "pix_bwt", "pix_ftt", "pix_defformat", "pix_tfMT"], "height": ["thin", "shape", "direction", "view", "volume", "image", "huge", "input", "window", "gh", "tight", "resolution", "padding", "above", "stroke", "dim", "inches", "upper", "gap", " heights", "hold", "size", "build", "w", "length", "high", "pull", "thumbnails", "deep", "layout", "history", "crop", "rows", "Height", "depth", "h", "row", "ty", "density", "images", "y", "bottom"], "desired_format": ["deserved_audio", "desired_unit", "desired24spec", "desired_language", "desired24format", "desiring_width", "desire_type", "deserved_format", "desirednattribute", "desired__transform", "desiring_type", "deserved_unit", "desired__version", "desirednformat", "desired_scale", "desired_width", "desire_unit", "desired_attribute", "desired__format", "desired_audio", "desired_flat", "desiring_service", "desire_form", "desiring_language", "desired_layout", "desire_layout", "desiring_transform", "desired_service", "deserved_spec", "desire_transform", "desirednflat", "desired_version", "desirable_format", "desired_spec", "desire_version", "desiring_version", "desirable_flat", "desiring_scale", "desirable_version", "desirable_attribute", "desired24audio", "desire_format", "desirednversion", "desiring_format", "desired_type", "desired24version", "desired_transform", "desired_form", "deserved_version", "desiring_unit"], "codec_id": ["codef_ip", "codecSID", "codec_ident", "codecSid", "codef2name", "codec2ip", "coduc_id", "codec_ID", "codic_info", "codec2ident", "codef_ident", "codec2id", "codec_type", "codec_ref", "codef2id", "codec_ids", "coduc_type", "codEC_id", "codEC_def", "codec_ip", "codef_id", "codic_ip", "codef2ip", "codec_in", "coduc_ref", "codef2ident", "codec_def", "codec_info", "codic_id", "codec_name", "codef_name", "codEC_type", "codic_ID", "coduc_in", "codEC_ids", "codec2name", "codecSinfo", "codecSip"], "ret": ["entry", "html", "x", "bit", "ref", "full", "obj", "nt", "result", "str", "att", "feat", "id", "fit", "rev", "pat", "rep", "res", "mt", "valid", "len", "part", "rc", "fun", "rf", "arg", "arr", "art", "Ret", "bf", "cat", "gt", "RET", "pret", "pet", "ft", "iter", "desc", "status", "code", "f", "alt", "lit", "r", "rt", "sb", "match", "bad", "val", "re", " result", "back", "sr", "rl", "py", "value", "reply", "success", "db", "t", "data", "info", "let", "reg", "flag", "pass", "active", "def", "rets", "en", "get", "lt", "format", "fail", "det", "req", "rb", "url", "error", "red", "usr"], "i": ["ti", "gi", "uri", "part", "bi", "m", "init", "j", "iii", "info", "f", "jp", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "g", "module", "ii", "ie", "di", "index", "ind", "iu", "I", "slice", "multi", "zi", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "e", "v", "lc", "ni", "si", "ki", "ri", "p", "xi", "ir", "b", "mu", "it", "eni", "fi", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "2f0772c5b4818d4b2078be9dace0036d1030faee", "target": 1, "func": "static void lsi_soft_reset(LSIState *s)\n\n{\n\n    lsi_request *p;\n\n\n\n    DPRINTF(\"Reset\\n\");\n\n    s->carry = 0;\n\n\n\n    s->msg_action = 0;\n\n    s->msg_len = 0;\n\n    s->waiting = 0;\n\n    s->dsa = 0;\n\n    s->dnad = 0;\n\n    s->dbc = 0;\n\n    s->temp = 0;\n\n    memset(s->scratch, 0, sizeof(s->scratch));\n\n    s->istat0 = 0;\n\n    s->istat1 = 0;\n\n    s->dcmd = 0x40;\n\n    s->dstat = LSI_DSTAT_DFE;\n\n    s->dien = 0;\n\n    s->sist0 = 0;\n\n    s->sist1 = 0;\n\n    s->sien0 = 0;\n\n    s->sien1 = 0;\n\n    s->mbox0 = 0;\n\n    s->mbox1 = 0;\n\n    s->dfifo = 0;\n\n    s->ctest2 = LSI_CTEST2_DACK;\n\n    s->ctest3 = 0;\n\n    s->ctest4 = 0;\n\n    s->ctest5 = 0;\n\n    s->ccntl0 = 0;\n\n    s->ccntl1 = 0;\n\n    s->dsp = 0;\n\n    s->dsps = 0;\n\n    s->dmode = 0;\n\n    s->dcntl = 0;\n\n    s->scntl0 = 0xc0;\n\n    s->scntl1 = 0;\n\n    s->scntl2 = 0;\n\n    s->scntl3 = 0;\n\n    s->sstat0 = 0;\n\n    s->sstat1 = 0;\n\n    s->scid = 7;\n\n    s->sxfer = 0;\n\n    s->socl = 0;\n\n    s->sdid = 0;\n\n    s->ssid = 0;\n\n    s->stest1 = 0;\n\n    s->stest2 = 0;\n\n    s->stest3 = 0;\n\n    s->sidl = 0;\n\n    s->stime0 = 0;\n\n    s->respid0 = 0x80;\n\n    s->respid1 = 0;\n\n    s->mmrs = 0;\n\n    s->mmws = 0;\n\n    s->sfs = 0;\n\n    s->drs = 0;\n\n    s->sbms = 0;\n\n    s->dbms = 0;\n\n    s->dnad64 = 0;\n\n    s->pmjad1 = 0;\n\n    s->pmjad2 = 0;\n\n    s->rbc = 0;\n\n    s->ua = 0;\n\n    s->ia = 0;\n\n    s->sbc = 0;\n\n    s->csbc = 0;\n\n    s->sbr = 0;\n\n    while (!QTAILQ_EMPTY(&s->queue)) {\n\n        p = QTAILQ_FIRST(&s->queue);\n\n        QTAILQ_REMOVE(&s->queue, p, next);\n\n        g_free(p);\n\n    }\n\n    if (s->current) {\n\n        g_free(s->current);\n\n        s->current = NULL;\n\n    }\n\n}\n", "idx": 17833, "substitutes": {"s": ["ns", "settings", "service", "ss", "cs", "d", "new", "qs", "ments", "by", "sym", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "ctr", "in", "o", "su", "the", "tests", "v", "si", "S", "a", "an", "ds", "ans", "status", "f", "r", "results", "type", "as", "this", "l", "ins", "features", "w", "vs", "sync", "c", "ps", "b", "sum", "sys", "your", "es", "addr", "states", "sq", "params", "session", "stats", "t", "conf", "data", "all", "services", "n", "has", "g", "i", "ats", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "_", "js", "seq", "http", "gs", "its", "os", "parts", "y", "u"], "p": ["pc", "wp", "m", "t", "data", "fp", "f", "jp", "op", "sp", "r", "o", "d", "pre", "w", "e", "q", "v", "c", "ps", "param", "proc", "pers", "os", "tp", "port", "params", "P"]}}
{"project": "FFmpeg", "commit_id": "bacc4b6e8173fa944c24f297435dc507a60efb10", "target": 1, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n", "idx": 17877, "substitutes": {"s": ["ns", "spec", "sky", "full", "settings", "service", "ss", "cs", "qs", "sym", "p", "ks", "us", "sets", "comments", "m", "sup", "ts", "sg", "sis", "aws", "self", "lines", "o", "su", "obs", "side", "si", "S", "hs", "ds", "core", "f", "sv", "sb", "current", "this", "l", "ins", "features", "sync", "c", "ps", "b", "sys", "es", "states", "sq", "np", "sf", "t", "stats", "conf", "services", "plugins", "g", "ls", "ops", "ctx", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "js", "gs", "os", "parts", "south", "u"], "icoef": ["iscef", "iceff", "coef", "icaEF", "coeb", "icoalf", "iliEF", "icoeff", "cieff", "icefined", "ciEF", "coEF", "cief", "icoeb", "iciff", "icaef", "icief", "icoefined", "icieff", "coeff", "iciefined", "iciiff", "iscouf", "iscalf", "ICOeff", "icaouf", "ichoeff", "icaalf", "ichoiff", "ICOef", "ilief", "cieb", "ichoef", "ilialf", "icoiff", "ichoefined", "iliouf", "icef", "ICOeb", "icoouf", "ICOEF", "iscEF", "icoEF"], "pred": ["ab", "stat", "ped", "code", "data", "info", "obj", "text", "core", "proof", "reg", "vec", "confirmed", "feed", "report", "result", "confidence", "cept", "cod", "loc", "lex", "pos", "ind", "model", "def", "sd", "surv", "gold", "pect", "Pred", "arr", "object", "prop", "score", "fitted", "val", "rec", "ed", "old", "future", "pre", "seed", "sub", "redict", "fit", "prev", "fb", "post", "p", "repl", "test", "expected", "support", "prep", "gen", "fn", "red", "rep", "tested", "pro", "cast", "callback", "valid", "eddy", "dict", " predict", "success", "dist"], "ich": ["ic", "x", "qi", "ai", "rich", "iche", "egg", "ie", "sh", "fact", "icht", "config", "ish", "ih", "hard", "ike", "igh", "arch", "h", "aff", "isc", "chip", "ei", "init", "cht", "isch", "ix", "cm", "hop", "chid", "inch", "ench", "Ch", "ig", "icy", "dom", "imp", "orient", "ocl", "code", "och", "che", "f", "ct", "ict", "mot", "rh", "ii", "di", "ind", "act", "anch", "chi", "host", "ht", "ICH", "ci", "q", "c", "chn", "cot", "ik", "ch", "irc", "channel", "g", "dim", "ip", "ach", "img", "ait", "intel", "interest", "im", "ill"], "i": ["ic", "ti", "gi", "uri", "ei", "bi", "sup", "m", "ik", "j", "ch", "ami", "t", "x", "f", "jp", "ix", "ini", "qi", "ai", "mi", "io", "phi", "g", "hi", "ii", "ori", "ie", "iu", "index", "ind", "I", "di", "in", "zi", "multi", "o", "ip", "chi", "l", "oi", "yi", "pi", "ui", "ci", "id", "e", "k", "ih", "isi", "c", "ni", "si", "v", "cli", "p", "xi", "ki", "ri", "ir", "b", "a", "api", "im", "it", "eni", "fi", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "198a0039c5fca224a77e9761e2350dd9cc102ad0", "target": 1, "func": "static void vnc_dpy_copy(DisplayState *ds, int src_x, int src_y, int dst_x, int dst_y, int w, int h)\n\n{\n\n    VncDisplay *vd = ds->opaque;\n\n    VncState *vs = vd->clients;\n\n    while (vs != NULL) {\n\n        if (vnc_has_feature(vs, VNC_FEATURE_COPYRECT))\n\n            vnc_copy(vs, src_x, src_y, dst_x, dst_y, w, h);\n\n        else /* TODO */\n\n            vnc_update(vs, dst_x, dst_y, w, h);\n\n        vs = vs->next;\n\n    }\n\n}\n", "idx": 17883, "substitutes": {"ds": ["ns", "dc", "Ds", "dd", "dn", "db", "bs", "rs", "gd", "dds", "md", "pd", "dh", "plays", "ys", "hd", "ss", "ls", "dt", "ld", "fs", "dl", "xs", "sd", "cs", "d", "df", "DS", "dm", "xd", "ps", "da", "sts", "ks", "gs", "cd", "uds"], "src_x": ["src00y", " src_no", " src_image", "src00xy", "src00image", " src_work", " src_xy", "src00work", "src_no", "src_work", "src_xy", "src_image", "src00no", "src00x"], "src_y": [" src_Y", "dest_y", "src_oy", "src_Y", "src_z", "dest_z", " src_ny", "dest_oy", "src_ny", "dest_x"], "dst_x": ["dest_id", "dsts_y", "dst_name", "dst_ix", "ddest_ix", "dsts_ux", "dest_y", "dst00y", "dst_ux", "dest_on", "dst00ux", "dst00name", "ddest_X", "dst00x", "ddest_y", "dst_id", "dst_on", "dsts_x", "dst_X", "ddest_x", "dest_x", "dsts_name"], "dst_y": ["dst_yi", "dstJz", "dstJy", "dst__y", "dst__ny", "dst__vy", "dest_vy", "dest_y", "dst_vy", "dst00ny", "dest_yi", "dst__x", "dst_z", "dst00yi", "dst00y", "dest_yl", "dst__yi", "dest_ny", "dstJvy", "dst_by", "dest_z", "dst00x", "dstJx", "dst_ny", "dstJby", "dest_by", "dst_yl", "dstJyl", "dst__by", "dest_x"], "w": ["m", "wt", "fw", "t", "wx", "x", "f", "r", "n", "wl", "we", "sw", "z", "max", "ow", "wb", "iw", "wd", "ew", "o", "l", "d", "hw", "W", "ww", "e", "q", "k", "v", "c", "p", "rw", "tw", "b", "win", "aw", "wa", "wh", "a", "y", "wy", "u"], "h": ["m", "ch", "t", "x", "f", "oh", "r", "g", "gh", "hi", "i", "hd", "z", "uh", "help", "en", "o", "host", "l", "d", "hw", "ht", "sh", "e", "q", "k", "bh", "v", "c", "p", "hm", "b", "hh", "ph", "wa", "ha", "hs", "H", "y", "u"], "vd": ["dc", "vid", "dn", "dd", "vg", "db", "nd", "gd", "vr", "sv", "vc", "vp", "pd", "dh", "sb", "hd", "dt", "ld", "dl", "wd", "sd", "lv", "vm", "VS", "d", "df", "VD", "dr", "v", "xd", "vt", "ud", "va", "nv"], "vs": ["ns", "ves", "ms", "ums", "vas", "vid", "fg", "ts", "s", "bs", "vg", "styles", "rs", "vr", "sv", "vc", "otes", "vp", "ils", "plugins", "vals", "forces", "plays", "cb", "ys", "ss", "ls", "ops", "fs", " VS", "vi", "xs", "vers", "sk", "vm", "cs", "VS", "prev", "Vs", "obs", "iss", "sr", "dr", "pps", "ov", "verts", "v", "alls", "qs", "ps", "vt", "sts", "versions", "ks", "va", "gs", "es", "os", "asts", "docs", "eps", "cv", "oss"]}}
{"project": "qemu", "commit_id": "da5361cc685c004d8bb4e7c5e7b3a52c7aca2c56", "target": 1, "func": "static int emulated_exitfn(CCIDCardState *base)\n\n{\n\n    EmulatedState *card = DO_UPCAST(EmulatedState, base, base);\n\n    VEvent *vevent = vevent_new(VEVENT_LAST, NULL, NULL);\n\n\n\n    vevent_queue_vevent(vevent); /* stop vevent thread */\n\n    qemu_mutex_lock(&card->apdu_thread_quit_mutex);\n\n    card->quit_apdu_thread = 1; /* stop handle_apdu thread */\n\n    qemu_cond_signal(&card->handle_apdu_cond);\n\n    qemu_cond_wait(&card->apdu_thread_quit_cond,\n\n                      &card->apdu_thread_quit_mutex);\n\n    /* handle_apdu thread stopped, can destroy all of it's mutexes */\n\n    qemu_cond_destroy(&card->handle_apdu_cond);\n\n    qemu_cond_destroy(&card->apdu_thread_quit_cond);\n\n    qemu_mutex_destroy(&card->apdu_thread_quit_mutex);\n\n    qemu_mutex_destroy(&card->handle_apdu_mutex);\n\n    qemu_mutex_destroy(&card->vreader_mutex);\n\n    qemu_mutex_destroy(&card->event_list_mutex);\n\n    return 0;\n\n}\n", "idx": 17885, "substitutes": {"base": ["status", "instance", "super", "db", "mod", "core", "name", "handle", "Base", "buffer", "file", "block", "type", "model", "create", "object", "ca", "home", "store", "class", "old", "zero", "build", "rule", "bu", "prefix", "id", "bas", "parent", "c", "lc", "builder", "address", "area", "cache", "b", "ace", "loop", "local", "state", "server"], "card": ["entry", "element", "comment", "thread", "gu", "service", "file", "cf", "role", "cas", "Card", "ck", "gen", "carry", "valid", "word", "die", "cc", "mod", "self", "controller", "load", "class", "parse", "read", "cards", "parent", "cat", "lc", "can", "play", "cell", "field", "row", "list", "cart", "dc", "code", "view", "core", "call", "component", "coll", "node", "this", "game", "ca", "arc", "host", "star", "back", "c", "check", "book", "bug", "record", "car", "module", "pass", "day", "create", "ce", "old", "event", "draw", "rule", "add", "man", "cl", "cache", "ard", "cast", "server", "custom"], "vevent": ["VEcf", "pevent", " vequest", "vequest", "evecf", "vecf", "evevent", "tection", "evegent", "pection", "tevent", " veevent", "eveevent", " vecf", "tegent", "peder", "eveder", "evequest", "VEevent", "pegent", "VEvent", "vection", "vegent", "veevent", "VEquest", "teder", "evection", "veder"]}}
{"project": "FFmpeg", "commit_id": "4691a77db4672026d62d524fd292fb17db6514b4", "target": 1, "func": "static inline int get_chroma_qp(H264Context *h, int qscale){\n\n    return h->pps.chroma_qp_table[qscale & 0xff];\n\n}\n", "idx": 17893, "substitutes": {"h": ["m", "ch", "t", "eh", "image", "oh", "n", "gh", "i", "cpp", "hd", "rh", "ctx", "host", "context", "hw", "header", "ht", "him", "sh", "ahi", "w", "hl", "q", "e", "bh", "ih", "v", "c", "hp", "p", "hm", "b", "http", "hh", "ec", "ph", "ha", "hs", "he", "ah", "H"], "qscale": ["eqset", "eqslice", "qualcale", "bitcale", "qqshape", "qualset", "bitset", " qcale", "qqcale", "bitscale", "qshape", "wcale", "eqscale", "eqcale", " qshape", "wshape", "qset", "wscale", "qcale", "qualscale", "qslice", "qqscale", "bitslice", "qualslice"]}}
{"project": "FFmpeg", "commit_id": "fe8c9420dd5bbc7a0c545e479da9118bcf311dd2", "target": 1, "func": "int AAC_RENAME(ff_ps_read_data)(AVCodecContext *avctx, GetBitContext *gb_host, PSContext *ps, int bits_left)\n\n{\n\n    int e;\n\n    int bit_count_start = get_bits_count(gb_host);\n\n    int header;\n\n    int bits_consumed;\n\n    GetBitContext gbc = *gb_host, *gb = &gbc;\n\n\n\n    header = get_bits1(gb);\n\n    if (header) {     //enable_ps_header\n\n        ps->enable_iid = get_bits1(gb);\n\n        if (ps->enable_iid) {\n\n            int iid_mode = get_bits(gb, 3);\n\n            if (iid_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"iid_mode %d is reserved.\\n\",\n\n                       iid_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_iid_par    = nr_iidicc_par_tab[iid_mode];\n\n            ps->iid_quant     = iid_mode > 2;\n\n            ps->nr_ipdopd_par = nr_iidopd_par_tab[iid_mode];\n\n        }\n\n        ps->enable_icc = get_bits1(gb);\n\n        if (ps->enable_icc) {\n\n            ps->icc_mode = get_bits(gb, 3);\n\n            if (ps->icc_mode > 5) {\n\n                av_log(avctx, AV_LOG_ERROR, \"icc_mode %d is reserved.\\n\",\n\n                       ps->icc_mode);\n\n                goto err;\n\n            }\n\n            ps->nr_icc_par = nr_iidicc_par_tab[ps->icc_mode];\n\n        }\n\n        ps->enable_ext = get_bits1(gb);\n\n    }\n\n\n\n    ps->frame_class = get_bits1(gb);\n\n    ps->num_env_old = ps->num_env;\n\n    ps->num_env     = num_env_tab[ps->frame_class][get_bits(gb, 2)];\n\n\n\n    ps->border_position[0] = -1;\n\n    if (ps->frame_class) {\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = get_bits(gb, 5);\n\n    } else\n\n        for (e = 1; e <= ps->num_env; e++)\n\n            ps->border_position[e] = (e * numQMFSlots >> ff_log2_tab[ps->num_env]) - 1;\n\n\n\n    if (ps->enable_iid) {\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_iid_data(avctx, gb, ps, ps->iid_par, huff_iid[2*dt+ps->iid_quant], e, dt))\n\n                goto err;\n\n        }\n\n    } else\n\n        memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n\n\n    if (ps->enable_icc)\n\n        for (e = 0; e < ps->num_env; e++) {\n\n            int dt = get_bits1(gb);\n\n            if (read_icc_data(avctx, gb, ps, ps->icc_par, dt ? huff_icc_dt : huff_icc_df, e, dt))\n\n                goto err;\n\n        }\n\n    else\n\n        memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n\n\n    if (ps->enable_ext) {\n\n        int cnt = get_bits(gb, 4);\n\n        if (cnt == 15) {\n\n            cnt += get_bits(gb, 8);\n\n        }\n\n        cnt *= 8;\n\n        while (cnt > 7) {\n\n            int ps_extension_id = get_bits(gb, 2);\n\n            cnt -= 2 + ps_read_extension_data(gb, ps, ps_extension_id);\n\n        }\n\n        if (cnt < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"ps extension overflow %d\\n\", cnt);\n\n            goto err;\n\n        }\n\n        skip_bits(gb, cnt);\n\n    }\n\n\n\n    ps->enable_ipdopd &= !PS_BASELINE;\n\n\n\n    //Fix up envelopes\n\n    if (!ps->num_env || ps->border_position[ps->num_env] < numQMFSlots - 1) {\n\n        //Create a fake envelope\n\n        int source = ps->num_env ? ps->num_env - 1 : ps->num_env_old - 1;\n\n        int b;\n\n        if (source >= 0 && source != ps->num_env) {\n\n            if (ps->enable_iid) {\n\n                memcpy(ps->iid_par+ps->num_env, ps->iid_par+source, sizeof(ps->iid_par[0]));\n\n            }\n\n            if (ps->enable_icc) {\n\n                memcpy(ps->icc_par+ps->num_env, ps->icc_par+source, sizeof(ps->icc_par[0]));\n\n            }\n\n            if (ps->enable_ipdopd) {\n\n                memcpy(ps->ipd_par+ps->num_env, ps->ipd_par+source, sizeof(ps->ipd_par[0]));\n\n                memcpy(ps->opd_par+ps->num_env, ps->opd_par+source, sizeof(ps->opd_par[0]));\n\n            }\n\n        }\n\n        if (ps->enable_iid){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (FFABS(ps->iid_par[ps->num_env][b]) > 7 + 8 * ps->iid_quant) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"iid_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        if (ps->enable_icc){\n\n            for (b = 0; b < ps->nr_iid_par; b++) {\n\n                if (ps->icc_par[ps->num_env][b] > 7U) {\n\n                    av_log(avctx, AV_LOG_ERROR, \"icc_par invalid\\n\");\n\n                    goto err;\n\n                }\n\n            }\n\n        }\n\n        ps->num_env++;\n\n        ps->border_position[ps->num_env] = numQMFSlots - 1;\n\n    }\n\n\n\n\n\n    ps->is34bands_old = ps->is34bands;\n\n    if (!PS_BASELINE && (ps->enable_iid || ps->enable_icc))\n\n        ps->is34bands = (ps->enable_iid && ps->nr_iid_par == 34) ||\n\n                        (ps->enable_icc && ps->nr_icc_par == 34);\n\n\n\n    //Baseline\n\n    if (!ps->enable_ipdopd) {\n\n        memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n        memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    }\n\n\n\n    if (header)\n\n        ps->start = 1;\n\n\n\n    bits_consumed = get_bits_count(gb) - bit_count_start;\n\n    if (bits_consumed <= bits_left) {\n\n        skip_bits_long(gb_host, bits_consumed);\n\n        return bits_consumed;\n\n    }\n\n    av_log(avctx, AV_LOG_ERROR, \"Expected to read %d PS bits actually read %d.\\n\", bits_left, bits_consumed);\n\nerr:\n\n    ps->start = 0;\n\n    skip_bits_long(gb_host, bits_left);\n\n    memset(ps->iid_par, 0, sizeof(ps->iid_par));\n\n    memset(ps->icc_par, 0, sizeof(ps->icc_par));\n\n    memset(ps->ipd_par, 0, sizeof(ps->ipd_par));\n\n    memset(ps->opd_par, 0, sizeof(ps->opd_par));\n\n    return bits_left;\n\n}\n", "idx": 17904, "substitutes": {"avctx": ["devctx", "devcu", " avContext", "afContext", "avlc", "verctx", "aflc", "devcf", "AVContext", "AVcu", "afcontext", "avContext", "evconn", "avconn", "afctx", "evctx", "vercf", "avcf", "vercu", "evcontext", "AVlc", "AVcf", "evlc", "afconn", " avlc", "AVctx", " avcontext", "AVconn", "AVcontext", "avcu", "avcontext", "vercontext", "devcontext"], "gb_host": ["rg_source", "gbamhost", "gg_port", "gg_component", "rg_server", "sb_host", "gg_server", "gbamaddress", "rgamserver", "gg_host", "gb_conn", "sb_address", "gb_server", "rgamhost", "rgamsource", "rgamaddress", "sb_conn", "gb_address", "sb_server", "rg_address", "gbamserver", "rg_host", "gb_port", "gbamsource", "gb_source", "gb_component"], "ps": ["ns", "pex", "options", "ports", "pl", "details", "files", "ss", "points", "pos", "cs", "als", "aps", "ims", "pse", "qs", "cop", "p", "ks", "pers", "pt", "pc", "ms", "ts", "rs", "times", "ips", "cp", "self", "posts", "lines", "sk", "changes", "pg", "pre", "style", "tests", "pa", "PS", "pes", "pr", "ups", "ds", "wp", "bs", "ys", "ins", "pps", "vs", "maps", "amps", "ppa", "pres", "eps", "params", "per", "ras", "sp", "pe", "plugins", "ats", "ls", "pass", "ops", "fs", "Ps", "css", "pp", "pull", "js", "http", "gs", "its", "parts", "tp", "ples"], "bits_left": ["bitsScontent", "bits_content", "bits_right", "bitsScount", "bits_count", " bits_content", " bits_count", "bitsSleft", "bitsSright", " bits_right"], "e": ["E", "element", "x", "debug", "ie", "pos", "ze", "d", "layer", "comp", "ev", "config", "ea", "p", "bytes", "end", "est", "m", "eb", "eg", "ei", "j", "eu", "ne", "de", "je", "ge", "y", "dt", "entity", "o", "ey", "v", "ele", "ec", "code", "f", "fe", "r", "see", "or", "this", "ae", "ee", "l", "ue", "c", "line", "ace", "er", "es", "edge", "esi", "s", "all", "buffer", "pe", "n", "g", "i", "z", "en", "ce", "event", "add", "oe", "_", "ade", "error", "body", "se", "el"], "header": ["rr", "offset", "skip", "request", "data", "fp", "metadata", "err", "f", "ref", "comment", "buffer", "duration", "bridge", "border", "result", "channel", "master", "type", "auth", "padding", "headers", "player", "index", "forward", "bb", "head", "numbered", "Header", "cover", "layer", "grade", "aster", "event", "length", "config", "dr", "parent", "position", "meta", "p", "table", "binary", "vv", "error", "h", "body", "frame", "valid", "server", "writer", "source", "version", "reader"], "bits_consumed": ["bits_comerved", "bits_comumed", "bits_consovered", "bits_colerved", "bits_comume", "bits_comovered", "bits_columed", "bits_colovered", "bits_colume", "bits_conserved", "bits_Consume", "bits_Consumed", "bits_consume", "bits_Conserved", "bits_Consovered"], "gb": ["pc", "gi", "gram", "cfg", "sg", "vg", "db", "eb", "gnu", "GB", "gd", "gal", "agg", "usb", "gc", "gg", "bm", "gae", "gom", "sb", "g", "gin", "cb", "bp", "hd", "bc", "hub", "gru", "ctx", "gam", "rg", "abb", "bb", "lb", "git", "nb", "game", "pg", "gp", "kb", "bf", "ui", "mb", "gl", "ga", "buff", "sync", "bg", "rb", "lib", "bn", "gz", "gs", "storage", "boot", "gy", "gm", "ha", "cgi", "ub"], "num_env": [" num__en", "num__exe", " num_exe", " num__exe", "numMvs", "nb_vs", "max_enc", "num_enc", "num_extra", "max_env", " num_vs", "num__vs", "num_vs", "nb_win", "num_en", "num_exe", "num_environment", "max_extra", " num_enc", "nb_enc", "num__env", " num_environment", "numMenv", "num_win", "num__en", "max_environment", "numallenv", " num__env", "numMexe", " num__vs", "numallenvironment", "numallextra", " num_en", "numMen", "nb_env", "numallenc"]}}
{"project": "FFmpeg", "commit_id": "4641ae352ec587355764ffd5c43dd0d0ebd47654", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908, "substitutes": {"s": ["ns", "spec", "m", "t", "f", "g", "i", "ops", "fs", "sec", "parser", "o", "cs", "d", "w", "e", "ssl", "c", "si", "p", "S", "b", "gs", "sys", "storage", "sets", "sq"], "st": ["ist", "est", "stat", "ts", "nd", "t", "rest", "ct", "sp", "ste", "td", "fe", "nt", "str", "sb", "ost", "stream", "sl", "ss", "src", "ctx", "ld", "sa", "ST", "sd", "sta", "art", "d", "std", "sn", "sc", "sth", "kt", "stage", "sts", "St", "inst", "a", "mt", "ft", "pt", "sf"], "pkt": ["hkt", "psacket", "tacket", "tke", "nacket", "tcp", "mct", "Pett", "hct", "wpct", " ppt", "wpcht", "tct", "Pcp", "pett", "Packet", "Pk", "tkt", " pett", "psct", "mpt", " pct", "packet", "Pcht", " packet", " pke", "hett", " pcht", "nct", "pspt", "pskt", "mkt", "nk", " pcp", "pct", "macket", "ppt", "nkt", "Pkt", "pcht", "wpkt", "Pct", "Ppt", "pk", "pke", "wpacket", " pk", "Pke", "pcp", "hacket"], "desc": ["dc", "txt", "code", "data", "info", "esc", "text", "dest", "dir", "ref", "name", "rc", "str", "pert", "cb", "bc", "src", "loc", "sel", "ext", "ptr", "des", "sec", "done", "def", "en", "description", "empty", "rec", "df", "std", "feat", "aux", "sub", "config", "id", "sc", "buf", "rev", "lc", "req", "seq", "meta", "uc", "Desc", "doc", "cmp", "dist", "proc", "cv", "success", "asc"], "ret": ["status", "offset", "data", "info", "ref", "alt", "rc", "gc", "reg", "lit", "fun", "nt", "result", "num", "match", "ext", "sec", "des", "mem", "resp", "rets", "en", "def", "att", "score", "val", "rec", "re", "Ret", "std", "feat", "back", "xt", "det", "rev", "cur", "cat", "seq", "gt", "RET", "error", "nz", "res", "opt", "reply", "success", "len"], "ast": ["at", "ist", "est", "ab", "esp", "nd", "af", "rest", "aste", "op", "ess", "alt", "eth", "nt", "ar", "ost", "AST", "am", "anc", "as", "node", "ap", "act", "atom", "parser", "sta", "art", "att", "host", "exec", "ta", "std", "aster", "ac", "Ast", "add", "ad", "asm", "sam", "post", "test", "mast", "od", "aw", "asting", "ace", "a", "inst", "ard", "cast", "amd", "ma", "end", "addr", "it", "asts", "sa", "amp"], "sub_demuxer": ["sub_demluxeder", "sub_demuxers", "sub_promxe", "sub_promxers", "sub_demxeder", "sub_demployler", "sub_demuxler", "sub_promuxeder", "sub_deuxler", "sub_demversler", "sub_promxeder", "sub_promployer", "sub_demxeri", "sub_dexer", "sub_demluxe", "sub_deuxer", "sub_promployers", "sub_promuxe", "sub_promuxers", "sub_demverser", "sub_demployeder", "sub_demployed", "sub_demxed", "sub_promuxeri", "sub_promxer", "sub_demployeri", "sub_demversers", "sub_deuxers", "sub_demxer", "sub_demuxe", "sub_demployer", "sub_demxers", "sub_promployeri", "sub_promuxed", "sub_demluxers", "sub_demxe", "sub_dexeri", "sub_demuxeri", "sub_promuxer", "sub_promployed", "sub_demxler", "sub_demuxeder", "sub_demversed", "sub_demverseri", "sub_demploye", "sub_demluxer", "sub_dexers", "sub_dexler", "sub_deuxeri", "sub_demuxed", "sub_demployers"], "time_base": ["TIME_cache", "time__buffer", "time_builder", "time__builder", "time__cache", "TIME_base", "time_cache", "time_buffer", "TIME_buffer", "TIME_builder", "time__base"], "size": ["offset", "extra", "x", "file", "num", "max", "pos", "sec", "enc", "score", "empty", "sh", "large", "length", "send", "bytes", "Size", "end", "len", "scale", "content", "name", "rc", "clean", "count", "last", "sc", "si", "loss", "iz", "gz", "weight", "term", "time", "code", "core", "SIZE", "f", "sized", "who", "loc", "sd", "speed", "grade", "go", "ci", "sn", "ize", "start", "sync", "c", "position", "address", "sent", "fee", "sum", "value", "capacity", "small", "data", "shape", "esc", "mode", "ng", "n", "channel", "g", "i", "day", "en", "args", "ui", "use", "e", "unit", "form", "storage", "body", "message"], "pb": ["pc", "wp", "ab", "plugin", "eb", "txt", "db", "fp", "jp", "platform", "vp", "pl", "bm", "stab", "sb", "pm", "bp", "cb", "bc", "cp", "hub", "lp", "wb", "ctx", "fc", "xb", "lb", "nb", "PB", "parser", "dp", "pg", "gb", "rob", "summary", "kb", "pkg", "bf", "bps", "sub", "abi", "pa", "bot", "buf", "fb", "bh", "lc", "primary", "rb", "tmp", "p", "b", "prot", "uf", "np", "ub", "pt", "lab", "ib", "typ"], "pd": ["pc", "wp", "plugin", "DP", " disp", "dd", "db", "pid", "cdn", "data", "gd", " def", "pod", "td", "px", "md", "pe", "edd", " dc", "pm", "hd", "cp", "lp", "vd", "dt", "dl", "ld", " data", " ta", "wd", " prod", "sd", "bb", "PB", "po", "dp", "pg", "wk", "d", " d", "pp", " sd", "pkg", "pi", " da", "bd", "ad", "fd", "pa", "raf", "xd", " dd", "PD", "p", "cmd", "da", "ud", "ppa", "od", " rc", "cd", " cd", " td", " cp", " df", "py", "tp", " DP", "np", "ds"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909, "substitutes": {"d": ["dc", "m", "dn", "dd", "db", "nd", "t", "data", "gd", "f", "md", "dh", "z", "vd", "dt", "ld", "dl", "sd", "o", "l", "std", "draw", "did", "w", "bd", "ad", "id", "fd", "e", "dr", "c", "dom", "D", "dev", "da", "p", "cmd", "od", "dat", "cd", "dad", "ds"]}}
{"project": "FFmpeg", "commit_id": "ac726a4f0cd2fb8619b478af51312a4282215f0e", "target": 0, "func": "static int movie_request_frame(AVFilterLink *outlink)\n\n{\n\n    AVFilterBufferRef *outpicref;\n\n    MovieContext *movie = outlink->src->priv;\n\n    int ret;\n\n\n\n    if (movie->is_done)\n\n        return AVERROR_EOF;\n\n    if ((ret = movie_get_frame(outlink)) < 0)\n\n        return ret;\n\n\n\n    outpicref = avfilter_ref_buffer(movie->picref, ~0);\n\n    ff_start_frame(outlink, outpicref);\n\n    ff_draw_slice(outlink, 0, outlink->h, 1);\n\n    ff_end_frame(outlink);\n\n    avfilter_unref_buffer(movie->picref);\n\n    movie->picref = NULL;\n\n\n\n    return 0;\n\n}\n", "idx": 17913, "substitutes": {"outlink": ["outline", "newstream", "inl", "atlink", "atline", "upload", "againlog", "outlinked", " outloop", "againlock", " outlog", "againLink", "downlink", "inLink", "actlink", "inlink", " outload", "opframe", "opink", " outline", "downlock", "outlive", "serverlive", "againink", "oplink", "oplock", " outlock", "offlink", "antlog", " outl", " outLink", "outink", "uplink", "outstyle", "againlink", "outstream", "againload", "antloop", "antlock", "actlive", "actlog", "againloop", "outlock", "offlinked", "outlog", "offstyle", "againline", "antlink", " outstyle", " outstream", "serverstyle", "serverlink", "offLink", "downlive", "outLink", "newLink", "downlog", "actstyle", "inlinked", "downink", "serverlog", "outloop", "againstream", "newlink", "newload", "outload", "outl", "newstyle", "upline", "outframe", "downstyle", "inload", "newlinked", "againframe", "atl", "atLink", "againlinked", " outlinked", "downframe", "uplinked"], "outpicref": ["inpicall", "outPicRef", "inPicref", "outPicall", "outlcref", "outPicurl", "Outnicreference", "outPicref", "inPicall", "outPicreference", "outpictref", "Outpicreference", "outlcreference", "outlcall", "inpicref", "OutnicRef", "OutpicRef", "outpicurl", "outnicreference", "outpicRef", "Outnicurl", "outpictreference", "outfcref", "outpicturl", "outnicurl", "outpicall", "outpicreference", "inpicRef", "outnicRef", "Outpicurl", "outfcall", "inPicRef", "Outnicref", "outfcreference", "outfcRef", "inpicreference", "inPicreference", "outlcRef", "Outpicref", "outnicref", "outpictRef"], "movie": ["hero", "move", "lot", "episode", "rama", "image", "comment", "media", "camera", "hide", "file", "fi", "money", "youtube", "show", "channel", "ani", "module", "coll", "anim", "make", "loader", "ie", "player", "mc", "manager", "nick", "game", "fake", "flash", "parse", "style", "img", "film", "cam", "Movie", "cop", "tv", "video", "doc", "pie", "play", "error", "music", "rame", "mpeg", "picture", "frame", "die", "motion", "cow", "voice", "bug"], "ret": ["code", "obj", "ref", "alt", "rc", "nt", "reg", "lit", "fun", "rt", "result", "job", "flag", "ext", "fin", "run", "mem", "def", "rets", "en", "out", "arg", "att", "arr", "art", "bad", "val", "re", "Ret", " RET", "det", "rev", " Ret", "RET", "red", "rep", "res", "end", "valid", "rem", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "89d4d7d759a59e8535b267b7f5af757f731da712", "target": 1, "func": "static void process_client(AVIOContext *client, const char *in_uri)\n\n{\n\n    AVIOContext *input = NULL;\n\n    uint8_t buf[1024];\n\n    int ret, n, reply_code;\n\n    uint8_t *resource = NULL;\n\n    while ((ret = avio_handshake(client)) > 0) {\n\n        av_opt_get(client, \"resource\", AV_OPT_SEARCH_CHILDREN, &resource);\n\n        // check for strlen(resource) is necessary, because av_opt_get()\n\n        // may return empty string.\n\n        if (resource && strlen(resource))\n\n            break;\n\n\n    }\n\n    if (ret < 0)\n\n        goto end;\n\n    av_log(client, AV_LOG_TRACE, \"resource=%p\\n\", resource);\n\n    if (resource && resource[0] == '/' && !strcmp((resource + 1), in_uri)) {\n\n        reply_code = 200;\n\n    } else {\n\n        reply_code = AVERROR_HTTP_NOT_FOUND;\n\n    }\n\n    if ((ret = av_opt_set_int(client, \"reply_code\", reply_code, AV_OPT_SEARCH_CHILDREN)) < 0) {\n\n        av_log(client, AV_LOG_ERROR, \"Failed to set reply_code: %s.\\n\", av_err2str(ret));\n\n        goto end;\n\n    }\n\n    av_log(client, AV_LOG_TRACE, \"Set reply code to %d\\n\", reply_code);\n\n\n\n    while ((ret = avio_handshake(client)) > 0);\n\n\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    fprintf(stderr, \"Handshake performed.\\n\");\n\n    if (reply_code != 200)\n\n        goto end;\n\n    fprintf(stderr, \"Opening input file.\\n\");\n\n    if ((ret = avio_open2(&input, in_uri, AVIO_FLAG_READ, NULL, NULL)) < 0) {\n\n        av_log(input, AV_LOG_ERROR, \"Failed to open input: %s: %s.\\n\", in_uri,\n\n               av_err2str(ret));\n\n        goto end;\n\n    }\n\n    for(;;) {\n\n        n = avio_read(input, buf, sizeof(buf));\n\n        if (n < 0) {\n\n            if (n == AVERROR_EOF)\n\n                break;\n\n            av_log(input, AV_LOG_ERROR, \"Error reading from input: %s.\\n\",\n\n                   av_err2str(n));\n\n            break;\n\n        }\n\n        avio_write(client, buf, n);\n\n        avio_flush(client);\n\n    }\n\nend:\n\n    fprintf(stderr, \"Flushing client\\n\");\n\n    avio_flush(client);\n\n    fprintf(stderr, \"Closing client\\n\");\n\n    avio_close(client);\n\n    fprintf(stderr, \"Closing input\\n\");\n\n    avio_close(input);\n\n\n}", "idx": 17929, "substitutes": {"client": ["pc", "util", "plugin", "session", "global", "request", "child", "core", "reader", "call", "google", "image", "conn", "service", "chrome", "worker", "current", "clean", "cod", "public", "ctx", "container", "host", "context", "secure", "ce", "path", "ac", "socket", "con", "config", "prefix", "ssl", "remote", "cli", "cat", "c", "open", "batch", "parent", "private", "uc", "cl", "cache", "http", "cell", "consumer", "product", "wrapper", "Client", "api", "local", "connection", "project", "cn", "port", "server", "mac", "custom", "connect"], "in_uri": [" in_collection", "in_collection", "in_resource", "inpri", "in_path", " in_resource", "invaluri", "In_binary", " in_URI", "invalcollection", "inpURI", "inppath", "inpuri", "invalURI", "in_ri", " in_ri", " in_filename", "In_ri", "in_binary", " in_path", "invalfilename", "In_uri", "in_filename", "in_URI", "In_URI"], "input": ["entry", "dc", "util", "plugin", "instance", "bin", "session", "init", "request", "data", "view", "reader", "child", "image", "text", "buffer", "inc", "current", "stream", "i", "in", "accept", "active", "act", "container", "context", "Input", "event", "ac", "import", "socket", "back", "img", "config", "queue", "id", "pull", "ssl", "batch", "cli", "temp", "cat", "include", "qa", "uc", "binary", "url", "http", "output", "interface", "form", "storage", "field", "api", "local", "connection", "list", "server", "command", "inner", "source"], "buf": ["Buffer", "br", "ff", "data", "text", "err", "pool", "buffer", "rc", "vec", "window", "cb", "block", "bc", "msg", "raw", "ctx", "wb", "pb", "cas", "context", "header", "box", "queue", "config", "fd", "buff", "batch", "fb", "map", "c", "temp", "rb", "seq", "tmp", "uc", "cmd", "b", "cache", "output", "cap", "alloc", " buffer", "port", "bag", "uf", "cv"], "ret": ["br", "obj", "al", "ref", "nt", "result", "str", "job", "ut", "att", "store", "reset", "rev", "repl", "pat", "res", "mt", "prot", "len", "part", "j", "sur", "rest", "rc", "ne", "fun", "fin", "timeout", "rf", "resp", "arg", "art", "Ret", "bf", "cat", "RET", "pet", "ft", "iter", "rem", "ner", "err", "alt", "lit", "rt", "sb", "match", "nl", "mem", "nb", "ry", "val", "re", " RET", "back", "sr", "post", "rl", "detail", "er", "reply", "success", "db", "t", "info", "reg", "flag", "ext", "def", "rets", "en", "out", "old", "fail", "det", "bot", "cur", "rb", "url", "ur", "error", "red", "usr"], "n": ["ns", "not", "na", "m", "ner", "dn", "j", "s", "gn", "t", "un", "x", "f", "name", "pn", "ng", "r", "nt", "ne", "num", "N", "g", "i", "nor", "z", "nl", "node", "pos", "nb", "min", "en", "count", "nat", "o", "l", "d", "nr", "nc", "size", "no", "sn", "nu", "rn", "k", "e", "c", "ni", "p", "none", "b", "fn", "cn", "number", "body", "nn", "an", "y", "conn", "len"], "reply_code": ["reply67code", "reply_number", "response_codes", "response_coded", "replyxCode", "reply_text", "replyalcount", "replyalnumber", "reply_count", "replyaccoded", "replySline", "reply_handler", "replySnumber", "reply_coded", "replyflowcodes", "reply_start", "replyflowhandler", "replyIPcount", "replyflownumber", "reply_codes", "response_cod", "replyachandler", "replyxcode", "replyingcodes", "replyingcod", "replyflowCode", "replyflowcod", "repl_code", "replyIPcode", "replyaccount", "replyScount", "reply_line", "repl_start", "replyIPcoded", "replyxhandler", "replyflowcode", "repl_class", "reply67codes", "reply_cod", "response_number", "replyingcode", "response_handler", "replyalcode", "reply_class", "response_Code", "replyxcodes", " reply_codes", "response_code", "replyingnumber", "reply_Code", " reply_count", "response_line", "replyIPhandler", "reply67text", " reply_text", "replyalline", "response_count", "reply67count", "replyScode", "replyaccode", "repl_codes"], "resource": ["uri", "rage", "content", "record", "offset", "request", "data", "core", "rest", "search", "ref", "attribute", "token", "media", "name", "buffer", "Resource", "r", "random", "file", "result", "channel", "document", "query", "region", "type", "src", "reference", "resources", "rg", "scope", "index", "byte", "password", "progress", "replace", "pointer", "range", "context", "re", "event", "rule", "value", "config", "response", "sr", "prefix", "remote", "ruby", "id", "parent", "ri", "url", "address", "output", "error", "res", "number", "character", "connection", "project", "rect", "message", "server", "operation", "reply", "source", "reader"]}}
{"project": "FFmpeg", "commit_id": "cec939597722663f322941b4c12e00a583e63504", "target": 1, "func": "static inline void pred_direct_motion(H264Context * const h, int *mb_type){\n\n    MpegEncContext * const s = &h->s;\n\n    const int mb_xy =   s->mb_x +   s->mb_y*s->mb_stride;\n\n    const int b8_xy = 2*s->mb_x + 2*s->mb_y*h->b8_stride;\n\n    const int b4_xy = 4*s->mb_x + 4*s->mb_y*h->b_stride;\n\n    const int mb_type_col = h->ref_list[1][0].mb_type[mb_xy];\n\n    const int16_t (*l1mv0)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[0][b4_xy];\n\n    const int16_t (*l1mv1)[2] = (const int16_t (*)[2]) &h->ref_list[1][0].motion_val[1][b4_xy];\n\n    const int8_t *l1ref0 = &h->ref_list[1][0].ref_index[0][b8_xy];\n\n    const int8_t *l1ref1 = &h->ref_list[1][0].ref_index[1][b8_xy];\n\n    const int is_b8x8 = IS_8X8(*mb_type);\n\n    int sub_mb_type;\n\n    int i8, i4;\n\n\n\n    if(IS_8X8(mb_type_col) && !h->sps.direct_8x8_inference_flag){\n\n        /* FIXME save sub mb types from previous frames (or derive from MVs)\n\n         * so we know exactly what block size to use */\n\n        sub_mb_type = MB_TYPE_8x8|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_4x4 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }else if(!is_b8x8 && (IS_16X16(mb_type_col) || IS_INTRA(mb_type_col))){\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_16x16 */\n\n    }else{\n\n        sub_mb_type = MB_TYPE_16x16|MB_TYPE_P0L0|MB_TYPE_P0L1|MB_TYPE_DIRECT2; /* B_SUB_8x8 */\n\n        *mb_type =    MB_TYPE_8x8|MB_TYPE_L0L1;\n\n    }\n\n    if(!is_b8x8)\n\n        *mb_type |= MB_TYPE_DIRECT2;\n\n\n\n    tprintf(\"mb_type = %08x, sub_mb_type = %08x, is_b8x8 = %d, mb_type_col = %08x\\n\", *mb_type, sub_mb_type, is_b8x8, mb_type_col);\n\n\n\n    if(h->direct_spatial_mv_pred){\n\n        int ref[2];\n\n        int mv[2][2];\n\n        int list;\n\n\n\n        /* ref = min(neighbors) */\n\n        for(list=0; list<2; list++){\n\n            int refa = h->ref_cache[list][scan8[0] - 1];\n\n            int refb = h->ref_cache[list][scan8[0] - 8];\n\n            int refc = h->ref_cache[list][scan8[0] - 8 + 4];\n\n            if(refc == -2)\n\n                refc = h->ref_cache[list][scan8[0] - 8 - 1];\n\n            ref[list] = refa;\n\n            if(ref[list] < 0 || (refb < ref[list] && refb >= 0))\n\n                ref[list] = refb;\n\n            if(ref[list] < 0 || (refc < ref[list] && refc >= 0))\n\n                ref[list] = refc;\n\n            if(ref[list] < 0)\n\n                ref[list] = -1;\n\n        }\n\n\n\n        if(ref[0] < 0 && ref[1] < 0){\n\n            ref[0] = ref[1] = 0;\n\n            mv[0][0] = mv[0][1] =\n\n            mv[1][0] = mv[1][1] = 0;\n\n        }else{\n\n            for(list=0; list<2; list++){\n\n                if(ref[list] >= 0)\n\n                    pred_motion(h, 0, 4, list, ref[list], &mv[list][0], &mv[list][1]);\n\n                else\n\n                    mv[list][0] = mv[list][1] = 0;\n\n            }\n\n        }\n\n\n\n        if(ref[1] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L1;\n\n            sub_mb_type &= ~MB_TYPE_P0L1;\n\n        }else if(ref[0] < 0){\n\n            *mb_type &= ~MB_TYPE_P0L0;\n\n            sub_mb_type &= ~MB_TYPE_P0L0;\n\n        }\n\n\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref[0], 1);\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, ref[1], 1);\n\n            if(!IS_INTRA(mb_type_col)\n\n               && (   (l1ref0[0] == 0 && ABS(l1mv0[0][0]) <= 1 && ABS(l1mv0[0][1]) <= 1)\n\n                   || (l1ref0[0]  < 0 && l1ref1[0] == 0 && ABS(l1mv1[0][0]) <= 1 && ABS(l1mv1[0][1]) <= 1\n\n                       && (h->x264_build>33 || !h->x264_build)))){\n\n                if(ref[0] > 0)\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                if(ref[1] > 0)\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                else\n\n                    fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                fill_rectangle(&h->mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n\n\n                fill_rectangle(&h->mv_cache[0][scan8[i8*4]], 2, 2, 8, pack16to32(mv[0][0],mv[0][1]), 4);\n\n                fill_rectangle(&h->mv_cache[1][scan8[i8*4]], 2, 2, 8, pack16to32(mv[1][0],mv[1][1]), 4);\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref[0], 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, ref[1], 1);\n\n\n\n                /* col_zero_flag */\n\n                if(!IS_INTRA(mb_type_col) && (   l1ref0[x8 + y8*h->b8_stride] == 0\n\n                                              || (l1ref0[x8 + y8*h->b8_stride] < 0 && l1ref1[x8 + y8*h->b8_stride] == 0\n\n                                                  && (h->x264_build>33 || !h->x264_build)))){\n\n                    const int16_t (*l1mv)[2]= l1ref0[x8 + y8*h->b8_stride] == 0 ? l1mv0 : l1mv1;\n\n                    for(i4=0; i4<4; i4++){\n\n                        const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                        if(ABS(mv_col[0]) <= 1 && ABS(mv_col[1]) <= 1){\n\n                            if(ref[0] == 0)\n\n                                *(uint32_t*)h->mv_cache[0][scan8[i8*4+i4]] = 0;\n\n                            if(ref[1] == 0)\n\n                                *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] = 0;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n        }\n\n    }else{ /* direct temporal mv pred */\n\n        if(IS_16X16(*mb_type)){\n\n            fill_rectangle(&h->ref_cache[1][scan8[0]], 4, 4, 8, 0, 1);\n\n            if(IS_INTRA(mb_type_col)){\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, 0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, 0, 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, 0, 4);\n\n            }else{\n\n                const int ref0 = l1ref0[0] >= 0 ? h->map_col_to_list0[0][l1ref0[0]]\n\n                                                : h->map_col_to_list0[1][l1ref1[0]];\n\n                const int dist_scale_factor = h->dist_scale_factor[ref0];\n\n                const int16_t *mv_col = l1ref0[0] >= 0 ? l1mv0[0] : l1mv1[0];\n\n                int mv_l0[2];\n\n                mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                fill_rectangle(&h->ref_cache[0][scan8[0]], 4, 4, 8, ref0, 1);\n\n                fill_rectangle(&h-> mv_cache[0][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0],mv_l0[1]), 4);\n\n                fill_rectangle(&h-> mv_cache[1][scan8[0]], 4, 4, 8, pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]), 4);\n\n            }\n\n        }else{\n\n            for(i8=0; i8<4; i8++){\n\n                const int x8 = i8&1;\n\n                const int y8 = i8>>1;\n\n                int ref0, dist_scale_factor;\n\n                const int16_t (*l1mv)[2]= l1mv0;\n\n\n\n                if(is_b8x8 && !IS_DIRECT(h->sub_mb_type[i8]))\n\n                    continue;\n\n                h->sub_mb_type[i8] = sub_mb_type;\n\n                if(IS_INTRA(mb_type_col)){\n\n                    fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                    fill_rectangle(&h-> mv_cache[0][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    fill_rectangle(&h-> mv_cache[1][scan8[i8*4]], 2, 2, 8, 0, 4);\n\n                    continue;\n\n                }\n\n\n\n                ref0 = l1ref0[x8 + y8*h->b8_stride];\n\n                if(ref0 >= 0)\n\n                    ref0 = h->map_col_to_list0[0][ref0];\n\n                else{\n\n                    ref0 = h->map_col_to_list0[1][l1ref1[x8 + y8*h->b8_stride]];\n\n                    l1mv= l1mv1;\n\n                }\n\n                dist_scale_factor = h->dist_scale_factor[ref0];\n\n\n\n                fill_rectangle(&h->ref_cache[0][scan8[i8*4]], 2, 2, 8, ref0, 1);\n\n                fill_rectangle(&h->ref_cache[1][scan8[i8*4]], 2, 2, 8, 0, 1);\n\n                for(i4=0; i4<4; i4++){\n\n                    const int16_t *mv_col = l1mv[x8*2 + (i4&1) + (y8*2 + (i4>>1))*h->b_stride];\n\n                    int16_t *mv_l0 = h->mv_cache[0][scan8[i8*4+i4]];\n\n                    mv_l0[0] = (dist_scale_factor * mv_col[0] + 128) >> 8;\n\n                    mv_l0[1] = (dist_scale_factor * mv_col[1] + 128) >> 8;\n\n                    *(uint32_t*)h->mv_cache[1][scan8[i8*4+i4]] =\n\n                        pack16to32(mv_l0[0]-mv_col[0],mv_l0[1]-mv_col[1]);\n\n                }\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 17932, "substitutes": {"h": ["m", "ch", "t", "eh", "x", "f", "oh", "r", "hr", "n", "dh", "gh", "g", "cpp", "hi", "sw", "z", "rh", "i", "th", "y", "en", "o", "home", "host", "l", "hw", "d", "ht", "sh", "w", "hl", "q", "e", "k", "bh", "ih", "v", "c", "hp", "p", "hm", "b", "http", "hh", "ph", "a", "ha", "hs", "he", "ah", "H", " H", "u"], "mb_type": ["motion_index", "mb_name", "mp_name", "bb_key", "motion_types", "mc_count", "motion_type", "mp_types", "mc_var", "mb___key", "mb_types", "mb_col", "bb_comp", "bb_role", "mp_type", "mb___type", "motion_col", "mb_role", "mb_val", "mc_val", "mb_id", "mb_key", "mb___role", "mb_comp", "mp_id", "mc_type", "mb_count", "mb_index", "bb_type", "mb___comp", "mb_var"], "s": ["ns", "spec", "m", "ts", "t", "stats", "conf", "f", "x", "ages", "services", "settings", "ions", "r", "n", "g", "i", "sl", "ss", "ls", "rh", "in", "fs", "is", "o", "l", "d", "location", "sh", "w", "qs", "e", "k", "ses", "v", "client", "c", "ps", "si", "sym", "p", "support", "S", "b", "gs", "storage", "a", "es", "os", "hs", "us", "server", "sq", "an", "y", "ds", "u"], "l1mv0": ["l1Mv0", "l1Mf50", "l1mf2", "l1mv2", "l1Mvfe", "l1mmfe", "l1mv50", "l1Mffe", "l1mf50", "l1Mf0", "l1mvfe", "l1mw50", "l1mw2", "l1Mv2", "l1mm50", "l1mm2", "l1Mv50", "l1mffe", "l1mw0", "l1Mf2", "l1mm0", "l1mf0", "l1mwfe"], "l1mv1": ["l1mf1", "l1mvb", "l1mc0", "l1mx3", "l1pf1", "l1mc3", "l1mfb", "l1pfb", "l1mf0", "l1mcb", "l1mc1", "l1pvb", "l1mv3", "l1mf3", "l1pv1", "l1mx1", "l1pv3", "l1pf0", "l1mxb", "l1mx0", "l1pf3", "l1pv0"], "l1ref0": ["l1q50", "l1pos5", "l1q5", "l6ref0", "l1reference50", "l6reference10", "l1pos0", "l6ref5", "l1pos50", "l1q0", "l6reference5", "l1reference5", "l1pos10", "l6reference50", "l6ref50", "l6reference0", "l1reference0", "l6ref10", "l1q10", "l1ref50", "l1ref5", "l1reference10", "l1ref10"], "l1ref1": ["l1l2", "l1ref2", "l1def1", "l1Ref2", "l2Refn", "l1ln", "l1Refn", "l2Ref1", "l1refn", "l2ref1", "l2ref2", "l1defn", "l1def2", "l1l1", "l2refn", "l1Ref1", "l2Ref2"], "sub_mb_type": ["sub_bb\n", "sub_MB2", "sub_mm_call", "sub_mb0", "sub_mm2", "sub_bb2", "sub_mm_id", "sub_mm_key", "sub_mb__name", "sub_mb__key", "sub_mm0", "sub_mb_id", "sub_mb2", "sub_mm_type", "sub_bb0", "sub_mb\n", "sub_MB_types", "sub_mb_types", "sub_mb__id", "sub_mb__types", "sub_mb__type", "sub_mb_key", "sub_mb_call", "sub_MB_type", "sub_MB\n", "sub_mb_name", "sub_mb__call", "sub_MB0", "sub_MB_name", "sub_mm\n"], "i8": ["p20", " i6", "l6", "i20", "i16", "p16", "i6", "p6", "p8", " i16", "l16", " i20", "l8", "l20"], "i4": ["p4", " i12", "xi12", " i24", "i24", "xi8", "p8", "xi24", "xi4", "p24", "i12", "p12"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static int bdrv_qed_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVQEDState *s = bs->opaque;\n\n    QEDHeader le_header;\n\n    int64_t file_size;\n\n    int ret;\n\n\n\n    s->bs = bs;\n\n    QSIMPLEQ_INIT(&s->allocating_write_reqs);\n\n\n\n    ret = bdrv_pread(bs->file, 0, &le_header, sizeof(le_header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    qed_header_le_to_cpu(&le_header, &s->header);\n\n\n\n    if (s->header.magic != QED_MAGIC) {\n\n        error_setg(errp, \"Image not in QED format\");\n\n        return -EINVAL;\n\n    }\n\n    if (s->header.features & ~QED_FEATURE_MASK) {\n\n        /* image uses unsupported feature bits */\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"%\" PRIx64,\n\n            s->header.features & ~QED_FEATURE_MASK);\n\n        error_set(errp, QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n            bdrv_get_device_name(bs), \"QED\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n    if (!qed_is_cluster_size_valid(s->header.cluster_size)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Round down file size to the last cluster */\n\n    file_size = bdrv_getlength(bs->file);\n\n    if (file_size < 0) {\n\n        return file_size;\n\n    }\n\n    s->file_size = qed_start_of_cluster(s, file_size);\n\n\n\n    if (!qed_is_table_size_valid(s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_is_image_size_valid(s->header.image_size,\n\n                                 s->header.cluster_size,\n\n                                 s->header.table_size)) {\n\n        return -EINVAL;\n\n    }\n\n    if (!qed_check_table_offset(s, s->header.l1_table_offset)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    s->table_nelems = (s->header.cluster_size * s->header.table_size) /\n\n                      sizeof(uint64_t);\n\n    s->l2_shift = ffs(s->header.cluster_size) - 1;\n\n    s->l2_mask = s->table_nelems - 1;\n\n    s->l1_shift = s->l2_shift + ffs(s->table_nelems) - 1;\n\n\n\n    /* Header size calculation must not overflow uint32_t */\n\n    if (s->header.header_size > UINT32_MAX / s->header.cluster_size) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if ((s->header.features & QED_F_BACKING_FILE)) {\n\n        if ((uint64_t)s->header.backing_filename_offset +\n\n            s->header.backing_filename_size >\n\n            s->header.cluster_size * s->header.header_size) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        ret = qed_read_string(bs->file, s->header.backing_filename_offset,\n\n                              s->header.backing_filename_size, bs->backing_file,\n\n                              sizeof(bs->backing_file));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        if (s->header.features & QED_F_BACKING_FORMAT_NO_PROBE) {\n\n            pstrcpy(bs->backing_format, sizeof(bs->backing_format), \"raw\");\n\n        }\n\n    }\n\n\n\n    /* Reset unknown autoclear feature bits.  This is a backwards\n\n     * compatibility mechanism that allows images to be opened by older\n\n     * programs, which \"knock out\" unknown feature bits.  When an image is\n\n     * opened by a newer program again it can detect that the autoclear\n\n     * feature is no longer valid.\n\n     */\n\n    if ((s->header.autoclear_features & ~QED_AUTOCLEAR_FEATURE_MASK) != 0 &&\n\n        !bdrv_is_read_only(bs->file) && !(flags & BDRV_O_INCOMING)) {\n\n        s->header.autoclear_features &= QED_AUTOCLEAR_FEATURE_MASK;\n\n\n\n        ret = qed_write_header_sync(s);\n\n        if (ret) {\n\n            return ret;\n\n        }\n\n\n\n        /* From here on only known autoclear feature bits are valid */\n\n        bdrv_flush(bs->file);\n\n    }\n\n\n\n    s->l1_table = qed_alloc_table(s);\n\n    qed_init_l2_cache(&s->l2_cache);\n\n\n\n    ret = qed_read_l1_table_sync(s);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* If image was not closed cleanly, check consistency */\n\n    if (!(flags & BDRV_O_CHECK) && (s->header.features & QED_F_NEED_CHECK)) {\n\n        /* Read-only images cannot be fixed.  There is no risk of corruption\n\n         * since write operations are not possible.  Therefore, allow\n\n         * potentially inconsistent images to be opened read-only.  This can\n\n         * aid data recovery from an otherwise inconsistent image.\n\n         */\n\n        if (!bdrv_is_read_only(bs->file) &&\n\n            !(flags & BDRV_O_INCOMING)) {\n\n            BdrvCheckResult result = {0};\n\n\n\n            ret = qed_check(s, &result, true);\n\n            if (ret) {\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    bdrv_qed_attach_aio_context(bs, bdrv_get_aio_context(bs));\n\n\n\nout:\n\n    if (ret) {\n\n        qed_free_l2_cache(&s->l2_cache);\n\n        qemu_vfree(s->l1_table);\n\n    }\n\n    return ret;\n\n}\n", "idx": 17953, "substitutes": {"bs": ["ns", "ms", "status", "ab", "stat", "bi", "ts", "ros", "lbs", "stats", "rs", "aws", "base", "settings", "ubs", "sb", "cb", "bc", "ls", "ss", "src", "bt", "pb", "lb", "bb", "fs", "bid", "cs", "css", "als", "gb", "bos", "bot", "ins", "obs", "outs", "BS", "iss", "blocks", "bis", "bl", "vs", "bas", "ses", "bh", "ps", "fb", "js", "bits", "b", "ks", "http", "gs", "es", "bytes", "os", "state", "bes", "us", "sa", "ds", "bing"], "options": ["ts", "ch", "stats", "info", "conf", "obj", "settings", "op", "io", "details", "cb", "ops", "fs", "o", "cs", "linux", "args", "outs", "config", "js", "bits", "lib", "fn", "opt", "os", "Options", "params"], "flags": ["status", "ts", "stats", "data", "mode", "settings", "Flags", "reg", "flag", "ips", "files", "ints", "utils", "ops", "fs", "mask", "cs", "args", "features", "config", "bits", "errors", "reads", "bytes", "parts", "opens", "len"], "errp": [" errP", "acerpe", " errfp", "acerp", "erfp", "rorP", "acerpb", "nerpc", "err", "errP", "derpb", "errpc", "acerv", "errv", "derpe", "rorfp", "derp", "Erpb", "errpb", "nerr", "erpc", "erp", "Erv", "errr", "errpo", "derv", "nerp", "errpe", "errfp", " errr", "erP", "Erpe", "erpo", " errpc", " errpo", "rorpo", "rorp", "Erp", "nerP"], "s": ["ns", "spec", "strings", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "us", "sets", "sa", "ms", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "uses", "a", "ds", "uns", "f", "sv", "r", "sb", "as", "l", "ins", "bis", "vs", "sync", "c", "ps", "rows", "b", "sys", "es", "state", "states", "sq", "session", "t", "stats", "conf", "services", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "parts", "u"], "le_header": ["ile_bridge", "le_dr", "ile_name", "le___handler", "le___head", "le_buffer", "LE_header", "LE_handler", "le_bridge", "ele_cover", "le_cover", " le_buffer", "le_manager", "le_head", " le_layer", " le_dr", "le_layer", "le_name", "ele_header", "ele_head", "LE_head", "le_handler", "ile_header", "ele_manager", "LE_pair", "ile_layer", "le___header", "le_pair", "le___pair"], "file_size": ["table_sized", "table_Size", "fileFsize", "file64error", "file_name", "file_source", "fileacsize", "file___source", "ile_name", "ile_align", "table_depth", "file_align", "fieldaclen", "fileperror", "file\u00b7align", "field_range", " file_length", "file_sn", "ile_adjust", "fieldacsize", "field_len", "files_size", "fileFsn", "file_sized", "filelexsource", "file_depth", "file\u00b7size", "file_adjust", "ile_size", "filelexlength", "file64size", "file\u00b7adjust", "filelexsize", "fileFrange", " file_source", "file_location", "file___size", "file___Size", "field_sn", "file64speed", "file___length", "filepspeed", "file\u00b7name", " file_speed", "fieldacsn", "fileFlen", "fileaclen", "fileacsn", "file_error", "field_size", "fileacrange", "file_len", "files_Size", "table_size", "fieldacrange", "file_speed", "files_name", "filelexlocation", "file___sized", "file_Size", "file___location", "file___depth", "file_length", "files_sized", "filepsize", "file_range", " file_error", " file_location"], "ret": ["status", "offset", "code", "t", "data", "x", "bit", "f", "al", "alt", "ref", "let", "err", "rc", "nt", "lit", "reg", "rt", "fun", "result", "num", "flag", "match", "pass", "ext", "fin", "run", "def", "rets", "en", "count", "out", "art", "att", "arr", "val", "re", "Ret", "fail", " RET", "no", "back", "det", "rl", " Ret", "RET", "pat", "error", "pet", "res", "mt", "ft", "reply", "pt", "success", "len"], "buf": ["bin", "br", "ff", "data", "text", "fp", "wrap", "ref", "buffer", "rc", "vec", "fi", "result", "cf", "exc", "block", "cb", "bc", "loc", "src", "msg", "wb", "ctx", "raw", "mem", "byte", "header", "path", "feat", "aux", "config", "queue", "fd", "buff", "fb", "temp", "rb", "seq", "cmd", "uc", "tmp", "pad", "doc", "b", "cap", "la", "alloc", "proc", " buffer", "bytes", "addr", "bag", "uf", "cv"]}}
{"project": "FFmpeg", "commit_id": "2aab7c2dfaca4386c38e5d565cd2bf73096bcc86", "target": 0, "func": "void ff_put_h264_qpel8_mc31_msa(uint8_t *dst, const uint8_t *src,\n\n                                ptrdiff_t stride)\n\n{\n\n    avc_luma_hv_qrt_8w_msa(src - 2,\n\n                           src - (stride * 2) +\n\n                           sizeof(uint8_t), stride, dst, stride, 8);\n\n}\n", "idx": 17954, "substitutes": {"dst": ["delst", "Dst", "idsrc", "delsrc", "dsrc", "adsrc", "Dsrc", "DST", "idst", "delST", "delrc", "dsc", "Drc", "adst", "adST", " dsc", "idsc", " dsrc", " drc", "dST", " dST", "idST", "adsc", "drc"], "src": ["grad", "sup", "sur", "rs", "rest", "dest", "rc", "lit", "rt", "supp", "sb", "cb", "sl", "lower", "loc", "sel", "sec", "low", "gb", "rd", "rob", "secure", "comp", "st", "config", "img", "sr", "sc", "ssl", "gl", "buf", "sync", "send", "start", "rb", "lib", "bg", "url", "b", "gz", "sub", "inst", "sq", "source", "dist"], "stride": ["Strise", "strride", "slided", "Strade", "Strided", "Strride", "Stride", "Strite", "vertided", "vertide", "STRride", "arride", "vertider", " strise", "STRide", " strride", "STRite", "yride", "strade", "slide", "STRided", "yrade", " strided", "strite", "slider", "arrend", "vertend", "strend", "arrider", "strided", "Strider", " strider", " strite", "yrider", "Strend", "slade", "strider", "arrided", "strise", "yrided", "slise"]}}
{"project": "qemu", "commit_id": "d0d7708ba29cbcc343364a46bff981e0ff88366f", "target": 0, "func": "static CharDriverState *qemu_chr_open_pipe(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    ChardevHostdev *opts = backend->u.pipe;\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_new0(WinCharState, 1);\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename, errp) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 17972, "substitutes": {"id": ["uri", "stat", "pid", "data", "name", "f", "ID", "file", "window", "i", "root", "in", "ctx", "fs", "ip", "uid", "path", "oid", "ident", "fd", "seq", "url", "ids", "sid", "fn", "proc", "desc"], "backend": [" backender", "frontward", "backends", "backward", " backward", "frontend", "frontender", "Backward", "Backended", "frontended", "Backend", " backends", "frontends", "Backends", " backride", "Backride", "backender", "frontride", "backride", "Backender", " backended", "backended"], "ret": ["status", "data", "al", "conn", "buffer", "result", "fin", "fs", "mem", "def", "rets", "en", "out", "val", "re", "Ret", "w", "buf", "RET", "output", "sys", "res", "proc", "desc", "fi", "success"], "errp": ["errorf", " errP", " Errps", " Errf", "err", "errP", "ryr", "rylp", "errorps", "errorP", " errlp", " Errp", "errorp", " ErrP", "erp", "ryP", "errr", " errr", "errlp", "errps", "erP", " errps", " errf", "erlp", "errf", "ryp"], "opts": ["optes", "OPts", "OPt", "OPtes", " optes", "fpTs", "opertes", "fpters", "opert", "fpts", " opcs", "opters", "optTs", "opTs", "opercs", "opcs", "optts", "operts", "OPTs", "OPters", "optters", " opt", "optt", "fpt", "opt", "OPcs"], "filename": ["txt", "fp", "name", "f", "fil", "tty", "ils", "file", "n", "kl", "i", "files", "wb", "username", "o", "enc", "l", "nil", "directory", "path", "feat", "kn", "sn", "prefix", "which", "il", "fd", "buf", "rl", "cmd", "binary", "url", "b", "sid", "fn", "til", "dll", "Filename"], "chr": ["ichru", "chpr", "motrt", "cherc", "anchr", "charrf", "ichcr", "chert", "anchru", "colrr", "ichrt", "Chrf", "chri", "Chr", "ichp", "shrf", "chrt", "shr", " chri", " chcr", "CHtr", "ichrr", "Chru", "chnru", "cheru", " chsr", "colar", "Chtr", "ichrb", " chrt", "CHr", "shrc", "cherb", "chnr", "chsr", " chrr", "checr", "ichrf", " chru", "chrf", "chrb", "gyrb", "ichr", "ichsr", " chrc", "motr", "gyru", "chepr", "motpr", "colr", "chcr", " chrb", "motrc", "Chp", " chp", "Chrb", "colrt", "chtr", "chntr", "chrr", "chru", "shri", " chpr", "anchrt", "chrc", "chnrb", "gyr", "cherf", "CHrb", "CHru", "cher", "charr", "Chri", "gyrf", "charri", "chp", "ichar", "ichri", "anchrb", "charrc", " chrf", "Chsr"], "s": ["ns", "spec", "m", "sg", "t", "rs", "f", "settings", "r", "n", "sb", "g", "i", "sl", "ips", "ss", "src", "ops", "fs", "self", "is", "o", "share", "d", "su", "socket", "sn", "w", "e", "ssl", "ses", "v", "sync", "c", "si", "p", "S", "b", "http", "sid", "params", "sys", "u", "storage", "h", "gs", "a", "os", "state", "south", "sq", "y", "ds", "sf"]}}
{"project": "qemu", "commit_id": "7bbcb0afe715c36545bbbd872441c473927c1a4e", "target": 0, "func": "uint32_t HELPER(clz)(uint32_t x)\n\n{\n\n    int count;\n\n    for (count = 32; x; count--)\n\n        x >>= 1;\n\n    return count;\n\n}\n", "idx": 17981, "substitutes": {"x": ["rx", "m", "xf", "xx", "time", "t", "data", "wx", "ix", "n", "num", "xe", "z", "max", "xy", "ctx", "index", "xb", "xs", "xa", "xp", "exec", "fx", "l", "val", "event", "size", "tx", "ax", "ex", "w", "xc", "xxx", "X", "e", "length", "v", "xt", "c", "xi", "p", "check", "cross", " xx", "number", "y", "u"], "count": ["pc", "process", "cc", "offset", "code", "child", "core", "base", "name", "call", "counter", "num", "i", "type", "match", "max", "Count", "index", "ind", "force", "val", "size", "length", "id", "e", "key", "start", "parent", "c", "catch", "p", "test", "sum", "cache", "depth", "col", "loop", "weight", "number", "allow", "list", "race", "cond", "len"]}}
{"project": "qemu", "commit_id": "96c9cff0ab986f3a0606e1a96c5b00e6a7c675c6", "target": 0, "func": "static void kvm_get_fallback_smmu_info(PowerPCCPU *cpu,\n\n                                       struct kvm_ppc_smmu_info *info)\n\n{\n\n    CPUPPCState *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n\n\n    memset(info, 0, sizeof(*info));\n\n\n\n    /* We don't have the new KVM_PPC_GET_SMMU_INFO ioctl, so\n\n     * need to \"guess\" what the supported page sizes are.\n\n     *\n\n     * For that to work we make a few assumptions:\n\n     *\n\n     * - If KVM_CAP_PPC_GET_PVINFO is supported we are running \"PR\"\n\n     *   KVM which only supports 4K and 16M pages, but supports them\n\n     *   regardless of the backing store characteritics. We also don't\n\n     *   support 1T segments.\n\n     *\n\n     *   This is safe as if HV KVM ever supports that capability or PR\n\n     *   KVM grows supports for more page/segment sizes, those versions\n\n     *   will have implemented KVM_CAP_PPC_GET_SMMU_INFO and thus we\n\n     *   will not hit this fallback\n\n     *\n\n     * - Else we are running HV KVM. This means we only support page\n\n     *   sizes that fit in the backing store. Additionally we only\n\n     *   advertize 64K pages if the processor is ARCH 2.06 and we assume\n\n     *   P7 encodings for the SLB and hash table. Here too, we assume\n\n     *   support for any newer processor will mean a kernel that\n\n     *   implements KVM_CAP_PPC_GET_SMMU_INFO and thus doesn't hit\n\n     *   this fallback.\n\n     */\n\n    if (kvm_check_extension(cs->kvm_state, KVM_CAP_PPC_GET_PVINFO)) {\n\n        /* No flags */\n\n        info->flags = 0;\n\n        info->slb_size = 64;\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[0].page_shift = 12;\n\n        info->sps[0].slb_enc = 0;\n\n        info->sps[0].enc[0].page_shift = 12;\n\n        info->sps[0].enc[0].pte_enc = 0;\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[1].page_shift = 24;\n\n        info->sps[1].slb_enc = SLB_VSID_L;\n\n        info->sps[1].enc[0].page_shift = 24;\n\n        info->sps[1].enc[0].pte_enc = 0;\n\n    } else {\n\n        int i = 0;\n\n\n\n        /* HV KVM has backing store size restrictions */\n\n        info->flags = KVM_PPC_PAGE_SIZES_REAL;\n\n\n\n        if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n            info->flags |= KVM_PPC_1T_SEGMENTS;\n\n        }\n\n\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->slb_size = 32;\n\n        } else {\n\n            info->slb_size = 64;\n\n        }\n\n\n\n        /* Standard 4k base page size segment */\n\n        info->sps[i].page_shift = 12;\n\n        info->sps[i].slb_enc = 0;\n\n        info->sps[i].enc[0].page_shift = 12;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n        i++;\n\n\n\n        /* 64K on MMU 2.06 and later */\n\n        if (env->mmu_model == POWERPC_MMU_2_06 ||\n\n            env->mmu_model == POWERPC_MMU_2_07) {\n\n            info->sps[i].page_shift = 16;\n\n            info->sps[i].slb_enc = 0x110;\n\n            info->sps[i].enc[0].page_shift = 16;\n\n            info->sps[i].enc[0].pte_enc = 1;\n\n            i++;\n\n        }\n\n\n\n        /* Standard 16M large page size segment */\n\n        info->sps[i].page_shift = 24;\n\n        info->sps[i].slb_enc = SLB_VSID_L;\n\n        info->sps[i].enc[0].page_shift = 24;\n\n        info->sps[i].enc[0].pte_enc = 0;\n\n    }\n\n}\n", "idx": 18015, "substitutes": {"cpu": ["pc", "process", "pid", "core", "jp", "cus", "vc", "uci", "conn", "PF", "px", "gc", "rc", "cpp", "cp", "node", "ocr", "utils", "ctx", "CP", "vm", "css", "roc", "hw", "gp", "linux", "nc", "uu", "ci", "gpu", "CPU", "config", "processor", "cli", "lc", "c", "kernel", "hp", "cache", "cmp", "sys", "clock", "proc", "cn", "boot", "pu", "eni", "np", "cow", "chip"], "info": ["uri", "offset", "extra", "user", "child", "obj", "comment", "options", "op", "job", "result", "num", "INFO", "available", "iso", "config", "id", "buff", "h", "end", "fi", "command", "source", "gi", "part", "thin", "init", "txt", "name", "app", "rf", "setup", "inf", "key", "update", "si", "off", "hand", "Info", "ami", "f", "image", "base", "guide", "cb", "type", "ii", "orig", "di", "help", "fo", "bar", "ci", "start", "post", "qa", "information", "check", "state", "py", "now", "bug", "where", "data", "conf", "note", "all", "ops", "ext", "index", "fs", "event", "ignore", "ui", "args", "cache", "http", "error", "tf", "api", "php", "diff", "inner", "by"], "env": ["cfg", "forge", "gu", "inc", "anc", "environment", "console", "energy", "enc", "exec", "config", "ev", "qt", "cli", "age", "ea", "dat", "opt", "end", "conn", "cal", "eu", "rc", "engine", "ne", "app", "dt", "scope", "eng", "inf", "style", "iss", "v", "dev", "stage", "ec", "ef", "visor", "dict", "org", "esp", "code", "core", "err", "estate", "net", "ou", "pec", "edge", "eni", "np", "db", "global", "conf", "skin", "exc", "ani", "oa", "ext", "ctx", "en", "profile", "context", "ce", "nc", "event", "args", "site", "ui", "e", "kernel", "cache", "agent", "server"], "cs": ["ns", "pc", "spec", "bs", "rs", "conn", "rc", "Cs", "CS", "cp", "ls", "bc", "wcs", "ctx", "ss", "fs", "self", "cas", "ca", "sk", "css", "gb", "acs", "cms", "nc", "args", "qs", "sc", "vs", "sync", "c", "ps", "si", "ck", "ks", "sys", "ec", "proc", "cn", "state", "co", "cc", "ds"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "ie", "d", "pi", "id", "cli", "ni", "xi", "p", "anti", "it", "fi", "gi", "m", "init", "j", "ix", "ini", "in", "y", "iu", "I", "o", "v", "si", "ri", "a", "iv", "ti", "mi", "ii", "di", "mini", "multi", "zi", "l", "oi", "ci", "start", "c", "b", "inst", "func", "all", "io", "n", "g", "ij", "ski", "index", "ip", "ui", "args", "e", "_", "cache", "li", "u"]}}
{"project": "qemu", "commit_id": "7e84c2498f0ff3999937d18d1e9abaa030400000", "target": 0, "func": "void helper_iret_protected(int shift)\n\n{\n\n    helper_ret_protected(shift, 1, 0);\n\n}\n", "idx": 18020, "substitutes": {"shift": [" shifted", "set", "offset", "init", "small", "data", "push", "ix", "hift", "buffer", "center", "pack", "pixel", "i", " offset", "src", "slice", "index", "pointer", "ip", "size", "seed", "reset", "length", "config", "start", " shifts", "pull", "slave", "off", "pad", "address", "next", "carry", "transform", "Shift", "input"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "void qemu_bh_schedule(QEMUBH *bh)\n\n{\n\n    AioContext *ctx;\n\n\n\n    ctx = bh->ctx;\n\n    bh->idle = 0;\n\n    /* The memory barrier implicit in atomic_xchg makes sure that:\n\n     * 1. idle & any writes needed by the callback are done before the\n\n     *    locations are read in the aio_bh_poll.\n\n     * 2. ctx is loaded before scheduled is set and the callback has a chance\n\n     *    to execute.\n\n     */\n\n    if (atomic_xchg(&bh->scheduled, 1) == 0) {\n\n        aio_notify(ctx);\n\n    }\n\n}\n", "idx": 18038, "substitutes": {"bh": ["bi", "bs", "ch", "aph", "fp", "adh", "hap", "bm", "dh", "sb", "gh", "bp", "cpp", "beh", "rh", "hub", "acl", "pb", "bt", "lb", "uh", "xb", "hw", "ht", "sh", "kh", "BT", "zh", "bf", "pkg", "abi", "hl", "pa", "sth", "batch", "ih", "bg", "rb", "hp", "p", "hm", "b", "http", "hh", "h", "ph", "hs", "ah"], "ctx": ["pc", "rx", "grad", "cc", "cfg", "fp", "obj", "vc", "gc", "cm", "bm", "cf", "cpp", "cb", "module", "cp", "loc", "src", "scope", "timeout", "graph", "multi", "kw", "ctrl", "cas", "Context", "ca", "cs", "exec", "context", "hw", "kb", "pkg", "tx", "ci", "tc", "xc", "config", "queue", "sc", "cu", "client", "cli", "lc", "c", "chan", "sync", "qa", "cmd", "ck", "cmp", "alloc", "cn", "sq", "np", "cv", "conn"]}}
{"project": "qemu", "commit_id": "7bd427d801e1e3293a634d3c83beadaa90ffb911", "target": 0, "func": "static SpiceTimer *timer_add(SpiceTimerFunc func, void *opaque)\n\n{\n\n    SpiceTimer *timer;\n\n\n\n    timer = qemu_mallocz(sizeof(*timer));\n\n    timer->timer = qemu_new_timer(rt_clock, func, opaque);\n\n    QTAILQ_INSERT_TAIL(&timers, timer, next);\n\n    return timer;\n\n}\n", "idx": 18044, "substitutes": {"func": ["pc", "util", "arf", "code", "data", "obj", "f", "name", "expr", "r", "fun", "apply", "n", "job", "worker", "cb", "as", "function", "in", "this", "slice", " function", "exec", "ln", "val", "nc", "exe", "xxx", "handler", "sync", "lc", "c", "lambda", "b", "Function", "fee", "fn", "unc", "proc", "wrapper", "a", "callback", "attr"], "opaque": ["operace", "operacity", "Opaque", "coque", "Opacity", "coaque", "oprobe", " opacity", "Opque", "Opaques", " opace", "opacity", " oprobe", "operaque", "operque", "Oprobe", "opace", "coaques", "coacity", "opaques", "operaques", "operrobe", "Opace", "opque"], "timer": ["term", "izer", "tim", "txt", "time", "fp", "cookie", "f", "err", "runner", "starter", "buffer", "tick", "walker", "counter", "duration", "theme", "worker", "result", "imer", "loader", "roller", "icer", "cb", "or", "trial", "player", "finder", "oller", "ext", "timeout", "manager", "icker", "ee", "pointer", "ger", "ter", "later", "event", "acker", "browser", "tc", "fit", "ler", "handler", "processor", "acer", "Timer", "temp", "item", "inter", "cache", "next", "clock", "wrapper", "er", "loop", "peer", "message", "iter", "server", "trigger", "writer", "inner", "outer", "reader"]}}
{"project": "qemu", "commit_id": "b131c74a0e485b084ddaffc8214c8a19af492be7", "target": 0, "func": "static int kvm_virtio_pci_vq_vector_use(VirtIOPCIProxy *proxy,\n\n                                        unsigned int queue_no,\n\n                                        unsigned int vector,\n\n                                        MSIMessage msg)\n\n{\n\n    VirtQueue *vq = virtio_get_queue(proxy->vdev, queue_no);\n\n    EventNotifier *n = virtio_queue_get_guest_notifier(vq);\n\n    VirtIOIRQFD *irqfd = &proxy->vector_irqfd[vector];\n\n    int ret;\n\n\n\n    if (irqfd->users == 0) {\n\n        ret = kvm_irqchip_add_msi_route(kvm_state, msg);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n        irqfd->virq = ret;\n\n    }\n\n    irqfd->users++;\n\n\n\n    ret = kvm_irqchip_add_irq_notifier(kvm_state, n, irqfd->virq);\n\n    if (ret < 0) {\n\n        if (--irqfd->users == 0) {\n\n            kvm_irqchip_release_virq(kvm_state, irqfd->virq);\n\n        }\n\n        return ret;\n\n    }\n\n\n\n    virtio_queue_set_guest_notifier_fd_handler(vq, true, true);\n\n    return 0;\n\n}\n", "idx": 18067, "substitutes": {"proxy": ["uri", "plugin", "Proxy", "super", "core", "base", "image", "pool", "buffer", "io", "library", "service", "bridge", "module", "node", "python", "pb", "phy", "manager", "model", "ip", "vm", "socket", "pse", "queue", "config", "remote", "cop", "client", "parent", "driver", "p", "que", "cache", "http", "resource", "route", "wrapper", "pro", "connection", "project", "port", "server", "bus"], "queue_no": ["queue__len", "queue__no", "que_len", "queue_No", "queue_number", "que_no", "queue_len", "queue_offset", " queue_offset", "queue__number", "que_number", " queue_number", " queue_No"], "vector": ["uri", "native", "Vector", " generator", "creator", "token", "buffer", "vec", "node", "manager", "timeout", "virtual", " matrix", "pointer", "letter", "network", "queue", "prefix", " vendor", "buf", " protocol", "v", "driver", "binary", "iterator", "card", " router", "iv", "number", "connection", "sequence", "port", "prot", "command", "version", "reader"], "msg": ["uri", "ms", "m", "cfg", "request", "data", "text", "name", "op", "vec", " message", "g", "node", "sim", "Message", "mem", "manager", " MSG", "def", "out", "vm", "nm", "new", "event", "config", "response", "queue", "send", "v", "req", "Msg", "seq", "cmd", "sym", "gen", "route", "mail", "message", "command", "reply"], "vq": ["giq", "vqq", "tvch", "Vq", "vvq", "gq", "tvqa", " vch", "tvq", "vc", "gqa", "miq", "pq", " vQ", "mqq", "gqq", "tvqi", "vvqa", "pqa", " vc", "viq", "tvque", "vqi", "tvc", " vqa", "vvch", "mq", "vvque", "vque", "VQ", "pqq", "tvQ", "Vqi", "Vc", "piq", " vqi", "vQ", "vqa", "mqa", " vque", "vch"], "n": ["ns", " ng", "gn", "dn", "m", "s", "j", "t", "f", "pn", "ne", "r", "mn", "num", "N", "g", "i", "nor", "z", "nl", "nb", "en", "o", "nm", "l", "d", " N", "nr", "nc", "network", "sn", "w", "nu", "v", "nw", "c", "p", "b", "cn", "number", "nn", "np", "y"], "irqfd": ["irquestfin", "ircdir", "irqafin", "irpatchFD", "irqfront", "irpFD", "ireqfn", "yrarchcdn", "arinqufin", "irqfan", "irchfd", "irkfen", "irvfen", "iraqufan", "irtqFD", "irqufin", "yrarchfd", "irquestfen", "irqudir", "irqufn", "irqufan", "irquFD", "irqfl", "iraqfd", "irqds", "irpatchfl", "irpatchfun", "ireqfun", "arinqfen", "irkfd", "irpatchfed", "irpatchfn", "irtqfl", "irsqbd", "iraquds", "irekfd", "irvfd", "irhFD", "ireqfed", "iersqFD", "irkFD", "irwallfd", "irarchcdn", "yrarchfen", "irchfen", "irancebd", "ircfd", "irqfc", "yrarchdf", "irchdf", "iriqds", "irqufun", "iraqfan", "irqFD", "irqufd", "ierqFD", "iraqds", "ierqfd", "yrqdf", "irekfc", "iraqufin", "irtqufl", "irqufed", "ireqFD", "irsqfront", "arinqdf", "iersqfront", "irqafan", "irquestfd", "yrqfd", "irqufen", "irequfn", "arinqfin", "iersqfd", "irhfd", "irarchfen", "yrqcdn", "irqcdn", "irvcdn", "irqudf", "irsqfd", "yrqfen", "irqfn", "ircbd", "arinqufd", "ircfront", "ireqfen", "irquestdf", "irpatchdir", "arinqudf", "irqadf", "irquds", "irwallfun", "irequfed", "iraqfin", "irtqufd", "irqdir", "irtqdir", "irancefront", "irqfin", "iranceFD", "irpatchfd", "irwallfed", "irequfd", "irchfin", "irtqfd", "irqfun", "ierqbd", "irqbd", "irpfc", "irtqudir", "irqafd", "irpfen", "ireqfd", "irpfd", "irarchdf", "arinqfd", "iraqufd", "iersqbd", "ircFD", "irqads", "iriqfin", "iriqfd", "irkfc", "irqufl", "irekFD", "irekfen", "irqfed", "iriqfan", "irqdf", "arinqufen", "ircfl", "irtquFD", "ireqfc", "irwallfn", "irancefd", "irqafen", "irqacdn", "irequfun", "irqfen", "irvdf", "irsqFD", "irhfc", "ierqfront", "irarchfd", "irhfen"], "ret": ["part", "db", "code", "t", "info", "x", "f", "ref", "bit", "alt", "obj", "err", "rc", "nt", "ver", "reg", "rt", "fun", "lit", "result", "job", "try", "fi", "flag", "type", "match", "pass", "ext", "done", "run", "rf", "ry", "def", "rets", "active", "mem", "art", "secret", "att", "arg", "val", "re", "Ret", "bf", "back", "reset", "value", "rev", "cat", "rb", "hard", "repl", "url", "RET", "pat", "error", "red", "rep", "res", "pet", "opt", "mt", "ft", "usr", "reply", "success", "len"], "users": ["classes", "bugs", "packages", "pages", "jobs", "stars", "mins", "ports", "modules", "workers", "plugins", "devices", "files", "runners", "models", "items", "apps", "lines", "vers", "views", "units", "Users", "drivers", "blocks", "pins", "masters", "versions", "ids", "projects", "leaders", "names", "rules", "members", "groups", "parents", "docs", "locks"]}}
{"project": "FFmpeg", "commit_id": "ddd86a2924b9bc67c406cd66ebb1fc8915cd60f7", "target": 1, "func": "static int output_packet(InputStream *ist,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n\n\n    AVPacket avpkt;\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    }\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = transcode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = transcode_video    (ist, &avpkt, &got_output, &pkt_pts);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_ostreams; i++) {\n\n        OutputStream *ost = &ost_table[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18077, "substitutes": {"ist": ["set", "edit", "nt", "adder", "empt", "att", "ont", "irst", "feat", "pop", "it", "pt", "est", "part", "tt", "txt", "work", "nd", "rest", "artist", "osi", "ld", "wd", "dit", "pect", "imet", "art", "istor", "pg", "aint", "et", "ft", "list", "at", "wp", "ists", "ict", "ess", "mot", "ind", "isd", "act", "sta", "ht", "ird", "back", "xt", "ad", "start", "post", "ust", "iste", "ism", "inst", "ace", "er", "progress", "oss", "ord", "ast", "ext", "ctx", "gest", "asp", "lect", "old", "elect", "alist", "add", "st", "ush", "dr", "isi", "ait", "kt", "support", "pick", "best", "IST", "ard", "usr", "dist"], "ost_table": ["ost_source", "oc_file", "ost_col", "ost_file", "oc_col", "oc_table", "oc_source"], "nb_ostreams": ["nb_octstreams", "nb_ostocollist", "nb_ostreamgroups", "nb_octstreamgroups", "nb_octreams", "nb_ostinputs", "nb_octstreamd", "nb_ostocols", "nb_octstreamlist", "nb_ostreamd", "nb_ostocold", "nb_ostinputlist", "nb_oststreamgroups", "nb_octreamlist", "nb_ostinputd", "nb_oststreams", "nb_octreamgroups", "nb_ostocolgroups", "nb_octreamd", "nb_oststreamd", "nb_oststreamlist", "nb_ostinputgroups", "nb_ostreamlist"], "pkt": ["preacket", "mwk", "delt", " psth", " pct", "packet", "ppkt", "fcht", "melt", "opett", "jpacket", "mkt", "apqt", "backet", "apcht", "pcht", "Pkt", "cpett", "Pct", "tpcht", "Pqt", "ppnt", "Ptch", "pnt", "tpkt", "bkt", "paramwk", "rkt", "tkt", "mcht", "fsth", " pet", "payacket", "pqt", "cpqt", "opkt", "mnt", "jpkt", "prent", "paykt", " pqt", "pet", "psth", "apelt", "tacket", "fkt", "rtch", "paycht", "Pet", "pett", "Packet", "fwk", "ppct", "cpct", "tpqt", "Pcht", "dcht", "jpett", "paramnt", " pcht", "opelt", "facket", "paramkt", "cpkt", " pelt", "rcht", "macket", "racket", "opcht", "tpelt", "paramacket", "dkt", "apkt", "tsth", "Pnt", "bwk", "dacket", "prewk", "jpcht", "pelt", " packet", " pnt", "pwk", "ppacket", "paytch", "tcht", "pct", "cpelt", "bcht", "cpcht", "cpet", "cpacket", "ptch", "opacket", "prekt"], "i": ["ti", "gi", "j", "t", "f", "io", "mi", "n", "ai", "ii", "di", "slice", "mini", "ind", "I", "ip", "d", "pi", "ui", "ci", "c", "si", "p", "xi", "it", "fi", "inner", "li"], "got_output": ["got_response", "got___response", "getting_download", "getting_output", "got_download", " got_Output", "getting_response", "got_input", "getting_input", " got_input", "got_Output", "got___output", "got___input", "got___download"], "avpkt": ["avpcht", "ovbetsk", "avaiece", "avfcht", "avfett", "avfact", "avdpacket", "avcpkt", "Avpact", "avpqt", "Avpkt", "avecct", "avgkt", "avpcp", "evpk", "caltpwk", "AVcpcp", "avccht", "avvkt", "avepcht", "avparamcht", "Avppkt", "ovpkt", "avopk", "avpwk", "evcpkt", "avparamet", "avPqt", "avipact", "avakt", "avmnt", "avcpet", "AVcpkt", "avopqt", "avepkt", "Avpwk", "ovbkt", "avckt", "avegiece", "avepct", "avgke", "calpacket", "avdpkt", "avfnt", "avfwk", "adpett", "avciece", "avvnt", "avbnt", "avpact", "avpet", "avspkt", "aveciece", "ovbnt", "avipkt", "caltpkt", "AVcpcht", "avpunct", "avpetsk", "calpunct", "adpkt", "avmqt", "evpnt", "avnpct", "avpft", "avvetsk", "avtpkt", "avfqt", "avppacket", "avegft", "ovpetsk", "Avpacket", "avcpk", "avbacket", "evcpqt", "avlpqt", "ovpnt", "calpwk", "avtpunct", "avnpft", "avspet", "avipacket", "avppact", "avppwk", "avopett", "avgiece", "avegke", "avepiece", "avaft", "avcpcp", "avmkt", "avpk", "avPk", "Avppact", "avpett", "evpqt", "avfetsk", "avpct", "adlpkt", "avtpwk", "avlpk", "avepke", "avcpcht", "avpnt", "avcct", "avfk", "evpkt", "Avppwk", "avcpqt", "Avppacket", "avgft", "aveccht", "ovpacket", "adlpett", "avopkt", "avdpwk", "avtpacket", "avegkt", "avspcp", "AVpkt", "AVpcp", "adpqt", "avpacket", "evcpnt", "avparamcp", "AVpet", "avbetsk", "avfkt", "avnpkt", "avfct", "caltpunct", "avpke", "avdpunct", "avpiece", "avmk", "avfunct", "avvacket", "avnpiece", "avake", "ovbacket", "AVcpet", "avbkt", "adpk", "avspcht", "adlpk", "evcpk", "AVpcht", "avnpcht", "caltpacket", "avnpke", "avlpkt", "avppkt", "avipwk", "adlpqt", "calpkt", "avPnt", "avparamkt", "aveckt", "avepft", "avfacket", "avlpett", "avcpnt", "avPkt", "avfiece"], "duration": ["m", "group", "sg", "err", "f", "T", "fun", "debug", "wait", "result", "num", "g", "sec", "timeout", "resp", "gap", "d", "G", "id", "start", "unit", "loss", "lag", "total", "desc", "valid", "gr"]}}
{"project": "FFmpeg", "commit_id": "af2ee6fc4921a81133c0915985e05781505c2ff8", "target": 0, "func": "static void search_for_quantizers_anmr(AVCodecContext *avctx, AACEncContext *s,\n\n                                       SingleChannelElement *sce,\n\n                                       const float lambda)\n\n{\n\n    int q, w, w2, g, start = 0;\n\n    int i, j;\n\n    int idx;\n\n    TrellisPath paths[TRELLIS_STAGES][TRELLIS_STATES];\n\n    int bandaddr[TRELLIS_STAGES];\n\n    int minq;\n\n    float mincost;\n\n    float q0f = FLT_MAX, q1f = 0.0f, qnrgf = 0.0f;\n\n    int q0, q1, qcnt = 0;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        float t = fabsf(sce->coeffs[i]);\n\n        if (t > 0.0f) {\n\n            q0f = FFMIN(q0f, t);\n\n            q1f = FFMAX(q1f, t);\n\n            qnrgf += t*t;\n\n            qcnt++;\n\n        }\n\n    }\n\n\n\n    if (!qcnt) {\n\n        memset(sce->sf_idx, 0, sizeof(sce->sf_idx));\n\n        memset(sce->zeroes, 1, sizeof(sce->zeroes));\n\n        return;\n\n    }\n\n\n\n    //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n    q0 = av_clip_uint8(log2(q0f)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n    q1 = av_clip_uint8(log2(q1f)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n    if (q1 - q0 > 60) {\n\n        int q0low  = q0;\n\n        int q1high = q1;\n\n        //minimum scalefactor index is when maximum nonzero coefficient after quantizing is not clipped\n\n        int qnrg = av_clip_uint8(log2(sqrt(qnrgf/qcnt))*4 - 31 + SCALE_ONE_POS - SCALE_DIV_512);\n\n        q1 = qnrg + 30;\n\n        q0 = qnrg - 30;\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n        if (q0 < q0low) {\n\n            q1 += q0low - q0;\n\n            q0  = q0low;\n\n        } else if (q1 > q1high) {\n\n            q0 -= q1 - q1high;\n\n            q1  = q1high;\n\n        }\n\n    }\n\n    //av_log(NULL, AV_LOG_ERROR, \"q0 %d, q1 %d\\n\", q0, q1);\n\n\n\n    for (i = 0; i < TRELLIS_STATES; i++) {\n\n        paths[0][i].cost    = 0.0f;\n\n        paths[0][i].prev    = -1;\n\n    }\n\n    for (j = 1; j < TRELLIS_STAGES; j++) {\n\n        for (i = 0; i < TRELLIS_STATES; i++) {\n\n            paths[j][i].cost    = INFINITY;\n\n            paths[j][i].prev    = -2;\n\n        }\n\n    }\n\n    idx = 1;\n\n    abs_pow34_v(s->scoefs, sce->coeffs, 1024);\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w]) {\n\n        start = w*128;\n\n        for (g = 0; g < sce->ics.num_swb; g++) {\n\n            const float *coefs = sce->coeffs + start;\n\n            float qmin, qmax;\n\n            int nz = 0;\n\n\n\n            bandaddr[idx] = w * 16 + g;\n\n            qmin = INT_MAX;\n\n            qmax = 0.0f;\n\n            for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                if (band->energy <= band->threshold || band->threshold == 0.0f) {\n\n                    sce->zeroes[(w+w2)*16+g] = 1;\n\n                    continue;\n\n                }\n\n                sce->zeroes[(w+w2)*16+g] = 0;\n\n                nz = 1;\n\n                for (i = 0; i < sce->ics.swb_sizes[g]; i++) {\n\n                    float t = fabsf(coefs[w2*128+i]);\n\n                    if (t > 0.0f)\n\n                        qmin = FFMIN(qmin, t);\n\n                    qmax = FFMAX(qmax, t);\n\n                }\n\n            }\n\n            if (nz) {\n\n                int minscale, maxscale;\n\n                float minrd = INFINITY;\n\n                //minimum scalefactor index is when minimum nonzero coefficient after quantizing is not clipped\n\n                minscale = av_clip_uint8(log2(qmin)*4 - 69 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                //maximum scalefactor index is when maximum coefficient after quantizing is still not zero\n\n                maxscale = av_clip_uint8(log2(qmax)*4 +  6 + SCALE_ONE_POS - SCALE_DIV_512);\n\n                minscale = av_clip(minscale - q0, 0, TRELLIS_STATES - 1);\n\n                maxscale = av_clip(maxscale - q0, 0, TRELLIS_STATES);\n\n                for (q = minscale; q < maxscale; q++) {\n\n                    float dist = 0;\n\n                    int cb = find_min_book(sce->sf_idx[w*16+g], sce->ics.group_len[w], sce->ics.swb_sizes[g], s->scoefs+start);\n\n                    for (w2 = 0; w2 < sce->ics.group_len[w]; w2++) {\n\n                        FFPsyBand *band = &s->psy.psy_bands[s->cur_channel*PSY_MAX_BANDS+(w+w2)*16+g];\n\n                        dist += quantize_band_cost(s, coefs + w2*128, s->scoefs + start + w2*128, sce->ics.swb_sizes[g],\n\n                                                            q + q0, cb, lambda / band->threshold, INFINITY, NULL);\n\n                    }\n\n                    minrd = FFMIN(minrd, dist);\n\n\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + dist\n\n                               + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            } else {\n\n                for (q = 0; q < q1 - q0; q++) {\n\n                    if (!isinf(paths[idx - 1][q].cost)) {\n\n                        paths[idx][q].cost = paths[idx - 1][q].cost + 1;\n\n                        paths[idx][q].prev = q;\n\n                        continue;\n\n                    }\n\n                    for (i = 0; i < q1 - q0; i++) {\n\n                        float cost;\n\n                        if (isinf(paths[idx - 1][i].cost))\n\n                            continue;\n\n                        cost = paths[idx - 1][i].cost + ff_aac_scalefactor_bits[q - i + SCALE_DIFF_ZERO];\n\n                        if (cost < paths[idx][q].cost) {\n\n                            paths[idx][q].cost    = cost;\n\n                            paths[idx][q].prev    = i;\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n            sce->zeroes[w*16+g] = !nz;\n\n            start += sce->ics.swb_sizes[g];\n\n            idx++;\n\n        }\n\n    }\n\n    idx--;\n\n    mincost = paths[idx][0].cost;\n\n    minq    = 0;\n\n    for (i = 1; i < TRELLIS_STATES; i++) {\n\n        if (paths[idx][i].cost < mincost) {\n\n            mincost = paths[idx][i].cost;\n\n            minq = i;\n\n        }\n\n    }\n\n    while (idx) {\n\n        sce->sf_idx[bandaddr[idx]] = minq + q0;\n\n        minq = paths[idx][minq].prev;\n\n        idx--;\n\n    }\n\n    //set the same quantizers inside window groups\n\n    for (w = 0; w < sce->ics.num_windows; w += sce->ics.group_len[w])\n\n        for (g = 0;  g < sce->ics.num_swb; g++)\n\n            for (w2 = 1; w2 < sce->ics.group_len[w]; w2++)\n\n                sce->sf_idx[(w+w2)*16+g] = sce->sf_idx[w*16+g];\n\n}\n", "idx": 18095, "substitutes": {"avctx": ["avpkg", "ajcas", "verpkg", "AVcontext", "vercas", "ajctx", "ajpkg", "verctx", "avcas", "AVcas", "AVpkg", "avcontext", "ajcontext", "AVctx", "vercontext"], "s": ["spec", "session", "ts", "rs", "services", "service", "sl", "fs", "sec", "o", "cs", "space", "e", "ssl", "sc", "ses", "sync", "client", "c", "S", "b", "sys", "a", "os", "server", "sa"], "sce": ["sinced", "exced", "wscel", "insCE", "mce", "jscing", " scel", "jsce", "jsCE", "ste", "mces", "rsCE", "Sge", "vesced", "dsce", " sCE", "opensce", "dce", "ske", "ssCE", " ske", "wscing", "dcf", "vesce", "sincing", "exce", "scel", "sCE", "scing", "mcel", "excast", "dcel", "insce", "vescast", " sces", "opensced", "rsge", "mge", "sces", "Sces", "dscel", "wsces", "scast", "dces", "Sce", "since", " scing", "wske", "sinCE", " scf", "dscf", "ssces", "Scel", "openste", "veste", "ssce", "inscing", "scf", "exte", "jsced", "sge", "wsce", "openscast", "ssge", "rsces", "sced", "dsces", "rsce", "wsced", "wsge", " sge", "inske", "wsCE"], "lambda": [" delta", "scale", "frac", " costs", "func", "fun", "phi", " beta", " formula", "function", " fn", " function", " gamma", " loss", "ta", "loss", "da", " func", " weight", " Phi", "fee", " L", "b", " lam", "beta", "weight", "alpha", " omega"], "q": ["quant", "ch", "quest", "x", "f", "qi", "dq", "z", "max", "Q", "count", "ip", "qu", "d", "iq", "qs", "k", "qt", "cl", "v", "c", "req", "qq", "qa", "p", "sq"], "w": ["m", "wt", "x", "f", "r", "n", "we", "z", "max", "l", "d", "W", "k", "v", "c", "p", "b", "win", "wh", "h", "wa", "weight", "y", "u"], "w2": ["x0", "waii", "wa1", "w1", "x2", "wa2", "wii", "xii", "w0", "x1", "qii", "wa0", "q2"], "g": ["m", "gn", "group", "sg", "x", "f", "n", "z", "l", "d", "gp", "G", "go", "k", "e", "v", "c", "p", "b", "gs", "h", "gm", "y", "u"], "i": ["ti", "gi", "uri", "m", "ji", "t", "info", "x", "f", "ix", "ini", "r", "ai", "mi", "n", "io", "z", "ii", "in", "ie", "iu", "index", "di", "I", "multi", "zi", "is", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "e", "k", "c", "ni", "si", "ri", "p", "xi", "b", "uli", "h", "it", "eni", "fi", "y", "li", "u"], "j": ["m", "jl", "ji", "x", "jp", "f", "r", "n", "z", "ij", "pos", "o", "l", "d", "J", "k", "e", "v", "c", "p", "b", "h", "y", "li", "u"], "idx": [" idz", "midx", "idz", " idw", "Idx", "Idw", "idw", "midX", "midw", " idX", "IdX", "idX", "midz", "Idz"], "paths": ["stres", "strses", "Pathls", "pathes", "strls", "bufses", "bufs", "pathses", "bufes", "Pathses", "Pathes", "pathls", "strs", "bufls", "Paths"], "TRELLIS_STAGES": ["TRELLIS_STRages", "TRELLIS_INSTATES", "TRELLIS_StATES", "TRELLIS_STAGE", "TRELLIS_STRAGES", "TRELLIS_StAGE", "TRELLIS_StGES", "TRELLIS_INSTAGES", "TRELLIS_INSTages", "TRELLIS_STATES", "TRELLIS_INSTAGE", "TRELLIS_StAGES", "TRELLIS_STRAGE", "TRELLIS_Stages", "TRELLIS_STRGES", "TRELLIS_STRATES", "TRELLIS_STages", "TRELLIS_STGES"], "bandaddr": ["bandwork", "Bandaddr", "waveaddr", "cmaddr", "cmpad", "wavework", "cmptr", "wavepad", "Bandpad", "cmwork", "Bandptr", "waveptr", "bandpad", "bandptr", "Bandwork"], "minq": ["mindq", "Minqa", "Minp", "Mindq", "minp", "minimumqa", "Minq", "minimump", "minqa", " minqa", "minimumdq", " mindq", " minp", "minimumq"], "mincost": ["initcost", "minfee", "subprice", "subq", "initprice", "initq", "subfee", "subcost", "minprice", "initfee", " minprice", " minfee"], "q0": ["qa6", "query00", "qu2", "Q0", "quest0", "qifrom", "qi00", "p2", "qi0", "query9", "p0", "qq2", "qu00", "sq4", "questfrom", "qq50", " q6", "iq1", "Q00", "qu4", "qa2", "query2", "que0", " q50", "iq4", "qiie", "dq9", "query6", "qfrom", " q00", "query0", "query1", "dq0", "sq0", "que00", "qu50", "q00", "q50", "sq6", " q2", "q9", "dq4", "qu0", "qa50", "qa00", "sq00", "qq00", "questie", "iq0", "qu1", "Qie", "p00", "que2", "q4", "qu6", "dq2", "dq00", "qq0", "Qfrom", "qie", "query4", "sq2", "iq00", "quest00", "que9", "p1", "sq1", "q6", "qa0", "dq6", "q2", "qa1"], "q1": ["quest7", "qq01", "qq2", "eq8", " q6", " qone", "qu01", "eq2", "Q1", "qqb", "eq9", "query0", "query1", " q2", "eq1", "qu0", "qu1", "sqOne", "qub", "que11", "q11", "sq1", "q7", "qu13", "q10", "qa9", "quest8", "sq61", "p8", "sq6", "qq1", "sq2", "qend", "p1", "eq7", "qa1", "sq01", "queend", "pone", "qu8", "que0", "eqone", "Q8", " q8", "eq01", "q8", "queryend", "qa8", "qqOne", "q61", " qb", "qqone", "qOne", "quend", "Q7", "query11", "qa10", "quOne", "eq10", "qb", "q6", "q2", "quest1", "eq6", "qu2", " q01", "quest2", "p0", "sqone", "que1", "qu11", "q01", "qone", "eq13", "eq61", "q9", " q10", "quone", "Q2", "qu61", "q13", "sq13", " q9"], "qcnt": ["qrcrt", "qpcrt", "qcrt", "qlcNT", " qcant", " qlcNT", " qcct", "qdcrt", "qncnt", "qCno", "qlcnd", "qecnt", " qscct", " qscant", "qncno", "qlcrt", "qpcnt", " qlcrt", "qpcNT", "qscrt", " qncno", "qpcret", " qncrt", " qncnt", "qrcnt", "qlcno", "qecrt", "qCNT", "qncant", "qrcNT", "qCnt", " qcret", "qncrt", "qecct", "qecant", "qncret", "qdcant", "qcno", "qcNT", "qdcnt", " qscnt", "qpcant", "qpcnd", "qcret", "qncNT", " qlcnd", "qCrt", " qcrt", " qcnd", " qcNT", " qlcant", " qncNT", "qscant", " qlcnt", "qlcret", "qscnt", "qcnd", "qscct", "qcct", "qncct", "qcant", " qlcret", " qscrt", " qcno", "qdcnd", "qrcno", " qlcno", "qlcnt", "qpcno", "qlcant"]}}
{"project": "qemu", "commit_id": "fef6070eff233400015cede968b0afe46c80bb0f", "target": 0, "func": "static int create_fixed_disk(int fd, uint8_t *buf, int64_t total_size)\n\n{\n\n    int ret = -EIO;\n\n\n\n    /* Add footer to total size */\n\n    total_size += 512;\n\n    if (ftruncate(fd, total_size) != 0) {\n\n        ret = -errno;\n\n        goto fail;\n\n    }\n\n    if (lseek(fd, -512, SEEK_END) < 0) {\n\n        goto fail;\n\n    }\n\n    if (write(fd, buf, HEADER_SIZE) != HEADER_SIZE) {\n\n        goto fail;\n\n    }\n\n\n\n    ret = 0;\n\n\n\n fail:\n\n    return ret;\n\n}\n", "idx": 18138, "substitutes": {"fd": ["dc", "dd", "draft", "db", "fw", "fp", "fat", "f", " FD", "dir", "reader", "handle", "tty", "io", "file", "feed", "cf", "hd", "cod", "wb", " fid", "fc", "dl", "ptr", "wd", "fin", "fs", "fed", "lf", "fx", "d", "fl", "df", "bd", "ad", "handler", "fb", "buff", "xd", "c", "rb", "flo", "driver", "fn", "cd", "fi", "FD", "ds", "sf"], "buf": ["Buffer", "db", "ff", "data", "fp", "f", "buffer", "rc", "vec", "fi", "cb", "bc", "src", "loc", "wb", "ctx", "fin", "ptr", "bf", "bd", "queue", "buff", "fb", "v", "batch", "rb", "tmp", "seq", "b", "alloc", " buffer", "bytes", "uf", "cv"], "total_size": ["total_bytes", " total_capacity", " total_SIZE", "totalaccapacity", "total64size", " total_bytes", "totalacspeed", "total64loc", " total_loc", "totalacsize", "total_loc", "total64SIZE", "total_capacity", "total_SIZE", " total_speed", "total_speed"]}}
{"project": "qemu", "commit_id": "2c30dd744aa02d31a8a3b87daaba0b2cb774f346", "target": 0, "func": "static int local_readdir_r(FsContext *ctx, V9fsFidOpenState *fs,\n\n                           struct dirent *entry,\n\n                           struct dirent **result)\n\n{\n\n    return readdir_r(fs->dir, entry, result);\n\n}\n", "idx": 18142, "substitutes": {"ctx": ["rx", "pc", "cc", "fw", "conf", "obj", "jp", "vc", "rc", "cm", "exc", "cb", "cp", "loc", "bc", "utils", "cas", "Context", "cs", "exec", "context", "conv", "pkg", "tx", "ci", "xc", "lc", "cmp", "conn"], "fs": ["ns", "fw", "bs", "s", "rs", "fp", "obj", "f", "FS", "irs", "flows", "feed", "cf", "files", "ls", "fc", "cs", "fx", "acs", "df", "cms", "tx", "qs", "fd", "raf", "fb", "vs", "ks", "cache", "sys", "es", "os", "Fs", "ds"], "entry": [" Entry", "record", "archive", "data", "ent", "element", "info", " entries", "feed", "try", "enter", "ie", "ry", "array", "event", "import", "Entry", "ident", "id", "e", "ries", "deep", "insert", "cur", "si", "inter", "cell", "row", "end", "se", "inner", "reader"], "result": ["inner", "instance", "ret", "record", "data", "Result", "err", "comment", "rc", "r", "results", "counter", "report", "master", "match", "successful", "raw", "der", "arr", "pair", "final", "array", "event", "future", "response", "resource", "card", "res", "end", "desc", "list", "valid", "dict", "success"]}}
{"project": "qemu", "commit_id": "368d25881c94f9e09ef19a3d93e8fec797dbcd05", "target": 0, "func": "static int zrle_send_framebuffer_update(VncState *vs, int x, int y,\n\n                                        int w, int h)\n\n{\n\n    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);\n\n    size_t bytes;\n\n    int zywrle_level;\n\n\n\n    if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {\n\n        if (!vs->vd->lossy || vs->tight.quality < 0 || vs->tight.quality == 9) {\n\n            zywrle_level = 0;\n\n            vs->zrle.type = VNC_ENCODING_ZRLE;\n\n        } else if (vs->tight.quality < 3) {\n\n            zywrle_level = 3;\n\n        } else if (vs->tight.quality < 6) {\n\n            zywrle_level = 2;\n\n        } else {\n\n            zywrle_level = 1;\n\n        }\n\n    } else {\n\n        zywrle_level = 0;\n\n    }\n\n\n\n    vnc_zrle_start(vs);\n\n\n\n    switch(vs->clientds.pf.bytes_per_pixel) {\n\n    case 1:\n\n        zrle_encode_8ne(vs, x, y, w, h, zywrle_level);\n\n        break;\n\n\n\n    case 2:\n\n        if (vs->clientds.pf.gmax > 0x1F) {\n\n            if (be) {\n\n                zrle_encode_16be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_16le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_15be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_15le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 4:\n\n    {\n\n        bool fits_in_ls3bytes;\n\n        bool fits_in_ms3bytes;\n\n\n\n        fits_in_ls3bytes =\n\n            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&\n\n             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&\n\n             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));\n\n\n\n        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&\n\n                            vs->clientds.pf.gshift > 7 &&\n\n                            vs->clientds.pf.bshift > 7);\n\n\n\n        if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {\n\n            if (be) {\n\n                zrle_encode_24abe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ale(vs, x, y, w, h, zywrle_level);\n\n          }\n\n        } else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {\n\n            if (be) {\n\n                zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_24ble(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        } else {\n\n            if (be) {\n\n                zrle_encode_32be(vs, x, y, w, h, zywrle_level);\n\n            } else {\n\n                zrle_encode_32le(vs, x, y, w, h, zywrle_level);\n\n            }\n\n        }\n\n    }\n\n    break;\n\n    }\n\n\n\n    vnc_zrle_stop(vs);\n\n    bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);\n\n    vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);\n\n    vnc_write_u32(vs, bytes);\n\n    vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);\n\n    return 1;\n\n}\n", "idx": 18150, "substitutes": {"vs": ["ns", "ums", "vr", "pages", "las", "settings", "ports", "ss", "pos", "cs", "uv", "VS", "vis", "ev", "qs", "ov", "vt", "ks", "va", "env", "cv", "ms", "values", "ts", "fps", "rs", "vc", "vp", "px", "blogs", "vals", "lines", "lv", "posts", "vert", "nets", "sk", "pg", "vol", "obs", "iss", "v", "dev", "versions", "iv", "hs", "ver", "ds", "ves", "wp", "vas", "vg", "bs", "sv", "otes", "net", "ils", "ys", "ii", "utils", "vi", "nav", "ins", "Vs", "serv", "pps", "verts", "alls", "ps", "rss", "es", "rules", "state", "flags", "eps", "oss", "ens", "s", "styles", "stats", "services", "plugins", "ls", "ops", "fs", "xs", "vers", "views", "css", "js", "orts", "http", "gs", "os", "iffs", "opens"], "x": ["rx", "ic", "na", "m", "xx", "code", "t", "data", "wx", "f", "image", "ix", "px", "n", "on", "i", "z", "xy", "in", "index", "pos", "xs", "o", "l", "fx", "d", "up", "tx", "xt", "ex", "dx", "k", "X", "e", "id", "v", "c", "p", "line", "xi", "b", "win", "wa", "a", "py", "lat", "one", "wy", "u"], "y": ["j", "ch", "t", "f", "sky", "n", "ya", "i", "ys", "z", "ny", "xy", "zy", "ry", "cy", "o", "Y", "l", "d", "ye", "yi", "dy", "ay", "yy", "ey", "e", "ish", "yt", "v", "c", "yn", "p", "b", "win", "oy", "vy", "yo", "a", "py", "sy", "ies", "wy", "u"], "w": ["wp", "wt", "fw", "wx", "f", "r", "n", "wo", "wl", "we", "i", "sw", "z", "wb", "ow", "wan", "iw", "wd", "ew", "wall", "l", "d", "hw", "sh", "W", "wal", "ww", "way", "q", "v", "wid", "c", "wm", "p", "rw", "wr", "b", "win", "wu", "wa", "wn", "a", "wh", "aw", "wy", "u"], "h": ["m", "s", "ch", "f", "oh", "dh", "gh", "i", "hi", "g", "hd", "z", "rh", "th", "uh", "en", "home", "l", "hw", "ht", "sh", "kh", "height", "hl", "e", "q", "k", "bh", "v", "ih", "c", "hp", "p", "hm", "b", "hh", "how", "wh", "ph", "ha", "hs", "he", "ah", "H", "u"], "bytes": ["data", "ables", "amples", "all", "io", "cm", "ips", "ls", "ii", "ops", "byte", "out", "Bytes", "iff", "gb", "complete", "args", "lements", "elt", "bits", "odes", "ents", "os", "len"], "zywrle_level": ["zywrleaclevel", "zywrole_where", "zywrle0weight", "zywrge_vel", "zywrle_line", "zywrle0level", "zywrla_level", "zywrble_line", "zywrleacvalue", "zywrl_value", "zywrla_limit", "zywrole_vel", "zywrle_depth", "zywrle_all", "zywrl_line", "zywrla_vel", "zywrle_letter", "zywrleacvel", "zywrble_limit", "zywrle_value", "zywrle_vel", "zywrli_weight", "zywrle__limit", "zywrke_inc", "zywrle_limit", "zywrble_level", "zywrle_lvl", "zywrge_depth", "zywrle_weight", "zywrle__level", "zywrble_where", "zywrla_lock", "zywrke_depth", "zywrl_level", "zywrle0all", "zywrle__line", "zywrli_level", "zywrle_where", "zywrle_levels", "zywrke_levels", "zywrke_level", "zywrole_level", "zywrle_lock", "zywrleaclayer", "zywrble_letter", "zywrl_lvl", "zywrl_vel", "zywrl_layer", "zywrle_inc", "zywrge_level", "zywrle__where", "zywrli_all", "zywrle_layer", "zywrge_levels"], "fits_in_ls3bytes": ["fits_in_ls2units", "fits_in_ls6seconds", "fits_in_nsdbytes", "fits_in_las6bits", "fits_in_las3pieces", "fits_in_ls3pieces", "fits_in_las3bits", "fits_in_lsdbytes", "fits_in_ls6pieces", "fits_in_lsdbits", "fits_in_ns3bytes", "fits_in_ls6bytes", "fits_in_ls32pieces", "fits_in_ls1pieces", "fits_in_las6seconds", "fits_in_ls1seconds", "fits_in_lsthreebits", "fits_in_las6pieces", "fits_in_ls2bytes", "fits_in_ls32bits", "fits_in_ls32seconds", "fits_in_ls3seconds", "fits_in_ls1bits", "fits_in_ls6bits", "fits_in_ns3units", "fits_in_ls32bytes", "fits_in_lsthreeunits", "fits_in_las3bytes", "fits_in_ls3units", "fits_in_ns3bits", "fits_in_las6bytes", "fits_in_ls1bytes", "fits_in_lsdunits", "fits_in_ls3bits", "fits_in_las3seconds", "fits_in_nsdunits", "fits_in_ls2bits", "fits_in_lsthreebytes", "fits_in_nsdbits"], "fits_in_ms3bytes": ["fits_in_msdbytes", "fits_in_les6byte", "fits_in_ms2bits", "fits_in_ms3byte", "fits_in_msdbyte", "fits_in_les3bytes", "fits_in_ms2bytes", "fits_in_ms6bits", "fits_in_ms6byte", "fits_in_les6bytes", "fits_in_msdbits", "fits_in_les6bits", "fits_in_ms6bytes", "fits_in_ms2byte", "fits_in_les3bits", "fits_in_les3byte", "fits_in_ms3bits"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t mmio_ide_status_read(void *opaque, target_phys_addr_t addr,\n\n                                     unsigned size)\n\n{\n\n    MMIOState *s= opaque;\n\n    return ide_status_read(&s->bus, 0);\n\n}\n", "idx": 18159, "substitutes": {"opaque": ["ipec", "copc", "ipace", "copaque", " opacity", "copec", " opace", " opaco", "opac", "opec", "opacity", " opac", "ipac", "ipaco", " opc", "ipacity", " opec", "opaco", "OPaque", "opace", "ipaque", "OPac", "OPacity", "OPace", "opc", "copaco", "ipc"], "addr": ["dc", "part", "work", "Address", "data", "base", "ref", "ord", "type", "oa", "src", "ptr", "pos", "byte", "pointer", "host", "nr", "args", "config", "ad", "seq", "da", "address", "pad", "ada", "cap", "ace", "len"], "size": ["offset", "capacity", "small", "data", "mode", "SIZE", "shape", "type", " bytes", "empty", "args", "ize", "length", " Size", "c", "unit", "address", " sizes", "number", "bytes", "Size", "desc", " length", "len"], "s": ["spec", "m", "session", "request", "f", "settings", "services", "service", "r", "n", "g", "i", "sl", "ss", "ops", "scope", "fs", "o", "submit", "d", "e", "ssl", "ses", "sync", "c", "si", "sym", "p", "secondary", "S", "b", "h", "a", "state", "hs", "sq", "ds"]}}
{"project": "qemu", "commit_id": "e37e6ee6e100ebc355b4a48ae9a7802b38b8dac0", "target": 0, "func": "void tlb_flush_page(CPUState *env, target_ulong addr)\n\n{\n\n    int i;\n\n\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_flush_page: \" TARGET_FMT_lx \"\\n\", addr);\n\n#endif\n\n    /* must reset current TB so that interrupts cannot modify the\n\n       links while we are modifying them */\n\n    env->current_tb = NULL;\n\n\n\n    addr &= TARGET_PAGE_MASK;\n\n    i = (addr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    tlb_flush_entry(&env->tlb_table[0][i], addr);\n\n    tlb_flush_entry(&env->tlb_table[1][i], addr);\n\n#if (NB_MMU_MODES >= 3)\n\n    tlb_flush_entry(&env->tlb_table[2][i], addr);\n\n#if (NB_MMU_MODES == 4)\n\n    tlb_flush_entry(&env->tlb_table[3][i], addr);\n\n#endif\n\n#endif\n\n\n\n    tlb_flush_jmp_cache(env, addr);\n\n\n\n#ifdef USE_KQEMU\n\n    if (env->kqemu_enabled) {\n\n        kqemu_flush_page(env, addr);\n\n    }\n\n#endif\n\n}\n", "idx": 18161, "substitutes": {"env": ["entry", "viron", "obj", "here", "forge", "debug", "gui", "environment", "console", "fen", "energy", "enc", "vm", "exec", "equ", "ev", "config", "qt", "impl", "ea", "eur", "output", "dat", "enh", "cv", "conn", "enable", "eve", "eye", "eu", "engine", "app", "bc", "manager", "eng", "exe", "v", "ec", "ef", "et", "iter", "dict", "org", "ner", "fg", "code", "eh", "err", "net", "ou", "vs", "er", "eni", "np", "ah", "Environment", "vel", "db", "global", "conf", "exc", "loader", "enter", "oa", "ext", "en", "her", "context", "event", "nc", "e", "esm", "req", "que", "cache", "server", "el"], "addr": ["dd", "offset", "extra", "Address", "x", "obj", "ref", "align", "ar", "result", "adder", "ptr", "location", "layer", "config", "asm", "ea", "p", "adr", "word", "conn", "target", "len", "rx", "part", "work", "handle", "eth", "rc", "hop", "localhost", "rg", "pointer", "arr", "size", "off", "route", "ha", "port", "mac", "order", "amp", "r", "worker", "node", "loc", "src", "player", "di", "xp", "host", "ack", "nr", "device", "address", "inter", "ace", "amd", "edge", "eni", "rr", "ord", "coord", "enter", "oa", "ext", "index", "slice", "ip", "alias", "site", "add", "dr", "e", "kt", "url", "cmp", "intel", "server", "usr", "attr"], "i": ["ti", "uri", "gi", "j", "t", "info", "x", "f", "name", "ix", "ini", "qi", "io", "ai", "phi", "type", "ii", "ie", "iu", "index", "di", "I", "min", "multi", "o", "ip", "l", "d", "yi", "pi", "ui", "site", "ci", "id", "key", "e", "v", "cli", "c", "si", "ri", "p", "xi", "address", "line", "b", "mu", "field", "a", "it", "eni", "diff", "source", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "daa7a1d4431b6acf1f93c4a98b3de123abf4ca18", "target": 0, "func": "void ff_slice_thread_free(AVCodecContext *avctx)\n\n{\n\n    ThreadContext *c = avctx->thread_opaque;\n\n    int i;\n\n\n\n    pthread_mutex_lock(&c->current_job_lock);\n\n    c->done = 1;\n\n    pthread_cond_broadcast(&c->current_job_cond);\n\n    pthread_mutex_unlock(&c->current_job_lock);\n\n\n\n    for (i=0; i<avctx->thread_count; i++)\n\n         pthread_join(c->workers[i], NULL);\n\n\n\n    pthread_mutex_destroy(&c->current_job_lock);\n\n    pthread_cond_destroy(&c->current_job_cond);\n\n    pthread_cond_destroy(&c->last_job_cond);\n\n    av_free(c->workers);\n\n    av_freep(&avctx->thread_opaque);\n\n}\n", "idx": 18171, "substitutes": {"avctx": ["akcv", "avectx", "AVlib", "afcmp", "apcmp", "apconfig", "avconfig", "avca", "avlc", "avlib", "AVconfig", "ablc", "awctx", "afca", "aflc", "apcontext", "awcontext", "AVcmp", "afcontext", "akcontext", "aflib", "apctx", "afctx", "abctx", "abcontext", "abcmp", "awcmp", "afconfig", "AVlc", "avecontext", "AVctx", "aveca", "akca", "akctx", "avcv", "AVcontext", "avcmp", "awlib", "avecv", "avcontext", "afcv"], "c": ["pc", "dc", "oc", "m", "s", "t", "f", "vc", "ct", "conn", "n", "cm", "cf", "g", "coll", "anc", "bc", "cp", "ctx", "this", "mc", "fc", "self", "ctrl", "count", "ca", "cs", "arc", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "xc", "config", "e", "cu", "k", "sc", "cr", "v", "lc", "cl", "cur", "p", "uc", "can", "b", "cmp", "ec", "h", "cn", "co", "icc", "C", "cc", "u"], "i": ["ti", "gi", "uri", "m", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "r", "io", "ai", "n", "mi", "phi", "hi", "z", "ii", "di", "iu", "index", "I", "multi", "zi", "count", "o", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "e", "k", "v", "si", "ri", "p", "xi", "b", "h", "a", "fi", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "e5dd4ae7284bb290d8dc8e9cd3f2e035d1d77cd0", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175, "substitutes": {"avctx": ["ajctx", "avc", "ajcontext", "afc", "ajcv", "ajci", "ajloc", "afcontext", "AVci", "abc", "afctx", "abctx", "abcontext", "avci", "AVloc", "ajc", "abcv", "afloc", "afci", "avloc", "AVctx", "avcv", "AVcontext", "avcontext", "afcv"], "data": ["part", "Data", "content", "offset", "code", "mode", "reader", "base", "name", "image", "media", "buffer", "result", "window", "type", "padding", "pos", "progress", "pointer", "d", "empty", "draw", "complete", "size", "memory", "length", "id", "start", "ad", "open", "parent", "map", "da", "p", "address", "pad", "ada", "cache", "missing", "dat", "ata", "next", "body", "DATA", "message", "bytes", "addr", "frame", "connection", "a", "alpha", "value", "source", "input"], "got_sub_ptr": ["got_sub_dr", "got_subipdim", "got_sub_dim", "got_subxpointer", "got_sub_addr", "got_subxptr", "got_subxaddr", "got_subipaddr", "got_sub_pointer", "got_subxdr", "got_subipptr", "got_subippointer"], "avpkt": ["avpcht", "ajpakt", "avfcht", "avmka", "abpnt", "avprkt", "avpkg", "avpqt", "uppkt", "abpkt", "avpcp", "abfkt", "abfkg", "avvpkt", "avvkt", "avfkg", "avspct", "ajpke", "ajpcht", "afPqt", "avprqt", "upvpacket", "avpwk", "avnkt", "avPqt", "avpake", "avpcacket", "avfet", "avnacket", "avspqt", "afpct", "afPkt", "avfnt", "avfwk", "avnqt", "abfqt", "avpawk", "upvpet", "avpet", "avspkt", "afpkt", "abpkg", "avprct", "afPcp", "avprcp", "abpwk", "avfqt", "ajpkt", "ajpake", "avvpacket", "uppet", "ajpaacket", "abpacket", "avpant", "avvpet", "ajpacht", "avPcht", "abfwk", "avpckt", "afpcp", "avmkt", "avPcp", "avPct", "upvpkt", "avmet", "avpct", "uppacket", "avpnt", "uppka", "afPct", "avnkg", "avvpka", "ajpacket", "avspcp", "abpqt", "avpka", "avpacket", "abfacket", "avvqt", "avfkt", "upvpka", "avfka", "avpke", "afpqt", "avpacht", "abfnt", "avpaacket", "avvacket", "avPke", "avmacket", "avpakt", "avvkg", "avpcnt", "avpcwk", "avfacket", "avPkt", "avfke", "avPacket"], "ptr": ["point", "offset", "pointers", "tr", "fp", "ref", "ctr", "tty", "buffer", "coord", " pointer", "loc", "src", "ctx", "ext", "slice", "pos", "index", "pointer", "context", "length", "tell", "start", "fd", "dr", "buff", "buf", "temp", "req", "cur", "tmp", "patch", "p", "shift", "address", "pad", "depth", "alloc", "proc", "inst", "addr", "Ptr", "port", "desc", "attr", "pt"], "len": ["lon", "part", "offset", "code", "ell", "lim", "base", "name", "all", "lit", "vec", "n", "fun", "str", "i", "sl", "z", "loc", "ls", "ie", "led", "fin", "dl", "pos", "min", "en", "count", "lt", "lf", " el", "ln", "l", "low", "val", "fl", "size", "le", "pre", "dy", "length", "hl", "ler", " length", "id", "start", "rev", "span", "elt", "lc", "c", "seq", "lib", "line", "url", "doc", "req", "split", "bytes", "iter", "lang", "el", "li", "Len"], "dialog": ["llogue", "chalogs", "Dialogue", "collog", "llocation", "dialogue", "chalogue", "colog", "diffogs", "defogue", "llog", "defogs", "diffogue", "chalogging", "logog", "diffog", "cologue", "dialit", "dialogs", "Dialog", "logocation", "llocol", "colocation", "logogue", "Dialogo", "collogo", "Dialit", "dialocation", "defog", "dialogging", "logocol", "colocol", "chalog", "defogging", "dialogo", "diffogging", "collit", "collogue", "dialocol", "logogo", "logit"]}}
{"project": "qemu", "commit_id": "5e003f17ec518cd96f5d2ac23ce9e14144426235", "target": 1, "func": "static int init_blk_migration(QEMUFile *f)\n\n{\n\n    BlockDriverState *bs;\n\n    BlkMigDevState *bmds;\n\n    int64_t sectors;\n\n    BdrvNextIterator it;\n\n    int i, num_bs = 0;\n\n    struct {\n\n        BlkMigDevState *bmds;\n\n        BlockDriverState *bs;\n\n    } *bmds_bs;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    block_mig_state.submitted = 0;\n\n    block_mig_state.read_done = 0;\n\n    block_mig_state.transferred = 0;\n\n    block_mig_state.total_sector_sum = 0;\n\n    block_mig_state.prev_progress = -1;\n\n    block_mig_state.bulk_completed = 0;\n\n    block_mig_state.zero_blocks = migrate_zero_blocks();\n\n\n\n    for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {\n\n        num_bs++;\n\n    }\n\n    bmds_bs = g_malloc0(num_bs * sizeof(*bmds_bs));\n\n\n\n    for (i = 0, bs = bdrv_first(&it); bs; bs = bdrv_next(&it), i++) {\n\n        if (bdrv_is_read_only(bs)) {\n\n            continue;\n\n        }\n\n\n\n        sectors = bdrv_nb_sectors(bs);\n\n        if (sectors <= 0) {\n\n            ret = sectors;\n\n\n            goto out;\n\n        }\n\n\n\n        bmds = g_new0(BlkMigDevState, 1);\n\n        bmds->blk = blk_new(BLK_PERM_CONSISTENT_READ, BLK_PERM_ALL);\n\n        bmds->blk_name = g_strdup(bdrv_get_device_name(bs));\n\n        bmds->bulk_completed = 0;\n\n        bmds->total_sectors = sectors;\n\n        bmds->completed_sectors = 0;\n\n        bmds->shared_base = migrate_use_block_incremental();\n\n\n\n        assert(i < num_bs);\n\n        bmds_bs[i].bmds = bmds;\n\n        bmds_bs[i].bs = bs;\n\n\n\n        block_mig_state.total_sector_sum += sectors;\n\n\n\n        if (bmds->shared_base) {\n\n            DPRINTF(\"Start migration for %s with shared base image\\n\",\n\n                    bdrv_get_device_name(bs));\n\n        } else {\n\n            DPRINTF(\"Start full migration for %s\\n\", bdrv_get_device_name(bs));\n\n        }\n\n\n\n        QSIMPLEQ_INSERT_TAIL(&block_mig_state.bmds_list, bmds, entry);\n\n    }\n\n\n\n    /* Can only insert new BDSes now because doing so while iterating block\n\n     * devices may end up in a deadlock (iterating the new BDSes, too). */\n\n    for (i = 0; i < num_bs; i++) {\n\n        BlkMigDevState *bmds = bmds_bs[i].bmds;\n\n        BlockDriverState *bs = bmds_bs[i].bs;\n\n\n\n        if (bmds) {\n\n            ret = blk_insert_bs(bmds->blk, bs, &local_err);\n\n            if (ret < 0) {\n\n                error_report_err(local_err);\n\n                goto out;\n\n            }\n\n\n\n            alloc_aio_bitmap(bmds);\n\n            error_setg(&bmds->blocker, \"block device is in use by migration\");\n\n            bdrv_op_block_all(bs, bmds->blocker);\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    g_free(bmds_bs);\n\n    return ret;\n\n}", "idx": 18187, "substitutes": {"f": ["m", "fr", "xf", "t", "fp", "info", "fe", "file", "fa", "feed", "fc", "fs", "filename", "fo", "l", "d", "df", "e", "fd", "c", "fu", "F", "p", "b", "tf", "fn", "fi", "sf"], "bs": ["ns", "ab", "eb", "ts", "s", "lbs", "stats", "db", "blog", "obj", "base", "ob", "las", "rs", "fe", "feed", "ubs", "hop", "sb", "cb", "bc", "ss", "ls", "loc", "hub", "src", "pb", "fs", "lb", "bb", "ba", "bid", "cs", "css", "gb", "bo", "bos", "bed", "ins", "bps", "obs", "bu", "BS", "iss", "blocks", "bis", "browser", "bl", "bas", "ses", "vs", "bot", "bits", "ps", "fb", "lib", "js", "bh", "b", "http", "gs", "boot", "loop", "os", "state", "bes", "banks", "ds", "bing"], "bmds": ["bndl", "bndls", "vmde", "binmdls", " bmme", "bmuns", "bmdls", "bnds", "bmdches", "b\n", "bmdps", "bmdirs", "bc\n", "bmde", "bmgils", "vmds", "Bcmdps", "bmms", "bcmdi", "bmdqs", "Bmds", "bdrns", "bmdn", "bmadabs", "bMDs", " bmdqs", "B\n", "bmln", "bdre", "bgmacs", " bndb", " bmdn", " b\n", "bddps", "bcmds", "bdefches", "bidde", "bdefs", "bmdss", "bindils", "bgmds", "libmadabs", "baldn", " bmdss", "baldses", "bmdl", "bgmdlines", "bdrps", "bhardl", " bg", "bmaclines", "binmuns", "Bmde", "bmadps", "bmadss", "bmunqs", "b_", "bdefabs", "bmgirs", "fcmdirs", "bcmdc", "Bmdps", "bcmdils", "Bcmds", " bmdb", "bcg", "binmunqs", "binmds", "bndqs", "bmmn", "bmmc", "bmdjs", "bcmdirs", "brefabs", " bmdi", " bcmds", " bMDss", "bmmi", "bgmacn", "libmdabs", "fmdirs", " bmdses", "bmdils", "bhardb", "biddses", "bcmdls", "libmdches", "bg", "bmade", "bmadches", "B_", "bmdses", " bmde", "fmdils", "bmdi", "balds", "fcmdils", "libmads", "bndb", "bcmdps", " bnds", "bmdc", "libmadns", " bmms", "bmadns", "vmdps", "bmdabs", "fmds", "bMDss", "libmadches", "bhards", " bMDses", "bMDses", "bdrs", "libmdns", "brefches", "bmme", "brefns", "bcmdl", "bndjs", "bmunls", "bddc", "bmlses", "libmds", "bcmdb", "bcmdlines", "biddss", "bmdb", "vmdns", "bcmde", "bindirs", " bndl", " bcmdqs", "bgmaclines", "binds", "vmads", "bmdns", "bMDi", "bmdlines", "bc_", "bgmdn", "bmacs", "Bg", " bmmi", "Bcmdc", "bmacn", "bmads", "bdefns", "Bcmde", "bMDns", "baldqs", "bhardjs", "bidds", "bdds", "bMDe", "bMDps", " b_", "bcmdn", "bcmdses", "bmadses", "bmmps", "bmgs", "Bmdc", "bcmdqs", "binmdqs", "fcmds", " bMDs", "vmadns", "bcmdjs", "brefs", " bcmdses", " bmdjs", "vmadps", "bmls", " bmdl", "vmade", " bcmdn", " bndjs", "binmunls", " bMDe", "bdde", "bmmlines", "bmlqs"], "sectors": ["Sector", " secs", "vections", "gefs", " sections", "pegments", "cections", "iegment", "spexes", "gexes", "gerets", "perets", " selements", "sections", "gectors", "vexes", "pecs", "gections", "spegments", " sexes", "spections", "sector", " sector", "secs", "pections", "specs", "sefs", "tector", "segments", "iefs", "spectors", "selements", "telements", "sexes", "pelements", "spelements", "gegment", "Selements", "serets", " sefs", "pectors", "iectors", "cectors", " segments", "Sectors", "vectors", "tectors", "cerets", "tections", "celements", "segment", "Sections", "vecs", "iexes", "gelements", " segment"], "it": ["ic", "ti", "bin", "init", "IT", "ite", "j", "t", "itted", "sit", "bit", "jit", "ort", "ct", "op", "edit", "let", "reg", "lit", "pit", "n", "feed", "ble", "loc", "in", "ie", "sec", "dit", "quit", "ip", "exec", "mit", "join", "l", "ins", "ac", "ci", "rit", "bas", "you", "ait", "unit", "si", "p", "iti", "iz", "item", "b", "ul", "its", "It", "itter", "hit", "iter"], "i": ["ti", "gi", "uri", "wei", "bi", "j", "x", "base", "ini", "qi", "ai", "io", "n", "phi", "mi", "hi", "z", "ii", "in", "ie", "iu", "index", "ind", "di", "I", "ori", "vi", "zi", "mini", "is", "chi", "l", "d", "yi", "pi", "ui", "ci", "id", "start", "k", "e", "cli", "v", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "uli", "h", "eni", "fi", "ij", "y", "li", "ib", "u"], "bmds_bs": ["bmds2body", "bmds__bc", "bmda_bits", "bmdsJbs", "bmdsJb", "bmdqs_bas", "bmdqs_bs", "bmda_ns", "bmds_bas", "bmdqs_abs", "bmds2b", "bmds_b", "bmdds_ls", "bmds__bs", "bmds2bs", "bmdds_bas", "bmdps_body", "bmds_ls", "bmdps_bs", "bmdsJbody", "bmdsJns", "bmdqs_bc", "bmds__abs", "bmds__bas", "bmdds_b", "bmds_body", "bmdps_b", "bmds_bits", "bmds_abs", "bmdps_ns", "bmdds_bs", "bmds2ns", "bmds_ns", "bmds_bc", "bmda_ls", "bmda_bs"], "local_err": ["local7error", "localallerr", "local_data", "localalldiff", "local7data", " local_error", " local_data", " local_diff", "local7diff", "local7err", "localallerror", "localalldata", "local_error", "local_diff"], "ret": ["rs", "info", "al", "x", "conn", "rc", "reg", "nt", "fun", "lit", "result", " res", "sel", "ext", "sec", "mem", "resp", "rets", "def", "multi", "out", "arr", "exec", "val", "re", "Ret", "std", "esi", "back", " RET", "det", "selected", "seq", " Ret", "RET", "rep", "res", " resp", "list", "fi", "bus", "section", "success", "len"], "num_bs": ["num__ls", "num_bc", " num_blocks", " num_bytes", "num__ns", "numXbytes", "numDsections", " num_ses", "numDvs", " num_sections", "multi_ls", "multi_bs", "num_ns", " num_vs", "num_os", "num_vs", " num_ns", "num_ses", "num_bytes", "num_ls", "num__bc", "num__ses", "num__os", " num_bc", "num_sections", "numDblocks", "num__blocks", "numXns", "multi_ns", "numDbs", "multi_os", "num_blocks", "num__bs", "numXblocks", "numXbs"]}}
{"project": "qemu", "commit_id": "6baebed7698a37a0ac5168faf26023426b0ac940", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194, "substitutes": {"vs": ["ns", "ums", "vas", "ts", "s", "bs", "stats", "rs", "vr", "las", "sv", "vc", "services", "vp", "ils", "vals", "sb", "ys", "ss", "ls", "ops", "fs", "xs", "lines", "lv", "vers", "sk", "views", "cs", "css", "VS", "obs", "outs", "qs", "ov", "ses", "v", "verts", "js", "ps", "alls", "vt", "sts", "ks", "http", "gs", "va", "es", "env", "cv", "ds"], "y": ["j", "ch", "ky", "t", "sky", "iy", "hy", "ya", "i", "year", "ys", "type", "z", "ny", "ym", "zy", "ry", "cy", "Y", "l", "d", "ye", "yi", "dy", "ay", "w", "height", "yy", "ey", "e", "ish", "key", "yt", "v", "yr", "c", "yn", "p", "col", "oy", "vy", "yo", "gy", "a", "py", "sy", "u"], "last_x": ["last__w", " last_ex", "last_index", "last__xy", " last_xp", "prev_y", " last_z", " last_xy", "last__xp", "last__x", " last_w", "prev_x", "prev_w", "prev_index", "last__y", "last__z", "last_w", "last_z", "last_xy", "last_xp", "last__ex", "last_y", "last_ex", " last_y"], "x": ["rx", "m", "xf", "xx", "t", "f", "ix", "px", "n", "i", "z", "xy", "max", "index", "pos", "xs", "en", "l", "d", "ax", "ex", "w", "dx", "e", "X", "q", "_", "v", "c", "p", "xi", "wa", "u"], "h": ["m", "j", "ch", "code", "t", "eh", "f", "oh", "hr", "n", "hy", "dh", "g", "gh", "hi", "i", "hd", "z", "rh", "max", "ho", "uh", "o", "han", "his", "home", "hhh", "l", "d", "ht", "sh", "kh", "height", "w", "hl", "id", "k", "q", "e", "bh", "v", "ih", "c", "hp", "p", "hm", "b", "hh", "ph", "ha", "hs", "he", "ah", "H", "u"], "tmp_x": ["tmp__xi", "last_rx", " tmp_name", " tmp_xs", "tmp_ex", " tmp_ex", "tmp_ix", " tmp_X", "last_ix", "tmp__y", "tmp_name", " tmp_rex", "tmp_xs", "tmp_pe", "tmp__pe", "tmp_X", " tmp_xi", " tmp_pe", "tmp_rex", "tmp__x", "tmp_y", " tmp_y", "last_X", "tmp_rx", "tmp_xi"]}}
{"project": "qemu", "commit_id": "a0067da1577e3eb0c60758384282568f4b2328fe", "target": 1, "func": "static void test_dispatch_cmd_failure(void)\n\n{\n\n    QDict *req = qdict_new();\n\n\n    QObject *resp;\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd2\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n\n\n    /* check that with extra arguments it throws an error */\n\n    req = qdict_new();\n\n    qdict_put(args, \"a\", qint_from_int(66));\n\n    qdict_put(req, \"arguments\", args);\n\n\n\n    qdict_put_obj(req, \"execute\", QOBJECT(qstring_from_str(\"user_def_cmd\")));\n\n\n\n    resp = qmp_dispatch(QOBJECT(req));\n\n    assert(resp != NULL);\n\n    assert(qdict_haskey(qobject_to_qdict(resp), \"error\"));\n\n\n\n    qobject_decref(resp);\n\n    QDECREF(req);\n\n}", "idx": 18195, "substitutes": {"req": ["require", "grad", "spec", "ref", "report", "ar", "str", "var", "exec", "rec", "comp", "config", "id", "qt", "qq", "res", "gr", "conn", "rx", "work", "urg", "ctr", "hr", "dq", "query", "self", "arg", "art", "load", "row", "desc", "org", "required", "fr", "push", "err", "call", "f", "respond", "r", "rt", "rel", "worker", "cb", "root", "rh", "this", "ry", "crit", "ack", "ru", "q", "qa", "er", "pro", "progress", "cook", "rr", "request", "reg", "loader", "ctx", "def", "pkg", "args", "response", "pull", "dr", "e", "par", "cur", "rb", "cmd", "cache", "http", "requ", "form", "proc", "attr"], "resp": ["html", "grad", "obj", "ref", "inc", "report", "result", "comm", "zip", "exec", "sol", "rec", "comp", "ev", "buff", "rev", "temp", "Response", "p", "repl", "resource", "rep", "res", "gr", "conn", "part", "work", "wx", "hop", "bb", "object", "remote", "patch", "download", "wp", "ret", "fr", "esp", "err", "call", "jp", "f", "respond", "r", "rel", "rh", "wb", "model", "page", "val", "re", "serv", "q", "rss", "reply", "progress", "cook", "params", "rr", "session", "request", "data", "sp", "reg", "ctx", "Resp", "pkg", "args", "response", "respons", "ll", "cmd", "cache", "error", "proc", "api"]}}
{"project": "FFmpeg", "commit_id": "b754978a3b0aa17e7794f64c69bf4491762797fd", "target": 0, "func": "static void add_index_entry(AVStream *st,\n\n                            int64_t pos, int64_t timestamp, int flags)\n\n{\n\n    AVIndexEntry *entries, *ie;\n\n    \n\n    entries = av_fast_realloc(st->index_entries,\n\n                              &st->index_entries_allocated_size,\n\n                              (st->nb_index_entries + 1) * \n\n                              sizeof(AVIndexEntry));\n\n    if (entries) {\n\n        st->index_entries = entries;\n\n        ie = &entries[st->nb_index_entries++];\n\n        ie->pos = pos;\n\n        ie->timestamp = timestamp;\n\n        ie->flags = flags;\n\n    }\n\n}\n", "idx": 18200, "substitutes": {"st": ["ist", "est", "stat", "ts", "nd", "t", "rest", "dest", "ct", "sp", "ste", "td", "rt", "str", "sb", "ost", "sw", "sl", "ast", "stream", "src", "ss", "lex", "ld", "ST", "sta", "sk", "art", "std", "stack", "sn", "sr", "sc", "start", "sth", "cl", "c", "stage", "ust", "sts", "osc", "St", "inst", "ace", "ft", "asts", "sa", "sf"], "pos": ["pc", "part", "spec", "offset", "pid", "time", "obj", "base", "ref", "loc", "Pos", "index", "ptr", "timeout", "tag", "count", "pointer", "POS", "po", "prop", "Position", "val", "slot", "axis", "size", " position", "comp", "pri", "length", "rot", "start", "open", "neg", "position", "seq", "patch", "address", "pose", "cache", "clock", "opt", "os", "addr", "port", "diff", "pt", "len"], "timestamp": ["dimpoint", "timet", "Timeness", "typette", "timeness", "typestamp", "stimetime", "immetime", "guestamp", "timette", "typet", "stimestamp", "typpoint", "timence", "immempt", "stimeline", "timeestamp", "immestamp", "immeline", "timpoint", "guence", "tunet", "gueline", "dimet", "tunpoint", "Timempt", "stimempt", "timeence", "tunette", "timetime", "Timetime", "timempt", "dimestamp", "timeeness", "gueness", "tunestamp", "timeline", "Timeline", "Timestamp", "Timence", "timeeline", "dimette"], "flags": ["types", "status", "strings", "fixes", "offset", "s", "fps", "stats", "leases", "FLAG", "f", "fields", "options", "faces", "issues", "Flags", "vals", "tails", "times", "flag", "tags", "files", "ints", "ops", "items", "ags", "fs", "mask", "lines", "mods", "lf", "links", "args", "features", "fts", "includes", "frames", "bits", "atts", "lag", "fee", "events", "ants", "tracks", "properties", "bytes", "members", "parts", "comments", "locks"], "entries": ["questrys", "encries", "Entries", "ntlements", "questries", "antrys", "antries", "endrance", "eventories", "encrys", "entories", "endies", "outrance", "encities", "antities", "entrants", "entsries", "contities", "questrants", "outries", "eventities", "rentrants", "entrance", "rentrance", "ntrys", "entsories", " entrys", "rentrys", "ntities", "questrance", " entles", "rentries", "entsities", "ntries", "outrys", "endities", "contrys", "endries", "endlements", "eventries", "entlements", "entles", "ntles", " entities", "eventrys", "entsrys", "Enties", "Entrys", "antrance", "entities", "outities", "entrys", "Entrance", "enties", "contles", "nties", "Entrants", "endrys", "contries", "encories", "Entlements"], "ie": ["entry", "IE", "lie", "ei", "eb", "bi", "ji", "ite", "ell", "info", "ine", "net", "fe", "ne", "sie", "je", "tie", "ge", "zie", "ide", "ii", "lex", "ext", "sea", "zip", "zi", "ee", "ze", "ip", "ice", "ce", "le", "rie", "ci", "e", "kie", "oe", "elt", "si", "ade", "pie", "nie", "ke", "ace", "edge", "se", "eni", "el", "ies", "li"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int rv10_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n\n                             AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    MpegEncContext *s = avctx->priv_data;\n\n    AVFrame *pict = data;\n\n    int i, ret;\n\n    int slice_count;\n\n    const uint8_t *slices_hdr = NULL;\n\n\n\n    av_dlog(avctx, \"*****frame %d size=%d\\n\", avctx->frame_number, buf_size);\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0) {\n\n        return 0;\n\n    }\n\n\n\n    if (!avctx->slice_count) {\n\n        slice_count = (*buf++) + 1;\n\n        buf_size--;\n\n\n\n        if (!slice_count || buf_size <= 8 * slice_count) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Invalid slice count: %d.\\n\",\n\n                   slice_count);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        slices_hdr = buf + 4;\n\n        buf       += 8 * slice_count;\n\n        buf_size  -= 8 * slice_count;\n\n    } else\n\n        slice_count = avctx->slice_count;\n\n\n\n    for (i = 0; i < slice_count; i++) {\n\n        unsigned offset = get_slice_offset(avctx, slices_hdr, i);\n\n        int size, size2;\n\n\n\n        if (offset >= buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if (i + 1 == slice_count)\n\n            size = buf_size - offset;\n\n        else\n\n            size = get_slice_offset(avctx, slices_hdr, i + 1) - offset;\n\n\n\n        if (i + 2 >= slice_count)\n\n            size2 = buf_size - offset;\n\n        else\n\n            size2 = get_slice_offset(avctx, slices_hdr, i + 2) - offset;\n\n\n\n        if (size <= 0 || size2 <= 0 ||\n\n            offset + FFMAX(size, size2) > buf_size)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        if ((ret = rv10_decode_packet(avctx, buf + offset, size, size2)) < 0)\n\n            return ret;\n\n\n\n        if (ret > 8 * size)\n\n            i++;\n\n    }\n\n\n\n    if (s->current_picture_ptr != NULL && s->mb_y >= s->mb_height) {\n\n        ff_er_frame_end(&s->er);\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            if ((ret = av_frame_ref(pict, &s->current_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            if ((ret = av_frame_ref(pict, &s->last_picture_ptr->f)) < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->last_picture_ptr);\n\n        }\n\n\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *got_frame = 1;\n\n        }\n\n\n\n        // so we can detect if frame_end was not called (find some nicer solution...)\n\n        s->current_picture_ptr = NULL;\n\n    }\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 18202, "substitutes": {"avctx": ["evcmp", "evctl", "afcmp", "auconn", "ajcontext", "avpkg", "averctx", "avctrl", "avhw", "airvoc", "abcontext", "avehw", "evcontext", "ajpkg", "afloc", "afcci", "avtx", "AVctx", "auctrl", " avcontext", "avalkw", "vertx", "ajhw", "avvoc", "Avctx", "airctx", "Avctl", "avctl", "aveconn", "afnp", "avercontext", "ajvoc", "akctrl", " avloc", "avalcli", "ajcci", "auctx", "abpkg", "ajctrl", "aucontext", "akcli", "aucf", "afctrl", " avcf", "AVloc", "afvoc", "avcci", "avcmp", "afcf", "aftx", "avcli", "vercontext", "avercli", "avalnp", "avalcci", "ajctx", "abcf", "avkw", " avpkg", "Avcontext", "avcf", "avloc", "avnp", "akctx", "AVcontext", "afkw", "avalctx", "avepkg", "afpkg", " avconn", "avalcontext", "avectx", "afctl", "verctx", "Avcmp", "averkw", "abctrl", "verpkg", "aircontext", "afhw", "afcontext", "akcontext", "ajnp", "avconn", "afctx", "abctx", "evctx", "avecontext", "AVcf", "aircci", "ajcli", "afconn", "abconn", "afcli", "autx", "avcontext", "aupkg"], "data": ["Data", "content", "au", "code", "reader", "sample", "base", "image", "f", "media", "buffer", "result", "window", "channel", "package", "padding", "slice", "o", "load", "d", "empty", "val", "array", "memory", "response", "start", "ad", "buff", "client", "parent", "tmp", "da", "p", "video", "address", "pad", "cache", "dat", "next", "body", "api", "DATA", "bytes", "message", "frame", "connection", "a", "value", "input"], "got_frame": ["buf_image", "buf_frames", "received_image", "buf_width", "bufvalframe", "bufvalwidth", "bufvalimage", "bufvalframes", "received_frames", "received_width", "received_frame", "buf_frame"], "avpkt": ["avppKT", "avcKT", "abcpfd", "avfkt", "avpKT", "evpacket", "avPkg", " avppk", "abcpkt", "avfct", "evpkg", "avcpkt", "avbpacket", "avvpk", "avbpkt", " avppkt", " avpKT", "avbpkg", "avpk", "avpkg", "abpfd", "evfkg", "avPsth", "avpfd", " avppKT", "abpkt", "avvpKT", " avppck", "avfsth", "abpct", "evpsth", "avppk", "avvpkt", "avpct", "avfkg", "avcpfd", " avpk", "evfsth", "avpck", " avpck", "avbpsth", "avpacket", "evpkt", "avffd", "avppkt", "avvpck", "evfkt", "abcpct", "avppck", "avvpacket", "avfacket", "avpsth", "abpacket", "abcpacket", "avvpfd", "avck", "avcck", "avvpct", "avPkt", "avcpct", "avcpacket", "evfacket", "avPacket", "avckt"], "buf": ["br", "func", "lim", "ctr", "true", "pool", "buffer", "rc", "vec", "result", "cf", "pack", "num", "window", "cb", "block", "cp", "bc", "loc", "src", "wb", "ctx", "pb", "pos", "cas", "xff", "home", "header", "array", "conv", "pkg", "feat", "av", "uu", "box", "aux", "img", "queue", "config", "front", "buff", "fb", "cur", "rb", "seq", "uc", "shift", "cmd", "off", "b", "cmp", "cap", "la", "alloc", "proc", "wa", "ha", "port", "bag", "uf", "cv", "len"], "s": ["ns", "spec", "m", "session", "j", "stats", "aws", "conf", "sv", "sp", "services", "service", "g", "sl", "ss", "utils", "self", "is", "cs", "d", "args", "sub", "sc", "ssl", "ses", "v", "sync", "c", "ps", "p", "S", "http", "gs", "sys", "storage", "a", "os", "se", "server", "sa"], "pict": ["fr", "arf", "fw", "ff", "af", " img", "image", "ref", "fa", " ff", "in", " f", "fs", "rf", "fo", "fl", "feat", "img", "rn", "w", "F", "fm", " fr", " fa", "aw", " r", "ft", " w", "cv", "wave"], "i": ["ti", "gi", "uri", "part", "bi", "init", "j", "ji", "code", "ami", "offset", "info", "x", "f", "name", "image", "ix", "ini", "qi", "r", "io", "mi", "ai", "phi", "g", "hi", "z", "ii", "ie", "in", "iu", "index", "di", "ind", "I", "slice", "multi", "zi", "mini", "is", "ip", "chi", "l", "oi", "pi", "uni", "ui", "ci", "id", "e", "ni", "c", "si", "p", "xi", "field", "h", "api", "it", "eni", "my", "fi", "esi", "inner", "y", "li", "u"], "ret": ["status", "info", "bit", "ref", "alt", "rc", "reg", "nt", "mi", "rt", "fun", "lit", "result", "r", "flag", "match", "ext", "fin", "mini", "mem", "def", "rets", "en", "arg", "bad", "val", "re", "Ret", "bf", "back", "value", "img", "xt", "det", "rb", " Ret", "RET", "error", "red", "res", "mt", "iter", "ft", "desc", "fi", "reply", "success", "len"], "slice_count": ["slice54size", " slice_loop", "slice_state", "slice_length", " slice_sum", "slice67div", "slice67count", " slice_label", "slice0count", "sliceNcount", "sliceablenumber", "slice54count", "slice0offset", "field_number", "byte67div", "byte_div", "field_offset", "field54number", "slice_limit", "slice67size", " slice_state", "slice54number", " slice_limit", "slicexgroup", "slice_div", "sliceOstate", "sliceNset", "sliceOlength", "field_count", "slice0number", "sliceablecount", " slice_length", " slice_size", "slice54offset", " slice_type", "slice67label", "field54size", " slice_start", "slice_number", " slice_queue", "sliceOstart", "slice4ref", " slice_group", "slice_group", "field54count", "slice_type", "byte67size", "sliceNsize", "slice4size", "slice_start", "slice_label", "sliceOcount", "slice_set", "slice_offset", "sliceablesize", "slice_ref", "byte_count", " slice_set", " slice_number", "field_size", " slice_ref", "byte_size", "slice_queue", "field54offset", "slice_loop", "byte67count", "sliceablelimit", "slice4count", "slice_size", "slice_sum", "slice0size", "slicexcount", "slicexloop"], "slices_hdr": ["slices_cdr", "slices_card", "slices_phdr", "slices_Hier", "slices_hr", "slices_shard", "slices_Hider", "slices_archdr", "slices_hstr", "slices_hier", "slices_Haddr", "slices_hhard", "slices_hhdr", "slices_hpider", "slices_shDR", "slices_hhtr", "slices_hDR", "slices_adhstr", "slices_adhict", "slices_phict", "slices_shdr", "slices_hard", "slices_hdier", "slices_hrt", "slices_hhDR", "slices_frt", "slices_shtr", "slices_archider", "slices_fhr", "slices_adhdr", "slices_hpdr", "slices_hddr", "slices_htr", "slices_hpaddr", "slices_cDR", "slices_Hr", "slices_hict", "slices_harrt", "slices_HDR", "slices_fdr", "slices_ctr", "slices_phstr", "slices_hpDR", "slices_harhr", "slices_haddr", "slices_hider", "slices_archaddr", "slices_archDR", "slices_hhr", "slices_hardr", "slices_Hdr"], "buf_size": ["buf00channel", "cap_len", "buflexuse", "bufcksize", "bufxize", "buf_sync", "uf_use", "buflexexternal", "bufsmax", "buff_external", "buf_set", "buflexcount", "buf_scale", "buf00small", "buff_use", "buf67sync", "uf_sec", "img67scale", "buff64count", "uf_scale", "queue_size", "queue_small", "buf64external", "cap67offset", "buf64size", "buf67size", "buf00size", "buff_max", "uf_capacity", "bufckcontent", "buf_channel", "cap_number", "img67size", "buff64size", "bufckcount", "uc_set", "buf_capacity", "buff_number", "uc_ize", "buf_external", "buf67send", "img_scale", "buf_content", "buf64ize", "uc_size", "bufckize", "buf_small", "bufcksmall", "buff64use", "uf_center", "queue_channel", "buf67len", "cap67len", "bufckscale", "buf00count", "uc_line", "buf_use", "buf16center", "cap_size", "buf64count", "bufxsize", "buf_send", "img_send", "buff_size", "img_size", "buf67number", "buf64line", "bufckchannel", "buf64set", "buff_count", "buf16size", "queue_count", "buf16use", "buf67offset", "buf_max", "buf_offset", "buf16scale", "buf64use", "img_sync", "img67send", "bufxline", "buf_ize", "cap67number", "uf_count", "uf_content", "buf_len", "bufxset", "uf_size", "buflexsize", "buf_sec", "bufsnumber", "buf_center", "buf_number", "img67sync", "cap_offset", "buf67scale", "cap67size", "buf_line", "buff64external", "uf_ize", "bufssize", "buf_count"], "size": ["set", "offset", "full", "pos", "empty", "new", "large", "length", "send", "age", "area", "Size", "len", "scale", "content", "name", "handle", "sort", "from", "timeout", "count", "last", "si", "iz", "shift", "gz", "weight", "code", "time", "core", "SIZE", "err", "image", "sized", "loc", "mini", "any", "speed", "ice", "page", "ize", "sync", "position", "address", "sum", "fee", "frame", "value", "izes", "capacity", "shape", "mode", "small", "esc", "slice", "en", "member", "ui", "use", "e", "unit", "video", "cap", "storage", "body", "second", "el"], "size2": ["speedTwo", "ize02", "size02", "speed1", "ize4", " size8", "size1", "name2", "scale1", "length5", " size4", "length2", "name8", "scaleTwo", "length82", " size5", "scale2", " size82", "size162", "ize3", "size5", "length02", "size3", "ize1", "speed62", "ize62", " size62", "size4", "size82", " size162", " size3", " sizeTwo", "ize2", "name1", "nameTwo", "scale3", "ize5", "ize8", " size1", "scale162", " size02", "speed2", "address2", "addressTwo", "lengthTwo", "size8", "ize162", "scale82", "length1", "size62", "address4", "izeTwo", "address1", "sizeTwo"]}}
{"project": "FFmpeg", "commit_id": "aba232cfa9b193604ed98f3fa505378d006b1b3b", "target": 1, "func": "ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,\n\n                           AVStream *st, RMStream *rst, int codec_data_size)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 18203, "substitutes": {"v": ["m", "vid", "V", "j", "s", "t", "vr", "x", "f", "sv", "vp", "r", "n", "version", "g", "i", "vi", "lv", "vert", "uv", "l", "val", "vol", "change", "d", "conv", "value", "ev", "e", "q", "vs", "c", " V", "p", "vt", "volt", "b", "vv", "va", "h", "nv", "ve", "cv", "ver", "u"], "size": ["s", "small", "code", "SIZE", "esc", "f", "rc", "reg", "mi", "n", "g", "i", "max", "loc", "sel", "sec", "en", "enc", "fl", "e", "sent", "desc", "len"], "codec_pos": ["codec_position", "codesc_len", "codesc_type", "codec__pos", "codec_type", "codec_loc", "codec__type", "codec_len", "codesc_loc", "codesc_pos", "codesc_position", "codec__len", "codec_size", "codesc_size", "codec__size"], "ret": ["status", "obj", "f", "ref", "alt", "reg", "nt", "lit", "rc", "fun", "rt", "result", "flag", "match", "ut", "ext", "sec", "mem", "resp", "rets", "def", "en", "arg", "bad", "att", "val", "re", "Ret", "fail", "back", "utf", "id", "fit", "det", "rev", "RET", "ben", "rep", "res", "pet", "red", "mt", "valid", "reply", "success", "len"], "fps": ["status", "f", "buffer", "rc", "gc", " res", "cb", "pass", "fin", "resp", "back", "test", "gen", "rep", "res", "loop", "live", "frame", "flags", "valid", "fast", "progress", "success", "len"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211, "substitutes": {"f": ["m", "fr", "fw", "ff", "fp", "fat", "ref", "conf", "x", "obj", "fe", "file", "fa", "feed", "g", "i", "fs", "rf", "o", "lf", "fx", "l", "d", "df", "inf", "fd", "e", "c", "F", "p", "b", "tf", "h", "a", "fi"], "pv": ["pf", "cpv", "fpv", " pf", "fpf", "pb", "pV", "cpb", "PV", "cpf", " pb", "Pb", " pV", "Pf", "Pv", "fpV"], "size": ["m", "small", "shape", "data", "fp", "SIZE", "x", "fe", "g", "z", "l", "val", "d", "large", "ize", "w", "e", "k", "c", "fff", " sizes", "h", "iv", "Size", "len"], "v": ["m", "V", "s", "j", "t", "data", "x", "volume", "sv", "vp", "n", "g", "i", "vd", "vi", "lv", "o", "uv", "l", "val", "conv", "value", "q", "k", "e", "vs", "c", "inv", "tv", "p", "vt", "b", "vv", "iv", "ve", "u"]}}
{"project": "qemu", "commit_id": "17b74b98676aee5bc470b173b1e528d2fce2cf18", "target": 0, "func": "QJSON *qjson_new(void)\n\n{\n\n    QJSON *json = QJSON(object_new(TYPE_QJSON));\n\n    return json;\n\n}\n", "idx": 18220, "substitutes": {"json": ["status", "tree", "j", "global", "fruit", "data", "obj", "feed", "result", "pack", "son", "java", "module", "current", "raw", "aj", "object", "array", "new", "build", "config", "response", "key", "xxx", "jack", "update", "javascript", "js", "temp", "parent", "xml", "output", "body", "api", "ja", "twitter", "py", "JSON", "journal", "server", "value"]}}
{"project": "qemu", "commit_id": "4a1418e07bdcfaa3177739e04707ecaec75d89e1", "target": 0, "func": "void kqemu_record_dump(void)\n\n{\n\n    PCRecord **pr, *r;\n\n    int i, h;\n\n    FILE *f;\n\n    int64_t total, sum;\n\n\n\n    pr = malloc(sizeof(PCRecord *) * nb_pc_records);\n\n    i = 0;\n\n    total = 0;\n\n    for(h = 0; h < PC_REC_HASH_SIZE; h++) {\n\n        for(r = pc_rec_hash[h]; r != NULL; r = r->next) {\n\n            pr[i++] = r;\n\n            total += r->count;\n\n        }\n\n    }\n\n    qsort(pr, nb_pc_records, sizeof(PCRecord *), pc_rec_cmp);\n\n\n\n    f = fopen(\"/tmp/kqemu.stats\", \"w\");\n\n    if (!f) {\n\n        perror(\"/tmp/kqemu.stats\");\n\n        exit(1);\n\n    }\n\n    fprintf(f, \"total: %\" PRId64 \"\\n\", total);\n\n    sum = 0;\n\n    for(i = 0; i < nb_pc_records; i++) {\n\n        r = pr[i];\n\n        sum += r->count;\n\n        fprintf(f, \"%08lx: %\" PRId64 \" %0.2f%% %0.2f%%\\n\",\n\n                r->pc,\n\n                r->count,\n\n                (double)r->count / (double)total * 100.0,\n\n                (double)sum / (double)total * 100.0);\n\n    }\n\n    fclose(f);\n\n    free(pr);\n\n\n\n    kqemu_record_flush();\n\n}\n", "idx": 18231, "substitutes": {"pr": ["pc", "per", "rr", "fr", "br", "j", "tr", "rs", "vr", "pred", "ref", "rc", "pe", "hr", "rt", "Pr", "pl", "rel", "ar", "str", "por", "pol", "pos", "kr", "arr", "po", "prop", "PR", "pair", "rec", "val", "pp", "pre", "sr", "dr", "pa", "lr", "pull", "cr", "par", "rev", "ps", "p", "repl", "wr", "mp", "adr", "col", "spr", "ra", "rep", "pro", "py", "gr", "attr", "pt"], "r": ["entry", "m", "rr", "fr", "br", "ner", "tr", "rs", "vr", "x", "err", "rc", "hr", "rt", "R", "rel", "ar", "result", "str", "g", "or", "master", "rh", "var", "rg", "rf", "kr", "o", "range", "l", "rec", "rd", "re", "d", "nr", "mr", "rar", "ru", "w", "sr", "dr", "e", "lr", "k", "cr", "v", "cur", "c", "rev", "rb", "rl", "ir", "p", "ur", "wr", "b", "resource", "adr", "ra", "er", "row", "usr", "attr", "u"], "i": ["ti", "gi", "bi", "init", "j", "info", "x", "name", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "hi", "z", "ii", "ie", "iu", "di", "ind", "index", "I", "count", "is", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "start", "e", "limit", "v", "c", "ni", "si", "ri", "p", "xi", "b", "a", "eni", "fi", "inner", "y", "li", "u"], "h": ["m", "j", "ch", "t", "eh", "x", "oh", "hr", "hash", "n", "dh", "hi", "hd", "z", "rh", "th", "uh", "o", "l", "d", "ht", "sh", "kh", "w", "id", "k", "q", "e", "bh", "v", "ih", "c", "p", "hm", "b", "hh", "ul", "ph", "ha", "hs", "he", "ah", "H", "y", "u"], "f": ["m", "fr", "xf", "fw", "ff", "j", "t", "func", "fp", "x", "af", "conf", "full", "fe", "file", "fun", "fa", "feed", "cf", "g", "s", "function", "fc", "fs", "rf", "fen", "o", "fo", "lf", "fx", "l", "d", "df", "bf", "w", "fore", "fit", "fd", "e", "buff", "fb", "v", "c", "F", "p", "b", "fm", "tf", "fn", "form", "fi", "sf"], "total": ["stat", "offset", "full", "dot", "nt", "result", "num", "max", "ss", "non", "ta", "pi", " totals", "no", "length", "cu", "temp", "meta", "valid", "mm", "part", "scale", "quant", "tt", "fat", "gross", "count", " max", "summary", "parse", "size", "cat", "parent", " final", "si", "null", "Total", "tax", "base", "net", "current", "type", "toc", "di", "ass", "fo", "pretty", "final", "percent", "start", "otal", "post", "doc", "average", "ph", "ma", "alpha", "now", "mu", "t", "data", "info", "all", "index", "mon", "complete", "cost", "error", "local", "tp", "diff", "li"], "sum": ["stat", "scale", "session", "offset", "s", "cal", "fat", "info", "comment", "all", "sp", "net", "gross", "num", "sal", "um", "max", "ss", "index", "pos", "ass", "mem", "min", "count", "out", "miss", "vol", "summary", "sh", "up", "size", "cost", "percent", "diff", "no", "length", "start", "sc", "si", "loss", "dev", "mean", "doc", "average", "fee", "cache", "error", "a", "Sum", "weight", "us", "se", "mm", "alpha", "sa", "li", "len"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void pcnet_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    PCNetState *s = opaque;\n\n    int is_padr = 0, is_bcast = 0, is_ladr = 0;\n\n    uint8_t buf1[60];\n\n    int remaining;\n\n    int crc_err = 0;\n\n\n\n    if (CSR_DRX(s) || CSR_STOP(s) || CSR_SPND(s) || !size)\n\n        return;\n\n\n\n#ifdef PCNET_DEBUG\n\n    printf(\"pcnet_receive size=%d\\n\", size);\n\n#endif\n\n\n\n    /* if too small buffer, then expand it */\n\n    if (size < MIN_BUF_SIZE) {\n\n        memcpy(buf1, buf, size);\n\n        memset(buf1 + size, 0, MIN_BUF_SIZE - size);\n\n        buf = buf1;\n\n        size = MIN_BUF_SIZE;\n\n    }\n\n\n\n    if (CSR_PROM(s)\n\n        || (is_padr=padr_match(s, buf, size))\n\n        || (is_bcast=padr_bcast(s, buf, size))\n\n        || (is_ladr=ladr_match(s, buf, size))) {\n\n\n\n        pcnet_rdte_poll(s);\n\n\n\n        if (!(CSR_CRST(s) & 0x8000) && s->rdra) {\n\n            struct pcnet_RMD rmd;\n\n            int rcvrc = CSR_RCVRC(s)-1,i;\n\n            target_phys_addr_t nrda;\n\n            for (i = CSR_RCVRL(s)-1; i > 0; i--, rcvrc--) {\n\n                if (rcvrc <= 1)\n\n                    rcvrc = CSR_RCVRL(s);\n\n                nrda = s->rdra +\n\n                    (CSR_RCVRL(s) - rcvrc) *\n\n                    (BCR_SWSTYLE(s) ? 16 : 8 );\n\n                RMDLOAD(&rmd, nrda);\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n                    printf(\"pcnet - scan buffer: RCVRC=%d PREV_RCVRC=%d\\n\",\n\n                                rcvrc, CSR_RCVRC(s));\n\n#endif\n\n                    CSR_RCVRC(s) = rcvrc;\n\n                    pcnet_rdte_poll(s);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (!(CSR_CRST(s) & 0x8000)) {\n\n#ifdef PCNET_DEBUG_RMD\n\n            printf(\"pcnet - no buffer: RCVRC=%d\\n\", CSR_RCVRC(s));\n\n#endif\n\n            s->csr[0] |= 0x1000; /* Set MISS flag */\n\n            CSR_MISSC(s)++;\n\n        } else {\n\n            uint8_t *src = s->buffer;\n\n            target_phys_addr_t crda = CSR_CRDA(s);\n\n            struct pcnet_RMD rmd;\n\n            int pktcount = 0;\n\n\n\n            if (!s->looptest) {\n\n                memcpy(src, buf, size);\n\n                /* no need to compute the CRC */\n\n                src[size] = 0;\n\n                src[size + 1] = 0;\n\n                src[size + 2] = 0;\n\n                src[size + 3] = 0;\n\n                size += 4;\n\n            } else if (s->looptest == PCNET_LOOPTEST_CRC ||\n\n                       !CSR_DXMTFCS(s) || size < MIN_BUF_SIZE+4) {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size])\n\n                    CRC(fcs, *p++);\n\n                *(uint32_t *)p = htonl(fcs);\n\n                size += 4;\n\n            } else {\n\n                uint32_t fcs = ~0;\n\n                uint8_t *p = src;\n\n\n\n                while (p != &src[size-4])\n\n                    CRC(fcs, *p++);\n\n                crc_err = (*(uint32_t *)p != htonl(fcs));\n\n            }\n\n\n\n#ifdef PCNET_DEBUG_MATCH\n\n            PRINT_PKTHDR(buf);\n\n#endif\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            /*if (!CSR_LAPPEN(s))*/\n\n                SET_FIELD(&rmd.status, RMDS, STP, 1);\n\n\n\n#define PCNET_RECV_STORE() do {                                 \\\n\n    int count = MIN(4096 - GET_FIELD(rmd.buf_length, RMDL, BCNT),remaining); \\\n\n    target_phys_addr_t rbadr = PHYSADDR(s, rmd.rbadr);          \\\n\n    s->phys_mem_write(s->dma_opaque, rbadr, src, count, CSR_BSWP(s)); \\\n\n    src += count; remaining -= count;                           \\\n\n    SET_FIELD(&rmd.status, RMDS, OWN, 0);                       \\\n\n    RMDSTORE(&rmd, PHYSADDR(s,crda));                           \\\n\n    pktcount++;                                                 \\\n\n} while (0)\n\n\n\n            remaining = size;\n\n            PCNET_RECV_STORE();\n\n            if ((remaining > 0) && CSR_NRDA(s)) {\n\n                target_phys_addr_t nrda = CSR_NRDA(s);\n\n#ifdef PCNET_DEBUG_RMD\n\n                PRINT_RMD(&rmd);\n\n#endif\n\n                RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                    crda = nrda;\n\n                    PCNET_RECV_STORE();\n\n#ifdef PCNET_DEBUG_RMD\n\n                    PRINT_RMD(&rmd);\n\n#endif\n\n                    if ((remaining > 0) && (nrda=CSR_NNRD(s))) {\n\n                        RMDLOAD(&rmd, PHYSADDR(s,nrda));\n\n                        if (GET_FIELD(rmd.status, RMDS, OWN)) {\n\n                            crda = nrda;\n\n                            PCNET_RECV_STORE();\n\n                        }\n\n                    }\n\n                }\n\n            }\n\n\n\n#undef PCNET_RECV_STORE\n\n\n\n            RMDLOAD(&rmd, PHYSADDR(s,crda));\n\n            if (remaining == 0) {\n\n                SET_FIELD(&rmd.msg_length, RMDM, MCNT, size);\n\n                SET_FIELD(&rmd.status, RMDS, ENP, 1);\n\n                SET_FIELD(&rmd.status, RMDS, PAM, !CSR_PROM(s) && is_padr);\n\n                SET_FIELD(&rmd.status, RMDS, LFAM, !CSR_PROM(s) && is_ladr);\n\n                SET_FIELD(&rmd.status, RMDS, BAM, !CSR_PROM(s) && is_bcast);\n\n                if (crc_err) {\n\n                    SET_FIELD(&rmd.status, RMDS, CRC, 1);\n\n                    SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n                }\n\n            } else {\n\n                SET_FIELD(&rmd.status, RMDS, OFLO, 1);\n\n                SET_FIELD(&rmd.status, RMDS, BUFF, 1);\n\n                SET_FIELD(&rmd.status, RMDS, ERR, 1);\n\n            }\n\n            RMDSTORE(&rmd, PHYSADDR(s,crda));\n\n            s->csr[0] |= 0x0400;\n\n\n\n#ifdef PCNET_DEBUG\n\n            printf(\"RCVRC=%d CRDA=0x%08x BLKS=%d\\n\",\n\n                CSR_RCVRC(s), PHYSADDR(s,CSR_CRDA(s)), pktcount);\n\n#endif\n\n#ifdef PCNET_DEBUG_RMD\n\n            PRINT_RMD(&rmd);\n\n#endif\n\n\n\n            while (pktcount--) {\n\n                if (CSR_RCVRC(s) <= 1)\n\n                    CSR_RCVRC(s) = CSR_RCVRL(s);\n\n                else\n\n                    CSR_RCVRC(s)--;\n\n            }\n\n\n\n            pcnet_rdte_poll(s);\n\n\n\n        }\n\n    }\n\n\n\n    pcnet_poll(s);\n\n    pcnet_update_irq(s);\n\n}\n", "idx": 18254, "substitutes": {"opaque": ["iopesc", "operacity", "Opaque", "OPhole", "Opacity", "ophole", " opacity", "operhole", "operatile", " opace", "opatile", "oppacity", "OPatile", "opacity", "oppaque", "iopaque", "operaque", "opphole", " opesc", "Opesc", "iopace", "oppatile", "OPaque", "opace", "iopacity", "OPacity", "Opace", "opesc"], "buf": ["Buffer", "br", "data", "fp", "text", "f", "pool", "buffer", "rc", "vec", "fi", "cf", "window", "cb", "block", "bc", "loc", "wb", "ctx", "pb", "mem", "byte", "cas", "enc", "home", "prop", "gb", "header", "box", "queue", "config", "fd", "bl", "buff", "fb", "tmp", "seq", "cmd", "uc", "rb", "que", "b", "cache", "cap", "alloc", "proc", "port", "bag", "uf", "cv", "len"], "size": ["offset", "extra", "x", "full", "huge", "num", "six", "max", "sec", "empty", "large", "length", "send", "needed", "bytes", "Size", "source", "len", "scale", "content", "name", "timeout", "count", "eng", "sc", "si", "weight", "grow", "code", "time", "SIZE", "fe", "negative", "sized", "loc", "speed", "page", "go", "security", "ize", "sn", "sync", "c", "address", "sent", "sum", "fee", "small", "capacity", "data", "shape", "esc", "mode", "ng", "buffer", "g", "complete", "args", "ui", "use", "unit", "cache", "form", "storage"], "s": ["ns", "spec", "settings", "service", "ions", "details", "comm", "ss", "submit", "d", "qs", "sym", "us", "sets", "m", "sg", "rs", "times", "self", "lines", "o", "su", "tests", "side", "k", "v", "si", "S", "a", "an", "ds", "native", "f", "r", "sb", "multi", "l", "w", "bis", "sync", "private", "c", "ps", "secondary", "b", "sys", "er", "es", "state", "states", "sq", "sf", "types", "session", "small", "stats", "t", "request", "conf", "services", "n", "plugins", "g", "sl", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "client", "js", "hm", "http", "gs", "its", "local", "os", "parts", "server", "south"], "buf1": ["buff1", "bufn", "buf2", "buff0", " bufone", "buffer1", "buf0", "uf2", " bufn", "uf0", "buffone", "ufn", "uf1", "buffer2", "buffern", "buff2", "bufferone", "bufone", " buf2", " buf0", "buffer0"], "remaining": [" remend", "remend", "resaining", "romoding", "remoding", " remoding", "resoding", "resend", "romaining", "romend"], "rmd": [" rmb", "rccmd", "rarm", "rrarm", " rarm", "prcmd", "prarm", "rsha", " prMD", "RMD", "rmb", "rcmd", " rMD", "rld", "rrld", " prcmd", "Rmd", "rrcmd", "prld", " rsha", " prsha", "rrmd", " prmd", "rcMD", "rrmb", " rcmd", " rld", "rMD", "Rsha", "Rcmd", "rcmb", "rrMD", "prmd"], "i": ["ti", "gi", "uri", "bi", "j", "info", "x", "ix", "ini", "qi", "ai", "mi", "io", "phi", "n", "z", "ii", "iu", "index", "di", "ind", "I", "mini", "multi", "zi", "o", "ip", "pi", "ui", "ci", "e", "ni", "c", "si", "ri", "xi", "mu", "anti", "im", "it", "fi", "li", "u"], "nrda": ["nrandia", "nldae", " nldo", "Nrdas", "Nrda", "nrssae", "Nlda", "nrlas", "nrsas", "nrusae", "nddas", "nrdb", "nldar", "nrsa", "nrusas", "nrssa", "nrsb", "ndda", "nddia", "nrdae", "Nldia", "Nrdia", " nrdae", "nrusa", " nrdb", " nlda", "nrdas", "nrlb", "nrsar", "nldo", "nrandas", "Nldb", "Nrdb", " nrdar", " nrdas", "nranda", "nddb", "nrdia", "nruso", " nrsar", "nrdo", "nrssas", " nrdo", "nldb", "nrdar", " nldae", "nrla", "Nldas", " nrsas", " nrsb", "nrandb", "nrlar", "nlda", "nldas", "nrsso", " nrsa", "nldia", " nldas"], "rcvrc": ["rcfrc", "RCfrt", " rcverRC", " rcvRC", "rcvru", "rcvrec", "RCfrc", "rcvmgd", "rcfRC", "rckrt", "rchrt", "rcfra", "rcfunRC", "rcfsrc", "rchrc", "rcvsrc", " rcversrc", "rcverRC", "rcVsrc", "rcfgd", "rckra", "rcsvrc", "rcnrr", "rchrec", "rcversc", "rcfru", "rcVrs", "rcfunrf", "rckrc", "rcVgd", "rcvmrc", "RCfgd", "rcvpRC", "RCfrs", "rcvvrf", "rcnsrc", "rcvprc", "rcnRC", "RCfrf", "RCvRC", "rcfsc", "rcvpra", "RCvrr", "rcvvru", "rcpsc", "rcvgd", " rcverrc", "rckRC", "rcfunrc", "rcVras", "rcpRC", "rcfrf", "rcvvRC", "rcfrr", " rcvsrc", "rcvrf", "rcprc", "rcfras", " rcversc", "RCvgd", "rcvmRC", "RCfRC", "rcVRC", "RCvrf", "RCvrt", "rcnrc", "rcvrr", "rcvRC", "rchRC", "RCfras", "rcVrc", " rcvsc", "rcfunru", "rcfrec", "rcvprt", "rcfrs", "rcvvras", "RCvsrc", "rcsvRC", "rcvsc", "rcvmsrc", "rcvvrs", "rcpsrc", "RCvra", "RCfrec", "RCfrr", "rcverrc", "RCvrec", "rcvvrc", "RCfra", "rcvra", "rcsvrt", "rcversrc", "rcsvrec", "rcprr", "RCfru", "rcvrt", "RCvras", "RCvru", "RCfsrc", "rcvras", "rcfrt", "RCvrc", "RCvrs", "rcvrs"], "CSR_RCVRC": ["CSR_RRvRS", "CSR_RCFRS", "CSR_RCVDRS", "CSR_RCVDRL", "CSR_RCPRL", "CSR_RRvRL", "CSR_RCVRS", "CSR_RRvRC", "CSR_RCFRR", "CSR_RRVRL", "CSR_RCVRT", "CSR_RCFRC", "CSR_RCPRR", "CSR_RCFRT", "CSR_RCVDVR", "CSR_RCVRL", "CSR_RCvRT", "CSR_RCvVR", "CSR_RCvRS", "CSR_RRvRR", "CSR_RCPRS", "CSR_RRVRR", "CSR_RCvRL", "CSR_RRVRC", "CSR_RCFVR", "CSR_RCvRC", "CSR_RCvRR", "CSR_RCPRC", "CSR_RRvVR", "CSR_RCFRL", "CSR_RRVRS", "CSR_RCVDRC", "CSR_RCVVR", "CSR_RRVRT", "CSR_RRVVR", "CSR_RCVRR", "CSR_RRvRT"]}}
{"project": "qemu", "commit_id": "f53a829bb9ef14be800556cbc02d8b20fc1050a7", "target": 0, "func": "static void nbd_reply_ready(void *opaque)\n\n{\n\n    NbdClientSession *s = opaque;\n\n    uint64_t i;\n\n    int ret;\n\n\n\n    if (s->reply.handle == 0) {\n\n        /* No reply already in flight.  Fetch a header.  It is possible\n\n         * that another thread has done the same thing in parallel, so\n\n         * the socket is not readable anymore.\n\n         */\n\n        ret = nbd_receive_reply(s->sock, &s->reply);\n\n        if (ret == -EAGAIN) {\n\n            return;\n\n        }\n\n        if (ret < 0) {\n\n            s->reply.handle = 0;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* There's no need for a mutex on the receive side, because the\n\n     * handler acts as a synchronization point and ensures that only\n\n     * one coroutine is called until the reply finishes.  */\n\n    i = HANDLE_TO_INDEX(s, s->reply.handle);\n\n    if (i >= MAX_NBD_REQUESTS) {\n\n        goto fail;\n\n    }\n\n\n\n    if (s->recv_coroutine[i]) {\n\n        qemu_coroutine_enter(s->recv_coroutine[i], NULL);\n\n        return;\n\n    }\n\n\n\nfail:\n\n    nbd_teardown_connection(s);\n\n}\n", "idx": 18267, "substitutes": {"opaque": ["pc", "copaques", "opusac", "copc", " opque", "copaque", "pque", "opac", "opusaques", "OPcel", "pac", "opuscel", " opc", "opcel", "OPaques", "pcel", "paques", "opusaque", "paque", "OPaque", "copque", "OPac", "opaques", "opc", "opque", " opaques"], "s": ["ns", "ms", "spec", "m", "session", "sg", "ts", "rs", "aws", "conf", "f", "uns", "t", "settings", "services", "service", "r", "n", "plugins", "sb", "g", "sl", "ss", "ls", "ops", "fs", "self", "xs", "is", "o", "cs", "l", "d", "su", "args", "socket", "w", "qs", "e", "ssl", "comments", "ses", "sync", "client", "c", "js", "si", "ps", "sym", "p", "S", "ks", "http", "b", "gs", "sys", "its", "a", "es", "os", "se", "sets", "sq", "server", "south", "ds", "u"], "i": ["ti", "gi", "uri", "bi", "m", "j", "t", "info", "x", "f", "name", "ix", "ini", "qi", "r", "ai", "mi", "io", "phi", "type", "z", "ii", "ie", "iu", "di", "index", "ind", "I", "mini", "is", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "e", "v", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "h", "a", "iter", "it", "fi", "esi", "y", "li", "u"], "ret": ["j", "code", "t", "x", "f", "err", "ref", "alt", "bit", "rc", "r", "nt", "mi", "rt", "reg", "fun", "result", "num", "lit", "flag", "match", "in", "ie", "ext", "fin", "mem", "en", "rets", "arg", "art", "att", "l", "val", "re", "Ret", "rot", "id", "det", "rev", "v", "cat", "RET", "b", "pat", "pet", "mt", "iter", "ft", "fi", "reply", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "5e5f75cf8abd76ada3011790a9b4f0762a72e41a", "target": 0, "func": "static void ffm_write_data(AVFormatContext *s,\n\n                           const uint8_t *buf, int size,\n\n                           int64_t pts, int header)\n\n{\n\n    FFMContext *ffm = s->priv_data;\n\n    int len;\n\n\n\n    if (header && ffm->frame_offset == 0) {\n\n        ffm->frame_offset = ffm->packet_ptr - ffm->packet + FFM_HEADER_SIZE;\n\n        ffm->pts = pts;\n\n    }\n\n\n\n    /* write as many packets as needed */\n\n    while (size > 0) {\n\n        len = ffm->packet_end - ffm->packet_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(ffm->packet_ptr, buf, len);\n\n\n\n        ffm->packet_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        if (ffm->packet_ptr >= ffm->packet_end) {\n\n            /* special case : no pts in packet : we leave the current one */\n\n            if (ffm->pts == 0)\n\n                ffm->pts = pts;\n\n\n\n            flush_packet(s);\n\n        }\n\n    }\n\n}\n", "idx": 18268, "substitutes": {"s": ["ns", "spec", "m", "instance", "ts", "sg", "session", "t", "rs", "request", "conf", "f", "sv", "services", "service", "r", "n", "sb", "g", "i", "ss", "ops", "ctx", "this", "self", "cs", "submit", "d", "su", "secure", "w", "e", "sc", "ssl", "ses", "v", "client", "c", "js", "sync", "span", "p", "secondary", "b", "http", "gs", "sys", "h", "storage", "a", "es", "server", "south", "sq", "an", "ds", "u"], "buf": ["Buffer", "br", "offset", "ff", "data", "func", "fp", "base", "ref", "f", "lim", "buffer", "vec", "cf", "cb", "block", "bc", "src", "loc", "msg", "wb", "ctx", "bb", "count", "cas", "context", "gb", "path", "flow", "queue", "bd", "length", "fd", "limit", "buff", "fb", "map", "rb", "seq", "cmd", "uc", "off", "b", "alloc", "addr", "port", "callback", "bag", "uf"], "size": ["term", "scale", "offset", "content", "shape", "small", "data", "mode", "SIZE", "name", "core", "code", "capacity", "buffer", "cm", "n", "sized", "max", "loc", "source", "pos", "time", "en", "count", "speed", "low", "range", "page", "l", "empty", "fl", "ize", "length", "limit", "e", "lc", "c", "position", "iz", "url", "address", "fee", "line", "body", "bytes", "Size", "end", "el"], "pts": ["ptblocks", "ntabs", "ntp", "aptt", "ptgs", "ctd", "monts", "ntts", "eptgs", "reqd", "aptts", "cols", "reqs", "oints", "ppabs", "PTns", "ointblocks", "pathsm", "ppsets", "ctn", " ptsets", "pgp", "periodt", "aptp", "PTsm", "ptabs", "ctp", "epts", "ptn", "ptsets", "ppts", "apts", "ptsm", "nts", "pathd", "periodts", "ptns", "eptt", "ointfs", " ptblocks", "ptfs", "paths", "ptt", "ptd", "periods", "ntd", "pathns", "ointsets", "eptp", "pgts", "colns", "cold", "PTs", "pps", "ppgs", "pgs", "montsets", "ntsets", "colsm", "PTsets", " ptfs", "montts", "eptts", "reqp", "periodp", "PTd", "montabs", "reqn", "cts", "ppp", "ntn", "PTfs", "ptts", "PTblocks", "pggs", "ptp"], "header": ["offset", "outer", "code", "name", "f", "err", "buffer", "center", "border", "n", "counter", "channel", "block", "master", "holder", "padding", "headers", "forward", "head", "Header", "cover", "layer", "final", "aster", "response", "dr", "handler", "parent", "line", "shift", "table", "tail", "h", "er", "body", "number", "server", "writer", "inner", "version"], "ffm": ["uffbm", "effm", "effmd", "ufm", "fxm", "ffam", "ffim", "efdm", "effmodule", "buffm", "ffarm", "ffg", "buffmodule", "ffn", "uffd", "uffam", "ffmin", "buffam", "fxcm", "ppn", "effdm", "effmin", "lfmc", "uffl", "effbm", "ufmo", "ffM", "ffp", "ffdm", "effp", "bufff", "uffsm", "uffn", "buffl", "iffim", "ufbm", "uffarm", "uffm", "effmm", "ufl", "ufcm", "ffl", "effM", "ffbm", "effd", "fxmd", "buffdm", "effg", "offom", "iffarm", "fxg", "ffd", "effn", " ffmc", "ffmm", "offmc", "fxn", "ffsm", "ufmodule", "fff", "fxd", "offf", "affom", "efn", "uppmu", "uffcm", "ufmc", "uffmd", "lfcm", "ffcm", "iffmin", "ffmc", "iffn", "uffp", "buffcm", "effsm", "ffmu", " ffmo", "uppm", "ppd", "effam", "uffmc", "efm", "efp", "efM", "iffm", "lfmo", "affmc", "offl", "fxim", "iffsm", "ffmd", "efff", "ffmodule", "uppmin", "offg", "buffmm", "affl", "lfm", "affm", " ffcm", "fxmm", "iffcm", "iffdm", "uffdm", "ffmo", "effim", "iffmu", "uffM", "fxdm", "effarm", "uffom", "efd", "offcm", "ppdm", "ffom", "uffmodule", "buffbm", "effcm", "effmu", "ppm", "offm", "fxf", "uppcm"], "len": ["lon", "data", "lim", "f", "base", "sp", "lit", "vec", "n", "fun", "lu", "late", "coll", "sl", "z", "ls", "loc", "lp", "ie", "led", "fin", "pos", "dl", "ld", "en", "count", "low", "lf", "ln", "l", "val", "fl", "le", "pre", "length", "hl", "ler", "il", "limit", "span", "lc", "rev", "elt", "ll", "line", "url", "lan", "la", "lin", "el", "li", "Len"]}}
{"project": "qemu", "commit_id": "0d7937974cd0504f30ad483c3368b21da426ddf9", "target": 0, "func": "static inline void vmsvga_cursor_define(struct vmsvga_state_s *s,\n\n                struct vmsvga_cursor_definition_s *c)\n\n{\n\n    QEMUCursor *qc;\n\n    int i, pixels;\n\n\n\n    qc = cursor_alloc(c->width, c->height);\n\n    qc->hot_x = c->hot_x;\n\n    qc->hot_y = c->hot_y;\n\n    switch (c->bpp) {\n\n    case 1:\n\n        cursor_set_mono(qc, 0xffffff, 0x000000, (void*)c->image,\n\n                        1, (void*)c->mask);\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/mono\");\n\n#endif\n\n        break;\n\n    case 32:\n\n        /* fill alpha channel from mask, set color to zero */\n\n        cursor_set_mono(qc, 0x000000, 0x000000, (void*)c->mask,\n\n                        1, (void*)c->mask);\n\n        /* add in rgb values */\n\n        pixels = c->width * c->height;\n\n        for (i = 0; i < pixels; i++) {\n\n            qc->data[i] |= c->image[i] & 0xffffff;\n\n        }\n\n#ifdef DEBUG\n\n        cursor_print_ascii_art(qc, \"vmware/32bit\");\n\n#endif\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: unhandled bpp %d, using fallback cursor\\n\",\n\n                __FUNCTION__, c->bpp);\n\n        cursor_put(qc);\n\n        qc = cursor_builtin_left_ptr();\n\n    }\n\n\n\n    dpy_cursor_define(s->vga.ds, qc);\n\n    cursor_put(qc);\n\n}\n", "idx": 18272, "substitutes": {"s": ["ns", "spec", "m", "ts", "t", "rs", "f", "settings", "services", "r", "service", "g", "sl", "ss", "sim", "sec", "is", "o", "cs", "su", "e", "ssl", "ses", "v", "sync", "si", "p", "S", "gs", "sys", "storage", "os", "south", "states", "sets", "params", "sf"], "c": ["pc", "dc", "ic", "oc", "m", "ch", "t", "core", "conf", "f", "call", "cus", "ct", "vc", "conn", "x", "cm", "n", "cf", "or", "coll", "anc", "cp", "bc", "mc", "sec", "cy", "o", "ca", "enc", "cs", "arc", "l", "d", "ce", "nc", "ac", "ci", "tc", "w", "config", "con", "e", "cu", "k", "sc", "cr", "v", "lc", "cur", "cl", "p", "uc", "b", "cache", "ec", "h", "a", "co", "C", "cc", "u"], "qc": [" qdc", "sqsc", "quickcm", "questpc", "questc", "chf", "pubn", "pubc", "qdc", "quch", "qrc", "Qxc", " qcf", "sqrc", "qub", " qf", " qrc", " qxc", "qucu", "quickc", " qct", "calf", "sqca", "qcs", "qusc", "pubcp", " qpc", "qcu", " qcur", "questlc", "qcur", "qucf", "sqc", "sqf", " qcr", "pubec", "qulc", "reqpc", "Qc", " qci", "qsc", " qcm", "questct", "qcm", "quci", "quct", "ql", "quickcr", "qlc", "quxc", "reqf", "questsc", "sqci", " ql", "Qdc", "sqcur", "qpc", "calcr", "qf", "quec", "qct", "questcur", "sqcr", "questcs", "calct", "qca", "questcf", "commentc", " qcp", " qcu", "qch", "chpc", "sqcu", "Qpc", "calc", "chc", "qn", "qci", " qcs", "reqxc", " qb", "questca", "qurc", "quickcf", "chxc", "commentcm", "sql", "qb", "reqp", " qn", "reqc", "qxc", "sqn", "qucur", "sqpc", "quc", "sqdc", "qec", "reqb", "reql", "qun", "qcf", "reqch", " qch", "commentcf", "sqlc", "calpc", "qucp", "sqp", "qcp", "reqn", "sqct", "Qci", "qucs", "qupc", "qcr", "calcur", " qec", "calcu", "Qrc", "sqxc", "quca", "qp", " qp", "commentcr"], "i": ["ti", "gi", "uri", "m", "bi", "j", "ji", "t", "data", "x", "f", "ix", "ini", "qi", "ai", "n", "phi", "z", "ii", "di", "index", "I", "multi", "zi", "o", "l", "adi", "d", "oi", "yi", "pi", "uni", "ui", "ci", "abi", "id", "k", "e", "v", "ni", "si", "ri", "p", "xi", "b", "mu", "a", "it", "eni", "fi", "li", "u"], "pixels": ["ppii", "pii", "Picks", " pii", "cicks", "uorts", " pints", "picks", " ports", "ports", "pips", "uixels", "spips", "Pii", "Pixels", "spicks", "spowers", "spixels", "Powers", "Ports", "cowers", "uints", "pints", "cixels", "ppixels", "Pints", "cips", "ppips", "powers", " pips", "Pips", "uips"]}}
{"project": "FFmpeg", "commit_id": "1acd7d594c15aa491729c837ad3519d3469e620a", "target": 0, "func": "static void FUNCC(pred4x4_horizontal_add)(uint8_t *_pix, const int16_t *_block,\n\n                                          ptrdiff_t stride)\n\n{\n\n    int i;\n\n    pixel *pix = (pixel*)_pix;\n\n    const dctcoef *block = (const dctcoef*)_block;\n\n    stride >>= sizeof(pixel)-1;\n\n    for(i=0; i<4; i++){\n\n        pixel v = pix[-1];\n\n        pix[0]= v += block[0];\n\n        pix[1]= v += block[1];\n\n        pix[2]= v += block[2];\n\n        pix[3]= v +  block[3];\n\n        pix+= stride;\n\n        block+= 4;\n\n    }\n\n}\n", "idx": 18279, "substitutes": {"_pix": [" _pixels", "_paix", "_Pixels", " _pinch", "_Pinch", " _pox", " _Pinch", " _Pox", "_jpixels", "_pox", "_paIX", "_jpix", "_jpox", "_cpIX", "_pinch", "_cpox", "_Pix", "_paox", "_pixels", "_cpixels", " _Pixels", "_paixels", "_pIX", "_cpix", "_jpinch", " _Pix", "_Pox", "_PIX"], "_block": [" _group", " _image", "_bin", "_image", " _Block", "\u00a0Block", " _batch", "\u00a0group", "_group", "\u00a0image", "_batch", " _bin", "_Block"], "stride": ["Strided", " strides", "Stride", "strime", " strime", " strine", "trided", "stime", "trime", "drided", "strie", "drides", "stider", "strine", "slide", " strie", " strided", "Strie", "slider", "stide", "sline", "strided", "Strider", "trider", "Strides", "strides", " strider", "dride", " strIDE", "strider", "strIDE", "slie", "Strine", "drIDE", "tride", "StrIDE", "stided"], "i": ["gi", "uri", "m", "bi", "j", "ami", "t", "info", "x", "f", "ix", "qi", "io", "ai", "n", "phi", "pixel", "z", "ii", "ie", "di", "iu", "pos", "I", "vi", "zi", "multi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "ki", "p", "xi", "b", "a", "eni", "fi", "y", "li", "u"], "pix": ["bixels", "pixels", "ipis", "apox", "ipix", "spix", "picon", "Pius", "prix", "ptox", "bius", "mpix", "pish", "pik", " pixel", "spius", "px", "ptix", "apius", "pixel", "Pixel", "Pox", "Pich", "bil", " pich", " pip", "Pixels", "pox", "pius", "pip", " pil", " pixels", "pricon", " pik", "ipixels", "Px", "spixels", "ptish", "Pix", "xixels", " pox", "pich", "mpius", " picon", " pish", "cpius", " pius", "bip", "bixel", "Pish", "xip", "ipicon", "apix", " pis", "cpix", "cpixel", " px", "spixel", "pis", "apixel", "cpik", "prixels", "cpox", "bix", "xix", "pris", "xil", "pil", "mpik", "ipich", "mpox", "ptixels", "ipx"], "block": ["board", "plugin", "rock", "bin", "point", "group", "work", "offset", "info", "image", "ref", "full", "comment", "plus", "buffer", "tick", "border", "pack", "num", "um", "clean", "type", "bc", "node", "padding", "pos", "byte", "object", "wall", "label", "ip", "container", "page", "bar", "disk", "chain", "box", "Block", "config", "length", "bl", "batch", "cl", "sync", "map", "unit", "device", "position", "line", "off", "none", "lock", "cache", "check", "cross", "error", "col", "row", "number", "end", "list", "panel", "section", "book"]}}
{"project": "qemu", "commit_id": "6ca8d0fd51154c37b571ea74dd0b3e7a60ab847a", "target": 0, "func": "static void set_proc_name(const char *s)\n\n{\n\n#ifdef __linux__\n\n    char name[16];\n\n    if (!s)\n\n        return;\n\n    name[sizeof(name) - 1] = 0;\n\n    strncpy(name, s, sizeof(name));\n\n    /* Could rewrite argv[0] too, but that's a bit more complicated.\n\n       This simple way is enough for `top'. */\n\n    prctl(PR_SET_NAME, name);\n\n#endif    \t\n\n}\n", "idx": 18282, "substitutes": {"s": ["ns", "spec", "m", "strings", "say", "sg", "small", "data", "f", "r", "n", "str", "sb", "g", "i", "ss", "in", "ops", "slice", "is", "o", "l", "d", "array", "args", "e", "sync", "v", "c", "si", "sym", "p", "S", "address", "b", "u", "h", "names", "sign", "a", "bytes", "ds", "sf"], "name": ["ns", "part", "m", "code", "data", "info", "x", "ame", "call", "f", "image", "base", "n", "str", "num", "block", "type", "root", "nam", "Name", "self", "object", "o", "val", "NAME", "class", "array", "alias", "d", "new", "path", "size", "args", "no", "sn", "w", "prefix", "id", "named", "start", "e", "key", "c", "p", "address", "none", "missing", "null", "names", "number", "len", "a", "word", "value"]}}
{"project": "qemu", "commit_id": "b1b27b64262fdace45e5ab134c4438338076cb98", "target": 1, "func": "int nbd_client_session_co_flush(NbdClientSession *client)\n\n{\n\n    struct nbd_request request;\n\n    struct nbd_reply reply;\n\n    ssize_t ret;\n\n\n\n    if (!(client->nbdflags & NBD_FLAG_SEND_FLUSH)) {\n\n        return 0;\n\n    }\n\n\n\n    request.type = NBD_CMD_FLUSH;\n\n    if (client->nbdflags & NBD_FLAG_SEND_FUA) {\n\n        request.type |= NBD_CMD_FLAG_FUA;\n\n    }\n\n\n\n    request.from = 0;\n\n    request.len = 0;\n\n\n\n    nbd_coroutine_start(client, &request);\n\n    ret = nbd_co_send_request(client, &request, NULL, 0);\n\n    if (ret < 0) {\n\n        reply.error = -ret;\n\n    } else {\n\n        nbd_co_receive_reply(client, &request, &reply, NULL, 0);\n\n    }\n\n    nbd_coroutine_end(client, &request);\n\n    return -reply.error;\n\n}\n", "idx": 18285, "substitutes": {"client": ["pc", "ic", "session", "code", "connect", "cdn", "child", "call", "core", "google", "friend", "cm", "current", "clean", "method", "cod", "public", "admin", "ctx", "manager", "self", "bird", "container", "context", "close", "ce", "ac", "socket", "con", "config", "queue", "id", "front", "remote", "cli", "parent", "c", "private", "cur", "lib", "cache", "http", "win", "cell", "consumer", "ace", "Client", "api", "local", "connection", "project", "co", "cn", "server", "command", "custom", "conn", "contact"], "request": ["set", "instance", "session", "issue", "work", "record", "quest", "friend", "QUEST", "call", "base", "push", "child", "user", "buffer", "delete", "proxy", "apply", "report", "job", "worker", "query", "enter", "type", "method", "reference", "id", "self", "create", "get", "object", "head", "view", "pair", "re", "read", "complete", "event", "order", "use", "queue", "response", "received", "q", "config", "send", "hello", "open", "parent", "req", "post", "patch", "xml", "Request", "question", "resource", "requ", "route", "error", "er", "message", "connection", "frame", "server", "command", "transfer", "input"], "reply": ["entry", "part", "rr", "record", "child", "info", "base", "err", "comment", "ping", "call", "buffer", "hide", "delete", "proxy", "respond", "r", "apply", "report", "query", "root", "match", "related", "ry", "resp", "replace", "force", "link", "flash", "answer", "parse", "read", "bill", "ignore", "order", "reset", "back", "notice", "prefix", "response", "bot", "send", "sync", "be", "post", " response", "repl", "address", " replied", " replies", "http", "route", "error", "sys", "write", "list", "server", "Reply", "transfer"], "ret": ["part", "code", "data", "al", "bit", "ref", "err", "alt", "all", "conn", "buffer", "rc", "reg", "nt", "rt", "fun", "lit", "result", "num", "job", "ary", "flag", "rf", "ry", "resp", "rets", "count", "en", "r", "mem", "arr", "art", "att", "arg", "val", "re", "Ret", "order", "back", "ig", "response", "det", "sr", "id", "rev", "cat", "success", "rb", "RET", "pat", "pet", "res", "et", "mt", "ft", "valid", "py", "ver", "len"]}}
{"project": "FFmpeg", "commit_id": "57d77b3963ce1023eaf5ada8cba58b9379405cc8", "target": 0, "func": "int av_opencl_buffer_read(uint8_t *dst_buf, cl_mem src_cl_buf, size_t buf_size)\n\n{\n\n    cl_int status;\n\n    void *mapped = clEnqueueMapBuffer(gpu_env.command_queue, src_cl_buf,\n\n                                      CL_TRUE,CL_MAP_READ, 0, buf_size,\n\n                                      0, NULL, NULL, &status);\n\n\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not map OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    memcpy(dst_buf, mapped, buf_size);\n\n\n\n    status = clEnqueueUnmapMemObject(gpu_env.command_queue, src_cl_buf, mapped, 0, NULL, NULL);\n\n    if (status != CL_SUCCESS) {\n\n        av_log(&openclutils, AV_LOG_ERROR, \"Could not unmap OpenCL buffer: %s\\n\", opencl_errstr(status));\n\n        return AVERROR_EXTERNAL;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18304, "substitutes": {"dst_buf": ["dsrc_buf", "dsrc_queue", "dst_buff", "dst_queue", "drc_buffer", "dsrc_buff", "drc_queue", "dsrc_buffer", "dst_buffer", "drc_buff", "drc_buf"], "src_cl_buf": ["src_clpbuf", "src_pl_cb", "src_clpbuff", "src_cl_uf", "src_cl_queue", "src_cl_buff", "src_clmbuffer", "src_cl_buffer", "src_clpuf", "src_pl_buff", "src_pl_uf", "src_cl_cb", "src_clmbuf", "src_pl_buffer", "src_clmbuff", "src_clpcb", "src_pl_queue", "src_clpbuffer", "src_clmuf", "src_pl_buf"], "buf_size": [" buf_Size", "buflenSize", "buf2size", "buf_capacity", "buf_num", "buf_len", "buf2len", "buf_send", " buf_send", " buf_num", "buf_Size", " buf2size", " buf_capacity", "buflensend", " buf_len", " buf2len", "buflensize", "buflenlen", " buf2capacity", "buf2capacity"], "status": ["html", "spec", "stat", "skip", "full", "comment", "settings", " Status", "service", "ity", "result", "num", "java", "ss", "score", "id", "cli", "temp", "xml", "source", "example", "name", "msg", "magic", "summary", "size", "pre", "received", "Status", "update", "si", "stage", "uses", "gly", "reason", "process", "sex", "code", "expr", "err", "image", "json", "login", "sb", "current", "type", "date", " stat", "speed", "security", "sr", "start", "sync", "wrapper", "state", "progress", "success", "session", "s", "stats", "sp", "gc", "wait", "sw", "sl", "STAT", "index", "complete", "step", "args", "response", "ssl", "js", "url", "error", " success", "server"], "mapped": ["mmaped", "maped", "mached", "cmaped", "mmapped", "smapped", "cmached", "smaked", "smaped", "smapping", "mapping", "Mapped", "cmamped", "mmamped", "smoved", "Mached", "mmached", " moved", "mamped", "smached", "maked", "Mapping", "Maked", " mached", "Maped", " maked", " maped", " mapping", "Moved", "moved", "cmapped", "Mamped"]}}
{"project": "FFmpeg", "commit_id": "ed9b2a5178d7a7c5a95694da3a808af327f36aff", "target": 1, "func": "static int mov_read_stsc(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    AVStream *st;\n\n    MOVStreamContext *sc;\n\n    unsigned int i, entries;\n\n\n\n    if (c->fc->nb_streams < 1)\n\n        return 0;\n\n    st = c->fc->streams[c->fc->nb_streams-1];\n\n    sc = st->priv_data;\n\n\n\n    avio_r8(pb); /* version */\n\n    avio_rb24(pb); /* flags */\n\n\n\n    entries = avio_rb32(pb);\n\n\n\n    av_log(c->fc, AV_LOG_TRACE, \"track[%i].stsc.entries = %i\\n\", c->fc->nb_streams-1, entries);\n\n\n\n    if (!entries)\n\n        return 0;\n\n    if (entries >= UINT_MAX / sizeof(*sc->stsc_data))\n\n        return AVERROR_INVALIDDATA;\n\n    sc->stsc_data = av_malloc(entries * sizeof(*sc->stsc_data));\n\n    if (!sc->stsc_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < entries && !pb->eof_reached; i++) {\n\n        sc->stsc_data[i].first = avio_rb32(pb);\n\n        sc->stsc_data[i].count = avio_rb32(pb);\n\n        sc->stsc_data[i].id = avio_rb32(pb);\n\n        if (sc->stsc_data[i].id > sc->stsd_count)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    sc->stsc_count = i;\n\n\n\n    if (pb->eof_reached)\n\n        return AVERROR_EOF;\n\n\n\n    return 0;\n\n}\n", "idx": 18311, "substitutes": {"c": ["pc", "dc", "ic", "m", "ch", "t", "conf", "f", "cus", "vc", "ct", "rc", "cm", "n", "cf", "coll", "bc", "cp", "ctx", "fc", "mc", "cy", "ctrl", "enc", "ca", "cs", "arc", "l", "ce", "nc", "ac", "ci", "tc", "con", "xc", "w", "cu", "k", "cl", "lc", "cur", "p", "uc", "cache", "ec", "co", "icc", "C", "cv", "cc", "u"], "pb": ["pc", "ab", "eb", "db", "fp", "jp", "platform", "rc", "pd", "pl", "bm", "sb", "pm", "bp", "cb", "cpp", "bc", "cp", "src", "lp", "wb", "ctx", "fc", "xb", "lb", "hub", "fab", "bb", "PB", "dp", "pg", "gb", "rob", "pp", "summary", "kb", "pkg", "bps", "bf", "tc", "config", "pa", "bot", "bh", "fb", "lc", "rb", "p", "uc", "mp", "b", "ppa", "pro", "tp", "py", "prot", "ub", "cv", "lab", "typ"], "atom": [" plat", " atoms", " slab", "cm", "am", "bc", " mom", "abc", "mom", " subp", " ac", " ax", " acc", " arr", " ap", " app", " form", "com", " com", " om", " ab", " program", " cm", " parent", "orb", " em", " Atom", " am"], "st": ["pc", "s", "ch", "t", "cv", "ct", "sp", "ste", "nt", "r", "sb", "sw", "sl", "ss", "src", "bc", "fc", "sec", "ST", "sd", "sta", "std", "sn", "SC", "sth", "cr", "cl", "lc", "cur", "sync", "p", "uc", "sts", "osc", "sci", "St", "inst", "Sc", "ft", "se", "sa"], "sc": ["spec", "inc", "cf", "anc", "ss", "hub", "sec", "enc", "cs", "exec", "contract", "gb", "config", "cli", "icc", "isc", "cv", "cc", "asc", "pc", "cus", "rc", "cm", "acc", "bc", "mc", "scope", "pg", "usc", "cont", "sub", "soc", "cr", "lc", "uc", "sche", "ec", "co", "desc", "dc", "core", "ct", "sb", "match", "src", "loc", "ctrl", "ca", "go", "SC", "ga", "sync", "capt", "sci", "Sc", "sq", "ch", "esc", "sp", "sw", "ctx", "fc", "cer", "nc", "tc", "cl", "client", "cur", "osc", "ced"], "i": ["entry", "uri", "bi", "ji", "x", "qi", "ai", "phi", "hi", "ie", "d", "pi", "length", "id", "cli", "ni", "p", "xi", "anti", "h", "it", "fi", "gi", "m", "init", "j", "ix", "ini", "in", "iu", "I", "count", "v", "si", "ri", "field", "iv", "ti", "f", "r", "mi", "type", "ii", "di", "mini", "multi", "zi", "l", "oi", "yi", "ci", "abi", "start", "b", "eni", "esi", "mu", "s", "t", "data", "info", "n", "g", "z", "ij", "ski", "slice", "index", "ip", "idi", "ui", "e", "limit", "api", "y", "li", "u"], "entries": ["entry", "centries", "Entries", "rentresses", "integlements", " entrants", "gentrants", "entrs", "ENTresses", "centures", "entrants", "centry", "entures", "centrys", "ENTrys", "gentrys", "integries", "ENTrs", "ntrs", "ntrys", " entrys", "rentrys", "infrys", "infries", "rentries", "entues", "ntrants", "ENTants", "ntries", "infrants", " entlements", "estries", "ENTry", "centies", "entlements", "ENTries", "ntresses", "Enties", " entrs", "Entrs", "Entrys", " entants", "centues", "estry", "gentues", "ntry", "entrys", "ntures", "integrys", "gentries", "gentures", "integrants", "gentry", "centrs", "integrs", "rentrs", "Entrants", "estresses", "entresses", "integry", "ENTrants", "enties", "centrants", "entants", "nties", "ntues", "gentresses", "Entlements", "infants", "estrants"]}}
{"project": "FFmpeg", "commit_id": "8c013a9e55d9065793ef7ca6459d1178927a2b35", "target": 0, "func": "static int avi_read_tag(AVFormatContext *s, AVStream *st, uint32_t tag,\n\n                        uint32_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    char key[5]     = { 0 };\n\n    char *value;\n\n\n\n    size += (size & 1);\n\n\n\n    if (size == UINT_MAX)\n\n        return AVERROR(EINVAL);\n\n    value = av_malloc(size + 1);\n\n    if (!value)\n\n        return AVERROR(ENOMEM);\n\n    avio_read(pb, value, size);\n\n    value[size] = 0;\n\n\n\n    AV_WL32(key, tag);\n\n\n\n    return av_dict_set(st ? &st->metadata : &s->metadata, key, value,\n\n                       AV_DICT_DONT_STRDUP_VAL);\n\n}\n", "idx": 18323, "substitutes": {"s": ["ns", "spec", "stats", "rs", "t", "f", "sv", "services", "service", "sb", "i", "sl", "ss", "src", "ls", "ctx", "xs", "self", "is", "cs", "d", "su", "space", "w", "start", "e", "ssl", "sc", "ses", "v", "sam", "c", "ps", "si", "p", "S", "sci", "b", "cmp", "gs", "sys", "storage", "a", "es", "os", "se", "sq", "sa", "ds", "sf"], "st": ["est", "ts", "code", "stim", "t", "rest", "obj", "ct", "ste", "td", "r", "stab", "str", "sb", "ost", "stream", "sl", "ast", "ss", "src", "ptr", "ST", "sd", "sta", "store", "rd", "d", "std", "step", "stack", "start", "sc", "sth", "cr", "client", "sam", "c", "tmp", "stage", "sts", "St", "storage", "inst", "se", "sa", "ds"], "tag": ["scale", "code", "mode", "name", "token", "tick", "tags", "year", "block", "match", "type", "loc", "root", "max", "scope", "pos", "byte", "date", "count", "Tag", "format", "use", "ig", "length", "id", "prefix", "TAG", "parent", "unit", "tail", "row", "number", "word", "bug"], "size": ["set", "scale", "content", "offset", "capacity", "small", "shape", "code", "SIZE", "name", "time", "n", "sized", "g", "i", "type", "max", "loc", "six", "timeout", "count", "false", "speed", "score", "empty", "zero", "style", "ize", "length", "unit", "position", "si", "c", "address", "fee", "sum", "cache", "number", "weight", "bytes", "Size", "len"], "pb": ["pc", "ab", "eb", "db", "bs", "fp", "metadata", "obj", "jp", "platform", "vp", "mi", "pd", "bm", "pl", "sb", "pm", "bp", "cb", "cpp", "bc", "cp", "hub", "lp", "wb", "ctx", "fc", "lb", "PB", "parser", "dp", "pg", "rob", "summary", "pa", "bh", "fb", "rb", "meta", "p", "mp", "b", "ppa", "fm", "api", "py", "prot", "uf", "attr", "cv", "typ"], "key": ["entry", "code", "time", "text", "data", "esc", "name", "op", "property", "ro", "str", "root", "block", "match", "or", "type", "loc", "ie", "index", "count", "ee", "date", "prop", "pair", "val", "section", "link", " error", "ac", "rule", "length", "id", "k", "prefix", "start", "fee", "error", "field", "Key", "row", "keys", "sign", "message", "word", "mac", "KEY", "version"], "value": ["entry", "values", "scale", "content", "Value", "data", "text", "element", "name", "image", "json", "media", "buffer", "result", "current", "block", "type", "max", "function", "index", "byte", "vi", "member", "create", "object", "range", "val", "section", "array", "format", "complete", "memory", "large", "flow", "w", "length", "response", "wave", "buf", "v", "parent", "unit", "VALUE", "p", "address", "total", "fee", "null", "output", "error", "number", "message", "end", "valid", "word", "one", "version"]}}
{"project": "FFmpeg", "commit_id": "bf1945af301aff54c33352e75f17aec6cb5269d7", "target": 0, "func": "static void hybrid_analysis(float out[91][32][2], float in[5][44][2], float L[2][38][64], int is34, int len)\n\n{\n\n    int i, j;\n\n    for (i = 0; i < 5; i++) {\n\n        for (j = 0; j < 38; j++) {\n\n            in[i][j+6][0] = L[0][j][i];\n\n            in[i][j+6][1] = L[1][j][i];\n\n        }\n\n    }\n\n    if (is34) {\n\n        hybrid4_8_12_cx(in[0], out,    f34_0_12, 12, len);\n\n        hybrid4_8_12_cx(in[1], out+12, f34_1_8,   8, len);\n\n        hybrid4_8_12_cx(in[2], out+20, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[3], out+24, f34_2_4,   4, len);\n\n        hybrid4_8_12_cx(in[4], out+28, f34_2_4,   4, len);\n\n        for (i = 0; i < 59; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+32][j][0] = L[0][j][i+5];\n\n                out[i+32][j][1] = L[1][j][i+5];\n\n            }\n\n        }\n\n    } else {\n\n        hybrid6_cx(in[0], out, f20_0_8, len);\n\n        hybrid2_re(in[1], out+6, g1_Q2, len, 1);\n\n        hybrid2_re(in[2], out+8, g1_Q2, len, 0);\n\n        for (i = 0; i < 61; i++) {\n\n            for (j = 0; j < len; j++) {\n\n                out[i+10][j][0] = L[0][j][i+3];\n\n                out[i+10][j][1] = L[1][j][i+3];\n\n            }\n\n        }\n\n    }\n\n    //update in_buf\n\n    for (i = 0; i < 5; i++) {\n\n        memcpy(in[i], in[i]+32, 6 * sizeof(in[i][0]));\n\n    }\n\n}\n", "idx": 18324, "substitutes": {"out": ["IN", "user", "x", "bit", "dot", "op", "plus", "inc", "align", "Out", "trial", "copy", "again", "store", "d", "new", "no", "id", "lib", "p", "OUT", "gen", "output", "win", "h", "lin", "conn", "our", "input", "not", "part", "bin", "init", "work", "name", "ne", "min", "o", "flat", "up", "size", "outs", "v", "update", "loss", "off", "route", "list", "order", "outer", "at", "ret", "code", "f", "image", "call", "err", "net", "r", "block", "after", "val", "ex", "c", "line", "b", "sum", "lock", "version", "t", "data", "all", "io", "n", "channel", "g", "gin", "flag", "In", "pass", "ext", "index", "en", "use", "req", "cache", "error", "inner", "y"], "in": ["ic", "at", "inner", "plus", "bin", "thin", "init", "IN", "t", "data", "inn", "x", "f", "image", "bit", "all", "ini", "pin", "din", "r", "kin", "login", "n", "inc", "on", "gin", "In", "as", "pass", "index", "min", "again", "l", "d", "val", "old", "up", "new", "el", "ins", "ac", "err", "isin", "diff", "use", "con", "config", "id", "pull", "call", "v", "c", "lib", "nin", "line", "rin", "b", "gen", "win", "a", "lin", "it", "scan", "vin", "conn", "input"], "L": ["E", "LA", "UL", "V", "List", "IN", "LU", "Layer", "T", "IL", "LIN", "M", "n", "R", "LB", "N", "A", "FL", "Q", "B", "LL", "NL", "SL", "I", " l", "LR", "ln", "l", "U", "Long", "G", "W", "DL", "XL", "EL", "Lu", "J", "X", "LI", "LT", "v", "LE", "F", "D", "LP", "S", "BL", "O", "LG", "LM", "Lin", "dL", "list", "CL", "C", "el", "H", "P", "VL"], "is34": ["Is345", "IS34", "IS35", "isi33", "IS33", "IS67", "isa34", "p35", "isi345", "is67", "isa33", "p34", "isa345", "Is34", " is35", "is345", "isi34", "p67", " is67", "is35", "is33", "p33", "Is33", " is33"], "len": ["lim", "str", "num", "pos", "fen", "ln", "layer", "length", "rev", "lib", "gen", "win", "lin", "end", "lang", "lon", "bin", "lif", "fun", "fin", "ld", "min", "fl", "size", "pre", "den", "lc", "norm", "la", "f", "err", "base", "net", "lit", "lu", "block", "light", "dl", "l", "val", "le", "dy", "line", "lock", "split", "zen", "Len", "data", "all", "n", "syn", "z", "dim", "en", "lf", "low", "limit", "LI", "seq", "ll", "el", "li", "dist"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "hi", "ie", "ori", "d", "pi", "id", "cli", "ni", "p", "xi", "\u0438", "it", "fi", "source", "gi", "m", "name", "ix", "ini", "iu", "I", "o", "key", "k", "v", "si", "ki", "ri", "a", "ti", "ami", "f", "mi", "ii", "di", "mini", "ind", "vi", "zi", "chi", "l", "oi", "yi", "ci", "c", "b", "eni", "mu", "ik", "info", "io", "n", "z", "index", "slice", "is", "ip", "ui", "site", "isin", "e", "api", "im", "my", "y", "li", "u"], "j": ["bi", "br", "ji", "x", "obj", "uj", "op", "qi", "job", "java", "ie", "d", "ju", "ni", "p", "xi", "h", "it", "pt", "m", "jl", "bj", "ix", "jj", "je", "o", "J", "key", "k", "v", "si", "pr", "a", "jc", "fr", "f", "jp", "ii", "jet", "aj", "dj", "l", "ci", "oj", "q", "b", "jo", "ik", "ch", "t", "note", "io", "adj", "n", "g", "z", "ij", "jen", "ui", "e", "js", "ja", "el", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "void qemu_file_set_rate_limit(QEMUFile *f, int64_t limit)\n\n{\n\n    f->xfer_limit = limit;\n\n}\n", "idx": 18326, "substitutes": {"f": ["m", "fr", "fw", "ff", "j", "t", "fp", "ref", "fe", "file", "n", "feed", "i", "fs", "rf", "o", "lf", "fo", "l", "fx", "d", "df", "inf", "bf", "w", "fd", "e", "fb", "v", "c", "F", "p", "fm", "tf", "h", "ef", "aff", "sf"], "limit": ["limits", "offset", "skip", "lim", "base", "image", "buffer", "io", "limited", "file", "i", "type", "match", "lp", "index", "timeout", "ip", "page", "l", "inf", "format", "size", "path", "length", "policy", "id", "unit", "position", "include", "url", "lock", "rate", "filter", "cache", "route", "Limit", "len", "iter", "source", "target", "pin"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329, "substitutes": {"v": ["m", "V", "j", "t", "x", "f", "sv", "vin", "vp", "r", "g", "i", "vi", "self", "vert", "o", "vm", "uv", "l", "d", "vol", "vis", "vim", "w", "q", "k", "e", "ov", "c", "p", "volt", "b", "vv", "iv", "value", "u"], "name": ["part", "time", "data", "x", "ame", "f", "comment", "call", "n", "str", "on", "option", "i", "anc", "type", "ext", "Name", "self", "object", "o", "nm", "val", "NAME", "unknown", "d", "new", "size", "path", "no", "prefix", "key", "id", "named", "e", "parent", "none", "b", "resource", "null", "error", "names", "a", "word"], "obj": ["init", "j", "func", "ob", "ref", "expr", "op", "clone", "objects", "cb", "type", "oa", "ops", "ctx", "pos", "act", "object", "o", "po", "art", "otype", "arr", "val", "bo", "old", "path", "nc", "args", "prefix", "bool", "parent", "js", "tmp", "lib", "orb", "output", "Object", "opt", "ocl", "os", "Obj", "amp"], "errp": ["errpi", "nerlp", "err", "errP", "errpr", "rrr", "errpc", " errpr", "nerpr", "drr", "gerp", "gerr", " errlp", "nerr", "erpc", "erp", " errb", "errr", "drpi", "nerp", "gerpr", " errr", "rrp", "rrpi", "errlp", "errb", "erpi", "drP", "drp", "erP", "rrP", " errpc", "gerlp", "rrb", "erb", "rrpc"], "qiv": ["qsive", " qerv", "qsvoc", "Qiv", "Qvoc", "questiv", "qvoc", "Qou", "quiv", "qerv", " qou", "questoid", "quive", "questive", "quvoc", "qive", "qoid", "qsoid", "querv", "quou", " qvoc", "Qerv", "qou", "quoid", "qsiv", "questvoc"], "qobj": ["sqobject", "reqorb", "Qorb", "sqtmp", "reqbo", "quobb", "reqbuff", "qtmp", "reqobj", "qlib", "qutmp", "qobject", "Qbo", "qobb", "pobject", "Qobj", "pobj", "qorb", " qorb", "Qbuff", "plib", " qbo", "quobj", "ptmp", "quobject", "pbb", "sqbb", "qulib", "sqlib", "qbuff", "qubb", "sqobj", "qbo", "pobb", "sqobb", "qbb", " qbuff"], "qbool": ["questbool", "questbin", "qboot", "sqbin", "sqobject", "qavoid", "qubool", "dqval", "qbit", "qaobject", "qaval", "chbo", "chbool", "questbo", "qurl", "sqval", "sqvoid", "chvoid", "qobject", "dqvoid", "sqbo", "qabool", "squrl", "questbf", "chbit", "questurl", "qbf", "quurl", " qbis", "sqboot", "qubis", " qbf", "quboot", "dqobject", "qbis", "questboot", "sqbit", "qval", " qbo", "qbin", "qubf", "sqbool", "qvoid", "qubin", "qbo", "dqbool", " qvoid", "qubo", " qbit", "questbis"]}}
{"project": "qemu", "commit_id": "860643bc5aa902f9b736c57b66e301ef08a2b68e", "target": 0, "func": "int kvm_arch_get_registers(CPUState *cs)\n\n{\n\n    S390CPU *cpu = S390_CPU(cs);\n\n    CPUS390XState *env = &cpu->env;\n\n    struct kvm_one_reg reg;\n\n    struct kvm_sregs sregs;\n\n    struct kvm_regs regs;\n\n    int i, r;\n\n\n\n    /* get the PSW */\n\n    env->psw.addr = cs->kvm_run->psw_addr;\n\n    env->psw.mask = cs->kvm_run->psw_mask;\n\n\n\n    /* the GPRS */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_GPRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->regs[i] = cs->kvm_run->s.regs.gprs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_REGS, &regs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->regs[i] = regs.gprs[i];\n\n        }\n\n    }\n\n\n\n    /* The ACRS and CRS */\n\n    if (cap_sync_regs &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_ACRS &&\n\n        cs->kvm_run->kvm_valid_regs & KVM_SYNC_CRS) {\n\n        for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = cs->kvm_run->s.regs.acrs[i];\n\n            env->cregs[i] = cs->kvm_run->s.regs.crs[i];\n\n        }\n\n    } else {\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_SREGS, &sregs);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n         for (i = 0; i < 16; i++) {\n\n            env->aregs[i] = sregs.acrs[i];\n\n            env->cregs[i] = sregs.crs[i];\n\n        }\n\n    }\n\n\n\n    /* The prefix */\n\n    if (cap_sync_regs && cs->kvm_run->kvm_valid_regs & KVM_SYNC_PREFIX) {\n\n        env->psa = cs->kvm_run->s.regs.prefix;\n\n    }\n\n\n\n    /* One Regs */\n\n    reg.id = KVM_REG_S390_CPU_TIMER;\n\n    reg.addr = (__u64)&(env->cputm);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_CLOCK_COMP;\n\n    reg.addr = (__u64)&(env->ckc);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    reg.id = KVM_REG_S390_TODPR;\n\n    reg.addr = (__u64)&(env->todpr);\n\n    r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    if (cap_async_pf) {\n\n        reg.id = KVM_REG_S390_PFTOKEN;\n\n        reg.addr = (__u64)&(env->pfault_token);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFCOMPARE;\n\n        reg.addr = (__u64)&(env->pfault_compare);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n\n\n        reg.id = KVM_REG_S390_PFSELECT;\n\n        reg.addr = (__u64)&(env->pfault_select);\n\n        r = kvm_vcpu_ioctl(cs, KVM_GET_ONE_REG, &reg);\n\n        if (r < 0) {\n\n            return r;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 18344, "substitutes": {"cs": ["ns", "pc", "ums", "ms", "spec", "cc", "ts", "s", "bs", "ches", "core", "ras", "cus", "vc", "rc", "cf", "Cs", "cb", "CS", "bc", "ls", "ces", "wcs", "ctx", "nas", "mc", "fs", "cons", "cas", "cks", "sk", "ca", "css", "acs", "cms", "ce", "cing", "nc", "cells", "ins", "args", "ci", "acks", "tc", "qs", "sc", "ics", "vs", "sync", "lc", "c", "js", "TS", "acts", "ck", "ks", "cache", "gs", "sys", "ec", "ced", "cn", "ace", "cers", "cases", "co", "conn", "ds"], "cpu": ["pc", "cal", "core", "cus", "uci", "net", "gc", "cm", "nic", "cp", "bc", "node", "ocr", "ctx", "vm", "hw", "linux", "nc", "CPU", "gpu", "processor", "sync", "cli", "lc", "c", "kernel", "uc", "cache", "cmp", "clock", "proc", "cn", "ace", "pu", "eni", "np", "cow", "cv", "conn"], "env": ["viron", "cfg", "extra", "cf", "gui", "environment", "console", "energy", "enc", "equ", "exec", "stack", "config", "ev", "cli", "age", "ea", "output", "end", "cv", "conn", "enable", "cdn", "cal", "eve", "eu", "engine", "ne", "assets", " environment", "erv", "scope", "armor", "manager", "eng", "exe", "style", "iss", "den", "v", "stage", "ec", "et", "export", "dict", "org", "core", "err", "estate", "net", "chal", "utils", "ass", "inet", "c", "eni", "np", "esi", "Environment", "vel", "session", "cot", "db", "global", "conf", "skin", "exc", "loader", "ani", "oa", "shell", "ext", "en", "her", "context", "header", "args", "site", "e", "ssl", "osc", "cache", "que", "eval", "proc", "server", "el"], "reg": ["pc", "org", "spec", "eg", "stat", "mod", "core", "name", "all", "num", "g", "block", "or", "sec", "mem", "rec", "ig", "arch", "param", "REG", "proc", "Reg", "gr", "conn"], "sregs": ["spredl", "nsconnns", "spredo", "sregh", "srolcs", "srecl", "dsregd", "nsregns", "sargg", "csregh", "sconnves", "pregs", "dsrecl", "nsconnves", "dsregl", "pregg", "nsregi", "sreges", "nsregs", "sregd", "nsconni", "csreals", "sorgd", "srecns", "sregi", "sstats", "sorgl", "sregg", "sgregobs", "sbads", "srealobs", "sgregcs", "sconnns", "sstatns", "sbadi", "pstatg", "preges", "srols", "csregobs", "srecd", "sbadves", "pstates", "sconni", "sconns", "sorgo", "srecves", "csregcs", "csrealh", "csrealcs", "spreds", "srolh", "sstatg", "sargs", "dsrecs", "sbadns", "sregcs", "srecg", "sstates", "sregl", "sgregs", "dsrego", "pregns", "srealcs", "nsconns", "sargns", "pstatns", "sarges", "sreci", "srecs", "sregves", "dsreco", "sregobs", "csrealobs", "pstats", "sreals", "srealh", "spredd", "sregns", "csregs", "sgregh", "dsrecd", "srego", "sreces", "dsregs", "srolobs", "nsregves", "sorgs", "sreco"], "regs": ["funs", "signis", "REGo", "privp", "colports", "threads", "grega", "privwords", "grege", " rege", "funns", "colgs", "privgs", "recions", "reggs", "recs", "fungs", "colcs", "signe", "secp", "cols", " regb", "recp", "signs", "funcs", "priva", "gregb", "rolgs", "gregf", "logcs", "gregs", "REGs", "gregns", "rega", "regf", "grego", "signns", "REGb", "privs", "secs", "rege", "regp", "bindf", "REGp", "regsym", "reco", " regions", " regsym", "regions", "rolns", "gregports", "stata", "greggs", "statwords", "loggs", "threadcs", "regwords", "rols", " regp", "regb", "gregis", "privsym", "bindp", "mems", "rego", "threadports", "binds", "memp", "threadgs", "logs", "gregions", "stats", "recb", "regports", " regns", "gregcs", "regis", "memsym", "privis", "logns", "statgs", "memis", "regns", " regis", "secf", "rolcs", "gregwords", "gregp", "regcs"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "hi", "ie", "ori", "d", "pi", "id", "cli", "ni", "p", "xi", "resource", "uli", "anti", "it", "fi", "source", "gi", "m", "ei", "init", "j", "name", "ix", "ini", "iu", "I", "o", "key", "k", "v", "lc", "si", "ri", "field", "a", "ti", "f", "mi", "current", "ii", "di", "multi", "zi", "vi", "l", "oi", "yi", "ci", "abi", "c", "device", "b", "eni", "esi", "mu", "s", "t", "data", "info", "io", "n", "module", "index", "slice", "ip", "adi", "ui", "isin", "site", "e", "isi", "api", "my", "y", "li", "u"], "r": ["m", "rr", "ner", "br", "j", "fr", "t", "rs", "err", "f", "all", "rc", "hr", "reb", "n", "R", "rt", "result", "ar", "str", "g", "or", "z", "rh", "var", "rg", "rf", "arr", "o", "range", "l", "rd", "d", "re", "nr", "mr", "rar", "ru", "w", "rn", "sr", "dr", "e", "lr", "q", "cr", "c", "rb", "rl", "ir", "p", "rw", "ur", "b", "pr", "error", "h", "er", "a", "ver", "u"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int select_watchdog(const char *p)\n\n{\n\n    WatchdogTimerModel *model;\n\n    QemuOpts *opts;\n\n\n\n    /* -watchdog ? lists available devices and exits cleanly. */\n\n    if (strcmp(p, \"?\") == 0) {\n\n        LIST_FOREACH(model, &watchdog_list, entry) {\n\n            fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                     model->wdt_name, model->wdt_description);\n\n        }\n\n        return 2;\n\n    }\n\n\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        if (strcasecmp(model->wdt_name, p) == 0) {\n\n            /* add the device */\n\n            opts = qemu_opts_create(&qemu_device_opts, NULL, 0);\n\n            qemu_opt_set(opts, \"driver\", p);\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    fprintf(stderr, \"Unknown -watchdog device. Supported devices are:\\n\");\n\n    LIST_FOREACH(model, &watchdog_list, entry) {\n\n        fprintf(stderr, \"\\t%s\\t%s\\n\",\n\n                 model->wdt_name, model->wdt_description);\n\n    }\n\n    return 1;\n\n}\n", "idx": 18345, "substitutes": {"p": ["pc", "wp", "m", "point", "s", "t", "data", "fp", "f", "jp", "name", "sp", "vp", "r", "pe", "n", "ar", "g", "i", "bp", "type", "cp", "lp", "python", "ap", "pb", "parser", "o", "ip", "l", "pair", "d", "pp", "path", "pre", "e", "pa", "q", "v", "par", "c", "ps", "b", "param", "h", "tp", "np", "P", "u"], "model": ["entry", "pattern", "child", "user", "comment", "service", "gu", "file", "package", "copy", "store", "bank", "config", "id", "language", "xml", "resource", "serial", "command", "source", "reader", "m", "mod", "name", "media", "cm", "document", "app", "models", "scope", "self", "lv", "style", "parent", "lc", "table", "null", "product", "cell", "connection", "code", "view", "core", "base", "image", "cookie", "script", "block", "type", "this", "ml", "sm", "email", "ga", "line", "Model", "live", "template", "project", "ma", "author", "session", "db", "record", "global", "where", "data", "mode", "pe", "feed", "module", "sl", "method", "shell", "get", "link", "cl", "client", "form", "message", "server", "el"], "opts": ["otts", "opents", "OPts", "OPt", " oputs", " opps", "ots", "opouts", "opert", "ops", "operouts", "opps", "opta", "otps", "opcs", "ocs", "optents", " opents", "optts", "ota", "operts", "OPps", "optps", "optuts", "operents", "otcs", " opouts", "optcs", " opt", "OPuts", "optt", "opt", "oputs", "optta", "otta", "optouts"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static void virtio_balloon_handle_output(VirtIODevice *vdev, VirtQueue *vq)\n\n{\n\n    VirtIOBalloon *s = VIRTIO_BALLOON(vdev);\n\n    VirtQueueElement elem;\n\n    MemoryRegionSection section;\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        size_t offset = 0;\n\n        uint32_t pfn;\n\n\n\n        while (iov_to_buf(elem.out_sg, elem.out_num, offset, &pfn, 4) == 4) {\n\n            ram_addr_t pa;\n\n            ram_addr_t addr;\n\n            int p = virtio_ldl_p(vdev, &pfn);\n\n\n\n            pa = (ram_addr_t) p << VIRTIO_BALLOON_PFN_SHIFT;\n\n            offset += 4;\n\n\n\n            /* FIXME: remove get_system_memory(), but how? */\n\n            section = memory_region_find(get_system_memory(), pa, 1);\n\n            if (!int128_nz(section.size) || !memory_region_is_ram(section.mr))\n\n                continue;\n\n\n\n            trace_virtio_balloon_handle_output(memory_region_name(section.mr),\n\n                                               pa);\n\n            /* Using memory_region_get_ram_ptr is bending the rules a bit, but\n\n               should be OK because we only want a single page.  */\n\n            addr = section.offset_within_region;\n\n            balloon_page(memory_region_get_ram_ptr(section.mr) + addr,\n\n                         !!(vq == s->dvq));\n\n            memory_region_unref(section.mr);\n\n        }\n\n\n\n        virtqueue_push(vq, &elem, offset);\n\n        virtio_notify(vdev, vq);\n\n    }\n\n}\n", "idx": 18351, "substitutes": {"vdev": ["ldev", "vdd", "Vnd", "Vq", "Vdevice", "svtr", "vdi", "svq", " vtr", " vdef", "Vgd", "Vconf", "Vdd", " vnd", "svdef", "verev", "verdi", "svdd", "ltr", "vev", "svdev", " vdi", " vconf", "Vdev", "svgd", "vtr", "vnd", " vdevice", "svconf", " vgd", "svdevice", "vgd", "verdevice", "svnd", "Vdi", "ldevice", "vdef", "vdevice", "verdev", " vev", " vdd", "ldef", "Vev", "vconf"], "vq": ["mQ", " vk", "mquest", "Vq", "Vw", "vg", "enq", "wQ", "svq", " viq", " vqu", "tvq", " vw", "wg", "svg", "viewk", "tvw", "enque", " vQ", "svk", "wdev", "svque", "tvqu", "viewq", "hq", " vg", "viq", "qquest", "eng", " vqt", "qquery", "qQ", " vque", "mq", "vk", "hdev", "vqu", "hg", "vque", "viewiq", "VQ", " vquest", "vqt", "tvQ", "wq", "vquest", "qq", "vw", "sviq", "hQ", "vQ", " vquery", "enqt", "Vqu", "viewque", "vquery", "mquery", "svqt"], "s": ["spec", "m", "session", "t", "uns", "aws", "f", "conf", "services", "r", "service", "n", "sb", "g", "ss", "ls", "ops", "self", "o", "cs", "d", "su", "sh", "ins", "w", "e", "sc", "ses", "v", "c", "ps", "p", "S", "b", "gs", "params", "sys", "storage", "os", "state", "server", "states", "sa"], "elem": ["Elev", "nelements", "elev", "pelem", "elete", " elee", "nelete", "Elem", "element", "eelems", "nelev", " elements", " elev", "Element", "eelement", "belems", "belem", "eelements", "belee", "eelev", "belement", "pelements", "eelete", "eelee", " elete", "elee", "pelement", "belements", " elems", "elems", "belev", "pelev", "eelem", "nelem", "elements", " element", "Elements"], "section": ["entry", "set", "ect", "shadow", " replacement", "element", "child", "comment", "service", "region", "sec", "location", "piece", " intersection", "large", "config", "protection", "test", "area", "sa", "ion", "part", "j", "sect", "search", "division", "mission", "sector", "description", " component", "definition", "size", "sub", " part", "key", "sc", "lc", "parent", "patch", " parent", "ment", " structure", "ec", "row", "connection", " option", "port", "instance", " extension", "vision", "view", "iner", "script", "block", "sections", "loc", "function", "page", "array", "line", "address", "ace", "character", " segment", "session", "group", "small", "esc", "Section", "pe", "option", "module", "setting", "tag", "member", "ray", " address", "step", "ler", "e", " sec", "form", "storage", "sign", "se", "server"], "pfn": ["pnm", "ppfn", "pfd", " pfd", "vpnm", "bpfen", "pkn", "spfp", "spfn", "pfl", "tpfn", "bpfl", " pbn", "tpkn", "ppfl", "spbn", " pnm", "Pfn", "pbn", "vpfn", " pkn", "vpfp", " pfp", " pfl", "tpfp", "ppfd", " pfen", "bpfn", "ppfen", "bpfd", "tpbn", "pfp", "Pfp", "pfen", "Pnm", "spkn"], "pa": ["pc", "offset", "fp", "jp", "ref", "ara", "pn", "pe", "ai", "fa", "PA", "apa", "sb", "oa", "cp", "Pa", "lp", "pb", "pai", "ba", "pointer", " Pa", "po", "ca", "appa", "ta", "ota", "ista", "pi", "pre", "prefix", "tta", " PA", "si", "qa", "p", "address", "area", "ppa", "pr", "wa", "api", "ia", "opa", "pu", "ma", "ha", "port", "sa"], "addr": ["pc", "part", "au", "offset", "x", "base", "ref", "conn", "fe", "r", "rc", "rt", "coord", "align", "ar", "hop", "arm", "cp", "loc", "oa", "ptr", "pos", "byte", "pointer", "ip", "xp", "nm", "store", "layer", "alias", "nr", "ad", "asm", "ag", "seq", "afi", "qa", "p", "pad", "address", "area", "url", "adr", "route", "wa", "ace", "ha", "edge", "port", "eni", "attr", "ady", "amp"]}}
{"project": "FFmpeg", "commit_id": "5602a464c9f9e3c0922f5cfeccaf2fa1c40b2401", "target": 0, "func": "static av_cold int vorbis_decode_init(AVCodecContext *avccontext)\n\n{\n\n    vorbis_context *vc = avccontext->priv_data;\n\n    uint8_t *headers   = avccontext->extradata;\n\n    int headers_len    = avccontext->extradata_size;\n\n    uint8_t *header_start[3];\n\n    int header_len[3];\n\n    GetBitContext *gb = &vc->gb;\n\n    int hdr_type, ret;\n\n\n\n    vc->avccontext = avccontext;\n\n    ff_dsputil_init(&vc->dsp, avccontext);\n\n    ff_fmt_convert_init(&vc->fmt_conv, avccontext);\n\n\n\n    if (avccontext->request_sample_fmt == AV_SAMPLE_FMT_FLT) {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_FLT;\n\n        vc->scale_bias = 1.0f;\n\n    } else {\n\n        avccontext->sample_fmt = AV_SAMPLE_FMT_S16;\n\n        vc->scale_bias = 32768.0f;\n\n    }\n\n\n\n    if (!headers_len) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata missing.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = avpriv_split_xiph_headers(headers, headers_len, 30, header_start, header_len)) < 0) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Extradata corrupt.\\n\");\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[0], header_len[0]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 1) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"First header is not the id header.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_id_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Id header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    init_get_bits(gb, header_start[2], header_len[2]*8);\n\n    hdr_type = get_bits(gb, 8);\n\n    if (hdr_type != 5) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Third header is not the setup header.\\n\");\n\n        vorbis_free(vc);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if ((ret = vorbis_parse_setup_hdr(vc))) {\n\n        av_log(avccontext, AV_LOG_ERROR, \"Setup header corrupt.\\n\");\n\n        vorbis_free(vc);\n\n        return ret;\n\n    }\n\n\n\n    if (vc->audio_channels > 8)\n\n        avccontext->channel_layout = 0;\n\n    else\n\n        avccontext->channel_layout = ff_vorbis_channel_layouts[vc->audio_channels - 1];\n\n\n\n    avccontext->channels    = vc->audio_channels;\n\n    avccontext->sample_rate = vc->audio_samplerate;\n\n    avccontext->frame_size  = FFMIN(vc->blocksize[0], vc->blocksize[1]) >> 2;\n\n\n\n    avcodec_get_frame_defaults(&vc->frame);\n\n    avccontext->coded_frame = &vc->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18371, "substitutes": {"avccontext": ["avccyncontext", "avcconride", "avdconystruct", "avccronconnection", "avccasternect", "avccetnt", "avccONfig", "avccONner", "avccaontstruct", "avCCONtex", "avdconconfig", "avcconstruct", "avccronconfig", "avCConfig", "avccroncontext", "avmconstruct", "avctonnt", "avccrontext", "avcconyTEXT", "avCConstext", "avcONvert", "avccaontnect", "avcONTEXT", "avccettext", "avrconter", "avccolonstruct", "avccoconfig", "avccoconnect", "avccondnect", "avcconytext", "avcONfig", "avccONtext", "avccattext", "avctonnect", "avcconttext", "avcconscontext", "avcONcurrent", "avccastertext", "avconnect", "avccaonttext", "avccatstruct", "avrcanontext", "avccanoncurrent", "avccontnect", "avdcontext", "avdconytext", "avrcanonstruct", "avccasterstruct", "avccatte", "avCCONner", "avccONvert", "aveconssystem", "avccolontext", "avccONnt", "avmcattex", "avcconestruct", "avdconyconnection", "avcONtext", "avccorfig", "avccocontext", "avcconvert", "avCConnect", "avcconfig", "avccynstruct", "avcconynect", "avccONconfig", "avccentext", "avcconerpath", "avcconstex", "avccoconTEXT", "avcconystruct", "avdconyconfig", "avccoconsystem", "avccenTEXT", "avcconconfig", "avcconsTEXT", "avcconsystem", "avCContex", "avccynnect", "avcconsnt", "avccattex", "avccennt", "avccoconride", "avcONnect", "avccaontext", "avcconnt", "avccnter", "avmcontex", "avccondst", "avcconerner", "avCConsnect", "avcconsnect", "avcconsner", "avcconTEXT", "avrcanonnect", "avrcontext", "avcconerstruct", "avcconertext", "avcconner", "avconvert", "avccaonnect", "avccetstruct", "avCConner", "aveconsride", "avccONconnection", "avCConcontext", "avccasterpath", "avccONnect", "avcconsfig", "avccanontext", "avccetnect", "avconfig", "avccontex", "avcconernect", "avCCONtext", "avccondstruct", "avccennect", "avcONstruct", "avcconest", "avccolonnect", "avccondtext", "aveconsTEXT", "avccONst", "avccONte", "avrcanonter", "avccaonnt", "avmconte", "avccortext", "avccronstruct", "avCConsfig", "avccONstruct", "avccoloncurrent", "avcconyconfig", "avccONcurrent", "avcconsride", "avctonsnt", "aveconride", "avccorTEXT", "avrconnect", "avctonsstruct", "avccanonstruct", "aveconTEXT", "avccaontnt", "avccetTEXT", "avmcattext", "avctontext", "avCCONTEXT", "avccatnect", "avccronnect", "avcconcurrent", "avcconyride", "avccONter", "avcconenect", "avdconconnection", "avconstruct", "avctonstext", "avccONtex", "avccronfig", "avcconssystem", "avCContext", "avrconstruct", "avconpath", "avccONTEXT", "avccoconstruct", "avccyntext", "avccynte", "avcconnect", "avcconte", "avccontstruct", "avccntext", "avcconyconnection", "avccyntex", "avconTEXT", "avccenstruct", "aveconstext", "avcconetext", "avcconerTEXT", "avmcatte", "avccaonstruct", "aveconsystem", "avccanonnect", "aveconsnect", "avmcatstruct", "avccnnect", "avccynfig", "avccatvert", "avconst", "avccanonter", "avcconter", "avmcontext", "avecontext", "avcconst", "avcONst", "avcconcontext", "avdconstruct", "avcconertex", "avccronTEXT", "avctonstruct", "avconcurrent", "avccONpath", "avcONpath", "avccontnt", "avcconconnection", "avccatTEXT", "avccnstruct", "avcconpath", "avcconsstruct", "avctonsnect", "avccorstruct", "avcontext", "avccetvert", "avccensystem", "aveconnect", "avCConscontext", "avCConTEXT", "avcconstext"], "vc": ["dc", "ic", "util", "cc", "vg", "db", "fw", "vr", "wx", "cca", "gd", "sv", "cci", "vp", "nt", "service", "vec", "rt", "rc", "input", "cf", "coll", "ou", "auth", "bc", "var", "cp", "vd", "ctx", "fc", "wd", "bb", "lv", "ctrl", "vm", "cs", "uv", "hw", "ht", "ac", "ci", "serv", "cu", "ga", "vs", "ant", "VC", "lc", "c", "client", "req", "v", "cmd", "vt", "cache", "vv", "api", "nv", "cv", "conn", "voc"], "headers": ["ns", "types", "limits", "strings", "ts", "data", "fields", "services", "irs", "plugins", "details", "vals", "ers", "cb", "devices", "files", "ints", "ls", "fs", "lines", "xs", "rings", "header", "cells", "drivers", "args", "blocks", "xxx", "codes", "qs", "dr", "frames", "bits", "bands", "rows", "reports", "events", "gs", "heads", "groups", "tp", "parts", "uds", "ds"], "header_start": ["writerFenable", "header_count", "header2start", "headerMstart", "writer_start", "writer_change", "driver_start", "writerFchange", "header5clean", "header5next", "headerFstart", "header_enable", "header2end", "headerallstart", "writer_end", "headerCnext", "headerMenable", "driver_add", "driverFclean", "header_list", "driverFnext", "writer_enable", "headerPnext", "header2next", " header2end", "headerMend", "header_min", "driverFadd", "driver_next", "header_add", "headerFnext", "writerFstart", " header2start", " header_count", "header_next", "headerPend", " header_next", "header2count", " header2next", "header5start", "headerPcount", "header_end", " header_end", " header_min", "writerFend", "headerFclean", "headeralllen", "headerFenable", "header_change", "headerCadd", "headerMchange", "headerallmin", "header5add", "headerPstart", "headerFend", "headeralllist", " header_list", "headerFadd", "driverFstart", "driver_clean", "headerCstart", "headerFchange", "header_clean", "headerCclean", " header2count"], "header_len": ["header___Len", "headerCstop", "header___len", "driver_stop", "headerPl", "urationMlog", "header_l", "entry_l", "header_depth", "header_body", "headeracl", "entryaclen", "header54size", "headeracoffset", "header0len", "driver_len", "header54depth", "entry_loc", "headerklen", "headerMno", "entry_len", "header___log", "header_stop", "entry_offset", "header___no", "headerMlen", "header_log", "headerPoffset", "entryacoffset", " header_depth", "uration_Len", "headerkbody", "driverCstop", "header_pos", "headerCpos", "headerMLen", "header_size", "header54start", "driverCpos", "header0size", "driver_pos", "urationMlen", "urationMno", "uration_no", "headerCbody", "driverCbody", "uration_len", " header_size", "headerClen", "driverClen", "headeraclen", "header0depth", "headerMlog", "header_Len", "header0start", "uration_log", "entryacl", "header_no", "header_loc", "driver_body", "headerPlen", "urationMLen", "entryacloc", "header_offset", "headerPloc", "headerkpos", "headerkstop", "headeracloc", "header54len"], "gb": ["pc", "dc", "gram", "cfg", "sg", "db", "vg", "GB", "gd", "metadata", "agg", "ged", "rc", "gc", "du", "gg", "bm", "sb", "g", "gh", "cb", "gin", "hd", "bc", "cod", "hub", "vd", "ctx", "fc", "rg", "abb", "bb", "mc", "uv", "gp", "hw", "kb", "bf", "ui", "bd", "mb", "ga", "buff", "cli", "bg", "rb", "lib", "bn", "vt", "gt", "hm", "gz", "gs", "storage", "gy", "gm", "py", "cv"], "hdr_type": ["hr_length", "hdr_name", "hdr_no", "hdr_length", "hr_id", "hDR_part", "hdr2pos", "hDR_type", "hdr_part", "hr_no", "hr_type", "hdrrno", "hdr2id", "hDR_name", "hdr_pos", "hdr2type", "hDR_id", "hdrrtype", "hdrrid", "hdrrlength", "hdr_id", "hdr2name"], "ret": ["info", "obj", "bit", "ref", "base", "alt", "al", "let", "reg", "lit", "nt", "fun", "rt", "result", "flag", "match", "ut", "pass", "mem", "resp", "rets", "count", "def", "en", "arg", "arr", "att", "bad", "val", "re", "Ret", "feat", "bf", "fail", "aud", "back", "img", "value", "utf", "det", "fit", "bot", "rev", "cat", "cur", "ur", "url", "RET", "pat", "pet", "res", "ft", "valid", "usr", "reply", "success", "len"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void blk_send(QEMUFile *f, BlkMigBlock * blk)\n\n{\n\n    int len;\n\n    uint64_t flags = BLK_MIG_FLAG_DEVICE_BLOCK;\n\n\n\n    if (block_mig_state.zero_blocks &&\n\n        buffer_is_zero(blk->buf, BLOCK_SIZE)) {\n\n        flags |= BLK_MIG_FLAG_ZERO_BLOCK;\n\n    }\n\n\n\n    /* sector number and flags */\n\n    qemu_put_be64(f, (blk->sector << BDRV_SECTOR_BITS)\n\n                     | flags);\n\n\n\n    /* device name */\n\n    len = strlen(bdrv_get_device_name(blk->bmds->bs));\n\n    qemu_put_byte(f, len);\n\n    qemu_put_buffer(f, (uint8_t *)bdrv_get_device_name(blk->bmds->bs), len);\n\n\n\n    /* if a block is zero we need to flush here since the network\n\n     * bandwidth is now a lot higher than the storage device bandwidth.\n\n     * thus if we queue zero blocks we slow down the migration */\n\n    if (flags & BLK_MIG_FLAG_ZERO_BLOCK) {\n\n        qemu_fflush(f);\n\n        return;\n\n    }\n\n\n\n    qemu_put_buffer(f, blk->buf, BLOCK_SIZE);\n\n}\n", "idx": 18384, "substitutes": {"f": ["m", "fr", "xf", "fw", "j", "ff", "t", "func", "fp", "af", "info", "fe", "r", "file", "fi", "elf", "feed", "cf", "g", "i", "fac", "fc", "fs", "rf", "self", "fen", "lf", "fo", "l", "fx", "d", "df", "inf", "w", "fore", "fd", "e", "buff", "k", "fb", "v", "front", "c", "F", "p", "b", "tf", "fn", "form", "h", "ft", "uf", "sf"], "blk": ["plq", " blc", "Blq", "alc", " blok", "plk", "ilk", "ilok", "alke", "plok", "alkg", "plkg", "blke", "plak", "mlok", "bkg", "mlck", "brck", " blkg", "elok", "blkg", "ilck", "Blok", "lukg", "ilK", "plck", "clck", " blck", "blc", "bke", " blq", " blb", "brke", "elK", " blke", "belq", "Blck", "clak", "luke", "mlq", "belck", "alk", "plb", "blK", " blak", "clb", "luk", "plK", "luc", "blck", "brkg", "mlk", "clk", "belk", "elck", "brk", "blb", "Blk", "bk", "bck", "elk", "blq", "belok", "plke", "blok", "blak"], "len": ["lon", "part", "offset", "lim", "sp", "lit", "n", "str", "flag", "sl", "z", "ls", "ie", "lp", "led", "fin", "pos", "dl", " l", "en", "count", "lt", "L", "lf", "ln", "l", "val", "fl", "le", "size", "dy", "length", "id", "il", "ler", "limit", "span", "lc", " lang", "ll", "lag", "line", " lib", "Len", "lock", "lan", "la", "lin", "lang", "el", "li", " length"]}}
{"project": "qemu", "commit_id": "e5d9adbdab972a2172815c1174aed3fabcc448f1", "target": 1, "func": "int64_t qmp_guest_fsfreeze_freeze(Error **err)\n\n{\n\n    int ret = 0, i = 0;\n\n    FsMountList mounts;\n\n    struct FsMount *mount;\n\n    Error *local_err = NULL;\n\n    int fd;\n\n\n\n    slog(\"guest-fsfreeze called\");\n\n\n\n    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    QTAILQ_INIT(&mounts);\n\n    build_fs_mount_list(&mounts, &local_err);\n\n    if (error_is_set(&local_err)) {\n\n        error_propagate(err, local_err);\n\n        return -1;\n\n    }\n\n\n\n    /* cannot risk guest agent blocking itself on a write in this state */\n\n    ga_set_frozen(ga_state);\n\n\n\n    QTAILQ_FOREACH(mount, &mounts, next) {\n\n        fd = qemu_open(mount->dirname, O_RDONLY);\n\n        if (fd == -1) {\n\n            error_setg_errno(err, errno, \"failed to open %s\", mount->dirname);\n\n            goto error;\n\n        }\n\n\n\n        /* we try to cull filesytems we know won't work in advance, but other\n\n         * filesytems may not implement fsfreeze for less obvious reasons.\n\n         * these will report EOPNOTSUPP. we simply ignore these when tallying\n\n         * the number of frozen filesystems.\n\n         *\n\n         * any other error means a failure to freeze a filesystem we\n\n         * expect to be freezable, so return an error in those cases\n\n         * and return system to thawed state.\n\n         */\n\n        ret = ioctl(fd, FIFREEZE);\n\n        if (ret == -1) {\n\n            if (errno != EOPNOTSUPP) {\n\n                error_setg_errno(err, errno, \"failed to freeze %s\",\n\n                                 mount->dirname);\n\n                close(fd);\n\n                goto error;\n\n            }\n\n        } else {\n\n            i++;\n\n        }\n\n        close(fd);\n\n    }\n\n\n\n    free_fs_mount_list(&mounts);\n\n    return i;\n\n\n\nerror:\n\n    free_fs_mount_list(&mounts);\n\n    qmp_guest_fsfreeze_thaw(NULL);\n\n    return 0;\n\n}\n", "idx": 18409, "substitutes": {"err": ["ret", "rr", "ner", "br", "cfg", "fr", "conf", "call", "runner", "ctr", "eor", "reader", "eth", "rc", "r", "reg", "rt", "ar", "str", "or", "ast", "usr", "rh", "ie", "orig", "ind", "ry", "der", "resp", "arr", "orr", "nil", "gr", "aster", "mr", "rar", "ev", "rn", "ler", "dr", "e", "lr", "cr", "rev", "acer", "erg", "req", "rb", "dev", "ir", "doc", "gz", "error", "sys", "Er", "er", "iter", "server", "fi", "order", "attr", "conn", "bug"], "mounts": ["ountgs", "hostches", "ounts", "ntses", "mountes", "Mountgs", "threads", "lses", "configd", "mountedd", "hosts", "configp", "pathl", "Mounts", "uptes", "configes", "threadls", "mountongs", "Mountains", "configses", "emptains", "configls", "dirls", "dirs", "ntes", "threades", "nts", "mountl", "fundses", "configches", "dires", "emptgs", "paths", "dird", "les", "dirches", "mountsets", "mountedp", "Mountses", "mountses", "mountedl", "mounteds", "mountches", "Mountongs", "uptses", "hostses", "mountgs", "configs", "dirses", "hostes", "mountd", "mountains", "ntsets", "threadl", "uptsets", "mountp", "pathes", "emptongs", "upts", "mountls", "mountedls", "ls", "ountongs", "ountains", "mountedes", "lsets", "dirp", "empts", "pathls", "funds"], "mount": ["entry", "part", "m", "group", "child", "user", "f", "call", "track", "handle", "component", "md", "service", "option", "root", "block", "match", "source", "mem", "multi", "pg", "host", "link", "pair", "hw", "path", "pkg", "fail", "config", "Mount", "sync", "parent", "device", "mont", "c", "patch", "account", "p", "url", "dev", "follow", "cache", "mounted", "lock", "cmp", "od", "monitor", "field", "proc", "boot", "find", "connection", "project", "port", "mm", "valid", "own", "lc", "attr", "target"], "local_err": ["local_er", "locallytx", " local_state", "http_log", "local_log", "local__ir", " local_order", " local_er", "localxtx", "local__log", " local_error", "localapperr", "localxerror", "local7err", "local7error", " local_tx", "localapperror", "localappcor", "local__error", "local_ir", " local_magic", "shared_err", "shared_rr", "localxer", "localxerr", " local_cor", "local_error", "local_rr", " local_rr", "locallyerr", "shared_error", "shared_req", "local7er", "local_order", "locallyerror", "localxmagic", "http_error", "http_err", "localxorder", "local__err", "local_state", "locallyorder", "http_ir", "local_cor", "local7state", "local_req", "local_magic", "localapprr", "local_tx"], "fd": ["dc", "dn", "dd", "draft", "db", "pid", "nd", "fw", "ff", "fp", " FD", "f", "fat", "dir", "handle", "gd", "conn", "reader", "fe", "md", "io", "file", " fin", "fun", "feed", "fa", "cf", "cb", "hd", "vd", "wb", " f", " fid", "fc", "dl", "fs", "wd", "ld", "zip", "fen", "sd", "fed", "writer", "wind", "cond", "ln", "fx", "lf", "d", "fl", " d", "df", "bf", "FH", "socket", "bd", "pipe", "handler", "fb", "buf", "c", "fff", "fm", "fn", "cd", "len", "fi", "FD", "ds", "sf"], "i": ["ret", "init", "j", "t", "info", "x", "f", "ini", "qi", "r", "ai", "mi", "io", "phi", "n", "counter", "result", "nt", "num", "ii", "di", "index", "mini", "ind", "I", "count", "out", " ret", "l", "val", "pi", "ui", "ci", "abi", "id", "key", "limit", "e", "v", "c", "ni", "si", "p", "b", "len", "it", "fi", "li", "ib", "u"]}}
{"project": "qemu", "commit_id": "ccbcfedd17fd2d13521fcee66810d0df464ec1cc", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412, "substitutes": {"fdt": ["cdnt", "dld", "fdtt", "vdtt", "fdx", "ndd", "dlx", "dfct", "dfx", "vdta", "dfnt", "cdt", "vdnt", "dlnt", "lfx", "fdd", "lfnt", "fdct", "fdnt", "vdt", "dfta", "cdta", "ndct", "dftt", "lfta", "ndtt", "dfd", "dlct", "dlt", "fdta", "dltt", "dlta", "cdtt", "lft", "dft", "ndt"], "node_path": ["node_data", "node_name", "nodebookname", "nodebookpointer", "node_prop", " node_name", " node_data", "nodebookpath", "nodebookprop", " node_pointer", " node_prop", "node_pointer"], "property": ["set", "part", "term", "integer", "data", "element", "name", "attribute", "Property", "option", "root", "type", "package", "node", "function", "filename", "pointer", "object", "description", "prop", "range", "letter", "location", "section", "path", "prefix", "key", "parent", "position", "variable", "p", "address", "item", "feature", "resource", "field", "properties", "number", "value", "attr", "expression"], "offset": ["set", "part", "data", "info", "Offset", "f", "optional", "attribute", "fp", "ref", "sort", "align", "i", "type", "loc", "phase", "node", "padding", "index", "pos", "timeout", "count", "pointer", "object", "o", "online", "range", "notation", "location", "slot", "inet", "unknown", "alias", "empty", "size", "no", "length", "prefix", "start", "layout", "position", "off", "p", "address", "url", "missing", "append", "null", "output", "error", "shift", "et", "number", "api", "addr", "end", "absolute", "alpha", "operation", "value", "len"]}}
{"project": "FFmpeg", "commit_id": "5ff998a233d759d0de83ea6f95c383d03d25d88e", "target": 1, "func": "static uint32_t calc_optimal_rice_params(RiceContext *rc, int porder,\n\n                                         uint32_t *sums, int n, int pred_order)\n\n{\n\n    int i;\n\n    int k, cnt, part;\n\n    uint32_t all_bits;\n\n\n\n    part     = (1 << porder);\n\n    all_bits = 4 * part;\n\n\n\n    cnt = (n >> porder) - pred_order;\n\n    for (i = 0; i < part; i++) {\n\n        k = find_optimal_param(sums[i], cnt);\n\n        rc->params[i] = k;\n\n        all_bits += rice_encode_count(sums[i], cnt, k);\n\n        cnt = n >> porder;\n\n    }\n\n\n\n    rc->porder = porder;\n\n\n\n    return all_bits;\n\n}\n", "idx": 18426, "substitutes": {"rc": ["dc", "oc", "pc", "rx", "rs", "core", "irc", "cca", "RC", "r", "rt", "result", "coll", "anc", "cb", "bc", "src", "loc", "rh", "ctx", "fc", "abc", "ctrl", "auc", "cs", "arc", "context", "roc", "rec", "gb", "nc", "ac", "tc", "xc", "config", "sc", "sync", "cur", "c", "lc", "rb", "uc", "cmp", "icc", "cv", "cc"], "porder": ["lpake", "npake", "upair", "parm", "corders", " pordered", " pcount", "varm", "nordered", "lparm", "npair", "prorder", "Porders", "upoder", " pake", "Pordering", "lporders", "uporder", "lpordering", "pordered", "preoder", " paddress", " porders", "pcount", "cordered", "Parm", "prorders", "ncount", "rordered", "preair", "Porder", "vorder", "uporders", "pair", " poder", "lpaddress", "upordering", "cordering", "pordering", "pake", "paddress", "prordering", "vordering", "nair", "rair", "corder", "poder", " pordering", "upordered", "lpair", "porders", "vorders", "preorder", " pair", "rcount", "lporder", "norder", "rorder", "npaddress", "nporder", "preorders"], "sums": ["sesums", " sults", "psamples", " samples", " suma", "samples", " sum", "asups", " suss", "sesuss", "pales", "asums", "sus", "psales", "Sums", "suss", "Suma", "sults", "suma", " sales", "Suss", "Sults", "subs", "pum", "pamples", "asuma", " sups", "pums", "sups", "sum", " subs", "psum", "Subs", "sesubs", "psums", "Sus", " sus", "sales", "Sups", "sesults", "asus"], "n": ["ns", "m", "j", "s", "un", "t", "x", "f", "pn", "net", "ne", "nt", "num", "mn", "N", "g", "z", "node", "in", "nb", "en", "o", "nm", "l", "d", "non", "nc", "network", "sn", "no", "e", "span", "v", "ni", "c", "p", "b", "fn", "cn", "len", "number", "nn", "an", "conn", "u"], "pred_order": ["Pred_order", "predPordered", "predfordered", "Pred_key", "pred__orders", "Pred_orders", "predforders", "cmp_orders", "pred_orders", "pred_rank", "pred__rank", "pred_Order", "cmpforder", "predfrank", "Pred_ordered", "predPorder", "pred__order", "cmpforders", "cmp_Order", "predPkey", "cmpfrank", "predfOrder", "pred_key", "predfkey", "predforder", "cmp_rank", "pred__Order", "cmp_order", "pred_ordered", "cmpfOrder", "predPorders"], "i": ["gi", "ti", "uri", "m", "bi", "init", "j", "s", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "io", "ii", "in", "ie", "di", "index", "mini", "slice", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "abi", "id", "e", "q", "v", "c", "ni", "si", "ki", "ri", "p", "xi", "b", "mu", "h", "api", "it", "fi", "y", "li", "u"], "k": ["m", "ik", "j", "work", "ijk", "x", "f", "kick", "ek", "r", "kin", "g", "K", "ok", "kind", "kid", "kr", "kw", "o", "sk", "ask", "d", "kh", "ko", "kn", "w", "key", "id", "q", "e", "ak", "kat", "unk", "ka", "c", "v", "ki", "p", "ck", "mk", "ks", "b", "ke", "dk", "kk", "y", "u"], "cnt": ["dcct", "cnd", "acnt", "pcpt", "dcnt", " cnc", "cpt", "pcnn", "acent", " cNT", "dcnd", "Cno", " cnd", " cct", "dcant", "ucant", "crt", "Cant", "dcpt", "conwd", " cpt", "ucnd", " cent", "Cnt", "CNT", "dcNT", "acwd", "conNT", "ucnn", " crt", "cent", " cno", "ucnc", "ucnt", "cct", "connt", "cwd", " cant", "dcrt", "conent", "cno", "cNT", "dcnc", "ucct", "cant", "pcnt", "pcrt", "acNT", "cnn", " cwd", "dcnn", "cnc", "dcno", " cnn"], "part": ["pc", "m", "point", "j", "x", "base", "f", "round", "block", "year", "type", "max", "pos", "min", "count", "po", "art", "half", "force", "pair", "val", "d", "section", "change", "step", "partial", "space", "pi", "pre", "seed", "minute", "no", "start", "limit", "PART", "id", "v", "span", "parent", "position", "patch", "p", "pad", "b", "number", "parts", "Part", "order", "len"], "all_bits": ["allCbytes", "all__bits", "all_bit", "all_pieces", "all__parts", "all_params", " all_pins", "all_pins", "allCparams", " all_bytes", " all_parts", "all__bytes", "allCbits", "all__pieces", " all_bit", "all_bytes", "allCpieces", " all_pieces", "all_parts", " all_params"]}}
{"project": "qemu", "commit_id": "4c8449832c0add27b898e657a9e7e8603f44157c", "target": 1, "func": "static void external_snapshot_commit(BlkActionState *common)\n\n{\n\n    ExternalSnapshotState *state =\n\n                             DO_UPCAST(ExternalSnapshotState, common, common);\n\n\n\n    bdrv_set_aio_context(state->new_bs, state->aio_context);\n\n\n\n    /* This removes our old bs and adds the new bs */\n\n    bdrv_append(state->new_bs, state->old_bs);\n\n    /* We don't need (or want) to use the transactional\n\n     * bdrv_reopen_multiple() across all the entries at once, because we\n\n     * don't want to abort all of them if one of them fails the reopen */\n\n    bdrv_reopen(state->old_bs, state->old_bs->open_flags & ~BDRV_O_RDWR,\n\n                NULL);\n\n}\n", "idx": 18437, "substitutes": {"common": ["util", "session", "mod", "global", "record", "core", "conf", "name", "full", "component", "shared", "from", "cm", "command", "loader", "comm", "document", "master", "public", "node", "control", "ctx", "normal", "create", "COM", "low", "context", "Common", "generic", "summary", "new", "pkg", "stack", "comp", "recent", "com", "con", "security", "standard", "remote", "sync", "client", "central", "lib", "cache", "foreign", "resource", "server", "diff", " Common"], "state": ["set", "status", "part", "instance", "stat", "session", "spec", "j", "work", "cal", "data", "info", "name", "call", "comment", "settings", "media", "element", "all", "core", "component", "module", "or", "master", "type", "scope", "ass", "slice", "manager", "self", "tag", "date", "object", "State", "art", "parse", "are", "grade", "event", "the", "seed", "rule", "style", "use", "config", "start", "update", "parent", "post", "STATE", "patch", "address", "cache", "resource", "output", "form", "param", "ace", "list", "port", "states", "conn"]}}
{"project": "FFmpeg", "commit_id": "38d553322891c8e47182f05199d19888422167dc", "target": 1, "func": "int av_image_alloc(uint8_t *pointers[4], int linesizes[4],\n\n                   int w, int h, enum PixelFormat pix_fmt, int align)\n\n{\n\n    int i, ret;\n\n    uint8_t *buf;\n\n\n\n    if ((ret = av_image_check_size(w, h, 0, NULL)) < 0)\n\n        return ret;\n\n    if ((ret = av_image_fill_linesizes(linesizes, pix_fmt, w)) < 0)\n\n        return ret;\n\n\n\n    for (i = 0; i < 4; i++)\n\n        linesizes[i] = FFALIGN(linesizes[i], align);\n\n\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, NULL, linesizes)) < 0)\n\n        return ret;\n\n    buf = av_malloc(ret + align);\n\n    if (!buf)\n\n        return AVERROR(ENOMEM);\n\n    if ((ret = av_image_fill_pointers(pointers, pix_fmt, h, buf, linesizes)) < 0) {\n\n        av_free(buf);\n\n        return ret;\n\n    }\n\n    if (av_pix_fmt_descriptors[pix_fmt].flags & PIX_FMT_PAL)\n\n        ff_set_systematic_pal2((uint32_t*)pointers[1], pix_fmt);\n\n\n\n    return ret;\n\n}\n", "idx": 18438, "substitutes": {"pointers": ["angles", "tips", "limits", "roots", "styles", "pieces", "pages", "fields", "weights", "faces", "ports", "cuts", "ices", "details", " pointer", "ips", "toc", "points", "ints", "wcs", "padding", "ctx", "rh", "ptr", "pos", "posts", "lines", "xs", "pointer", "rings", "balls", "path", "offs", "codes", "pins", "maps", "amps", "steps", "thumbnails", "ps", "rows", "p", "pad", "books", "tracks", "ipes", "holes", "parts", "cases", "opens", "sets", "notes", "inters", "eps", "locks"], "linesizes": [" linesamples", "lesizes", "linedizes", "linizations", "linsamples", "lineizers", " linesets", " linesizing", "lesizing", "linedizing", "lineizing", " linesize", "linesets", "lesizations", "inesizations", "inesamples", "linsizers", "inesets", "linesizations", "linesizers", "linets", "linedizations", "linsizes", "linizes", " linesizers", "linsizations", "inesizers", "linedize", "linsize", "lesamples", "linesamples", "lineizes", "linesizing", "lineizations", "inesizes", "linizers", "linesize", "lineize", "linizing", " linesizations", "linedamples", "linsizing"], "w": ["m", "wt", "fw", "s", "x", "f", "wrap", "all", "r", "n", "we", "window", "sw", "z", "max", "wb", "wd", "ew", "o", "l", "d", "hw", "W", "v", "temp", "c", "nw", "p", "rw", "b", "win", "wh", "wa", "aw", "a", "y", "u"], "h": ["m", "offset", "ch", "t", "x", "f", "oh", "hr", "r", "n", "gh", "g", "hi", "hd", "z", "rh", "loc", "padding", "uh", "help", "pointer", "head", "host", "l", "hw", "ht", "sh", "path", "height", "q", "bh", "v", "ih", "c", "cl", "p", "hm", "b", "hh", "ph", "ha", "hs", "ah", "H", "y", "u"], "pix_fmt": ["pix2frMT", "pix_tfprintf", "pix_funformat", "pix_frmt", "pix_frrt", "pix_formmat", "pix_lprintf", "pix_freemat", "pix_lrt", "pix_formkt", "pix_tfkt", "pix_fformat", "pix_formmt", "pix2fMT", "pix_fcMT", "pix_frformat", "pix_freert", "pix_fMT", "pix2frmt", "pix_freemt", "pix_fcformat", "pix_formMT", "pix_funkt", "pix_fkt", "pix_lmt", "pix_formrt", "pix2frformat", "pix_tfformat", "pix_frt", "pix_lmat", "pix_fcmt", "pix2frt", "pix_fmat", "pix_lformat", "pix2frrt", "pix_lMT", "pix_formformat", "pix_frMT", "pix_freeformat", "pix_funmt", "pix_fprintf", "pix_tfmt", "pix_fcprintf", "pix2fformat", "pix2fmt", "pix_tfrt", "pix_funMT", "pix_tfMT"], "align": ["IGN", "offset", "work", "ff", "mag", "al", "f", "ref", "x", "wrap", "ail", "coord", "border", "pixel", "angle", "padding", "aligned", "help", "xff", "ign", "balance", "margin", "array", " alignment", "format", "size", "alias", "ignment", "style", "adjust", "img", "lace", "arrow", "ag", "shift", "pad", "cache", "addr", "aff", "diff", "attr", "amp", "len"], "i": ["gi", "ti", "uri", "m", "j", "s", "t", "x", "f", "ix", "ini", "qi", "r", "io", "ai", "n", "phi", "type", "z", "ii", "in", "iu", "di", "ind", "index", "I", "multi", "zi", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "it", "eni", "fi", "y", "li", "ib", "u"], "ret": ["entry", "offset", "obj", "ref", "nt", "debug", "result", "run", "replace", "att", "feat", "reset", "id", "buff", "rev", "hard", "rep", "opt", "res", "end", "fi", "len", "part", "ff", "fat", "fun", "usr", "fin", "count", "arg", "art", "plain", "Ret", "bf", "cat", "RET", "pet", "ft", "status", "f", "base", "alt", "lit", "rt", "match", "mem", "bad", "val", "re", "aux", "ru", "back", "addr", "value", "reply", "success", "af", "wrap", "let", "buffer", "reg", "flag", "pass", "ext", "def", "rets", "prop", "complete", "fail", "img", "fd", "rb", "error", "nz", "red", "proc", "uf"], "buf": ["Buffer", "ab", "offset", "br", "ff", "data", "fp", "obj", "f", "ref", "func", "pool", "buffer", "rc", "vec", "lit", "fun", "result", "cb", "bc", "src", "Buff", "loc", "wb", "ctx", "pb", "ptr", "lb", "mem", "ba", "cas", "xff", "aux", "box", "back", "img", "queue", "bd", "fd", "buff", "fb", "v", "temp", "cur", "tmp", "seq", "rb", "uc", "off", "pad", "plug", "b", "alloc", "port", "bag", "callback", "uf", "cv"]}}
{"project": "qemu", "commit_id": "c627e7526a902dd5bb1907dbbd5cf961679dfa68", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439, "substitutes": {"s": ["ns", "status", "stat", "session", "t", "conf", "f", "settings", "services", "service", "sie", "sb", "g", "ss", "scope", "fs", "self", "is", "o", "l", "su", "site", "iss", "e", "ssl", "side", "ses", "sync", "c", "js", "si", "sym", "p", "S", "b", "gs", "sys", "u", "local", "os", "state", "se", "states", "sq", "sf"], "index": ["point", "offset", "x", "element", "inc", "Index", "range", "design", "path", "length", "id", "feature", "loop", "end", "column", "input", "part", "name", "ix", "action", "pointer", "object", "axis", "zero", "key", "update", "include", "condition", "fff", "row", "weight", "connection", "expression", "instance", "view", "f", "image", "fe", "window", "coll", "block", "match", "type", "loc", "ind", "forward", "date", "val", "position", "address", "fee", "append", "lock", "ace", "addr", "edge", "value", "success", "version", "shape", "info", "office", "i", "iframe", "slice", "active", "draw", "insert", "error", "level", "body"], "frame": ["raise", "point", "scale", "offset", "code", "time", "info", "f", "image", "thread", "series", "hide", "fe", "trace", "version", "family", "cf", "window", "iframe", "block", "loc", "function", "orig", "slice", "ind", "forward", "scope", "range", "close", "event", "flow", "length", "e", "update", "frames", "c", "position", " Frame", "line", "feature", "append", "next", "clock", "ace", "row", "loop", "fram", "state", "Frame"]}}
{"project": "qemu", "commit_id": "71407786054cad26de7ef66718b2a57a4bcb49b5", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447, "substitutes": {"vdev": ["ldev", "fdev", " vdef", " vnd", "fprom", "lprom", "fdef", "vprom", "vci", "svdev", " vprom", "fnd", "vnd", " vdevice", "svdevice", "svnd", "ldevice", "svci", "vdef", "vdevice", "fci", " vci", "ldef", "fdevice"], "vq": ["svue", "sveq", "gudq", " veq", "veq", "svq", "guq", " vqu", "tvq", "tvue", " vQ", "invq", "invqu", "svQ", "guque", "invdq", "tveq", "invque", "vqu", "vque", "tvQ", " vue", "vQ", " vdq", "vdq", "vue", "guqu", " vque"], "s": ["ns", "spec", "m", "sup", "t", "core", "f", "sv", "services", "r", "service", "n", "sb", "g", "i", "ss", "ops", "scope", "self", "is", "o", "sk", "share", "cs", "d", "su", "secure", "new", "socket", "w", "e", "ssl", "sc", "q", "ses", "v", "sync", "js", "c", "si", "dev", "sym", "p", "secondary", "S", "support", "http", "sys", "storage", "a", "hs", "server", "sq", "an", "ds", "sf"]}}
{"project": "qemu", "commit_id": "1a20a032ccbb5800bfdfc75accfcff2ac67f5bcb", "target": 1, "func": "USBDevice *usb_host_device_open(const char *devname)\n\n{\n\n    struct usb_device_info bus_info, dev_info;\n\n    USBDevice *d = NULL;\n\n    USBHostDevice *dev;\n\n    char ctlpath[PATH_MAX + 1];\n\n    char buspath[PATH_MAX + 1];\n\n    int bfd, dfd, bus, address, i;\n\n    int ugendebug = UGEN_DEBUG_LEVEL;\n\n\n\n    if (usb_host_find_device(&bus, &address, devname) < 0)\n\n        return NULL;\n\n\n\n    snprintf(buspath, PATH_MAX, \"/dev/usb%d\", bus);\n\n\n\n    bfd = open(buspath, O_RDWR);\n\n    if (bfd < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to open usb bus - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n    bus_info.udi_addr = address;\n\n    if (ioctl(bfd, USB_DEVICEINFO, &bus_info) < 0) {\n\n#ifdef DEBUG\n\n        printf(\"usb_host_device_open: failed to grab bus information - %s\\n\",\n\n               strerror(errno));\n\n#endif\n\n        return NULL;\n\n    }\n\n\n\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s\", bus_info.udi_devnames[0]);\n\n#else\n\n    snprintf(ctlpath, PATH_MAX, \"/dev/%s.00\", bus_info.udi_devnames[0]);\n\n#endif\n\n\n\n    dfd  = open(ctlpath, O_RDWR);\n\n    if (dfd < 0) {\n\n        dfd = open(ctlpath, O_RDONLY);\n\n        if (dfd < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to open usb device %s - %s\\n\",\n\n                   ctlpath, strerror(errno));\n\n#endif\n\n        }\n\n    }\n\n\n\n    if (dfd >= 0) {\n\n        if (ioctl(dfd, USB_GET_DEVICEINFO, &dev_info) < 0) {\n\n#ifdef DEBUG\n\n            printf(\"usb_host_device_open: failed to grab device info - %s\\n\",\n\n                   strerror(errno));\n\n#endif\n\n            goto fail;\n\n        }\n\n\n\n        d = usb_create(NULL /* FIXME */, \"usb-host\");\n\n        dev = DO_UPCAST(USBHostDevice, dev, d);\n\n\n\n        if (dev_info.udi_speed == 1)\n\n            dev->dev.speed = USB_SPEED_LOW - 1;\n\n        else\n\n            dev->dev.speed = USB_SPEED_FULL - 1;\n\n\n\n        if (strncmp(dev_info.udi_product, \"product\", 7) != 0)\n\n            pstrcpy(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                    dev_info.udi_product);\n\n        else\n\n            snprintf(dev->dev.product_desc, sizeof(dev->dev.product_desc),\n\n                     \"host:%s\", devname);\n\n\n\n        pstrcpy(dev->devpath, sizeof(dev->devpath), \"/dev/\");\n\n        pstrcat(dev->devpath, sizeof(dev->devpath), dev_info.udi_devnames[0]);\n\n\n\n        /* Mark the endpoints as not yet open */\n\n        for (i = 0; i < USB_MAX_ENDPOINTS; i++)\n\n           dev->ep_fd[i] = -1;\n\n\n\n        ioctl(dfd, USB_SETDEBUG, &ugendebug);\n\n\n\n        return (USBDevice *)dev;\n\n    }\n\n\n\nfail:\n\n    return NULL;\n\n}\n", "idx": 18457, "substitutes": {"devname": ["DevName", "devno", "Devno", " devno", "evName", "devNAME", " devnames", "evNAME", "deviceName", "evname", "devnames", "deviceno", "devicename", "DevNAME", "devName", " devName", "Devnames", " devNAME", "devicenames", "Devname"], "bus_info": ["busjINFO", " buserinfo", "dev_now", "bus_inf", " usb_info", "busallstart", "bus_now", " usbgINFO", " bus_auto", "driver_start", "driver_inf", "busgInfo", " usb_ref", "dev_inf", "busallinf", "usb_start", "buserauto", "busjref", "bus_id", "usb_area", "driverallfo", "driver_fo", "bus_INFO", "bus_ref", "driverallinfo", "bus_area", "usb_info", "bus_fo", "usb_id", " usb_INFO", "bus_auto", " usbgref", " bus_object", " buserauto", "driverallinf", "busallfo", "busjInfo", " usbgInfo", "buserinfo", "busgref", "bus_object", "driver_info", "busjinfo", "busginfo", "busallinfo", " usb_Info", "bus_start", "driverallstart", " usbginfo", "buserobject", " buserobject", "busgINFO", "bus_Info"], "dev_info": ["dev_INFO", " dev_inf", "devsInfo", "dev_num", "Dev_inf", " dev_Info", "dev_Info", "Dev_info", "Dev_INFO", " dev_INFO", "devsinf", "devsinfo", "dev_inf", " dev_num"], "d": ["dc", "m", "dn", "dd", "t", "gd", "f", "md", "n", "dh", "g", "z", "di", "dt", "dl", "def", "sd", "l", "std", "w", "bd", "dm", "ad", "e", "fd", "v", "c", "device", "D", "p", "driver", "ded", "b", "dat", "h", "cd", "dict", "ds"], "dev": ["dd", "gd", "md", "gu", "debug", "nt", "max", "raw", "console", "sh", "ev", "gpu", "config", "temp", "p", "od", "next", "res", "serial", "die", "ve", "Dev", "init", "mod", "pub", "de", "app", "o", "hw", "linux", "adv", "v", "dom", "off", "ver", "dc", "f", "block", "di", "sd", "fo", "home", "w", "ad", "dm", "start", "private", "device", "D", "cd", "bug", "s", "ch", "data", "info", "conf", "g", "def", "cost", "bd", "_", "driver", "error", "proc", "api", "diff", "attr", "dist"], "ctlpath": ["ctlcase", "ctrlenc", "ctrlkey", "configPath", "fdenc", "bcpath", "ditstr", "lcpath", "ctlparent", "sudoath", "gitparent", "dlPath", "ctlinfo", "configpath", "sudopath", "bcPATH", "bccase", "ctlPath", "gitPATH", "ditpath", "catpath", "controlpath", "ctlath", "controlcase", "ctrlPath", "ctrlpath", "gitcase", "fdkey", "dlath", "catath", "configcase", "lcinfo", "configenc", "catPath", "ditinfo", "sslath", "sudoPath", "configath", "controlath", "catcase", "ctlkey", "ctlPATH", "configkey", "ctlenc", "lcath", "sslpath", "dlstr", "ditPath", "ctlstr", "sslPath", "sudoinfo", "configPATH", "gitpath", "configparent", "dlpath", "controlPath", "configstr", "bcparent", "ditath", "fdPath", "fdpath"], "buspath": ["busPath", "blockroom", "businfo", "bridgepath", "switchconfig", "busath", "driverpath", "usbconfig", "usbroot", "ctlinfo", "blockfull", "switchpath", "ctlPath", "bootinfo", "ctlath", "passroot", "busfull", "driverroom", "passfull", "driverfull", "bridgefull", "switchroot", "usbpath", "bootpath", "busconfig", "blockpath", " businfo", "switchfull", "bridgecat", "bridgeroom", "drivercat", "buscat", "busroot", "busroom", "bootPath", "passpath", "bootath", "usbfull", " busath", "passconfig", "blockcat", " busPath"], "bfd": [" bcd", "bdc", "Bdc", "ldf", "ffa", "bdf", "Bdd", "Bfd", "rbfd", " bdf", "lcd", "bFD", "lfc", " bFD", "bcd", "BFD", "rbfc", "fdc", "fdd", " bdd", "basedc", "ffd", "Bfc", "baseFD", "bfa", "bdd", "rbcd", "rbdf", " bfa", "lfd", "bfc", " bfc", "Bfa", "basefd", "ffc", "basefc", " bdc"], "dfd": ["bbdy", "mddy", "mdd", "DFyd", "fcds", "dfdb", "dfdh", "ddds", "ufds", "pdfcd", "cfl", "cfs", "depsd", "dft", "bdyd", "DFD", "bbD", "depD", "efds", "eft", "dfcd", "uft", "ufl", "afd", "fdf", "DFb", "dfl", "afdh", "efl", "defds", "dff", "pdfd", "defd", "mdsd", "fdcd", "fdD", "dfD", "DFdh", "cfb", "fcd", "bdb", "afb", "rawD", "cfd", "DFt", "bds", "DFds", "fddb", "bbsd", "pdfD", "fdd", "dfb", "ddf", "bbd", "dfds", "bdd", "dfdy", "deff", "ddd", "ufd", "dfyd", "afD", "cfD", "depd", "depdy", "fcD", "fdds", "rawcd", "DFd", "dfs", "fddh", "rawdb", "cfyd", "cfds", "ddcd", "fcl", "efd", "defcd", "dfsd", "rawd", "DFs", "fdb", "pdfdb", "mdD", "DFl"], "bus": ["uri", "board", "plugin", "base", "name", "usb", "bridge", "Bus", "type", "hub", "def", "object", "controller", "host", "class", "path", "config", "length", "id", "mount", "cat", "device", "lib", "driver", "plug", "b", "BUS", "cache", "route", "interface", "boot", "serial", "os", "connection", "us", "port", "bug"], "address": ["uri", "instance", "offset", "shape", "Address", "name", "image", "attribute", "base", "service", "ai", "bridge", "master", "type", "package", "reference", "index", "ip", "host", "location", "ress", "array", "alias", "path", "audio", "network", "length", "id", "config", "device", "position", "p", "url", "route", "interface", "ace", "a", "number", "api", "addr", "message", "end", "port", "server", "order", "target"], "i": ["uri", "instance", "init", "info", "ini", "ai", "ii", "in", "di", "iu", "index", "I", "is", "ip", "pi", "ui", "ci", "id", "cli", "c", "ni", "p", "b", "interface", "api", "fi", "li"]}}
{"project": "FFmpeg", "commit_id": "98b377004d9c6fa1c1756c814efe9882b65f96b9", "target": 0, "func": "static av_cold int twin_decode_init(AVCodecContext *avctx)\n\n{\n\n    int ret;\n\n    TwinContext *tctx = avctx->priv_data;\n\n    int isampf, ibps;\n\n\n\n    tctx->avctx       = avctx;\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_FLTP;\n\n\n\n    if (!avctx->extradata || avctx->extradata_size < 12) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Missing or incomplete extradata\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avctx->channels = AV_RB32(avctx->extradata    ) + 1;\n\n    avctx->bit_rate = AV_RB32(avctx->extradata + 4) * 1000;\n\n    isampf          = AV_RB32(avctx->extradata + 8);\n\n\n\n    if (isampf < 8 || isampf > 44) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported sample rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    switch (isampf) {\n\n    case 44: avctx->sample_rate = 44100;         break;\n\n    case 22: avctx->sample_rate = 22050;         break;\n\n    case 11: avctx->sample_rate = 11025;         break;\n\n    default: avctx->sample_rate = isampf * 1000; break;\n\n    }\n\n\n\n    if (avctx->channels <= 0 || avctx->channels > CHANNELS_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unsupported number of channels: %i\\n\",\n\n               avctx->channels);\n\n        return -1;\n\n    }\n\n    avctx->channel_layout = avctx->channels == 1 ? AV_CH_LAYOUT_MONO :\n\n                                                   AV_CH_LAYOUT_STEREO;\n\n\n\n    ibps = avctx->bit_rate / (1000 * avctx->channels);\n\n\n\n    if (ibps > 255) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported per channel bitrate %dkbps\\n\", ibps);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((isampf << 8) +  ibps) {\n\n    case (8 <<8) +  8: tctx->mtab = &mode_08_08; break;\n\n    case (11<<8) +  8: tctx->mtab = &mode_11_08; break;\n\n    case (11<<8) + 10: tctx->mtab = &mode_11_10; break;\n\n    case (16<<8) + 16: tctx->mtab = &mode_16_16; break;\n\n    case (22<<8) + 20: tctx->mtab = &mode_22_20; break;\n\n    case (22<<8) + 24: tctx->mtab = &mode_22_24; break;\n\n    case (22<<8) + 32: tctx->mtab = &mode_22_32; break;\n\n    case (44<<8) + 40: tctx->mtab = &mode_44_40; break;\n\n    case (44<<8) + 48: tctx->mtab = &mode_44_48; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"This version does not support %d kHz - %d kbit/s/ch mode.\\n\", isampf, isampf);\n\n        return -1;\n\n    }\n\n\n\n    ff_dsputil_init(&tctx->dsp, avctx);\n\n    avpriv_float_dsp_init(&tctx->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n    if ((ret = init_mdct_win(tctx))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error initializing MDCT\\n\");\n\n        twin_decode_close(avctx);\n\n        return ret;\n\n    }\n\n    init_bitstream_params(tctx);\n\n\n\n    memset_float(tctx->bark_hist[0][0], 0.1, FF_ARRAY_ELEMS(tctx->bark_hist));\n\n\n\n    avcodec_get_frame_defaults(&tctx->frame);\n\n    avctx->coded_frame = &tctx->frame;\n\n\n\n    return 0;\n\n}\n", "idx": 18462, "substitutes": {"avctx": ["akcca", "afcmp", "avecp", "abcca", "afconv", "avcdn", "afcu", "avalcf", "avc", "ajcontext", " avsci", "ablc", "avcmd", " avcn", "avcoll", "avalsys", "avpkg", "AVcmp", "avctrl", " avxc", "abcontext", "vercf", "avekb", "afconfig", "afsync", "afloc", "AVlc", "avecci", " avcmp", "avaldc", "avsync", "ajcn", "navctrl", "afcci", "ajdc", " avlc", "AVctx", "akcoll", " avcontext", "abconf", "avcca", "avectrl", "avecmp", "aveconf", "afcoll", "verclient", "avcomp", "navcontext", "airctx", "avdc", "ajconn", "afcas", "avlc", "akconv", "aveconn", "aucu", "afc", "avecmd", "ajcci", "avecu", "vercas", "AVsci", "avcp", "avalcmd", "auctx", "verconfig", "avsys", "aucontext", "aveconfig", "akcli", "versync", "avalc", "afctrl", "AVloc", " avcas", "AVcca", "avcas", "avalconn", "avcci", "afxc", "navctx", "avecca", "avcmp", "afcf", "ajcu", "avcli", "vercontext", "aveloc", "ajctx", "avconfig", "ajconv", "AVxc", "navconf", "AVpkg", "airlc", "alctx", "avconv", "AVcmd", "avsci", " avpkg", " avcu", "avxc", "aucp", "avclient", "aveclient", "afcca", "akcomp", "afdc", "afsci", "verdc", "avcf", "avconf", "afcp", "navkb", "akcu", "navcp", "avecoll", "avesys", "avloc", "afcomp", "akctx", "AVcontext", "akcn", "avalctx", "afcdn", " avcca", "avepkg", "afpkg", "afsys", "alpkg", "avalcontext", "avectx", "avalctrl", "avedc", "aircu", "avalclient", "verctx", "ajcoll", "ajcomp", "avalcdn", "afcn", "aflc", "alcmp", "avkb", "verpkg", "avcn", "afclient", "aircontext", "navcu", "afcontext", "akcontext", "navcca", "alcontext", "avconn", "afctx", "verxc", "abctx", "abcu", "vercu", "avalsync", "avecontext", "airxc", "avecn", "ajcli", "navcdn", "afconn", "AVconn", "afcli", "aircf", "afkb", "avec", "avcu", "avcontext"], "ret": ["Val", "code", "rc", "nt", "result", " res", "var", "resp", "arr", "val", "Ret", " result", " RET", "no", "id", "RET", "Return", "Num", " rc", "res", " resp", " r", "len"], "tctx": ["tconf", "mconf", "tlc", "mbatch", "tqa", " txc", "tcontext", "trlc", " ttx", "vxc", "trxc", " tbatch", " tqa", "atcmp", "atconn", "attconn", "mtx", "attcmp", "trconf", "trcontext", " tconf", "txc", "atctx", "trctx", "attctx", " tcmp", "trbatch", "trtx", "atcontext", " tcontext", "mlc", "tbatch", "tconn", "trqa", " tconn", "vctx", "attcontext", "vqa", "vcontext", "tcmp", " tlc", "mctx", "mcontext", "ttx"], "isampf": ["issarpl", "isambe", " isapfo", "isampfe", "intarpe", "isamprf", "isppf", "ismpfs", "isumpfs", " isarpsf", "isambfs", "issepF", "issampl", "isampp", "isumpfo", "isaprf", "intarpfs", "issampf", "isarpfor", "isumpp", "isappf", "issarpfe", "isumpe", "isaspf", "hisaspform", "issampv", "ismpf", "ismpfe", " isampc", "isppF", "intampe", "isarpv", "isampfor", "bisapf", "hisampF", "isaspform", "isumpsf", "isepfe", "bisaprf", "isappv", "issepf", "issampfs", "bisampF", "hisampf", "ismpF", "intarpf", "isapc", "isarpfe", " isarpc", "isppform", "isampfs", "isumpfe", "isarpe", "isarpc", "intampfs", "isampfo", "isappfe", "hisaspf", " isampfs", "isumpc", "isumpF", "bisamprf", "isumpf", "isapl", " isarpf", "isarpl", "isampl", "isepf", "issampfe", "intampf", "isaspF", "bisampfor", "isampform", "bisapfor", " isampF", "isapfs", "intampp", "bisampf", "isumprf", "isapsf", "isumpfor", "isampsf", "isampF", "isapfe", " isapfs", "isppfe", "issarpv", "isaspfe", "isarpsf", "isapfor", "isarpp", "bisapF", "hisampform", "isarpfo", "issepfs", "hisampfe", "isepF", "isarpf", " isapc", "isambp", "isapfo", " isampfo", "isampv", " isarpF", "hisaspfe", "intarpp", "isappl", "isapF", "isarpfs", "issarpf", "isampe", "isepfs", "isarpF", "issampF", " isampsf", "hisaspF", "isampc", "isarprf", "isambf", " isapf", "isapf", "isarpform", "isapv", "issepfe"], "ibps": ["ambps", "IBpps", "ambpped", "ambaps", "ibaps", "iwpes", "ibfs", "ibPS", "ibpped", "ubfs", "ubops", "iwps", "ibpps", "ilibps", "ibpes", "habops", "ubpps", "ilibp", "IBops", "obops", "abpes", "obPS", " ibops", "IBfs", "habpes", "obs", "ibp", "abps", "ibpp", "ambpes", "ibops", "obps", "IBPS", "obpes", "ilibpps", " ibpped", "ibs", " ibpes", "iwpped", "habs", "IBps", "obpp", "ebp", "ubps", "ebfs", " ibpps", "ebps", "ebpps", "abops", "obp", " ibaps", "ebops", "ebpp", " ibPS", "habps", "obpps", "iwaps", "ilibpp"]}}
{"project": "FFmpeg", "commit_id": "18ff4d20201ae69fdeb2da2c90bdcbd33f7ac025", "target": 1, "func": "static int copy_chapters(InputFile *ifile, OutputFile *ofile, int copy_metadata)\n\n{\n\n    AVFormatContext *is = ifile->ctx;\n\n    AVFormatContext *os = ofile->ctx;\n\n    int i;\n\n\n\n    for (i = 0; i < is->nb_chapters; i++) {\n\n        AVChapter *in_ch = is->chapters[i], *out_ch;\n\n        int64_t ts_off   = av_rescale_q(ofile->start_time - ifile->ts_offset,\n\n                                       AV_TIME_BASE_Q, in_ch->time_base);\n\n        int64_t rt       = (ofile->recording_time == INT64_MAX) ? INT64_MAX :\n\n                           av_rescale_q(ofile->recording_time, AV_TIME_BASE_Q, in_ch->time_base);\n\n\n\n\n\n        if (in_ch->end < ts_off)\n\n            continue;\n\n        if (rt != INT64_MAX && in_ch->start > rt + ts_off)\n\n            break;\n\n\n\n        out_ch = av_mallocz(sizeof(AVChapter));\n\n        if (!out_ch)\n\n            return AVERROR(ENOMEM);\n\n\n\n        out_ch->id        = in_ch->id;\n\n        out_ch->time_base = in_ch->time_base;\n\n        out_ch->start     = FFMAX(0,  in_ch->start - ts_off);\n\n        out_ch->end       = FFMIN(rt, in_ch->end   - ts_off);\n\n\n\n        if (copy_metadata)\n\n            av_dict_copy(&out_ch->metadata, in_ch->metadata, 0);\n\n\n\n        os->nb_chapters++;\n\n        os->chapters = av_realloc(os->chapters, sizeof(AVChapter) * os->nb_chapters);\n\n        if (!os->chapters)\n\n            return AVERROR(ENOMEM);\n\n        os->chapters[os->nb_chapters - 1] = out_ch;\n\n    }\n\n    return 0;\n\n}\n", "idx": 18474, "substitutes": {"ifile": [" ifle", "OFil", "ifilt", "fil", "IFime", "fetch", "Ifile", "Ifilt", "file", "ifail", " ifime", "afile", "IFile", "afil", "ifle", " ifil", "ifuture", "afime", "IFetch", " ifilt", "ifILE", "future", "ifil", "Ifle", "OFetch", " ifail", "IFail", "IFilt", "OFile", "IFuture", " ifILE", "ifime", "IFle", "OFuture", "IFILE", "afail", "ifetch", "IFil", "IfILE"], "ofile": ["OFil", "alfile", " ofactory", "Ofilt", "offilia", "Offile", "Ofactory", "alfili", "affile", "ofime", "offile", "afile", "ofilia", "afil", "Ofile", "afime", "afili", "ofil", "offil", " ofime", " ofilia", "offactory", "alffile", "alfilt", " ofili", "offime", "OFile", "offilt", "Ofime", "ofili", "ofactory", "OFilia", " offile", "OFime", "ofilt", "alfil", " ofil", "offfile", "alfime"], "copy_metadata": ["copy_adata", " copy_filename", " copy_adata", " copy_meta", "copy__adata", "copy__metadata", "copy__data", "copy_meta", " copy_data", "copy_data", "copy__filename", "copy_filename", "copy__meta"], "is": ["ns", "was", "fr", "s", "sis", "bs", "info", "ot", "image", "so", "op", "ais", "ai", "ar", "has", "isu", "as", "ie", "in", "ii", "ois", "fs", "ris", "cs", "acs", "iso", "are", "iq", "mis", "kit", "obs", "ins", "iss", "id", "bis", "iris", "ics", "isi", "js", "ir", "ri", "p", "ace", "its", "isl", "us", "it", "IS", "isc", "lis", "ib"], "os": ["ns", "oc", "ms", "Os", "org", "ros", "at", "cot", "s", "bs", "ot", "obj", "base", "so", "op", "otes", "net", "io", "oS", "osi", "ou", "mot", "ss", "as", "oper", "ops", "ow", "ori", "pos", "oos", "out", "o", "object", "cs", "css", "iso", "acs", "bos", "oid", "kit", "obs", "los", "ol", "vs", "cat", "js", "ps", "si", "rss", "p", "osc", "ks", "sys", "proc", "et", "boot", "es", "us", "OS", "conn", "ds", "oss"], "i": ["ti", "gi", "uri", "bi", "j", "ami", "info", "x", "ix", "ini", "qi", "r", "ai", "io", "mi", "n", "phi", "hi", "ii", "ie", "iu", "index", "di", "mini", "I", "dim", "multi", "zi", "o", "ip", "chi", "l", "oi", "yi", "pi", "ui", "ci", "id", "start", "k", "e", "v", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "it", "eni", "fi", "y", "li", "u"], "in_ch": ["namexche", "inPcher", "in_ach", "in__cha", "out_cher", "in_char", "line_che", "name_cho", "line_ch", "in1ich", "line_tch", "inxtch", "inqchn", "in1che", "out_che", "name_ch", "out_sch", "inacchn", "inqsch", "in__cht", "inxach", "in_cher", "linektch", "in_ich", "out_chi", "in_ech", "name_ach", "inacch", "in_chn", "inPch", "in_che", "in__che", "out_ech", "out_cha", "inxchip", "inxche", "inPche", "inkchip", "in_cha", "linekche", "out_ich", "out_chn", "linekchip", "inxch", "line_chip", "inPsch", "inPchn", "in_tch", "inacche", "in_sch", "namexch", "inktch", "in1chn", "inxcho", "out_char", "namexach", "in_chip", "inacich", "namexcho", "in1ch", "in_cho", "inkch", "in_cht", "in__ch", "linekch", "inkche", "inPchar", "out_cht", "inqche", "name_che", "inqch", "in_chi"], "out_ch": ["outerch", "outPch", "in_ach", "in_char", "again_chip", "out_Ch", "out_che", "out_sch", "again_sch", "outPche", "out_cur", "outedCh", "in_ich", "in_chan", " out_chan", "outedchip", "in_Ch", "out_chi", "in_chn", "in_che", "out_cha", "out_chart", "outercha", "again_chart", "in_cha", "out_ich", "outxcha", "out_chn", " out_chip", " out_Ch", "out_chip", "in_sch", "outerchar", "outxchan", "out_char", "outedch", "outxCh", "outPcha", "in_cht", "out_ach", "in_cur", "outedchan", "outxch", "again_ch", "outerche", "out_cht", "out_chan", "outPchar", "in_chi"], "nb_chapters": ["nb_chars", "nb_Chants", "nb_anchases", "nb_choapters", "nb_quangers", "nb_hapters", "nb_chases", "nb_Chars", "nb_cheases", "nb_changers", "nb_choors", "nb_shannels", "nb_cheannels", "nb_quapters", "nb_quats", "nb_Channels", "nb_cheangers", "nb_cheisodes", "nb_cheats", "nb_quannels", "nb_choases", "nb_cheors", "nb_anchannels", "nb_hars", "nb_achats", "nb_shapters", "nb_Chapters", "nb_hants", "nb_chatannels", "nb_shants", "nb_chisodes", "nb_chatisodes", "nb_achannels", "nb_hannels", "nb_achangers", "nb_chators", "nb_chors", "nb_chatapters", "nb_achapters", "nb_chats", "nb_anchisodes", "nb_anchapters", "nb_anchors", "nb_choannels", "nb_cheapters", "nb_shars", "nb_channels", "nb_chants"]}}
{"project": "qemu", "commit_id": "ef4c9fc8542e06b1d567172c04b0c0377c7ab0c5", "target": 1, "func": "int trace_record_start(TraceBufferRecord *rec, TraceEventID event, size_t datasize)\n\n{\n\n    unsigned int idx, rec_off, old_idx, new_idx;\n\n    uint32_t rec_len = sizeof(TraceRecord) + datasize;\n\n    uint64_t event_u64 = event;\n\n    uint64_t timestamp_ns = get_clock();\n\n\n\n    do {\n\n        old_idx = g_atomic_int_get(&trace_idx);\n\n        smp_rmb();\n\n        new_idx = old_idx + rec_len;\n\n\n\n        if (new_idx - writeout_idx > TRACE_BUF_LEN) {\n\n            /* Trace Buffer Full, Event dropped ! */\n\n            g_atomic_int_inc(&dropped_events);\n\n            return -ENOSPC;\n\n        }\n\n    } while (!g_atomic_int_compare_and_exchange(&trace_idx, old_idx, new_idx));\n\n\n\n    idx = old_idx % TRACE_BUF_LEN;\n\n\n\n    rec_off = idx;\n\n    rec_off = write_to_buffer(rec_off, &event_u64, sizeof(event_u64));\n\n    rec_off = write_to_buffer(rec_off, &timestamp_ns, sizeof(timestamp_ns));\n\n    rec_off = write_to_buffer(rec_off, &rec_len, sizeof(rec_len));\n\n    rec_off = write_to_buffer(rec_off, &trace_pid, sizeof(trace_pid));\n\n\n\n    rec->tbuf_idx = idx;\n\n    rec->rec_off  = (idx + sizeof(TraceRecord)) % TRACE_BUF_LEN;\n\n    return 0;\n\n}\n", "idx": 18477, "substitutes": {"rec": ["ic", "oc", "record", "data", "irc", "Rec", "ref", "comment", "track", "reg", "rc", "inc", "rel", "exc", "acc", "ctx", "mc", "bb", "abc", "resp", "enc", "exec", "ack", "re", "REC", "change", "pre", "disc", "ac", "con", "prev", "cl", "sync", "cur", "req", "c", "history", "Record", "xml", "ck", "doc", "cache", "win", "ec", "form", "co", "rem"], "event": ["instance", "issue", "record", "time", "data", "view", "x", "name", "image", " record", "attribute", " exception", "exc", "document", "type", "package", "ception", "index", "date", "object", "Event", "ce", " Event", "ev", "id", "received", "handler", "update", "xml", "vent", "address", "events", "resource", "error", "row", "ace", "message", "command", "value", "source", "input"], "datasize": ["datalsize", "datacsize", "datASIZE", " datasIZE", "datatsite", "datasizing", " datacsize", "datasiz", "datacize", " datacize", "datasesize", "datarssize", "datalsiz", "datarsite", "datasesizes", "datasizes", "datasIZE", " datasizes", " datasiz", "datacite", "datatssize", "datacizing", " datacite", "datalsizes", " datasizing", "datASizes", "datasesIZE", "datatsizing", " datASizes", "datassize", " datASIZE", "datalsIZE", " datacizing", "datarsizing", "datatsize", "datarsize", "datasite", "datASize", " datASiz", "datASiz", " datassize", " datASize", " datasite", "datasesiz"], "idx": ["idxc", "indxc", "Idc", "inX", "idexc", "idX", "idxp", " idxc", "Idz", "indX", "idz", "inxc", "idex", "idc", "IDf", "sidX", "idec", " idc", "Idxp", " idz", "Idf", "Idx", "sidxc", "idf", "inx", "sidxs", " idX", "Idxs", "IDz", "IdX", "IDx", "sidx", "IDxc", "inxs", "ideX", " idxp", "indxp", "indx", "idxs", "Idxc", " idxs", " idf"], "rec_off": ["rec_len", " rec_offer", " rec_wo", "RECdover", "recPover", "rec2offs", "rec___offs", " rec_offs", "rec_num", "rec8offer", "rec__off", "rec_offset", "rec_OFF", "Rec_offer", "recfend", " rec_oa", "rec_online", "rec_end", "rec8off", "recFoffs", "rec8offs", "recfoffer", "record_on", "REC_offer", "rec__OFF", "Rec_on", "recdoffer", "recdOff", "receroffs", "Rec_off", "rec_offer", "receronline", "Rec_len", "rec8offset", "rec_none", "rec2len", "record_offs", "rec_output", " rec_end", "Rec_OFF", "rec8Off", "rec___num", " rec_len", "rec2off", "rec_on", "rec8len", "rec__len", "REC_over", "Rec_none", " rec_num", "RECdoff", "record_off", "recdover", "REC_Off", "RECdoffer", "recdoff", "recFoutput", "recFon", "record_len", "rec___off", "recfoff", "rec8on", "rec_oa", "recPoffer", "rec2OFF", "Rec_online", "receroff", " rec_online", "record_OFF", "RECdOff", "REC_off", "recfonline", "Rec_Off", "rec___oa", "rec_over", "recFoff", "recPOff", "record_output", "rec_offs", "rec_wo", "recPoff", "Rec_offset", "Rec_offs", "recernone", "rec__offs", "rec_Off"], "old_idx": ["old_itc", "old_idex", "old_idg", "old_idz", "old_endxs", "old_idux", "old_videx", "old_vidxc", "old_idn", "old_indy", "old_idxx", "old_idexx", "old_ridx", "old_Idux", "old_idy", "old_idc", "old_iden", "old_endg", "old_Idz", "old_vidxi", "old_vidz", "old_Idx", "old_itex", "old_idexe", "old_itg", "old_index", "old_ridxx", "old_idxi", "old_endc", "old_indxe", "old_vidx", "old_Idxc", "old_indxx", "old_indx", "old_vidy", "old_ridn", "old_ridz", "old_indxs", "old_indg", "old_vidxx", "old_idxc", "old_itexc", "old_itx", "old_idxe", "old_endx", "old_indc", "old_indn", "old_itxs", "old_idxs", "old_iteux", "old_itez", "old_indxi", "old_ridxc", "old_ridxe"], "new_idx": ["new_ipz", "new_idv", "new_aidn", "new_pidx", "new_aidx", "new_indv", "new_idX", "new_pidz", "new_intx", "new_intn", "new_indX", "new_Idy", "new_ipw", "new_ipy", "new_Idn", "new_idxc", "new_Idv", "new_inty", "new_Idw", "new_idpx", "new_IdX", "new_idw", "new_indz", "new_indx", "new_idn", "new_intpx", "new_pidy", "new_Idpx", "new_Idxc", "new_ipx", "new_Idx", "new_idz", "new_pidxc", "new_Idz", "new_idy", "new_aidy", "new_aidpx"]}}
{"project": "qemu", "commit_id": "e6afc87f804abee7d0479be5e8e31c56d885fafb", "target": 1, "func": "static float64 roundAndPackFloat64( flag zSign, int16 zExp, uint64_t zSig STATUS_PARAM)\n\n{\n\n    int8 roundingMode;\n\n    flag roundNearestEven;\n\n    int16 roundIncrement, roundBits;\n\n    flag isTiny;\n\n\n\n    roundingMode = STATUS(float_rounding_mode);\n\n    roundNearestEven = ( roundingMode == float_round_nearest_even );\n\n    roundIncrement = 0x200;\n\n    if ( ! roundNearestEven ) {\n\n        if ( roundingMode == float_round_to_zero ) {\n\n            roundIncrement = 0;\n\n        }\n\n        else {\n\n            roundIncrement = 0x3FF;\n\n            if ( zSign ) {\n\n                if ( roundingMode == float_round_up ) roundIncrement = 0;\n\n            }\n\n            else {\n\n                if ( roundingMode == float_round_down ) roundIncrement = 0;\n\n            }\n\n        }\n\n    }\n\n    roundBits = zSig & 0x3FF;\n\n    if ( 0x7FD <= (uint16_t) zExp ) {\n\n        if (    ( 0x7FD < zExp )\n\n             || (    ( zExp == 0x7FD )\n\n                  && ( (int64_t) ( zSig + roundIncrement ) < 0 ) )\n\n           ) {\n\n            float_raise( float_flag_overflow | float_flag_inexact STATUS_VAR);\n\n            return packFloat64( zSign, 0x7FF, - ( roundIncrement == 0 ));\n\n        }\n\n        if ( zExp < 0 ) {\n\n            if ( STATUS(flush_to_zero) ) return packFloat64( zSign, 0, 0 );\n\n            isTiny =\n\n                   ( STATUS(float_detect_tininess) == float_tininess_before_rounding )\n\n                || ( zExp < -1 )\n\n                || ( zSig + roundIncrement < LIT64( 0x8000000000000000 ) );\n\n            shift64RightJamming( zSig, - zExp, &zSig );\n\n            zExp = 0;\n\n            roundBits = zSig & 0x3FF;\n\n            if ( isTiny && roundBits ) float_raise( float_flag_underflow STATUS_VAR);\n\n        }\n\n    }\n\n    if ( roundBits ) STATUS(float_exception_flags) |= float_flag_inexact;\n\n    zSig = ( zSig + roundIncrement )>>10;\n\n    zSig &= ~ ( ( ( roundBits ^ 0x200 ) == 0 ) & roundNearestEven );\n\n    if ( zSig == 0 ) zExp = 0;\n\n    return packFloat64( zSign, zExp, zSig );\n\n\n\n}\n", "idx": 18493, "substitutes": {"zSign": ["zenStep", "zenSign", "zBig", "ZDig", "xSpec", "tzExp", "zoExp", "xSign", "tzSize", "xSk", "zenBig", "xSc", "zoneReg", "zoRound", "jBig", "zenReg", "zSc", "xReg", " zStep", "zoneSc", "zoneSk", "jSc", "zReg", "zenSc", "zStep", "zRound", " zDig", "zSpec", "zSize", "zenSize", "zoneSign", "zoSign", "zoDig", " zSize", "ZRound", "zenSk", "zDig", " zRound", "zSk", "jSpec", "jSign", "tzSign", "zenExp", "tzStep", "zenSpec", "ZSign", "xBig", "ZExp"], "zExp": ["zhEx", "zExec", "zexp", "zhEXP", " zExec", " zPos", "izStep", "ZEnd", "izDiv", "ziDiv", " zEnc", "Zexp", "zipRes", "zenEnd", "izExpl", "zLeg", "wEXP", "zEXP", "izImp", "zipSec", "zhExp", "zSc", "zeExp", " zStep", "zEx", "zeScale", "izRes", "izEx", "zenScale", "ziExp", " zSc", " zFe", "zhSec", "izPlus", "zEnc", "izEnc", "wexp", "ziEnc", "zhInc", "zhExpl", "zPlus", "zenPlus", "zeSec", "zenImp", " zEnd", "ziEx", "zhPos", " zLeg", "zhPlus", "zhSc", "zenEm", "zipExp", "zDiv", " zSec", "zPos", "zSec", " zEm", "zipInc", "izExp", "zenFe", "zhRes", "wExp", "wPos", "izInc", "zenExp", "zEnd", "zhexp", "zEm", "zhStep", "ZExp", "zenEx", " zScale", "izSec", "zhExec", " zDiv", "zScale", "ZEm", " zexp", "zeFe", "zenSc", " zEx", "zStep", "zenExec", "zExpl", "zenSec", "zenExpl", "zenexp", "zInc", "zImp", "zFe", "izLeg", " zEXP", "zhImp", "zhLeg", "zRes"], "STATUS_PARAM": ["STATUS_ARAME", "STATUS_PAR", "STATUS_PARAR", "STATUS_PARAME", "STATUS_VAR", "STATUS_PARAMS", "STATUS_VAME", "STATUS_PAME", "STATUS_VAM", "STATUS_VAMS", "STATUS_ARAR", "STATUS_PAM", "STATUS_ARAMS", "STATUS_ARAM", "STATUS_PAMS"], "roundingMode": ["boundlingOperation", "roundgingMethod", "boundingModule", "accountdingMode", "pooleringMODE", "callningModule", "tungingMode", "boundlingMode", "roundeningKind", "rounddingMODE", "tungingMethod", "roundeningModule", "accountingConfiguration", "pooleringMac", "boundingKind", "roundeningMode", "boundingEngine", "roundationMode", "rounddingStyle", "tuningStyle", "roundingEngine", "tuningMethod", "poolingMac", "poolingMODE", "boundingMODE", "roundationEngine", "boundeningMODE", "rounderingMac", "accountdingEngine", "poolingMode", "callningMode", "roundgingModule", "roundpingMethod", "roundeningStyle", "roundningOperation", "tuningMODE", "roundpingStyle", "accountingEngine", "roundeningEngine", "roundingMac", "pooleringMode", "roundlingOperation", "roundlingKind", "callingModule", "roundingModule", "accountdingConfiguration", "tungingMODE", "rounddingMode", "roundtingMac", "boundingMode", "roundgingMODE", "roundlingMode", "roundlingModule", "boundlingModule", "roundpingMODE", "roundningMode", "boundingOperation", "roundingMODE", "tuningMode", "roundingOperation", "roundgingStyle", "rounddingMethod", "rounderingMode", "roundpingMode", "callingMODE", "roundgingMac", "roundeningMODE", "roundningMODE", "roundingMethod", "roundningEngine", "roundtingMode", "roundingKind", "roundningKind", "roundingConfiguration", "roundingStyle", "roundationConfiguration", "roundtingMODE", "rounddingEngine", "callningMODE", "roundgingConfiguration", "roundningStyle", "boundingStyle", "boundlingKind", "rounderingMODE", "roundgingEngine", "boundeningStyle", "roundningModule", "rounddingConfiguration", "roundeningOperation", "roundgingMode", "boundeningMode", "callingMode", "tungingStyle", "boundeningEngine", "accountingMode"], "roundNearestEven": ["roundNelderEven", "roundNearesteven", "roundnearestOne", "roundNutraleven", "roundNearerEven", "roundNeestEven", "roundNehestEven", "roundNearestHalf", "roundneestHalf", "roundNeuristicEven", "roundNeestOne", "roundNeutralEven", "roundnearestHalf", "roundNearestEnd", "roundNaresteven", "roundNutralEven", "roundNeuristicEnd", "roundNeldereven", "roundNeutraleven", "roundNearereven", "roundneestOne", "roundNehestOne", "roundNarestEven", "roundneestEven", "roundNeutralOne", "roundNelderEnd", "roundNearestOne", "roundNeestHalf", "roundNeutralHalf", "roundNehestHalf", "roundNeuristiceven", "roundNehesteven", "roundnearestEven", "roundNeesteven", "roundnearesteven", "roundneesteven", "roundNeutralEnd"], "roundIncrement": ["roundInterment", "roughIncrelex", "rollDecreMENT", "rollIncreution", "rowSegmentation", "roundIncreasemental", "roundDecreral", "roughIncrements", " roundIncrementation", "rowIncrementation", "rowIncreration", "roundIncreral", "roundIncreasemented", "roundincrese", "Roundincremented", "roundFragmentation", "roundSegments", "roundAugse", "roundAdjustment", "roundAdjustral", "roundIncreration", "roundDecrement", " roundIncreasement", "roundIncreaseMENT", "rollDecreution", "rolln", "roundIncrementation", " roundn", " roundIncregment", "roundincremented", "roundincrementation", "roundDecregment", "rollDecremented", "roundIntermentation", "rowIncrements", "roundincrements", "roughIncreral", "rollIncrementation", "rollIncremented", "Roundincrements", "rollIncrement", "roundIncremental", "rollDecrese", " roundIncreasementation", "roundAugution", "roundDecremented", "Roundincrement", "RoundIncreMENT", "roundFragmented", "roughMeasurements", "roundincrereement", "roughMeasureral", "rowSegreement", "rollIncrese", "roundincreMENT", " roundIncremented", "roughMeasurement", "roundAdjustments", "rowIncrement", "roundIncreasese", "roundDecrese", "roundInterration", "RoundincreMENT", "rowInterration", "roundDecrelex", "roundInterution", " round\n", "rollIncreMENT", "roundIncreasement", "roundFragmental", "rowSegment", "roundIncreant", "rowIntermentation", "roundIncremented", "roundSegmental", "RoundIncremented", "roundincreant", "roundDecrementation", "roundAugmentation", " roundIncreasegment", "roundIncreasementation", "roundIncrements", "roundFragment", "roundincrement", "roundIncreution", "roundIncregment", "roundDecreMENT", "rowInterant", " roundIncremental", "roundMeasurelex", "roughIncrement", "roundIncreasegment", "roundAdjustlex", " roundIncreasemented", "rowIncrereement", "roundAugment", "roundDecrereement", "round\n", "roll\n", "roundSegmentation", "roundIncrereement", "roundincreration", "rollDecrement", "roundMeasurements", " roundIncreasese", "roundSegMENT", "roundAugMENT", "rowInterment", "roundn", "roundSegreement", "roundMeasurement", "row\n", "RoundIncrement", "rowSegments", "roundInterant", "roundAugmented", "roundAuggment", "rown", " roundIncrese", "roundIncreaseration", "roundIncreaseution", " roundIncreasemental", "roundDecrements", "roundSegment", "roughMeasurelex", "rowIncreant", "roundDecreution", "roundMeasureral", "RoundIncrements", "roundIntermented", "rollDecrementation", "roundIncrelex", "roundIncreMENT", "roundIncreaseant", "roundSegmented", "roundIncrese", "roundFragse"], "roundBits": ["roundKites", " roundBBizes", "roundClbits", "roundBsit", "sortBBith", "roundBBbits", "roundBandits", "roundWbits", "roundKatches", "rowBITS", "sortBith", "roundPITS", "roundBsugs", "roundRits", " roundBandITS", " roundBandits", "roundBandbits", "roundFit", " roundBbits", "rowbugs", " roundBites", " roundBit", "roundFits", "roundBandit", "roundRit", "roundPuts", " roundBBits", "roundWits", "rowBit", "sortBBits", "roundKits", "roundBsits", "roundBBith", "roundFITS", "roundRounds", "roundbit", "rowbit", " roundBBites", "sortBITS", "roundPbits", "roundBatches", "roundBugs", "roundBites", "roundKizes", "roundFuts", "sortBits", "roundBBatches", " roundBanduts", "roundBandITS", "roundbITS", "roundClits", "roundBbits", "roundBit", "roundBBites", "roundBsITS", "sortBbits", " roundBBatches", "roundbugs", "roundFbits", "roundClITS", "roundSBizes", "roundPits", "roundbits", "roundSBatches", "rowBugs", "roundBBITS", "roundBBizes", "roundSBits", "roundButs", " roundBatches", "roundRITS", "roundClith", "roundBith", "rowBits", "roundFounds", " roundBounds", "roundBITS", "sortBBbits", " roundBandbits", "roundSBites", "roundWITS", "rowbITS", " roundBITS", "roundWith", "rowbits", " roundBizes", "roundBandugs", "roundBizes", "roundBounds", "roundBBits", " roundButs", "sortBBITS", "roundBanduts"], "isTiny": ["IsNotiny", "isPig", "isTunky", "isWiny", "IsTidy", "isTwick", "isNiny", "isPng", "isTwig", " isTunky", "isTick", " isPiny", "isTidy", "isPiger", "isTiger", "isTng", "isDidy", " isTick", " isTig", "isPunky", "isWunky", " isTng", "isNig", "isDiger", " isPig", "isTwiny", "isTwunky", "isPiny", "isDick", "isNotiny", "isTig", " isPick", "isDiny", "IsTiny", "isPick", "isPidy", "IsTiger", "isNotiger", "isNng", "isNick", "isWick", "IsNotiger", "IsNotick", "IsNotidy", "isNotick", "isNotidy", " isPunky", "isWig", "IsTick"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void xen_remap_bucket(MapCacheEntry *entry,\n\n                             hwaddr size,\n\n                             hwaddr address_index)\n\n{\n\n    uint8_t *vaddr_base;\n\n    xen_pfn_t *pfns;\n\n    int *err;\n\n    unsigned int i;\n\n    hwaddr nb_pfn = size >> XC_PAGE_SHIFT;\n\n\n\n    trace_xen_remap_bucket(address_index);\n\n\n\n    pfns = g_malloc0(nb_pfn * sizeof (xen_pfn_t));\n\n    err = g_malloc0(nb_pfn * sizeof (int));\n\n\n\n    if (entry->vaddr_base != NULL) {\n\n        if (munmap(entry->vaddr_base, entry->size) != 0) {\n\n            perror(\"unmap fails\");\n\n            exit(-1);\n\n        }\n\n    }\n\n    g_free(entry->valid_mapping);\n\n    entry->valid_mapping = NULL;\n\n\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        pfns[i] = (address_index << (MCACHE_BUCKET_SHIFT-XC_PAGE_SHIFT)) + i;\n\n    }\n\n\n\n    vaddr_base = xc_map_foreign_bulk(xen_xc, xen_domid, PROT_READ|PROT_WRITE,\n\n                                     pfns, err, nb_pfn);\n\n    if (vaddr_base == NULL) {\n\n        perror(\"xc_map_foreign_bulk\");\n\n        exit(-1);\n\n    }\n\n\n\n    entry->vaddr_base = vaddr_base;\n\n    entry->paddr_index = address_index;\n\n    entry->size = size;\n\n    entry->valid_mapping = (unsigned long *) g_malloc0(sizeof(unsigned long) *\n\n            BITS_TO_LONGS(size >> XC_PAGE_SHIFT));\n\n\n\n    bitmap_zero(entry->valid_mapping, nb_pfn);\n\n    for (i = 0; i < nb_pfn; i++) {\n\n        if (!err[i]) {\n\n            bitmap_set(entry->valid_mapping, i, 1);\n\n        }\n\n    }\n\n\n\n    g_free(pfns);\n\n    g_free(err);\n\n}\n", "idx": 18512, "substitutes": {"entry": ["extra", "element", "comment", "service", "inc", "package", "ie", "enc", "import", "comp", "config", "end", "it", "command", "source", "reader", "plugin", " Entry", "archive", "name", "engine", "ge", "entity", "existing", "parse", "the", "Entry", "key", "update", "lc", "cat", "si", "table", "item", "cell", "row", "export", "connection", "ent", "view", "image", "component", "try", "match", "ry", "ae", "post", "address", "lock", "ace", "session", "record", "data", "info", "feed", "option", "enter", "module", "index", "member", "get", "parser", "ce", "event", "cel", "add", "e", "ries", "cur", "insert", "cache", "error", "server", "se", "inner"], "size": ["set", "offset", "file", "num", "six", "max", "strength", "sec", "empty", "location", "sh", "new", "path", "large", "length", "send", "external", "bytes", "Size", "len", "scale", "content", "name", "handle", "engine", "from", "cm", "timeout", "count", "si", "shift", "gz", "weight", "code", "time", "core", "SIZE", "sized", "block", "loc", "speed", "memory", "sn", "ize", "security", "sync", "c", "address", "fee", "sum", "s", "small", "capacity", "data", "mode", "shape", "gc", "password", "member", "ui", "use", "limit", "e", "unit", "cache", "storage", "number", "body"], "address_index": ["address_ind", "ip_id", "position_index", "address_length", "address2index", " address_position", " address_address", "address2Index", "ip__slice", "address__id", "address2prefix", "address__address", "address__slice", " address_length", "address__index", " address_ind", "position2index", "address_Index", "position_offset", "position_prefix", "address_start", "address_position", "address2id", "address__ind", " address_slice", "address_offset", "address__list", "address_slice", "address_prefix", "address_list", "address2offset", "ip_start", "ip_slice", "ip__start", "position2prefix", "position2offset", "address_id", " address_list", "position2Index", "ip__id", "address2slice", "ip__index", "address2start", "address__start", "ip_index", "address_address", "position_Index"], "vaddr_base": ["vaddr2area", "vsp_base", "vsp__count", "vaddr__count", "vattr_bas", "vaddr_bas", "vsp__base", "vaddr2Base", "vdr_index", "vaddr_area", "vaddr_bi", "vaddr2cache", "vaddr_prefix", "vaddr2base", "vaddr_address", "vsp_Base", "vrt_bas", "vaddress_bas", "vaddress_home", "vad_full", "vattr_full", "vaddr_cache", "vaddr_count", "vaddr_home", "vaddress_base", "vdr_base", "vsp__len", "vad_base", "vaddr_based", "vad_Base", "vattr_address", "vaddr__len", "vrt_base", "vdr_prefix", "vdr_bas", "vsp_count", "vrt_area", "vaddr_len", "vaddr_full", "vaddr_index", "vsp__Base", "vaddress_based", "vsp_len", "vaddr__base", "vad_bi", "vaddr_Base", "vaddr__Base", "vattr_base"], "pfns": ["pcfails", "pafns", "pfxks", "vfks", "Pfails", "pfks", "pdfts", "pffs", "pdfns", "Pfks", "psfirs", "pfcns", "pofls", "pfcnc", "pfnes", "pfn", "pcfks", "psfns", "pfsails", "pafnc", "pcfls", "poffs", "pfsbs", "pdfls", "psfnes", "pdfnc", "Pcfails", "pcfnc", "pcfbs", "pfdls", "pfls", "Pfbs", "vfns", "pfbs", "prefks", "pofns", "Pcfns", "pfdks", " pdefnc", " pfls", "pdefls", "prefns", "pofks", "tfcn", "pfxns", "pcfns", "tfcns", "pfdfs", "pfcls", " pdefns", "pofbs", "tfls", "Pcffs", "pafn", "pfcn", "pfnc", "pfxnes", "tfnc", " pfts", "tfn", "tfns", "Pcfbs", " pdefts", "vfnes", "pcffs", "pcfn", " pdefls", "Pfns", "pfsls", "vfxns", "Pcfls", "pdefns", "pfxirs", "psfks", "prefirs", "pfirs", "tfcnc", "vfxks", "prefnes", "vfirs", " pfnc", "pdefts", "pfdns", "pfails", "vfxirs", "pfsns", "pafls", "Pcfks", "pcfts", "tfcls", "Pffs", "pdefnc", "Pfls", "vfxnes", "pofails", "pfts"], "err": ["status", "rr", "ner", "rage", "fr", "ch", "conf", "f", "eor", "runner", "sp", "ini", "rc", "r", "inc", "phi", "result", "ar", "str", "late", "ok", "cb", "icer", "nor", "arm", "rh", "loc", "msg", "finder", "ind", "der", "ise", "resp", "arr", "fer", "gr", "bug", "nr", "aster", "order", "mr", "rar", "aa", "rn", "ler", "dr", "lr", "acer", "req", "erg", "yr", "ir", "p", "test", "Error", "error", "Er", "res", "er", "errors", "iter", "fi", "inner", "attr", "len"], "i": ["uri", "gi", "ti", "m", "bi", "ei", "init", "j", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "io", "mi", "n", "phi", "ai", "hi", "z", "ii", "in", "ie", "di", "iu", "index", "ori", "I", "mini", "multi", "zi", "o", "ip", "chi", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "start", "e", "v", "c", "ni", "si", "ri", "p", "xi", "b", "mu", "u", "a", "it", "eni", "fi", "inner", "y", "li", "len"]}}
{"project": "qemu", "commit_id": "5ac2731cf821a7ecae90786d9052891afb09dfc2", "target": 1, "func": "void usb_packet_complete(USBDevice *dev, USBPacket *p)\n\n{\n\n    USBEndpoint *ep = p->ep;\n\n    int ret;\n\n\n\n    assert(p->state == USB_PACKET_ASYNC);\n\n    assert(QTAILQ_FIRST(&ep->queue) == p);\n\n    usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n    QTAILQ_REMOVE(&ep->queue, p, queue);\n\n    dev->port->ops->complete(dev->port, p);\n\n\n\n    while (!QTAILQ_EMPTY(&ep->queue)) {\n\n        p = QTAILQ_FIRST(&ep->queue);\n\n        if (p->state == USB_PACKET_ASYNC) {\n\n            break;\n\n        }\n\n        assert(p->state == USB_PACKET_QUEUED);\n\n        ret = usb_process_one(p);\n\n        if (ret == USB_RET_ASYNC) {\n\n            usb_packet_set_state(p, USB_PACKET_ASYNC);\n\n            break;\n\n        }\n\n        p->result = ret;\n\n        usb_packet_set_state(p, USB_PACKET_COMPLETE);\n\n        QTAILQ_REMOVE(&ep->queue, p, queue);\n\n        dev->port->ops->complete(dev->port, p);\n\n    }\n\n}\n", "idx": 18513, "substitutes": {"dev": ["plugin", "grad", "Dev", "dd", "dn", "ch", "data", "dep", "user", "conf", "info", "f", "md", "ver", "debug", "de", "pack", "current", "block", "app", "package", "var", "raw", "di", "this", "def", "prom", "self", "development", "sd", "dp", "home", "d", "pp", "av", "w", "ev", "dm", "config", "img", "v", "device", "cmd", "driver", "plug", "test", "b", "dist", "error", "dem", "priv", "pro", "local", "pu", "valid", "server", "end", "diff", "conn", "ds", "bug"], "p": ["pc", "process", "wp", "part", "m", "point", "per", "plugin", "s", "j", "pid", "t", "fp", "f", "jp", "op", "sp", "vp", "pe", "n", "pl", "pm", "g", "bp", "i", "app", "cp", "lp", "pb", "ap", "parser", "o", "ip", "po", "pg", "l", "dp", "d", "gp", "pp", "pre", "pi", "w", "queue", "pipe", "e", "pa", "cop", "q", "v", "client", "c", "ps", "post", "patch", "mp", "b", "pr", "param", "er", "api", "a", "tp", "py", "port", "np", "press", "P", "u"], "ep": ["pc", "wp", "org", "point", "eg", "eb", "esp", "fp", "ah", "eff", "jp", "element", "op", "sp", "ng", "ek", "vp", "pe", "elf", "inc", "job", "channel", "app", "cp", "loc", "lp", "Ep", "ext", "ap", "ee", "eng", "ew", "ip", "dp", "xp", "enc", "sk", "exec", "gp", "pp", "ev", "pipe", "queue", "e", "ak", "EP", "imp", "kg", "mp", "ec", "ef", "er", "peer", "tp", "yp", "el", "env", "eps", "P", "amp"], "ret": ["html", "code", "f", "ref", "alt", "reg", "nt", "lit", "rt", "fun", "hash", "result", "rc", "r", "sb", "mem", "resp", "rets", "en", "arg", "att", "val", "re", "Ret", "bf", " RET", "xt", "det", "sr", "bot", "rev", "cat", " Ret", "ur", "repl", "RET", "pat", "ben", "rep", "res", "pet", "mer", "fire", "mt", "ft", "reply", "pt", "success", "len"]}}
{"project": "FFmpeg", "commit_id": "64e105e051ca3e5088b0db64551244482b2836b4", "target": 0, "func": "static void dyn_buf_write(void *opaque, UINT8 *buf, int buf_size)\n\n{\n\n    DynBuffer *d = opaque;\n\n    int new_size, new_allocated_size;\n\n    UINT8 *new_buffer;\n\n    \n\n    /* reallocate buffer if needed */\n\n    new_size = d->pos + buf_size;\n\n    new_allocated_size = d->allocated_size;\n\n    while (new_size > new_allocated_size) {\n\n        if (!new_allocated_size)\n\n            new_allocated_size = new_size;\n\n        else\n\n            new_allocated_size = (new_allocated_size * 3) / 2;\n\n    }\n\n    \n\n    if (new_allocated_size > d->allocated_size) {\n\n        new_buffer = av_malloc(new_allocated_size);\n\n        if (!new_buffer)\n\n            return;\n\n        memcpy(new_buffer, d->buffer, d->size);\n\n        av_free(d->buffer);\n\n        d->buffer = new_buffer;\n\n        d->allocated_size = new_allocated_size;\n\n    }\n\n    memcpy(d->buffer + d->pos, buf, buf_size);\n\n    d->pos = new_size;\n\n    if (d->pos > d->size)\n\n        d->size = d->pos;\n\n}\n", "idx": 18518, "substitutes": {"opaque": ["opga", "operacity", "apacity", "apga", "OPec", "ospec", "opec", "opusaques", "operec", "opacity", "opusga", "operaque", "ospacity", "operga", "ospca", "opca", "operca", "opusaque", "OPaque", "OPacity", "OPca", "opaques", "ospaque", "operaques", "opusacity", "apaques", "apaque"], "buf": ["offset", "pub", "f", "buffer", "rc", "vec", "num", "window", "cb", "bc", "src", "loc", "wb", "ctx", "pb", "pos", "xff", "gb", "header", "array", "bf", "img", "queue", "fd", "buff", "fb", "v", "map", "c", "rb", "seq", "cmd", "uc", "b", "alloc", "uf", "cv"], "buf_size": ["grab_loc", "grabkSIZE", "grabkloc", "bufksize", "uf_num", "buf64name", "buflexsized", "buf2size", "buf64large", "uf_large", "bufkloc", "buflexSize", "exclexlarge", "exc_sized", "exclexsized", "bufksized", "buf_num", "exclexSize", "buf_large", "buf_Size", "buf_SIZE", "uf_size", "buflexsize", "buf2loc", "buf2sized", "bufkSIZE", "exc_size", "exclexsize", "buf2SIZE", "buf_loc", "grab_SIZE", "buflexlarge", "buf64size", "uf_name", "grab_sized", "grab_size", "buf64num", "exc_large", "grabksize", "buf_sized", "grabksized", "exc_Size", "buf_name"], "d": ["dc", "plugin", "m", "dn", "dd", "db", "s", "j", "t", "data", "gd", "x", "f", "nd", "td", "md", "r", "n", "pd", "dh", "dos", "g", "i", "z", "vd", "dt", "di", "ld", "dl", "wd", "done", "self", "sd", "dp", "l", "old", "new", "did", "defined", "ed", "w", "bd", "ad", "dm", "e", "fd", "dr", "mad", "id", "v", "xd", "c", "dom", "D", "ded", "p", "del", "da", "ud", "b", "od", "dat", "cd", "end", "dad", "diff", "ds", "u"], "new_size": ["fresh___timeout", "new5sum", "uniquelexsize", "uniquelexchannel", " new_shape", "uniquelexshape", "newlexscale", "fresh_sized", "fresh___ize", "new_location", "newWorklocation", "new67size", "new67ize", "new___size", "new___timeout", "new53size", "new_sum", "newlexlocation", "newworkshape", "newlexshape", "new5shape", "newlsize", "newlposition", "newworkchannel", "new5ize", " new_scale", "newlwidth", "uniquelexlocation", "fresh_ize", "next_position", "new53loc", "newlloc", "new67shape", "large_shape", "new_loc", "newWorksize", "large_ize", "newlexsize", "unique_location", "new___ize", "new_position", "unique_shape", "new53scale", "fresh___size", "newWorkshape", "next_width", "next_size", "unique_size", "next_loc", "large_size", "new_scale", " new_loc", "new_ize", "newlexchannel", "fresh_timeout", "new53shape", "newworksize", "fresh_size", "newlexloc", "new_sized", "new5size", "large_sum", "fresh___sized", "newWorkchannel", "new___sized", "new_channel", "new_shape", "newworklocation", "new_width", "unique_channel", "new_timeout", "new67sum"], "new_allocated_size": ["new_allocation_name", "new_alloc_size", "new_allocatedssize", "new_allocation_line", "new_allocatedacsize", "new_allocatedallcapacity", "new_allocatedalsize", "new_allocatedxsize", "new_allocation_cap", "new_allocation_size", "new_allocatedityscale", "new_allocated_capacity", "new_allocation_needed", "new_alloc_address", "new_allocatedlexize", "new_allocation_ize", "new_allowed_count", "new_allocated_count", "new_allocation_sized", "new_allocation_scale", "new_allowed_size", "new_allocatedacize", "new_allocated_eni", "new_allowed_capacity", "new_allocated_ize", "new_allocated_offset", "new_allocatedxsized", "new_allocated_address", "new_allocatedityunit", "new_allocatedallsize", "new_allocatedlexoffset", "new_allocatedablesize", "new_allocated_unit", "new_allocatedallcap", "new_allowed_address", "new_allocated_length", "new_allocated_scale", "new_allocated_needed", "new_allocatedalname", "new_allocatedablecapacity", "new_allocation_unit", "new_alloc_capacity", "new_allocated_name", "new_allocation_offset", "new_allocatedlexsize", "new_allocation_capacity", "new_allocated_line", "new_allocatedableaddress", "new_alloc_scale", "new_allocation_eni", "new_allocatedacline", "new_allocation_length", "new_allocated_sized", "new_allocated_cap", "new_allocatedablecount", "new_allocatedsline", "new_allocatedsize", "new_allocateditysize", "new_allocatedxneeded", "new_allocation_address", "new_allocatedaleni"], "new_buffer": ["newJcapacity", " new_byte", "newthebuffer", "newworksurface", " new_position", "new__size", "new64size", "newlexbuffer", "new___extra", "newlexdevice", "new__position", " new_buff", "old_device", "new___size", "newtheslice", "new_capacity", "new_device", "old_size", "new_slice", "new___buff", "newworkslice", "newworkbuffer", "newJbuffer", "newlexbuff", "new___buffer", "new_buff", "newJsize", "newlexsize", "new__byte", "new_position", "old_buff", "new64buffer", "newthesurface", "newthesize", "new_extra", "old_buffer", "newworksize", "new_byte", " new_capacity", "newJslice", " new_extra", "new_surface", "new64slice", " new_surface", "new64capacity", " new_slice", "new__buffer"]}}
{"project": "FFmpeg", "commit_id": "20da77449d4427a7152b80e4f9acce6a8c93ee7d", "target": 0, "func": "static inline int RENAME(yuv420_rgb24)(SwsContext *c, uint8_t* src[], int srcStride[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dst[], int dstStride[]){\n\n    int y, h_size;\n\n\n\n    if(c->srcFormat == PIX_FMT_YUV422P){\n\n\tsrcStride[1] *= 2;\n\n\tsrcStride[2] *= 2;\n\n    }\n\n\n\n    h_size= (c->dstW+7)&~7;\n\n    if(h_size*3 > dstStride[0]) h_size-=8;\n\n    \n\n    __asm__ __volatile__ (\"pxor %mm4, %mm4;\" /* zero mm4 */ );\n\n\n\n    for (y= 0; y<srcSliceH; y++ ) {\n\n\tuint8_t *_image = dst[0] + (y+srcSliceY)*dstStride[0];\n\n\tuint8_t *_py = src[0] + y*srcStride[0];\n\n\tuint8_t *_pu = src[1] + (y>>1)*srcStride[1];\n\n\tuint8_t *_pv = src[2] + (y>>1)*srcStride[2];\n\n\tlong index= -h_size/2;\n\n\n\n\t    /* this mmx assembly code deals with SINGLE scan line at a time, it convert 8\n\n\t       pixels in each iteration */\n\n\t    __asm__ __volatile__ (\n\n\t/* load data for start of next scan line */\n\n\t\t     \"movd (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\t\t     \"movd (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t     \"movq (%5, %0, 2), %%mm6;\" /* Load 8  Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n//\t\t    \".balign 16\t\t\t\\n\\t\"\n\n\t\t    \"1:\t\t\t\t\\n\\t\"\n\nYUV2RGB\n\n\t/* mm0=B, %%mm2=G, %%mm1=R */\n\n#ifdef HAVE_MMX2\n\n\t\t\t\"movq \"MANGLE(M24A)\", %%mm4\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(M24C)\", %%mm7\t\\n\\t\"\n\n\t\t\t\"pshufw $0x50, %%mm0, %%mm5\t\\n\\t\" /* B3 B2 B3 B2  B1 B0 B1 B0 */\n\n\t\t\t\"pshufw $0x50, %%mm2, %%mm3\t\\n\\t\" /* G3 G2 G3 G2  G1 G0 G1 G0 */\n\n\t\t\t\"pshufw $0x00, %%mm1, %%mm6\t\\n\\t\" /* R1 R0 R1 R0  R1 R0 R1 R0 */\n\n\n\n\t\t\t\"pand %%mm4, %%mm5\t\t\\n\\t\" /*    B2        B1       B0 */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G2        G1       G0 */\n\n\t\t\t\"pand %%mm7, %%mm6\t\t\\n\\t\" /*       R1        R0       */\n\n\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* G2        G1       G0    */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"psrlq $8, %%mm2\t\t\\n\\t\" /* 00 G7 G6 G5  G4 G3 G2 G1 */\n\n\t\t\t\"pshufw $0xA5, %%mm0, %%mm5\t\\n\\t\" /* B5 B4 B5 B4  B3 B2 B3 B2 */\n\n\t\t\t\"pshufw $0x55, %%mm2, %%mm3\t\\n\\t\" /* G4 G3 G4 G3  G4 G3 G4 G3 */\n\n\t\t\t\"pshufw $0xA5, %%mm1, %%mm6\t\\n\\t\" /* R5 R4 R5 R4  R3 R2 R3 R2 */\n\n\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm5\t\\n\\t\" /* B5       B4        B3    */\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" /*       G4        G3       */\n\n\t\t\t\"pand %%mm4, %%mm6\t\t\\n\\t\" /*    R4        R3       R2 */\n\n\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\" /* B5    G4 B4     G3 B3    */\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"pshufw $0xFF, %%mm0, %%mm5\t\\n\\t\" /* B7 B6 B7 B6  B7 B6 B6 B7 */\n\n\t\t\t\"pshufw $0xFA, %%mm2, %%mm3\t\\n\\t\" /* 00 G7 00 G7  G6 G5 G6 G5 */\n\n\t\t\t\"pshufw $0xFA, %%mm1, %%mm6\t\\n\\t\" /* R7 R6 R7 R6  R5 R4 R5 R4 */\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"pand %%mm7, %%mm5\t\t\\n\\t\" /*       B7        B6       */\n\n\t\t\t\"pand %%mm4, %%mm3\t\t\\n\\t\" /*    G7        G6       G5 */\n\n\t\t\t\"pand \"MANGLE(M24B)\", %%mm6\t\\n\\t\" /* R7       R6        R5    */\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\\\n\n\t\t\t\"por %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"por %%mm3, %%mm6\t\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 16(%1)\t\t\\n\\t\"\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\n\n#else\n\n\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm0, %%mm5\t\t\\n\\t\" /* B */\n\n\t\t\t\"movq %%mm1, %%mm6\t\t\\n\\t\" /* R */\n\n\t\t\t\"punpcklbw %%mm2, %%mm0\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"punpcklbw %%mm4, %%mm1\t\t\\n\\t\" /* 0R0R0R0R 0 */\n\n\t\t\t\"punpckhbw %%mm2, %%mm5\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpckhbw %%mm4, %%mm6\t\t\\n\\t\" /* 0R0R0R0R 2 */\n\n\t\t\t\"movq %%mm0, %%mm7\t\t\\n\\t\" /* GBGBGBGB 0 */\n\n\t\t\t\"movq %%mm5, %%mm3\t\t\\n\\t\" /* GBGBGBGB 2 */\n\n\t\t\t\"punpcklwd %%mm1, %%mm7\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"punpckhwd %%mm1, %%mm0\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"punpcklwd %%mm6, %%mm5\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"punpckhwd %%mm6, %%mm3\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"movq %%mm7, %%mm2\t\t\\n\\t\" /* 0RGB0RGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGB0RGB 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGB0RGB 2 */\n\n\t\t\t\"movq %%mm3, %%mm4\t\t\\n\\t\" /* 0RGB0RGB 3 */\n\n\n\n\t\t\t\"psllq $40, %%mm7\t\t\\n\\t\" /* RGB00000 0 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* RGB00000 1 */\n\n\t\t\t\"psllq $40, %%mm5\t\t\\n\\t\" /* RGB00000 2 */\n\n\t\t\t\"psllq $40, %%mm3\t\t\\n\\t\" /* RGB00000 3 */\n\n\n\n\t\t\t\"punpckhdq %%mm2, %%mm7\t\t\\n\\t\" /* 0RGBRGB0 0 */\n\n\t\t\t\"punpckhdq %%mm6, %%mm0\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"punpckhdq %%mm1, %%mm5\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"punpckhdq %%mm4, %%mm3\t\t\\n\\t\" /* 0RGBRGB0 3 */\n\n\n\n\t\t\t\"psrlq $8, %%mm7\t\t\\n\\t\" /* 00RGBRGB 0 */\n\n\t\t\t\"movq %%mm0, %%mm6\t\t\\n\\t\" /* 0RGBRGB0 1 */\n\n\t\t\t\"psllq $40, %%mm0\t\t\\n\\t\" /* GB000000 1 */\n\n\t\t\t\"por %%mm0, %%mm7\t\t\\n\\t\" /* GBRGBRGB 0 */\n\n\t\t\tMOVNTQ\" %%mm7, (%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%2, %0), %%mm0;\" /* Load 4 Cb 00 00 00 00 u3 u2 u1 u0 */\n\n\n\n\t\t\t\"psrlq $24, %%mm6\t\t\\n\\t\" /* 0000RGBR 1 */\n\n\t\t\t\"movq %%mm5, %%mm1\t\t\\n\\t\" /* 0RGBRGB0 2 */\n\n\t\t\t\"psllq $24, %%mm5\t\t\\n\\t\" /* BRGB0000 2 */\n\n\t\t\t\"por %%mm5, %%mm6\t\t\\n\\t\" /* BRGBRGBR 1 */\n\n\t\t\tMOVNTQ\" %%mm6, 8(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8 (%5, %0, 2), %%mm6;\" /* Load 8 Y Y7 Y6 Y5 Y4 Y3 Y2 Y1 Y0 */\n\n\n\n\t\t\t\"psrlq $40, %%mm1\t\t\\n\\t\" /* 000000RG 2 */\n\n\t\t\t\"psllq $8, %%mm3\t\t\\n\\t\" /* RGBRGB00 3 */\n\n\t\t\t\"por %%mm3, %%mm1\t\t\\n\\t\" /* RGBRGBRG 2 */\n\n\t\t\tMOVNTQ\" %%mm1, 16(%1)\t\t\\n\\t\"\n\n\n\n\t\t\t\"movd 4 (%3, %0), %%mm1;\" /* Load 4 Cr 00 00 00 00 v3 v2 v1 v0 */\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n#endif\n\n\t\t     \n\n\t\t     \"add $24, %1\t\t\t\\n\\t\"\n\n\t\t     \"add $4, %0\t\t\t\\n\\t\"\n\n\t\t     \" js 1b\t\t\t\t\\n\\t\"\n\n\t\t     \n\n\t\t     : \"+r\" (index), \"+r\" (_image)\n\n\t\t     : \"r\" (_pu - index), \"r\" (_pv - index), \"r\"(&c->redDither), \"r\" (_py - 2*index)\n\n\t\t     );\n\n    }\n\n\n\n    __asm__ __volatile__ (EMMS);\n\n    return srcSliceH;\n\n}\n", "idx": 18523, "substitutes": {"c": ["pc", "oc", "m", "s", "ch", "t", "cal", "conf", "f", "vc", "ct", "conn", "rc", "cm", "n", "g", "cp", "ctx", "mc", "ctrl", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "xc", "w", "e", "cu", "cam", "k", "lc", "p", "b", "ec", "cd", "h", "cn", "C", "cv", "cc", "u"], "src": ["grad", "sup", "bs", "sur", "text", "dest", "rc", "scene", "reflect", "pack", "sb", "sl", "upp", "attr", "loc", "usr", "sel", "ctx", "sec", "host", "rob", "secure", "conv", "st", "config", "img", "sub", "sc", "ssl", "gl", "sr", "start", "scl", "req", "rb", "seq", "rss", "support", "url", "uc", "lib", "scenes", "inst", "proc", "iv", "rect", "desc", "sq", "source", "cv", "dist"], "srcStride": ["srcScri", "srcEstrite", "srcCri", "srcScrate", "srcstide", "srcScrite", "srcstr", "gradStute", "rcScrate", "srcstro", " srcStgrade", " srcScrite", "srcSTride", "srcStandute", " srcStro", "srcStide", "gradSTride", "srcStrride", "srcStandride", "srcStandide", "srcEstride", "srcStandrite", "srcSlride", "srcSlro", "srcSTbit", "rcStrate", "srcEstide", "srcShrip", "srcScrip", "srcStro", "srcStrite", "srcCrip", "srcCide", "gradSTrip", " srcScride", "srcSTrite", "srcStrrate", "srcShute", "srcStbit", " srcStide", "srcEstgrade", "srcScide", "srcShroute", "srcStandroute", "srcSlr", "rcScrite", "rcStide", "srcStrate", "rcStride", "rcStrip", "gradSTroute", "gradStroute", "srcShride", "srcStgrade", "srcStr", "rcScbit", "srcStrrite", "srcScride", "srcStute", "srcStandgrade", "srcstride", "gradStride", " srcStrite", "gradSTute", "srcStandrip", "rcStrite", " srcScri", "rcStbit", "srcSTrip", " srcScide", "srcStri", "rcScride", "srcScbit", " srcStr", "srcSTrate", "srcEstri", "srcStroute", "srcSTute", "gradStrip", "srcStrip", "rcScide", "srcCride", "srcStrbit", "rcScrip", "srcSlide", "srcSTroute", " srcStri", "srcCrite"], "srcSliceY": ["srcSlaceY", "srcFliceW", "srcFlICEB", "srcSlICEY", "srcSlaseH", "srcPliceH", "srcSlenseY", "srcSlashB", "srcSlaseX", "srcFliceY", "srcSliceB", "srcPliceY", "srcSlaseB", "srcSlenseH", "srcFliceB", "srcPlaseB", "srcSlICEW", "srcSliceX", "srcSlashX", "srcPliceB", "srcFlICEX", "srcPlaseY", "srcSlICEB", "srcSlenseB", "srcSlaseY", "srcSlashW", "srcSlaceH", "srcSlaceW", "srcSlICEX", "srcFlICEY", "srcPlaseH", "srcSlenseX", "srcPlaseX", "srcSlaceX", "srcFliceX", "srcSlaceB", "srcFlICEW", "srcSlashY", "srcSliceW", "srcPliceX"], "srcSliceH": ["srcSlICEH", "srcSlaceY", "srcFliceW", "srcSlICEY", "srcFliceH", "srcSlideV", "srcFliceY", "srcSlideW", "srcSlideH", "srcSlICEW", "srcSliceX", "srcFlICEX", "srcSlineY", "srcSlaceH", "srcSlaceW", "srcSlICEX", "srcSlineX", "srcSlineW", "srcFlICEY", "srcFliceV", "srcFlICEV", "srcSliceV", "srcSlineH", "srcSlideY", "srcSlICEV", "srcSlaceX", "srcFliceX", "srcFlICEH", "srcFlICEW", "srcSlaceV", "srcSliceW"], "dst": ["Dst", "lsrc", "lsts", "dsrc", "Dsc", "Dsrc", "dsc", "Dsts", "Drc", " dsc", "lst", "inrc", " dsrc", " drc", "insrc", "insts", " dsts", "lsc", "inst", "dsts", "drc"], "dstStride": ["drcCrite", "dstTope", "dstSyncride", "dsrcStride", "dsrcstrite", "dstCride", "dstRride", "drcScride", "dstWrite", "dststend", "dstUri", "dsrcstend", "drcCerve", "dstStri", "dsrcStube", "dsrcStend", "dstSyncube", "dstStrip", "dsrcstube", "dstStrite", "dstUride", "drcSterve", "dstRrib", "dstSterve", "dstScri", "drcStope", "drcStrib", "drcScri", "dstStrib", "dstSyncend", "dstCrite", "dstScrip", "dstSTend", "dstCerve", "drcStrite", "dstWride", "dstScope", "dststride", "dststube", "dstTride", "drcStri", "dstRerve", "dststrite", "dstStube", "drcScope", "drcScrip", "dstCrib", "dstScride", "dstSyncrite", "dstUrip", "dstTrip", "dstTri", "dsrcStrite", "dstSTrite", "dstWrib", "drcCrib", "drcStrip", "dstWerve", "drcCride", "drcStride", "dstStend", "dstSTride", "dstUope", "dstRrite", "dstSTube", "dsrcstride", "dstStope"], "y": ["m", "xx", "j", "ky", "t", "ady", "wx", "x", "f", "sky", "yd", " Y", "n", "hy", "iy", "ya", "i", "year", "ys", "type", "z", "ny", "ym", "zy", "ry", "count", "cy", "Y", "l", "d", "yi", "ye", "dy", "ay", "w", "ey", "yy", "yt", "yr", "yer", "p", "yu", "oy", "vy", "h", "yo", "gy", "ty", "py", "yl", "sy", "my", "uy", "wy"], "h_size": ["p_width", " h__SIZE", " h_width", " h__loc", "h__name", "h_loc", " h__ize", "h_ize", "h__loc", "h_address", " h__name", "h2width", "p_address", " h__size", "h2size", "h_scale", " h_ize", "h2sized", " h__scale", "h__SIZE", "h__ize", " h_sized", "h2name", "h__scale", "h2address", " h_loc", " h_scale", "p_scale", "h__size", "h2scale", "h_width", "h_name", " h_name", "p_size", " h_SIZE", "h_SIZE", "h_sized"], "_image": ["xjpg", "ximg", "jjpg", "_jpg", "jpx", "xpx", "ximage", "jimg", "_px", "jimage", "_img"], "_py": ["tpx", "_ph", "tdi", " _ph", "tpy", " _px", "tph", "_px", "_di", " _di"], "_pu": ["_gpu", "__px", "__pu", "__gpu", "__pl", " _px", " _pl", "_px", "_pl", " _gpu"], "_pv": ["_cpd", "_mpsv", "_kv", "_cpsv", "_pd", "_mpv", "_mpd", "_psv", "_ksv", "_px", "_cpx", "_kd", "_mpx", "_cpv", "_kx"]}}
{"project": "FFmpeg", "commit_id": "c89658008705d949c319df3fa6f400c481ad73e1", "target": 0, "func": "static int hex_to_data(uint8_t *data, const char *p)\n\n{\n\n    int c, len, v;\n\n\n\n    len = 0;\n\n    v = 1;\n\n    for(;;) {\n\n        skip_spaces(&p);\n\n        if (*p == '\\0')\n\n            break;\n\n        c = toupper((unsigned char)*p++);\n\n        if (c >= '0' && c <= '9')\n\n            c = c - '0';\n\n        else if (c >= 'A' && c <= 'F')\n\n            c = c - 'A' + 10;\n\n        else\n\n            break;\n\n        v = (v << 4) | c;\n\n        if (v & 0x100) {\n\n            if (data)\n\n                data[len] = v;\n\n            len++;\n\n            v = 1;\n\n        }\n\n    }\n\n    return len;\n\n}\n", "idx": 18529, "substitutes": {"data": ["m", "Data", "code", "base", "f", "buffer", "result", "window", "i", "block", "type", "slice", "index", "pos", "self", "o", "d", "array", "new", "size", "memory", "ad", "e", "buf", "parent", "temp", "map", "da", "pad", "cache", "b", "dat", "ata", "wa", "a", "api", "DATA", "body", "ma", "alpha", "value", "li", "input"], "p": ["pc", "at", "wp", "m", "point", "s", "code", "t", "fp", "f", "jp", "op", "sp", "vp", "pe", "n", "g", "bp", "i", "cp", "lp", "python", "ap", "pos", "pointer", "o", "po", "ip", "l", "pair", "d", "pp", "pi", "e", "q", "pa", "ps", "b", "pat", "a", "api", "tp", "py", "np", "P", "u"], "c": ["pc", "dc", "m", "s", "ch", "code", "t", "x", "f", "vc", "ct", "r", "n", "cm", "cf", "g", "i", "cp", "bc", "fc", "mc", "count", "cy", "o", "enc", "ca", "cs", "l", "d", "ce", "nc", "ac", "ci", "q", "w", "tc", "xc", "k", "cu", "e", "sc", "cr", "lc", "cl", "cur", "uc", "b", "col", "ec", "h", "C", "y", "cc", "u"], "len": ["j", "code", "t", "x", "f", "base", "vc", "r", "n", "i", "sl", "z", "loc", "pos", "min", "en", "count", "lv", "vert", "ln", "l", "val", "d", "fl", "le", "size", "pre", "dy", "length", "id", "e", "limit", "lc", "rev", "ll", "line", "b", "cmp", "split", "lin", "iter", "el", "vin", "y", "li", "Len", "u"], "v": ["m", "V", "j", "s", "t", "x", "f", "sv", "vc", "vin", "ve", "r", "n", "g", "i", "z", "vi", "lv", "count", "vert", "o", "uv", "l", "val", "d", "vol", "conv", "size", "ci", "w", "ev", "length", "e", "k", "vs", "lc", "b", "vv", "va", "h", "iv", "C", "value", "y", "u"]}}
{"project": "FFmpeg", "commit_id": "fa30a0a54854cd291008c065dfaf45d610e3cd04", "target": 0, "func": "static int RENAME(dct_quantize)(MpegEncContext *s,\n\n                            int16_t *block, int n,\n\n                            int qscale, int *overflow)\n\n{\n\n    x86_reg last_non_zero_p1;\n\n    int level=0, q; //=0 is because gcc says uninitialized ...\n\n    const uint16_t *qmat, *bias;\n\n    LOCAL_ALIGNED_16(int16_t, temp_block, [64]);\n\n\n\n    av_assert2((7&(int)(&temp_block[0])) == 0); //did gcc align it correctly?\n\n\n\n    //s->fdct (block);\n\n    RENAME_FDCT(ff_fdct)(block); // cannot be anything else ...\n\n\n\n    if(s->dct_error_sum)\n\n        s->denoise_dct(s, block);\n\n\n\n    if (s->mb_intra) {\n\n        int dummy;\n\n        if (n < 4){\n\n            q = s->y_dc_scale;\n\n            bias = s->q_intra_matrix16[qscale][1];\n\n            qmat = s->q_intra_matrix16[qscale][0];\n\n        }else{\n\n            q = s->c_dc_scale;\n\n            bias = s->q_chroma_intra_matrix16[qscale][1];\n\n            qmat = s->q_chroma_intra_matrix16[qscale][0];\n\n        }\n\n        /* note: block[0] is assumed to be positive */\n\n        if (!s->h263_aic) {\n\n        __asm__ volatile (\n\n                \"mul %%ecx                \\n\\t\"\n\n                : \"=d\" (level), \"=a\"(dummy)\n\n                : \"a\" ((block[0]>>2) + q), \"c\" (ff_inverse[q<<1])\n\n        );\n\n        } else\n\n            /* For AIC we skip quant/dequant of INTRADC */\n\n            level = (block[0] + 4)>>3;\n\n\n\n        block[0]=0; //avoid fake overflow\n\n//        temp_block[0] = (block[0] + (q >> 1)) / q;\n\n        last_non_zero_p1 = 1;\n\n    } else {\n\n        last_non_zero_p1 = 0;\n\n        bias = s->q_inter_matrix16[qscale][1];\n\n        qmat = s->q_inter_matrix16[qscale][0];\n\n    }\n\n\n\n    if((s->out_format == FMT_H263 || s->out_format == FMT_H261) && s->mpeg_quant==0){\n\n\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            MOVQ\" (%2), \"MM\"5                   \\n\\t\" // qmat[0]\n\n            \"pxor \"MM\"6, \"MM\"6                  \\n\\t\"\n\n            \"psubw (%3), \"MM\"6                  \\n\\t\" // -bias[0]\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            \"psubusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat), \"r\" (bias),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }else{ // FMT_H263\n\n        __asm__ volatile(\n\n            \"movd %%\"FF_REG_a\", \"MM\"3           \\n\\t\" // last_non_zero_p1\n\n            SPREADW(MM\"3\")\n\n            \"pxor \"MM\"7, \"MM\"7                  \\n\\t\" // 0\n\n            \"pxor \"MM\"4, \"MM\"4                  \\n\\t\" // 0\n\n            \"mov $-128, %%\"FF_REG_a\"            \\n\\t\"\n\n            \".p2align 4                         \\n\\t\"\n\n            \"1:                                 \\n\\t\"\n\n            MOVQ\" (%1, %%\"FF_REG_a\"), \"MM\"0     \\n\\t\" // block[i]\n\n            SAVE_SIGN(MM\"1\", MM\"0\")                   // ABS(block[i])\n\n            MOVQ\" (%3, %%\"FF_REG_a\"), \"MM\"6     \\n\\t\" // bias[0]\n\n            \"paddusw \"MM\"6, \"MM\"0               \\n\\t\" // ABS(block[i]) + bias[0]\n\n            MOVQ\" (%2, %%\"FF_REG_a\"), \"MM\"5     \\n\\t\" // qmat[i]\n\n            \"pmulhw \"MM\"5, \"MM\"0                \\n\\t\" // (ABS(block[i])*qmat[0] + bias[0]*qmat[0])>>16\n\n            \"por \"MM\"0, \"MM\"4                   \\n\\t\"\n\n            RESTORE_SIGN(MM\"1\", MM\"0\")                // out=((ABS(block[i])*qmat[0] - bias[0]*qmat[0])>>16)*sign(block[i])\n\n            MOVQ\" \"MM\"0, (%5, %%\"FF_REG_a\")     \\n\\t\"\n\n            \"pcmpeqw \"MM\"7, \"MM\"0               \\n\\t\" // out==0 ? 0xFF : 0x00\n\n            MOVQ\" (%4, %%\"FF_REG_a\"), \"MM\"1     \\n\\t\"\n\n            MOVQ\" \"MM\"7, (%1, %%\"FF_REG_a\")     \\n\\t\" // 0\n\n            \"pandn \"MM\"1, \"MM\"0                 \\n\\t\"\n\n            PMAXW(MM\"0\", MM\"3\")\n\n            \"add $\"MMREG_WIDTH\", %%\"FF_REG_a\"   \\n\\t\"\n\n            \" js 1b                             \\n\\t\"\n\n            PMAX(MM\"3\", MM\"0\")\n\n            \"movd \"MM\"3, %%\"FF_REG_a\"           \\n\\t\"\n\n            \"movzbl %%al, %%eax                 \\n\\t\" // last_non_zero_p1\n\n            : \"+a\" (last_non_zero_p1)\n\n            : \"r\" (block+64), \"r\" (qmat+64), \"r\" (bias+64),\n\n              \"r\" (inv_zigzag_direct16 + 64), \"r\" (temp_block + 64)\n\n              XMM_CLOBBERS_ONLY(\"%xmm0\", \"%xmm1\", \"%xmm2\", \"%xmm3\",\n\n                                \"%xmm4\", \"%xmm5\", \"%xmm6\", \"%xmm7\")\n\n        );\n\n    }\n\n    __asm__ volatile(\n\n        \"movd %1, \"MM\"1                     \\n\\t\" // max_qcoeff\n\n        SPREADW(MM\"1\")\n\n        \"psubusw \"MM\"1, \"MM\"4               \\n\\t\"\n\n        \"packuswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#if COMPILE_TEMPLATE_SSE2\n\n        \"packsswb \"MM\"4, \"MM\"4              \\n\\t\"\n\n#endif\n\n        \"movd \"MM\"4, %0                     \\n\\t\" // *overflow\n\n        : \"=g\" (*overflow)\n\n        : \"g\" (s->max_qcoeff)\n\n    );\n\n\n\n    if(s->mb_intra) block[0]= level;\n\n    else            block[0]= temp_block[0];\n\n\n\n    if (s->idsp.perm_type == FF_IDCT_PERM_SIMPLE) {\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x08] = temp_block[0x01]; block[0x10] = temp_block[0x08];\n\n        block[0x20] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x18] = temp_block[0x09]; block[0x04] = temp_block[0x02];\n\n        block[0x09] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x14] = temp_block[0x0A]; block[0x28] = temp_block[0x11];\n\n        block[0x12] = temp_block[0x18]; block[0x02] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1A] = temp_block[0x19]; block[0x24] = temp_block[0x12];\n\n        block[0x19] = temp_block[0x0B]; block[0x01] = temp_block[0x04];\n\n        block[0x0C] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x11] = temp_block[0x0C]; block[0x29] = temp_block[0x13];\n\n        block[0x16] = temp_block[0x1A]; block[0x0A] = temp_block[0x21];\n\n        block[0x30] = temp_block[0x28]; block[0x22] = temp_block[0x30];\n\n        block[0x38] = temp_block[0x29]; block[0x06] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x21] = temp_block[0x14];\n\n        block[0x1C] = temp_block[0x0D]; block[0x05] = temp_block[0x06];\n\n        block[0x0D] = temp_block[0x07]; block[0x15] = temp_block[0x0E];\n\n        block[0x2C] = temp_block[0x15]; block[0x13] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x0B] = temp_block[0x23]; block[0x34] = temp_block[0x2A];\n\n        block[0x2A] = temp_block[0x31]; block[0x32] = temp_block[0x38];\n\n        block[0x3A] = temp_block[0x39]; block[0x26] = temp_block[0x32];\n\n        block[0x39] = temp_block[0x2B]; block[0x03] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x25] = temp_block[0x16];\n\n        block[0x1D] = temp_block[0x0F]; block[0x2D] = temp_block[0x17];\n\n        block[0x17] = temp_block[0x1E]; block[0x0E] = temp_block[0x25];\n\n        block[0x31] = temp_block[0x2C]; block[0x2B] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x36] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x23] = temp_block[0x34]; block[0x3C] = temp_block[0x2D];\n\n        block[0x07] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x0F] = temp_block[0x27]; block[0x35] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x2E] = temp_block[0x35]; block[0x33] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x27] = temp_block[0x36];\n\n        block[0x3D] = temp_block[0x2F]; block[0x2F] = temp_block[0x37];\n\n        block[0x37] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else if(s->idsp.perm_type == FF_IDCT_PERM_LIBMPEG2){\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x04] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x0C] = temp_block[0x09]; block[0x01] = temp_block[0x02];\n\n        block[0x05] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x09] = temp_block[0x0A]; block[0x14] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x1C] = temp_block[0x19];\n\n        block[0x11] = temp_block[0x12]; block[0x0D] = temp_block[0x0B];\n\n        block[0x02] = temp_block[0x04]; block[0x06] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0A] = temp_block[0x0C]; block[0x15] = temp_block[0x13];\n\n        block[0x19] = temp_block[0x1A]; block[0x24] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x2C] = temp_block[0x29]; block[0x21] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1D] = temp_block[0x1B]; block[0x12] = temp_block[0x14];\n\n        block[0x0E] = temp_block[0x0D]; block[0x03] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0B] = temp_block[0x0E];\n\n        block[0x16] = temp_block[0x15]; block[0x1A] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x25] = temp_block[0x23]; block[0x29] = temp_block[0x2A];\n\n        block[0x34] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x3C] = temp_block[0x39]; block[0x31] = temp_block[0x32];\n\n        block[0x2D] = temp_block[0x2B]; block[0x22] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1E] = temp_block[0x1D]; block[0x13] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1B] = temp_block[0x1E]; block[0x26] = temp_block[0x25];\n\n        block[0x2A] = temp_block[0x2C]; block[0x35] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x39] = temp_block[0x3A]; block[0x3D] = temp_block[0x3B];\n\n        block[0x32] = temp_block[0x34]; block[0x2E] = temp_block[0x2D];\n\n            block[0x23] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2B] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x36] = temp_block[0x35]; block[0x3A] = temp_block[0x3C];\n\n        block[0x3E] = temp_block[0x3D]; block[0x33] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3B] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }else{\n\n        if(last_non_zero_p1 <= 1) goto end;\n\n        block[0x01] = temp_block[0x01];\n\n        block[0x08] = temp_block[0x08]; block[0x10] = temp_block[0x10];\n\n        if(last_non_zero_p1 <= 4) goto end;\n\n        block[0x09] = temp_block[0x09]; block[0x02] = temp_block[0x02];\n\n        block[0x03] = temp_block[0x03];\n\n        if(last_non_zero_p1 <= 7) goto end;\n\n        block[0x0A] = temp_block[0x0A]; block[0x11] = temp_block[0x11];\n\n        block[0x18] = temp_block[0x18]; block[0x20] = temp_block[0x20];\n\n        if(last_non_zero_p1 <= 11) goto end;\n\n        block[0x19] = temp_block[0x19];\n\n        block[0x12] = temp_block[0x12]; block[0x0B] = temp_block[0x0B];\n\n        block[0x04] = temp_block[0x04]; block[0x05] = temp_block[0x05];\n\n        if(last_non_zero_p1 <= 16) goto end;\n\n        block[0x0C] = temp_block[0x0C]; block[0x13] = temp_block[0x13];\n\n        block[0x1A] = temp_block[0x1A]; block[0x21] = temp_block[0x21];\n\n        block[0x28] = temp_block[0x28]; block[0x30] = temp_block[0x30];\n\n        block[0x29] = temp_block[0x29]; block[0x22] = temp_block[0x22];\n\n        if(last_non_zero_p1 <= 24) goto end;\n\n        block[0x1B] = temp_block[0x1B]; block[0x14] = temp_block[0x14];\n\n        block[0x0D] = temp_block[0x0D]; block[0x06] = temp_block[0x06];\n\n        block[0x07] = temp_block[0x07]; block[0x0E] = temp_block[0x0E];\n\n        block[0x15] = temp_block[0x15]; block[0x1C] = temp_block[0x1C];\n\n        if(last_non_zero_p1 <= 32) goto end;\n\n        block[0x23] = temp_block[0x23]; block[0x2A] = temp_block[0x2A];\n\n        block[0x31] = temp_block[0x31]; block[0x38] = temp_block[0x38];\n\n        block[0x39] = temp_block[0x39]; block[0x32] = temp_block[0x32];\n\n        block[0x2B] = temp_block[0x2B]; block[0x24] = temp_block[0x24];\n\n        if(last_non_zero_p1 <= 40) goto end;\n\n        block[0x1D] = temp_block[0x1D]; block[0x16] = temp_block[0x16];\n\n        block[0x0F] = temp_block[0x0F]; block[0x17] = temp_block[0x17];\n\n        block[0x1E] = temp_block[0x1E]; block[0x25] = temp_block[0x25];\n\n        block[0x2C] = temp_block[0x2C]; block[0x33] = temp_block[0x33];\n\n        if(last_non_zero_p1 <= 48) goto end;\n\n        block[0x3A] = temp_block[0x3A]; block[0x3B] = temp_block[0x3B];\n\n        block[0x34] = temp_block[0x34]; block[0x2D] = temp_block[0x2D];\n\n        block[0x26] = temp_block[0x26]; block[0x1F] = temp_block[0x1F];\n\n        block[0x27] = temp_block[0x27]; block[0x2E] = temp_block[0x2E];\n\n        if(last_non_zero_p1 <= 56) goto end;\n\n        block[0x35] = temp_block[0x35]; block[0x3C] = temp_block[0x3C];\n\n        block[0x3D] = temp_block[0x3D]; block[0x36] = temp_block[0x36];\n\n        block[0x2F] = temp_block[0x2F]; block[0x37] = temp_block[0x37];\n\n        block[0x3E] = temp_block[0x3E]; block[0x3F] = temp_block[0x3F];\n\n    }\n\n    end:\n\n    return last_non_zero_p1 - 1;\n\n}\n", "idx": 18545, "substitutes": {"s": ["ns", "spec", "strings", "settings", "ions", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "m", "ts", "sg", "rs", "sim", "self", "o", "su", "outs", "k", "v", "si", "S", "ds", "native", "phys", "f", "r", "sb", "this", "sports", "l", "ins", "features", "sync", "c", "ps", "secondary", "b", "sys", "es", "states", "sq", "sf", "session", "stats", "t", "rates", "conf", "services", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "sites", "args", "e", "ssl", "ses", "client", "js", "support", "http", "gs", "its", "os", "parts", "se", "server", "u"], "block": ["board", "session", "group", "work", "record", "time", "view", "x", "name", "image", "f", "comment", "round", "buffer", "bit", "tick", "pack", "channel", "clean", "type", "bc", "node", "slice", "run", "byte", "object", "o", "ip", "enc", "ack", "load", "section", "chain", "event", "box", "Block", "w", "blocks", "config", "bl", "batch", "sync", "k", "cl", "device", "map", "off", "p", "line", "none", "lock", "cache", "null", "check", "filter", "clock", "row", "number", "frame", "word", "blocking", "input"], "n": ["ns", "m", "j", "t", "x", "f", "nt", "num", "N", "g", "i", "z", "nl", "nb", "en", "count", "l", "d", "nc", "network", "sn", "k", "e", "v", "c", "p", "b", "h", "nn", "np", "y", "u"], "qscale": [" qmode", "Qsize", "dqparse", "sqscale", "eqtotal", "sqcale", "qclip", "Qscale", "qusquare", "eqparse", "sqtile", "kscale", "sqdelay", "qparse", "qudepth", "qucos", "quarea", "pmode", "Qdepth", "kpack", "qtotal", "eqarea", "sqclip", "qdelay", "eqtile", "qtile", "Qmode", "qpack", "qascale", "questscale", " qsize", "qucale", "qcale", "qarea", "eqphase", "kdrop", "qdrop", "psize", "qualityarea", "qutile", "pseed", "Qdelay", "eqcos", "sqpack", "eqzone", "questparse", "dqtotal", "qualityscale", "qazone", "qseed", "qualitycale", "qualitypack", " qseed", "eqsquare", "qudelay", "Qzone", "eqclip", "qmode", "pscale", "qsquare", "qatile", "qualitydrop", "quphase", "Qseed", "quscale", "dqscale", "kcale", "sqcos", "sqdepth", "questarea", "questtotal", "eqcale", "eqscale", "qzone", "qualityphase", "dqarea", "qualitysquare", "Qcale", "qcos", "qphase", "quclip", "qsize", "Qtile", "qdepth", "qacale", "sqdrop"], "overflow": ["overcharge", " override", "Overload", "Overflow", "Override", "undercharge", "Overcharge", "underload", "overload", "underride", " overload", " overcharge", "override", "underflow"], "last_non_zero_p1": ["last_non_zero_q0", "last_non_zero_p11", "last_non_zero_q3", "last_non_zero_rone", "last_non_zero_c2", "last_non_zero_pone", "last_non_zero_p2", "last_non_zero_p0", "last_non_zero_c0", "last_non_zero_P11", "last_non_zero_P3", "last_non_zero_c3", "last_non_zero_r11", "last_non_zero_p3", "last_non_zero_r2", "last_non_zero_P2", "last_non_zero_P0", "last_non_zero_Pone", "last_non_zero_q11", "last_non_zero_P1", "last_non_zero_qone", "last_non_zero_c1", "last_non_zero_q2", "last_non_zero_r1", "last_non_zero_q1"], "q": ["quant", "scale", "offset", "ch", "t", "eq", "f", "bit", "x", "qi", "dq", "g", "quality", "i", "query", "type", "z", "charge", "Q", "quad", "count", "d", "qu", "iq", "w", "length", "id", "qs", "k", "limit", "qt", "v", "temp", "c", "qq", "qa", "p", "depth", "h", "level", "weight", "sq", "y", "u"], "qmat": ["querystat", " qmit", "qdim", "qunat", "qnat", "qqmat", "quscale", "sqscale", "sqpath", "qatransform", "queryatt", "qustat", "qapath", " qatt", "queryscale", "ppath", "quhat", "qadim", "qascale", "qatt", "qqdim", "qqcrit", "qhat", "qacrit", "ptransform", "sqmat", "qstat", "qudim", "qamat", "qumat", "qanat", "qtransform", "querymit", "qpath", " qstat", " qhat", "qmit", "pscale", "quatt", "sqtransform", "qucrit", "querymat", "queryhat", "pmat", "qumit", "qqnat", "qcrit"], "bias": ["cac", "barscale", "bscale", "cbasing", "bius", "lasing", " basing", "cias", " bscale", "dasing", "lias", "babel", " bius", "Bscale", "barix", "cbius", " baria", "barias", "Bac", "cius", "dius", "basing", "bararia", "baria", "Baria", " bix", "Basing", "bac", "dias", "cabel", " binding", "dinding", "lius", "binding", "cbias", "bix", "Babel", "Bius", "Binding", "Bix", " babel", " bac", "Bias"], "dummy": ["sdabbage", "Dummy", "Dabbage", "sdummy", "dumb", "dairy", " dairy", "Dumb", "dangling", " dangling", "Dumper", "sdumper", "dabbage", "Dairy", "sdumb", "Dangling", "dumper", " dumper"]}}
{"project": "FFmpeg", "commit_id": "491eaf35ae1f9b619441314bec33766e31580184", "target": 1, "func": "static void qdm2_fft_decode_tones (QDM2Context *q, int duration, GetBitContext *gb, int b)\n\n{\n\n    int channel, stereo, phase, exp;\n\n    int local_int_4,  local_int_8,  stereo_phase,  local_int_10;\n\n    int local_int_14, stereo_exp, local_int_20, local_int_28;\n\n    int n, offset;\n\n\n\n    local_int_4 = 0;\n\n    local_int_28 = 0;\n\n    local_int_20 = 2;\n\n    local_int_8 = (4 - duration);\n\n    local_int_10 = 1 << (q->group_order - duration - 1);\n\n    offset = 1;\n\n\n\n    while (1) {\n\n        if (q->superblocktype_2_3) {\n\n            while ((n = qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2)) < 2) {\n\n                offset = 1;\n\n                if (n == 0) {\n\n                    local_int_4 += local_int_10;\n\n                    local_int_28 += (1 << local_int_8);\n\n                } else {\n\n                    local_int_4 += 8*local_int_10;\n\n                    local_int_28 += (8 << local_int_8);\n\n                }\n\n            }\n\n            offset += (n - 2);\n\n        } else {\n\n            offset += qdm2_get_vlc(gb, &vlc_tab_fft_tone_offset[local_int_8], 1, 2);\n\n            while (offset >= (local_int_10 - 1)) {\n\n                offset += (1 - (local_int_10 - 1));\n\n                local_int_4  += local_int_10;\n\n                local_int_28 += (1 << local_int_8);\n\n            }\n\n        }\n\n\n\n        if (local_int_4 >= q->group_size)\n\n\n\n\n        local_int_14 = (offset >> local_int_8);\n\n\n\n\n\n        if (q->nb_channels > 1) {\n\n            channel = get_bits1(gb);\n\n            stereo = get_bits1(gb);\n\n        } else {\n\n            channel = 0;\n\n            stereo = 0;\n\n        }\n\n\n\n        exp = qdm2_get_vlc(gb, (b ? &fft_level_exp_vlc : &fft_level_exp_alt_vlc), 0, 2);\n\n        exp += q->fft_level_exp[fft_level_index_table[local_int_14]];\n\n        exp = (exp < 0) ? 0 : exp;\n\n\n\n        phase = get_bits(gb, 3);\n\n        stereo_exp = 0;\n\n        stereo_phase = 0;\n\n\n\n        if (stereo) {\n\n            stereo_exp = (exp - qdm2_get_vlc(gb, &fft_stereo_exp_vlc, 0, 1));\n\n            stereo_phase = (phase - qdm2_get_vlc(gb, &fft_stereo_phase_vlc, 0, 1));\n\n            if (stereo_phase < 0)\n\n                stereo_phase += 8;\n\n        }\n\n\n\n        if (q->frequency_range > (local_int_14 + 1)) {\n\n            int sub_packet = (local_int_20 + local_int_28);\n\n\n\n            qdm2_fft_init_coefficient(q, sub_packet, offset, duration, channel, exp, phase);\n\n            if (stereo)\n\n                qdm2_fft_init_coefficient(q, sub_packet, offset, duration, (1 - channel), stereo_exp, stereo_phase);\n\n        }\n\n\n\n        offset++;\n\n    }\n\n}", "idx": 18556, "substitutes": {"q": ["m", "quant", "ch", "t", "quest", "core", "f", "conf", "cal", "qi", "input", "dq", "g", "query", "ou", "z", "gui", "Q", "quad", "aq", "qu", "d", "ce", "sh", "iq", "ue", "config", "queue", "qs", "k", "qt", "cl", "v", "req", "c", "qq", "qa", "cmd", "p", "ck", "question", "que", "cache", "requ", "h", "sq", "u"], "duration": ["m", "br", "db", "nd", "time", "direction", "mode", "name", "component", "buffer", "mult", "window", "seconds", "i", "cb", "resolution", "dt", "bb", "timeout", "dim", "nb", "date", " bc", " dur", "gap", "d", " d", "nr", "nc", "uu", "length", "id", "e", "v", "unit", "c", "span", "stage", "video", "frequency", "depth", "rate", "days", "period", "number", "repeat", "sequence", "Duration", "y", "version", "len"], "gb": ["pc", "eb", "cfg", "gram", "db", "gnu", "GB", "gd", "cca", "gio", "usb", "gc", "gu", "gg", "bm", "cm", "bridge", "sb", "gh", "bp", "cb", "gin", "bc", "hub", "gru", "ctx", "gam", "rg", "abb", "bb", "lb", "nb", "gp", "kb", "bf", "mb", "bd", "kj", "ga", "cli", "bg", "rb", "lib", "bn", "hm", "gs", "storage", "gy", "gm", "cgi", "ub"], "b": ["ab", "m", "eb", "bin", "s", "j", "f", "base", "bit", "buffer", "r", "sb", "g", "cb", "bc", "B", "bb", "nb", "l", "d", "bar", "bf", "w", "bd", "e", "k", "batch", "v", "c", "bg", "rb", "p", "binary", "h", "boot", "a", "ib"], "channel": ["scale", "session", "group", "ch", "shape", "mode", "name", "f", "bit", "color", "component", "rc", "service", "pixel", "type", "bc", "normal", "byte", "gap", "context", "broad", "layer", "Channel", "slot", "size", "nc", "event", "socket", "config", "queue", "button", "batch", "lc", "unit", "chan", "depth", "error", "connection", "message", "source", "version"], "stereo": ["stealing", "mastadium", "structure", "Stealing", "estereo", "STereo", "mastereo", "constadium", " stealing", "stamber", "Structure", "Strobe", "mastrobe", "STrobe", "constamber", "Stereo", "stadium", "STadium", "Stadium", "STructure", "constructure", "estadium", "strobe", "Stamber", "estructure", " stamber", " structure", "estealing", "mastructure", "constereo", " stadium"], "phase": ["scale", "shape", "mode", "direction", "sample", "image", "name", "component", "type", "slice", "scope", "dim", "description", "location", "layer", "format", "step", "unit", "seq", "stage", "norm", "level", "version", "wave"], "local_int_4": ["local_Int_44", "local_int6720", "local_int89", "local_int674", "local_Int_10", "local_Int_4", "local_Int_14", "local_int_44", "local_ind_4", "local_ind_8", "local_int_7", "local_Int_04", "local_int679", "local_int820", "local_int_9", "local_Int_20", "local_Int_9", "local_int_four", "local_int84", "local_ind_44", "local_Int_four", "local_int8four", "local_Int_7", "local_int67four", "local_int_40", "local_Int_8", "local_int_04", "local_Int_40", "local_ind_04"], "local_int_8": ["local_inst_10", "local_int328", "local_int6720", "local_bit_08", "local_int_128", "local_ints_08", "local_bit_14", "local_int_88", "local_intP128", "local_int_16", "local_int_08", "local_bit_88", "local_intP08", "local_int678", "local_intP10", "local_int6725", "local_intP8", "local_int3210", "local_ints6708", "local_ext_4", "local_ext_8", "local_ext_14", "local_int_18", "local_bit_9", "local_int_25", "local_ints6710", "local_ints8", "local_Int_08", "local_int_9", "local_ints678", "local_int3225", "local_int3220", "local_int6716", "local_inst_18", "local_int_2", "local_ints_10", "local_ints6716", "local_ints08", "local_int6708", "local_bit_10", "local_Int_88", "local_ints16", "local_bit_2", "local_ints_8", "local_ints10", "local_Int_28", "local_inst_2", "local_bit_8", "local_ints_16", "local_inst_8", "local_bit_20", "local_Int_8", "local_bit_25", "local_bit_128", "local_ext_10", "local_int6710"], "stereo_phase": ["stereo_seq", "struction_seq", "stereo_version", "struction_phase", "struction_version", "struction_exp"], "local_int_10": ["local_int3214", "local_int_11", "local_int9610", "local_int328", "local_int_5", "local_int96data", "local_nt_8", "local_Int_5", "local_int64config", "local_Int_10", "local_int6412", "local_int28", "local_int3228", "local_int9612", "local_Int_14", "local_int6410", "local_Int_config", "local_int2data", "local_int3210", "local_int6420", "local_int212", "local_int_25", "local_ints8", "local_Int_20", "local_int3225", "local_Int_data", "local_nt_10", "local_intsconfig", "local_int648", "local_int968", "local_int3211", "local_nt_15", "local_nt_4", "local_int_15", "local_int_config", "local_int_12", "local_ints20", "local_ints10", "local_int_data", "local_Int_28", "local_Int_12", "local_Int_8", "local_int6415", "local_Int_25", "local_Int_11", "local_int210", "local_Int_15"], "local_int_14": ["local_Int_14", "local_int_13", "local_int_12", "local_int6413", "local_int6428", "local_Int_28", "local_bit_8", "local_Int_13", "local_int228", "local_int648", "local_Int_8", "local_int6414", "local_bit_28", "local_int6412", "local_int212", "local_int214", "local_bit_14", "local_bit_12", "local_int28"], "stereo_exp": ["stereo_full", "stropy_scale", "stropy_phase", "stropy_exp", "stereo_scale", "stropy_full"], "local_int_20": ["local_nt_14", "local_int220", "local_int4820", "local_int488", "local_nt_20", "local_nt_10", "local_nt_8", "local_nt_18", "local_int4810", "local_int6420", "local_int_0", "local_int6418", "local_int648", "local_int6414", "local_int214", "local_int_18", "local_int480", "local_int28", "local_int218", "local_nt_0"], "local_int_28": ["local_bit_5", "local_int_56", "local_int2528", "local_int_5", "local_int244", "local_int832", "local_int_29", "local_inc829", "local_inc_29", "local_bit_14", "local_ind_29", "local_Int_14", "local_intA28", "local_int1256", "local_ind_4", "local_int258", "local_int2514", "local_ind_8", "local_intA14", "local_int2515", "local_int6429", "local_int6427", "local_ind_28", "local_int2429", "local_int_27", "local_int_32", "local_ind_48", "local_int_48", "local_inc_32", "local_int2428", "local_int829", "local_int648", "local_int1229", "local_bit_28", "local_inc832", "local_inc_28", "local_int_15", "local_intA5", "local_ind_27", "local_int1232", "local_int1228", "local_int6428", "local_int828", "local_inc_56", "local_Int_28", "local_bit_8", "local_int2448", "local_inc828", "local_Int_8", "local_intA8", "local_inc856", "local_int856", "local_Int_15"], "n": ["ns", "na", "m", "dn", "j", "t", "un", "x", "f", "pn", "r", "nt", "ne", "adj", "num", "mn", "N", "g", "i", "nor", "z", "loc", "node", "nb", "en", "count", "o", "l", "d", "nr", "nc", "no", "sn", "nu", "k", "e", "v", "span", "c", "unit", "p", "none", "fn", "u", "h", "cn", "number", "nn", "y", "conn", "len"], "offset": ["entry", "set", "skip", "bit", "align", "padding", "pos", "aligned", "range", "location", "layer", "iso", "no", "length", "layout", "p", "frequency", "area", "beta", "aff", "end", "len", "part", "scale", "Offset", "timeout", "pointer", "online", "o", "slot", "size", "style", "parent", "off", "shift", "operation", "outer", "f", "image", "alt", "type", "loc", "function", "bound", "gap", "start", "delay", "sync", "position", "address", "fee", "append", "alpha", "af", "optional", "attribute", "option", "i", "index", "slice", "member", "alias", "step", "event", "seed", "limit", "error", "number", "api"]}}
{"project": "qemu", "commit_id": "ff472a5badf8e6d964455de39ca67ea3a7758dea", "target": 1, "func": "static void cuda_receive_packet(CUDAState *s,\n\n                                const uint8_t *data, int len)\n\n{\n\n    uint8_t obuf[16] = { CUDA_PACKET, 0, data[0] };\n\n    int autopoll;\n\n    uint32_t ti;\n\n\n\n    switch(data[0]) {\n\n    case CUDA_AUTOPOLL:\n\n        autopoll = (data[1] != 0);\n\n        if (autopoll != s->autopoll) {\n\n            s->autopoll = autopoll;\n\n            if (autopoll) {\n\n                timer_mod(s->adb_poll_timer,\n\n                               qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) +\n\n                               (get_ticks_per_sec() / CUDA_ADB_POLL_FREQ));\n\n            } else {\n\n                timer_del(s->adb_poll_timer);\n\n            }\n\n        }\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_6805_ADDR:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_SET_TIME:\n\n        ti = (((uint32_t)data[1]) << 24) + (((uint32_t)data[2]) << 16) + (((uint32_t)data[3]) << 8) + data[4];\n\n        s->tick_offset = ti - (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_GET_TIME:\n\n        ti = s->tick_offset + (qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) / get_ticks_per_sec());\n\n        obuf[3] = ti >> 24;\n\n        obuf[4] = ti >> 16;\n\n        obuf[5] = ti >> 8;\n\n        obuf[6] = ti;\n\n        cuda_send_packet_to_host(s, obuf, 7);\n\n        break;\n\n    case CUDA_FILE_SERVER_FLAG:\n\n    case CUDA_SET_DEVICE_LIST:\n\n    case CUDA_SET_AUTO_RATE:\n\n    case CUDA_SET_POWER_MESSAGES:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        break;\n\n    case CUDA_POWERDOWN:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_shutdown_request();\n\n        break;\n\n    case CUDA_RESET_SYSTEM:\n\n        cuda_send_packet_to_host(s, obuf, 3);\n\n        qemu_system_reset_request();\n\n        break;\n\n    case CUDA_COMBINED_FORMAT_IIC:\n\n\n        obuf[1] = 0x5;\n\n\n\n\n        break;\n\n    case CUDA_GET_SET_IIC:\n\n        if (len == 4) {\n\n            cuda_send_packet_to_host(s, obuf, 3);\n\n        } else {\n\n\n\n\n\n\n        }\n\n        break;\n\n    default:\n\n\n\n\n\n\n        break;\n\n    }\n\n}", "idx": 18559, "substitutes": {"s": ["ns", "spec", "m", "stat", "session", "ts", "sg", "stats", "rs", "t", "conf", "f", "sv", "services", "service", "r", "ions", "n", "sie", "g", "sb", "ss", "ls", "ops", "fs", "self", "is", "cs", "l", "d", "su", "site", "serv", "side", "ssl", "e", "ses", "sync", "private", "c", "js", "si", "ps", "sym", "p", "S", "ks", "http", "b", "gs", "sys", "your", "es", "state", "hs", "server", "states", "sq", "south", "se", "sets", "y", "ds", "sf"], "data": ["na", "Data", "dd", "code", "request", "info", "sample", "image", "buffer", "results", "result", "pack", "window", "i", "block", "devices", "package", "xy", "di", "index", "done", "slice", "multi", "date", "after", "load", "d", "empty", "array", "size", "zero", "args", "style", "ui", "aa", "config", "response", "start", "xxx", "key", "send", "batch", "ad", "delay", "device", "post", "da", "p", "pad", "cache", "missing", "dat", "next", "ata", "la", "split", "wa", "body", "a", "DATA", "message", "bytes", "api", "alpha", "value", "input"], "len": ["offset", "code", "SIZE", "base", "all", "n", "type", "src", "fin", "pos", "en", "count", "enc", "l", "val", "size", "nc", "length", " length", "seq", "lib", " clen", "end", "el", "Len"], "obuf": ["braf", "abuff", "ocbuf", " obbuff", "obsbuffer", "OBub", "objectuf", "objectust", " ibush", "oauff", "obust", "oblu", " obaf", "bruffer", "odaf", "Obdf", "abdf", "ocum", "OBuffer", "oauf", " obbuffer", " obull", "obsuf", "OBaf", " obuc", "skub", "obuff", "obdf", "abbuf", "obsuffer", "OBull", "obbuf", "bruf", " obdf", "ocdf", " obuff", "sklu", "abull", " obault", "Obush", "skuff", "skuf", " obboard", " obub", "obbuff", "ouust", "brub", "OBuf", " obush", "abbuff", "Obuf", "ocuf", " obuffer", "Obuffer", "Obboard", " obust", "obum", "obsboard", "objectush", "odault", " obume", "oduc", "OBuc", "oduf", "Obub", "ouush", "OBuff", "objectume", " ibuf", " ibbuf", "ablu", "obume", " ibdf", "abub", "oabuff", "Obaf", " oblu", "Obbuffer", "obboard", "OBault", " obum", "obub", "obush", "OBbuff", "abum", "ouuf", "abuf", "Obbuf", "oabuf", " obbuf", "obault", "obbuffer", "obuc", "obaf", "ouume", "obull", "obuffer"], "autopoll": ["autofoller", " autompoller", "autocloll", "autocoll", " autofool", "autompol", "autopell", "octopol", "autobell", " autopoller", "autocock", " autopell", " autompone", "autocll", "autipool", "autofell", "autofollo", "autobone", "octopool", "octompoller", "autoholl", "autopoller", " autopll", " autopollo", "autopol", " autompell", "autopll", "octompoll", "autofoll", "autocol", "autocell", "autompone", "autompell", "autoboller", "autobol", "autompll", "autobool", " autofollo", " autompll", "autofll", "autohock", "autopool", "autohollo", " autopone", "octompol", " autopool", "autipoll", " autompock", " autofoll", "autocollo", "autompollo", "autophol", "autompock", "autobollo", "octopoll", " autopock", "autoclol", "autopollo", "autopholl", "autohol", "autophell", "autopock", "autocloller", "autipoller", "autipol", "octopoller", "autofol", "autoclell", "autompoller", "autompoll", " autompoll", "autoboll", " autompollo", "autophone", "octompool", "autompool", " autompool", " autompol", "autofool", " autofoller", " autopol", "autopone"], "ti": ["uri", "shi", "uti", "bi", "ami", "t", "edi", "tti", "wi", "ini", "qi", "oti", "lit", "ai", "mi", "phi", "osi", "TI", "i", "hi", "tu", "ii", "ori", "ski", "di", "te", "multi", "tif", "zi", "vi", "chi", "tis", "adi", "ta", "yi", "pi", "ui", "ci", "sil", "nu", "tta", "oni", "isi", "ni", "ki", "si", "xi", "tin", "ati", "ita", "eni", "tm", "iri", "li"]}}
{"project": "qemu", "commit_id": "b6b75a99dab760c902c3d355519e0dc2616872e1", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562, "substitutes": {"bm": ["m", "bi", "bin", "db", "obj", "buffer", "md", "rm", "cm", "mi", "pm", "sb", "bp", "cb", "ym", "om", "bc", "pb", "bt", "lb", "bb", "nb", "nm", "gb", "bo", "bank", "kb", "mr", "bf", "img", "bd", "mb", "fb", "buf", "bh", "map", "bg", "wm", "bn", "hm", "b", "fm", "gm", "tm", "BM"]}}
{"project": "FFmpeg", "commit_id": "513a3494396d0a20233273b3cadcb5ee86485d5c", "target": 1, "func": "static int vp6_parse_coeff(VP56Context *s)\n\n{\n\n    VP56RangeCoder *c = s->ccp;\n\n    VP56Model *model = s->modelp;\n\n    uint8_t *permute = s->idct_scantable;\n\n    uint8_t *model1, *model2, *model3;\n\n    int coeff, sign, coeff_idx;\n\n    int b, i, cg, idx, ctx;\n\n    int pt = 0;    /* plane type (0 for Y, 1 for U or V) */\n\n\n\n    if (c->end >= c->buffer && c->bits >= 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"End of AC stream reached in vp6_parse_coeff\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    for (b=0; b<6; b++) {\n\n        int ct = 1;    /* code type */\n\n        int run = 1;\n\n\n\n        if (b > 3) pt = 1;\n\n\n\n        ctx = s->left_block[ff_vp56_b6to4[b]].not_null_dc\n\n              + s->above_blocks[s->above_block_idx[b]].not_null_dc;\n\n        model1 = model->coeff_dccv[pt];\n\n        model2 = model->coeff_dcct[pt][ctx];\n\n\n\n        coeff_idx = 0;\n\n        for (;;) {\n\n            if ((coeff_idx>1 && ct==0) || vp56_rac_get_prob_branchy(c, model2[0])) {\n\n                /* parse a coeff */\n\n                if (vp56_rac_get_prob_branchy(c, model2[2])) {\n\n                    if (vp56_rac_get_prob_branchy(c, model2[3])) {\n\n                        idx = vp56_rac_get_tree(c, ff_vp56_pc_tree, model1);\n\n                        coeff = ff_vp56_coeff_bias[idx+5];\n\n                        for (i=ff_vp56_coeff_bit_length[idx]; i>=0; i--)\n\n                            coeff += vp56_rac_get_prob(c, ff_vp56_coeff_parse_table[idx][i]) << i;\n\n                    } else {\n\n                        if (vp56_rac_get_prob_branchy(c, model2[4]))\n\n                            coeff = 3 + vp56_rac_get_prob(c, model1[5]);\n\n                        else\n\n                            coeff = 2;\n\n                    }\n\n                    ct = 2;\n\n                } else {\n\n                    ct = 1;\n\n                    coeff = 1;\n\n                }\n\n                sign = vp56_rac_get(c);\n\n                coeff = (coeff ^ -sign) + sign;\n\n                if (coeff_idx)\n\n                    coeff *= s->dequant_ac;\n\n                idx = model->coeff_index_to_pos[coeff_idx];\n\n                s->block_coeff[b][permute[idx]] = coeff;\n\n                run = 1;\n\n            } else {\n\n                /* parse a run */\n\n                ct = 0;\n\n                if (coeff_idx > 0) {\n\n                    if (!vp56_rac_get_prob_branchy(c, model2[1]))\n\n                        break;\n\n\n\n                    model3 = model->coeff_runv[coeff_idx >= 6];\n\n                    run = vp56_rac_get_tree(c, vp6_pcr_tree, model3);\n\n                    if (!run)\n\n                        for (run=9, i=0; i<6; i++)\n\n                            run += vp56_rac_get_prob(c, model3[i+8]) << i;\n\n                }\n\n            }\n\n            coeff_idx += run;\n\n            if (coeff_idx >= 64)\n\n                break;\n\n            cg = vp6_coeff_groups[coeff_idx];\n\n            model1 = model2 = model->coeff_ract[pt][ct][cg];\n\n        }\n\n\n\n        s->left_block[ff_vp56_b6to4[b]].not_null_dc =\n\n        s->above_blocks[s->above_block_idx[b]].not_null_dc = !!s->block_coeff[b][0];\n\n    }\n\n    return 0;\n\n}\n", "idx": 18578, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "t", "rs", "aws", "conf", "f", "sv", "settings", "services", "service", "r", "n", "sb", "g", "sl", "ss", "ls", "sim", "sec", "xs", "is", "o", "cs", "l", "d", "su", "space", "site", "qs", "e", "ssl", "ses", "sync", "v", "js", "si", "sym", "p", "support", "S", "ks", "gs", "sys", "u", "a", "es", "states", "os", "south", "sets", "sq", "se", "ds", "sf"], "c": ["dc", "ic", "oc", "m", "ch", "t", "f", "vc", "conn", "rc", "r", "n", "cf", "g", "coll", "bc", "cp", "mc", "self", "cy", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "com", "con", "config", "tc", "e", "cu", "k", "cl", "v", "lc", "cur", "p", "uc", "cache", "col", "ec", "cell", "a", "C", "cc", "u"], "model": ["m", "db", "mod", "global", "code", "data", "view", "core", "f", "image", "base", "mode", "engine", "gu", "service", "mi", "cm", "bm", "center", "cf", "g", "module", "document", "sl", "query", "package", "coll", "block", "source", "models", "mc", "scope", "manager", "ml", "sm", "ca", "l", "bank", "config", "ga", "general", "man", "v", "lib", "p", "Model", "cache", "cell", "mm", "server", "custom", "cc"], "permute": ["smut", "permut", "computation", "permutation", "smutation", "smute", "mutes", "comput", "mute", "computes", "mutation", "smutes", "compute", "permutes", "mut"], "model1": ["models3", "form1", "form4", "model8", "module8", "modulen", " model8", "module1", "moduleOne", "Model_", "Model4", "model4", "model_", "modelsOne", "module2", "Model1", "Model2", "Model8", "modelOne", "modelsn", " model_", "module3", " model4", " modeln", "Model3", "form_", "modeln", "models1", " modelOne", "form2"], "model2": [" model5", "layer2", "key1", "moduletwo", "model8", "modelSecond", "link2", "image2", "module8", "block8", " model8", "keyTwo", "module1", "block4", "Model4", "linkTwo", "model4", "method2", "module2", "layer1", "module0", "block0", "image5", "imageSecond", "Model1", "Model2", "method5", " modeltwo", "module4", " model0", "layertwo", "module3", "model0", " model4", "Model3", "model5", "image4", "link5", "modeltwo", "methodSecond", "block2", "link1", "key2", " modelTwo", "key5", "layer3", "method4", " modelSecond", "modelTwo"], "model3": ["image3", "image4", "image6", "module4", "model4", "image2", "module3", "model6", " model4", "module2", " model6", "module6"], "coeff": ["poefficient", "Coefficient", "coef", "koef", "poeff", "poff", "Coff", " coefficient", " coff", "coefficient", "coff", "Coeff", "poef", "koeff", " coef", "colefficient", "coleff", "colef", "Coef", "koff", "koefficient", "colff"], "sign": ["scale", "sup", "init", "mod", "shape", "err", "ss", "pass", "ind", "pos", "sec", "min", "act", "enc", "ign", "cost", "rib", "roll", "iss", "sc", "sum", "iv", "weight", "diff", "circ", "round"], "coeff_idx": ["coeff_Idz", "coeff_indst", "coeff_numx", "coeff_idw", "coeff_IdX", "coeff_numz", "coeff_Idst", "coeff_numj", "coeff_idst", "coeff_idz", "coeff_pidz", "coeff_pidx", "coeff_inx", "coeff_Idw", "coeff_indx", "coeff_pidX", "coeff_idj", "coeff_numX", "coeff_indz", "coeff_Idj", "coeff_pidw", "coeff_Idx", "coeff_inz", "coeff_idX", "coeff_inst"], "b": ["ab", "eb", "br", "j", "db", "bs", "t", "x", "f", "base", "ob", "r", "n", "sb", "cb", "bc", "wb", "B", "pb", "bt", "lb", "bb", "nb", "l", "d", "gb", "bar", "bf", "w", "mb", "k", "e", "bot", "fb", "bh", "v", "emb", "bl", "rb", "bas", "be", "p", "h", "boot", "a", "y", "ib", "u"], "i": ["ti", "uri", "gi", "m", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "io", "mi", "ai", "phi", "n", "g", "hi", "z", "ii", "ori", "iu", "index", "mini", "di", "I", "multi", "o", "ip", "chi", "l", "d", "oi", "pi", "ui", "ci", "id", "start", "e", "k", "v", "ni", "si", "ri", "p", "xi", "u", "h", "it", "eni", "my", "fi", "value", "y", "li", "ib", "mu"], "cg": ["ccg", "cw", "ccw", "ccgs", "catgi", "cgs", "catw", " cgs", " cw", "cgi", "catgs", "catg", "ccgi", " cgi"], "idx": ["midx", "odx", "pidz", "odxes", "inX", "indf", "idX", "pidy", "Idz", "ody", "idz", "odz", "iny", "idy", "indz", "idex", "midX", "idez", "Idn", "midn", "pidX", " idz", " idi", "Idx", "Idxes", "idi", "idf", "idn", "inx", " idX", "pidx", "IdX", "idxes", " idxes", "inz", "idei", "idey", "ideX", "idef", "indx", "Idy", "iden", "midy", "indi", " idy", " idf"], "ctx": ["pc", "dc", "pt", "x", "cca", "ref", "ct", "vc", "conn", "thread", "rc", "nt", "cm", "cf", "cb", "cp", "bc", "loc", "fc", "kw", "ctrl", "cas", "ca", "cs", "context", "kb", "nc", "tx", "ci", "tc", "xc", "config", "sc", "q", "cu", "sync", "lc", "parent", "temp", "qa", "cmd", "cmp", "unc", "cn", "port", "sq", "kk", "cv", "cc"]}}
{"project": "FFmpeg", "commit_id": "229843aa359ae0c9519977d7fa952688db63f559", "target": 0, "func": "static int ftp_passive_mode_epsv(FTPContext *s)\n\n{\n\n    char *res = NULL, *start = NULL, *end = NULL;\n\n    int i;\n\n    static const char d = '|';\n\n    static const char *command = \"EPSV\\r\\n\";\n\n    static const int epsv_codes[] = {229, 0};\n\n\n\n    if (ftp_send_command(s, command, epsv_codes, &res) != 229 || !res)\n\n        goto fail;\n\n\n\n    for (i = 0; res[i]; ++i) {\n\n        if (res[i] == '(') {\n\n            start = res + i + 1;\n\n        } else if (res[i] == ')') {\n\n            end = res + i;\n\n            break;\n\n        }\n\n    }\n\n    if (!start || !end)\n\n        goto fail;\n\n\n\n    *end = '\\0';\n\n    if (strlen(start) < 5)\n\n        goto fail;\n\n    if (start[0] != d || start[1] != d || start[2] != d || end[-1] != d)\n\n        goto fail;\n\n    start += 3;\n\n    end[-1] = '\\0';\n\n\n\n    s->server_data_port = atoi(start);\n\n    av_dlog(s, \"Server data port: %d\\n\", s->server_data_port);\n\n\n\n    av_free(res);\n\n    return 0;\n\n\n\n  fail:\n\n    av_free(res);\n\n    s->server_data_port = -1;\n\n    return AVERROR(ENOSYS);\n\n}\n", "idx": 18583, "substitutes": {"s": ["ns", "m", "ts", "session", "t", "rates", "aws", "core", "f", "conf", "settings", "services", "service", "r", "n", "sb", "g", "ss", "ls", "ops", "fs", "self", "xs", "is", "o", "cs", "d", "su", "socket", "w", "fts", "qs", "e", "ssl", "ses", "sync", "client", "c", "js", "ps", "si", "sym", "p", "secondary", "S", "b", "ks", "gs", "sys", "u", "storage", "your", "a", "es", "os", "us", "hs", "south", "sets", "ds", "sf"], "res": ["rx", "ms", "ros", "ret", "content", "rs", "info", "rest", "ras", "err", "ix", "rc", "r", "results", "reg", "result", "vals", "details", "rh", "resolution", "Res", "des", "RES", "ry", "resp", "def", "arr", "changes", "cs", "ris", "range", "rec", "ray", "re", "ress", "gr", "pre", "ins", "args", "reset", "blocks", "response", "prev", "id", "remote", "ries", "e", "rev", "req", "rus", "rows", "resource", "rez", "ids", "error", "ons", "rep", "errors", "es", "os", "pres", "rem", "reply", "progress", "params"], "start": ["offset", "x", "str", "show", "max", "ie", "pos", "started", "range", "d", "length", "id", "mid", "p", "test", "next", "source", "part", "init", "work", "rest", "name", "from", "in", "min", "count", "art", "parse", "size", "pre", "stop", "style", "key", "k", "open", "patch", "shift", "time", "r", "root", "Start", "type", "ind", "date", "grade", "starting", "ad", "check", "info", "sp", "get", "old", "step", "first", "space", "cost", "seed", "use", "add", "e", "error", "se", "diff"], "end": ["ion", "inner", "est", "set", "offset", "code", "info", "rest", "name", "all", "r", "n", "then", "END", "max", "index", "pos", "en", "after", "enc", "range", "End", "d", "change", "begin", "stop", "value", "add", "last", "use", "id", "e", "send", "open", "v", "ad", "c", "post", "p", "address", "b", "append", "next", "length", "h", "ension", "edge", "ending", "order", "ended"], "i": ["ti", "gi", "uri", "m", "bi", "j", "code", "t", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "hi", "ii", "in", "ori", "di", "index", "ind", "iu", "I", "ie", "min", "multi", "is", "o", "ip", "l", "d", "rec", "oi", "pi", "ui", "ci", "pri", "w", "abi", "id", "e", "rev", "v", "c", "si", "ri", "xi", "p", "shift", "b", "u", "iv", "api", "it", "eni", "iter", "fi", "one", "y", "li", "len"], "command": ["pattern", "m", "content", "code", "request", "data", "mode", "text", "call", "comment", "attribute", "script", "document", "query", "method", "function", "password", "game", "execute", "description", "exec", "array", "directory", "event", "prefix", "response", "Command", "send", "power", "c", "cmd", "resource", "connection", "message", "sequence", "usage", "operation", "custom"], "epsv_codes": ["epsv_flags", "epsv_errors", "epsv_lines", "epsi_codes", "epsi_lines", "epsi_code", "epsi_errors", "epsi_cod", "epsi_flags", "epsv_code", "epsv_cod"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qemu_enqueue_packet(VLANClientState *sender,\n\n                                const uint8_t *buf, int size,\n\n                                NetPacketSent *sent_cb)\n\n{\n\n    VLANPacket *packet;\n\n\n\n    packet = qemu_malloc(sizeof(VLANPacket) + size);\n\n    packet->sender = sender;\n\n    packet->size = size;\n\n    packet->sent_cb = sent_cb;\n\n    memcpy(packet->data, buf, size);\n\n\n\n    TAILQ_INSERT_TAIL(&sender->vlan->send_queue, packet, entry);\n\n}\n", "idx": 18596, "substitutes": {"sender": ["issiver", "dendor", "sending", "Sent", "dender", "spendor", "Sending", " sener", "issorter", "dent", " siver", "sendor", " susher", " send", "Send", "sorter", "denders", "Sender", "senders", "ssending", "ssender", "ssend", "Senders", "Sener", "send", "issend", "ssener", "sent", "spenders", " senders", "siver", "sener", " sending", "spent", "spender", " sorter", "Sendor", "Susher", "susher", "issender"], "buf": ["data", "lim", "fp", "base", "pool", "buffer", "rc", "vec", "feed", "pack", "window", "cb", "bc", "src", "msg", "ctx", "pb", "enc", "context", "gb", "box", "flow", "queue", "bd", "length", "fd", "config", "buff", "batch", "fb", "seq", "cmd", "b", "alloc", "bytes", "frame", "uf", "cv", "len"], "size": ["set", "scale", "offset", "content", "capacity", "small", "time", "mode", "SIZE", "name", "code", "shape", "data", "rc", "cm", "sized", "pack", "g", "type", "six", "loc", "source", "timeout", "en", "count", "enc", "empty", "complete", "large", "args", "use", "ize", "length", "e", "send", "sync", "unit", "c", "iz", "address", "sent", "sum", "fee", "export", "Size", "end", "server", "len"], "sent_cb": ["sent2cb", "send_rb", "sentityfun", "sent2sec", "send_cb", "sent_rb", " sent_handler", "sentingcallback", "sent_callback", "send_callback", "sent_sec", "sentitycb", "sentityfunction", "sent_function", " sent_fun", " sent_function", "sentitycallback", "sentingfun", "sent2callback", "sentingcb", "sent_handler", "sent_fun", "sent2rb", "sentingfunction", " sent_callback", "send_sec"], "packet": ["macet", "appeter", "assat", "packageel", "maceter", "compet", "packageeter", "packel", "compat", "octet", "octeter", "plugett", "packew", "packen", "competer", "octset", " packacket", "compel", "viewacket", " packett", " packew", " packette", "appacket", "asset", "packagelet", "octacket", "packett", "packageew", "viewset", "viewet", "octeting", "compette", "passeter", "pluget", "passette", "packeting", "maceting", "compett", " packeter", "compen", " packen", "packageet", "passet", "assacket", "packageat", "passacket", "assel", "compacket", "packlet", "appset", "packeter", "vieweting", "plugacket", "plugen", "packset", "appet", "macacket", "vieweter", "packette", "packageacket", "complet", "packat", "compew", "packacket", "packageette", " packlet"]}}
{"project": "qemu", "commit_id": "7d6b1daedd00b35e50ce87ea835f662b36a23160", "target": 0, "func": "static inline uint64_t cpu_ppc_get_tb(CPUPPCState *env)\n\n{\n\n    /* TO FIX */\n\n    return 0;\n\n}\n", "idx": 18597, "substitutes": {"env": ["txt", "init", "code", "conf", "err", "obj", "dir", "cb", "bc", "np", "environment", "ctx", "scope", "ptr", "en", "enc", "context", "style", "ev", "config", "e", "buf", "bg", "dev", "ec", "proc", "iv", "dict"]}}
{"project": "qemu", "commit_id": "22156ab498acf5f8104801148732ae8e83f336a0", "target": 0, "func": "uint16_t net_checksum_tcpudp(uint16_t length, uint16_t proto,\n\n                             uint8_t *addrs, uint8_t *buf)\n\n{\n\n    uint32_t sum = 0;\n\n\n\n    sum += net_checksum_add(length, buf);         // payload\n\n    sum += net_checksum_add(8, addrs);            // src + dst address\n\n    sum += proto + length;                        // protocol & length\n\n    return net_checksum_finish(sum);\n\n}\n", "idx": 18598, "substitutes": {"length": ["offset", "shape", "code", "text", "ch", "buffer", "duration", "family", "block", "type", "match", "loc", "th", "padding", "count", "range", "l", "size", "cost", "build", "buff", "cur", "position", "seq", "url", "address", "sum", "h", "number", "weight", "Length", "port", "end", "word", "len"], "proto": ["protcer", "pex", "Prof", "protx", "peco", "prob", "proco", "Prob", "preb", "protocol", "prox", "precer", "Proocol", "proocol", "protto", "pecer", "procer", "peto", "prex", "prof", "Proto", "protco", "preocol", "preco", "preto", "pref", "protf", "protb"], "addrs": ["addls", "attresses", "ddr", "addros", "attrs", "ddrs", "adros", " addros", "attros", "ddls", "ddresses", "adrs", "adresses", " addresses", "adls", "adr", "addresses", "attls", "addr", " addr", "attr"], "buf": ["br", "data", "text", "ctr", "pool", "buffer", "rc", "vec", "cf", "cb", "src", "padding", "raw", "header", "array", "uint", "aux", "queue", "mount", "config", "buff", "cur", "rb", "seq", "cmd", "binary", "address", "pad", "b", "alloc", "addr", "port", "uf", "each", "cv", "len"]}}
{"project": "qemu", "commit_id": "cea5f9a28faa528b6b1b117c9ab2d8828f473fef", "target": 0, "func": "void cpu_loop_exit(CPUState *env1)\n\n{\n\n    env1->current_tb = NULL;\n\n    longjmp(env1->jmp_env, 1);\n\n}\n", "idx": 18614, "substitutes": {"env1": ["environmentOne", "envOne", " envOne", "encOne", "en7", "environment1", "excone", "environment2", "env5", "env2", "en1", " env7", "encone", "enc2", " env2", " env5", "enc5", "enc1", "environmentone", "excOne", "env7", "en5", " envone", "envone", "enc7", "exc1"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void ppc_hw_interrupt (CPUPPCState *env)\n\n{\n\n    int raised = 0;\n\n\n\n#if 1\n\n    if (loglevel & CPU_LOG_INT) {\n\n        fprintf(logfile, \"%s: %p pending %08x req %08x me %d ee %d\\n\",\n\n                __func__, env, env->pending_interrupts,\n\n                env->interrupt_request, msr_me, msr_ee);\n\n    }\n\n#endif\n\n    /* Raise it */\n\n    if (env->pending_interrupts & (1 << PPC_INTERRUPT_RESET)) {\n\n        /* External reset / critical input */\n\n        /* XXX: critical input should be handled another way.\n\n         *      This code is not correct !\n\n         */\n\n        env->exception_index = EXCP_RESET;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_RESET);\n\n        raised = 1;\n\n    }\n\n    if (raised == 0 && msr_me != 0) {\n\n        /* Machine check exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_MCK)) {\n\n            env->exception_index = EXCP_MACHINE_CHECK;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_MCK);\n\n            raised = 1;\n\n        }\n\n    }\n\n    if (raised == 0 && msr_ee != 0) {\n\n#if defined(TARGET_PPC64H) /* PowerPC 64 with hypervisor mode support */\n\n        /* Hypervisor decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_HDECR)) {\n\n            env->exception_index = EXCP_HDECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_HDECR);\n\n            raised = 1;\n\n        } else\n\n#endif\n\n        /* Decrementer exception */\n\n        if (env->pending_interrupts & (1 << PPC_INTERRUPT_DECR)) {\n\n            env->exception_index = EXCP_DECR;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DECR);\n\n            raised = 1;\n\n        /* Programmable interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_PIT)) {\n\n            env->exception_index = EXCP_40x_PIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_PIT);\n\n            raised = 1;\n\n        /* Fixed interval timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_FIT)) {\n\n            env->exception_index = EXCP_40x_FIT;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_FIT);\n\n            raised = 1;\n\n        /* Watchdog timer on embedded PowerPC */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_WDT)) {\n\n            env->exception_index = EXCP_40x_WATCHDOG;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_WDT);\n\n            raised = 1;\n\n        /* External interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_EXT)) {\n\n            env->exception_index = EXCP_EXTERNAL;\n\n            /* Taking an external interrupt does not clear the external\n\n             * interrupt status\n\n             */\n\n#if 0\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_EXT);\n\n#endif\n\n            raised = 1;\n\n#if 0 // TODO\n\n        /* Thermal interrupt */\n\n        } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_THERM)) {\n\n            env->exception_index = EXCP_970_THRM;\n\n            env->pending_interrupts &= ~(1 << PPC_INTERRUPT_THERM);\n\n            raised = 1;\n\n#endif\n\n        }\n\n#if 0 // TODO\n\n    /* External debug exception */\n\n    } else if (env->pending_interrupts & (1 << PPC_INTERRUPT_DEBUG)) {\n\n        env->exception_index = EXCP_xxx;\n\n        env->pending_interrupts &= ~(1 << PPC_INTERRUPT_DEBUG);\n\n        raised = 1;\n\n#endif\n\n    }\n\n    if (raised != 0) {\n\n        env->error_code = 0;\n\n        do_interrupt(env);\n\n    }\n\n}\n", "idx": 18619, "substitutes": {"env": ["status", "enable", "viron", "txt", "db", "session", "global", "extra", "data", "core", "conf", "err", "cdn", "net", "engine", "eu", "ne", "n", "exc", "loader", " environment", "np", "oa", "shell", "environment", "ext", "scope", "init", "console", "manager", "en", "eng", "her", "enc", "vm", "exec", "context", "inet", "event", "nc", "args", "style", "Environment", "site", "config", "ev", "e", "vs", "qt", "client", "v", "nw", "ea", "dev", "stage", "qa", "que", "cache", "output", "ec", "et", "er", "export", "state", "end", "server", "el", "dict", "cv", "conn"]}}
{"project": "qemu", "commit_id": "23979dc5411befabe9049e37075b2b6320debc4e", "target": 0, "func": "gen_intermediate_code_internal(CPUState *env, TranslationBlock *tb,\n\n                               int search_pc)\n\n{\n\n    uint16_t *gen_opc_end;\n\n    uint32_t pc_start;\n\n    int j, lj;\n\n    struct DisasContext ctx;\n\n    struct DisasContext *dc = &ctx;\n\n    uint32_t next_page_start, org_flags;\n\n    target_ulong npc;\n\n    int num_insns;\n\n    int max_insns;\n\n\n\n    qemu_log_try_set_file(stderr);\n\n\n\n    pc_start = tb->pc;\n\n    dc->env = env;\n\n    dc->tb = tb;\n\n    org_flags = dc->synced_flags = dc->tb_flags = tb->flags;\n\n\n\n    gen_opc_end = gen_opc_buf + OPC_MAX_SIZE;\n\n\n\n    dc->is_jmp = DISAS_NEXT;\n\n    dc->jmp = 0;\n\n    dc->delayed_branch = !!(dc->tb_flags & D_FLAG);\n\n    dc->pc = pc_start;\n\n    dc->singlestep_enabled = env->singlestep_enabled;\n\n    dc->cpustate_changed = 0;\n\n    dc->abort_at_next_insn = 0;\n\n    dc->nr_nops = 0;\n\n\n\n    if (pc_start & 3)\n\n        cpu_abort(env, \"Microblaze: unaligned PC=%x\\n\", pc_start);\n\n\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n#if !SIM_COMPAT\n\n        qemu_log(\"--------------\\n\");\n\n        log_cpu_state(env, 0);\n\n#endif\n\n    }\n\n\n\n    next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE;\n\n    lj = -1;\n\n    num_insns = 0;\n\n    max_insns = tb->cflags & CF_COUNT_MASK;\n\n    if (max_insns == 0)\n\n        max_insns = CF_COUNT_MASK;\n\n\n\n    gen_icount_start();\n\n    do\n\n    {\n\n#if SIM_COMPAT\n\n        if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], dc->pc);\n\n            gen_helper_debug();\n\n        }\n\n#endif\n\n        check_breakpoint(env, dc);\n\n\n\n        if (search_pc) {\n\n            j = gen_opc_ptr - gen_opc_buf;\n\n            if (lj < j) {\n\n                lj++;\n\n                while (lj < j)\n\n                    gen_opc_instr_start[lj++] = 0;\n\n            }\n\n            gen_opc_pc[lj] = dc->pc;\n\n            gen_opc_instr_start[lj] = 1;\n\n                        gen_opc_icount[lj] = num_insns;\n\n        }\n\n\n\n        /* Pretty disas.  */\n\n        LOG_DIS(\"%8.8x:\\t\", dc->pc);\n\n\n\n        if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO))\n\n            gen_io_start();\n\n\n\n        dc->clear_imm = 1;\n\n\tdecode(dc);\n\n        if (dc->clear_imm)\n\n            dc->tb_flags &= ~IMM_FLAG;\n\n        dc->pc += 4;\n\n        num_insns++;\n\n\n\n        if (dc->delayed_branch) {\n\n            dc->delayed_branch--;\n\n            if (!dc->delayed_branch) {\n\n                if (dc->tb_flags & DRTI_FLAG)\n\n                    do_rti(dc);\n\n                 if (dc->tb_flags & DRTB_FLAG)\n\n                    do_rtb(dc);\n\n                if (dc->tb_flags & DRTE_FLAG)\n\n                    do_rte(dc);\n\n                /* Clear the delay slot flag.  */\n\n                dc->tb_flags &= ~D_FLAG;\n\n                /* If it is a direct jump, try direct chaining.  */\n\n                if (dc->jmp != JMP_DIRECT) {\n\n                    eval_cond_jmp(dc, env_btarget, tcg_const_tl(dc->pc));\n\n                    dc->is_jmp = DISAS_JUMP;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (env->singlestep_enabled)\n\n            break;\n\n    } while (!dc->is_jmp && !dc->cpustate_changed\n\n         && gen_opc_ptr < gen_opc_end\n\n                 && !singlestep\n\n         && (dc->pc < next_page_start)\n\n                 && num_insns < max_insns);\n\n\n\n    npc = dc->pc;\n\n    if (dc->jmp == JMP_DIRECT) {\n\n        if (dc->tb_flags & D_FLAG) {\n\n            dc->is_jmp = DISAS_UPDATE;\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n            sync_jmpstate(dc);\n\n        } else\n\n            npc = dc->jmp_pc;\n\n    }\n\n\n\n    if (tb->cflags & CF_LAST_IO)\n\n        gen_io_end();\n\n    /* Force an update if the per-tb cpu state has changed.  */\n\n    if (dc->is_jmp == DISAS_NEXT\n\n        && (dc->cpustate_changed || org_flags != dc->tb_flags)) {\n\n        dc->is_jmp = DISAS_UPDATE;\n\n        tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    }\n\n    t_sync_flags(dc);\n\n\n\n    if (unlikely(env->singlestep_enabled)) {\n\n        t_gen_raise_exception(dc, EXCP_DEBUG);\n\n        if (dc->is_jmp == DISAS_NEXT)\n\n            tcg_gen_movi_tl(cpu_SR[SR_PC], npc);\n\n    } else {\n\n        switch(dc->is_jmp) {\n\n            case DISAS_NEXT:\n\n                gen_goto_tb(dc, 1, npc);\n\n                break;\n\n            default:\n\n            case DISAS_JUMP:\n\n            case DISAS_UPDATE:\n\n                /* indicate that the hash table must be used\n\n                   to find the next TB */\n\n                tcg_gen_exit_tb(0);\n\n                break;\n\n            case DISAS_TB_JUMP:\n\n                /* nothing more to generate */\n\n                break;\n\n        }\n\n    }\n\n    gen_icount_end(tb, num_insns);\n\n    *gen_opc_ptr = INDEX_op_end;\n\n    if (search_pc) {\n\n        j = gen_opc_ptr - gen_opc_buf;\n\n        lj++;\n\n        while (lj <= j)\n\n            gen_opc_instr_start[lj++] = 0;\n\n    } else {\n\n        tb->size = dc->pc - pc_start;\n\n                tb->icount = num_insns;\n\n    }\n\n\n\n#ifdef DEBUG_DISAS\n\n#if !SIM_COMPAT\n\n    if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) {\n\n        qemu_log(\"\\n\");\n\n#if DISAS_GNU\n\n        log_target_disas(pc_start, dc->pc - pc_start, 0);\n\n#endif\n\n        qemu_log(\"\\nisize=%d osize=%td\\n\",\n\n            dc->pc - pc_start, gen_opc_ptr - gen_opc_buf);\n\n    }\n\n#endif\n\n#endif\n\n    assert(!dc->abort_at_next_insn);\n\n}\n", "idx": 18620, "substitutes": {"gen_opc_end": ["gen_opc2end", "gen_opc_begin", "gen_opcs_End", "gen_opcu_len", "gen_opc2End", "gen_opc_End", "gen_opcu_END", "gen_opc_len", "gen_opcu_end", "gen_opcu_start", "gen_opc2start", "gen_opc_start", "gen_opcs_end", "gen_opc_END", "gen_opcs_begin", "gen_opc2begin", "gen_opcs_start"], "pc_start": ["pc__done", "pc__end", "pc_pos", "pc67id", "pc_add", "pc_size", "vc67pos", "pcPstart", "pc64start", "cpu_add", "pc_count", "page_end", "pc67end", "pcPend", "pc_stop", "pc__size", "page_id", "pc0start", "arc67start", "pcMid", "pc_part", "arc67pos", "cpu_part", "pcMend", "cpu_start", "pc67size", "vc_start", "vc67started", "arc67id", "PC_start", "vc67last", "pc64started", "arc_start", "page_stop", "pcPadd", "arc67size", "pc0part", "PC_done", "pcMdone", "pc64last", "pcPstarted", "vc_last", "pc67start", "cpu_count", "arc_id", "pcMsize", "pc67add", "pc_id", "pc67started", "PC_end", "vc67start", "pc67pos", "pc0end", "pc67last", "pc_last", "arc_size", "pc__start", "pc_started", "pc_end", "pc64pos", "PC_size", "vc_started", "pc_done", "pc0count", "page_start", "arc_pos", "vc_pos", "pcMstart", "cpu_end", "cpu_started", "pcMpos"], "j": ["jc", "x", "jp", "obj", "uj", "r", "adj", "n", "jj", "job", "num", "i", "z", "ii", "ij", "aj", "out", "l", "jen", "J", "kj", "v", "js", "p", "lock", " i", "im"], "lj": ["llj", "lbji", " ljp", "lljp", " lb", "lbj", "lbJ", "lckey", "lcjp", "lcJ", "ljp", "lb", " ljl", "lji", "lkey", "lljl", "lJ", "lbb", "lcjl", "llkey", " lkey", " lji", " lJ", "lcj", "ljl", "lcb", "lcji"], "ctx": ["cc", "cfg", "func", "fp", "cca", "ctl", "rc", "cm", "cb", "bc", "cp", " context", " c", "kw", "ctrl", "cas", "Context", "ca", "exec", "context", "class", "nc", "tx", "aux", "ci", "config", "xc", "cu", "lc", " gcc", " cx", "c", "lib", "cmd", "cache", "cmp", "null", "ec", " rc", "conn"], "dc": ["cfg", "thread", "cf", "enc", "design", "exec", "d", "feat", "config", "id", "ea", "da", "dat", "die", "cc", "conn", "input", "pc", "cdn", "cca", "dest", "ctr", "vc", "rc", "de", "bc", "dt", "mc", "controller", "disc", "DC", "sc", "lc", "uc", "ec", "mac", "wp", "jc", "uci", "r", "loc", "di", "git", "ctrl", "auc", "dm", "ga", "c", "device", "doc", "cd", "db", "func", "dir", "all", "gc", "g", "enter", "fc", "acl", "abc", "context", "df", "draw", "nc", "ac", "args", "tc", "dr", "client", "_", "seq", "director"], "next_page_start": ["next_page2st", "next_page2start", "next_page2end", "next_page___stop", "next_page___end", "next_page_end", "next_page2size", "next_page_size", "next_page_stop", "next_page___start", "next_page_send", "next_page___send", "next_page_st"], "org_flags": ["org_ops", "orgityflags", "org_alls", " org_rules", "org_items", "orgityalls", " org_ops", "org_flag", "org__alls", "org_settings", " org_items", " org_alls", "org__flags", "org__ops", "org_rules", " org_settings", "orgityops", " org_flag", "orgityrules", "org__rules"], "npc": ["ndpd", "ndc", "ndpc", "nc", "lcpu", "ndcpu", "unc", "unpc", "lpc", "ncpu", "uncpu", "lc", "unpd", "npd", "lpd"], "num_insns": ["num_asinn", "num_intsens", "num_insnos", "num_incn", "num_incni", "num_inens", "num_inni", "num_asinnos", "num_outns", "num_inns", "num_incs", "num_asinni", "num_innos", "num_incnos", "num_outn", "num_insn", "num_insni", "num_inscs", "num_outcs", "num_intsn", "num_asinns", "num_inn", "num_intscs", "num_outens", "num_incns", "num_insens", "num_intsns"], "max_insns": ["max_lincs", "max_incks", "max_innn", "max_vinks", "max_innnes", "max_inNs", "max_links", "max_insks", "max_incs", "max_inns", "max_wincs", "max_inncs", "max_linnes", "max_innns", "max_innes", "max_vinns", "max_innis", "max_inscs", "max_insnis", "max_vinNs", "max_inccs", "max_insn", "max_insnes", "max_winks", "max_incnis", "max_incns", "max_minsn", "max_winn", "max_inks", "max_incNs", "max_minsns", "max_minsnis", "max_linns", "max_inn", "max_vinn", "max_insNs", "max_linn", "max_winns", "max_minscs", "max_incn"], "delayed_branch": ["delayed_trruction", "delayed_franch", "delayed_blruction", "delayed_brant", "delayed_tranc", "delayed_trant", "delayed_blanch", "delayed_blant", "delayed_branc", "delayed_frant", "delayed_tranch", "delayed_blanc", "delayed_brruction", "delayed_franc", "delayed_frruction"]}}
{"project": "FFmpeg", "commit_id": "d1916d13e28b87f4b1b214231149e12e1d536b4b", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624, "substitutes": {"dst": ["sdbl", "Dst", "rdsrc", "rdst", "rdsts", "Dfe", "dsST", "sdput", "dssrc", " dbl", "dsbl", "dfe", "dsrc", "rdST", "adsrc", "udsrc", "dsst", "sdfe", "sdst", "udST", " dput", "adst", "adST", "udst", "adbl", "Dput", " dsrc", "dput", " dfe", " dsts", "dssts", "dST", " dST", "Dbl", "dsts", "dbl", "udbl"], "src1": [" srca", "rcA", "scb", "rc2", "src3", "src0", "srcb", "srcA", "source1", "sc0", "sourcea", " srcb", "rc3", "source2", "sourceA", "source0", " srcA", "seqb", "sc1", "sourceb", "source3", "rc1", "srca", "rca", "rcb", "seqA", "sc3", "seq2", "seq1", "rc0"], "src2": ["gb82", "loadb", "load1", " src0", " srcB", "rc2", "src0", "srcb", "config82", "configtwo", "source1", "rcB", " srcb", "config02", "srctwo", "src82", "source2", "gbtwo", " src02", "source0", "gb02", " srctwo", "loadB", "config2", "load2", "sourceb", "gb2", "rc1", "src02", "rcb", "rc0", " src82", "srcB"], "w": ["wei", "wt", "m", "fw", "wed", "t", "wx", "x", "f", "r", "n", "wl", "we", "g", "window", "sw", "z", "max", "wb", "ow", "iw", "kw", "ew", "l", "hw", "d", "W", "ww", "q", "k", "v", "c", "nw", "p", "tw", "win", "wh", "wa", "h", "aw", "u", "weight", "wave"], "i": ["gi", "ti", "uri", "m", "bi", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "hi", "z", "ii", "ie", "in", "di", "index", "iu", "I", "multi", "zi", "o", "l", "adi", "d", "oi", "yi", "pi", "ui", "ci", "abi", "id", "e", "k", "v", "cli", "ni", "c", "si", "lc", "ri", "xi", "p", "b", "mu", "a", "api", "it", "fi", "y", "li", "ib", "u"]}}
{"project": "qemu", "commit_id": "7453c96b78c2b09aa72924f933bb9616e5474194", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629, "substitutes": {"bs": ["ns", "ms", "ros", "org", "bi", "ts", "rs", "ras", "base", "las", "obj", "plugins", "ubs", "sb", "cb", "bc", "ls", "ss", "bing", "pb", "fs", "bb", "lines", "cs", "ris", "css", "gb", "bos", "ins", "bps", "obs", "outs", "BS", "iss", "bis", "bl", "bh", "vs", "bas", "ses", "js", "ps", "fb", "bits", "rss", "b", "ks", "http", "gs", "os", "bes", "ds", "oss"], "res": ["rx", "ms", "spec", "rr", "ros", "rates", "rs", "ras", "err", "ref", "rest", "rc", "r", "results", "reg", "report", "rel", "result", "vals", "details", "reed", "ss", "resolution", "resources", "Res", "RES", "ry", "resp", "def", "changes", "cs", "ris", "re", "ress", "gr", "resh", "mr", "tx", "reset", "response", "rev", "req", "js", "ps", "rus", "rss", "rows", "rys", "resource", "rez", "sys", "os", "us", "pres", "rem", "reply", "ver"], "fix": ["fixes", "init", "conf", "err", "call", "op", "commit", "ix", "FIX", "r", "apply", "result", "Fix", "mask", "def", "replace", "force", "re", "change", "diff", "reset", "add", "correct", "config", "prefix", "prev", "start", "pull", "delay", "back", "update", "patch", " Fix", "b", "next", "check", "valid", "before", "bug"], "rebuild": [" unreuild", "reboot", "restall", "renboot", "renbuild", "reshold", "refupdate", "Rebreak", " unrebuild", "reuild", "renstall", "prestall", "preboot", "prebuild", "resbuild", " unreboot", "rebreak", "Rehold", "renuild", "preuild", "refhold", "rehold", "Reupdate", "refbreak", "refbuild", "reupdate", "Rebuild", " unrestall", "resbreak", "resupdate"], "refcount_table": ["refcountingarray", "refCount_time", "refprocessingservice", "refcountingtime", "refcount_required", "refCount_cache", "refcount_result", "refount_tab", "refcounttmodule", "refcount_window", "refount_table", "refcount_t", "refcount_module", "reflast_table", "refgroup_t", "refcount_database", "refcountNresult", "refcountttable", "refcounttsession", "refcountingservice", "refprocess_service", "refCount_Table", "refcount1table", "refcount_Table", "refcountgdatabase", "refcount24service", "refcountentable", "reflast_integer", "refgroup_table", "refpool_module", "refCount_window", "refcountingtab", "refcounttTABLE", "refprocessingtab", "refcountent", "refount_cache", "refcountxdatabase", "refCount_array", "refcountingrequired", "refCount_table", "reflastpletable", "refgroupent", "refCount_database", "refcountingtable", "refcount24required", "refcountplesession", "refgroup_array", "refcount_TABLE", "refcountNTable", "refcount24tab", "refcountableresource", "refCount_total", "refcount_time", "refcountablet", "refCount_required", "refcountxtable", "refprocessingtable", "refcountenarray", "refcountabletable", "reflastpleinteger", "refcountertable", "refcountxwindow", "refcountgtable", "refpool_table", "refcounttt", "refcountpleinteger", "refgroup_resource", "refcount1resource", "refgroupentable", "refpool_TABLE", "refcountgwindow", "refprocess_required", "reflastplet", "refcount_integer", "reflastplesession", "refcount_resource", "refcountgtotal", "refprocess_table", "refcount_service", "refcounterservice", "refcountablearray", "refcount1array", "refgroupenresource", "refcounterrequired", "refCount_result", "refgroupenarray", "refcount_array", "refcount_session", "refcount_cache", "refcountingTable", "refcountplet", "refcount_total", "refcounttinteger", "refpool_t", "refcountingcache", "refcountertab", "reflast_t", "refprocess_tab", "refcountxtotal", "refcountNtable", "refcount_tab", "reflast_session", "refcount24table", "refcountpletable", "refcountenresource", "refcount1t", "refprocessingrequired"], "nb_clusters": ["nboseclusters", "nb_fliffs", "nb_kluster", "nbosesplusters", "nb_slambers", "nb_shorders", "nb_lcappers", "nb_clores", "nbovulibraries", "nbovulusters", "nballclambers", "nb_klibraries", "nb_gluster", "nb_colambers", "nb_ulusters", "nb_ulros", "nb_slers", "nb_sclambers", "nb_clers", "nb_shuster", "nb_glores", "nb_shusters", "nb_flusters", "nb_plusters", "nb_spliffs", "nb_Clicas", "nb_lciffs", "nb_splusters", "nb_clients", "nbovulows", "nbosesplappers", "nb_sclorders", "nb_splappers", "nb_splodes", "nb_scluster", "nb_CLappers", "nb_clicas", "nb_colusters", "nbovcluster", "nb_CLicas", "nb_Cluster", "nb_CLambers", "nballlicayers", "nballclers", "nb_clodes", "nballclayers", "nb_CLorders", "nbovuluster", "nbosespluster", "nb_licambers", "nb_glients", "nbosecluster", "nb_ulows", "nb_flodes", "nboseclros", "nb_klows", "nb_clros", "nb_clorders", "nb_plows", "nb_clibraries", "nb_klusters", "nb_CLows", "nb_cluster", "nb_clayers", "nb_glusters", "nb_slusters", "nb_gallows", "nb_clambers", "nb_gallores", "nb_plients", "nbovclibraries", "nballlicers", "nb_colayers", "nballlicambers", "nb_clows", "nb_ulibraries", "nb_plores", "nb_splros", "nb_cliffs", "nb_colers", "nb_CLusters", "nb_plicas", "nb_flappers", "nb_Clusters", "nb_Clores", "nb_CLuster", "nb_shambers", "nb_licayers", "nb_ulappers", "nb_CLibraries", "nballclusters", "nb_pluster", "nballlicusters", "nb_slayers", "nbovclows", "nb_lcodes", "nb_licers", "nbosesplros", "nb_galluster", "nb_CLients", "nb_licusters", "nb_CLros", "nb_CLores", "nb_clappers", "nb_uluster", "nb_lcusters", "nbovclusters", "nb_gallusters", "nb_spluster", "nboseclappers", "nb_Clients", "nb_sclusters"], "s": ["ns", "spec", "full", "settings", "service", "details", "ss", "cs", "als", "qs", "sym", "p", "h", "us", "sets", "m", "ts", "sg", "rs", "self", "o", "su", "v", "si", "S", "a", "ds", "ans", "f", "r", "results", "sb", "as", "l", "ins", "bis", "c", "ps", "secondary", "b", "sys", "es", "state", "states", "session", "stats", "rates", "services", "n", "ubs", "g", "sl", "ls", "ops", "fs", "xs", "is", "css", "sites", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "server", "y"], "i": ["uri", "bi", "ji", " reply", "x", "qi", "gu", "ai", "phi", "ie", " rest", "d", "pi", "id", "ni", "xi", "p", "h", "it", "fi", "gi", " inf", "j", " j", "name", "ix", "ini", " rep", "iu", "I", "o", "key", "k", "v", "ki", "si", "ri", " mi", " index", "ib", "ti", "ami", " pri", "mi", "ii", "di", "mini", "vi", "zi", " pi", "chi", "l", " li", "yi", "ci", "c", " ii", "eni", "mu", "ik", "info", " bi", "io", " fin", "n", " si", "z", "index", " info", "is", "ip", "ui", "e", " fi", " ie", "y", "li", " err", "u"], "sn": ["ns", "na", "dn", "Sn", "sv", "sp", "ne", "n", "syn", "sb", "sw", "sl", "ny", "ii", "ski", "nb", "sd", "sm", "sk", "su", "nr", "sh", "kn", "sch", "sr", "sc", "sync", "span", "scl", "sam", "SN", "si", "ni", "cl", "bn", "sid", "fn", "cn", "nn", "eni", "an", "sa", "li", "sf"], "ret": ["obj", "bit", "ref", "over", "true", "nt", "debug", "result", "num", "job", "str", "ut", "run", "att", "feat", "reset", "fit", "rev", "hard", "test", "repl", "rep", "opt", "mt", "end", "valid", "it", "pt", "len", "part", "rc", "fun", "done", "rf", "arg", "art", "Ret", "pre", "bf", "key", "cat", "off", "gt", "RET", "pret", "pet", "et", "ft", "ver", "status", "code", "f", "base", "err", "alt", "lit", "rt", "match", "val", "re", " result", "post", "py", "reply", "value", "success", "group", "data", "info", "let", "reg", "flag", "pass", "ext", "def", "rets", "ber", "lt", "out", "en", "format", "fail", "det", "req", "url", "error", "red"], "check_errors": ["check___codes", "check___fixes", "checking_codes", "check___errors", "checking___fixes", "check_fixes", "check_codes", "checking___errors", "checkingcodes", "checkingerrors", "check_error", "checking_errors", "checking___codes", "checking_fixes", "check___error", "checkingerror", "checking___error", "checking_error", "checkingfixes"]}}
{"project": "qemu", "commit_id": "40545f84cfcbe4b73cca040b3043a1c2de935762", "target": 1, "func": "static void ne2000_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    NE2000State *s = opaque;\n\n    int offset, page;\n\n\n\n    addr &= 0xf;\n\n#ifdef DEBUG_NE2000\n\n    printf(\"NE2000: write addr=0x%x val=0x%02x\\n\", addr, val);\n\n#endif\n\n    if (addr == E8390_CMD) {\n\n        /* control register */\n\n        s->cmd = val;\n\n        if (val & E8390_START) {\n\n            s->isr &= ~ENISR_RESET;\n\n            /* test specific case: zero length transfert */\n\n            if ((val & (E8390_RREAD | E8390_RWRITE)) &&\n\n                s->rcnt == 0) {\n\n                s->isr |= ENISR_RDC;\n\n                ne2000_update_irq(s);\n\n            }\n\n            if (val & E8390_TRANS) {\n\n                qemu_send_packet(s->nd, s->mem + (s->tpsr << 8), s->tcnt);\n\n                /* signal end of transfert */\n\n                s->tsr = ENTSR_PTX;\n\n                s->isr |= ENISR_TX;\n\n                ne2000_update_irq(s);\n\n            }\n\n        }\n\n    } else {\n\n        page = s->cmd >> 6;\n\n        offset = addr | (page << 4);\n\n        switch(offset) {\n\n        case EN0_STARTPG:\n\n            s->start = val << 8;\n\n            break;\n\n        case EN0_STOPPG:\n\n            s->stop = val << 8;\n\n            break;\n\n        case EN0_BOUNDARY:\n\n            s->boundary = val;\n\n            break;\n\n        case EN0_IMR:\n\n            s->imr = val;\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN0_TPSR:\n\n            s->tpsr = val;\n\n            break;\n\n        case EN0_TCNTLO:\n\n            s->tcnt = (s->tcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_TCNTHI:\n\n            s->tcnt = (s->tcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RSARLO:\n\n            s->rsar = (s->rsar & 0xff00) | val;\n\n            break;\n\n        case EN0_RSARHI:\n\n            s->rsar = (s->rsar & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_RCNTLO:\n\n            s->rcnt = (s->rcnt & 0xff00) | val;\n\n            break;\n\n        case EN0_RCNTHI:\n\n            s->rcnt = (s->rcnt & 0x00ff) | (val << 8);\n\n            break;\n\n        case EN0_DCFG:\n\n            s->dcfg = val;\n\n            break;\n\n        case EN0_ISR:\n\n            s->isr &= ~(val & 0x7f);\n\n            ne2000_update_irq(s);\n\n            break;\n\n        case EN1_PHYS ... EN1_PHYS + 5:\n\n            s->phys[offset - EN1_PHYS] = val;\n\n            break;\n\n        case EN1_CURPAG:\n\n            s->curpag = val;\n\n            break;\n\n        case EN1_MULT ... EN1_MULT + 7:\n\n            s->mult[offset - EN1_MULT] = val;\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 18640, "substitutes": {"opaque": ["iopatile", " opque", "operacity", " opacity", "iopque", "operatile", "opera", "opatile", "opacity", "iopaque", "operaque", " opatile", "operque", " opa", "iopacity", "opa", "opque", "iopa"], "addr": ["lon", "point", "code", "data", "mode", "x", "vr", "ref", "rc", "md", "ord", "debug", "coord", "align", "hop", "inc", "num", "cb", "oa", "src", "node", "loc", "padding", "ext", "index", "ptr", "pos", "env", "pointer", "ip", "host", "slot", "d", "layer", "alias", "nc", "prefix", "ad", "id", "dr", "device", "cmd", "url", "address", "pad", "adr", "route", "sid", "ace", "inst", "amd", "mt", "port", "mac", "attr", "amp", "len"], "val": ["Val", "grad", "stat", "al", "x", "ref", "pl", "role", "pos", "sec", "exec", "sol", "nil", "config", "elt", "p", "test", "win", "aval", "end", "valid", "pt", "len", "au", "cal", "vals", "ld", "count", "arr", "arg", "slot", "vol", "fl", "pre", "ol", "rot", "key", "bl", "v", "update", "util", "ret", "base", "alt", "lit", "loc", "sel", "ind", "byte", "ee", "VAL", "sil", "serv", "start", "buf", "bool", "doc", "ul", "split", "live", "py", "value", "db", "pid", "data", "all", "buffer", "sl", "ctx", "index", "dim", "def", "prop", "format", "pal", "fail", "il", "ssl", "unit", "url", "eval", "local", "el"], "s": ["ns", "spec", "stat", "settings", "service", "sie", "ss", "sec", "cs", "d", "new", "qs", "sym", "p", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "scope", "self", "o", "v", "si", "S", "a", "hs", "port", "an", "ds", "status", "uns", "f", "r", "sb", "as", "this", "l", "ins", "bis", "serv", "sync", "c", "ps", "b", "sys", "your", "es", "state", "states", "sq", "session", "t", "stats", "conf", "request", "services", "g", "i", "sl", "ls", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "south", "se", "server", "y", "u"], "offset": ["set", "offer", "part", "mode", "Offset", "base", "ref", "bit", "net", "nt", "align", "hop", "num", "type", "loc", "phase", "padding", "index", "pos", "ptr", "count", "o", "ip", "range", "slot", "layer", "location", "header", "reset", "rot", "start", "position", "seq", "off", "line", "address", "pad", "p", "fee", "orient", "et", "number", "end", "port", "operation", "order", "len"], "page": ["pc", "pid", "code", "pages", "x", "f", "ref", "sp", "net", "n", "pl", "inc", "wait", "num", "phase", "loc", "pos", "count", "ip", "pg", "pp", "step", "size", "site", "value", "Page", "key", "limit", "e", "v", "age", "line", "p", "url", "next", "col", "row", "number", "end", "port", "server", "pen", "order", "ver", "len"]}}
{"project": "FFmpeg", "commit_id": "0a359cf157957f3eb37760f731fa75dd320fd659", "target": 0, "func": "static int vc1_filter_line(uint8_t* src, int stride, int pq){\n\n    int a0, a1, a2, a3, d, clip, filt3 = 0;\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n\n\n    a0     = (2*(src[-2*stride] - src[ 1*stride]) - 5*(src[-1*stride] - src[ 0*stride]) + 4) >> 3;\n\n    if(FFABS(a0) < pq){\n\n        a1 = (2*(src[-4*stride] - src[-1*stride]) - 5*(src[-3*stride] - src[-2*stride]) + 4) >> 3;\n\n        a2 = (2*(src[ 0*stride] - src[ 3*stride]) - 5*(src[ 1*stride] - src[ 2*stride]) + 4) >> 3;\n\n        a3 = FFMIN(FFABS(a1), FFABS(a2));\n\n        if(a3 < FFABS(a0)){\n\n            d = 5 * ((a0 >=0 ? a3 : -a3) - a0) / 8;\n\n            clip = (src[-1*stride] - src[ 0*stride])/2;\n\n            if(clip){\n\n                filt3 = 1;\n\n                if(clip > 0)\n\n                    d = av_clip(d, 0, clip);\n\n                else\n\n                    d = av_clip(d, clip, 0);\n\n                src[-1*stride] = cm[src[-1*stride] - d];\n\n                src[ 0*stride] = cm[src[ 0*stride] + d];\n\n            }\n\n        }\n\n    }\n\n    return filt3;\n\n}\n", "idx": 18646, "substitutes": {"src": ["spec", "grad", "grab", "pl", "supp", "pack", "uv", "gb", "secure", "feat", "stack", "comp", "config", "gl", "chrom", "impl", "lib", "rect", "us", "scan", "source", "cv", "sup", "sit", "sur", "rs", "rest", "dest", "ctr", "rc", "stream", "upp", "app", "bc", "msg", "bb", "hw", "cont", "usc", "sub", "sc", "uc", "iv", "kk", "bs", "text", "view", "sb", "cb", "loc", "sel", "head", "host", "ack", "go", "sn", "sr", "sync", "rss", "obl", "b", "fn", "split", "inst", "sq", "sl", "ctx", "fc", "uint", "conv", "use", "img", "st", "pull", "ssl", "cl", "cur", "rb", "seq", "support", "url", "http", "proc", "usr", "attr", "dist"], "stride": ["staine", "Strride", "Stride", "sprine", "instide", " strande", "instride", "Strode", "staide", "Straine", "spride", "arrider", "Strider", "stripe", "straine", "stidi", " strand", "Striden", "stiding", "cline", "variider", "divide", "slided", "strride", "slode", "Strided", "strand", "brided", " straine", "variipe", "stode", " striding", "stider", "stand", "strine", "yride", "variide", " strided", "brider", "hrider", "bripe", "bridi", "strided", "yrande", "strides", " strider", "clide", "instider", "sprider", "arriden", "stided", "stande", "divided", "hrided", "divipe", "staided", "slide", "Stripe", "staider", "strande", "stridi", "staride", "yrride", "Strides", "hride", "striding", "clipe", "brine", "variided", "brides", "strider", "sprided", " stripe", " strides", "slipe", " strine", "hrine", "arride", "clider", "stine", " strride", "divider", " stridi", "Striding", "variine", "strode", "striden", "slider", "stide", "sline", "sliden", "instine", "yrider", "stipe", "instided", "brride", "bride", "arrided", "Strine", "instand"], "pq": ["jpq", "Pcharge", "PQ", " pQ", "tpqa", "pQ", "pqa", "pcharge", "tpQ", "jpqq", " pqa", "jpqa", " pqu", "pqq", "tpqu", "Pq", "Pqq", "jpcharge", "jpqu", "tpq", "tpcharge", "tpqq", "pqu", "jpQ"], "a0": ["A080", "ia0", "ia2", " a8", "a8", "p2", "p0", "A1", "ae9", "a5", "aa1", "ga2", "ae1", "alpha1", "alpha9", "A0", "a05", "alpha4", "alpha2", " a9", "va00", "p080", "ia080", "aa8", "A8", "ga5", " a5", "a00", "alpha0", " a00", "aa5", " a4", "va5", "va05", "A2", "ga00", "ga05", "a9", "A5", "ga4", "ga9", "a080", "ae0", "a4", "ga0", "aa0", "p1", "ia1", " a05", "alpha5", "va0", "ae2"], "a1": ["am2", "na4", "sa2", "na5", "ac1", "A1", "a5", "am1", "alpha1", "am0", "A0", "sa5", "sa1", "alpha4", "na1", "alpha2", "ac5", "na3", " a5", "alpha0", " a4", "A2", "ac4", "ac3", "A5", "A4", "sa0", "am5", "a4"], "a2": ["an8", "am2", "a42", " a62", "sa2", " a8", "a8", "ac2", "an0", "am8", "A0", "an4", "am4", "ac42", "an2", "am42", "sa3", "an3", "ac62", " a4", "A2", "an62", "ac4", "a62", "A3", "A4", "sa0", " a42", "a4", "sa4", "ac8"], "a3": ["an8", "aa03", "aa3", " a15", " a83", " a8", "an83", "a8", "p2", "p0", " a23", "an03", "ar83", "ar3", "A23", "A1", "aa1", "a5", "a15", "an0", "A0", "sa5", "p23", " a03", "A6", "an1", "aa83", "an2", "a23", "p3", "aa8", "sa3", "sa6", "an3", "ar8", "aa15", "A83", "ar15", "a03", "A2", "a83", "an6", "A3", "A5", "sa0", "a6", "an5"], "d": ["dc", "m", "dd", "s", "j", "nd", "t", "data", "x", "f", "yd", "du", "md", "n", "dh", "dos", "g", "i", "z", "dt", "di", "ld", "dl", "ind", "dim", "min", "sd", "l", "did", "dy", "w", "dx", "id", "ad", "e", "delay", "bd", "fd", "dr", "q", "v", "c", "dom", "D", "ded", "p", "del", "pad", "da", "b", "dist", "dat", "depth", "cd", "h", "a", "dad", "die", "diff", "y", "ds", "u"], "clip": ["grab", "skip", "x", "op", "apply", "pl", "job", "zip", "copy", "iff", "sh", "ipp", "large", "comp", "id", "p", "crop", "pad", "none", "kill", "loop", "scale", "ape", "cp", "load", "up", "stop", "flow", "push", "f", "du", "drop", "block", "dl", "tool", "plane", "gap", "keep", "close", "ad", "q", "sync", "c", "qa", "b", "lock", "split", "az", "cut", "tip", "shape", "clone", "hide", "pe", "sl", "ide", "z", "slice", "ip", "low", "ignore", "cel", "bd", "pull", "limit", "cl", "strip", "pick", "cap", "around", "diff"], "cm": ["m", "cdn", "core", "ctr", "CM", "iam", "rc", "rm", "bm", "cf", "pm", "ym", "module", "km", "cb", "comm", "bc", "am", "rom", "cp", "sem", "ctx", "mc", "ctrl", "ca", "vm", "container", "uv", "ci", "com", "con", "config", "img", "cam", "cl", "cr", "map", "mx", "lc", "c", "wm", "cmd", "ram", "cmp", "fm", "don", "cd", "cn", "gm", "im", "mm", "cv", "cc"]}}
{"project": "FFmpeg", "commit_id": "c1f2c4c3b49277d65b71ccdd3b6b2878f1b593eb", "target": 0, "func": "static int rle_unpack(const unsigned char *src, unsigned char *dest,\n\n                      int src_count, int src_size, int dest_len)\n\n{\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            return 0;\n\n        *pd++ = bytestream2_get_byteu(&gb);\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (bytestream2_get_bytes_left(&gb) < 1)\n\n            break;\n\n        l = bytestream2_get_byteu(&gb);\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (dest_end - pd < l || bytestream2_get_bytes_left(&gb) < l)\n\n                return bytestream2_tell(&gb);\n\n            bytestream2_get_bufferu(&gb, pd, l);\n\n            pd += l;\n\n        } else {\n\n            if (dest_end - pd < i || bytestream2_get_bytes_left(&gb) < 2)\n\n                return bytestream2_tell(&gb);\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n                *pd++ = bytestream2_get_byteu(&gb);\n\n            }\n\n            bytestream2_skip(&gb, 2);\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return bytestream2_tell(&gb);\n\n}\n", "idx": 18648, "substitutes": {"src": ["sur", "rs", "gd", "image", "rc", "sb", "cb", "sl", "attr", "ources", "loc", "sel", "ctx", "slice", "inf", "rib", "sub", "img", "config", "sr", "sc", "ssl", "sth", "buff", "sync", "cur", "rb", "uc", "url", "gz", "storage", "split", "inst", "sq", "source", "dist"], "dest": ["dc", "sup", "dd", "data", "destroy", "rest", "gd", " destination", "mode", "delete", "lit", "de", "sb", "usr", "cp", "wb", "slice", "done", "wd", "ptr", "pb", "home", "d", "class", "later", "std", "path", "ident", "large", "img", "config", "standard", "remote", "buff", "comb", "sync", "target", "v", "tmp", "trans", "slave", "uc", "dev", "route", "wh", "Dest", "end", "desc", "source", "dist"], "src_count": ["src_low", " src_order", "source_size", "src__size", "src__sum", "src64size", "src__len", "srcqsize", "src__low", " src_length", "src__limit", " src_limit", "source_len", "src_length", "src_sum", "src64count", "src__count", "source_sum", "srcqlength", "src_id", "src_order", "src_len", "src_limit", " src_id", "srcqorder", " src_low", "source_count", "src64order", "srcqcount", "src__id", "src__length", "src64length"], "src_size": [" src_len", "src2name", " src_length", "src2len", "src2length", "src_length", " src_name", "src2size", "src_len", "src_name"], "dest_len": ["Dest_pos", "dest_pos", "Dest_len", "dest_l", "dest_length", "Dest_size", "Dest_line", "Dest_l", "Dest_length", "dest_line", "dest_size"], "pd": ["pc", "dra", "wp", "grad", "dd", "sg", "db", "pid", "cdn", "data", "gd", "fp", "sv", "pod", "td", "md", "edd", "pl", "sb", "pm", "hd", "cp", "lp", "vd", "wb", "dt", "ld", "dl", "pb", "bb", "wd", "slice", "sd", "lv", "parser", "po", "dp", "pg", "d", "std", "pkg", "bf", "pi", "ci", "bd", "fd", "sth", "xd", "lc", "lib", "PD", "p", "da", "ud", "ppa", "od", "god", "cd", "dL", "wa", "api", "pro", "tp", "py", "php", "dk", "li", "ds"], "i": ["ti", "uri", "gi", "m", "bi", "j", "ji", "t", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "n", "mi", "phi", "fi", "g", "hi", "z", "ii", "in", "ie", "iu", "index", "ind", "di", "I", "dl", "count", "o", "ip", "L", "d", "yi", "pi", "ui", "ci", "id", "start", "e", "k", "v", "cli", "c", "ni", "si", "lc", "ri", "p", "xi", "ll", "b", "split", "list", "el", "y", "li", "u"], "l": ["m", "s", "j", "ell", "t", "f", "all", "r", "n", "pl", "lu", "g", "kl", "sl", "z", "nl", "ls", "lp", "dl", "lb", "o", "L", "lf", "ln", "tl", "d", "lo", "fl", "le", "ol", "length", "il", "e", "bl", "k", "v", "lc", "c", "ll", "p", "line", "b", "col", "la", "ul", "u", "h", "el", "li", "len"], "dest_end": ["dest___start", "dest_tail", "src_end", "src_tail", "Dest_end", "destacstart", "Dest_limit", "Dest_len", "src_last", "dest_limit", "destactail", "dest_start", "destallstart", "destallimit", "destallname", "dest___len", "dest_enc", "destallend", "dest___end", "destacend", "destaclast", "destalstart", "Dest_name", "src_start", "dest___enc", "destalllimit", "destalname", "dest_name", "dest_last", "destalend", "Dest_enc", "Dest_start"], "gb": ["pc", "gi", "gn", "gram", "cfg", "eb", "db", "GB", "gd", "gal", "yg", "gio", "gow", "rc", "usb", "gu", "gc", "gg", "bm", "gae", "gom", "sb", "g", "gin", "cb", "sl", "hd", "bc", "gru", "hub", " storage", "greg", "gam", "rg", "bb", "phy", "nb", " db", "git", " rgb", "pg", "range", "gp", "bo", " rg", "kb", "bf", "ui", "ci", "mb", "gh", "gl", "ga", "cli", "lc", "rb", "bg", "gt", "b", "gz", "gs", " rc", "cd", "gy", "gm", "storage", "boot", " GB", "Gb", "ub", "ds"]}}
{"project": "FFmpeg", "commit_id": "1dff9adcb934175fe1beb14ee139ad0636daa29d", "target": 0, "func": "static int recheck_discard_flags(AVFormatContext *s, int first)\n\n{\n\n    HLSContext *c = s->priv_data;\n\n    int i, changed = 0;\n\n\n\n    /* Check if any new streams are needed */\n\n    for (i = 0; i < c->n_playlists; i++)\n\n        c->playlists[i]->cur_needed = 0;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        struct playlist *pls = c->playlists[s->streams[i]->id];\n\n        if (st->discard < AVDISCARD_ALL)\n\n            pls->cur_needed = 1;\n\n    }\n\n    for (i = 0; i < c->n_playlists; i++) {\n\n        struct playlist *pls = c->playlists[i];\n\n        if (pls->cur_needed && !pls->needed) {\n\n            pls->needed = 1;\n\n            changed = 1;\n\n            pls->cur_seq_no = select_cur_seq_no(c, pls);\n\n            pls->pb.eof_reached = 0;\n\n            if (c->cur_timestamp != AV_NOPTS_VALUE) {\n\n                /* catch up */\n\n                pls->seek_timestamp = c->cur_timestamp;\n\n                pls->seek_flags = AVSEEK_FLAG_ANY;\n\n                pls->seek_stream_index = -1;\n\n            }\n\n            av_log(s, AV_LOG_INFO, \"Now receiving playlist %d, segment %d\\n\", i, pls->cur_seq_no);\n\n        } else if (first && !pls->cur_needed && pls->needed) {\n\n            if (pls->input)\n\n                ff_format_io_close(pls->parent, &pls->input);\n\n            pls->needed = 0;\n\n            changed = 1;\n\n            av_log(s, AV_LOG_INFO, \"No longer receiving playlist %d\\n\", i);\n\n        }\n\n    }\n\n    return changed;\n\n}\n", "idx": 18649, "substitutes": {"s": ["ns", "ans", "spec", "m", "ts", "sg", "session", "t", "rs", "aws", "conf", "f", "stats", "sv", "settings", "services", "r", "service", "n", "sb", "g", "sl", "ss", "as", "fs", "is", "o", "cs", "l", "su", "ins", "args", "qs", "e", "ssl", "sc", "ses", "v", "sync", "js", "si", "ps", "p", "S", "sts", "b", "ks", "events", "gs", "http", "sys", "h", "its", "a", "es", "os", "us", "sets", "se", "sq", "server", "less", "sa", "ds", "u"], "first": ["required", "full", "f", "leaf", "current", "root", "based", "max", "top", "count", "always", "empty", "final", "change", "found", "First", "initial", "use", "correct", "last", "seen", "start", "prev", "only", "latest", "used", "p", "once", "missing", "next", "error", "split", "second", "repeat", "end", "before", "alpha", "one", "now"], "c": ["pc", "dc", "ic", "m", "ch", "t", "conf", "f", "cus", "vc", "ct", "conn", "r", "cm", "n", "cf", "g", "coll", "bc", "cp", "ctx", "mc", "ctrl", "o", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "con", "tc", "config", "sc", "cu", "e", "k", "cr", "v", "lc", "cur", "p", "uc", "b", "ec", "cd", "h", "co", "C", "cc", "u"], "i": ["ti", "gi", "uri", "m", "bi", "init", "j", "ami", "info", "x", "f", "name", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "g", "hi", "ii", "ie", "in", "di", "index", "ind", "iu", "I", "ori", "multi", "zi", "is", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "isin", "ci", "changed", "abi", "id", "start", "e", "k", "v", "cli", "ni", "si", "lc", "ri", "p", "xi", "b", "mu", "h", "a", "iv", "it", "eni", "my", "fi", "y", "li", "u"], "st": ["pt", "ist", "est", "fr", "rest", "ct", "sp", "ste", "pe", "str", "sb", "sw", "ast", "ss", "src", "ld", "sec", "ST", "sd", "stal", "sta", "su", "std", "sh", "stack", "stop", "sn", "sr", "sc", "start", "sth", "cr", "be", "si", "rss", "sts", "St", "inst", "ace", "ft", "se", "sa"], "pls": ["phs", "splws", "PLs", " plS", "plses", "ynws", "Plp", " Pld", " pli", "plops", "phses", "celp", "cli", "splss", "plds", "plS", "relp", "plg", "splg", "plis", "clp", "yni", " plsb", "plsb", "feeds", " Pls", "pgi", "pgp", "llp", "impls", "celsets", "plss", "splsets", "slp", "feedsets", " Pli", "sld", "cels", "implp", "PlS", "controlses", "splos", "pts", "clis", "splp", "ynp", " plws", " plsets", "clg", "cls", "phsets", "Pli", "splops", " plops", "logd", "logi", "plsets", "PLd", "pgis", "rels", "plos", "ptds", "plp", "splds", "pgses", "yng", "lls", "pps", " plis", "pgs", " plp", "Plsets", "celses", "controlsets", " plds", "pld", "spli", "splsb", " plss", "Pls", " pld", "yns", "logs", "PLi", "puti", "implops", " plses", "sls", "ppds", "plws", " plg", "spls", "logsb", "controls", "spld", "ppp", "relss", "lld", "putS", "slsets", "ynos", "php", "pli", " plos", "feedp", "ptp"]}}
{"project": "qemu", "commit_id": "92dcc234ec1f266fb5d59bed77d66320c2c75965", "target": 0, "func": "static int tpm_passthrough_unix_transfer(int tpm_fd,\n\n                                         const TPMLocality *locty_data)\n\n{\n\n    return tpm_passthrough_unix_tx_bufs(tpm_fd,\n\n                                        locty_data->w_buffer.buffer,\n\n                                        locty_data->w_offset,\n\n                                        locty_data->r_buffer.buffer,\n\n                                        locty_data->r_buffer.size);\n\n}\n", "idx": 18673, "substitutes": {"tpm_fd": ["tPM_writer", "tpm_id", "tpm67db", "tpm_FD", "tPM_fd", "tpm_writer", "tpmfid", "tPM_db", "tpmfd", "tpm67id", "tpm67d", "tpm67fd", "tpmfdb", "tPM_FD", "tPM_id", "tPM_d", "tpm_d", "tpmffd", "tpm_db"], "locty_data": ["loctory_writer", "loctyMcache", "loctya_cache", "loctory_buffer", "loctyPdata", "locty_image", "locti_size", "loctyPimage", "locty_args", "loctysdata", "loctyPsize", "locty_ui", "loctysreader", "locty2data", "locty2buffer", "loctiy_ui", "loctyMdatabase", "locty_parent", "locty_database", "loctyMsize", "loctyMdata", "loctyd_reader", "loctya_database", "loctyuserui", "loctory2resource", "loctory_resource", "loctiy_dat", "loctyd_args", "locty_reader", "loctyuserresult", "loctyuserdat", "loctory2buffer", "locty_resource", "locti_data", "locty_cache", "loctyd_buffer", "locty_result", "loctyPparent", "locti_parent", "locty_dat", "loctya_data", "locty_buffer", "loctysbuffer", "locty2writer", "loctyd_data", "locti_image", "loctory2writer", "locty_size", "locty_writer", "loctory_data", "loctya_size", "locty2resource", "loctyuserdata", "loctiy_result", "loctory2data", "loctysargs", "loctiy_data"]}}
{"project": "qemu", "commit_id": "e1833e1f96456fd8fc17463246fe0b2050e68efb", "target": 0, "func": "void do_tw (int flags)\n\n{\n\n    if (!likely(!(((int32_t)T0 < (int32_t)T1 && (flags & 0x10)) ||\n\n                  ((int32_t)T0 > (int32_t)T1 && (flags & 0x08)) ||\n\n                  ((int32_t)T0 == (int32_t)T1 && (flags & 0x04)) ||\n\n                  ((uint32_t)T0 < (uint32_t)T1 && (flags & 0x02)) ||\n\n                  ((uint32_t)T0 > (uint32_t)T1 && (flags & 0x01))))) {\n\n        do_raise_exception_err(EXCP_PROGRAM, EXCP_TRAP);\n\n    }\n\n}\n", "idx": 18675, "substitutes": {"flags": ["types", "strings", "s", "planes", "styles", "stats", "info", "FLAG", "f", "tones", "words", "options", "all", "Flags", "fe", "ports", "requires", "plugins", "details", "vals", "flag", "files", "pants", "ints", "utils", "fires", "ags", "fs", "mask", "locks", "count", "checks", "tools", "linux", "ffff", "args", "features", "codes", "fd", "frames", "alls", "bits", "comments", "atts", "orts", "lag", "reports", "lins", "ants", "powers", "rep", "errors", "rules", "opens", "notes", "states", "allows", "caps", "len"]}}
{"project": "qemu", "commit_id": "f85da3081d001909929a19e530e69cea0487f00e", "target": 1, "func": "void sh4_translate_init(void)\n\n{\n\n    int i;\n\n    static const char * const gregnames[24] = {\n\n        \"R0_BANK0\", \"R1_BANK0\", \"R2_BANK0\", \"R3_BANK0\",\n\n        \"R4_BANK0\", \"R5_BANK0\", \"R6_BANK0\", \"R7_BANK0\",\n\n        \"R8\", \"R9\", \"R10\", \"R11\", \"R12\", \"R13\", \"R14\", \"R15\",\n\n        \"R0_BANK1\", \"R1_BANK1\", \"R2_BANK1\", \"R3_BANK1\",\n\n        \"R4_BANK1\", \"R5_BANK1\", \"R6_BANK1\", \"R7_BANK1\"\n\n    };\n\n    static const char * const fregnames[32] = {\n\n         \"FPR0_BANK0\",  \"FPR1_BANK0\",  \"FPR2_BANK0\",  \"FPR3_BANK0\",\n\n         \"FPR4_BANK0\",  \"FPR5_BANK0\",  \"FPR6_BANK0\",  \"FPR7_BANK0\",\n\n         \"FPR8_BANK0\",  \"FPR9_BANK0\", \"FPR10_BANK0\", \"FPR11_BANK0\",\n\n        \"FPR12_BANK0\", \"FPR13_BANK0\", \"FPR14_BANK0\", \"FPR15_BANK0\",\n\n         \"FPR0_BANK1\",  \"FPR1_BANK1\",  \"FPR2_BANK1\",  \"FPR3_BANK1\",\n\n         \"FPR4_BANK1\",  \"FPR5_BANK1\",  \"FPR6_BANK1\",  \"FPR7_BANK1\",\n\n         \"FPR8_BANK1\",  \"FPR9_BANK1\", \"FPR10_BANK1\", \"FPR11_BANK1\",\n\n        \"FPR12_BANK1\", \"FPR13_BANK1\", \"FPR14_BANK1\", \"FPR15_BANK1\",\n\n    };\n\n\n\n    for (i = 0; i < 24; i++) {\n\n        cpu_gregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, gregs[i]),\n\n                                              gregnames[i]);\n\n    }\n\n    memcpy(cpu_gregs + 24, cpu_gregs + 8, 8 * sizeof(TCGv));\n\n\n\n    cpu_pc = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pc), \"PC\");\n\n    cpu_sr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, sr), \"SR\");\n\n    cpu_sr_m = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_m), \"SR_M\");\n\n    cpu_sr_q = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_q), \"SR_Q\");\n\n    cpu_sr_t = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, sr_t), \"SR_T\");\n\n    cpu_ssr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, ssr), \"SSR\");\n\n    cpu_spc = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, spc), \"SPC\");\n\n    cpu_gbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, gbr), \"GBR\");\n\n    cpu_vbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, vbr), \"VBR\");\n\n    cpu_sgr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, sgr), \"SGR\");\n\n    cpu_dbr = tcg_global_mem_new_i32(cpu_env,\n\n                                     offsetof(CPUSH4State, dbr), \"DBR\");\n\n    cpu_mach = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, mach), \"MACH\");\n\n    cpu_macl = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, macl), \"MACL\");\n\n    cpu_pr = tcg_global_mem_new_i32(cpu_env,\n\n                                    offsetof(CPUSH4State, pr), \"PR\");\n\n    cpu_fpscr = tcg_global_mem_new_i32(cpu_env,\n\n                                       offsetof(CPUSH4State, fpscr), \"FPSCR\");\n\n    cpu_fpul = tcg_global_mem_new_i32(cpu_env,\n\n                                      offsetof(CPUSH4State, fpul), \"FPUL\");\n\n\n\n    cpu_flags = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t       offsetof(CPUSH4State, flags), \"_flags_\");\n\n    cpu_delayed_pc = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t\t    offsetof(CPUSH4State, delayed_pc),\n\n\t\t\t\t\t    \"_delayed_pc_\");\n\n    cpu_delayed_cond = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State,\n\n                                                       delayed_cond),\n\n                                              \"_delayed_cond_\");\n\n    cpu_ldst = tcg_global_mem_new_i32(cpu_env,\n\n\t\t\t\t      offsetof(CPUSH4State, ldst), \"_ldst_\");\n\n\n\n    for (i = 0; i < 32; i++)\n\n        cpu_fregs[i] = tcg_global_mem_new_i32(cpu_env,\n\n                                              offsetof(CPUSH4State, fregs[i]),\n\n                                              fregnames[i]);\n\n}\n", "idx": 18696, "substitutes": {"i": ["ti", "gi", "uri", "m", "bi", "j", "ji", "s", "t", "info", "x", "f", "ix", "ini", "qi", "io", "ai", "n", "phi", "mi", "hi", "z", "ii", "ie", "iu", "di", "mini", "slice", "I", "index", "multi", "zi", "ind", "o", "ip", "l", "oi", "yi", "hei", "pi", "uni", "ui", "ci", "abi", "id", "key", "e", "v", "c", "si", "ri", "xi", "p", "b", "anti", "u", "a", "it", "eni", "fi", "y", "li", "mu"], "gregnames": ["gramnam", "rgname", "structnames", "rgnames", "regnames", "gramname", "gramnames", "rgnam", "regNames", "gregNames", "regname", "structname", "gregname", "structNames", "structnam", "rgNames", "gregnam", "gramNames", "regnam"], "fregnames": ["fdebugspec", "gregspec", "fregdef", "fregname", "fdebugname", "fdebugnames", "ggregname", "ggregspec", "fgregname", "fregisterspec", "gregdef", "ggregdef", "fgregnames", "gregname", "fregspec", "fregisternames", "fregistername", "fregisterdef", "ggregnames", "fdebugdef", "fgregspec", "fgregdef"]}}
{"project": "FFmpeg", "commit_id": "e70fcf075b8f92c4e410b80c703fbdc1d531d42d", "target": 1, "func": "AVStream *add_audio_stream(AVFormatContext *oc, int codec_id)\n\n{\n\n    AVCodec *codec;\n\n    AVCodecContext *c;\n\n    AVStream *st;\n\n\n\n    st = av_new_stream(oc, 1);\n\n    if (!st) {\n\n        fprintf(stderr, \"Could not alloc stream\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* find the MP2 encoder */\n\n    codec = avcodec_find_encoder(codec_id);\n\n    if (!codec) {\n\n        fprintf(stderr, \"codec not found\\n\");\n\n        exit(1);\n\n    }\n\n    c = &st->codec;\n\n    c->codec_type = CODEC_TYPE_AUDIO;\n\n\n\n    /* put sample parameters */\n\n    c->bit_rate = 64000;\n\n    c->sample_rate = 44100;\n\n    c->channels = 2;\n\n\n\n    /* open it */\n\n    if (avcodec_open(c, codec) < 0) {\n\n        fprintf(stderr, \"could not open codec\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* init signal generator */\n\n    t = 0;\n\n    tincr = 2 * M_PI * 440.0 / c->sample_rate;\n\n\n\n    audio_outbuf_size = 10000;\n\n    audio_outbuf = malloc(audio_outbuf_size);\n\n\n\n    /* ugly hack for PCM codecs (will be removed ASAP with new PCM\n\n       support to compute the input frame size in samples */\n\n    if (c->frame_size <= 1) {\n\n        audio_input_frame_size = audio_outbuf_size / c->channels;\n\n        switch(st->codec.codec_id) {\n\n        case CODEC_ID_PCM_S16LE:\n\n        case CODEC_ID_PCM_S16BE:\n\n        case CODEC_ID_PCM_U16LE:\n\n        case CODEC_ID_PCM_U16BE:\n\n            audio_input_frame_size >>= 1;\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    } else {\n\n        audio_input_frame_size = c->frame_size;\n\n    }\n\n    samples = malloc(audio_input_frame_size * 2 * c->channels);\n\n\n\n    return st;\n\n}\n", "idx": 18700, "substitutes": {"oc": ["dc", "pc", "org", "cot", "ocol", "irc", "rc", "cf", "coll", "anc", "toc", "loc", "bc", "ocr", "mot", "ctx", "mic", "fc", "o", "auc", "roc", "rec", "acs", "usc", "ac", "oci", "soc", "ucc", "uc", "circ", "ogg", "osc", "ec", "OC", "isc", "cc", "voc"], "codec_id": ["codoc_name", "codec0ID", "codef_ID", "codec___type", "codroc_vid", "codroc_id", "codec0type", "codec_code", "codec0id", "codec_type", "codec0name", "codec_ids", "codef_ids", "codec___vid", "codec_name", "codec___id", "codef_name", "codec0code", "codoc_type", "codoc_id", "codec___name", "codroc___vid", "codroc_name", "codef_id", "codec_ID", "codroc_type", "codec_vid", "codroc___name", "codroc___type", "codroc___id", "codoc_code", "codec0ids"], "codec": [" codesc", "cedect", "Codeca", "Codoc", "CodEC", "cedef", "cilesc", "compef", "codroc", "pedesc", "labesc", "codef", "labect", "compbc", "Codac", "Codroc", "odec", " codect", "chroc", "coderoc", " codEC", "codeec", "codect", "Codesc", "chesc", "labac", "codeca", "odef", " codac", "chec", "cilac", "codEC", "odesc", "cilect", " codbc", " codef", "codesc", "labec", "cedec", " codeca", "compesc", "pedec", "codbc", "pedoc", "cilec", "cedeca", "odac", "codeesc", "compec", "odect", " codoc", "choc", "odeca", "pedEC", "codac", "odbc", "codoc", "codeoc", "Codec"], "c": ["dc", "pc", "ic", "jc", "m", "spec", "content", "s", "ch", "code", "t", "f", "call", "vc", "ct", "rc", "r", "n", "cm", "cf", "g", "i", "coll", "anc", "cb", "cod", "bc", "ctx", "fc", "mc", "abc", "self", "ctrl", "cy", "o", "ca", "enc", "cs", "exec", "l", "rec", "d", "chain", "nc", "ac", "ci", "con", "xc", "config", "tc", "e", "cu", "k", "cl", "client", "lc", "v", "p", "uc", "cache", "b", "col", "ec", "h", "cn", "co", "icc", "C", "cc", "u"], "st": ["ist", "est", "fr", "t", "stim", "rest", "obj", "ct", "sp", "ste", "td", "fe", "nt", "pe", "r", "rt", "str", "stable", "sb", "ost", "stream", "sl", "ast", "ss", "sw", "ut", "src", "ld", "sa", "ST", "sec", "stand", "sta", "art", "spect", "d", "std", "step", "stack", "stop", "back", "sn", " est", "start", "sc", "e", "sth", "cr", "cl", " St", "tmp", "stage", "ust", "test", "sts", "St", "form", "put", "inst", "ace", "se", "pt"]}}
{"project": "FFmpeg", "commit_id": "ecc92ee717eac18540e236ee27e9052cd2917800", "target": 1, "func": "static av_cold int libopenjpeg_encode_init(AVCodecContext *avctx)\n\n{\n\n    LibOpenJPEGContext *ctx = avctx->priv_data;\n\n    int err = AVERROR(ENOMEM);\n\n\n\n    opj_set_default_encoder_parameters(&ctx->enc_params);\n\n\n\n    ctx->enc_params.cp_rsiz = ctx->profile;\n\n    ctx->enc_params.mode = !!avctx->global_quality;\n\n    ctx->enc_params.cp_cinema = ctx->cinema_mode;\n\n    ctx->enc_params.prog_order = ctx->prog_order;\n\n    ctx->enc_params.numresolution = ctx->numresolution;\n\n    ctx->enc_params.cp_disto_alloc = ctx->disto_alloc;\n\n    ctx->enc_params.cp_fixed_alloc = ctx->fixed_alloc;\n\n    ctx->enc_params.cp_fixed_quality = ctx->fixed_quality;\n\n    ctx->enc_params.tcp_numlayers = ctx->numlayers;\n\n    ctx->enc_params.tcp_rates[0] = FFMAX(avctx->compression_level, 0) * 2;\n\n\n\n    if (ctx->cinema_mode > 0) {\n\n        cinema_parameters(&ctx->enc_params);\n\n    }\n\n\n\n    ctx->compress = opj_create_compress(ctx->format);\n\n    if (!ctx->compress) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the compressor\\n\");\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n    ctx->image = mj2_create_image(avctx, &ctx->enc_params);\n\n    if (!ctx->image) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error creating the mj2 image\\n\");\n\n        err = AVERROR(EINVAL);\n\n        goto fail;\n\n    }\n\n\n\n    avctx->coded_frame = av_frame_alloc();\n\n    if (!avctx->coded_frame) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Error allocating coded frame\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    memset(&ctx->event_mgr, 0, sizeof(opj_event_mgr_t));\n\n    ctx->event_mgr.info_handler    = info_callback;\n\n    ctx->event_mgr.error_handler = error_callback;\n\n    ctx->event_mgr.warning_handler = warning_callback;\n\n    opj_set_event_mgr((opj_common_ptr) ctx->compress, &ctx->event_mgr, avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    opj_destroy_compress(ctx->compress);\n\n    ctx->compress = NULL;\n\n    opj_image_destroy(ctx->image);\n\n    ctx->image = NULL;\n\n    av_freep(&avctx->coded_frame);\n\n    return err;\n\n}\n", "idx": 18719, "substitutes": {"avctx": ["AVcrit", "afcmp", "varctrl", "Avcb", "svcontext", "AVcmp", "avctrl", "avcrit", "avenp", "vercf", "afcb", "avekb", "AVlc", "avectrl", "AVctx", "avconnection", " avcontext", "aveca", "avecmp", "svctrl", "navchan", "varnp", "navcontext", "Avctx", "airctx", " avcrit", " avpc", "avlc", "avca", "aveconn", "avepc", "avcb", " avloc", "airctrl", "afctrl", "AVloc", "avecrit", "Avchan", "navctx", "svctx", "avcmp", "avchan", "varcontext", "vercontext", "aveloc", "Avkb", "airlc", "AVca", "Avcontext", "avpc", "AVcb", "avcf", "navkb", "avloc", "avnp", "AVcontext", "verctrl", "AVconnection", "airconnection", "avectx", "AVcn", "verctx", "AVctrl", "afconnection", "Avcmp", "afcn", "aflc", "AVchan", "avkb", "aircontext", "avcn", "AVkb", "svca", "afcontext", "avconn", "afctx", "avecontext", "AVcf", "avecn", "AVpc", " avkb", "varctx", "afconn", "AVconn", "aircf", "AVnp", "avcontext"], "ctx": ["cfg", "concept", "cf", "anc", "cas", "cs", "exec", "tx", "config", "prefix", "xc", "cu", "cli", "ck", "cv", "conn", "cc", "pc", "txt", "cal", "cca", "cus", "vc", "rc", "cm", "bc", "cp", "wcs", "kw", "hw", "cms", "sc", "lc", "cat", "la", "connection", "co", "na", "fw", "fp", "ct", "component", "cb", "coll", "loc", "utils", "git", "ctrl", "act", "crit", "ca", "kb", "ci", "sync", "c", "qa", "sci", "fn", "sys", "cn", "sq", "np", "voc", "gc", "fc", "acl", "context", "conv", "pkg", "nc", "tc", "cam", "bh", "cl", "client", "req", "chan", "cmd", "support", "cmp"]}}
{"project": "qemu", "commit_id": "786a4ea82ec9c87e3a895cf41081029b285a5fe5", "target": 0, "func": "static inline unsigned int msi_nr_vectors(uint16_t flags)\n\n{\n\n    return 1U <<\n\n        ((flags & PCI_MSI_FLAGS_QSIZE) >> (ffs(PCI_MSI_FLAGS_QSIZE) - 1));\n\n}\n", "idx": 18724, "substitutes": {"flags": ["types", "values", "cycles", "planes", "stats", "FLAG", "f", "fields", "options", "settings", "Flags", "vals", "flag", "files", "little", "ints", "ops", "ags", "fs", "mask", "args", " Flags", "features", "blocks", "comments", "bits", "atts", "lag", "ids", "ants", "powers", "properties", "heads", "rules", "bytes", "members", "parts", "states", "caps"]}}
{"project": "qemu", "commit_id": "13f1c773640171efa8175b1ba6dcd624c1ad68c1", "target": 0, "func": "static void openrisc_sim_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *cpu_model = machine->cpu_model;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    OpenRISCCPU *cpu = NULL;\n\n    MemoryRegion *ram;\n\n    int n;\n\n\n\n    if (!cpu_model) {\n\n        cpu_model = \"or1200\";\n\n    }\n\n\n\n    for (n = 0; n < smp_cpus; n++) {\n\n        cpu = OPENRISC_CPU(cpu_generic_init(TYPE_OPENRISC_CPU, cpu_model));\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n        main_cpu_reset(cpu);\n\n    }\n\n\n\n    ram = g_malloc(sizeof(*ram));\n\n    memory_region_init_ram(ram, NULL, \"openrisc.ram\", ram_size, &error_fatal);\n\n    memory_region_add_subregion(get_system_memory(), 0, ram);\n\n\n\n    cpu_openrisc_pic_init(cpu);\n\n    cpu_openrisc_clock_init(cpu);\n\n\n\n    serial_mm_init(get_system_memory(), 0x90000000, 0, cpu->env.irq[2],\n\n                   115200, serial_hds[0], DEVICE_NATIVE_ENDIAN);\n\n\n\n    if (nd_table[0].used) {\n\n        openrisc_sim_net_init(get_system_memory(), 0x92000000,\n\n                              0x92000400, cpu->env.irq[4], nd_table);\n\n    }\n\n\n\n    cpu_openrisc_load_kernel(ram_size, kernel_filename, cpu);\n\n}\n", "idx": 18727, "substitutes": {"machine": ["program", "process", "m", "instance", "data", "core", "mode", "base", "image", "net", "service", "loader", "module", "node", "manager", "model", "mem", "mom", "computer", "game", "object", "vm", "host", "linux", "space", "gpu", "config", "processor", "device", "slave", "hard", "cache", "proc", "Machine", "template", "boot", "connection", "pu", "state", "mac", "message", "motion"], "cpu_model": [" cpu_module", "cpuLoglayout", "currencyLogmodel", "cpuLogdescription", "currency_description", " cpu_url", "cpu_view", "cpulexmodule", "gpu_format", "cpulexvariable", "cpu_layout", "cpu__module", "gpu_mode", "cpu_module", "gpu_variable", "cpu__model", "cpu_scope", "cpu_url", "cpuLogview", "currency_model", "cpu_mode", "currencyLogdescription", "cpu___model", "gpu_module", "cpu_format", "cpu___view", "cpu_models", "gpu_scope", "currency_view", " cpu_mode", "cpu___layout", "cpu_description", "currencyLoglayout", "currencyLogview", "cpu__mode", "cpuLogmodel", "gpu_models", "cpu_variable", "cpulexmodel", "gpu_model", "cpulexmode", "cpu___description", "currency_layout"], "kernel_filename": ["templateFlength", "kernelFdirectory", "storageblockfile", "kerneljfilename", "kernelblockfilename", "kernelFfilename", "kernellogfil", "kernellogfiles", "gpu_fil", "gpuingfil", "storage_name", "kernelingfilename", "storage_profile", "kerneljlength", "kernel_files", "kernellogfilename", "kernel_length", "templateFdescription", "storageblockprofile", "kernel_theme", "kernel_description", "kernelingfil", "gpu_files", "kernel_name", "storage_filename", "template_filename", "storage_file", "gpu_filename", "gpuingfilename", "template_length", "kernelingfiles", "storageblockname", "kernel_directory", "kernelblockprofile", "storageblockfilename", "templateFfilename", "kernelingtheme", "kernelblockfile", "gpuingtheme", "template_description", "kernel_profile", "kernel_fil", "gpuingfiles", "kerneljdescription", "gpu_theme", "template_directory", "kernelFlength", "templateFdirectory", "kernelblockname", "kernelFdescription", "kernellogtheme", "kernel_file", "kerneljdirectory"], "cpu": ["pc", "program", "process", "board", "core", "jp", "image", "platform", "uci", "pool", "net", "component", "px", "gc", "performance", "thread", "nic", "cm", "lu", "loader", "cp", "node", "gru", "python", "mc", "lb", "mem", "computer", "bench", "GPU", "vm", "roc", "hw", "linux", " CPU", "uu", "flow", "gpu", "CPU", "config", "cu", "cam", "processor", "cli", "lc", "mx", "c", "kernel", "ana", "none", "cache", "cmp", "null", "lan", "clock", "proc", "cn", "boot", "pu", "mac", "eni", "prem", "chip"], "ram": ["pc", "program", "process", "gram", "core", "mode", "image", "thread", "net", "cm", "ro", "pack", "ream", "channel", "region", "rom", "Ram", "am", "nam", "gam", "sim", "mc", "mem", "dim", "RAM", "vm", "range", "ray", "hw", "disk", "array", "space", "memory", "gpu", "sc", "cam", "gra", "lam", "sam", "mor", "resource", "sum", "lan", "param", "rame", "row", "ra", "jam", "mac", "mm", "rum", "scan", "cow"], "n": ["ns", "na", "m", "dn", "ner", "j", "t", "un", "inn", "x", "name", "f", "pn", "net", "nt", "ne", "syn", "num", "mn", "N", "g", "i", "nor", "nb", "min", "en", "nat", "o", "l", "d", " N", "nr", "nc", "no", "sn", "w", "nu", "network", "k", "span", "ni", "c", " ni", "nw", "p", "b", " i", "fn", "cn", "nn", "an", "u"]}}
{"project": "qemu", "commit_id": "891fb2cd4592b6fe76106a69e0ca40efbf82726a", "target": 0, "func": "static void ohci_reset(void *opaque)\n\n{\n\n    OHCIState *ohci = opaque;\n\n    OHCIPort *port;\n\n    int i;\n\n\n\n    ohci_bus_stop(ohci);\n\n    ohci->ctl = 0;\n\n    ohci->old_ctl = 0;\n\n    ohci->status = 0;\n\n    ohci->intr_status = 0;\n\n    ohci->intr = OHCI_INTR_MIE;\n\n\n\n    ohci->hcca = 0;\n\n    ohci->ctrl_head = ohci->ctrl_cur = 0;\n\n    ohci->bulk_head = ohci->bulk_cur = 0;\n\n    ohci->per_cur = 0;\n\n    ohci->done = 0;\n\n    ohci->done_count = 7;\n\n\n\n    /* FSMPS is marked TBD in OCHI 1.0, what gives ffs?\n\n     * I took the value linux sets ...\n\n     */\n\n    ohci->fsmps = 0x2778;\n\n    ohci->fi = 0x2edf;\n\n    ohci->fit = 0;\n\n    ohci->frt = 0;\n\n    ohci->frame_number = 0;\n\n    ohci->pstart = 0;\n\n    ohci->lst = OHCI_LS_THRESH;\n\n\n\n    ohci->rhdesc_a = OHCI_RHA_NPS | ohci->num_ports;\n\n    ohci->rhdesc_b = 0x0; /* Impl. specific */\n\n    ohci->rhstatus = 0;\n\n\n\n    for (i = 0; i < ohci->num_ports; i++)\n\n      {\n\n        port = &ohci->rhport[i];\n\n        port->ctrl = 0;\n\n        if (port->port.dev) {\n\n            usb_attach(&port->port, port->port.dev);\n\n        }\n\n      }\n\n    if (ohci->async_td) {\n\n        usb_cancel_packet(&ohci->usb_packet);\n\n        ohci->async_td = 0;\n\n    }\n\n    DPRINTF(\"usb-ohci: Reset %s\\n\", ohci->name);\n\n}\n", "idx": 18741, "substitutes": {"opaque": ["operace", "ipcot", "operacity", "Opaque", "ipque", "OPcot", "Opque", "operatile", "Opaques", "opatile", "opacity", "indaque", "OPque", "operaque", "ovaque", "OPaques", "indace", "ipaques", "indatile", "Opcot", "opcot", "OPaque", "opace", "ovace", "ipaque", "opaques", "ovatile", "ovacity", "indacity", "opque"], "ohci": ["hopcin", " ohsci", "uhci", "ihcci", " ohco", "ohki", "ophcu", "ohcit", "hcin", "oylc", "ohii", "ohdi", "ovc", "ohco", "ophii", "hopci", "hco", "ochki", "ohlc", "ahci", "ehsci", "ahdi", "ihci", "ehpi", "oshcu", "ohce", "ihlc", "ovlc", "ehdi", "ehco", "ehci", "oyci", " ohce", " ohcu", "ovki", "OHci", " ohlc", "ahco", "ovcci", "ihcit", "oshcin", "ihni", " ohki", "ovci", "oksci", "ovcit", "ahlc", "ihpi", "OHcci", "hcu", "ehki", " ohni", "okco", "ophci", "OHcu", "hlai", "ehcit", "hai", "ovcu", "ehc", "hlc", "ohCI", "okci", "ovce", "ohsci", "ahCI", "ohai", "hcit", "howco", "oycin", " ohdi", "hdi", "oshii", " ohcci", "ehlc", " ohcit", "uhco", "ihki", "okcit", "ohcci", "hopcu", "hcci", "ovsci", "ahc", "hni", "ophcin", "ehcu", "ihai", "uhni", "howci", "ahsci", "hldi", "ehce", "ihco", "howce", "oshci", "hlni", "hlCI", "ihcin", "hlci", "hopco", "ohc", "ihCI", "ochcu", "ophsci", "oyco", "ahcit", "ohcu", "ohni", "ahcu", "hlcu", "ehcin", "ahki", "ochii", "ehcci", "ovco", "ohpi", "ihdi", "hlcin", "howcci", "howcu", "hci", "uhlc", " ohcin", "ihcu", "oypi", "ophc", "oyni", "hopki", "oycu", "OHki", "ehii", "ihce", "ochci", "howlc", "ohcin", "oyki", "ihii"], "port": ["point", "child", "pod", "ports", "service", "report", "machine", "control", "contract", "pair", "select", "path", "import", "config", "pipe", "id", "slave", "p", "interface", "end", "source", "pt", "target", "ion", "plugin", "part", "direction", "name", "bridge", "stream", "app", "object", "controller", "PORT", "parent", "patch", "dev", "table", "export", "connection", "bus", "transfer", "image", "component", "proxy", "type", "match", "oper", "nat", "plane", "dp", "host", "device", "post", "address", "Port", "project", "state", "pin", "group", "pid", "ort", "pool", "feed", "option", "module", "public", "tag", "ip", "prop", "mount", "unit", "driver", "server"], "i": ["gi", "ti", "uri", "m", "bi", "j", "s", "ji", "ami", "udi", "info", "f", "name", "x", "ix", "ini", "qi", "gu", "io", "ai", "n", "phi", "mi", "z", "ii", "ie", "iu", "index", "mini", "di", "I", "slice", "multi", "zi", "count", "o", "ip", "l", "d", "yi", "pi", "ui", "ci", "key", "id", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "a", "eni", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "59800ec8e52bcfa271fa61fb0aae19205ef1b7f1", "target": 0, "func": "uint64_t helper_fsub(CPUPPCState *env, uint64_t arg1, uint64_t arg2)\n\n{\n\n    CPU_DoubleU farg1, farg2;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n\n\n    if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d) &&\n\n                 float64_is_neg(farg1.d) == float64_is_neg(farg2.d))) {\n\n        /* Magnitude subtraction of infinities */\n\n        farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXISI);\n\n    } else {\n\n        if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                     float64_is_signaling_nan(farg2.d))) {\n\n            /* sNaN subtraction */\n\n            fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN);\n\n        }\n\n        farg1.d = float64_sub(farg1.d, farg2.d, &env->fp_status);\n\n    }\n\n\n\n    return farg1.ll;\n\n}\n", "idx": 18744, "substitutes": {"env": ["viron", "txt", "db", "session", "code", "global", "cal", "dep", "conf", "here", "forge", "engine", "eu", "exc", "loader", "enter", "cb", "oa", "np", "chal", "erv", "chev", "environment", "ext", "shell", "console", "manager", "en", "fen", "eng", "energy", "enc", "her", "context", "him", "kn", "Environment", "iss", "keeper", "config", "ev", "queue", "e", "bot", "qt", "c", "ea", "que", "cache", "ec", "proc", "er", "eni", "enh", "ah", "conn"], "arg1": ["paramb", "argumentone", "argone", " argb", "argsone", "args01", "argument1", "paramone", "argument01", "args2", "arg01", "Arg1", "Argone", "argument2", " argone", "Argb", "param1", "args1", "Arg2", "argb", " arg01", "param2"], "arg2": ["ig1", " argb", "ark2", "ark1", "argument1", "arg0", " arg0", "ark4", "Arg1", "argument2", " argtwo", "argument4", "igb", "Argb", "arg4", "Argtwo", "argtwo", "Arg2", "ark0", "igtwo", "argument0", "ig2", " arg4", "argb"], "farg1": ["fargumentone", "fax2", " fArgth", "fargb", "flodef8", " fargb", "fagn5", "fmag41", "farm2", "fplay1", "infargone", "farg8", "fmag51", "fargpart", "fargument1", "fvalone", "fdef2", "infargart", "fag61", "fplayone", "fgen100", " fargone", "fag1", "farg41", "farm91", "frarg91", "faxone", "farg100", " fargspart", "infgen1", " farg3", "flodef2", "infgen61", "fargument81", "fergpart", "fval1", "fmag2", "fargs3", "fagone", "fdef1", "frmag01", " fArg1", "farg1001", "frmag91", "fmag1", "frarg1", "fArgone", "fag1001", "infag1001", "farmone", "fargone", "floarg1", "infarg1", "fregone", "fvar100", " farg01", "floarg8", "fargs1", "fArg81", "fArg2", "floarg2", "fagn1", "infgenart", " fargs5", "infarg100", "fmag91", "fax1001", "fvarart", "fresult61", "ferg5", "fresultone", "fgen61", "fmag8", "fargument100", " fargs3", "fresult1", "fArgth", "fgen91", "infarg61", "fgenart", "farg61", "fplay81", "fgen41", "fax01", "fagnpart", "fargsb", "fplayth", " farg5", "frarg01", "frmag41", "fvar1", "farg81", "flodef51", "freg1", " fArg81", "farg5", "floarg51", "ferg1", "fargart", "fax1", "fvar61", "farg01", "fergb", "fmag01", "fargumentth", "fgen01", "infarg1001", "farm3", " fargsone", "figpart", "fargth", "fArg01", "fargspart", "farg91", "fArgb", "fargument61", "faxb", " farg81", "frarg41", " fArgone", "fval3", "fig1", "fargs5", "freg2", "infag61", "fig3", "fdef8", "fresult1001", "freg3", "farg51", "fargsone", "infag1", "fdef51", "fArg1", "farg3", "fargumentart", " fargs1", "infagone", "fvalpart", "flodef1", "farm41", "infgen100", "fax61", "frmag1", " fargth", "figone", " fargsb", "fgen1", "farm1", " fargpart", "farm01", "fagnb"], "farg2": ["fax2", " fax1", "fregtwo", " fcall7", "fuseii", "afargSecond", "fargb", " finctwo", "figSecond", "fang3", " fargb", " fax2", "fgen22", " farg9", " fang2", "fcall2", "fregsecond", " finc9", "fplay2", "fuse2", " farg92", "fargs2", "afig1", "fplay22", " farg3", " fargii", "farg9", "afargsecond", "frockii", "finctwo", "fig2", "fmag2", "fargTwo", "frock7", "fuse7", "fplay02", " faxb", "figb", "afigsecond", "afigTwo", "fang2", " fax02", " fcall92", " fcallii", "faggTwo", " farg7", "fargs1", "fArg2", "fArgTwo", "finc02", "fuse92", "fArgSecond", "fargii", "fagg9", "afigSecond", "fargSecond", "fargsb", "figsecond", "farg92", " finc02", "afigb", "afig2", "freg1", "finc2", "figTwo", "fgen2", "finc9", "fax1", "fmag02", "faggtwo", "fcall92", " fang02", "fargtwo", "fang22", "afigtwo", " fang22", " finc2", "farg7", " fcall2", "fArgb", "faggb", "faxb", "afargb", " fang3", "farg22", "fgen02", "fig1", "fgen3", " farg02", "freg2", "farg02", "fargsecond", "fargs02", "frock2", "figtwo", "afarg1", "fplay3", "farg3", " farg22", "fagg02", "fang02", "fmag9", "fcall7", "afargtwo", "fax02", "fcallii", " fargtwo", "fagg2", "afarg2", "fmagtwo", "frock92", "afargTwo", "faggSecond"]}}
{"project": "qemu", "commit_id": "0f8c289ad539feb5135c545bea947b310a893f4b", "target": 1, "func": "static int net_socket_connect_init(NetClientState *peer,\n\n                                   const char *model,\n\n                                   const char *name,\n\n                                   const char *host_str)\n\n{\n\n    NetSocketState *s;\n\n    int fd, connected, ret;\n\n    struct sockaddr_in saddr;\n\n\n\n    if (parse_host_port(&saddr, host_str) < 0)\n\n        return -1;\n\n\n\n    fd = qemu_socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n    qemu_set_nonblock(fd);\n\n\n\n    connected = 0;\n\n    for(;;) {\n\n        ret = connect(fd, (struct sockaddr *)&saddr, sizeof(saddr));\n\n        if (ret < 0) {\n\n            if (errno == EINTR || errno == EWOULDBLOCK) {\n\n                /* continue */\n\n            } else if (errno == EINPROGRESS ||\n\n                       errno == EALREADY ||\n\n                       errno == EINVAL) {\n\n                break;\n\n            } else {\n\n                perror(\"connect\");\n\n                closesocket(fd);\n\n                return -1;\n\n            }\n\n        } else {\n\n            connected = 1;\n\n            break;\n\n        }\n\n    }\n\n    s = net_socket_fd_init(peer, model, name, fd, connected);\n\n    if (!s)\n\n        return -1;\n\n    snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n             \"socket: connect to %s:%d\",\n\n             inet_ntoa(saddr.sin_addr), ntohs(saddr.sin_port));\n\n    return 0;\n\n}\n", "idx": 18759, "substitutes": {"peer": ["pc", "request", "friend", "vr", "fp", "proxy", "pe", "worker", "loader", "master", "node", "player", "pb", "manager", "cer", "owner", "host", "gp", "seed", "socket", "pri", "ssl", "remote", "client", "parent", "p", "address", "http", "ppa", "ker", "proc", "er", "pro", "port", "server", "reader"], "model": ["plugin", "prov", "m", "instance", "brand", "db", "mode", "base", "image", "media", "proxy", "cm", "bm", "loader", "module", "block", "models", "ctx", "manager", "object", "host", "context", "layer", "config", "ssl", "client", "stage", "address", "Model", "que", "resource", "param", "message", "port", "server", "source", "reader"], "name": ["part", "time", "data", "x", "image", "n", "family", "str", "block", "anc", "type", "nam", "Name", "self", "object", "host", "NAME", "space", "path", "size", "no", "prefix", "key", "named", "config", "id", "client", "parent", "address", "none", "names", "connection", "word", "server", "version"], "host_str": ["host2Str", "host_string", "hostacstring", "host_Str", "host_set", " host_string", "hostacStr", " host_set", "hostacstr", " host_Str", "hostacset", "host2str", "host2set", "host2string"], "s": ["ns", "ts", "sg", "bs", "session", "stats", "func", "uns", "obj", "f", "rs", "aws", "conf", "sp", "services", "n", "sb", "g", "sl", "ys", "ss", "ls", "ops", "sec", "fs", "is", "o", "cs", "d", "su", "obs", "socket", "sn", "args", "qs", "sc", "ssl", "e", "ses", "sync", "comments", "js", "ps", "si", "c", "sym", "p", "sts", "S", "gs", "sys", "es", "os", "state", "server", "south", "sq", "se", "an", "sa", "conn", "ds"], "fd": ["dc", " conn", "dd", "dn", "draft", "db", "fw", "nd", "ff", "connect", "fp", "gd", "f", "td", "fe", " fin", "pd", "fa", "cf", "cb", " ff", "hd", "stream", "function", "dt", " fid", "fc", " f", "fin", "ld", "dl", "fs", "wd", "sd", "fen", "fed", "ind", "lf", "wind", "ln", "fx", "d", "fl", "df", "FD", "socket", "bd", "ad", "pipe", "handler", "sf", "fb", "xd", "client", "temp", "da", "fn", "cd", "connection", " df", "fi", "conn", "ds", " FD"], "connected": ["broken", "registered", "connect", "finished", "initialized", "updated", "checked", "running", "Connect", "reg", "confirmed", "fun", " closed", "current", "established", "called", "bc", "index", "ind", "started", "ended", "active", "en", "count", "loaded", "handled", "bound", "opened", "cond", "owned", " disconnected", "ed", "socket", "con", "config", "disabled", "sc", "selected", "open", "client", "sync", "controlled", "seq", "sent", "closed", "enabled", "connection", "supported", "valid", "circ", "conn", "locked"], "ret": ["not", "status", "ner", "j", "connect", "obj", "bit", "ref", "alt", "reg", "nt", "rc", "rt", "fun", "result", "num", "cb", "bc", "resp", "rets", "count", "cond", "att", "val", "re", "found", "Ret", "no", "con", "bd", "det", "sr", "rev", "temp", "success", "rb", "RET", "red", "res", "connection", "reply", "conn", "len"], "saddr": ["whost", "shost", "ssladdress", "_address", "chost", "waddress", "jsafi", " sattr", "gaddr", "cport", " saddress", "skyaddress", "skyattr", "_host", "_port", "serveraddress", "skyaddr", " svr", "daddress", "gaddress", "ssaddr", "servicelayer", "naddr", "sshost", " shost", "jsaddr", "ssvr", "ssaddress", "skylayer", "sadr", "sport", "caddress", "nport", "jsdb", " sdb", "syncadr", "caddr", "wAddress", "slayer", "ddb", "safi", "serviceattr", "serveraddr", "sslAddress", "dafi", "synclayer", "ssladdr", "sattr", "sdb", "sentry", "naddress", "gattr", "syncattr", "skyentry", "serviceadr", "daddr", "nhost", "waddr", "jsaddress", " sentry", "serverAddress", "wvr", " safi", "saddress", "serviceaddr", "syncaddr", "sAddress", "gentry", "_addr", "skyadr", "svr"]}}
{"project": "qemu", "commit_id": "3ad9fd5a257794d516db515c217c78a5806112fe", "target": 1, "func": "static int64_t load_kernel (void)\n\n{\n\n    int64_t kernel_entry, kernel_high;\n\n    long initrd_size;\n\n    ram_addr_t initrd_offset;\n\n    int big_endian;\n\n    uint32_t *prom_buf;\n\n    long prom_size;\n\n    int prom_index = 0;\n\n    uint64_t (*xlate_to_kseg0) (void *opaque, uint64_t addr);\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    big_endian = 1;\n\n#else\n\n    big_endian = 0;\n\n#endif\n\n\n\n    if (load_elf(loaderparams.kernel_filename, cpu_mips_kseg0_to_phys, NULL,\n\n                 (uint64_t *)&kernel_entry, NULL, (uint64_t *)&kernel_high,\n\n                 big_endian, ELF_MACHINE, 1) < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                loaderparams.kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    /* Sanity check where the kernel has been linked */\n\n    if (kvm_enabled()) {\n\n        if (kernel_entry & 0x80000000ll) {\n\n            error_report(\"KVM guest kernels must be linked in useg. \"\n\n                         \"Did you forget to enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_kvm_um_phys_to_kseg0;\n\n    } else {\n\n        if (!(kernel_entry & 0x80000000ll)) {\n\n            error_report(\"KVM guest kernels aren't supported with TCG. \"\n\n                         \"Did you unintentionally enable CONFIG_KVM_GUEST?\");\n\n            exit(1);\n\n        }\n\n\n\n        xlate_to_kseg0 = cpu_mips_phys_to_kseg0;\n\n    }\n\n\n\n    /* load initrd */\n\n    initrd_size = 0;\n\n    initrd_offset = 0;\n\n    if (loaderparams.initrd_filename) {\n\n        initrd_size = get_image_size (loaderparams.initrd_filename);\n\n        if (initrd_size > 0) {\n\n            initrd_offset = (kernel_high + ~INITRD_PAGE_MASK) & INITRD_PAGE_MASK;\n\n            if (initrd_offset + initrd_size > ram_size) {\n\n                fprintf(stderr,\n\n                        \"qemu: memory too small for initial ram disk '%s'\\n\",\n\n                        loaderparams.initrd_filename);\n\n                exit(1);\n\n            }\n\n            initrd_size = load_image_targphys(loaderparams.initrd_filename,\n\n                                              initrd_offset,\n\n                                              ram_size - initrd_offset);\n\n        }\n\n        if (initrd_size == (target_ulong) -1) {\n\n            fprintf(stderr, \"qemu: could not load initial ram disk '%s'\\n\",\n\n                    loaderparams.initrd_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Setup prom parameters. */\n\n    prom_size = ENVP_NB_ENTRIES * (sizeof(int32_t) + ENVP_ENTRY_SIZE);\n\n    prom_buf = g_malloc(prom_size);\n\n\n\n    prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_filename);\n\n    if (initrd_size > 0) {\n\n        prom_set(prom_buf, prom_index++, \"rd_start=0x%\" PRIx64 \" rd_size=%li %s\",\n\n                 xlate_to_kseg0(NULL, initrd_offset), initrd_size,\n\n                 loaderparams.kernel_cmdline);\n\n    } else {\n\n        prom_set(prom_buf, prom_index++, \"%s\", loaderparams.kernel_cmdline);\n\n    }\n\n\n\n    prom_set(prom_buf, prom_index++, \"memsize\");\n\n    prom_set(prom_buf, prom_index++, \"%i\",\n\n             MIN(loaderparams.ram_size, 256 << 20));\n\n\n\n    prom_set(prom_buf, prom_index++, \"modetty0\");\n\n    prom_set(prom_buf, prom_index++, \"38400n8r\");\n\n    prom_set(prom_buf, prom_index++, NULL);\n\n\n\n    rom_add_blob_fixed(\"prom\", prom_buf, prom_size,\n\n                       cpu_mips_kseg0_to_phys(NULL, ENVP_ADDR));\n\n\n\n\n    return kernel_entry;\n\n}", "idx": 18773, "substitutes": {"kernel_entry": ["loader_archive", "program_depth", "program_service", "loader_ident", "kerneldentry", "kernelallident", "kernel_cell", "kernel_archive", " kernel_low", "loader_entry", "kernel_low", "loader_data", " kernel_config", "kernel_ident", "kerneldconfig", "program_cell", "kernel_start", "kernel_system", "program_entry", " kernel_end", "kernelacsystem", "kernel_config", "kernel_data", "kerneldsystem", "kerneldstart", "kernelallentry", "kernelalldata", "kernel_service", "kernel_end", "kernel_depth", "kernelacentry", " kernel_system", "kernelacstart", "kernelallarchive", " kernel_start", "kernelacconfig"], "kernel_high": ["system_low", "kernel7target", "kernel7source", "kernel_location", "kernelaclocation", "kernel_source", "machine_location", "machine_source", "machineaclocation", "kernelactarget", "machine_high", "machineacsource", "kernelacsource", "system_large", "machine_entry", "kernelachigh", "kernel_mid", "machineactarget", "kernel_large", "machineachigh", "kernel7location", "kernel_target", "system_high", "machine_large", "machine_end", "kernel_end", "machine_target", "kernel7high", "kernel_low", "system_mid"], "initrd_size": ["initrl_size", "initrd_length", "initrdCsize", "initdd_data", "initrd_width", "initrr_address", "initri_size", "initld_size", "initrd_unit", "initld_SIZE", "initrdacbody", "initld_unit", "initrr_ize", "initrd_data", "initrdFshape", "initrr_size", "initrd_shape", "initrr_name", "initrdacsize", "initrl___score", "initrd_SIZE", "initddFdata", "initrdFsize", "initddFsize", "initrd_ize", "initrd___score", "initdd_shape", "initri_sum", "initld_name", "initri_width", "initri_area", "initld_body", "initrdaclength", "initdd_size", "initrdacSIZE", "initrdCshape", "initrl___name", "initrd_name", "initrd_address", "initrd_sum", "initrd_score", "initld_scale", "initrdFdata", "initrdCdata", "initrl_score", "initrl_name", "initrd_scale", "initrl___size", "initrd_body", "initrd___name", "initld_length", "initrd___size", "initrd_area", "initddFshape"], "initrd_offset": ["initrdFskip", "initrodxstart", "initrt_Offset", "initrd_position", "initrodxfrom", "initrdXstart", "initrost_skip", "new", "initrost_size", "initrod_from", "initrdxfrom", "initrd67Offset", "initrd_loc", "initrdxstart", "initrdXfrom", "initrost_position", "initrod_start", "initrod_offset", "initrost_entry", "initrd_start", "initrt_size", "initrd_entry", "linux", "initrdFsize", "initrd_slot", "initrd_Offset", "process", "initrt_slot", "initrdxoffset", "initrt_position", "initrdXsize", "cpu", "this", "initrost_offset", "initrt_offset", "initrdFloc", "initrodxoffset", "initrd_skip", "initrd_from", "initrodxsize", "initrd67slot", "s", "initrt_entry", "initrod_size", "initrdxsize", "all", "initrdXoffset", "initrd67offset", "g", "get", "initrdFoffset", "_", "initrost_loc", "proc"], "big_endian": ["big_endedian", "big_endedlic", "big_stopio", "big_endinglic", "big_endedians", "big_endingians", "big_endric", "big_endIAN", "big_endingric", "big_endsIAN", "big_endingIAN", "big_endrian", "big_endingrian", "big_pendien", "big_endlic", "big_endien", "big_pendians", "big_endingig", "big_endedric", "big_stopians", "big_stopian", "big_endsian", "big_endians", "big_endio", "big_endingian", "big_pendian", "big_pendio", "big_endsig", "big_stopien", "big_endsians", "big_endedrian", "big_endig"], "prom_buf": ["rem_buf", "rem_buffer", "prom_buff", "prom_alloc", "prom2alloc", "rem_alloc", "prom2buf", "prom_buffer", "prom2buff", "rem_buff", "prom2buffer"], "prom_size": ["prom_mode", "promacmode", "ram_index", "prom67size", "promacindex", "promacsize", "promacname", "ram_name", "prom67mode", "prom67index", "ram_size", "prom67name", "prom_name", "ram_mode"], "xlate_to_kseg0": ["xlate_to_ksega0", "xlate_to_ksegin50", "xlate_to_ksegin0", "xlate_to_ksega50", "xlate_to_ksegin10", "xlate_to_ksegam1", "xlate_to_ksegin2", "xlate_to_kseg10", "xlate_to_ksegam0", "xlate_to_kseg50", "xlate_to_ksegment0", "xlate_to_ksega2", "xlate_to_ksegment3", "xlate_to_ksegam50", "xlate_to_ksegin3", "xlate_to_kseg4", "xlate_to_ksegment2", "xlate_to_ksega10", "xlate_to_ksegin1", "xlate_to_ksegm1", "xlate_to_ksegment1", "xlate_to_ksegam10", "xlate_to_ksegm4", "xlate_to_ksegm0", "xlate_to_kseg1", "xlate_to_ksega3", "xlate_to_ksega4", "xlate_to_ksega1", "xlate_to_kseg2", "xlate_to_ksegment4", "xlate_to_kseg3"], "opaque": ["ompbuffer", "ipaque", "ipbuffer", "operac", "opac", "opcode", "ompac", "ompcode", "opercode", "ompaque", "operbuffer", "ipac", "operaque", "opbuffer", "ipcode"], "addr": ["extra", "Address", "data", "x", "image", "src", "ptr", "pos", "byte", "host", "array", "args", "map", "seq", "address", "null", "alloc", "proc"], "prom_index": ["gram_index", "prom_no", "gram2pos", "gram_no", "gram_addr", "prom2index", "prom_addr", "gram2no", "gram2index", "gram_pos", "prom_pos", "prom2no", "prom2pos", "gram2addr", "prom2addr"]}}
{"project": "qemu", "commit_id": "0fb6395c0cb5046432a80d608ddde7a3b2f8a9ae", "target": 0, "func": "static void test_validate_fail_union_anon(TestInputVisitorData *data,\n\n                                          const void *unused)\n\n{\n\n    UserDefAnonUnion *tmp = NULL;\n\n    Visitor *v;\n\n    Error *errp = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAnonUnion(v, &tmp, NULL, &errp);\n\n    g_assert(error_is_set(&errp));\n\n    qapi_free_UserDefAnonUnion(tmp);\n\n}\n", "idx": 18781, "substitutes": {"data": ["m", "Data", "init", "txt", "record", "t", "base", "f", "media", "buffer", "input", "result", "window", "i", "this", "done", "def", "self", "parser", "o", "fake", "d", "empty", "style", "config", "xxx", "start", "buf", "parent", "temp", "da", "p", "test", "dat", "u", "api", "DATA", "valid", "li", "reader"], "unused": [" unbused", " unuse", " unus", " uninitialized", "Unuse", " unbuse", "Uninitialized", " unbus", "unus", "uninitialized", "unuse", "Unus", "Unused", " unbinitialized"], "tmp": ["Temp", "tt", "txt", "j", "t", "metadata", "obj", "f", "dest", "jp", "sb", "cpp", "var", "wb", "ctx", "pb", "self", "lv", "copy", "po", "vm", "fake", "uv", "array", "tc", "st", "buf", "fb", "temp", "c", "tv", "rb", "p", "vt", "test", "mp", "b", "cmp", "vv", "api", "tp", "nv", "np", "kk", "cv", "amp", "verb"], "v": ["m", "V", "j", "t", "obj", "f", "sv", "vc", "vp", "n", "g", "i", "z", "vd", "vi", "lv", "o", "vm", "uv", "l", "d", "fl", "conv", "w", "e", "q", "vs", "k", "ant", "temp", "c", "tv", "vu", "p", "vt", "test", "vv", "va", "h", "iv", "nv", "ve", "cv", "version", "u"], "errp": ["Erf", "iterp", "rrpre", "errP", " erP", "errpr", " erps", "enerp", "iterpr", "erpre", "erps", "rrpa", "rrpo", "erf", "errpre", "erp", "rrf", " erp", "errpo", "enerpa", "errpa", "rrpr", "rrp", "enerpre", "errps", "erP", "rrps", "iterpre", " erpre", "enerpr", "rrP", "erpo", "errf", "Erpo", "iterpa", "Erp", "ErP"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_virtqueue_init(struct vhost_dev *dev,\n\n                                struct vhost_virtqueue *vq, int n)\n\n{\n\n    struct vhost_vring_file file = {\n\n        .index = n,\n\n    };\n\n    int r = event_notifier_init(&vq->masked_notifier, 0);\n\n    if (r < 0) {\n\n        return r;\n\n    }\n\n\n\n    file.fd = event_notifier_get_fd(&vq->masked_notifier);\n\n    r = dev->vhost_ops->vhost_call(dev, VHOST_SET_VRING_CALL, &file);\n\n    if (r) {\n\n        r = -errno;\n\n        goto fail_call;\n\n    }\n\n    return 0;\n\nfail_call:\n\n    event_notifier_cleanup(&vq->masked_notifier);\n\n    return r;\n\n}\n", "idx": 18799, "substitutes": {"dev": ["dc", "Dev", "dd", "db", "mod", "data", "info", "conf", "gd", "comment", "engine", "md", "gu", "debug", "de", "ver", "rad", "root", "app", "block", "var", "node", "di", "def", "development", "der", "self", "d", "hw", "w", "ev", "ad", "client", "v", "device", "cache", "DEV", "end", "valid", "die", "diff", "conn", "bug"], "vq": ["vcdq", "vmq", "nvq", "svq", "pquest", "tvq", " viq", "variqu", "vp", "pq", "variq", "vmp", " vQ", "pdq", "nvp", "svque", "pQ", "tvqu", "vmquest", "svqu", "eviq", "tvquery", "viq", "tvque", "vqi", "vcq", "vcquest", "svquery", "variquery", "nvqi", " vqa", "svqi", "evq", "vmqi", "svp", "vque", "vqu", "evqi", " vquest", "varique", "vquest", "nviq", " vqi", "nvqa", "vQ", " vdq", "nvquest", "vqa", "vdq", "vcQ", "vquery", "evqa", "svquest"], "n": ["ns", "na", "m", "init", "s", "t", "x", "name", "f", "r", "ne", "num", "N", "g", "i", "node", "index", "nb", "en", "nat", "o", "nm", "l", "d", "nc", "network", "sn", "w", "k", "e", "v", "c", "p", "b", "number", "a", "nn", "u"]}}
{"project": "FFmpeg", "commit_id": "c90b88090c260a0af018b6c1e955266e24ebf6f4", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *src_buffer)\n\n{\n\n    AVFilterContext  *ctx = inlink->dst;\n\n    ATempoContext *atempo = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n\n\n    int ret = 0;\n\n    int n_in = src_buffer->nb_samples;\n\n    int n_out = (int)(0.5 + ((double)n_in) / atempo->tempo);\n\n\n\n    const uint8_t *src = src_buffer->data[0];\n\n    const uint8_t *src_end = src + n_in * atempo->stride;\n\n\n\n    while (src < src_end) {\n\n        if (!atempo->dst_buffer) {\n\n            atempo->dst_buffer = ff_get_audio_buffer(outlink, n_out);\n\n            if (!atempo->dst_buffer)\n\n                return AVERROR(ENOMEM);\n\n            av_frame_copy_props(atempo->dst_buffer, src_buffer);\n\n\n\n            atempo->dst = atempo->dst_buffer->data[0];\n\n            atempo->dst_end = atempo->dst + n_out * atempo->stride;\n\n        }\n\n\n\n        yae_apply(atempo, &src, src_end, &atempo->dst, atempo->dst_end);\n\n\n\n        if (atempo->dst == atempo->dst_end) {\n\n            int n_samples = ((atempo->dst - atempo->dst_buffer->data[0]) /\n\n                             atempo->stride);\n\n            ret = push_samples(atempo, outlink, n_samples);\n\n            if (ret < 0)\n\n                goto end;\n\n        }\n\n    }\n\n\n\n    atempo->nsamples_in += n_in;\n\nend:\n\n    av_frame_free(&src_buffer);\n\n    return ret;\n\n}\n", "idx": 18812, "substitutes": {"inlink": ["inlog", " inlog", "outline", "innercall", "innerLink", "innlog", "incstyle", "incmachine", " instyle", "innerlink", "innerline", "outcall", " inLink", " inmachine", "innstyle", "innlink", "innmachine", " incall", "incall", "instyle", "outLink", "inLink", "inmachine", "inclog", "inclink"], "src_buffer": ["source_layer", "rc_buffer", "src2buf", " src_buf", "src00handler", "src_handler", "source_uffer", "rc_queue", " src_queue", "source_source", "src_buf", "src00queue", "rc_cache", "source_buffer", "rc_handler", "src_layer", "src00buffer", "src_source", "src2buffer", "src2queue", "source_queue", "src_queue", "src__queue", "src_reference", "src_buff", "src_cache", "src_uffer", "src__buf", "rc_buff", "src__buffer", "source_reference"], "ctx": ["instance", "init", "btn", "fw", "conf", "cca", "jp", "cus", "ref", "obj", "conn", "rc", "cm", "cf", "cpp", "cb", "anc", "cp", "bc", "loc", "utils", "ctrl", "act", "cas", "Context", "ca", "exec", "cs", "context", "hw", "conv", "pkg", "tx", "ci", "tc", "config", "xc", "cli", "lc", "c", "cmd", "cmp", "cn", "cv", "cc"], "atempo": ["iampa", "tmapo", "impos", "empos", "ormpo", "iempe", "ommpa", "iempo", "edompos", "atemapo", "impi", "idempi", "ommo", "ommppo", "atempa", "ammapo", "adempo", "iampi", "tmpos", "edompo", "tmpi", "amypi", "ormote", "tmote", "atemcho", "impa", "emapo", "temapo", "impo", "tomapo", "temota", "ompi", "iamo", "atemota", "edomota", "immo", "ademota", "dempi", "ammpo", "dempe", "ompos", "atempe", "iampos", "tempo", "adempe", "empi", "immpo", "immpos", "temo", "dempo", "iampe", "ommapo", "omo", "idempo", "amenpi", "tmpo", "amypo", "ymmcho", "mmote", "ommpe", "immote", "idempa", "ymapo", "tempos", "ymmbo", "adempa", "amenpos", "tempa", "atemo", "ademo", "atemppo", "ammpe", "impe", "atembo", "iempa", "mmpos", "ymcho", "demppo", "iempi", "tombo", "emo", "amyo", "iampo", "emanpos", "ademppo", "imo", "ompo", "aimpos", "ymbo", "gampo", "aimo", "gampe", "temote", "atempi", "mmpo", "ammo", "ommpo", "atemote", "tmpa", "edomo", "tomcho", "ameno", "ormapo", "tempi", "amypos", "adempos", "ammpi", "emanpa", "iemo", "gampi", "idempos", "empo", "ammpos", "atempos", "demo", "amenpo", "aimpo", "gampos", "iemapo", "emanpi", "emanpe", "ommpos", "tompo", "ammote", "adempi", "ommpi", "ormpos", "dempos", "ammpa", "iempos", "mmo", "aimapo", "ympo", "emanpo", "ymmapo", "ademote", "ymmpo", "ademapo", "iemote", "tmpe"], "outlink": ["outload", "mainlink", "outline", "offlinked", "outlinks", "againline", "inloop", "offlink", "OutLink", " outLink", "outlinked", " outloop", "offLink", "outLink", " outlinks", "Outline", "againLink", " outdo", "againlink", "outdo", "offdo", "againload", " outload", "againlinks", "Outlink", "outloop", "Outload", " outline", "maindo", " outlinked", "mainlinked", "inlinks", "mainLink", "againloop"], "src": ["uri", "sup", "sit", "sur", "data", "core", "rs", "rest", "dest", "text", "RC", "scene", "rc", "sb", "stream", "cb", "sl", "bc", "loc", "ources", "sel", "sec", "filename", "username", "head", "again", "gb", "rec", "rob", "rib", "sub", "length", "img", "sr", "sc", "ssl", "send", "st", "start", "config", "ource", "req", "cur", "rb", "tmp", "rss", "uc", "url", "rl", "sys", "proc", "inst", "sq", "source", "dist"], "src_end": [" src_ending", "rc_ended", "src_ends", "src0ends", "src0end", " src_ends", " src_close", "src0ending", "src_close", "src_entry", "src_ended", "src_ending", "src0start", "src_start", " src_entry", " src_start", "rc_end", "rc_start"]}}
{"project": "qemu", "commit_id": "1e7398a140f7a6bd9f5a438e7ad0f1ef50990e25", "target": 1, "func": "struct vhost_net *vhost_net_init(VhostNetOptions *options)\n\n{\n\n    int r;\n\n    bool backend_kernel = options->backend_type == VHOST_BACKEND_TYPE_KERNEL;\n\n    struct vhost_net *net = g_malloc(sizeof *net);\n\n\n\n    if (!options->net_backend) {\n\n        fprintf(stderr, \"vhost-net requires net backend to be setup\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    if (backend_kernel) {\n\n        r = vhost_net_get_fd(options->net_backend);\n\n        if (r < 0) {\n\n            goto fail;\n\n        }\n\n        net->dev.backend_features = qemu_has_vnet_hdr(options->net_backend)\n\n            ? 0 : (1ULL << VHOST_NET_F_VIRTIO_NET_HDR);\n\n        net->backend = r;\n\n    } else {\n\n        net->dev.backend_features = 0;\n\n        net->backend = -1;\n\n    }\n\n    net->nc = options->net_backend;\n\n\n\n    net->dev.nvqs = 2;\n\n    net->dev.vqs = net->vqs;\n\n    net->dev.vq_index = net->nc->queue_index;\n\n\n\n    r = vhost_dev_init(&net->dev, options->opaque,\n\n                       options->backend_type, options->force);\n\n    if (r < 0) {\n\n        goto fail;\n\n    }\n\n    if (backend_kernel) {\n\n        if (!qemu_has_vnet_hdr_len(options->net_backend,\n\n                               sizeof(struct virtio_net_hdr_mrg_rxbuf))) {\n\n            net->dev.features &= ~(1ULL << VIRTIO_NET_F_MRG_RXBUF);\n\n        }\n\n        if (~net->dev.features & net->dev.backend_features) {\n\n            fprintf(stderr, \"vhost lacks feature mask %\" PRIu64\n\n                   \" for backend\\n\",\n\n                   (uint64_t)(~net->dev.features & net->dev.backend_features));\n\n            vhost_dev_cleanup(&net->dev);\n\n            goto fail;\n\n        }\n\n    }\n\n    /* Set sane init value. Override when guest acks. */\n\n    vhost_net_ack_features(net, 0);\n\n    return net;\n\nfail:\n\n    g_free(net);\n\n    return NULL;\n\n}\n", "idx": 18819, "substitutes": {"options": ["words", "obj", "full", "settings", "op", "ports", "ions", "details", "six", "resources", "pos", "exec", "ims", "initial", "config", "lib", "none", "opt", "groups", "comments", "classes", "ts", "example", "content", "name", "times", "ips", "scope", "object", "o", "changes", "other", "pre", "outs", "ets", "steps", "null", "connection", "co", "ES", "image", "json", "results", "current", "cho", "or", "type", "utils", "this", "after", "final", "ex", "es", "rules", "pro", "params", "session", "s", "global", "data", "optional", "info", "io", "option", "public", "ops", "css", "args", "e", "cache", "http", "its", "names", "os", "Options", "li"], "r": ["m", "rr", "ner", "br", "j", "t", "rs", "x", "err", "f", "rc", "hr", "rt", "n", "R", "result", "ar", "i", "or", "z", "rh", "var", "rg", "run", "rf", "kr", "en", "arr", "range", "l", "d", "rd", "re", "nr", "like", "rar", "ru", "w", "rn", "sr", "k", "e", "lr", "dr", "cr", "v", "q", "c", "rl", "rb", "ir", "p", "ur", "rw", "b", "pr", "resource", "error", "res", "h", "er", "end", "attr", "u"], "net": ["ns", "set", "user", "dot", "nt", "ann", " network", "num", "ut", "mat", "web", "virtual", "vm", "non", "Net", "config", "nu", "ni", "lib", "p", "resource", "dat", "next", "output", "boot", "conn", "target", "not", "tun", "fat", "mult", "ne", "dt", "nets", "art", "plain", "kit", "key", "cat", "parent", "dev", "NET", "et", "connection", "ver", "na", "ner", "text", "core", "nic", "nit", "mot", "function", "act", "nat", "page", "inet", "network", "rn", "serv", " Net", "cn", "np", "connect", "pot", "db", "global", "data", "ort", "io", "n", "channel", "module", "en", "out", "ip", "nc", "site", "client", "unit", "cache", "server"]}}
{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820, "substitutes": {"usb_msd_init": ["usb_msd_config", "usb_msl_fix", "usb_msl_set", "usb_msd_set", "usb_msl_init", "usb_msl_config", "usb_msd_fix"], "filename": ["uri", "pty", "ename", "file", "duration", "phrase", "files", "package", "brush", "location", "nil", "jpg", "directory", "path", "feat", "kn", "initial", "length", "prefix", "asm", "p", "mpeg", "sequence", "word", "source", "Filename", "txt", "metadata", "name", "fil", "tty", "document", "description", "setup", "database", "sound", "title", "size", "whatever", "utf", "named", "lace", "binary", "exist", "download", "fp", "f", "src", "wb", "l", "generic", "material", "application", "ppa", "fn", "folder", "enabled", "sql", "params", "sf", "kl", "method", "password", "username", "maximum", "format", "il", "fd", "suff", "linear", "url", "subject", "sheet", "message", "dll"], "id": ["uri", "Id", "init", "db", "pid", "code", "data", "info", "text", "name", "bit", "ID", "base", "ref", "rid", "aid", "file", "num", "str", "i", "root", "type", "auth", "src", "in", "kid", "ctx", "bid", "ip", "head", "uid", "path", "did", "oid", "key", "start", "ad", "mid", "fd", "parent", "cat", "seq", "url", "pad", "ids", "sid", "end", "it", "desc"], "opts": ["optes", "otts", " opters", " opted", "OPts", " optt", "hopments", "OPt", "roptr", "ottics", "OPtes", "OPte", "roplets", "ropts", " optes", "obments", "ottes", " opte", " ops", "opments", " opments", " opcs", "opters", "ops", "oplets", "opcs", "optts", "optr", "obted", "hopts", "obts", "lockcs", "optlets", "optte", "locktics", "opttes", "obtes", "optments", "OPters", "opted", "ropte", "opst", "otcs", "lockte", "optters", " opt", "OPs", " optts", " opst", "optcs", " optr", "opttr", " optst", "hoptes", "optt", "otte", "hopted", " opttes", "opt", "lockts", " optics", " oplets", "otments", "optst", "optics", "OPcs", "opte"], "dinfo": ["dsinfo", "fcheck", "fInfo", "dInfo", "xdInfo", "ffo", "dnstate", "dfo", "dinf", "xdcheck", "dlservice", "dsfo", "dcheck", " dinf", "adfo", "finf", "dnInfo", " dcheck", "dlinfo", "adinfo", "dstate", "dservice", "finfo", "dlInfo", "xdinf", "adInfo", "adservice", " dfo", " dservice", "dninfo", " dstate", "xdinfo", " dInfo", "dsInfo", "dlfo", "dsinf", "fstate"], "dev": ["Dev", "dn", "dd", "mod", "ch", "data", "gd", "pub", "info", "obj", "err", "conf", "comment", "conn", "rc", "gu", "nt", "debug", "md", "de", "result", "block", "root", "app", "vd", "di", "der", "def", "sd", "self", "prom", "ee", "home", "prop", "fo", "hw", "d", "sh", "w", "ev", "ad", " device", "cam", "device", "driver", "p", "plug", "pad", "cache", "cd", "boot", "proc", "serial", "priv", "DEV", "pro", "die", "server", "diff", "bus", "ver", "dist", "bug"], "fatal_error": ["fatalpError", "fatal_Error", "fault_err", "fatal__ror", "fatal_break", "fatal_ror", "fatal_type", "fault_error", "fatal__err", "fault_break", "fault_ror", "fatal_err", "fatalptype", "fatalperror", "fatalperr", "fatal__error", "fatal__break"], "p1": ["param5", "p4", "pp2", "point01", "ppOne", "p0", "P1", " pOne", "f3", "point1", "P2", "r2", "pp1", "P0", "p01", "param01", "point3", "r4", "r0", "f2", "p8", "p5", " p01", " p0", "P01", "f1", "p3", " p8", "r1", "pOne", "P3", "P8", "param1", "POne", "P5", "P4", "f0", "point2", " p4", "f01", " p5", "pp0", "param2", "f8"], "fmt": ["fnt", "Frt", "fmb", "cfmt", "cfmb", "sfnt", "sfformat", "tfMT", "cfrt", "funformat", "fMT", "tflt", "cflt", "fformat", "Filt", " fnt", "funilt", "tfformat", "sfilt", "sfMT", "Fmt", " ftm", " fmb", "sfmt", " flt", "filt", "flt", "Fformat", "tfrt", "FMT", "tfmb", " fMT", " frt", "frt", "funMT", "sftm", " fformat", "tfmt", "ftm", "tftm", "tfnt", "funmt"], "nr": ["rx", "ner", "rr", " n", "dir", "ng", " no", "nor", "nl", " fn", "src", "nob", "nb", "arr", "range", "rec", " NR", "chain", "nc", "mr", "sn", "rn", "nir", "sr", "lr", " seq", "yr", "nw", "req", " ni", "seq", "rl", "rw", "ni", "wr", "next", "adr", "NR", " r", "number", "nn", "addr", "gr", " resid"], "p2": ["p4", " pTwo", "P1", "f3", "r02", "P2", "r2", "paTwo", "pTwo", "r4", "f2", "p8", "P02", " p3", "pa2", "f1", "p3", " p8", "PTwo", "r1", "P3", "P8", "pa1", "P4", " p02", "pa8", "f4", " p4", "p02", "f8"]}}
{"project": "FFmpeg", "commit_id": "aacf6b3a2fd8bc8603e3deaa6e612ea03cf08707", "target": 1, "func": "static inline void rv34_mc(RV34DecContext *r, const int block_type,\n\n                          const int xoff, const int yoff, int mv_off,\n\n                          const int width, const int height, int dir,\n\n                          const int thirdpel, int weighted,\n\n                          qpel_mc_func (*qpel_mc)[16],\n\n                          h264_chroma_mc_func (*chroma_mc))\n\n{\n\n    MpegEncContext *s = &r->s;\n\n    uint8_t *Y, *U, *V, *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, umx, umy, lx, ly, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride + mv_off;\n\n    int is16x16 = 1;\n\n\n\n    if(thirdpel){\n\n        int chroma_mx, chroma_my;\n\n        mx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) / 3 - (1 << 24);\n\n        my = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) / 3 - (1 << 24);\n\n        lx = (s->current_picture_ptr->f.motion_val[dir][mv_pos][0] + (3 << 24)) % 3;\n\n        ly = (s->current_picture_ptr->f.motion_val[dir][mv_pos][1] + (3 << 24)) % 3;\n\n        chroma_mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        chroma_my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = (chroma_mx + (3 << 24)) / 3 - (1 << 24);\n\n        umy = (chroma_my + (3 << 24)) / 3 - (1 << 24);\n\n        uvmx = chroma_coeffs[(chroma_mx + (3 << 24)) % 3];\n\n        uvmy = chroma_coeffs[(chroma_my + (3 << 24)) % 3];\n\n    }else{\n\n        int cx, cy;\n\n        mx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] >> 2;\n\n        my = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] >> 2;\n\n        lx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] & 3;\n\n        ly = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] & 3;\n\n        cx = s->current_picture_ptr->f.motion_val[dir][mv_pos][0] / 2;\n\n        cy = s->current_picture_ptr->f.motion_val[dir][mv_pos][1] / 2;\n\n        umx = cx >> 2;\n\n        umy = cy >> 2;\n\n        uvmx = (cx & 3) << 1;\n\n        uvmy = (cy & 3) << 1;\n\n        //due to some flaw RV40 uses the same MC compensation routine for H2V2 and H3V3\n\n        if(uvmx == 6 && uvmy == 6)\n\n            uvmx = uvmy = 4;\n\n    }\n\n    dxy = ly*4 + lx;\n\n    srcY = dir ? s->next_picture_ptr->f.data[0] : s->last_picture_ptr->f.data[0];\n\n    srcU = dir ? s->next_picture_ptr->f.data[1] : s->last_picture_ptr->f.data[1];\n\n    srcV = dir ? s->next_picture_ptr->f.data[2] : s->last_picture_ptr->f.data[2];\n\n    src_x = s->mb_x * 16 + xoff + mx;\n\n    src_y = s->mb_y * 16 + yoff + my;\n\n    uvsrc_x = s->mb_x * 8 + (xoff >> 1) + umx;\n\n    uvsrc_y = s->mb_y * 8 + (yoff >> 1) + umy;\n\n    srcY += src_y * s->linesize + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    if(   (unsigned)(src_x - !!lx*2) > s->h_edge_pos - !!lx*2 - (width <<3) - 4\n\n       || (unsigned)(src_y - !!ly*2) > s->v_edge_pos - !!ly*2 - (height<<3) - 4){\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 22 * s->linesize;\n\n\n\n        srcY -= 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(s->edge_emu_buffer, srcY, s->linesize, (width<<3)+6, (height<<3)+6,\n\n                            src_x - 2, src_y - 2, s->h_edge_pos, s->v_edge_pos);\n\n        srcY = s->edge_emu_buffer + 2 + 2*s->linesize;\n\n        s->dsp.emulated_edge_mc(uvbuf     , srcU, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        s->dsp.emulated_edge_mc(uvbuf + 16, srcV, s->uvlinesize, (width<<2)+1, (height<<2)+1,\n\n                            uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, s->v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n    }\n\n    if(!weighted){\n\n        Y = s->dest[0] + xoff      + yoff     *s->linesize;\n\n        U = s->dest[1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = s->dest[2] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }else{\n\n        Y = r->tmp_b_block_y [dir]     +  xoff     +  yoff    *s->linesize;\n\n        U = r->tmp_b_block_uv[dir*2]   + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n        V = r->tmp_b_block_uv[dir*2+1] + (xoff>>1) + (yoff>>1)*s->uvlinesize;\n\n    }\n\n\n\n    if(block_type == RV34_MB_P_16x8){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8;\n\n        srcY += 8;\n\n    }else if(block_type == RV34_MB_P_8x16){\n\n        qpel_mc[1][dxy](Y, srcY, s->linesize);\n\n        Y    += 8 * s->linesize;\n\n        srcY += 8 * s->linesize;\n\n    }\n\n    is16x16 = (block_type != RV34_MB_P_8x8) && (block_type != RV34_MB_P_16x8) && (block_type != RV34_MB_P_8x16);\n\n    qpel_mc[!is16x16][dxy](Y, srcY, s->linesize);\n\n    chroma_mc[2-width]   (U, srcU, s->uvlinesize, height*4, uvmx, uvmy);\n\n    chroma_mc[2-width]   (V, srcV, s->uvlinesize, height*4, uvmx, uvmy);\n\n}\n", "idx": 18830, "substitutes": {"r": ["rx", "m", "fr", "j", "rs", "f", "rc", "rt", "R", "n", "result", "ar", "g", "rh", "rg", "rf", "kr", "o", "d", "re", "w", "sr", "e", "dr", "q", "lr", "cr", "v", "c", "rl", "rb", "ir", "p", "rw", "b", "res", "er", "gr"], "block_type": ["block2name", "frame_Type", "frame_block", "block2block", "frame2block", "block8Type", "block_name", "block2type", "frame2name", "block8type", "frame_type", "block2Type", "block8name", "frame2Type", "block8block", "block_block", "frame2type", "block_Type", "frame_name"], "xoff": ["xOff", " xoffs", "xyoff", "xyoffs", "xyOff", "xoffs", "Xoffs", "Xoff", "xOFF", "xyOFF", " xOff", " xOFF", "XOff", "XOFF"], "yoff": ["xyoff", "dyOFF", "dyoffs", "xyoffs", "xoffs", "dyoff", "xyOFF", "xOFF", "yoffs", "yOFF"], "mv_off": ["mvarkon", "mv__mode", "mv__pos", "mvpon", "mov_on", "mv_type", "mvarkoff", "mv__on", "mf_open", "mvpoff", "mf_type", "mvptype", "mov_mode", "mv_mode", "mov_off", "mov_pos", "mv__off", "mf_off", "mv2on", "mv2pos", "mf_on", "mv_on", "mv2off", "mvpopen", "mvarktype", "mv_pos", "mvarkopen", "mv2mode", "mv_open"], "height": ["thin", "fw", "window", "gh", "max", "resolution", "padding", "th", "dim", "def", "style", "dy", "img", "length", "w", "deep", "layout", "rows", "Height", "depth", "row", "ty", "density"], "dir": ["dc", "uri", "spec", "DIR", "m", "direct", "dn", "group", "direction", "mode", "dep", "ref", "alt", "dest", "f", "sort", "du", "md", "handle", "file", "duration", "n", "rel", "module", "coll", "or", "name", "loc", "dt", "di", "ind", "manager", "dim", "def", "Dir", "d", "class", "rec", "directory", "path", "dy", "config", "id", "dr", "det", "cur", "c", "req", "lib", "ir", "url", "doc", "depth", "orient", "h", "level", "folder", "desc", "diff", "order", "y", "dist"], "thirdpel": ["Thirdpal", "thirdlace", "threepel", "Thirdlace", "threepl", "thirdpl", "thirdchal", "quadpel", "threelace", "quadpl", "Thirdchal", "threepal", "Thirdpl", "Thirdpel", "quadpal", "quadlace", "thirdpal"], "weighted": ["weighting", "masking", "maskable", "wnable", "processable", "masked", "wnned", "processing", "maskned", "wned", "weightned", "processned", "weightable", "wning", "processed"], "qpel_mc": ["qpal_pc", "qpel2mc", "qpel2lc", "qpal_cos", "qpal_mc", "qpel2pc", "qpal_lc", "qpel2cos", "qpel_lc", "qpel_pc", "qpel_cos"], "chroma_mc": ["chroma_mic", "chromama_mc", "chromama_lc", "chromama_mic", "chromama_mm", "chroma_lc", "chroma_mm"], "s": ["ns", "spec", "full", "settings", "service", "ss", "cs", "d", "qs", "sym", "p", "h", "us", "m", "sup", "ts", "sg", "j", "rs", "scope", "sim", "self", "o", "share", "su", "size", "sc", "v", "si", "S", "a", "ds", "f", "sb", "l", "w", "bis", "c", "ps", "b", "sys", "your", "es", "sq", "sf", "session", "t", "conf", "sp", "services", "n", "g", "i", "sl", "ls", "ops", "fs", "is", "space", "site", "e", "ssl", "ses", "js", "http", "gs", "os", "se", "server", "y", "u"], "Y": ["Z", "x", "T", "M", "R", "A", "N", "CH", "XY", "Q", "B", "I", "L", "G", "YY", "W", "X", "INT", "F", "D", "S", "MY", "O", "C", "H", "y", "P"], "U": ["E", "Z", "T", "M", "R", "A", "N", "K", "Q", "B", "UU", "I", "UD", "L", "G", "W", "X", "F", "D", "S", "UV", "O", "C", "H", "P", "u"], "V": ["E", "Z", "T", "VT", "M", "R", "A", "N", "XY", "Q", "B", "I", "L", "G", "W", "J", "X", "v", "F", "D", "VW", "S", "UV", "O", "C", "H", "P"], "srcY": ["rcXY", " srcXY", "rcN", "rcX", "srcN", "sourceY", " srcN", "sourceX", "rcY", "srcX", "sourceXY", "sourceN", " srcX", "srcXY"], "srcU": ["rcN", "rcX", "rcM", "srcN", " srcN", "sourceX", "sourceM", "srcX", " srcM", "rcU", " srcX", "sourceN", "srcM", "sourceU"], "srcV": ["rcM", "rcI", " srcI", "sourceM", "rcV", "sourceI", " srcM", "rcU", "srcI", "sourceV", "srcM", "sourceU"], "dxy": ["Dxy", "dpx", "dwy", "Dwy", "fxy", " dpx", " dwy", " dwx", "Dpx", "fwx", "fwy", "Dwx", "dwx", "fpx"], "mx": ["rx", "ms", "m", "mag", "yx", "wx", "x", "px", "md", "mi", "cm", "bm", "mn", "ym", "xy", "mic", "mc", "mus", "dj", "ml", "vm", "fx", "mr", "tx", "dy", "mb", "dm", "mos", "wm", "xml", "mp", "la", "MX", "nn", "py", "mm", "zx", "me", "y", "mu"], "my": ["ms", "m", "bi", "ky", "ami", "mys", "md", "mi", "why", "mn", "pm", "ym", "ny", "zy", "gray", "mic", "mc", "mini", "mmm", "any", "ml", "dy", "ram", "sym", "ury", "MY", "fy", "vy", "gy", "py", "ma", "mm", "me", "mia", "My", "y", "mph", "lly"], "umx": ["umh", "omy", "pmy", "mz", "umw", "ufw", "emz", "omw", "pmx", "ufx", "ulx", "omh", "pmX", "emX", "ufh", "emx", "ulw", "mX", "umX", "umz", "pmz", "emy", "uly", "ulh", "ufy", "omx"], "umy": ["umb", "umh", "amh", "ucy", "upx", "amx", "uch", "ufx", "amy", "ucx", "upb", "ufh", "ufz", "ucb", "upy", "uph", "amb", "upz", "amz", "umz", "ufy"], "lx": ["lh", "lw", "ely", "ulz", "lz", "elz", "ilh", "ily", "sly", "ulx", "slh", "ilx", "slx", "slw", "ulw", " lz", "elw", " lw", "ilw", "elx", "uly", "ulh"], "ly": ["gi", "ky", "wx", "px", "mi", "bm", "hy", "lu", "iy", "bly", "ym", "pm", "xy", "zy", "lex", "ry", "lv", "ml", "lo", "yi", "maybe", "ply", "dy", "yy", "bl", "lc", "fy", "la", "hh", "vy", "gy", "yo", "py", "mm", "zx", "wy", "y", "li"], "uvmx": ["uvmm", "vbmm", "vvmy", "ubmy", "uVMy", "ubmx", "ubmh", "vbmh", "vbmx", "vvmh", "uVMh", "uVMm", "upmh", "ubmm", "vvmx", "uVMx", "upmy", "uvmh", "vvmm", "vbmy", "upmm", "upmx"], "uvmy": ["cvmi", "umm", "udmy", "uvmm", "uvmi", "uvmd", "cvmd", "cvmy", "umd", "udmm", "cvmm", "udmi", "udmd", "umi"], "src_x": [" src_i", "src_id", "src_i", " src_id"], "src_y": ["dest_y", "dest_i", "src_py", "dest_py", "src_i", "dest_x"], "uvsrc_x": ["uvsrc_h", "uvsource_m", "uvsrc_m", "uvsource_x", "uvsource_h", "uvsource_y"], "uvsrc_y": ["uvsrc1i", "uvsrc_i", "uvsrc1z", "uvsrc1x", "uvsrc_z", "uvsrc1y"], "chroma_mx": ["chromaacym", "chroma__ym", "chromaacmain", "chroman_mm", "chroma_main", "chroman_mn", "chroman_mx", "chroma__rx", "chroman_main", "chroma_ym", "chroman_cp", "chroma_rx", "chroma__mm", "chroman_mus", "chroma__mn", "chroma__mx", "chroma_mus", "chroma_mm", "chroman_ym", "chroma_mn", "chroma_cp", "chromaacmx", "chromaacmn", "chroma__main", "chroman_rx"], "chroma_my": ["chroma__mis", "chroma67my", "chroman_mos", "chromama_mis", "chroma_mi", "chroma_My", "chroma67mi", "chroma__my", "chromama_nm", "chroma_mis", "chromama_mi", "chroman_mx", "chromama_My", "chroma67mos", "chroma_nm", "chroman_mi", "chroma_mos", "chroma67mx", "chroma__mx", "chromama_my", "chromama_mx", "chroman_my", "chroma__mi"]}}
{"project": "qemu", "commit_id": "9287ac271d83166f99e050a0e0a4ebd462f7eb2b", "target": 1, "func": "void migrate_fd_connect(MigrationState *s)\n\n{\n\n    s->state = MIG_STATE_SETUP;\n\n    trace_migrate_set_state(MIG_STATE_SETUP);\n\n\n\n    /* This is a best 1st approximation. ns to ms */\n\n    s->expected_downtime = max_downtime/1000000;\n\n    s->cleanup_bh = qemu_bh_new(migrate_fd_cleanup, s);\n\n\n\n    qemu_file_set_rate_limit(s->file,\n\n                             s->bandwidth_limit / XFER_LIMIT_RATIO);\n\n\n\n    qemu_thread_create(&s->thread, migration_thread, s,\n\n                       QEMU_THREAD_JOINABLE);\n\n    notifier_list_notify(&migration_state_notifiers, s);\n\n}\n", "idx": 18833, "substitutes": {"s": ["ns", "status", "spec", "m", "ts", "sg", "session", "stats", "t", "rs", "f", "settings", "services", "options", "service", "n", "plugins", "sb", "i", "g", "sl", "ss", "ls", "y", "fs", "self", "is", "o", "cs", "l", "submit", "d", "su", "args", "less", "qs", "e", "ssl", "side", "ses", "sync", "v", "js", "c", "si", "ps", "sym", "p", "S", "b", "http", "gs", "sys", "u", "your", "storage", "es", "os", "state", "south", "states", "sq", "sets", "se", "server", "params", "ds", "sf"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405cr_clk_setup (ppc405cr_cpc_t *cpc)\n\n{\n\n    uint64_t VCO_out, PLL_out;\n\n    uint32_t CPU_clk, TMR_clk, SDRAM_clk, PLB_clk, OPB_clk, EXT_clk, UART_clk;\n\n    int M, D0, D1, D2;\n\n\n\n    D0 = ((cpc->pllmr >> 26) & 0x3) + 1; /* CBDV */\n\n    if (cpc->pllmr & 0x80000000) {\n\n        D1 = (((cpc->pllmr >> 20) - 1) & 0xF) + 1; /* FBDV */\n\n        D2 = 8 - ((cpc->pllmr >> 16) & 0x7); /* FWDVA */\n\n        M = D0 * D1 * D2;\n\n        VCO_out = cpc->sysclk * M;\n\n        if (VCO_out < 400000000 || VCO_out > 800000000) {\n\n            /* PLL cannot lock */\n\n            cpc->pllmr &= ~0x80000000;\n\n            goto bypass_pll;\n\n        }\n\n        PLL_out = VCO_out / D2;\n\n    } else {\n\n        /* Bypass PLL */\n\n    bypass_pll:\n\n        M = D0;\n\n        PLL_out = cpc->sysclk * M;\n\n    }\n\n    CPU_clk = PLL_out;\n\n    if (cpc->cr1 & 0x00800000)\n\n        TMR_clk = cpc->sysclk; /* Should have a separate clock */\n\n    else\n\n        TMR_clk = CPU_clk;\n\n    PLB_clk = CPU_clk / D0;\n\n    SDRAM_clk = PLB_clk;\n\n    D0 = ((cpc->pllmr >> 10) & 0x3) + 1;\n\n    OPB_clk = PLB_clk / D0;\n\n    D0 = ((cpc->pllmr >> 24) & 0x3) + 2;\n\n    EXT_clk = PLB_clk / D0;\n\n    D0 = ((cpc->cr0 >> 1) & 0x1F) + 1;\n\n    UART_clk = CPU_clk / D0;\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_CPU_CLK], CPU_clk);\n\n    /* Setup time-base clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_TMR_CLK], TMR_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_PLB_CLK], PLB_clk);\n\n    /* Setup SDRAM clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_SDRAM_CLK], SDRAM_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_EXT_CLK], EXT_clk);\n\n    /* Setup UART clock */\n\n    clk_setup(&cpc->clk_setup[PPC405CR_UART_CLK], UART_clk);\n\n}\n", "idx": 18838, "substitutes": {"cpc": ["pullcs", "copc", "hpcs", "ppk", "cyc", "cpcs", "pplc", "ppca", "cppl", "ppcu", "cppcs", "pushc", "pprc", "cfe", "cpdc", "ckct", "pkgdc", "arpc", "CPdc", "pcs", "pkge", "zipl", "pkgct", "cpca", "cpm", "epl", "cfc", "ppl", "pkgb", "hpc", "copl", "pkgca", "pc", "pkgrc", "cpg", "pkgpc", "appcs", "cppce", "zipcu", "CAPct", "cppb", "pgp", "appce", "pkgc", "pkgnc", "ppg", "pge", "cppf", "pgca", "cycon", "pkgm", "arpcs", "appl", "ppe", "cff", "ippc", "copdc", "cppk", "arpdc", "hpdc", "ppb", "arppc", " cpcu", "cppdc", "cpbc", "appc", "ppnc", "cppe", "cppc", " cplc", "zipc", "pkgp", "ckc", "hpcu", "CAPcu", "CPl", "cpp", "cpct", "pkgcu", "zippc", "cpb", " cpdc", "cplc", "CPc", "cppnc", "pullc", "iprc", "ppbc", "ppf", "pkgl", "ppcs", "cpnc", "cfdc", "pdc", "ppc", "ppcon", "CPlc", "cpl", "pushk", "cpcu", " cpcs", "pushcon", "pullpc", "pgc", "cpe", "pushg", "epcs", "ckcu", "epc", "ppce", "pkgcon", "cyrc", "cync", "cpf", "copbc", "pkgbc", "cpk", "cprc", "CAPpc", "CAPc", "ppp", "ckpc", " cpl", "ziprc", "pullrc", "epcu", "ppm", "cpcon", "cppcon", "ipm", "zipcs", "cppg", "ppdc", "cpce", "ipc", "pppc"], "VCO_out": ["VCOPin", "VCO_error", "Vco_out", "VCo_out", "VGO_name", "VCO_IN", "VGO_out", "VCE_out", "Vco_conn", "VCOM_error", "VCO_in", "VCO_orig", "VCE_IN", "VCOPIN", "VCOM_out", "VCOPout", "VCO_name", "VCO_co", "VCO_Out", "VCE_call", "VCE_in", "VCo_co", "VCO_call", "VCO_id", "VCOPcall", "VCO_conn", "VCOM_in", "VCO_num", "VCOM_orig", "Vco_in", "VCo_id", "VGO_in", "VGO_num", "Vco_Out"], "PLL_out": ["PLL_all", "PCL_again", "PML_again", "PLLFout", "PLL64ex", "PLL_call", "PCL_Out", "PLL64out", "PLS_OUT", "PLS_ex", "PLL64again", "PPL_call", "PLL_Out", "PLL_prefix", "PLS_again", "PLL64OUT", "PPL_cache", "PPL_out", "PLL_cache", "PLL_ex", "PLLFprefix", "PLLFcache", "PLL_OUT", "PML_all", "PLL_again", "PPL_prefix", "PLS_out", "PML_Out", "PCL_out", "PML_out", "PLLFcall"], "CPU_clk": ["CPU_plkk", "CPU_flok", "CPU_CLck", "CPU_clck", "CPU_llk", "CPU_Clok", "CPU_CLke", "CPU_plok", "CPU_llke", "CPU_slkk", "CPU_llck", "CPU_plk", "CPU_Clky", "CPU_flck", "CPU_aclky", "CPU_plky", "CPU_Clck", "CPU_clke", "CPU_slk", "CPU_clky", "CPU_Clks", "CPU_slok", "CPU_plks", "CPU_flk", "CPU_elk", "CPU_CLk", "CPU_aclck", "CPU_clks", "CPU_CLks", "CPU_llks", "CPU_elck", "CPU_clok", "CPU_elkk", "CPU_elok", "CPU_CLkk", "CPU_plck", "CPU_clkk", "CPU_aclok", "CPU_slck", "CPU_flke", "CPU_elke", "CPU_Clk", "CPU_CLok", "CPU_plke", "CPU_llok", "CPU_Clkk", "CPU_aclk", "CPU_elks"], "TMR_clk": ["TMR_plck", "TMR_chck", "TMR_Clok", "TMR_mlK", "TMR_mlk", "TMR_CLck", "TMR_rlck", "TMR_Clk", "TMR_chki", "TMR_Clke", "TMR_CLk", "TMR_ClK", "TMR_clki", "TMR_plk", "TMR_CLok", "TMR_clok", "TMR_CLik", "TMR_classck", "TMR_chk", "TMR_Clik", "TMR_clK", "TMR_clck", "TMR_mlke", "TMR_clc", "TMR_Clc", "TMR_classki", "TMR_rlk", "TMR_chc", "TMR_plok", "TMR_Clck", "TMR_classc", "TMR_classk", "TMR_rlK", "TMR_rlke", "TMR_Clki", "TMR_plik", "TMR_clke", "TMR_clik", "TMR_mlck"], "SDRAM_clk": ["SDRAM_Clk", "SDRAM_Clik", "SDRAM_plk", "SDRAM_elok", "SDRAM_Clks", "SDRAM_elk", "SDRAM_CLk", "SDRAM_elks", "SDRAM_plck", "SDRAM_elck", "SDRAM_plok", "SDRAM_elik", "SDRAM_Clck", "SDRAM_plks", "SDRAM_clks", "SDRAM_CLks", "SDRAM_clik", "SDRAM_CLok", "SDRAM_clck", "SDRAM_CLck", "SDRAM_plik", "SDRAM_clok"], "PLB_clk": ["PLB_cln", "PLB_combok", "PLB_clks", "PLB_Clk", "PLB_plik", "PLB_CLk", "PLB_Clik", "PLB_plck", "PLB_CLik", "PLB_Clku", "PLB_combk", "PLB_flk", "PLB_CLok", "PLB_clok", "PLB_flik", "PLB_Clks", "PLB_clku", "PLB_combks", "PLB_plks", "PLB_pln", "PLB_CLks", "PLB_Clok", "PLB_combku", "PLB_CLn", "PLB_flku", "PLB_CLku", "PLB_plok", "PLB_clck", "PLB_CLck", "PLB_Cln", "PLB_plk", "PLB_clik", "PLB_Clck", "PLB_flks"], "OPB_clk": ["OPB_CLkn", "OPB_plk", "OPB_CLk", "OPB_collkn", "OPB_collk", "OPB_CLok", "OPB_CLks", "OPB_Clkg", "OPB_clks", "OPB_plks", "OPB_clck", "OPB_clkn", "OPB_clok", "OPB_eck", "OPB_clkg", "OPB_ecok", "OPB_plkn", "OPB_Clok", "OPB_collks", "OPB_Clck", "OPB_eckg", "OPB_CLck", "OPB_ecck", "OPB_CLkg", "OPB_collck", "OPB_plck", "OPB_Clk"], "EXT_clk": ["EXT_CLke", "EXT_clok", "EXT_logk", "EXT_clekk", "EXT_cleke", "EXT_CLck", "EXT_logkk", "EXT_flke", "EXT_Clok", "EXT_logke", "EXT_flk", "EXT_Clks", "EXT_clks", "EXT_plk", "EXT_CLk", "EXT_flok", "EXT_clek", "EXT_plke", "EXT_Clk", "EXT_clkk", "EXT_CLkk", "EXT_clke", "EXT_cleck", "EXT_plok", "EXT_Clke", "EXT_logck", "EXT_clck", "EXT_flks", "EXT_plks"], "UART_clk": ["UART_klck", "UART_Clb", "UART_CLk", "UART_klky", "UART_plk", "UART_clb", "UART_clck", "UART_plb", "UART_plck", "UART_plky", "UART_Clk", "UART_clok", "UART_plok", "UART_CLok", "UART_klk", "UART_CLck", "UART_plik", "UART_Clik", "UART_klok", "UART_Clck", "UART_CLky", "UART_clky", "UART_clik"], "M": ["E", "Z", "m", "V", "T", "MO", " m", "R", "N", "A", "K", "MD", "Q", "B", "MI", "I", "RM", "MN", "L", " D", "Y", "U", "G", " N", "IM", "W", "MT", "SM", "J", "X", "F", "D", "MS", "MM", "S", " L", "O", "LM", "MF", "C", "MON", "H", "MC", "P"], "D0": ["MD2", "DD255", "M90", "M13", " D180", "d125", "M63", "V6", "d14", "d2", "V00", "d3", "V080", "Do192", "D029", "L6", " D125", "d50", "D90", "Do1", "MD0", " D14", "Do63", "d0", "Do3", "Do0", "Do2", "M2", "MD90", "R255", " D255", " DZero", "d86", "Do4", "Do6", "D3", "DoZero", "D180", " D192", "D192", "D13", "DD0", "d4", " D3", "DO0", "M50", "L0", "Do00", "F50", " D00", "D00", "Do50", "D4", "R029", "D6", "DD029", "D255", "DO180", " D86", "d192", "Do125", " D50", "d13", " D6", "d180", "D125", "M6", "d00", " D029", "Do080", "F1", "M0", "DO14", " D63", "L080", "D50", "DO255", "M00", "D14", "D080", "L00", " D13", "V0", "FZero", "D63", "Do14", "DZero", "d6", " D4", "R0", "M86", "d90", "F0", "d255", "D86"], "D1": ["D7", "Do0", "Do2", "M2", "P1", "F4", "P2", "d2", "D4", "d1", "P6", "d7", "D6", "d3", "M3", "V2", "M1", "d6", "P3", "D3", "V4", "M01", "F2", "F01", "d4", "V1", "M6", "D01", "F7", "F0", "Do1", "Do01", "F1", "M0", "V7"], "D2": ["F3", "X02", "d9", "MD2", "M2", "d02", "M02", "d2", "X2", "d1", "D6", "d3", "M20", " D5", "d6", "D32", "D9", "D3", " D20", "F2", "M5", "d20", "M9", " D6", "MD1", "D02", "M6", "M32", " D9", "F0", "D20", "D5", "d5", "F1", "M0", "MD3", "MD0", "X5", "X32", "d0", "d32"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t cmd646_cmd_read(void *opaque, target_phys_addr_t addr,\n\n                                unsigned size)\n\n{\n\n    CMD646BAR *cmd646bar = opaque;\n\n\n\n    if (addr != 2 || size != 1) {\n\n        return ((uint64_t)1 << (size * 8)) - 1;\n\n    }\n\n    return ide_status_read(cmd646bar->bus, addr + 2);\n\n}\n", "idx": 18853, "substitutes": {"opaque": ["opusac", "ocacle", "operacity", "oprobe", " opacity", "ocaques", "opac", "opacity", " oprobe", " opac", "operaque", "ovaque", "OPaques", "ovacle", "ocaque", "opusaque", "OPaque", "operac", "opaques", "opusrobe", "operrobe", "opusacity", "OPacle", "ovaques", "opacle"], "addr": ["dc", "part", "point", "offset", "code", "data", "mode", "base", "alt", "rc", "md", "ord", "rt", "align", "hop", "oa", "src", "node", "adder", "ext", "index", "ptr", "pos", "slice", "byte", "pointer", "host", "layer", "args", "config", "ad", "dr", "fd", "seq", "patch", "address", "pad", "lvl", "cmp", "adr", "ace", "state", "amd", "port", "len"], "size": ["scale", "offset", "s", "small", "code", "data", "capacity", "SIZE", "x", "shape", "sized", "align", "g", "or", "type", "six", "loc", "sec", "timeout", "en", "count", "eng", "empty", " address", "args", "large", "sn", "ize", "length", "e", " Size", "send", "parent", "c", "si", "address", " sizes", "fee", "bytes", "Size", "len"], "cmd646bar": ["cmd16bart", "cmd346bars", " cmd156bar", " cmd156bart", "cmd646Bar", "cmd156bars", "cmd346bar", "cmd646bart", "cmd646bars", " cmd646bart", "ct646bar", "cmd626bars", "cmd6bar", "cmd512Bar", "ct512bars", "cmd346bart", " cmd646bars", "ct646server", "ct512Bar", "cmd646server", "cmd512bars", "cmd156Bar", " cmd156bars", "cmd16Bar", "cmd512server", " cmd646Bar", "cmd626server", "cmd156bar", " cmd156Bar", "ct646Bar", "cmd512bar", "ct646bars", "cmd16bar", "cmd6bars", "cmd626bar", "cmd156bart", "cmd6server", "cmd346Bar", "ct512server", "cmd626Bar", "cmd6Bar", "ct512bar", "cmd16bars"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t hpet_ram_read(void *opaque, target_phys_addr_t addr,\n\n                              unsigned size)\n\n{\n\n    HPETState *s = opaque;\n\n    uint64_t cur_tick, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_readl at %\" PRIx64 \"\\n\", addr);\n\n    index = addr;\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > s->num_timers) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return 0;\n\n        }\n\n\n\n        switch ((addr - 0x100) % 0x20) {\n\n        case HPET_TN_CFG:\n\n            return timer->config;\n\n        case HPET_TN_CFG + 4: // Interrupt capabilities\n\n            return timer->config >> 32;\n\n        case HPET_TN_CMP: // comparator register\n\n            return timer->cmp;\n\n        case HPET_TN_CMP + 4:\n\n            return timer->cmp >> 32;\n\n        case HPET_TN_ROUTE:\n\n            return timer->fsb;\n\n        case HPET_TN_ROUTE + 4:\n\n            return timer->fsb >> 32;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    } else {\n\n        switch (index) {\n\n        case HPET_ID:\n\n            return s->capability;\n\n        case HPET_PERIOD:\n\n            return s->capability >> 32;\n\n        case HPET_CFG:\n\n            return s->config;\n\n        case HPET_CFG + 4:\n\n            DPRINTF(\"qemu: invalid HPET_CFG + 4 hpet_ram_readl\\n\");\n\n            return 0;\n\n        case HPET_COUNTER:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick;\n\n        case HPET_COUNTER + 4:\n\n            if (hpet_enabled(s)) {\n\n                cur_tick = hpet_get_ticks(s);\n\n            } else {\n\n                cur_tick = s->hpet_counter;\n\n            }\n\n            DPRINTF(\"qemu: reading counter + 4  = %\" PRIx64 \"\\n\", cur_tick);\n\n            return cur_tick >> 32;\n\n        case HPET_STATUS:\n\n            return s->isr;\n\n        default:\n\n            DPRINTF(\"qemu: invalid hpet_ram_readl\\n\");\n\n            break;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 18892, "substitutes": {"opaque": [" opque", "ipque", " opacs", "ocaques", "opac", "occ", " opac", "ipac", "OPacs", "OPque", "operaque", "ocque", "OPaques", "opacs", "ocaque", "OPc", "operque", "OPaque", "operc", "ipaque", "OPac", "opaques", "operaques", "opc", "opque", "ipacs"], "addr": ["dc", "rx", "offset", "db", "work", "code", "data", "ady", "x", "base", "ref", "alt", "ix", "ord", "coord", "align", "hop", "channel", "i", "arm", "src", "node", "padding", "ctx", "ext", "ptr", "pos", "slice", "dim", "pointer", "sta", "host", "fx", "val", "slot", "nr", "tx", "config", "ad", "start", "dr", "delay", "asm", "prefix", "id", "seq", "p", "url", "address", "pad", "cmp", "adr", "clock", "ace", "mac", "conn", "amp", "len"], "size": [" len", "data", "SIZE", "x", " args", " c", "ctx", " bytes", " data", "pointer", " error", "length", "address", " sizes", " mem", "bytes", "Size", " length", "len"], "s": ["ns", "spec", "words", "settings", "options", "ports", "service", "ions", "sie", "ers", "ss", "als", "cs", "ims", "socket", "ments", "sym", "p", "sets", "comments", "m", "ts", "sg", "rs", "aws", "times", "in", "sim", "lines", "o", "ing", "tests", "v", "si", "S", "a", "ings", "ches", "ds", "status", "uns", "f", "r", "results", "sb", "current", "or", "multi", "l", "ins", "w", "features", "sync", "c", "secondary", "address", "b", "sys", "your", "es", "state", "states", "sq", "ies", "sf", "session", "t", "stats", "request", "rates", "services", "plugins", "g", "i", "sl", "ls", "ops", "slice", "xs", "is", "ed", "complete", "args", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "storage", "its", "local", "parts", "server", "south", "y"], "cur_tick": [" cur_time", "curJhop", "curjyear", "curVtime", "cur_call", " cur_tag", "curJick", "curJcycle", "curxtrigger", "curwdt", "curxsync", "curJstick", " cur_clock", "curFtick", "cur_year", "curRlock", "curjcycle", "cur_dt", "curJcall", "curLtime", "cur_trigger", "curxstick", "curjtick", " cur_ick", "curjclock", "curwval", "curwtick", "cur_time", "curxhop", "curFick", "curjstick", "cur67tag", "curJspin", "prev_val", "prev_cycle", "curxcycle", " cur_trigger", "curFclock", "curjsync", " cur_year", "curjkick", "curRtick", " cur_lock", "cur67stick", "cur_spin", "curwcycle", " cur_check", "cur_val", "cur_lock", "prev_dt", " cur_stick", "curxtick", "curRcycle", "curLtick", " cur_spin", "curRtrigger", "curxcookie", "curJtick", " cur_hop", "curVtick", "curVday", "cur_cookie", " cur_cycle", "curFkick", "cur_sync", "cur_check", "cur_tag", "curLcheck", "curjtrigger", "curVcheck", "cur_day", "curLday", "cur_kick", "curJdt", "cur67year", "curJval", " cur_call", " cur_sync", "cur_ick", "curjtag", "curJcookie", "cur_stick", "cur_clock", " cur_kick", "curjick", "cur_hop", " cur_cookie", "cur67tick", "cur_cycle", "prev_tick", " cur_day"], "index": ["dc", "point", "offset", "example", "shape", "code", "x", "name", "element", "search", "ix", "inc", "align", "hop", "num", "i", "type", "match", "loc", "Index", "ind", "pos", "dim", "slice", "active", "pointer", "host", "val", "axis", "xxxx", "diff", "height", "length", "id", "xxx", "prefix", "key", "update", "insert", "position", "si", "seq", "fff", "address", "test", "fee", "route", "ace", "number", "weight", "find", "connection", "nn", "loop", "len", "alpha", "value", "conn", "amp"], "timer": ["aer", "term", "m", "tim", "time", "user", "ipper", "text", "err", "runner", "thread", "buffer", "ester", "service", "duration", "counter", "trace", "worker", "loader", "imer", "roller", "icer", "times", "match", "trial", "player", "sim", "timeout", "watch", "manager", "cer", "ger", "parser", " timers", "maker", "ter", "later", "header", "event", "mr", "tc", "browser", "ler", "handler", "processor", "acer", "Timer", "meter", "si", "device", "driver", "test", "monitor", "clock", "wrapper", "er", "peer", "message", "server", "trigger", "writer", "inner", "tm", "amer", "reader"]}}
{"project": "qemu", "commit_id": "e75ccf2c033fb0503d6cb7ddd0fd1dfa0aa4fc16", "target": 0, "func": "static void virtio_init_pci(VirtIOPCIProxy *proxy, VirtIODevice *vdev,\n\n                            uint16_t vendor, uint16_t device,\n\n                            uint16_t class_code, uint8_t pif)\n\n{\n\n    uint8_t *config;\n\n    uint32_t size;\n\n\n\n    proxy->vdev = vdev;\n\n\n\n    config = proxy->pci_dev.config;\n\n    pci_config_set_vendor_id(config, vendor);\n\n    pci_config_set_device_id(config, device);\n\n\n\n    config[0x08] = VIRTIO_PCI_ABI_VERSION;\n\n\n\n    config[0x09] = pif;\n\n    pci_config_set_class(config, class_code);\n\n\n\n    config[0x2c] = vendor & 0xFF;\n\n    config[0x2d] = (vendor >> 8) & 0xFF;\n\n    config[0x2e] = vdev->device_id & 0xFF;\n\n    config[0x2f] = (vdev->device_id >> 8) & 0xFF;\n\n\n\n    config[0x3d] = 1;\n\n\n\n    if (vdev->nvectors && !msix_init(&proxy->pci_dev, vdev->nvectors, 1, 0)) {\n\n        pci_register_bar(&proxy->pci_dev, 1,\n\n                         msix_bar_size(&proxy->pci_dev),\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY,\n\n                         msix_mmio_map);\n\n    } else\n\n        vdev->nvectors = 0;\n\n\n\n    proxy->pci_dev.config_write = virtio_write_config;\n\n\n\n    size = VIRTIO_PCI_REGION_SIZE(&proxy->pci_dev) + vdev->config_len;\n\n    if (size & (size-1))\n\n        size = 1 << qemu_fls(size);\n\n\n\n    pci_register_bar(&proxy->pci_dev, 0, size, PCI_BASE_ADDRESS_SPACE_IO,\n\n                           virtio_map);\n\n\n\n    if (!kvm_has_many_ioeventfds()) {\n\n        proxy->flags &= ~VIRTIO_PCI_FLAG_USE_IOEVENTFD;\n\n    }\n\n\n\n    virtio_bind_device(vdev, &virtio_pci_bindings, proxy);\n\n    proxy->host_features |= 0x1 << VIRTIO_F_NOTIFY_ON_EMPTY;\n\n    proxy->host_features |= 0x1 << VIRTIO_F_BAD_FEATURE;\n\n    proxy->host_features = vdev->get_features(vdev, proxy->host_features);\n\n}\n", "idx": 18893, "substitutes": {"proxy": ["plugin", "Proxy", "instance", "db", "request", "child", "shadow", "core", "base", "image", "ping", "coe", "pool", "component", "clone", "engine", "io", "service", "bridge", "rc", "library", "pe", "phi", "module", "PRO", "slice", "index", "phy", "model", "zip", "web", "roxy", "ca", "force", "profile", "bo", "gp", "linux", "alias", "pse", "queue", "remote", "cop", "ruby", "client", "cube", "parent", "slave", "ube", "driver", "lib", "ghost", "que", "cache", "http", "resource", "proc", "wrapper", "pro", "connection", "project", "py", "port", "server", "callback", "bus", "apache", "source"], "vdev": ["fdev", "vserv", "vdi", "vdiff", " vdef", "vdiv", "vmdev", "nvconn", "ndiv", "pdev", " vow", "vev", "lvdevice", "vmdata", "nvvalid", "hdevice", " vconf", "pdata", "ppriv", "svconf", "Vserv", "nvdevice", "vmdevice", "svver", "vdc", "vdef", "nvow", "Vev", "fdevice", "vmod", "hdev", "vself", "vvalid", "ldev", "vdata", " vde", "Vdiv", "vde", " vdata", "ndef", "vmdd", "pconf", "pserv", " vdiv", "lconn", "Vdev", "vver", "svdevice", "udev", "svvalid", "fdi", "vdevice", "lvdiv", "pdd", "vconf", "hprof", "svde", "pver", "ndev", "vdd", "pself", "udi", "lvdc", "vmvalid", "lvpriv", "hdi", "vmdiff", "udevice", "pde", "nself", "vmpriv", "svdev", "nvdiff", "vpriv", "lvself", "nmod", "lmod", " vdd", "npriv", "fprof", "hdef", "vprof", "lvow", " vserv", "uprof", "nvdef", " vpriv", " vdc", "vconn", " vdevice", " vmod", "nvdc", " vver", "pdiv", "lvdev", "pev", "ldevice", "vow", "hconn", "nvdev", " vev", "ldef", "svdiff"], "vendor": ["ivendor", "coice", "lvendor", "soven", "bnc", "quendor", " voice", "lvirgin", " virgin", "birgin", "sendor", "uvender", "vnc", " voy", " voven", "cirgin", "firgin", "navendor", "qudev", "navnc", "navoven", "lvoice", "voy", "boven", "fendor", "lvender", "cendor", "svoven", "quoy", "voven", " vnc", "foice", "sender", "svendor", "voice", "svender", "ivdev", "ivoice", "bendor", "cender", "uvoven", "svirgin", "ivoy", "uvendor", "uvirgin", "navirgin", "sirgin", "virgin", "vender", "quoice", "fender"], "device": ["dc", "dn", "vision", "mode", "direction", "attribute", "dir", "Device", "component", "engine", "md", "service", "mi", "module", "devices", "package", "node", "di", "model", "password", "description", "d", "disk", "directory", "mobile", "drive", "unit", "dev", "driver", "address", "feature", "domain", "product", "serial", "connection", "project", "mac", "version", "target"], "class_code": ["class_coded", "classblockcode", "classercoded", "classercodes", "class_id", "classermessage", " class_two", "classblockmessage", " class_coded", " class_desc", " class_codes", " class_message", " class_id", "class_message", "classercode", "class_codes", "classblockcoded", "class_two", "class_desc", "classblockcodes"], "pif": ["Piff", " pIF", "fiff", "Pif", "pIF", "pifer", "Pifer", " pip", "pip", " piff", "piff", "fIF", " pifer", "Pip", "PIF", "fifer", "fip", "fif"], "config": ["set", "spec", "cfg", "settings", "options", "service", "inc", "supp", "cf", "gui", "control", "sec", "exec", "design", "contract", "path", "feat", "comp", "Config", "lib", "account", "p", "output", "source", "conn", "input", "not", "plugin", "content", "init", "name", "rc", "app", "bc", "controller", "load", "class", "sc", "cat", "tail", "connection", "desc", "license", "code", "text", "view", "f", "image", "ct", "json", "block", "ca", "host", "c", "qa", "access", "address", "project", "state", "connect", "session", "ch", "capacity", "data", "info", "conf", "attribute", "pool", "ext", "index", "password", "css", "context", "fig", "gate", "args", "front", "client", "man", "driver", "support", "cache", "body", "section", "custom"], "size": ["set", "scale", "offset", "small", "capacity", "code", "data", "SIZE", "name", "shape", "time", "core", "full", "sized", "six", "type", "loc", "z", "max", "sec", "mini", "timeout", "member", "count", "speed", "empty", "complete", "args", "large", "ci", "security", "ize", "length", "key", "limit", "e", "sync", "c", "si", "iz", "shift", "address", "cache", "fee", "sum", "form", "storage", "number", "weight", "Size", "server", "value", "len"]}}
{"project": "qemu", "commit_id": "bb5fc20f7c1c65e95030da3629dd0d7a0cce38cd", "target": 0, "func": "static int usb_device_add(const char *devname, int is_hotplug)\n\n{\n\n    const char *p;\n\n    USBDevice *dev;\n\n\n\n    if (!free_usb_ports)\n\n        return -1;\n\n\n\n    if (strstart(devname, \"host:\", &p)) {\n\n        dev = usb_host_device_open(p);\n\n    } else if (!strcmp(devname, \"mouse\")) {\n\n        dev = usb_mouse_init();\n\n    } else if (!strcmp(devname, \"tablet\")) {\n\n        dev = usb_tablet_init();\n\n    } else if (!strcmp(devname, \"keyboard\")) {\n\n        dev = usb_keyboard_init();\n\n    } else if (strstart(devname, \"disk:\", &p)) {\n\n        BlockDriverState *bs;\n\n\n\n        dev = usb_msd_init(p, &bs);\n\n        if (!dev)\n\n            return -1;\n\n        if (bdrv_key_required(bs)) {\n\n            autostart = 0;\n\n            if (is_hotplug && monitor_read_bdrv_key(bs) < 0) {\n\n                dev->handle_destroy(dev);\n\n                return -1;\n\n            }\n\n        }\n\n    } else if (!strcmp(devname, \"wacom-tablet\")) {\n\n        dev = usb_wacom_init();\n\n    } else if (strstart(devname, \"serial:\", &p)) {\n\n        dev = usb_serial_init(p);\n\n#ifdef CONFIG_BRLAPI\n\n    } else if (!strcmp(devname, \"braille\")) {\n\n        dev = usb_baum_init();\n\n#endif\n\n    } else if (strstart(devname, \"net:\", &p)) {\n\n        int nic = nb_nics;\n\n\n\n        if (net_client_init(\"nic\", p) < 0)\n\n            return -1;\n\n        nd_table[nic].model = \"usb\";\n\n        dev = usb_net_init(&nd_table[nic]);\n\n    } else if (!strcmp(devname, \"bt\") || strstart(devname, \"bt:\", &p)) {\n\n        dev = usb_bt_init(devname[2] ? hci_init(p) :\n\n                        bt_new_hci(qemu_find_bt_vlan(0)));\n\n    } else {\n\n        return -1;\n\n    }\n\n    if (!dev)\n\n        return -1;\n\n\n\n    return usb_device_add_dev(dev);\n\n}\n", "idx": 18915, "substitutes": {"devname": [" devnum", "gustart", " devid", "defid", "guname", "devNAME", "devnum", "guno", "plugcase", "evno", "deviceName", "evnamed", "propname", "plugno", "domname", "busname", "evstart", "devnamed", "busName", "pubName", "driverame", "DevNAME", "pubno", "bugstart", "propstart", "evcase", "plugName", "devicenum", "bugname", "deviceid", "DevName", " devno", "devame", "evName", "domno", "divnum", "defName", "devcase", "evname", "defno", "pubname", "propName", "drivername", "devstart", "busnamed", "pubstart", "Devname", "divname", "devno", "divName", "guName", "deviceNAME", "divno", "propno", "devicestart", " devcase", "driverstart", "busno", "devName", "evame", " devNAME", "bugame", "defname", "driverno", "plugname", "devid", "bugno", " devnamed", "deviceno", "devicename", " devName", "domstart", " devstart"], "is_hotplug": ["is_Hotplug", "is_nitplugin", "is_hotplugin", "is_deadlog", "is_Hotlog", "is_hotsplug", "is_hotslog", "is_hotpl", "is_livepl", "is_hotsplugin", "is_liveplug", "is_HotPlug", "is_deadplug", "is_nitpl", "is_hotsPlug", "is_nitplug", "is_deadPlug", "is_hotspl", "is_liveplugin", "is_hotlog", "is_hotPlug"], "p": ["pc", "per", "plugin", "part", "m", "point", "wp", "pot", "j", "s", "t", "data", "fp", "f", "jp", "op", "sp", "vp", "r", "pe", "n", "g", "i", "bp", "cp", "lp", "this", "ap", "pb", "self", "o", "ip", "po", "l", "d", "pp", "path", "pi", "pre", "args", "e", "pa", "q", "client", "v", "par", "c", "ps", "pad", "b", "pr", "params", "param", "proc", "h", "api", "tp", "py", "port", "np", "pt", "P"], "dev": ["grad", "dd", "user", "gd", "obj", "comment", "gu", "md", "debug", "result", "var", "d", "ev", "lib", "test", "od", "boot", "end", "valid", "die", "ve", "conn", "Dev", "mod", "pub", "de", "rad", "nov", "app", "develop", "development", "controller", "adv", "v", "dom", "off", "plug", "bus", "ver", "dc", "err", "f", "root", "block", "di", "w", "ad", "serv", "device", "inst", "dem", "priv", "bug", "db", "ch", "data", "info", "conf", "ow", "def", "df", "av", "fail", "img", "cam", "req", "cmd", "driver", "cache", "cmp", "error", "DEV", "diff", "dist"], "bs": ["ns", "ms", "bi", "br", "db", "s", "fps", "rs", "bm", "sb", "bp", "cb", "sl", "bc", "ls", "ss", "pb", "fs", "bb", "lb", "ba", "bid", "cs", "css", "gb", "bos", "ins", "bps", "BS", "iss", "bd", "blocks", "bis", "sc", "bl", "vs", "bh", "fb", "bas", "mb", "ps", "b", "ks", "gs", "its", "os", "state", "us", "bus", "sa", "ds"]}}
{"project": "qemu", "commit_id": "7e01376daea75e888c370aab521a7d4aeaf2ffd1", "target": 0, "func": "void ioinst_handle_msch(S390CPU *cpu, uint64_t reg1, uint32_t ipb)\n\n{\n\n    int cssid, ssid, schid, m;\n\n    SubchDev *sch;\n\n    SCHIB schib;\n\n    uint64_t addr;\n\n    int ret = -ENODEV;\n\n    int cc;\n\n    CPUS390XState *env = &cpu->env;\n\n    uint8_t ar;\n\n\n\n    addr = decode_basedisp_s(env, ipb, &ar);\n\n    if (addr & 3) {\n\n        program_interrupt(env, PGM_SPECIFICATION, 2);\n\n        return;\n\n    }\n\n    if (s390_cpu_virt_mem_read(cpu, addr, ar, &schib, sizeof(schib))) {\n\n        return;\n\n    }\n\n    if (ioinst_disassemble_sch_ident(reg1, &m, &cssid, &ssid, &schid) ||\n\n        !ioinst_schib_valid(&schib)) {\n\n        program_interrupt(env, PGM_OPERAND, 2);\n\n        return;\n\n    }\n\n    trace_ioinst_sch_id(\"msch\", cssid, ssid, schid);\n\n    sch = css_find_subch(m, cssid, ssid, schid);\n\n    if (sch && css_subch_visible(sch)) {\n\n        ret = css_do_msch(sch, &schib);\n\n    }\n\n    switch (ret) {\n\n    case -ENODEV:\n\n        cc = 3;\n\n        break;\n\n    case -EBUSY:\n\n        cc = 2;\n\n        break;\n\n    case 0:\n\n        cc = 0;\n\n        break;\n\n    default:\n\n        cc = 1;\n\n        break;\n\n    }\n\n    setcc(cpu, cc);\n\n}\n", "idx": 18931, "substitutes": {"cpu": ["pc", "program", "process", "fp", "core", "jp", "uci", "net", "rc", "performance", "cm", "pl", "loader", "cpp", "machine", "cp", "python", "CP", "ctx", "fc", "lb", "mem", "computer", "vm", "GPU", "css", "roc", "gp", "linux", "chip", "pp", "pkg", "gpu", "CPU", "config", "processor", "cli", "lc", "c", "kernel", "hp", "uc", "p", "cache", "cmp", "intel", "proc", "cn", "boot", "connection", "pu", "mac", "prem", "cow", "conn"], "reg1": ["REG1", "rg2", "rcfirst", "rg1", "REG3", "rc2", "regionfirst", "arcb", "REGb", "region1", " reg3", "arc1", "regb", "arc3", "reg3", "rc1", "regfirst", "region2", " regb", "rgfirst", "reg2"], "ipb": [" ipn", " ipl", "ipa", "ipsl", "IPv", "ipn", "ipsB", "opv", "IPa", "IPl", " ipa", "ipsa", "ipv", "IPB", "opb", "ipl", "IPb", " ipB", "ipB", "ipsb", "opn", "IPn", "opa", " ipv"], "cssid": ["rsside", "nsID", "hesside", "sskid", "ssit", "hessname", "passID", "nside", "nsids", "jsID", "passname", "rssname", "jskid", "cssID", "sside", "cssId", "nsId", "csskid", "hessit", "passid", "nskid", "hessID", "lside", "lsId", "cssit", "rssid", "ssID", "rssids", "jsid", "jside", "passide", "nsid", "csside", "rssId", "cssids", "lsids", "cssname", "lsid", "ssname", "hessid", "rssit"], "ssid": ["rsside", "ssite", "ssids", "sslit", "csid", "sklit", "skide", "ossite", "rsskid", "cssite", "passname", "rssname", "cssID", "csite", "sside", "ssiden", "csskid", "passid", "ossid", "osside", "csids", "spids", "spid", "passkid", "spname", "rssid", "ssID", "csID", "cside", "skid", "passide", "spID", "cssiden", "csiden", "csside", "skkid", "ossiden", "cssids", "cssname", "sskid", "ssname", "cskid", "cslit", "csslit", "csname"], "schid": ["skib", "ssib", "skip", "ssi", "schbit", "ssit", "ski", "chid", "chbit", "ssinfo", "skbit", "chi", "chit", "schinfo", "schit", "cssinfo", "skit", "schname", "skname", "cssip", "schi", "skinfo", "skid", "schip", "chib", "ssip", "ssbit", "cssname", "ssname", "chip"], "m": ["s", "ch", "mode", "f", "r", "M", "n", "md", "cm", "mi", "bm", "pm", "g", "i", "module", "ym", "machine", "am", "om", "mc", "mem", "manager", "o", "sm", "vm", "l", "d", "sh", "mr", "w", "config", "dm", "e", "man", "v", "c", "p", "hm", "b", "fm", "h", "a", "im", "y", "mu"], "sch": ["ch", "cht", "och", "che", "conf", "sky", "sp", "cm", "hop", "sb", "gh", "sl", "ss", "rh", "loc", "shop", "inch", "chid", "ich", "mc", "cer", "kr", "Sch", "sd", "her", "sm", "sk", "chi", "wk", "cs", "css", "gb", "ach", "kh", "sh", "zh", "ssh", "Ch", "sn", "sc", "ssl", "soc", "k", "cr", "cur", "chan", "c", "si", "arch", "sche", "ph", "inst", "co", "se", "chn", "ah", "conn"], "schib": ["skib", "ssib", "chie", "skip", "skie", "schig", "scheib", "scheig", "chob", "schbi", "khab", "schIB", "skIB", "schab", "chid", "schie", "chig", "khib", " schbi", "khIB", "ssbi", "scheIB", "schelib", "scheip", "chbi", "chlib", "schlib", "sklib", "skid", "schip", " schob", "chib", "ssip", "chIB", "khip", " schip", "chab", "schob", "skig", "scheid", "scheie", "scheab", "chip", "ssob"], "addr": ["rx", "part", "dd", "rr", "offset", "au", "code", "Address", "data", "rs", "x", "base", "call", "ref", "reg", "rc", "ord", "ann", "rt", "hash", "align", "arm", "oa", "src", "adder", "node", "ext", "acl", "ptr", "rac", "arr", "ip", "art", "sta", "host", "ack", " address", "ac", "args", "add", "ad", "id", "fd", "asm", "ars", "ag", "afi", "url", "address", "pad", "inter", "cmp", "adr", "ace", "az", "amd", "mac", "order", "attr", "amp", "len"], "cc": ["pc", "dc", "ret", "sup", "dd", "xx", "ff", "code", "func", "cca", "call", "comment", "ct", "CC", "RC", "vc", "rc", "inc", "result", "acc", "cf", " succ", "coll", "match", "bc", "cb", "pass", "PC", "fc", "count", "lv", " ret", "cs", "ce", "bug", "nc", "cost", "ac", "ci", "sc", "ucc", "c", "success", "seq", " ecc", "uc", "cmd", "ck", "fee", "cmp", "ec", " rc", "unc", "weight", "co", "isc", " CC", "kk", "cci"], "env": ["ei", "enable", "cfg", "viron", "global", "code", "esp", "core", "conf", "err", "obj", "estate", "ini", "eve", "eye", "eu", "engine", "pe", "net", "cf", "exc", "loader", "oa", "cp", "shell", "erv", "gui", "environment", "ctx", "python", "console", "en", "eng", "enc", "equ", "vm", "exec", "context", "hw", "inet", "nc", "style", "config", "ev", "e", "ep", "asm", "ern", "cli", "c", "ea", "que", "cache", "cmp", "ec", "proc", "priv", "er", "agent", "state", "eni", "server", "np", "dict", "conn"], "ar": ["aer", "at", " array", "rs", "al", "base", "ara", "Ar", "iar", "r", "ai", "inc", "car", "arn", "ary", "str", "or", "arm", "as", "ap", "arr", "har", "AR", "art", "arc", "arg", "dar", "array", "are", "ac", "args", "rar", "aa", "tar", "ad", "ars", "par", "cr", "c", "ir", "area", "inter", "ada", "arch", "adr", "ra", "ace", "a", "air", "ard", "el", "arp", "arat", "ari", "amp"]}}
{"project": "qemu", "commit_id": "7e5f90fa3ff32ea31548666d57a78005555ecf34", "target": 1, "func": "int load_uimage(const char *filename, target_ulong *ep, target_ulong *loadaddr,\n\n                int *is_linux)\n\n{\n\n    int fd;\n\n    int size;\n\n    uboot_image_header_t h;\n\n    uboot_image_header_t *hdr = &h;\n\n    uint8_t *data = NULL;\n\n    int ret = -1;\n\n\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (fd < 0)\n\n        return -1;\n\n\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n\n    if (size < 0)\n\n        goto out;\n\n\n\n    bswap_uboot_header(hdr);\n\n\n\n    if (hdr->ih_magic != IH_MAGIC)\n\n        goto out;\n\n\n\n    /* TODO: Implement Multi-File images.  */\n\n    if (hdr->ih_type == IH_TYPE_MULTI) {\n\n        fprintf(stderr, \"Unable to load multi-file u-boot images\\n\");\n\n        goto out;\n\n    }\n\n\n\n    switch (hdr->ih_comp) {\n\n    case IH_COMP_NONE:\n\n    case IH_COMP_GZIP:\n\n        break;\n\n    default:\n\n        fprintf(stderr,\n\n                \"Unable to load u-boot images with compression type %d\\n\",\n\n                hdr->ih_comp);\n\n        goto out;\n\n    }\n\n\n\n    /* TODO: Check CPU type.  */\n\n    if (is_linux) {\n\n        if (hdr->ih_type == IH_TYPE_KERNEL && hdr->ih_os == IH_OS_LINUX)\n\n            *is_linux = 1;\n\n        else\n\n            *is_linux = 0;\n\n    }\n\n\n\n    *ep = hdr->ih_ep;\n\n    data = qemu_malloc(hdr->ih_size);\n\n    if (!data)\n\n        goto out;\n\n\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n\n        fprintf(stderr, \"Error reading file\\n\");\n\n        goto out;\n\n    }\n\n\n\n    if (hdr->ih_comp == IH_COMP_GZIP) {\n\n        uint8_t *compressed_data;\n\n        size_t max_bytes;\n\n        ssize_t bytes;\n\n\n\n        compressed_data = data;\n\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n\n        data = qemu_malloc(max_bytes);\n\n\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n\n        qemu_free(compressed_data);\n\n        if (bytes < 0) {\n\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n\n            goto out;\n\n        }\n\n        hdr->ih_size = bytes;\n\n    }\n\n\n\n    cpu_physical_memory_write_rom(hdr->ih_load, data, hdr->ih_size);\n\n\n\n    if (loadaddr)\n\n        *loadaddr = hdr->ih_load;\n\n\n\n    ret = hdr->ih_size;\n\n\n\nout:\n\n    if (data)\n\n        qemu_free(data);\n\n    close(fd);\n\n    return ret;\n\n}\n", "idx": 18942, "substitutes": {"filename": ["uri", "txt", "fp", "f", "name", "fil", "tty", "file", "wl", "kl", "files", "source", "wb", "acl", "tif", "username", "lf", "nil", "jpg", "original", "directory", "path", "FH", "utf", "prefix", "il", "download", "rl", "rb", "url", "binary", "ppa", "fn", "figure", "dll", "Filename"], "ep": ["wp", "offset", "esp", "dep", "fp", "op", "sp", "ek", "rc", "elf", "channel", "ream", "root", "cp", "ext", "Ep", "ap", "isp", "ip", "xp", "enc", "dp", "pp", "up", "esi", "email", "ev", "e", "cl", "EP", "imp", "seq", "p", "mp", "ppa", "ec", "ef", "yp", "el", "env", "eps"], "loadaddr": ["packoffset", "lockoffset", "lockaddress", "lockptr", "laddr", "lptr", "packaddress", "laddress", "loadptr", "loadoffset", "loadaddress", "packaddr", "lockaddr", "loffset", "packptr"], "is_linux": ["is_intel", " is_ubuntu", " is_pkg", "is2mac", "is___local", "is_pkg", " is_binary", "is_binary", " is_boot", "is_mac", "is_cpu", "is2cpu", "is___binary", "is_local", "is_ubuntu", " is_intel", " is_Linux", "is_boot", "is___ubuntu", "is_Linux", " is_mac", "is2linux", "is___linux", "is2Linux", " is_local", " is_cpu"], "fd": ["dc", "dra", "ecd", "dd", "dn", "draft", "db", "fw", "nd", "fr", "fp", "fat", "f", "reader", "dir", "handle", "md", "file", "pd", "fa", "feed", "hd", "vd", "wb", " fid", "fc", "dl", "ld", "wd", "fs", "writer", "sd", "fed", "lf", "wind", "ln", "fx", "cond", "d", "fl", "df", "ird", "bf", "FH", "bd", "pipe", "handler", "fb", "buf", "xd", "flo", "dat", "fn", "form", "cd", "len", "fi", "FD", "ds", "sf"], "size": ["scale", "content", "shape", "small", "code", "SIZE", "name", "err", "mode", "fat", "f", "capacity", "n", "sized", "g", "i", "z", "loc", "sec", "time", "any", "en", "count", "speed", "enc", "empty", "sh", "large", "sn", "ize", "length", "sync", "temp", "unit", "si", "iz", "address", "sum", "cache", "fee", "form", "body", "weight", "Size", "len"], "h": [" dh", "m", "eh", "f", " uh", " hr", "r", "hr", " hp", "g", "hi", "hd", "z", "rh", " self", "host", "d", "header", "ht", "sh", " dw", "w", "e", "handler", "bh", "ih", " ah", "c", "v", "hp", "p", " header", "hm", " hash", "hh", "ph", " eh", "hs", "ah", "H", " H"], "hdr": ["shhr", "hhmr", "httpDR", "mdr", "hyDR", "hstr", " hvd", " hld", " hpr", "rhadr", "Hstr", "thdr", "rhrec", "hder", "hymr", "archder", "ohdr", "hld", "ihder", "chdr", "herder", "avvd", "hrid", "ghcart", "hmr", "hlrec", "phDR", "bhder", "ohder", "shadr", "hyr", "Hdr", "hiDR", "ihod", "hrcart", "hr", "hDR", "khstr", "hfr", "hlrid", "mhr", "rhdr", "khdr", "khrid", "hvd", "archdr", "httpref", "phrec", "hrec", "ghrid", "hrdr", "hlpr", "archstr", "hhDR", " hDR", "HDR", "Hdi", "handrec", "histr", "hpr", " hrec", "hod", "shdr", "ohfr", " hrr", "hadr", "thder", "bhdr", "rhder", "handdr", "avrid", "ghrec", "hcart", "hirid", "hdi", "hlDR", "thrr", "bhrr", "chder", "avrec", " hod", "ihDR", "hhr", " hstr", "adhDR", "shref", "handrid", " href", "handvd", "hidr", "hydr", "phstr", " hhr", "shDR", "rhDR", "herrec", "hldi", "hrrec", "ihdr", "hrrid", "ihrr", "hlrr", "adhrid", "mrec", " hdi", " hder", "httpdi", "chDR", "href", "adhder", "mdi", "ohrec", " hr", "shdi", "ihrid", "shpr", "hider", "archDR", "ghdr", "httpdr", "shrec", "hlod", "herdr", "Hrec", " hadr", "adhdr", "rhfr", "hild", "hlcart", "hldr", "chdi", "avdr", "Hder", "hrr", " hmr", " hrid", "hhdr", "khld", "phdr", "herfr"], "data": ["dd", "extra", "sample", "result", "str", "raw", "pos", "zip", "d", "rec", "empty", "new", "no", "da", "p", "pad", "none", "dat", "next", "output", "end", "valid", "source", "reader", "input", "len", "Data", "content", "nd", "media", "dt", "done", "timeout", "arr", "read", "zero", "parent", "binary", "ata", "la", "a", "download", "ds", "broken", "base", "image", "json", "results", "window", "block", "di", "byte", "multi", "actions", "final", "array", "memory", "aa", "start", "buf", "batch", "sent", "missing", "append", "aw", "alpha", "value", "progress", "buffer", "feed", "slice", "format", "partial", "complete", "response", "cache", "wa", "body", "DATA", "inner"], "compressed_data": ["compressed___data", "compressed_byte", "compested_dist", "compested_result", "compested_memory", "compoded_response", "compodedingdata", "compoded_data", "compodedingsize", "compressed_dat", "compodedingdat", "compested___result", "compressedingresponse", "compressed_result", "compressed___result", "comprated_data", "compressed_response", "comprated_byte", "compratedingbody", "compratedingsize", "compested_data", "compested___data", "compressedingdat", "compressedingsize", "compoded_size", "compressed_dist", "compressedingdata", "compressederresponse", "compratedingbyte", "compressederdata", "comprated_body", "compratedingdata", "compested___dist", "compressedingbody", "compressed_body", "compressederdat", "compressed___dist", "compoded_dat", "comprated_size", "compressed___memory", "compressed_memory", "compressed_size", "compodedingresponse", "compested___memory", "compressedersize", "compressedingbyte"], "max_bytes": ["min_groups", "maxingframes", "min_seconds", "maxingseconds", "max67days", "max2bits", " max_bits", "min_bytes", "max2blocks", " max_frames", "max_seconds", "max__pages", "max2bytes", "min_days", "max_frames", "max67bytes", " max_seconds", "max_days", "maxingbits", "max67groups", " max_blocks", "max_blocks", "max_groups", "max67seconds", "max_bits", "maxingbytes", "max__bytes", " max_pages", "max2seconds", "max__seconds", "max_pages"], "bytes": ["ns", "values", "content", "bs", "code", "pieces", "words", "pages", "amples", "results", "seconds", "ips", "files", "ops", "raw", "items", "byte", "lines", "Bytes", "units", "complete", "cells", "args", "outs", "blocks", "codes", "parent", "bits", "steps", "seq", "binary", "video", "loads", "ec", "reads", "body", "parts", "len"]}}
{"project": "FFmpeg", "commit_id": "2e5195646dc5578e1751004b0ac6e787d18637e4", "target": 1, "func": "static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MPCContext *c = s->priv_data;\n\n    int ret, size, size2, curbits, cur = c->curframe;\n\n    int64_t tmp, pos;\n\n\n\n    if (c->curframe >= c->fcount)\n\n        return -1;\n\n\n\n    if(c->curframe != c->lastframe + 1){\n\n        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}", "idx": 18963, "substitutes": {"s": ["ns", "ms", "spec", "m", "ts", "sg", "session", "bs", "t", "rs", "aws", "f", "conf", "sv", "settings", "services", "r", "service", "ions", "n", "sb", "g", "sl", "ss", "ls", "as", "ops", "fs", "is", "cs", "l", "d", "su", "ins", "sites", "site", "qs", "e", "ssl", "sc", "ses", "v", "sync", "js", "si", "ps", "sym", "p", "S", "ks", "b", "http", "gs", "sys", "states", "es", "os", "us", "sets", "se", "sq", "y", "ds", "sf"], "pkt": ["ppKT", "psth", "preacket", "Pdt", "spke", "prekg", "fkt", "Pett", "ppsth", " psth", "Pet", "prkg", "placket", "fet", "pett", "spett", "Packet", "Psth", "plkt", "pKT", " pdt", " pct", "predt", "packet", " pet", "spkt", "spacket", " packet", "opkg", "ppkt", "plett", "Pft", "ppacket", "prft", "pracket", "PKT", "facket", "Pkg", "pkg", "opct", "opkt", "pct", " pft", "fkg", "Pkt", "Pct", " pkg", "pet", "pke", "pft", "opacket", "pdt", "Pke", " pKT", "prkt", "plke", "prekt"], "c": ["dc", "pc", "ic", "oc", "m", "ch", "code", "t", "x", "f", "cus", "vc", "ct", "conn", "r", "cm", "n", "cf", "g", "i", "coll", "cp", "bc", "z", "fc", "mc", "sec", "cy", "o", "ca", "enc", "cs", "l", "d", "ce", "chain", "nc", "ac", "ci", "q", "con", "xc", "w", "tc", "sc", "cu", "e", "k", "cr", "v", "cat", "lc", "cur", "cl", "config", "p", "uc", "cache", "b", "col", "ec", "h", "unc", "cn", "co", "C", "y", "cc", "u"], "ret": [" len", "part", "code", "data", "info", "obj", "f", "alt", "rc", "nt", "lit", "fun", "rt", "result", "num", "match", "mem", "resp", "rets", "def", "arr", "att", "flat", "val", "re", "Ret", " result", "length", "det", "buf", "temp", "seq", "RET", "cache", "pet", "res", " resp", "ft", "uf", "reply", "Len", "len"], "size": ["offset", "extra", "skip", "num", "max", "sec", "enc", "empty", "sh", "length", "send", "temp", "write", "bytes", "Size", "len", "scale", "name", "handle", "count", "parse", "read", "si", "weight", "time", "code", "SIZE", "r", "sized", "loc", "speed", "sn", "ize", "buf", "sent", "sum", "fee", "small", "shape", "capacity", "data", "sp", "buffer", "n", "feed", "g", "sw", "ny", "en", "use", "e", "_", "unit", "used", "error", "se"], "size2": ["name4", "speedTwo", "time2", "length56", "speed1", "position1", "size1", "name2", "length5", " size4", "length2", " size5", "rate2", "speed32", "speed3", "size5", "ize1", "size4", "rate1", "size56", " size3", " sizeTwo", "time1", "ize2", "size32", "rateTwo", "name1", "ize5", " size1", "speed2", "lengthTwo", "rate32", "length3", " size32", "length32", "positionTwo", "position56", "position2", "time4", " size56", "length1", "size3", "sizeTwo"], "curbits": ["lcurbite", " caudIT", "curbITS", " caudited", "cobbIT", " caudits", "cufforts", "bcurbbits", "bcribids", "caurbits", "caurITS", "lcribients", "cribals", "lcaurites", "crubins", "lcurbbits", "scurbITS", "curtIT", "scurbiting", " curbIT", "scaurit", "caudite", "cuffbits", "lcribITS", "caurits", "culpins", "caudats", "scurbits", "lcurtites", "cauriting", "crubites", "lcribins", "caurite", "bcurbids", "scurtins", "cobbins", "cribbits", "curlits", "curbids", "curlorts", "bcribins", "curbited", "bcurborts", "caudites", "curbases", "curlbits", "caudited", "curtited", "bcriborts", "caurals", "cuffids", "bcurbats", "scaurIT", "caudases", "scauriting", "lcaurIT", "curbbits", "cuffints", "cobbites", "curlids", "curbites", "caurins", "coblits", "caurients", "scurbints", "culpit", "caudIT", "curtites", "bcurbins", "caudITS", "cribases", "scribites", "caudits", "cobliting", "coblites", "curbite", "scurtints", "bcurbits", "culpites", " curbites", "caurints", "lcribits", "lcurbIT", "lcribases", "cribIT", "cribits", "lcurbITS", "cribited", " caudites", "curtITS", "lcurtITS", "curbiting", "criborts", "bcribbits", "scurtits", "curtbits", "lcurtins", "lcaurbits", "lcurbients", "cribats", "cuffites", "curits", "scribITS", "lcaurins", "scurtites", "lcurtits", "caurases", "curbit", "scurbins", "cribids", "curbints", "coblIT", "scaurins", "curtins", "scribins", "cribiting", "curborts", "lcribites", "scurbIT", "culpits", "lcurbites", "caurit", "cribins", "scurbites", "crubients", "curIT", "curins", "caurIT", "caudins", "curbats", "curtits", "cuffins", "curbIT", "caurites", "bcribals", "lcurbases", "cribites", "scribits", "bcribats", "curites", "lcurbins", "caudals", "scaurits", "cuffits", "cribite", "bcribits", "curbins", "scurbit", "lcurbits", "curtints", "curbients", "cribITS", "cribit", " curbited", "curbals", "lcaurite", "cobbits", "cribients", "lcaurits", "bcurbals", "crubits", "caurats", "scaurites"], "tmp": ["offset", "obj", "nt", "bp", "ptr", "zip", "po", "vm", "uv", "stuff", "buff", "elt", "temp", "meta", "p", "vt", "pad", "mp", "txt", "obb", "ape", "cp", "bb", "perm", "tab", "su", "v", "kk", "amp", "wp", "fp", "jp", "sb", "cb", "src", "abb", "appy", "nb", "buf", "fb", "uple", "np", "now", "data", "sp", "buffer", "ock", "tc", "foo", "rb", "trans", "cache", "cmp", "storage", "proc", "cro", "body", "api", "tp", "uf", "mo"], "pos": ["pc", "part", "stat", "spec", "offset", "skip", "pid", "data", "conf", "x", "ref", "op", "sp", "all", "pl", "rel", "block", "nos", "type", "loc", "Pos", "index", "fin", "sec", "min", "count", "pointer", "POS", "po", "prop", "val", "slot", "pi", "pre", "pri", "no", "rot", "start", "temp", "unit", "neg", "position", "p", "line", "doc", "pose", "cache", "proc", "res", "pro", "os", "state", "end", "port", "pres", "addr", "pt", "len"], "curframe": ["prevcycle", "prevframe", "firstimage", "vermodule", "curthread", "forefamily", "currentframes", "currentfram", "catsequence", "curfamily", "currentmodule", "Cursample", "lastframe", "vercycle", "urmodule", "foreflower", "urfram", "Curcycle", "curimage", "firstFrame", "perfram", "curflower", "currentimage", "permodule", "prevFrame", "Curflower", "firstsequence", "curcycle", "urframe", " cursequence", "lastfram", "catthread", "catframe", "catfram", "curfram", "currentframe", " curthread", "prevframes", " curimage", " curFrame", "currentFrame", " curfamily", " curflower", "verfram", "firstframe", "Curfamily", "Curfram", "prevsample", "Curframe", "firstfram", "verframe", "urcycle", " curfram", "percycle", "persample", "persequence", "forefram", "lastsequence", "cursequence", "Curmodule", "perframe", "curFrame", "currentthread", "curmodule", "currentsequence", " curmodule", "cursample", "curframes", "foreframe", "prevfram", " curframes"], "frames_noted": ["frames_notuned", "frames_notized", "frames_partuned", "frames_partned", "frames_noteds", "frames_anneds", "frames_naated", "frames_partated", "frames_NOTed", "frames_notmed", "frames__notized", "frames_NOTuned", "frames__NOTed", "frames_annmed", "frames_NOTeds", "frames_naed", "frames_naned", "frames_anned", "frames_parted", "frames_NOTated", "frames_annized", "frames__notmed", "frames_notned", "frames__NOTeds", "frames_nauned", "frames_NOTned", "frames_NOTized", "frames_NOTmed", "frames_notated", "frames__noted", "frames__NOTmed", "frames__NOTized", "frames__noteds"]}}
{"project": "qemu", "commit_id": "27bb0b2d6f80f058bdb6fcc8fcdfa69b0c8a6d71", "target": 1, "func": "static void hpet_ram_writel(void *opaque, target_phys_addr_t addr,\n\n                            uint32_t value)\n\n{\n\n    int i;\n\n    HPETState *s = (HPETState *)opaque;\n\n    uint64_t old_val, new_val, val, index;\n\n\n\n    DPRINTF(\"qemu: Enter hpet_ram_writel at %\" PRIx64 \" = %#x\\n\", addr, value);\n\n    index = addr;\n\n    old_val = hpet_ram_readl(opaque, addr);\n\n    new_val = value;\n\n\n\n    /*address range of all TN regs*/\n\n    if (index >= 0x100 && index <= 0x3ff) {\n\n        uint8_t timer_id = (addr - 0x100) / 0x20;\n\n        DPRINTF(\"qemu: hpet_ram_writel timer_id = %#x \\n\", timer_id);\n\n        HPETTimer *timer = &s->timer[timer_id];\n\n\n\n        if (timer_id > HPET_NUM_TIMERS - 1) {\n\n            DPRINTF(\"qemu: timer id out of range\\n\");\n\n            return;\n\n        }\n\n        switch ((addr - 0x100) % 0x20) {\n\n            case HPET_TN_CFG:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CFG\\n\");\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_TN_CFG_WRITE_MASK);\n\n                timer->config = (timer->config & 0xffffffff00000000ULL) | val;\n\n                if (new_val & HPET_TN_32BIT) {\n\n                    timer->cmp = (uint32_t)timer->cmp;\n\n                    timer->period = (uint32_t)timer->period;\n\n                }\n\n                if (new_val & HPET_TIMER_TYPE_LEVEL) {\n\n                    printf(\"qemu: level-triggered hpet not supported\\n\");\n\n                    exit (-1);\n\n                }\n\n\n\n                break;\n\n            case HPET_TN_CFG + 4: // Interrupt capabilities\n\n                DPRINTF(\"qemu: invalid HPET_TN_CFG+4 write\\n\");\n\n                break;\n\n            case HPET_TN_CMP: // comparator register\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP \\n\");\n\n                if (timer->config & HPET_TN_32BIT)\n\n                    new_val = (uint32_t)new_val;\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffff00000000ULL)\n\n                                  | new_val;\n\n                if (timer_is_periodic(timer)) {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffff00000000ULL)\n\n                                     | new_val;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_CMP + 4: // comparator register high order\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_CMP + 4\\n\");\n\n                if (!timer_is_periodic(timer) ||\n\n                           (timer->config & HPET_TN_SETVAL))\n\n                    timer->cmp = (timer->cmp & 0xffffffffULL)\n\n                                  | new_val << 32;\n\n                else {\n\n                    /*\n\n                     * FIXME: Clamp period to reasonable min value?\n\n                     * Clamp period to reasonable max value\n\n                     */\n\n                    new_val &= (timer->config\n\n                                & HPET_TN_32BIT ? ~0u : ~0ull) >> 1;\n\n                    timer->period = (timer->period & 0xffffffffULL)\n\n                                     | new_val << 32;\n\n                }\n\n                timer->config &= ~HPET_TN_SETVAL;\n\n                if (hpet_enabled())\n\n                    hpet_set_timer(timer);\n\n                break;\n\n            case HPET_TN_ROUTE + 4:\n\n                DPRINTF(\"qemu: hpet_ram_writel HPET_TN_ROUTE + 4\\n\");\n\n                break;\n\n            default:\n\n                DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n                break;\n\n        }\n\n        return;\n\n    } else {\n\n        switch (index) {\n\n            case HPET_ID:\n\n                return;\n\n            case HPET_CFG:\n\n                val = hpet_fixup_reg(new_val, old_val, HPET_CFG_WRITE_MASK);\n\n                s->config = (s->config & 0xffffffff00000000ULL) | val;\n\n                if (activating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Enable main counter and interrupt generation. */\n\n                    s->hpet_offset = ticks_to_ns(s->hpet_counter)\n\n                                     - qemu_get_clock(vm_clock);\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        if ((&s->timer[i])->cmp != ~0ULL)\n\n                            hpet_set_timer(&s->timer[i]);\n\n                }\n\n                else if (deactivating_bit(old_val, new_val, HPET_CFG_ENABLE)) {\n\n                    /* Halt main counter and disable interrupt generation. */\n\n                    s->hpet_counter = hpet_get_ticks();\n\n                    for (i = 0; i < HPET_NUM_TIMERS; i++)\n\n                        hpet_del_timer(&s->timer[i]);\n\n                }\n\n                /* i8254 and RTC are disabled when HPET is in legacy mode */\n\n                if (activating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_disable();\n\n                } else if (deactivating_bit(old_val, new_val, HPET_CFG_LEGACY)) {\n\n                    hpet_pit_enable();\n\n                }\n\n                break;\n\n            case HPET_CFG + 4:\n\n                DPRINTF(\"qemu: invalid HPET_CFG+4 write \\n\");\n\n                break;\n\n            case HPET_STATUS:\n\n                /* FIXME: need to handle level-triggered interrupts */\n\n                break;\n\n            case HPET_COUNTER:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffff00000000ULL)\n\n                                  | value;\n\n               DPRINTF(\"qemu: HPET counter written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            case HPET_COUNTER + 4:\n\n               if (hpet_enabled())\n\n                   printf(\"qemu: Writing counter while HPET enabled!\\n\");\n\n               s->hpet_counter = (s->hpet_counter & 0xffffffffULL)\n\n                                  | (((uint64_t)value) << 32);\n\n               DPRINTF(\"qemu: HPET counter + 4 written. ctr = %#x -> %\" PRIx64 \"\\n\",\n\n                        value, s->hpet_counter);\n\n               break;\n\n            default:\n\n               DPRINTF(\"qemu: invalid hpet_ram_writel\\n\");\n\n               break;\n\n        }\n\n    }\n\n}\n", "idx": 18969, "substitutes": {"opaque": ["operacity", "operaco", "Opaque", "OPhole", "Opacity", " opacs", "ophole", " opacity", "operhole", "OPaco", "opera", " opaco", "operacs", "opacity", "operramid", "operaque", " ophole", "ospacity", "opacs", "Opacs", "opaco", " opa", "OPaque", "OPacity", "ospaques", "opaques", "ospaque", "operaques", "ospa", "opramid", "opa", " opaques", " opramid", "Opramid"], "addr": ["grad", "point", "offset", "x", "ref", "md", "align", "arm", "padding", "ptr", "pos", "tx", "socket", "config", "prefix", "id", "asm", "afi", "pad", "adr", "conn", "len", "rx", "ix", "hop", "ld", "pointer", "arr", "slot", "size", "xxx", "mac", "amp", "code", "base", "image", "alt", "rt", "window", "src", "node", "loc", "sta", "xp", "host", "ack", "fx", "nr", "ad", "start", "device", "address", "ace", "data", "mode", "ord", "coord", "oa", "ctx", "dim", "context", "alias", "dr", "seq", "url", "cmp", "oster", "attr"], "value": ["values", "offset", "Value", "work", "example", "data", "name", "image", "buffer", "type", "max", "reference", "function", "padding", "range", "array", "format", "size", "memory", "flow", "length", "v", "VALUE", "test", "address", "null", "wa", "number", "write", "message", "end", "valid", "port", "server", "version", "target"], "i": ["offset", "j", "x", "f", " j", "ix", "r", "n", "z", "ii", "ind", "Index", "I", "l", "d", "ui", "id", "e", "v", "c", "si", "p", "address", "a", " ii", "len"], "s": ["ns", "spec", "m", "session", "sg", "conf", "f", "settings", "services", "service", "r", "sb", "g", "sl", "ss", "ops", "scope", "fs", "o", "space", "args", "socket", "e", "ssl", "ses", "sync", "v", "c", "si", "p", "S", "gs", "sys", "es", "state", "states", "sq", "params", "sf"], "old_val": ["old_vals", "old__Val", "old__eval", "old_value", "old_eval", " old_vals", "old_data", " old_Val", "old__value", "old_Val", "new_Val", " old_eval", "new_data", "new_value", "old__val", "old__data", " old_value"], "new_val": ["old_reg", "old_eval", " new_value", " new_vals", " new_Val", "new_valid", "NEW_VAL", "new67value", "NEW_Val", "newxval", "newxvals", "old_value", "new67reg", "NEW_val", "new_Val", "newJVal", "old_valid", "old_vals", " new_serv", " new_eval", "new_VAL", "new__valid", "new67val", "new67vals", "newJval", "new__Val", "NEWJVAL", "old_Val", "NEW_value", "new_serv", "NEWJvalue", "new_eval", "NEWJval", "newxserv", "new_vals", "new__eval", "newJVAL", "newxVal", "new__val", "NEWJVal", "newJvalue", "new_reg", "new__value", "new_value"], "val": ["Val", "ret", "offset", "data", "cal", "element", "base", "ref", "al", "call", "func", "buffer", "reg", "vals", "role", "sl", "bc", "loc", "evaluate", "trial", "sel", "ctx", "slice", "pb", "timeout", "ee", "exec", "slot", "change", "pre", "pal", "serv", "delay", "v", "unit", "seq", "test", "item", "play", "cache", "eval", "live", "local", "aval", "valid", "end", "el", "len"], "index": ["dc", "part", "point", "offset", "x", "search", "element", "ref", "ix", "bridge", "inc", "align", "hop", "num", "type", "match", "loc", "ctx", "ind", "pos", "Index", "slice", "dim", "pointer", "old", "socket", "height", "length", "id", "key", "prefix", "xxx", "position", "si", "address", "route", "error", "ace", "number", "weight", "find", "connection", "nn", "alpha", "section", "conn", "amp", "len"], "timer": ["gem", "thread", "service", "duration", "trial", "zer", "mom", "icker", "tg", "temp", "trigger", "tom", "amer", "reader", "txt", "stim", "eri", "sim", "timeout", "watch", "manager", "ger", "ter", "mr", "span", "acer", "builder", "oker", "gm", "iter", "tm", "outer", "term", "tim", "time", "cookie", "err", "runner", "tick", "walker", "counter", "worker", "imer", "icer", "task", "player", "caster", "later", "white", "browser", "yer", "monitor", "wrapper", "er", "peer", "writer", "tr", "buffer", "trace", "theme", "uner", "loader", "roller", "cer", "maker", "event", "acker", "tc", "ler", "immer", "Timer", "driver", "editor", "clock", "message", "server", "eddy", "inner"]}}
{"project": "qemu", "commit_id": "2af3da91839c04a5d73643b4eacce4cd93b9d428", "target": 0, "func": "void cpu_dump_state(CPUState *env, FILE *f, fprintf_function cpu_fprintf,\n\n        int flags)\n\n{\n\n    int i;\n\n\n\n    cpu_fprintf(f, \"PC=%08x\\n\", env->pc);\n\n\n\n    for (i = 0; i < 16; ++i) {\n\n        cpu_fprintf(f, \"A%02d=%08x%c\", i, env->regs[i],\n\n                (i % 4) == 3 ? '\\n' : ' ');\n\n    }\n\n}\n", "idx": 18988, "substitutes": {"env": ["enable", "viron", "txt", "db", "code", "obj", "err", "settings", "net", "eu", "ne", "engine", "exc", "loader", "np", "environment", "ext", "ctx", "console", "password", "manager", "en", "fen", "eng", "enc", "equ", "exec", "context", "profile", "inet", "args", "site", "config", "ev", "e", "v", "nw", "inv", "ea", "c", "vt", "que", "ec", "et", "iv", "er", "ef", "export", "server", "eni", "Environment", "cv", "conn"], "f": ["m", "fr", "xf", "j", "ff", "fw", "t", "func", "fp", "af", "fe", "r", "file", "n", "fa", "feed", "cf", "fc", "fs", "rf", "fen", "o", "l", "fx", "d", "w", "fd", "e", "fb", "v", "c", "F", "p", "b", "fm", "tf", "fn", "h"], "cpu_fprintf": ["cpu_forprintf", "cpu_dprintf", "cpu_rfdump", "cpu_cprint", "cpu_ccall", "cpu_Fprintln", "cpu_rfprint", "cpu_cprintf", "cpu_dprint", "cpu_forprint", "cpu_fdump", "cpu_rfcall", "cpu_cprintln", "cpu_fprintln", "cpu_bprint", "cpu_Fwrite", "cpu_fordump", "cpu_rfprintf", "cpu_ddump", "cpu_bprintf", "cpu_cwrite", "cpu_fwrite", "cpu_bwrite", "cpu_Fprint", "cpu_forwrite", "cpu_rfwrite", "cpu_fprint", "cpu_dwrite", "cpu_fcall", "cpu_Fprintf", "cpu_bcall"], "flags": ["offset", "stats", "func", "FLAG", "options", "settings", "ports", "Flags", "fun", "vals", "flag", "ips", "nl", "ints", "ops", "fs", "mask", "linux", "Flag", "ffff", "args", "features", "bits", "lag", "ants", "len"], "i": ["ti", "gi", "uri", "m", "bi", "j", "s", "code", "t", "data", "x", "name", "qi", "io", "ai", "n", "phi", "type", "ii", "ie", "di", "index", "iu", "I", "multi", "zi", "count", "pointer", "o", "ip", "l", "d", "oi", "pi", "ui", "ci", "length", "id", "start", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "h", "split", "a", "number", "eni", "fi", "li", "u"]}}
{"project": "qemu", "commit_id": "8d0bcba8370a4e8606dee602393a14d0c48e8bfc", "target": 0, "func": "int net_init_socket(const NetClientOptions *opts, const char *name,\n\n                    NetClientState *peer, Error **errp)\n\n{\n\n    /* FIXME error_setg(errp, ...) on failure */\n\n    Error *err = NULL;\n\n    const NetdevSocketOptions *sock;\n\n\n\n    assert(opts->kind == NET_CLIENT_OPTIONS_KIND_SOCKET);\n\n    sock = opts->socket;\n\n\n\n    if (sock->has_fd + sock->has_listen + sock->has_connect + sock->has_mcast +\n\n        sock->has_udp != 1) {\n\n        error_report(\"exactly one of fd=, listen=, connect=, mcast= or udp=\"\n\n                     \" is required\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_localaddr && !sock->has_mcast && !sock->has_udp) {\n\n        error_report(\"localaddr= is only valid with mcast= or udp=\");\n\n        return -1;\n\n    }\n\n\n\n    if (sock->has_fd) {\n\n        int fd;\n\n\n\n        fd = monitor_fd_param(cur_mon, sock->fd, &err);\n\n        if (fd == -1) {\n\n            error_report_err(err);\n\n            return -1;\n\n        }\n\n        qemu_set_nonblock(fd);\n\n        if (!net_socket_fd_init(peer, \"socket\", name, fd, 1)) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_listen) {\n\n        if (net_socket_listen_init(peer, \"socket\", name, sock->listen) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_connect) {\n\n        if (net_socket_connect_init(peer, \"socket\", name, sock->connect) ==\n\n            -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (sock->has_mcast) {\n\n        /* if sock->localaddr is missing, it has been initialized to \"all bits\n\n         * zero\" */\n\n        if (net_socket_mcast_init(peer, \"socket\", name, sock->mcast,\n\n            sock->localaddr) == -1) {\n\n            return -1;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    assert(sock->has_udp);\n\n    if (!sock->has_localaddr) {\n\n        error_report(\"localaddr= is mandatory with udp=\");\n\n        return -1;\n\n    }\n\n    if (net_socket_udp_init(peer, \"socket\", name, sock->udp, sock->localaddr) ==\n\n        -1) {\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 19003, "substitutes": {"opts": ["optks", "otts", " opters", "ocks", "OPts", " optt", "octt", " opps", "ots", "otds", " opcs", "opters", "ops", "obcs", "otks", "opps", "opcs", "ottt", "otters", "opks", "optts", "obks", "obts", "octs", " opks", "obps", "optps", "otcs", "OPs", "optcs", "optds", "optt", "octers", "OPcs", "OPds", "opds"], "name": ["part", "time", "call", "base", "options", "ame", "conn", "comment", "n", "str", "on", "type", "am", "node", "nam", "sea", "Name", "mini", "active", "filename", "self", "username", "ip", "home", "host", "nm", "NAME", "alias", "old", "new", "path", "up", "common", "size", "like", "large", "style", "space", "no", "prefix", "named", "key", "id", "client", "parent", "temp", "ni", "url", "address", "none", "resource", "cap", "names", "connection", "addr", "port", "server", "word", "version", "hello"], "peer": ["pc", "plugin", "part", "instance", "point", "request", "mode", "vr", "pool", "buffer", "pe", "worker", "loader", "channel", "cb", "master", "attr", "type", "node", "phase", "package", "player", "root", "scope", "wheel", "owner", "fork", "host", "context", "layer", "chain", "pkg", "seed", "wire", "socket", "ssl", "remote", "client", "parent", "rb", "slave", "address", "http", "ker", "proc", "wrapper", "er", "addr", "state", "connection", "port", "server", "pro", "message", "source", "conn", "reader"], "errp": ["erp", "errps", "rrps", "nerps", "errr", "nerp", "rrr", "rrp", "nerr", "erps"], "err": ["rx", "rr", "fr", "rage", "db", "conf", "ref", "runner", "eor", "reader", "fe", "r", "md", "rc", "fi", "inc", "ar", "str", " er", "exc", "cb", "or", "rh", "loc", "msg", "ind", "cer", "der", "ise", "resp", "kr", "ee", "ln", "mr", "rar", "dy", "ev", "rn", "ler", "dr", "lr", "e", "cr", "acer", "req", "rb", "dev", "ir", "doc", "fee", "error", "sys", "Er", "er", "iter", "Error", "gr", "attr", "conn", "bug"], "sock": ["sink", " slock", "say", "inock", " socket", "sck", "opensocket", "sslock", "nsoke", "osoke", "symoke", "confoke", "sslig", "svoke", "confock", "dsoco", " socol", "dsct", "dah", "sct", " siv", " song", "opensoc", "insoke", "psock", "sah", "scho", "dsock", "absock", "slock", "octoke", "toco", "soke", "servock", "psocket", "socks", "socket", "high", " sah", "enssocket", " sct", "ansocket", "psoke", " ssocket", "svock", " scho", "osock", "nock", "symink", "ensock", "sesong", "unsolve", "hsock", "gsolve", "octink", "pck", "octock", "siv", "alsocket", "passoke", " sig", "ssleth", "conflock", "alsolve", "ensvc", "insock", "octocket", "noy", "hsocket", "slib", "sect", "absoke", " svc", "sesocks", "sesvc", "sesocket", " say", "insocket", "noco", "hock", "symeth", "servoke", " solve", "fsay", "sigh", "sloke", "symod", "seth", "bock", "unsell", "gsell", " sink", "opensock", "dong", "sinock", "gsong", "yourock", "soc", "sesock", "insoy", "tah", "ensod", "dsigh", "passocol", "tocks", "holl", "nigh", "scall", "youroc", "absink", "nib", " soc", "boy", "absocket", "boke", "alscall", "nsock", "youriv", "alsell", "hsocks", "slink", "fsoc", "solve", "song", "socol", "inscho", "sib", "dock", "symock", "sesct", "soy", "sloy", "gsoco", "svvc", "alsoke", "sslink", "alsock", "osoup", " sod", "passink", "hocks", "tong", "soll", "hoco", "sinoke", " soco", "unscall", "sinoc", "soco", "gsigh", " sect", "fsiv", "pocks", "ansock", "pink", "confoc", "sig", "sell", " seth", "nsocket", "svink", " sck", "gscall", "nocket", "insink", "nsoy", "passock", "gsink", "dsocks", "slocket", "tock", "sinocket", "hsoll", "obsock", "dect", "gsocket", " socks", "hocket", "soup", "bocket", "obsoco", "symsocket", "pock", "unsock", "svc", "sinocks", "obsoke", "gsoke", "inoke", "inoup", "insoup", "sinong", "gscho", "tect", " sigh", " sib", "ansoke", "dsvc", "ssocket", "inocket", "alsoy", "fsock", "symvc", " soke", " soy", "tigh", "tocket", "servong", "symig", "servigh", "gsock", "youray", "slocol", "psoy", "obsolve", "osocket", "opensoke", "sod", "ansoy"], "fd": ["dc", "dd", "dn", "db", "pid", "ff", "nd", "fp", "fw", "f", "bind", "dir", "func", "conn", "fe", "md", "poll", "pd", "fun", "fa", "cf", "cb", "wb", "dt", " fid", "fc", "dl", " f", "wd", "timeout", "fin", "fs", "sd", "fed", "lf", "ln", "fx", "d", "fl", "df", "wat", "nc", "bf", "socket", "dy", "bd", "pipe", "handler", "fb", "buf", "da", "flo", "driver", "wr", "fee", "fm", "fn", "cd", "write", "connection", "port", "fi", "FD"]}}
{"project": "qemu", "commit_id": "297a3646c2947ee64a6d42ca264039732c6218e0", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005, "substitutes": {"v": ["m", "V", "j", "t", "view", "x", "f", "sv", "vc", "vp", "g", "i", "var", "this", "self", "lv", "o", "vm", "uv", "l", "val", "vis", "conv", "vim", "w", "ev", "k", "e", "vs", "client", "c", "tv", "p", "vt", "vv", "h", "iv", "vic", "api", "value", "u"], "obj": ["init", "j", "code", "ob", "ref", "image", "adj", "office", "objects", "sb", "cb", "type", "node", "ctx", "nb", "self", "object", "o", "po", "otype", "att", "val", "class", "args", "prefix", "det", "bot", "parent", "emb", "js", "tmp", "rb", "lib", "b", "lock", "Object", "api", "Obj"], "name": ["part", "time", "data", "info", "x", "base", "comment", "n", "block", "type", "var", "nam", "Name", "self", "object", "o", "label", "nm", "val", "NAME", "alias", "path", "nice", "common", "no", "prefix", "key", "named", "parent", "ni", "none", "null", "names", "word", "attr"], "errp": ["irlp", " errP", " errcp", "ercp", "errP", "erpp", "irP", "errpc", "erps", "ircp", "erc", "asterpp", " errc", "asterpc", " errlp", "irp", "erpc", "erp", "refc", "errlp", "errps", "erP", "refp", "refps", " errps", "asterp", "asterP", " errpc", "erlp", " errpp", "refP", "errpp", "errc", "errcp"]}}
{"project": "FFmpeg", "commit_id": "dd561441b1e849df7d8681c6f32af82d4088dafd", "target": 0, "func": "static av_always_inline av_flatten void h264_loop_filter_chroma_intra_c(uint8_t *pix, int xstride, int ystride, int alpha, int beta)\n\n{\n\n    int d;\n\n    for( d = 0; d < 8; d++ ) {\n\n        const int p0 = pix[-1*xstride];\n\n        const int p1 = pix[-2*xstride];\n\n        const int q0 = pix[0];\n\n        const int q1 = pix[1*xstride];\n\n\n\n        if( FFABS( p0 - q0 ) < alpha &&\n\n            FFABS( p1 - p0 ) < beta &&\n\n            FFABS( q1 - q0 ) < beta ) {\n\n\n\n            pix[-xstride] = ( 2*p1 + p0 + q1 + 2 ) >> 2;   /* p0' */\n\n            pix[0]        = ( 2*q1 + q0 + p1 + 2 ) >> 2;   /* q0' */\n\n        }\n\n        pix += ystride;\n\n    }\n\n}\n", "idx": 19011, "substitutes": {"av_flatten": ["av2flatten", "av2flash", "av2ffash", "av_lfatt", "av_lfand", "av_slash", "av_lfatten", "av_ffand", "av_slatten", "av_flash", "av2ffatten", "av_ffatt", "av_ffash", "av_flatt", "av_fland", "av_ffatten", "av_sland", "av2ffatt", "av2ffand", "av2flatt", "av_lfash", "av2fland", "av_slatt"], "pix": ["pixels", "Picks", "pani", "prix", "spix", "paixels", "npix", "Pius", "qIX", "paican", "cpicks", "pitch", "picks", "spius", " piped", " pixel", "spip", "qix", "PIX", "pixel", "Pixel", "Pox", " pitch", "priped", "npixed", " pani", " pip", "Pixels", "paius", "pox", "pius", "pip", " pican", "pixed", " pixels", "qicks", "paitch", "npitch", "spixels", "paixed", "Pix", " pox", "npixels", " pius", " pIX", "spican", " pixed", " picks", "cpix", "pIX", "spike", "spixel", "paix", "piped", "prixels", "Pip", "pican", "prani", "cpox", "prike", "Pani", " pike", "cpixels", "prixel", "spiped", "qixels", "pike", "spox"], "xstride": ["ybride", "Xbride", "xstide", "xbrides", "xbrided", "xStrides", "xstider", "xstrice", "xetrided", "xstides", "xstip", "xSTRide", "ystrider", "Xstrice", "xetrider", "xstided", "ybrides", "xStrride", "ystrip", "xstrider", "xetride", "Xstrride", "ystrided", "Xbrride", "Xstrider", "xbrice", "xstrride", "Xstrided", "xstaice", "xSTRides", "ystides", "xstice", "xstrided", "Xstride", "xStrided", "xstrip", "Xstrides", "Xbrice", "XStride", "xbrride", "ystide", "ybrided", "XStrides", "xbride", "xstrides", "xetrides", "ybrride", "xbrider", "xstaide", "Xbrided", "xSTRip", "ystrides", "XStrider", "XStrided", "xSTRided", "ystider", "ystrride", "ystided", "xStride", "xstaided", "xstaride", "ystip", "xStrider"], "ystride": ["ybride", "xstide", " yvariide", "yStrided", "xstides", " yvariride", "ystriride", "ystriide", "yStride", "xstided", " ystredge", "yStrides", "ystriides", "ystrided", "yStrride", "xstrride", "yvariide", " ystrride", "ystides", "ystredge", "xstrided", "ybredge", "ystriided", "ystedge", "ystide", "yvariride", "ybrided", " yvariedge", " ystrided", "xstrides", "ybrride", "yvariedge", "yvariided", "ystrides", "ystrride", "ystided", " yvariided"], "alpha": ["na", "scale", "offset", "f", "r", "inc", "ar", "acc", "igma", "A", "angle", "i", "as", "appa", "ta", "space", "ac", "audio", "aa", "amin", "asa", "lambda", "si", "Beta", "da", "p", "qa", "area", "ra", "a", "Alpha", "pha", "asc", "amp", "u"], "beta": ["bi", "eb", "scale", "offset", "base", "negative", "phi", "border", "igma", "mega", "bp", "i", "bc", "phase", "ii", "\u03b1", "xb", "asc", "ba", "appa", "ta", "margin", "size", "zero", "ac", "aa", "abi", "pa", "c", "lambda", "Beta", "qa", "rb", "p", "si", "pad", "\u03b2", "b", "a", "Alpha", "pha"], "d": ["dc", "m", "dd", "dn", "j", "s", "nd", "t", "x", "f", "du", "r", "md", "pd", "n", "dh", "dos", "g", "i", "z", "dt", "di", "ld", "dl", "ind", "dim", "l", "dy", "w", "dx", "id", "dm", "e", "fd", " dd", "c", "dom", "D", "da", "p", "b", "dat", "ds", "u"]}}
{"project": "qemu", "commit_id": "7364dbdabb7824d5bde1e341bb6d928282f01c83", "target": 1, "func": "static int protocol_version(VncState *vs, uint8_t *version, size_t len)\n\n{\n\n    char local[13];\n\n\n\n    memcpy(local, version, 12);\n\n    local[12] = 0;\n\n\n\n    if (sscanf(local, \"RFB %03d.%03d\\n\", &vs->major, &vs->minor) != 2) {\n\n        VNC_DEBUG(\"Malformed protocol version %s\\n\", local);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    VNC_DEBUG(\"Client request protocol version %d.%d\\n\", vs->major, vs->minor);\n\n    if (vs->major != 3 ||\n\n        (vs->minor != 3 &&\n\n         vs->minor != 4 &&\n\n         vs->minor != 5 &&\n\n         vs->minor != 7 &&\n\n         vs->minor != 8)) {\n\n        VNC_DEBUG(\"Unsupported client version\\n\");\n\n        vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n        vnc_flush(vs);\n\n        vnc_client_error(vs);\n\n        return 0;\n\n    }\n\n    /* Some broken clients report v3.4 or v3.5, which spec requires to be treated\n\n     * as equivalent to v3.3 by servers\n\n     */\n\n    if (vs->minor == 4 || vs->minor == 5)\n\n        vs->minor = 3;\n\n\n\n    if (vs->minor == 3) {\n\n        if (vs->auth == VNC_AUTH_NONE) {\n\n            VNC_DEBUG(\"Tell client auth none\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_client_init(vs);\n\n       } else if (vs->auth == VNC_AUTH_VNC) {\n\n            VNC_DEBUG(\"Tell client VNC auth\\n\");\n\n            vnc_write_u32(vs, vs->auth);\n\n            vnc_flush(vs);\n\n            start_auth_vnc(vs);\n\n       } else {\n\n            VNC_DEBUG(\"Unsupported auth %d for protocol 3.3\\n\", vs->auth);\n\n            vnc_write_u32(vs, VNC_AUTH_INVALID);\n\n            vnc_flush(vs);\n\n            vnc_client_error(vs);\n\n       }\n\n    } else {\n\n        VNC_DEBUG(\"Telling client we support auth %d\\n\", vs->auth);\n\n        vnc_write_u8(vs, 1); /* num auth */\n\n        vnc_write_u8(vs, vs->auth);\n\n        vnc_read_when(vs, protocol_client_auth, 1);\n\n        vnc_flush(vs);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19023, "substitutes": {"vs": ["ns", "ums", "vr", "pages", "las", "settings", "ports", "cf", "ss", "var", "pos", "vm", "cs", "VS", "qs", "ov", "vt", "sts", "ks", "va", "env", "conn", "ms", "plugin", "ts", "rs", "vc", "vp", "vals", "posts", "lines", "lv", "sk", "changes", "pg", "obs", "outs", "iss", "v", "dev", "versions", "hs", "ver", "ds", "ves", "wp", "vas", "bs", "sv", "otes", "net", "ils", "ys", "utils", "act", "ins", "Vs", "prev", "pps", "verts", "alls", "ps", "events", "es", "flags", "eps", "params", "oss", "s", "stats", "services", "plugins", "forces", "ls", "ops", "fs", "xs", "is", "vers", "views", "css", "args", "ses", "client", "js", "http", "gs", "ues", "its", "os", "server", "docs"], "version": ["VERSION", "plugin", "scale", "vision", "code", "data", "name", "ver", "option", "channel", "current", "type", "package", "public", "available", "match", "release", "secret", "val", "final", "format", "event", "up", "value", "Version", "length", "prefix", "remote", "update", "parent", "v", "latest", "patch", "url", "feature", "serial", "connection", "server", "section", "target"], "len": ["base", " n", " enc", "val", " max", "size", " count", "length", " bits", " lang", "seq", "Len", " lib", " avail", " clen", " encoding", " cur", " length"], "local": ["custom", "global", "small", "where", "child", "data", "base", "full", "shared", "buffer", "Local", "result", "we", "current", "match", "public", "loc", "localhost", "raw", "joined", "active", "self", "copy", "home", "other", "l", "same", "val", "final", "empty", "location", "old", "new", "build", "partial", "up", "initial", "back", "prefix", "standard", " locals", "remote", "client", "update", "parent", "private", "temp", "latest", "post", "binary", "total", "cache", "lock", "http", "missing", "serial", "a", "parts", "state", "valid", "lang", "server", "el"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027, "substitutes": {"base": ["pc", "status", "m", "bi", "scale", "db", "info", "x", "core", "name", "Base", "ases", "ix", "f", "buffer", "net", "r", "i", "root", "type", "cp", "ii", "padding", "sea", "scope", "index", "ba", "ip", "home", "gb", "space", "size", "bf", "pre", "kit", "site", "prefix", "id", "config", "start", "e", "bas", "q", "v", "temp", "c", "si", "p", "address", "ada", "area", "b", "cache", "null", "total", "resource", "pad", "ace", "a", "ase", "addr", "state", "py", "frame", "server", "ased", "os"], "env": ["status", "enable", "m", "viron", "init", "db", "conf", "f", "settings", "net", "eu", "r", "n", "exc", "z", "np", "oa", "environment", "ctx", "scope", "manager", "en", "energy", "enc", "context", "nc", "path", "network", "w", "config", "ex", "ev", "e", "zone", "ey", "ses", "v", "c", "ea", "p", "cache", "sche", "ec", "h", "er", "es", "state", "end", "py", "eni", "conn"], "s": ["ns", "spec", "settings", "series", "service", "ss", "cs", "d", "secure", "sh", "socket", "qs", "sym", "p", "ks", "us", "sets", "m", "ts", "sg", "init", "sis", "rs", "o", "sk", "su", "v", "si", "S", "ds", "f", "r", "sb", "sing", "l", "w", "q", "vs", "sync", "c", "ps", "b", "sys", "es", "state", "states", "sq", "sf", "session", "t", "conf", "services", "n", "g", "i", "sl", "z", "ls", "fs", "en", "is", "sites", "site", "e", "ssl", "ses", "js", "http", "gs", "storage", "its", "os", "se", "south", "y", "u"], "iomemtype": ["iomademweight", "iomempy", "iasmemweight", "iomigType", "iomembtypes", "iomemstyle", "iomemType", "iasmademstyle", "iomimertype", "iomigcolor", "iasmemtypes", "iomigtype", "igmeltypes", "igmemtypes", "iomemertype", "iomembweight", "iomexcolor", "iomeltypes", "iomemcolor", "iomimerstyle", "iasmademtypes", "igmemlike", "pixeligpy", "igmemsize", "igmemtype", "iomEMtype", "iomemerlike", "pixelempy", "pixeligtype", "iomigpy", "pixelemType", "igmeltype", "iasmemtype", "iomemsize", "igmelsize", "iomEMcolor", "iomemersize", "iomemweight", "iomeltype", "iasmademweight", "pixelemcolor", "iomEMType", "iomemlike", "iomellike", "iomexpy", "iomademstyle", "iomimersize", "iomembtype", "iomelsize", "iomimerlike", "iomimerweight", "iomimertypes", "iomEMpy", "igmellike", "iasmemstyle", "iasmademtype", "iomembstyle", "iomademtypes", "pixelemtype", "iomextype", "iomexType", "iomemtypes", "iomademtype", "pixeligType", "iomemertypes", "pixeligcolor"], "qi": ["shi", "wei", "ei", "bi", "qua", "agi", " q", " bi", " Qi", "jp", "ai", "fi", "cf", "dq", "i", "query", "gui", "ii", "quad", "ctx", "iu", "di", "pai", "fen", "zi", "chi", " iii", "yi", "iq", "ahi", "ci", "qs", "q", "qt", "cli", "iaz", "ni", "qq", "si", "qa", "p", "sci", "mu", "iana", "ace", " ii", "cgi", "eni", "sq", "esi", "li", "cci"]}}
{"project": "FFmpeg", "commit_id": "74b1bf632f125a795e66e5fd0a060b9c7c55b7a3", "target": 1, "func": "static int mp_decode_frame(MPADecodeContext *s, OUT_INT **samples,\n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    int i, nb_frames, ch, ret;\n\n    OUT_INT *samples_ptr;\n\n\n\n    init_get_bits(&s->gb, buf + HEADER_SIZE, (buf_size - HEADER_SIZE) * 8);\n\n\n\n    /* skip error protection field */\n\n    if (s->error_protection)\n\n        skip_bits(&s->gb, 16);\n\n\n\n    switch(s->layer) {\n\n    case 1:\n\n        s->avctx->frame_size = 384;\n\n        nb_frames = mp_decode_layer1(s);\n\n        break;\n\n    case 2:\n\n        s->avctx->frame_size = 1152;\n\n        nb_frames = mp_decode_layer2(s);\n\n        break;\n\n    case 3:\n\n        s->avctx->frame_size = s->lsf ? 576 : 1152;\n\n    default:\n\n        nb_frames = mp_decode_layer3(s);\n\n\n\n        if (nb_frames < 0)\n\n            return nb_frames;\n\n\n\n        s->last_buf_size=0;\n\n        if (s->in_gb.buffer) {\n\n            align_get_bits(&s->gb);\n\n            i = get_bits_left(&s->gb)>>3;\n\n            if (i >= 0 && i <= BACKSTEP_SIZE) {\n\n                memmove(s->last_buf, s->gb.buffer + (get_bits_count(&s->gb)>>3), i);\n\n                s->last_buf_size=i;\n\n            } else\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid old backstep %d\\n\", i);\n\n            s->gb           = s->in_gb;\n\n            s->in_gb.buffer = NULL;\n\n        }\n\n\n\n        align_get_bits(&s->gb);\n\n        assert((get_bits_count(&s->gb) & 7) == 0);\n\n        i = get_bits_left(&s->gb) >> 3;\n\n\n\n        if (i < 0 || i > BACKSTEP_SIZE || nb_frames < 0) {\n\n            if (i < 0)\n\n                av_log(s->avctx, AV_LOG_ERROR, \"invalid new backstep %d\\n\", i);\n\n            i = FFMIN(BACKSTEP_SIZE, buf_size - HEADER_SIZE);\n\n        }\n\n        assert(i <= buf_size - HEADER_SIZE && i >= 0);\n\n        memcpy(s->last_buf + s->last_buf_size, s->gb.buffer + buf_size - HEADER_SIZE - i, i);\n\n        s->last_buf_size += i;\n\n    }\n\n\n\n    /* get output buffer */\n\n    if (!samples) {\n\n        av_assert0(s->frame != NULL);\n\n        s->frame->nb_samples = s->avctx->frame_size;\n\n        if ((ret = ff_get_buffer(s->avctx, s->frame, 0)) < 0) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n            return ret;\n\n        }\n\n        samples = (OUT_INT **)s->frame->extended_data;\n\n    }\n\n\n\n    /* apply the synthesis filter */\n\n    for (ch = 0; ch < s->nb_channels; ch++) {\n\n        int sample_stride;\n\n        if (s->avctx->sample_fmt == OUT_FMT_P) {\n\n            samples_ptr   = samples[ch];\n\n            sample_stride = 1;\n\n        } else {\n\n            samples_ptr   = samples[0] + ch;\n\n            sample_stride = s->nb_channels;\n\n        }\n\n        for (i = 0; i < nb_frames; i++) {\n\n            RENAME(ff_mpa_synth_filter)(&s->mpadsp, s->synth_buf[ch],\n\n                                        &(s->synth_buf_offset[ch]),\n\n                                        RENAME(ff_mpa_synth_window),\n\n                                        &s->dither_state, samples_ptr,\n\n                                        sample_stride, s->sb_samples[ch][i]);\n\n            samples_ptr += 32 * sample_stride;\n\n        }\n\n    }\n\n\n\n    return nb_frames * 32 * sizeof(OUT_INT) * s->nb_channels;\n\n}\n", "idx": 19041, "substitutes": {"s": ["ns", "spec", "strings", "settings", "service", "six", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "ms", "m", "ts", "sg", "rs", "aws", "sim", "self", "o", "su", "side", "v", "si", "S", "single", "a", "hs", "an", "ds", "bs", "uns", "f", "sv", "r", "sb", "as", "sports", "l", "ins", "w", "bis", "serv", "vs", "sync", "c", "ps", "b", "sys", "your", "er", "es", "sq", "sf", "session", "t", "request", "conf", "stats", "services", "n", "g", "ls", "ops", "fs", "xs", "is", "css", "site", "e", "ssl", "ses", "js", "support", "gs", "os", "se", "south", "server"], "samples": ["sacks", "samps", " samps", "slamples", "slacks", "sample", " sacks", " sample", "slample", "slamps"], "buf": ["ab", "br", "ff", "data", "pool", "buffer", "rc", "vec", "feed", "num", "window", "sb", "cf", "cb", "block", "bc", "src", "max", "pb", "ptr", "count", "xff", "gb", "tc", "queue", "config", "length", "fd", "buff", "batch", "fb", "cur", "c", "rb", "seq", "uc", "off", "b", "alloc", "port", "uf", "cv", "len"], "buf_size": ["buf_eni", " buf_count", "bufjsize", "uber_desc", "uber_start", "uber_rate", "uber_size", "src_size", "bufjrate", "bufjstart", "buf0size", "bufjdesc", "buf_rate", "buf_start", " buf_\n", "buf1size", "buf1rate", "src_eni", " buf_SIZE", "buf0SIZE", "buf_\n", "buf_ize", "src_SIZE", "buf1start", "buf_SIZE", "buf_desc", "buf1desc", "buf0count", "src_ize", "buf_count"], "i": ["ti", "gi", "uri", "bi", "j", "t", "info", "x", "f", "ix", "ini", "qi", "ai", "io", "n", "mi", "phi", "hi", "type", "z", "ii", "in", "ie", "di", "index", "ind", "pos", "I", "mini", "iu", "zi", "count", "multi", "slice", "ip", "chi", "l", "adi", "d", "yi", "pi", "ui", "ci", "length", "id", "start", "e", "v", "cli", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "mu", "anti", "it", "eni", "fi", "y", "li", "ori", "u"], "nb_frames": ["ni_images", "ni_planes", "rb_bits", "nb_frame", "nb48values", "nb_bits", "nbNfeatures", "nb___images", "num_frames", "nb___rows", "nbNflows", "num_flows", "NB_tracks", "nb7cycles", "nb7images", "NB_weights", "nb67images", "rbJframes", "nb00bits", "nb7frames", "nb_cycles", "ni_frames", "num_images", "nbJbits", "nb67frames", "nb48classes", "rbJfeatures", "NB_values", "nb7planes", "nn_rows", "nb__frames", "nb___pages", "nbNframes", "rbJpages", "nbJpages", "NB48frames", "rbJbits", "nbJclasses", "rb_features", "nb_weights", "nb___bits", "nn_frames", "nb48tracks", "ni_cycles", "nbJfeatures", "nb_planes", "nb48weights", "nb00frames", "nb00events", "nb48frames", "nb00cycles", "nbJframes", "nb___frames", "nb00rows", "NB_frames", "nbJvalues", "nb67weights", "nb_images", "nb00images", "nn_events", "cb_bits", "nb__flows", "cb_frames", "nbxbits", "nb__images", "NB48values", "nb_pages", "nb___features", "nb_tracks", "NB48classes", "nb_rows", "NB_images", "nbxpages", "nb00planes", "nb___planes", "nbJimages", "nb00frame", "nbxfeatures", "NB48images", "nn_planes", "nb___events", "nb_values", "cb_frame", "nb_features", "rb_pages", "nb00games", "cb_games", "nb67tracks", "num_features", "nb_flows", "nb__features", "nb48images", "nb_classes", "nb___classes", "NB_classes", "rb_frames", "nb_games", "nb_events", "nb___values", "nbxframes", "nbNimages"], "ch": ["code", "ff", "conf", "err", "f", "info", "rc", "r", "channel", "cb", "bc", "done", "ry", "enc", "batch", "cur", "chan", "c", "bg", "seq", "col", "h", "res", "row", "fi", "conn"], "ret": ["rc", "nt", "result", "num", "cb", "bc", "fin", "sec", "mem", "def", "en", "enc", "val", "re", "aux", "back", "sil", "bis", "cur", "seq", "res", "flags", "prot", "fi", "len"], "samples_ptr": ["samples_port", "samples_addr", "sample_size", "sample_addr", "sample_ptr", "sample_port", "samples_size"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static InetSocketAddress *ssh_config(QDict *options, Error **errp)\n\n{\n\n    InetSocketAddress *inet = NULL;\n\n    QDict *addr = NULL;\n\n    QObject *crumpled_addr = NULL;\n\n    Visitor *iv = NULL;\n\n    Error *local_error = NULL;\n\n\n\n    qdict_extract_subqdict(options, &addr, \"server.\");\n\n    if (!qdict_size(addr)) {\n\n        error_setg(errp, \"SSH server address missing\");\n\n        goto out;\n\n    }\n\n\n\n    crumpled_addr = qdict_crumple(addr, errp);\n\n    if (!crumpled_addr) {\n\n        goto out;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n    iv = qobject_input_visitor_new(crumpled_addr);\n\n    visit_type_InetSocketAddress(iv, NULL, &inet, &local_error);\n\n    if (local_error) {\n\n        error_propagate(errp, local_error);\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    QDECREF(addr);\n\n    qobject_decref(crumpled_addr);\n\n    visit_free(iv);\n\n    return inet;\n\n}", "idx": 19075, "substitutes": {"options": ["ts", "info", "optional", "settings", "op", "ions", "results", "io", "details", "option", "objects", "cho", "ips", "points", "resources", "ops", "pos", "env", "o", "linux", "offs", "args", "config", "lib", "xml", "http", "opt", "os", "Options", "flags", "opens", "mac", "ors", "eps", "params"], "errp": ["errpi", " errP", " errpa", "err", "errP", " erP", "errpr", "rrr", "errpc", " errpr", "erps", " errpi", "erf", " erf", "erp", "asterpa", " errb", " erp", "aerpa", "errr", "errpa", " errr", "rrp", "aerpr", " erpc", "errb", "asterpr", "rrpi", "asterb", " erpi", "errps", "rrps", "erP", "aerb", " errps", "asterp", " errf", "rrP", " errpc", "errf", "aerp", " err", "rrpc"], "inet": ["inel", "obj", "eth", "prot", "net", "nt", "ne", "rt", "ether", "i", "ips", "loc", "dt", "ipt", "ctx", "ind", "encrypted", "ip", "host", "tz", "liv", "oi", "nil", "iot", "oid", "socket", "config", "prefix", "rn", "hole", "ssl", "qt", "ant", "ets", "elt", "ni", "unit", "ea", "binary", "address", "iterator", "adr", "route", "interface", "ec", "et", "connection", "eni", "el", "pton", "target"], "addr": ["rx", "offer", "part", "dd", "code", "data", "rs", "alt", "eth", "rc", "ord", "rt", "airs", "ast", "oa", "node", "adder", "src", "loc", "ext", "acl", "actor", "wd", "env", "act", "arr", "setup", "enc", "host", "ack", "pair", "ip", "layer", "array", "pkg", "size", "args", "acks", "config", "prefix", "ad", "dr", "xxx", "buf", "ars", "ea", "afi", "p", "url", "address", "xml", "kt", "od", "adr", "route", "error", "opt", "ace", "number", "amd", "mac", "server", "addons", "order", "attr", "params", "amp", "len"], "crumpled_addr": ["crumpled67address", "crumpled67addr", "crumpered__dr", "crumpled_pointer", "crumpled_dr", "crumpled_address", "crumpered__host", "crumpled___dr", "crumpled___addr", "crumpled_layer", "crumpled__address", "crumpled__dr", "crumpped_host", "crumpled__addr", "crumpled__layer", "crumpled_host", "crumpered_address", "crumpered_addr", "crumpered_pointer", "crumpled67message", "crumpered_host", "crumpered__addr", "crumpered_message", "crumpled_message", "crumpered_layer", "crumpled__host", "crumpped_address", "crumpered__address", "crumpped_addr", "crumpled___address", "crumpled67host", "crumpled___pointer", "crumpered_dr"], "iv": ["oc", "ik", "ivo", "irc", "vc", "ith", "rc", "io", "iva", "i", "anc", "ou", "loc", "erv", "ii", "iw", "actor", "Iv", "ind", "vi", "act", "opp", "ip", "IV", "exec", "enc", "uv", "hw", "liv", "oi", "iq", "av", "oid", "ipl", "ig", "ci", "ev", "il", "ov", "iver", "v", "ih", "ir", "ive", "adr", "ec", "iov", "riv", "iter", "eni", "it", "iri", "ib", "voc"], "local_error": ["localingror", " local_type", " local_grade", "localacaddress", "localamerr", "standard_danger", "localamror", "localamdanger", "local_bug", "standard_error", "local_key", "standard_err", " local_address", "local_err", "local_danger", "localingaddress", "localingerror", " local_ror", "localabletype", "localableerr", "localamerror", "standardamerr", " local_err", "local_ror", "localinggrade", "localacror", "standardamror", "standardamdanger", "standardamerror", "standard_ror", "localacerror", " local_key", "local_address", " local_bug", "localableerror", "localacgrade", "localablekey", "local_type", "local_grade"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "sdhci_buff_access_is_sequential(SDHCIState *s, unsigned byte_num)\n\n{\n\n    if ((s->data_count & 0x3) != byte_num) {\n\n        ERRPRINT(\"Non-sequential access to Buffer Data Port register\"\n\n                \"is prohibited\\n\");\n\n        return false;\n\n    }\n\n    return true;\n\n}\n", "idx": 19082, "substitutes": {}}
{"project": "qemu", "commit_id": "d1fdf257d52822695f5ace6c586e059aa17d4b79", "target": 0, "func": "static int nbd_negotiate_write(QIOChannel *ioc, const void *buffer, size_t size)\n\n{\n\n    ssize_t ret;\n\n    guint watch;\n\n\n\n    assert(qemu_in_coroutine());\n\n    /* Negotiation are always in main loop. */\n\n    watch = qio_channel_add_watch(ioc,\n\n                                  G_IO_OUT,\n\n                                  nbd_negotiate_continue,\n\n                                  qemu_coroutine_self(),\n\n                                  NULL);\n\n    ret = write_sync(ioc, buffer, size, NULL);\n\n    g_source_remove(watch);\n\n    return ret;\n\n}\n", "idx": 19090, "substitutes": {"ioc": ["aioci", "icocl", "ioid", "sioci", "ciocon", "iocon", "ciocl", "icoc", "iniocation", "abios", "icOC", "aioc", "iniocon", "uocl", "iocation", "iog", "iooc", "uoc", "ciocation", "icoid", "xiocl", "siog", "inioc", "abiog", "cioc", "sios", "iOC", "ioOC", "sioc", "aios", "iniocl", "abioc", "iooid", "uoid", "xiocon", "xiocation", "xioc", "aiog", "uOC", "iocl", "ioocl", "ioci", "abioci"], "buffer": ["Buffer", "capacity", "shape", "data", "fp", "base", "pool", "input", "window", "channel", "FFER", "block", "reference", "slice", "ptr", "layer", "header", "array", "read", "uffer", "length", "queue", "buff", "buf", "batch", "address", "cache", "b", "message", "iter", "server", "writer", "source", "transfer", "reader"], "size": ["scale", "content", "offset", "s", "capacity", "code", "small", "shape", "SIZE", "name", "time", "gc", "g", "max", "sec", "timeout", "en", "speed", "empty", "large", "sn", "ize", "length", "send", "sync", "c", "si", "address", "fee", "sum", "storage", "export", "weight", "Size", "len"], "ret": [" reply", "data", "wrap", "base", "alt", "rc", "gc", "fun", "rt", "result", "str", "wait", "sb", "match", "ext", "mem", "timeout", "resp", "def", "lv", "get", "arg", "exec", "att", "arr", "val", "re", "Ret", " result", "std", "read", "value", "ig", "_", "temp", "rl", "RET", "wa", "res", "live", "addr", "py", "iter", "fi", "reply", "success", "len"], "watch": ["push", "tt", "war", "work", "skip", "t", "wx", "x", "err", "wrap", "ct", "full", "call", "comment", "Watch", "rc", "service", "ann", "result", "wait", "worker", "g", "sw", "block", "app", "lv", "copy", "warn", "store", "change", "event", "W", "w", "guard", "serv", "batch", "sync", "par", "temp", "lc", "cat", "patch", "can", "cache", "lock", "aw", "wa", "clock", "live", "server", "writer", "scan", "sleep", "bug"]}}
{"project": "qemu", "commit_id": "031380d8770d2df6c386e4aeabd412007d3ebd54", "target": 0, "func": "static void aio_read_done(void *opaque, int ret)\n\n{\n\n    struct aio_ctx *ctx = opaque;\n\n    struct timeval t2;\n\n\n\n    gettimeofday(&t2, NULL);\n\n\n\n    if (ret < 0) {\n\n        printf(\"readv failed: %s\\n\", strerror(-ret));\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->Pflag) {\n\n        void *cmp_buf = malloc(ctx->qiov.size);\n\n\n\n        memset(cmp_buf, ctx->pattern, ctx->qiov.size);\n\n        if (memcmp(ctx->buf, cmp_buf, ctx->qiov.size)) {\n\n            printf(\"Pattern verification failed at offset %\"\n\n                   PRId64 \", %zd bytes\\n\", ctx->offset, ctx->qiov.size);\n\n        }\n\n        free(cmp_buf);\n\n    }\n\n\n\n    if (ctx->qflag) {\n\n        goto out;\n\n    }\n\n\n\n    if (ctx->vflag) {\n\n        dump_buffer(ctx->buf, ctx->offset, ctx->qiov.size);\n\n    }\n\n\n\n    /* Finally, report back -- -C gives a parsable format */\n\n    t2 = tsub(t2, ctx->t1);\n\n    print_report(\"read\", &t2, ctx->offset, ctx->qiov.size,\n\n                 ctx->qiov.size, 1, ctx->Cflag);\n\nout:\n\n    qemu_io_free(ctx->buf);\n\n    free(ctx);\n\n}\n", "idx": 19102, "substitutes": {"opaque": ["ocacity", "opsacity", " opacity", "opsaca", "ocaques", "ip666", "opacity", "osp666", "opaca", "placity", "plaques", " opaca", "op666", "ocaca", "pl666", "ospacity", "opsaques", "ipacity", "ocaque", "ipaques", "ipaque", "ospaques", "opaques", "plaque", "opsaque", "ospaque", " opaques"], "ret": ["sur", "t", "x", "bit", "ref", "alt", "rc", "nt", "lit", "reg", "rt", "fun", "result", "num", "ext", "fin", "sec", "mem", "rets", "arg", "att", "val", "re", "Ret", "no", "xt", "back", "rot", "id", "det", "sr", "rev", "cur", "cat", " Ret", "pret", "RET", "gt", "inter", "pat", "red", "rep", "res", "mt", "ft", "desc", "reply", "len"], "ctx": ["grad", "cfg", "obj", "cf", "anc", "six", "gru", " context", "cas", "exec", "tx", "xc", "config", "prefix", "cu", "general", "qt", "cli", "qq", "lib", "alloc", "command", "cv", "conn", "cc", "rx", "wx", "cca", "ctr", "cus", "cm", "cp", "bc", "wcs", "scope", "kw", "hw", "sc", "lc", "parent", "unc", "connection", "cgi", "wp", "fw", "fp", "jp", "component", "cb", "loc", "utils", "git", "ctrl", "crit", "ca", "kb", "ci", "sync", "c", "qa", "sci", "sys", "cn", "sq", "np", "gc", "exc", "fc", "css", "context", "conv", "ce", "pkg", "nc", "tc", "client", "cl", "req", "chan", "cmd", "que", "cmp"], "t2": ["tii", "temp2", "T2", " t3", "t0", " t4", "dt2", " t02", " t1", "T0", "p0", "p2", "TTwo", "temp1", "f3", "ta2", "dt02", "t4", "tatwo", "f2", "dtii", "temp3", " tTwo", "ta0", "f1", "ttwo", "t02", "dt4", "dt1", "tTwo", "T3", "t1", "T1", "ta1", "ptwo", "f4", "tempTwo", "Tii", "T02", "T4", "p1", " tii", "t3", "Ttwo"], "cmp_buf": ["cp_buffer", "cmp2buffer", "comp_alloc", "cmp_cb", "cmpingbuffer", "cp_buff", "mp_cb", "cmp2buf", "cmp2buff", "cmp_alloc", "mp_buffer", "cmpingalloc", "cp_cb", "cmp_uf", "cmp2cb", "mp_uf", "cmpingrc", "cmp_rc", "cp_buf", "comp_buf", "cmp_buffer", "mp_buff", "cmpingbuf", "comp_rc", "cmp_buff", "comp_buffer", "mp_buf"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_read_tbu (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_load_tbu(cpu_gpr[gprn], cpu_env);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 19108, "substitutes": {"ctx": ["cc", "txt", "fp", "obj", "cca", "vc", "rc", "cm", "cpu", "cpp", "anc", "cp", "src", "loc", "bc", "cas", "Context", "ca", "exec", "context", "pkg", "tx", "ci", "tc", "gpu", "config", "xc", "sc", "cu", "cam", "client", "sync", "lc", "c", "parent", "cli", "qa", "cmd", "cmp", "connection", "cgi", "cv", "conn", "cci"], "gprn": ["gsprn", " gptb", " gPrN", " gPrns", "gsprns", "gprb", "gptb", "gPrns", "gPRne", "gbrp", " gptp", " gprp", "gPrp", "gsprN", " gptn", "gptp", "gprp", "gbrn", "gPRb", "gprne", "gPRn", "gprns", "gPrN", " gprN", " gprne", "gbrb", " gprns", "gPRp", "gprN", "gPrn", "gbrne", "gsprp", " gprb", "gptn", " gPrn", " gPrp", " gptne", "gptne"], "sprn": ["sprN", " sprN", "prN", "prname", "prn", " prb", " prn", "sprname", " prN", "sprb", " prname", " sprname", " sprb", "prb"]}}
{"project": "qemu", "commit_id": "732b530c1bd064bdcc29975c0b78fc6de8c47e7f", "target": 0, "func": "static void nvdimm_build_common_dsm(Aml *dev)\n\n{\n\n    Aml *method, *ifctx, *function, *dsm_mem, *unpatched, *result_size;\n\n    uint8_t byte_list[1];\n\n\n\n    method = aml_method(NVDIMM_COMMON_DSM, 4, AML_SERIALIZED);\n\n    function = aml_arg(2);\n\n    dsm_mem = aml_name(NVDIMM_ACPI_MEM_ADDR);\n\n\n\n    /*\n\n     * do not support any method if DSM memory address has not been\n\n     * patched.\n\n     */\n\n    unpatched = aml_if(aml_equal(dsm_mem, aml_int(0x0)));\n\n\n\n    /*\n\n     * function 0 is called to inquire what functions are supported by\n\n     * OSPM\n\n     */\n\n    ifctx = aml_if(aml_equal(function, aml_int(0)));\n\n    byte_list[0] = 0 /* No function Supported */;\n\n    aml_append(ifctx, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(unpatched, ifctx);\n\n\n\n    /* No function is supported yet. */\n\n    byte_list[0] = 1 /* Not Supported */;\n\n    aml_append(unpatched, aml_return(aml_buffer(1, byte_list)));\n\n    aml_append(method, unpatched);\n\n\n\n    /*\n\n     * The HDLE indicates the DSM function is issued from which device,\n\n     * it is not used at this time as no function is supported yet.\n\n     * Currently we make it always be 0 for all the devices and will set\n\n     * the appropriate value once real function is implemented.\n\n     */\n\n    aml_append(method, aml_store(aml_int(0x0), aml_name(\"HDLE\")));\n\n    aml_append(method, aml_store(aml_arg(1), aml_name(\"REVS\")));\n\n    aml_append(method, aml_store(aml_arg(2), aml_name(\"FUNC\")));\n\n\n\n    /*\n\n     * tell QEMU about the real address of DSM memory, then QEMU\n\n     * gets the control and fills the result in DSM memory.\n\n     */\n\n    aml_append(method, aml_store(dsm_mem, aml_name(\"NTFI\")));\n\n\n\n    result_size = aml_local(1);\n\n    aml_append(method, aml_store(aml_name(\"RLEN\"), result_size));\n\n    aml_append(method, aml_store(aml_shiftleft(result_size, aml_int(3)),\n\n                                 result_size));\n\n    aml_append(method, aml_create_field(aml_name(\"ODAT\"), aml_int(0),\n\n                                        result_size, \"OBUF\"));\n\n    aml_append(method, aml_concatenate(aml_buffer(0, NULL), aml_name(\"OBUF\"),\n\n                                       aml_arg(6)));\n\n    aml_append(method, aml_return(aml_arg(6)));\n\n    aml_append(dev, method);\n\n}\n", "idx": 19115, "substitutes": {"dev": ["instance", "gram", "global", "data", "call", "comment", "library", "loader", "module", "block", "app", "package", "var", "model", " self", "def", "exec", "ev", "private", "device", "lambda", "lib", "ram", "param", "amd", "env", "attr"], "method": ["user", "full", "comment", "true", "op", "result", "java", "region", "package", "effect", "length", "math", "send", "feature", "resource", "h", "plugin", "m", "name", "sort", "document", "self", "object", "class", "update", "cell", "Method", "operation", "expression", "util", "process", "instance", "text", "view", "call", "block", "type", "rh", "orig", "python", "model", "array", "position", "history", "modified", "fn", "wrapper", "value", "each", "session", "record", "func", "mode", "option", "um", "module", "public", "pass", "slice", "member", "METHOD", "build", "event", "use", "pull", "man", "cl", "form", "sign", "api", "message", "callback"], "ifctx": ["IFctx", "ipcontext", "tifcu", "Ifcb", "tifctx", "ipctx", "ifqa", "ifcb", "ipcu", " ifcontext", "afcontext", "ipqa", "afctx", "IFcontext", "Ifcontext", "afcb", "afconfig", " ifcb", " ifconfig", "Ifconfig", " ifcu", "Ifctx", "tifqa", "ifcontext", " ifqa", "ifcu", "tifcontext", "ifconfig", "IFcb", "IFconfig"], "function": ["program", "process", "code", "func", "f", "call", "name", "action", "service", "library", "fun", "family", "option", "document", "module", "region", "package", "loc", "normal", "functional", "self", "object", "range", "array", "new", "value", "length", "handler", "parent", "unit", "lambda", "feature", "Function", "resource", "fn", "interface", "number", "connection", "callback", "command", "operation", "section", "version"], "dsm_mem": ["dsm__memory", "dvm_lim", "dmi___min", "dsm_hw", "dsm___min", "dcm_ram", "dsm_min", "dsm__mode", "dsm___hw", "dsm_Mem", "dcm_mem", "dsm_ref", "dsm_arm", "dmi_arm", "dcm__memory", "dcm__ram", "dsm_ram", "dmi_hw", "dsm_mode", "dsm___arm", "dsm_mm", "dvm_ref", "dmi___mem", "dsm_num", "dsm_memory", "dvm_Mem", "dvm_mem", "dcm_memory", "dcm__mem", "dsm__mem", "dsm_lim", "dsm___mem", "dvm_mm", "dmi___arm", "dmi_min", "dvm_ram", "dmi_mem", "dmi___hw", "dcm_mode", "dsm__ram", "dcm__mode", "dvm_num"], "unpatched": ["unliched", " unpatced", "unapatched", "unPathed", "unpached", "unapathed", "UnPatched", "unmatched", "unapatced", "unpatected", "unmatced", "synpathed", "unbatced", "synpached", " unpatured", "unlicched", "Unpathed", "synpatche", " unmatured", " unpatected", "synpache", "uncatches", "synpaced", "unpaches", "unfethed", "unpatches", "unlicche", "uncatched", "uncathed", "synpahed", "Unbatches", "unfetced", "unpathed", "unlicced", "unfetched", "unpitched", "unpache", "unafetced", "unbatured", "unatthed", "unmatected", "unmatured", "Unpatced", "unafetured", "Unpatcher", "unattced", "unafetched", "unbathed", "unfetured", "UnPathed", "Unbatced", " unmatected", " unmatced", "unapatured", "unpitured", "uncatcher", "unbatche", "unpatcher", "unPatches", "Unpatches", "unbatched", "unpaced", "unbatches", "Unbatched", "unbatcher", "unpitected", " unmatched", "unpatche", "unattched", "synpatced", "unfetected", "unpahed", "UnPatcher", "UnPatches", "synpatched", "uncatced", "Unbathed", "unpatured", "unPatched", "Unpatched", "unPatcher", "unpitced", "unattured", "unafethed", "unpatced"], "result_size": ["result_sum", "resultlexrate", "order_shape", " result_Size", "result_shape", " result_speed", "response_color", "resultlexname", "result_len", "memory_size", "result64number", "resultlexspeed", "result_rate", "response_sized", "response_time", "result64loss", "order_size", " result_rate", "order64loss", "result_scale", "resultlexsize", "result_speed", "order64shape", "result64speed", "result64name", "order64size", "memory64number", "result_name", " result_name", "result64size", "order64capacity", "result_weight", " result_format", "response_sum", "response_scale", "result64capacity", "order_loss", "memory64data", "memory_len", "result64shape", "result_sized", "result_color", "result_time", "result64rate", "result_capacity", "memory64len", " result_address", "result_loss", "result_data", "result_format", "memory64size", "memory_number", "result64data", "response_weight", "order_capacity", "response_size", "result_address", "memory_data", "result_number", "result_Size", "result64len"], "byte_list": ["byte2set", "character_range", "byte9size", "byteerList", "byte2size", "member_set", "memberenset", "byte_stack", "slice_name", "byteetname", "byteerpair", "sliceetname", "memberentest", "byte9test", "byte_pair", "byteetpart", "byteablelist", "byteerlist", "byte_part", "byte_batch", "member_size", "byte_lists", "byteablemap", "character_member", "member_list", "sliceetlist", "byte_name", "byteablerange", "byteetlist", "byteablebatch", "sliceetset", "memberenlist", "byteensize", "character_list", "byteetlists", " byte_batch", "member_test", "byteetpair", "byteetset", "slice_list", " byte_lists", "byte_map", "memberensize", "byte9set", "slice_set", " byte_List", "slice_part", "byteentest", " byte_map", "byteenset", "character_stack", "byte2test", " byte_range", "byteenlist", " byte_pair", "byte_size", "byte_member", "byte_List", "byte_range", "byteetList", "byte2list", "byteerlists", "byte_set", "sliceetpart", "byte9list", "byte_test"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static gnutls_anon_server_credentials vnc_tls_initialize_anon_cred(void)\n\n{\n\n    gnutls_anon_server_credentials anon_cred;\n\n    int ret;\n\n\n\n    if ((ret = gnutls_anon_allocate_server_credentials(&anon_cred)) < 0) {\n\n\tVNC_DEBUG(\"Cannot allocate credentials %s\\n\", gnutls_strerror(ret));\n\n\treturn NULL;\n\n    }\n\n\n\n    gnutls_anon_set_server_dh_params(anon_cred, dh_params);\n\n\n\n    return anon_cred;\n\n}\n", "idx": 19116, "substitutes": {"anon_cred": ["anon_fcred", "anon_configrib", "anon_configret", "anon_acredit", "anon_acid", "anon_Cred", "anon_credit", "anon_kred", "anon_acret", "anon_configredit", "anon_acld", "anon_Csp", "anon_kld", "anon_crypt", "anon_Cld", "anon_Crypt", "anon_Credits", "anon_acrypt", "anon_acsp", "anon_ksp", "anon_scred", "anon_csp", "anon_acrib", "anon_acred", "anon_configred", "anon_ctrib", "anon_cld", "anon_scredits", "anon_ctredit", "anon_fcid", "anon_fcld", "anon_Cid", "anon_acredits", "anon_krib", "anon_credits", "anon_fcredits", "anon_cid", "anon_scrypt", "anon_ctred", "anon_crib", "anon_cret", "anon_ctret", "anon_scrib", "anon_Crib"], "ret": ["db", "code", "f", "ref", "alt", "rc", "nt", "ver", "reg", "rt", "fun", "lit", "result", "num", "job", "flag", "match", "ext", "sec", "mem", "resp", "rets", "en", "arg", "art", "bad", "val", "re", "Ret", "fail", "back", "id", "det", "cur", "req", "success", "lib", "gt", "RET", "pret", "red", "virt", "res", "mt", "end", "die", "conn", "len"]}}
{"project": "qemu", "commit_id": "a3f1afb43a09e4577571c044c48f2ba9e6e4ad06", "target": 0, "func": "static int zero_single_l2(BlockDriverState *bs, uint64_t offset,\n\n    unsigned int nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l2_table;\n\n    int l2_index;\n\n    int ret;\n\n    int i;\n\n\n\n    ret = get_cluster_table(bs, offset, &l2_table, &l2_index);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* Limit nb_clusters to one L2 table */\n\n    nb_clusters = MIN(nb_clusters, s->l2_size - l2_index);\n\n\n\n    for (i = 0; i < nb_clusters; i++) {\n\n        uint64_t old_offset;\n\n\n\n        old_offset = be64_to_cpu(l2_table[l2_index + i]);\n\n\n\n        /* Update L2 entries */\n\n        qcow2_cache_entry_mark_dirty(bs, s->l2_table_cache, l2_table);\n\n        if (old_offset & QCOW_OFLAG_COMPRESSED) {\n\n            l2_table[l2_index + i] = cpu_to_be64(QCOW_OFLAG_ZERO);\n\n            qcow2_free_any_clusters(bs, old_offset, 1, QCOW2_DISCARD_REQUEST);\n\n        } else {\n\n            l2_table[l2_index + i] |= cpu_to_be64(QCOW_OFLAG_ZERO);\n\n        }\n\n    }\n\n\n\n    ret = qcow2_cache_put(bs, s->l2_table_cache, (void**) &l2_table);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return nb_clusters;\n\n}\n", "idx": 19119, "substitutes": {"bs": ["ns", "ms", "ros", "bi", "ts", "lbs", "fps", "ras", "base", "ob", "las", "plugins", "ubs", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "bid", "cs", "css", "gb", "bos", "ins", "bps", "obs", "outs", "ac", "BS", "iss", "abi", "bis", "bl", "vs", "bh", "ses", "fb", "js", "sync", "bas", "bits", "b", "gs", "ec", "es", "os", "bes", "banks", "us", "sa", "ds"], "offset": ["part", "data", "fp", "Offset", "base", "bit", "optional", "align", "reference", "utils", "padding", "index", "pos", "timeout", "pointer", "store", "location", "slot", "inet", "alias", "size", "seed", "initial", "reset", "prefix", "length", "start", "position", "slave", "off", "table", "address", "url", "alloc", "clock", "addr", " offsets", "len"], "nb_clusters": ["nb_blicas", "nb4clusters", "nb_ccocations", "nb_clores", "nb_clances", "nb_gluster", "nb_slores", "nb_clards", "nb_CLances", "nb_clroups", "nb4splocations", "nb_flocations", "nb_shusters", "nb_flusters", "nb_chards", "nb4splows", "nb_plusters", "nb_glicas", "nb_collows", "nb_splusters", "nb_plodes", "nb_clicas", "nb_nancers", "nb4clards", "nb_CLicas", "nb_conards", "nb_ccusters", "nb_ccards", "nb_glances", "nb_splocations", "nb_blubes", "nb_splows", "nb_clurs", "nb_chusters", "nb_clodes", "nb_clubes", "nb_shroups", "nb_plancers", "nb_shurs", "nb_nubes", "nb_nusters", "nb_CLows", "nb_cluster", "nb_bluster", "nb_glusters", "nb_slusters", "nb_clancers", "nb_conurs", "nb_conroups", "nb_clows", "nb4splards", "nb_flards", "nb4splusters", "nb_conusters", "nb4clocations", "nb_ccows", "nb_CLusters", "nb_clocations", "nb_collores", "nb_CLuster", "nb_blodes", "nb_slows", "nb4clows", "nb_collusters", "nb_shards", "nb_flows", "nb_CLores", "nb_colluster", "nb_chroups", "nb_blusters", "nb_churs", "nb_blancers", "nb_nodes", "nb_plubes", "nb_blances", "nb_splards", "nb_sluster"], "s": ["ns", "spec", "ts", "session", "t", "stats", "sv", "settings", "services", "service", "sie", "sb", "g", "sl", "ss", "ls", "is", "o", "cs", "su", "site", "bis", "e", "ssl", "ses", "sync", "js", "c", "ps", "si", "sym", "p", "S", "b", "gs", "sys", "storage", "a", "os", "state", "us", "se", "states", "server", "sa", "ds"], "l2_table": ["l2_result", "ltwo_tab", "l2_cache", "l1_body", "l2_comment", "ltwotresult", "ltwo_result", "l2__table", "l2ttab", "l2tinterface", "l2__cache", "l2_count", "l1_table", "l12_interface", "l2__body", "l2fquery", "l12_table", "l42amtable", "l2amcache", "l42amcache", "l2fresult", "l42_tab", "l42_table", "l4_list", "l2amtab", "l12ttable", "l42_module", "l12_result", "l2_tab", "ltwottab", "l2ftable", "l12tcache", "l4_result", "l42_cache", "l1_tree", "ltwo_table", "l2_interface", "l2tcache", "l2_body", "l2ttable", "l2tresult", "l2_tree", "l2amtable", "l12tinterface", "ltwo_query", "l2_query", "ltwottable", "l12tresult", "l2__tree", "l2tquery", "l1_count", "l1_cache", "l2_module", "l42amtab", "l2ammodule", "l2ftab", "l1_module", "l4_comment", "l1_chain", "l42ammodule", "l2_list", "ltwotquery", "l12_cache", "l2_chain", "l4_table", "l1_index"], "l2_index": ["l2_alias", "l2Eindex", "l1_size", "l2_lock", "l2Elock", "lto_size", "lto_action", "l2jalias", "l2Eshape", "l21Eindex", "l2_count", "ltwo_index", "l2_length", "l2_size", "l96_shape", "l2__style", "ltwojindex", "l96__shape", "l2__index", "l2__shape", "l96_index", "l21Edate", "l6_size", "l1_length", "ltwojoutput", "l6_index", "l2_style", "l6_position", "l2_output", "ltwo_output", "l96__style", "l21_lock", "l96_style", "ltwojalias", "l2_shape", "l2jindex", "l21_shape", "lto_index", "ltwojlock", "l2_action", "l2_pointer", "l1_count", "l21Elock", "ltwo_lock", "l6_pointer", "ltwo_alias", "l21Eshape", "l2joutput", "l2jlock", "l2_date", "lto_position", "l96__index", "l21_date", "l21_index", "l2Edate", "l1_index", "l2_position"], "ret": ["bit", "ref", "full", "nt", "result", "num", "run", "att", "reset", "id", "fit", "rev", "hard", "pat", "res", "mt", "conn", "len", "part", "j", "pub", "rc", "fun", "fin", "arg", "art", "Ret", "bf", "pre", "cat", " Ret", "gt", "RET", "ft", "iter", "f", "base", "err", "alt", "hash", "lit", "rt", "bad", "val", "re", "back", "post", "rl", "b", "reply", "success", "db", "info", "af", "reg", "flag", "pass", "ext", "active", "def", "rets", "en", "ber", "out", "complete", "fail", "det", "bot", "_", "error"], "i": ["gi", "ti", "uri", "bi", "m", "j", "init", "info", "x", "f", "ref", "base", "ix", "ini", "qi", "r", "ai", "mi", "n", "io", "current", "ii", "ie", "iu", "di", "index", "slice", "I", "multi", "en", "zi", "out", "is", "ip", "l", "d", "val", "oi", "yi", "pi", "ui", "reset", "ci", "abi", "id", "start", "e", "v", "ni", "c", "ki", "si", "ri", "p", "xi", "b", "mu", "uli", "u", "rep", "it", "eni", "fi", "y", "li", "len"], "old_offset": [" old_auto", "old__offset", "oldapppointer", "oldacauto", "old_object", "condappobject", "cond_object", "oldacaddress", " old_Offset", "oldacaddr", "old__attribute", "old__auto", "oldaclocation", "low_Offset", "low_offset", "old_addr", "old_auto", "old_Offset", "old_location", "oldappobject", "old__location", " old_index", "condappoffset", "old_attribute", "old_index", "oldappattribute", " old_error", "oldacOffset", "low_addr", "cond_offset", "old__object", "condapppointer", "cond_attribute", "oldacoffset", "cond_pointer", "old_pointer", "old_error", "old__pointer", "condappattribute", "low_address", " old_location", "old_address", "oldappoffset"]}}
{"project": "qemu", "commit_id": "67d5cd9722b230027d3d4267ae6069c5d8a65463", "target": 0, "func": "static AddressSpace *s390_pci_dma_iommu(PCIBus *bus, void *opaque, int devfn)\n\n{\n\n    S390pciState *s = opaque;\n\n\n\n    return &s->pbdev[PCI_SLOT(devfn)].as;\n\n}\n", "idx": 19126, "substitutes": {"bus": ["board", "plugin", "las", "cus", "usb", "engine", "io", "bridge", "Bus", "bc", "pos", "gate", "abi", "config", "bis", "mount", "buf", "driver", "plug", "cache", "BUS", "boot", "proc", "serial", "os", "us", "port"], "opaque": ["ospulence", "opride", "operacity", "iopaco", "uppride", "ophole", " opacity", "uppaco", "operhole", "iopc", " opaco", " opulence", "opacity", "osphole", "iopaque", "operaque", " opc", " ophole", "ospacity", "iopride", "operulence", "uppaque", "opulence", "opaco", " opride", "uppc", "ospaque", "opc"], "devfn": ["deffn", "devFN", "evfn", " devf", "DEVfn", " devfunction", " devFN", "Devfn", "deffee", "evf", "deffun", "devfunction", "defFN", "devfun", "devfee", "devf", "DevFN", "deff", "DEVFN", "evfunction", "evFN", "DEVfee", "DEVfun", "Devfun", "Devfee", "deffunction"], "s": ["m", "session", "f", "settings", "services", "r", "n", "g", "i", "sl", "ss", "ops", "scope", "o", "d", "socket", "e", "ssl", "sync", "v", "js", "c", "sym", "p", "secondary", "S", "address", "b", "http", "h", "php", "hs", "state", "states", "sq", "u"]}}
{"project": "qemu", "commit_id": "7b899f4dd596dbb7d271f7fab36fbfffec84868e", "target": 0, "func": "static void test_info_commands(void)\n\n{\n\n    char *resp, *info, *info_buf, *endp;\n\n\n\n    info_buf = info = hmp(\"help info\");\n\n\n\n    while (*info) {\n\n        /* Extract the info command, ignore parameters and description */\n\n        g_assert(strncmp(info, \"info \", 5) == 0);\n\n        endp = strchr(&info[5], ' ');\n\n        g_assert(endp != NULL);\n\n        *endp = '\\0';\n\n        /* Now run the info command */\n\n        if (verbose) {\n\n            fprintf(stderr, \"\\t%s\\n\", info);\n\n        }\n\n        resp = hmp(info);\n\n        g_free(resp);\n\n        /* And move forward to the next line */\n\n        info = strchr(endp + 1, '\\n');\n\n        if (!info) {\n\n            break;\n\n        }\n\n        info += 1;\n\n    }\n\n\n\n    g_free(info_buf);\n\n}\n", "idx": 19128, "substitutes": {"resp": ["rx", "gi", "html", "news", "part", "ret", "rr", "fr", "esp", "request", "data", "obj", "err", "ref", "jp", "json", "respond", "coord", "report", "result", "rh", "ctx", "Resp", "rec", "re", "comp", "response", "serv", "prev", "remote", "buff", "rev", "req", "seq", "ll", "Response", "cache", "http", "cmp", "error", "res", "proc", "api", "reply", "conn"], "info": ["offset", "extra", "obj", "ref", "comment", "op", "result", "show", "hi", "INFO", "zip", "rec", "iso", "found", "new", "pi", "no", "id", "buff", "afi", "p", "total", "aff", "end", "fi", "source", "quick", "part", "init", "work", "txt", "name", "app", "bb", "count", "parse", "inf", "handler", "open", "update", "si", "hand", "Info", "fw", "time", "f", "json", "type", "loc", "ii", "orig", "help", "fo", "close", "start", "qa", "information", "detail", "check", "py", "now", "bug", "where", "data", "conf", "i", "ok", "index", "slice", "is", "alias", "ignore", "about", "http", "error", "tf", "api", "php", "diff", "inner"], "info_buf": ["info2uf", "info_bytes", "inf_buffer", "info2buf", "infopybuf", "info__buf", "inf_done", "inf__buffer", " info_buffer", "info__buffer", "info_buffer", " info_box", "inf_uf", "info2done", "info__uf", "info_box", "inf__done", "info_done", "infopyuf", "infopybuffer", "inf_buf", "info_cb", " info_bytes", "infopydone", " info_cb", "inf__uf", "info_uf", "inf__buf", "info2buffer", "info__done"], "endp": ["Endi", "startr", "endedi", "endr", " endc", "adpoint", " endps", "endedP", " endpoint", "startP", "Endp", " endr", "endedpoint", "endedp", "endingps", "endingP", "endn", "startp", "endc", "endedn", "endingp", "endingi", "adi", "adP", "endps", "idP", "idi", "endP", "idp", "endpoint", "startpoint", "endedc", "endedr", "Endps", "adn", "idpoint", "EndP", " endi", " endn", "adp", "starti", "startc", "endi", " endP"]}}
{"project": "qemu", "commit_id": "eabb7b91b36b202b4dac2df2d59d698e3aff197a", "target": 0, "func": "static void tcg_out_mov(TCGContext *s, TCGType type, TCGReg ret, TCGReg arg)\n\n{\n\n    uint8_t *old_code_ptr = s->code_ptr;\n\n    assert(ret != arg);\n\n#if TCG_TARGET_REG_BITS == 32\n\n    tcg_out_op_t(s, INDEX_op_mov_i32);\n\n#else\n\n    tcg_out_op_t(s, INDEX_op_mov_i64);\n\n#endif\n\n    tcg_out_r(s, ret);\n\n    tcg_out_r(s, arg);\n\n    old_code_ptr[1] = s->code_ptr - old_code_ptr;\n\n}\n", "idx": 19129, "substitutes": {"s": ["ns", "spec", "m", "ts", "sg", "session", "t", "info", "x", "f", "services", "r", "ions", "service", "n", "sb", "g", "i", "ss", "src", "in", "ctx", "this", "scope", "fs", "sec", "self", "xs", "is", "o", "cs", "context", "d", "su", "new", "args", "site", "w", "e", "ssl", "ses", "sync", "v", "c", "js", "si", "p", "S", "b", "ks", "gs", "sys", "u", "a", "es", "os", "us", "se", "sq", "ds", "sf"], "type": ["types", "spec", " t", "t", "name", "f", "pe", "rel", "def", "enc", "class", "re", "Type", "path", "style", "sub", "id", "parent", "TYPE", "p", "ty", "py", "prot", "ype", " typ", "typ"], "ret": ["tr", "obj", "err", "ref", "f", "alt", "al", "reg", "rc", "rt", "fun", "rel", "result", "str", "ar", "flag", "match", "usr", "sel", "ext", "sec", "mem", "ry", "def", "rets", "arr", "att", "store", "val", "re", "Ret", "args", "sr", "rev", "RET", "inter", "sys", "res", "proc", "opt", "fi", "reply", "target"], "arg": ["grad", "rest", "err", "ref", "alt", "all", "rc", "reg", "debug", "ar", "result", "str", "g", "flag", "arm", "Arg", "orig", "ext", "sec", "tag", "arr", "enc", "arc", "rec", "val", "re", "Ret", "args", "ig", "ag", "cmd", "argument", "inter", "b", "param", "addr", "mac", "target"], "old_code_ptr": ["old_code\u00b7length", "old_code_ref", "old_codeJptr", "old_line_tr", "old_code2pointers", "old_line_pointer", "old_line_ptr", "old_code_pointers", "old_code_length", "old_call_rep", "old_code_pointer", "old_line_ref", "old_code2pointer", "old_codeJpointer", "old_code_tr", "old_code_rep", "old_codeJrep", "old_code\u00b7rep", "old_code_addr", "old_code\u00b7pointer", "old_call_ptr", "old_call_pointer", "old_code2addr", "old_code\u00b7ptr", "old_codeJlength", "old_code2ptr", "old_call_length"]}}
{"project": "qemu", "commit_id": "079d0b7f1eedcc634c371fe05b617fdc55c8b762", "target": 0, "func": "static int do_token_in(USBDevice *s, USBPacket *p)\n\n{\n\n    int request, value, index;\n\n    int ret = 0;\n\n\n\n    assert(p->devep == 0);\n\n\n\n    request = (s->setup_buf[0] << 8) | s->setup_buf[1];\n\n    value   = (s->setup_buf[3] << 8) | s->setup_buf[2];\n\n    index   = (s->setup_buf[5] << 8) | s->setup_buf[4];\n\n \n\n    switch(s->setup_state) {\n\n    case SETUP_STATE_ACK:\n\n        if (!(s->setup_buf[0] & USB_DIR_IN)) {\n\n            ret = usb_device_handle_control(s, p, request, value, index,\n\n                                            s->setup_len, s->data_buf);\n\n            if (ret == USB_RET_ASYNC) {\n\n                return USB_RET_ASYNC;\n\n            }\n\n            s->setup_state = SETUP_STATE_IDLE;\n\n            if (ret > 0)\n\n                return 0;\n\n            return ret;\n\n        }\n\n\n\n        /* return 0 byte */\n\n        return 0;\n\n\n\n    case SETUP_STATE_DATA:\n\n        if (s->setup_buf[0] & USB_DIR_IN) {\n\n            int len = s->setup_len - s->setup_index;\n\n            if (len > p->iov.size) {\n\n                len = p->iov.size;\n\n            }\n\n            usb_packet_copy(p, s->data_buf + s->setup_index, len);\n\n            s->setup_index += len;\n\n            if (s->setup_index >= s->setup_len)\n\n                s->setup_state = SETUP_STATE_ACK;\n\n            return len;\n\n        }\n\n\n\n        s->setup_state = SETUP_STATE_IDLE;\n\n        return USB_RET_STALL;\n\n\n\n    default:\n\n        return USB_RET_STALL;\n\n    }\n\n}\n", "idx": 19133, "substitutes": {"s": ["ns", "spec", "service", "ss", "cs", "d", "new", "qs", "sym", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "aws", "ips", "o", "su", "si", "S", "hs", "ds", "native", "bs", "f", "sv", "r", "sb", "as", "this", "l", "ins", "w", "vs", "sync", "c", "ps", "b", "sys", "es", "sq", "sf", "session", "t", "conf", "sp", "services", "n", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "site", "e", "ssl", "ses", "js", "support", "gs", "its", "os", "parts", "se", "server", "y", "u"], "p": ["pc", "per", "wp", "m", "j", "t", "data", "fp", "f", "jp", "op", "sp", "vp", "r", "pe", "n", "press", "script", "g", "bp", "i", "cp", "lp", "ap", "pb", "o", "ip", "l", "d", "gp", "pp", "up", "pi", "pre", "e", "pa", "cop", "q", "v", "c", "ps", "post", "mp", "b", "h", "proc", "api", "pro", "tp", "py", "np", "y", "P", "u"], "request": ["require", "session", "work", "data", "user", "name", "call", "buffer", "report", "result", "query", "method", "type", "rf", "claim", "create", "ip", "store", "pair", "header", "complete", "event", "initial", "back", "use", "config", "key", "pull", "response", "queue", "q", "open", "hello", "id", "req", "access", "url", "address", "Request", "condition", "xml", "resource", "requ", "message", "frame", "callback", "desc", "demand", "command", "order", "input"], "value": ["set", "values", "Value", "data", "view", "element", "sample", "volume", "name", "info", "media", "ve", "buffer", "property", "money", "result", "option", "show", "function", "range", "pair", "val", "change", "complete", "rule", "flow", "ue", "length", "response", "key", "wave", "hello", "v", "update", "VALUE", "off", "fee", "resource", "output", "dollar", "wa", "number", "message", "end", "server", "version"], "index": ["part", "offset", "where", "data", "x", "search", "call", "element", "edit", "action", "inc", "input", "num", "i", "match", "type", "in", "Index", "slice", "ind", "pos", "min", "context", "val", "size", "length", "key", "pull", "id", "open", "update", "position", "include", "success", "condition", "address", "area", "append", "weight", "end", "valid", "connect", "len"]}}
{"project": "qemu", "commit_id": "a193b0f0a8d7735f4eb2ff863fd0902a5fa5eec6", "target": 0, "func": "static int coroutine_fn backup_do_cow(BackupBlockJob *job,\n\n                                      int64_t offset, uint64_t bytes,\n\n                                      bool *error_is_read,\n\n                                      bool is_write_notifier)\n\n{\n\n    BlockBackend *blk = job->common.blk;\n\n    CowRequest cow_request;\n\n    struct iovec iov;\n\n    QEMUIOVector bounce_qiov;\n\n    void *bounce_buffer = NULL;\n\n    int ret = 0;\n\n    int64_t start, end; /* bytes */\n\n    int n; /* bytes */\n\n\n\n    qemu_co_rwlock_rdlock(&job->flush_rwlock);\n\n\n\n    start = QEMU_ALIGN_DOWN(offset, job->cluster_size);\n\n    end = QEMU_ALIGN_UP(bytes + offset, job->cluster_size);\n\n\n\n    trace_backup_do_cow_enter(job, start, offset, bytes);\n\n\n\n    wait_for_overlapping_requests(job, start, end);\n\n    cow_request_begin(&cow_request, job, start, end);\n\n\n\n    for (; start < end; start += job->cluster_size) {\n\n        if (test_bit(start / job->cluster_size, job->done_bitmap)) {\n\n            trace_backup_do_cow_skip(job, start);\n\n            continue; /* already copied */\n\n        }\n\n\n\n        trace_backup_do_cow_process(job, start);\n\n\n\n        n = MIN(job->cluster_size, job->common.len - start);\n\n\n\n        if (!bounce_buffer) {\n\n            bounce_buffer = blk_blockalign(blk, job->cluster_size);\n\n        }\n\n        iov.iov_base = bounce_buffer;\n\n        iov.iov_len = n;\n\n        qemu_iovec_init_external(&bounce_qiov, &iov, 1);\n\n\n\n        ret = blk_co_preadv(blk, start, bounce_qiov.size, &bounce_qiov,\n\n                            is_write_notifier ? BDRV_REQ_NO_SERIALISING : 0);\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_read_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = true;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        if (buffer_is_zero(iov.iov_base, iov.iov_len)) {\n\n            ret = blk_co_pwrite_zeroes(job->target, start,\n\n                                       bounce_qiov.size, BDRV_REQ_MAY_UNMAP);\n\n        } else {\n\n            ret = blk_co_pwritev(job->target, start,\n\n                                 bounce_qiov.size, &bounce_qiov,\n\n                                 job->compress ? BDRV_REQ_WRITE_COMPRESSED : 0);\n\n        }\n\n        if (ret < 0) {\n\n            trace_backup_do_cow_write_fail(job, start, ret);\n\n            if (error_is_read) {\n\n                *error_is_read = false;\n\n            }\n\n            goto out;\n\n        }\n\n\n\n        set_bit(start / job->cluster_size, job->done_bitmap);\n\n\n\n        /* Publish progress, guest I/O counts as progress too.  Note that the\n\n         * offset field is an opaque progress value, it is not a disk offset.\n\n         */\n\n        job->bytes_read += n;\n\n        job->common.offset += n;\n\n    }\n\n\n\nout:\n\n    if (bounce_buffer) {\n\n        qemu_vfree(bounce_buffer);\n\n    }\n\n\n\n    cow_request_end(&cow_request);\n\n\n\n    trace_backup_do_cow_return(job, offset, bytes, ret);\n\n\n\n    qemu_co_rwlock_unlock(&job->flush_rwlock);\n\n\n\n    return ret;\n\n}\n", "idx": 19160, "substitutes": {"job": ["child", "ob", "full", "jar", "service", "result", "java", "machine", "hub", "gru", "ie", "run", "big", "exec", "layer", "config", "lib", "resource", "output", "jam", "command", "plugin", "part", "j", "work", "name", "cp", "manager", "Job", "slot", "JO", "summary", "obs", "sub", "queue", "mb", "route", "connection", "order", "process", "status", "org", "base", "image", "jp", "f", "worker", "block", "cb", "match", "node", "function", "model", "batch", "sync", "emb", "line", "address", "lock", "mor", "b", "project", "py", "np", "bug", "jo", "session", "db", "jobs", "pool", "module", "lb", "member", "low", "build", "event", "site", "com", "rb", "cmd", "url", "http", "api", "ja", "server"], "offset": ["set", "part", "init", "fp", "Offset", "base", "from", "align", "loc", "reference", "phase", "padding", "slice", "index", "pos", "started", "done", "timeout", "location", "slot", "layer", "begin", "size", "offs", "starting", "seed", "stop", "initial", "reset", "prefix", "length", "limit", "id", "position", "off", "url", "address", "shift", "next", "error", "boot", "origin", "addr", "server", "order", "len"], "bytes": ["classes", "ns", "values", "limits", "s", "init", "data", "base", "seconds", "nos", "files", "ips", "ops", "items", "sec", "byte", "lines", "count", "units", "size", "bps", "args", "outs", "gets", "blocks", "length", "limit", "steps", "bits", "seq", "rows", "binary", "total", "fee", "tes", "boot", "reads", "es", "parts", "len", "flags", "errors", "os", "locks"], "error_is_read": ["error_is_write", "error_is_reader", "error_isocreader", "error_isocwrite", "error_is_readable", "error_is_sync", "error_is_closed", "error_isocread", "error_isocreadable"], "is_write_notifier": ["is_write_generification", "is_write_nonifer", "is_write_disification", "is_write_notformer", "is_write_notification", "is_write_serializer", "is_write_generformer", "is_write_generifier", "is_write_generiser", "is_write_disifier", "is_write_serialifer", "is_write_disformer", "is_write_serialifier", "is_write_nonifier", "is_write_notiser", "is_write_disiser", "is_write_notifying", "is_write_nonizer", "is_write_notifer", "is_write_nonifying", "is_write_serialifying", "is_write_notizer"], "blk": ["blkt", "plks", "clke", "plk", "ilk", " blks", "ilke", "blke", "BLK", "brck", "clkt", "plkt", "BLk", " blK", "BLck", "Blks", " blck", "clck", "plck", "BLks", "brke", " blke", "Blck", "plke", "ilks", "Blke", "blK", " blkt", "plK", "blks", "blck", "clk", "brk", "Blk", "BlK", "ilK", "brkt"], "cow_request": ["bootallmethod", "cowallresponse", "cowallrequest", "cow_order", "cow_method", "boot_response", "cow_req", "hw_order", "hw_req", "cowapprequest", "boot_begin", "cowappbegin", "cowappresponse", "bootallresponse", "bootallbegin", "cow_response", "cow_begin", "bootallrequest", "boot_method", "hw_request", "cowappmethod", "cowallbegin", "boot_request", "cowallmethod"], "iov": ["ixon", "wav", "sbm", "iii", "iro", "vg", "club", "inn", "icho", "iago", "micro", "gio", "obo", "io", "wikipedia", "\u00ef", "dq", "dyl", "gru", "iop", "ij", "iev", "iol", "roc", "hw", "liv", "rob", "nox", "arrison", "drm", "userc", "ovi", "imedia", "iris", "soc", "chrom", "vre", "voc", "yout", "lov", "voice", "ibr", "irin", "ominium", "ibl", "ilib", "minecraft", "odi", "oren", "uno", "oyer", "ilo", "gener", "rolet", " cohort"], "bounce_qiov": ["bounce_sqliv", "bounce_quoyer", "bounce_quiop", "bounce_dnox", "bounce_diop", "bounce_backliv", "bounce_qilo", "bounce_kilo", "bounce_qqovi", "bounce_piov", "bounce_sqiov", "bounce_qqilo", "bounce_kiop", "bounce_qiop", "bounce_diov", "bounce_backiop", "bounce_qovi", "bounce_qqoyer", "bounce_backovi", "bounce_poyer", "bounce_dliv", "bounce_qqliv", "bounce_pnox", "bounce_piop", "bounce_giop", "bounce_sqovi", "bounce_gilo", "bounce_qliv", "bounce_qoyer", "bounce_kliv", "bounce_knox", "bounce_quiov", "bounce_qqiov", "bounce_backiov", "bounce_quliv", "bounce_qnox", "bounce_pliv", "bounce_giov", "bounce_sqiop", "bounce_kiov", "bounce_gliv", "bounce_qqiop"], "bounce_buffer": ["bounce_value", "bouncelogbuffer", "bounced_buf", "benge_buffer", "bounce2value", "botationmemlength", "bounceglength", "battery_value", "bouncegbreak", "bounce2buffer", "botationmembuffer", "bouncememlength", "botationmemreader", "bouncegbuffer", "bouncepreader", "bounce32buffer", "bounced_Buffer", "battery_buf", "bounce_size", "botation_length", "bounce_Buffer", "botationmembreak", "bounced_buffer", "bounce32number", "bouncepbuffer", "bounce_break", "bounce32size", "botation_reader", "bouncelogbuf", "battery_buffer", "bouncelogvalue", "bounce_reader", "bouncepbreak", "bounce_length", "bounce_number", "bouncemembreak", "battery2value", "battery2buf", "bouncememreader", "bounceplength", "bounce2buf", "bouncemembuffer", "botation_buffer", "bounce_buff", "bounced_buff", "benge_number", "botation_break", "bounce_buf", "battery2buffer", "bouncegreader", "bounce2Buffer", "benge_size", "bounce2buff"], "start": ["set", "skip", "x", "show", "ie", "pos", "started", "d", "comp", "length", "id", "mid", "ish", "send", "p", "pad", "next", "boot", "it", "source", "len", "part", "enable", "scale", "init", "work", "rest", "name", "from", "in", "count", "sk", "art", "parse", "read", "size", "stop", "style", "key", "open", "shift", "base", "try", "current", "Start", "type", "ind", "help", "speed", "l", "grade", "starting", "like", "ad", "c", "sum", "check", "state", "now", "info", "sp", "i", "index", "en", "get", "ip", "step", "seed", "add", "use", "st", "cur", "se", "diff"], "end": ["set", "entry", "ion", "est", "ff", "nd", "eff", "ort", "alt", "END", "max", "z", "index", "pos", "ind", "en", "after", "enc", "until", "End", "close", "begin", "event", "size", "and", "stop", "add", "last", "except", "ad", "limit", "send", "e", "open", "id", "post", "append", "win", "edge", "ending", "inner", "ended"], "n": ["ns", "m", "init", "j", "s", "t", "un", "x", "f", "net", "nt", "ne", "adj", "r", "num", "N", "nit", "i", "g", "nor", "z", "nl", "nb", "en", "nat", "o", "nm", "l", "d", "nc", "size", "sn", "nu", "rn", "e", "k", "v", "c", "ni", "p", "b", "number", "nn", "y", "conn", "len"]}}
{"project": "qemu", "commit_id": "d157ed5f7235f3d2d5596a514ad7507b18e24b88", "target": 0, "func": "static int inject_error(BlockDriverState *bs, BlkdebugRule *rule)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    int error = rule->options.inject.error;\n\n    bool immediately = rule->options.inject.immediately;\n\n\n\n    if (rule->options.inject.once) {\n\n        QSIMPLEQ_REMOVE(&s->active_rules, rule, BlkdebugRule, active_next);\n\n        remove_rule(rule);\n\n    }\n\n\n\n    if (!immediately) {\n\n        aio_co_schedule(qemu_get_current_aio_context(), qemu_coroutine_self());\n\n        qemu_coroutine_yield();\n\n    }\n\n\n\n    return -error;\n\n}\n", "idx": 19184, "substitutes": {"bs": ["ns", "ms", "ab", "bi", "rs", "aws", "sb", "bc", "ss", "ls", "as", "pb", "fs", "bb", "lb", "ba", "bid", "cs", "gb", "cms", "ins", "outs", "BS", "abi", "iss", "bas", "ses", "vs", "fb", "bits", "ps", "rb", "b", "os", "ds"], "rule": ["entry", "gi", "plugin", "rr", "ULE", "record", "request", "user", "child", "element", "f", "call", "token", "comment", "name", "sort", "r", "service", "file", "result", "role", "module", "root", "block", "match", "function", "trial", "slice", "run", "model", "tag", "o", "range", "val", "rol", "event", "style", "ru", "use", "ride", "config", "e", "lr", "update", "rl", "Rule", "ri", "line", "rb", "item", "feature", "resource", "route", "sche", "row", "er", "rules", "fire", "state", "statement", "section", "ule"], "s": ["ns", "sg", "rs", "f", "sv", "services", "sie", "sb", "sl", "ss", "ls", "ops", "fs", "is", "o", "cs", "args", "sn", "iss", "qs", "e", "ssl", "ses", "v", "c", "ps", "si", "js", "p", "S", "b", "ks", "gs", "os", "state", "states", "sq", "sa", "ds"]}}
{"project": "qemu", "commit_id": "5d79b80b335c5f65f148d1bb1672d9d534ace73b", "target": 0, "func": "static void pflash_write(pflash_t *pfl, hwaddr offset,\n\n                         uint32_t value, int width, int be)\n\n{\n\n    uint8_t *p;\n\n    uint8_t cmd;\n\n\n\n    cmd = value;\n\n\n\n    DPRINTF(\"%s: writing offset \" TARGET_FMT_plx \" value %08x width %d wcycle 0x%x\\n\",\n\n            __func__, offset, value, width, pfl->wcycle);\n\n\n\n    if (!pfl->wcycle) {\n\n        /* Set the device in I/O access mode */\n\n        memory_region_rom_device_set_readable(&pfl->mem, false);\n\n    }\n\n\n\n    switch (pfl->wcycle) {\n\n    case 0:\n\n        /* read mode */\n\n        switch (cmd) {\n\n        case 0x00: /* ??? */\n\n            goto reset_flash;\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            break;\n\n        case 0x20: /* Block erase */\n\n            p = pfl->storage;\n\n            offset &= ~(pfl->sector_len - 1);\n\n\n\n            DPRINTF(\"%s: block erase at \" TARGET_FMT_plx \" bytes %x\\n\",\n\n                    __func__, offset, (unsigned)pfl->sector_len);\n\n\n\n            if (!pfl->ro) {\n\n                memset(p + offset, 0xff, pfl->sector_len);\n\n                pflash_update(pfl, offset, pfl->sector_len);\n\n            } else {\n\n                pfl->status |= 0x20; /* Block erase error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0x50: /* Clear status bits */\n\n            DPRINTF(\"%s: Clear status bits\\n\", __func__);\n\n            pfl->status = 0x0;\n\n            goto reset_flash;\n\n        case 0x60: /* Block (un)lock */\n\n            DPRINTF(\"%s: Block unlock\\n\", __func__);\n\n            break;\n\n        case 0x70: /* Status Register */\n\n            DPRINTF(\"%s: Read status register\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x90: /* Read Device ID */\n\n            DPRINTF(\"%s: Read Device information\\n\", __func__);\n\n            pfl->cmd = cmd;\n\n            return;\n\n        case 0x98: /* CFI query */\n\n            DPRINTF(\"%s: CFI query\\n\", __func__);\n\n            break;\n\n        case 0xe8: /* Write to buffer */\n\n            DPRINTF(\"%s: Write to buffer\\n\", __func__);\n\n            pfl->status |= 0x80; /* Ready! */\n\n            break;\n\n        case 0xf0: /* Probe for AMD flash */\n\n            DPRINTF(\"%s: Probe for AMD flash\\n\", __func__);\n\n            goto reset_flash;\n\n        case 0xff: /* Read array mode */\n\n            DPRINTF(\"%s: Read array mode\\n\", __func__);\n\n            goto reset_flash;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        pfl->wcycle++;\n\n        pfl->cmd = cmd;\n\n        break;\n\n    case 1:\n\n        switch (pfl->cmd) {\n\n        case 0x10: /* Single Byte Program */\n\n        case 0x40: /* Single Byte Program */\n\n            DPRINTF(\"%s: Single Byte Program\\n\", __func__);\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n                pflash_update(pfl, offset, width);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n            pfl->status |= 0x80; /* Ready! */\n\n            pfl->wcycle = 0;\n\n        break;\n\n        case 0x20: /* Block erase */\n\n        case 0x28:\n\n            if (cmd == 0xd0) { /* confirm */\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) { /* read array mode */\n\n                goto reset_flash;\n\n            } else\n\n                goto error_flash;\n\n\n\n            break;\n\n        case 0xe8:\n\n            DPRINTF(\"%s: block write of %x bytes\\n\", __func__, value);\n\n            pfl->counter = value;\n\n            pfl->wcycle++;\n\n            break;\n\n        case 0x60:\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0x01) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: Unknown (un)locking command\\n\", __func__);\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        case 0x98:\n\n            if (cmd == 0xff) {\n\n                goto reset_flash;\n\n            } else {\n\n                DPRINTF(\"%s: leaving query mode\\n\", __func__);\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 2:\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (!pfl->ro) {\n\n                pflash_data_write(pfl, offset, value, width, be);\n\n            } else {\n\n                pfl->status |= 0x10; /* Programming error */\n\n            }\n\n\n\n            pfl->status |= 0x80;\n\n\n\n            if (!pfl->counter) {\n\n                hwaddr mask = pfl->writeblock_size - 1;\n\n                mask = ~mask;\n\n\n\n                DPRINTF(\"%s: block write finished\\n\", __func__);\n\n                pfl->wcycle++;\n\n                if (!pfl->ro) {\n\n                    /* Flush the entire write buffer onto backing storage.  */\n\n                    pflash_update(pfl, offset & mask, pfl->writeblock_size);\n\n                } else {\n\n                    pfl->status |= 0x10; /* Programming error */\n\n                }\n\n            }\n\n\n\n            pfl->counter--;\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    case 3: /* Confirm mode */\n\n        switch (pfl->cmd) {\n\n        case 0xe8: /* Block write */\n\n            if (cmd == 0xd0) {\n\n                pfl->wcycle = 0;\n\n                pfl->status |= 0x80;\n\n            } else {\n\n                DPRINTF(\"%s: unknown command for \\\"write block\\\"\\n\", __func__);\n\n                PFLASH_BUG(\"Write block confirm\");\n\n                goto reset_flash;\n\n            }\n\n            break;\n\n        default:\n\n            goto error_flash;\n\n        }\n\n        break;\n\n    default:\n\n        /* Should never happen */\n\n        DPRINTF(\"%s: invalid write state\\n\",  __func__);\n\n        goto reset_flash;\n\n    }\n\n    return;\n\n\n\n error_flash:\n\n    qemu_log_mask(LOG_UNIMP, \"%s: Unimplemented flash cmd sequence \"\n\n                  \"(offset \" TARGET_FMT_plx \", wcycle 0x%x cmd 0x%x value 0x%x)\"\n\n                  \"\\n\", __func__, offset, pfl->wcycle, pfl->cmd, value);\n\n\n\n reset_flash:\n\n    memory_region_rom_device_set_readable(&pfl->mem, true);\n\n\n\n    pfl->bypass = 0;\n\n    pfl->wcycle = 0;\n\n    pfl->cmd = 0;\n\n}\n", "idx": 19198, "substitutes": {"pfl": ["lpfe", "ppflo", "execfl", "ppsl", "prefly", "gflo", "gfw", "ppform", "perf", "lpcol", "Pfly", "copfl", " pFL", "pbf", "preflo", "pfw", "pflash", "Pbf", "perFL", " psl", "wpf", "pfx", "PFL", "Pf", "peull", "gbf", "wpl", "presl", "wpFL", "tfly", "wpfly", "ppl", " pfc", "copfr", "prefi", "lpfx", "perfl", "ppfw", "Pfc", " pfi", "copFL", "Pform", "gFL", " pfly", "wfl", "Pzl", "tpsl", "pfr", "tpFL", "pfe", "lpull", "tpbf", "tfx", "wcl", "tfe", " pcol", "pecol", "Pflush", "pfly", "gsl", "Pflo", "lpfi", "copflo", "wFL", "Pcoll", "tll", "pfc", "Pflash", "tFL", "pefl", "ppfe", "prefl", "psl", " pzl", "tfl", " pflush", "lpflush", " pf", "pflush", "execflo", " pcl", "Pfe", "percoll", "pcoll", "copfly", " pcoll", "Pfl", "peFL", "pcl", " pfe", "Psl", "ppflush", " pull", "ppf", "pflo", "Ppl", "pform", " pflo", "lpfl", "tpfly", "pf", "ppFL", "execflash", "pfi", " ppl", "tfr", "pcol", "gf", "pzl", "pll", "lpFL", "ppfl", "wpfl", " pform", "copsl", "lpll", "pull", "Pfr", "execFL", "tpfl", "gfe", "precol", " pfx", " pll", "gflash", "tcl", "lpflo", "tpflo", "ppfc", " pfw", "pFL", "Pcl", "gfl", "ppzl"], "offset": ["entry", "part", "data", "info", "Offset", "af", "ref", "image", "attribute", "f", "fp", "op", "mode", "annot", "align", "num", "i", "loc", "phase", "padding", "index", "ptr", "pos", "slice", "timeout", "count", "pointer", "online", "o", "range", "l", "location", "slot", "alias", "size", "adjust", "initial", "length", "start", "limit", "layout", "position", "off", "address", "shift", "pad", "area", "enabled", "number", "origin", "api", "addr", "end", "port", "usage", "operation", "attr", "len"], "value": ["set", "native", "values", "scale", "Value", "content", "data", "text", "mode", "name", "image", "op", "buffer", "option", "window", "current", "type", "max", "function", "padding", "index", "create", "range", "val", "array", "format", "complete", "size", "memory", "flow", "w", "length", "start", "buf", "v", "update", "VALUE", "off", "output", "write", "weight", "message", "end", "port", "usage", "command", "version", "wave"], "be": ["s", "code", "mode", "bit", "op", "buffer", "pos", "count", "val", " mode", "le", "w", "buff", "buf", "bits", "pad", "b", "cap", " buffer", "loop", "cut", "write", "port"], "p": ["pc", "m", "point", "j", "t", "data", "fp", "x", "f", "jp", "op", "sp", "r", "pe", "n", "g", "i", "bp", "z", "pb", "ap", "pointer", "o", "ip", "l", "d", "array", "pre", "w", "e", "q", "v", "parent", "c", "b", "cache", "h", "tp", "port", "np", "P", "u"], "cmd": ["grad", "stat", "cfg", "bit", "ref", "op", "md", "align", "cf", "cod", "config", "prefix", "id", "send", "cli", "qq", "opt", "carry", "command", "cc", "target", "plugin", "content", "init", "mod", "wx", "name", "bind", "ctr", "fun", "cp", "msg", "force", "read", "update", "cat", "bg", "reason", "mac", "status", "gn", "code", "text", "cookie", "call", "component", "cb", "type", "mem", "byte", "help", "ctrl", "ack", "generic", "buf", "cd", "state", "func", "mode", "module", "method", "MD", "kind", "ctx", "acl", "def", "header", "Cmd", "pkg", "cl", "req", "seq", "url", "cmp", "sid", "custom"], "wcycle": ["xcle", "ewstage", "fwyear", "fwsec", " wyear", "wuse", " wsync", "swuse", "swcycle", "swcle", " wuse", "awsec", "wcle", "wyear", " wcycl", "rwcycle", "wsec", "ewcycle", " wsec", "wstage", " wstage", "fwcycle", "wsync", "awcycle", " wcle", "rwstage", "awcycl", "xuse", "fwcycl", "wcycl", "xcycl", "ewsync", "awyear", "xcycle", "rwsync", "swcycl"]}}
{"project": "qemu", "commit_id": "4c055ab54fae39b6329c57bcb5334d59b920463e", "target": 0, "func": "int kvm_init_vcpu(CPUState *cpu)\n\n{\n\n    KVMState *s = kvm_state;\n\n    long mmap_size;\n\n    int ret;\n\n\n\n    DPRINTF(\"kvm_init_vcpu\\n\");\n\n\n\n    ret = kvm_vm_ioctl(s, KVM_CREATE_VCPU, (void *)kvm_arch_vcpu_id(cpu));\n\n    if (ret < 0) {\n\n        DPRINTF(\"kvm_create_vcpu failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_fd = ret;\n\n    cpu->kvm_state = s;\n\n    cpu->kvm_vcpu_dirty = true;\n\n\n\n    mmap_size = kvm_ioctl(s, KVM_GET_VCPU_MMAP_SIZE, 0);\n\n    if (mmap_size < 0) {\n\n        ret = mmap_size;\n\n        DPRINTF(\"KVM_GET_VCPU_MMAP_SIZE failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    cpu->kvm_run = mmap(NULL, mmap_size, PROT_READ | PROT_WRITE, MAP_SHARED,\n\n                        cpu->kvm_fd, 0);\n\n    if (cpu->kvm_run == MAP_FAILED) {\n\n        ret = -errno;\n\n        DPRINTF(\"mmap'ing vcpu state failed\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if (s->coalesced_mmio && !s->coalesced_mmio_ring) {\n\n        s->coalesced_mmio_ring =\n\n            (void *)cpu->kvm_run + s->coalesced_mmio * PAGE_SIZE;\n\n    }\n\n\n\n    ret = kvm_arch_init_vcpu(cpu);\n\nerr:\n\n    return ret;\n\n}\n", "idx": 19204, "substitutes": {"cpu": ["pc", "instance", "core", "f", "platform", "uci", "net", "eu", "gc", "px", "lu", "cf", "loader", "cpp", "cp", "node", "bc", "ctx", "fc", "mc", "lb", "phy", "computer", "bench", "vm", "cs", "css", "hw", "gb", "linux", "su", " CPU", "nc", "comp", "hu", "CPU", "gpu", "config", "cu", "processor", "cli", "lc", "c", "p", "uc", "cache", "cmp", "null", "sys", "consumer", "clock", "proc", "boot", "cn", "os", "pu", "us", "mac", "uno", "fi", "np", "cow", "conn", "u"], "s": ["ns", "spec", "m", "stat", "session", "ts", "sg", "t", "stats", "rs", "conf", "f", "settings", "services", "service", "r", "n", "sie", "g", "sb", "sl", "i", "ss", "ops", "fs", "cons", "is", "o", "share", "cs", "css", "l", "d", "su", "ssh", "site", "socket", "w", "spot", "gpu", "e", "ssl", "ses", "v", "sync", "js", "c", "si", "ps", "sym", "p", "S", "b", "http", "params", "gs", "sys", "u", "proc", "es", "os", "state", "us", "server", "states", "sq", "sa", "ds", "sf"], "mmap_size": ["mmap_count", "mmap_len", "mmap_scale", "mmapping_count", "mmape_number", "mmape_length", "mmap_num", "mmap_length", "mmape_size", "mmape_scale", "mmcap_clean", "mmapping_number", "mmap_clean", "mmap_number", "mmap_small", "mmap_sec", "mmape_num", "mmap_Size", "mmcap_sec", "mmcap_small", "mmape_len", "mmapping_size", "mmcap_size", "mmape_Size", "mmapping_length"], "ret": ["al", "bit", "ref", "obj", "nt", "ann", "result", "num", "job", "ut", "sec", "run", "att", "feat", "fit", "rev", "hard", "repl", "pat", "res", "boot", "mt", "valid", "fi", "conn", "len", "j", "fat", "rc", "fun", "fin", "rf", "resp", "sat", "arg", "art", "Ret", "bf", "cat", " Ret", "gt", "RET", "pet", "ft", "code", "err", "base", "alt", "net", "lit", "rt", "match", "mem", "val", "final", "re", "std", " RET", "sr", "py", "reply", "success", "af", "let", "reg", "flag", "ext", "def", "rets", "en", "get", "out", "det", "bot", "req", "used"]}}
{"project": "qemu", "commit_id": "8d04fb55dec381bc5105cb47f29d918e579e8cbd", "target": 1, "func": "void arm_cpu_do_interrupt(CPUState *cs)\n{\n    ARMCPU *cpu = ARM_CPU(cs);\n    CPUARMState *env = &cpu->env;\n    unsigned int new_el = env->exception.target_el;\n    assert(!arm_feature(env, ARM_FEATURE_M));\n    arm_log_exception(cs->exception_index);\n    qemu_log_mask(CPU_LOG_INT, \"...from EL%d to EL%d\\n\", arm_current_el(env),\n                  new_el);\n    if (qemu_loglevel_mask(CPU_LOG_INT)\n        && !excp_is_internal(cs->exception_index)) {\n        qemu_log_mask(CPU_LOG_INT, \"...with ESR %x/0x%\" PRIx32 \"\\n\",\n                      env->exception.syndrome >> ARM_EL_EC_SHIFT,\n                      env->exception.syndrome);\n    }\n    if (arm_is_psci_call(cpu, cs->exception_index)) {\n        arm_handle_psci_call(cpu);\n        qemu_log_mask(CPU_LOG_INT, \"...handled as PSCI call\\n\");\n        return;\n    }\n    /* Semihosting semantics depend on the register width of the\n     * code that caused the exception, not the target exception level,\n     * so must be handled here.\n    if (check_for_semihosting(cs)) {\n        return;\n    }\n    assert(!excp_is_internal(cs->exception_index));\n    if (arm_el_is_aa64(env, new_el)) {\n        arm_cpu_do_interrupt_aarch64(cs);\n    } else {\n        arm_cpu_do_interrupt_aarch32(cs);\n    }\n    arm_call_el_change_hook(cpu);\n    if (!kvm_enabled()) {\n        cs->interrupt_request |= CPU_INTERRUPT_EXITTB;\n    }\n}", "idx": 19216, "substitutes": {"cs": ["pc", "ns", "spec", "ts", "s", "bs", "rs", "core", "ras", "cal", "cus", "vc", "ix", "conn", "cm", "cf", "Cs", "CS", "cp", "ls", "bc", "ces", "ctx", "wcs", "utils", "fs", "cer", "cons", "cas", "cks", "sk", "ca", "css", "acs", "cms", "ce", "nc", "ins", "args", "ci", "qs", "sc", "ics", "vs", "codes", "sync", "alls", "lc", "c", "ps", "js", "ck", "ks", "cmp", "ec", "sys", "ced", "cn", "cases", "cc", "ds"], "cpu": ["pc", "process", "instance", "cal", "core", "jp", "cus", "platform", "uci", "component", "runner", "cm", "nic", "cf", "loader", "cpp", "anc", "cp", "bc", "ctx", "fc", "mc", "console", "bench", "vm", "auc", "css", "roc", "hw", "linux", "chip", "nc", "CPU", "gpu", "config", "cu", "processor", "cli", "lc", "c", "kernel", "uc", "cache", "cmp", "ec", "orc", "clock", "boot", "cn", "proc", "os", "pu", "mac", "eni", "np", "cow", "conn"], "env": ["viron", "cfg", "extra", "settings", "cf", "anc", "environment", "console", "energy", "enc", "vm", "stack", "kn", "config", "ev", "cli", "impl", "ea", "opt", "enh", "cv", "conn", "cdn", "cal", "eve", "eye", "eu", "engine", "ne", "bc", " environment", "scope", "eng", "hw", "exe", "style", "iss", "v", "nw", "ec", "et", "export", "ds", "code", "core", "err", "net", "icer", "ass", "inet", "vs", "csv", "sys", "ace", "edge", "eni", "np", "Environment", "db", "conf", "skin", "exc", "loader", "module", "oa", "ext", "ctx", "en", "context", "ce", "nc", "args", "site", "e", "esm", "que", "cache", "osc", "agent", "el"], "depend": ["data", "dep", "dependent", "depending", "ependence", " react", "epend", "react", " independ", "respond", "cript", "Dep", " insist", "reflect", "ind", "Depending", "draw", "cend", " depended", " dependency", "sil", " Depend", " dependent", " dep", "ependent", "desc", " dependence"], "the": ["t", "athe", "f", "true", "all", "eth", "natural", "ethe", "their", "then", "n", "pe", "The", "current", "or", "match", "type", "public", "as", "th", "function", "this", "in", " The", "THE", "my", "what", "member", "page", "non", "broad", "d", "same", "to", "new", "and", "team", "no", "het", "last", "length", "ev", "since", "display", "_", "you", "by", "one", "test", "total", "\u00eb", "ure", "wh", "your", "end", "that", "them", "he", "with", "it", "an"], "of": ["at", "without", "name", "component", "OF", "from", "n", "on", "channel", "or", "type", "in", "Of", "oft", "new", "e", "by", "outside", "number", "during", "that", "with", "own", "one", "less", "source", "sf"], "caused": ["caated", "Caated", "Caued", "taued", "accuses", "Causes", "accused", "causes", "taused", "tauses", "Caused", "caued", "taated", "accated", "accued"], "exception": ["EXparent", "excevent", "extvention", "execformer", "excvention", "execception", "exceptions", "exposure", "EXception", "EXacket", "externalchange", " exformer", "extceptions", "execacket", "extposure", "exformer", "extception", " exacket", "excception", "lexception", "excexc", "execceptions", "excposure", "exchange", "ceptionception", "externalevent", "lexevent", "exevent", "EXceptions", "ceptionchange", "EXvention", "EXposure", "externalerror", "extparent", "pexevent", "exexc", "pexexc", "expresschange", "EXformer", "pexception", "exerror", "expresserror", "lexexc", "ceptionerror", "expressevent", "exacket", "exparent", "Exposition", "exposition", "EXposition", "expressception", "excposition", "extposition", "Exparent", "Exceptions", "externalception", "Exception", "exvention", "ceptionevent", " exceptions"], "not": ["at", "set", "un", "t", "ot", "note", "all", "nt", "ne", "n", "or", "nor", "match", "is", "bad", "non", "found", "Not", "no", "about", "NOT", "but", "et", "it", "by"], "target": ["rest", "platform", "arget", "current", "root", "master", "match", "effective", "top", "nat", "host", "lead", "new", "site", "config", "parent", "unit", "test", "external", "average", "next", "tail", "export", "supported", "real", "source"], "level": ["Level", "status", "point", "scale", "name", "type", "index", "scope", "location", "layer", "class", "path", "stack", "rule", "style", "length", "id", "limit", "levels", "stage", "line", "lvl", "depth", "error", "number", "sequence", "value"], "so": ["ans", "thus", "say", "s", "plus", "then", "because", "see", "who", "new", "and", "no", "since", "xxx", "e", "you", "can", " which", " So", "how", "now", " thus", "So", "co", "also"], "be": ["call", "ste", "fe", "ape", "see", "make", "te", "help", "en", "ae", "is", "ome", "stay", "always", "Be", "to", "le", "use", "st", "bl", "play", "BE", "bes", "co", "se"]}}
{"project": "qemu", "commit_id": "e3f30488e5f802547b3a60e40cebaef3b4ec16a3", "target": 1, "func": "static void virtio_net_flush_tx(VirtIONet *n, VirtQueue *vq)\n\n{\n\n    VirtQueueElement elem;\n\n\n\n    if (!(n->vdev.status & VIRTIO_CONFIG_S_DRIVER_OK))\n\n        return;\n\n\n\n    if (n->async_tx.elem.out_num) {\n\n        virtio_queue_set_notification(n->tx_vq, 0);\n\n        return;\n\n    }\n\n\n\n    while (virtqueue_pop(vq, &elem)) {\n\n        ssize_t ret, len = 0;\n\n        unsigned int out_num = elem.out_num;\n\n        struct iovec *out_sg = &elem.out_sg[0];\n\n        unsigned hdr_len;\n\n\n\n        /* hdr_len refers to the header received from the guest */\n\n        hdr_len = n->mergeable_rx_bufs ?\n\n            sizeof(struct virtio_net_hdr_mrg_rxbuf) :\n\n            sizeof(struct virtio_net_hdr);\n\n\n\n        if (out_num < 1 || out_sg->iov_len != hdr_len) {\n\n            fprintf(stderr, \"virtio-net header not in first element\\n\");\n\n            exit(1);\n\n        }\n\n\n\n        /* ignore the header if GSO is not supported */\n\n        if (!n->has_vnet_hdr) {\n\n            out_num--;\n\n            out_sg++;\n\n            len += hdr_len;\n\n        } else if (n->mergeable_rx_bufs) {\n\n            /* tapfd expects a struct virtio_net_hdr */\n\n            hdr_len -= sizeof(struct virtio_net_hdr);\n\n            out_sg->iov_len -= hdr_len;\n\n            len += hdr_len;\n\n        }\n\n\n\n        ret = qemu_sendv_packet_async(&n->nic->nc, out_sg, out_num,\n\n                                      virtio_net_tx_complete);\n\n        if (ret == 0) {\n\n            virtio_queue_set_notification(n->tx_vq, 0);\n\n            n->async_tx.elem = elem;\n\n            n->async_tx.len  = len;\n\n            return;\n\n        }\n\n\n\n        len += ret;\n\n\n\n        virtqueue_push(vq, &elem, len);\n\n        virtio_notify(&n->vdev, vq);\n\n    }\n\n}\n", "idx": 19223, "substitutes": {"n": ["ns", "not", "na", "tun", "m", "dn", "gn", "init", "j", "s", "un", "t", "cdn", "f", "pn", "net", "ng", "nt", "ne", "adj", "syn", "mn", "num", "N", "g", "on", "i", "nov", "nor", "z", "node", "in", "nb", "en", "nat", "o", "enc", "ln", "nm", "l", "non", "d", "nc", "network", "sn", "w", "rn", "nu", "e", "v", "c", "yn", "p", "bn", "none", "b", "fn", "cn", "nn", "np", "inner", "an", "y", "conn", "u"], "vq": ["quq", "fq", "evqs", " viq", " vqu", "nque", "fiq", " vQ", "nue", "nqs", "nqa", "cue", "eviq", "viq", " vqs", " vqa", "ququ", "cque", "quQ", "evq", "nQ", "vqu", "vque", "qque", "qqs", "vqs", " vue", "qq", "nqu", "fqs", "quque", "niq", "vQ", "fQ", "vqa", "cqa", "cq", "evQ", "nq", "vue", "qiq", " vque"], "elem": ["gelement", "Elegate", " elee", "ehem", "element", "Elem", "eelems", "oelete", "eelegate", "belem", "felem", "elegate", "ielez", "eelee", "gele", "felements", "pehem", "telev", "eelem", "nelem", "peld", "ely", "eeject", "eelez", "ielem", "ielements", "nelev", " elev", "oeject", "Element", "belee", "bely", "pelements", "eelete", " elete", "elee", "ielete", "inelem", "belements", "belev", "ele", "pelev", "ielement", "elements", "nelements", "elev", "telem", "felement", "tehem", "gelems", "oelem", "ield", "eele", "gelem", "eelev", " eject", " ehem", " elez", "oelement", "inelement", "elems", "telement", "elez", "eject", "eld", "Elements", "pelem", "elete", "nelement", "inele", "felegate", "eelement", "eelements", "eeld", " ely", "belement", "eely", "bele", "pelement", " ele", "inelems", " element"], "ret": ["bin", "db", "data", "obj", "bit", "err", "fat", "alt", "all", "let", "ref", "reg", "nt", "rc", "lit", "rt", "fun", "hash", "urn", "str", "num", "ok", "flag", "match", "ext", "fin", "mem", "def", "resp", "rets", "count", "out", "en", "arg", "att", "lt", "get", "val", "final", "empty", "re", "Ret", "no", "ig", "back", "rev", "cat", "rb", "seq", "del", "url", "RET", "total", "lock", "red", "res", "mt", "el", "reply", "success", "len"], "out_num": ["out_info", "int_no", " out_nu", " out_number", "outXsu", "outFno", "outxnom", "outFnum", "out_size", "in_su", "out_number", "out_su", "in_info", "outxnum", " out_nom", "in_name", "outxsu", "outXnum", "in_num", "outxnu", "out_nom", "outlexnum", "in_number", "outFnumber", "out_len", "in_len", "outXsg", "out_name", "outlexnom", "int_number", " out_su", "outFsize", "outXnumber", "out_nu", "outlexnu", "int_num", "out_no", "in_sg", "int_size", "outlexsu"], "out_sg": ["outLoggeneral", " out_nb", "outlexsu", "out_msg", "out_rg", "out_node", "outlexmsg", " out_rg", "out_alloc", "out_si", "out_su", "out_tg", "out_general", " out_node", "out_nb", "out_desc", "outlexrg", " out_alloc", "in_num", "in_msg", "outDsg", "outlexnum", "in_si", "outlexdesc", "outPsg", "in_session", "in_desc", "outDgeneral", " out_tg", "outDnum", "outlexsession", " out_general", " out_su", "outPnode", " out_desc", "outLognum", "out_session", "outlexsg", "outLogsg", "outDalloc", "outLogalloc", "in_sg", "outPnb", "outPsu"], "hdr_len": ["hdr5lon", "hdr5lin", "hdr_count", "hdr54count", "hdr7len", "hdr64length", "hadr_ln", "hdr_line", "hhr_lon", "hrt_len", "hdr_lib", "hdr64lim", "hadr_val", "hhr_len", "hdr5num", "hdr64lin", "hhr_num", "hdr54lin", "hdr_en", "hdr7lib", "hrid_len", "hgr_ler", "hdr_ln", "hdr64val", "hrt_lon", "hdr64line", "hrid_lib", "hdr_lon", "hdr_num", "hrt_line", "hrid_ler", "hrt_lin", "hadr_len", "hgr_l", "hdr7lon", "hdr7ler", "hdr54len", "hrid_lon", "hdr54Len", "hdr5len", "hrt_lim", "hdr64len", "hrt_val", "hdr_length", "hdr_val", "hadr_length", "hhr_lin", "hgr_num", "hdr_lin", "hrt_en", "hdr_ler", "hdr64ln", "hdr_Len", "hdr_lim", "hdr_l", "hgr_len"]}}
{"project": "qemu", "commit_id": "a1c5975270f2335e1d7129c084a6e562d7b99bdd", "target": 1, "func": "static void flush_queued_data(VirtIOSerialPort *port, bool discard)\n\n{\n\n    assert(port || discard);\n\n\n\n    do_flush_queued_data(port, port->ovq, &port->vser->vdev, discard);\n\n}\n", "idx": 19237, "substitutes": {"port": ["pt", "plugin", "point", "pid", "data", "child", "ort", "bind", "pod", "component", "ports", "proxy", "service", "bridge", "feed", "report", "type", "match", "public", "scope", "tag", "pointer", "object", "ip", "prop", "host", "contract", "select", "import", "rule", "PORT", "pipe", "parent", "post", "patch", "slave", "p", "table", "address", "Port", "null", "interface", "export", "project", "state", "end", "server", "source", "period", "transfer", "target"], "discard": [" disccard", "reccard", "Discarded", "ainard", "discards", "aincard", "Discard", "recard", "Discards", "disccard", "confard", "confress", " Discard", " discards", "recarding", "recarded", "confcard", "ainarding", " Discress", "discarded", "ainarded", " discarding", " discarded", "recress", "confarded", " Discarded", "discress", "recards", " Disccard", "discarding", "Discarding"]}}
{"project": "qemu", "commit_id": "129c7d1c536d0c67a8781cb09fb5bdb3d0f6a2d0", "target": 1, "func": "static int hdev_open(BlockDriverState *bs, QDict *options, int flags,\n\n                     Error **errp)\n\n{\n\n    BDRVRawState *s = bs->opaque;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n\n\n\n\n\n\n    const char *filename = qdict_get_str(options, \"filename\");\n\n    char bsd_path[MAXPATHLEN] = \"\";\n\n    bool error_occurred = false;\n\n\n\n    /* If using a real cdrom */\n\n    if (strcmp(filename, \"/dev/cdrom\") == 0) {\n\n        char *mediaType = NULL;\n\n        kern_return_t ret_val;\n\n        io_iterator_t mediaIterator = 0;\n\n\n\n        mediaType = FindEjectableOpticalMedia(&mediaIterator);\n\n        if (mediaType == NULL) {\n\n            error_setg(errp, \"Please make sure your CD/DVD is in the optical\"\n\n                       \" drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        ret_val = GetBSDPath(mediaIterator, bsd_path, sizeof(bsd_path), flags);\n\n        if (ret_val != KERN_SUCCESS) {\n\n            error_setg(errp, \"Could not get BSD path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If a real optical drive was not found */\n\n        if (bsd_path[0] == '\\0') {\n\n            error_setg(errp, \"Failed to obtain bsd path for optical drive\");\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        /* If using a cdrom disc and finding a partition on the disc failed */\n\n        if (strncmp(mediaType, kIOCDMediaClass, 9) == 0 &&\n\n            setup_cdrom(bsd_path, errp) == false) {\n\n            print_unmounting_directions(bsd_path);\n\n            error_occurred = true;\n\n            goto hdev_open_Mac_error;\n\n        }\n\n\n\n        qdict_put(options, \"filename\", qstring_from_str(bsd_path));\n\n\n\nhdev_open_Mac_error:\n\n        g_free(mediaType);\n\n        if (mediaIterator) {\n\n            IOObjectRelease(mediaIterator);\n\n        }\n\n        if (error_occurred) {\n\n            return -ENOENT;\n\n        }\n\n    }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n\n\n    s->type = FTYPE_FILE;\n\n\n\n    ret = raw_open_common(bs, options, flags, 0, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n#if defined(__APPLE__) && defined(__MACH__)\n\n        if (*bsd_path) {\n\n            filename = bsd_path;\n\n        }\n\n        /* if a physical device experienced an error while being opened */\n\n        if (strncmp(filename, \"/dev/\", 5) == 0) {\n\n            print_unmounting_directions(filename);\n\n        }\n\n#endif /* defined(__APPLE__) && defined(__MACH__) */\n\n        return ret;\n\n    }\n\n\n\n    /* Since this does ioctl the device must be already opened */\n\n    bs->sg = hdev_is_sg(bs);\n\n\n\n    if (flags & BDRV_O_RDWR) {\n\n        ret = check_hdev_writable(s);\n\n        if (ret < 0) {\n\n            raw_close(bs);\n\n            error_setg_errno(errp, -ret, \"The device is not writable\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}", "idx": 19238, "substitutes": {"bs": ["ns", "bi", "ts", "lbs", "rs", "base", "sb", "bp", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "bid", "cs", "als", "gb", "Bs", "bos", "bps", "obs", "outs", "BS", "iss", "bis", "bl", "vs", "ses", "bh", "fb", "js", "ps", "b", "ks", "es", "os", "bes", "banks", "ds"], "options": ["values", "ts", "styles", "rates", "stats", "info", "fps", "settings", "json", "ports", "results", "ions", "plugins", "details", "option", "times", "vals", "ips", "points", "resources", "ops", "acl", "scope", "lines", "o", "enc", "als", "linux", "array", "bos", "args", "outs", "style", "config", "includes", "bits", "http", "properties", "opt", "errors", "es", "os", "Options", "opens", "states", "ors", "eps", "params"], "flags": ["types", "status", "fps", "stats", "FLAG", "fields", "settings", "faces", "ports", "Flags", "ils", "plugins", "details", "vals", "tails", "flag", "ips", "files", "ints", "utils", "ops", "items", "fs", "mask", "lines", "lf", "tools", "fl", "format", "args", " Flags", "features", "fts", "codes", "frames", "bits", "orts", "lag", "versions", "properties", "reads", "rules", "bytes", "parts", "errors", "groups", "states", "locks"], "errp": ["Err", " errP", "armP", " errfp", "armp", "err", "errP", "rrpre", "Erps", "arrP", " erP", "errpc", "erps", "derpc", "Erpc", "derpe", "armpc", "arrpa", "derp", "rrfp", "errpre", "frpe", " erf", "armpe", "erp", "rrf", "arrpe", " erp", "errr", "aerpc", "errpe", "errfp", "aerp", "derP", "errpa", " errr", "rrp", "rrpc", "Erfp", "aerP", "frpa", "errps", "derpa", "erP", "aerpe", "frP", " erpre", " errps", "frp", " errf", "rrP", "arrp", " errpc", "errf", "Erp", " errpre", "ErP"], "s": ["ns", "spec", "session", "ts", "sg", "stats", "rs", "f", "sv", "services", "service", "sie", "sb", "sl", "ss", "ls", "ops", "fs", "is", "o", "cs", "sn", "qs", "e", "ssl", "ses", "c", "ps", "si", "p", "secondary", "S", "b", "gs", "sys", "its", "a", "es", "os", "sets", "states", "sq", "sa"], "local_err": ["local_er", "remote_err", "Local_er", "remote_order", "Local_rr", "remote_status", "remote_er", "local_status", "local_order", "Local_err", "local_rr"], "ret": ["status", "data", "al", "bit", "ref", "alt", "rc", "nt", "reg", "rt", "lit", "fun", "result", "str", "flag", "match", "mem", "resp", "rets", "arr", "att", "val", "final", "re", "Ret", " result", " RET", "det", "rb", "rl", " Ret", "RET", "Return", "rep", "res", "fi", "success", "len"], "filename": ["data", "fp", "name", "f", "fil", "json", "settings", "buffer", "file", "phrase", "SourceFile", "loader", "java", "document", "kl", "files", "source", "acl", "tif", "username", "tools", "location", "jpg", "path", "kn", "utf", "length", "prefix", "which", "fd", "il", "url", "binary", "fn", "unc", "Filename", "bytes", "word", "dll", "params"], "bsd_path": ["bsd_pointer", "bsd_ath", "bsd_full", "bsd_stream", "bsd_data", "bsd24stream", "bsdd_path", "bsd2name", "bsdd_data", "bsds_name", "bsdxname", "bsd2ath", "bsdd_pointer", "bsd24clean", "bsd00pointer", "bsd_url", "bscd_stream", "bsl_prefix", "bsdxath", "bsd_clean", "bssd_loc", "bsd00path", "bsdxpath", "bsd2data", "bssd_enc", "bsl_path", "bsd_prefix", "bsds_path", "bssd_pointer", "bsd2path", "bscd_clean", "bsd2stream", "bsd00enc", "bsl_pointer", "bsd24url", "bsds_ath", "bsd6value", "bssd_path", "bsd24path", "bsdxfull", "bsds_data", "bscd_path", "bsvd_path", "bsd00loc", "bsl_ath", "bssd_ath", "bsdd_stream", "bsd6name", "bsd_name", "bscd_url", "bsd_value", "bsd6path", "bsd2pointer", "bsd_enc", "bssd_name", "bssd_full", "bsd_loc", "bsvd_name", "bsvd_value"], "mediaType": ["videoClass", "memoryClass", "audioClass", " mediatype", " mediaClass", "imageClass", "laClass", "mediaSource", "mediaUnit", " mediaUnit", "mediatype", "videoUnit", "audioSource", "mediaClass", "audioStyle", "laUnit", "materialStyle", "memoryName", "mediaStyle", "memoryTypes", "audioName", "materialName", "mediaName", "materialClass", "audioTypes", "laType", "memoryType", " mediaName", "imageTypes", " mediaStyle", "audioType", "latype", "mediaTypes", "resourceName", "audiotype", "memorySource", "resourceClass", "videoName", "materialType", " mediaTypes", "imageName", "imageType", "resourceUnit", " mediaSource", "audioUnit", "resourceType", "videoType"], "ret_val": ["retvalarg", "ret_Val", "resp_arr", " ret_Val", " ret2obj", "retvalvals", " ret_arg", "resp_val", "ret64val", "ret_obj", "respgcount", "retvalval", " ret2Val", "retgarr", "ret2obj", "respgval", "retgcount", "retaymsg", "ret_msg", "ret_vals", "ret_count", "ret2val", "ret64Val", "resp_count", " ret2vals", "retvalvalue", "ret_value", " ret_vals", "retgval", "retayval", "retgmsg", "ret2Val", "ret64vals", " ret_value", "retaycount", "ret_arg", "resp_msg", "ret2vals", " ret2val", "retayarr", "ret_arr", "ret64obj", "respgarr", " ret_obj", "respgmsg"]}}
{"project": "qemu", "commit_id": "d3d250bddb3f6aa6c26e9dadf10e82d9fd8bfce3", "target": 1, "func": "int scsi_bus_legacy_handle_cmdline(SCSIBus *bus)\n\n{\n\n    Location loc;\n\n    DriveInfo *dinfo;\n\n    int res = 0, unit;\n\n\n\n    loc_push_none(&loc);\n\n    for (unit = 0; unit < bus->info->max_target; unit++) {\n\n        dinfo = drive_get(IF_SCSI, bus->busnr, unit);\n\n        if (dinfo == NULL) {\n\n            continue;\n\n        }\n\n        qemu_opts_loc_restore(dinfo->opts);\n\n        if (!scsi_bus_legacy_add_drive(bus, dinfo->bdrv, unit, false, -1)) {\n\n            res = -1;\n\n            break;\n\n        }\n\n    }\n\n    loc_pop(&loc);\n\n    return res;\n\n}\n", "idx": 19243, "substitutes": {"bus": ["board", "plugin", "session", "data", "user", "base", "comment", "las", "series", "usb", "nt", "io", "service", "bridge", "feed", "Bus", "module", "block", "bc", "hub", "this", "object", "controller", "class", "build", "use", "config", "mount", "sync", "cat", "lib", "dev", "driver", "plug", "cache", "BUS", "lock", "http", "product", "boot", "proc", "loop", "serial", "connection", "os", "us", "book", "bug"], "loc": ["util", "spec", "global", "where", "data", "lim", "info", "las", "dir", "reg", "rc", "lit", "rel", "num", "root", "or", "region", "coll", "src", "lex", "ctx", "Loc", "l", "location", "rec", "vol", "tx", "los", "remote", "bas", "voc", "parent", "lc", "c", "lib", "LOC", "col", "error", "la", "route", "loop", "local", " location", "state", "iter", "lang", "desc", "co", "lat", "valid", " Loc"], "dinfo": ["cdinfo", "dsid", "ddata", "vdinit", "cdinf", "lInfo", "dInfo", "dsinfo", "ldinfo", " dafi", "dinit", "dlinf", "ldinf", "Dinfo", "dinf", " did", "cddata", " dinit", "ldafi", " dinf", "dapi", "vdinfo", "dlinit", "vddef", "dsstate", "ldInfo", "dlinfo", "dafi", "dldata", "dstate", "Dafi", "did", "dlstate", "dldef", "Dinf", "lapi", " dapi", "vdapi", "cdstate", "vdInfo", "linfo", "ldid", " ddef", "ddef", " dInfo", "vdinf", "dsInfo", "dsdata", "dsinf", "linf"], "unit": ["uri", "part", "scale", "un", " units", "direction", "element", "name", "base", "category", "component", "file", "num", "nit", "i", "module", "year", "type", "block", "station", "index", "pos", "model", "dim", "min", "nat", "label", "force", "units", "format", "size", "uni", "style", "site", "ui", "no", "value", "rule", "key", "limit", "temp", "Unit", "position", "device", "parent", "condition", "address", "col", "route", "domain", "u", "number", "weight", "connection", "port", "order", "version", "target", "mu"]}}
{"project": "FFmpeg", "commit_id": "fbd97184f8b68b2074b79a1698e4d9404292f7ca", "target": 1, "func": "static int link_filter_inouts(AVFilterContext *filt_ctx,\n\n                              AVFilterInOut **curr_inputs,\n\n                              AVFilterInOut **open_inputs, AVClass *log_ctx)\n\n{\n\n    int pad = filt_ctx->input_count, ret;\n\n\n\n    while (pad--) {\n\n        AVFilterInOut *p = *curr_inputs;\n\n        if (!p) {\n\n            av_log(log_ctx, AV_LOG_ERROR,\n\n                   \"Not enough inputs specified for the \\\"%s\\\" filter.\\n\",\n\n                   filt_ctx->filter->name);\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        *curr_inputs = (*curr_inputs)->next;\n\n\n\n        if (p->filter) {\n\n            if ((ret = link_filter(p->filter, p->pad_idx, filt_ctx, pad, log_ctx)) < 0)\n\n                return ret;\n\n            av_free(p->name);\n\n            av_free(p);\n\n        } else {\n\n            p->filter = filt_ctx;\n\n            p->pad_idx = pad;\n\n            insert_inout(open_inputs, p);\n\n        }\n\n    }\n\n\n\n    if (*curr_inputs) {\n\n        av_log(log_ctx, AV_LOG_ERROR,\n\n               \"Too many inputs specified for the \\\"%s\\\" filter.\\n\",\n\n               filt_ctx->filter->name);\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    pad = filt_ctx->output_count;\n\n    while (pad--) {\n\n        AVFilterInOut *currlinkn = av_mallocz(sizeof(AVFilterInOut));\n\n\n\n        currlinkn->filter  = filt_ctx;\n\n        currlinkn->pad_idx = pad;\n\n        insert_inout(curr_inputs, currlinkn);\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 19245, "substitutes": {"filt_ctx": ["filt_lib", "filt_cn", "filt_cache", "filt_wcs", "filtertx", "filt_context", "flt_obj", "filt_lc", "filtflib", "filt_ca", "filtlogcontext", "filt_obj", "flt_context", "filtrcontext", "filt_conn", "filtfanc", "filt2context", "filtingctx", "facet_ca", "filtlogcache", "flt_anc", "filt2loc", "filtingcontext", "flt_pkg", "filt2ctx", "filt_anc", "filtflc", "filtfcu", "flt_wcs", "filt_cu", "facet_lib", "filtrobj", "filterctx", "flt_conn", "filtrctx", "filtercontext", "filtfctx", "filterwcs", "flt_ctx", "flt_cn", "filtrloc", "filtingtx", "filt_tx", "flt_cu", "filtlogctx", "filtingconn", "filtloglc", "facet_cache", "flt_tx", "filtfcontext", "facet_ctx", "facet_lc", "filt_loc", "filt_pkg", "flt_loc", "facet_context", "filt2obj"], "curr_inputs": ["curr_controlp", "curr_controlws", "curr_outputw", "curr_inputerences", "curr_incb", "curr_intws", "curr_outputerences", "curr_turnerences", "curr_outputs", "curr_inputws", "curr_pulles", "curr_selects", "curr_outputb", "curr_refs", "curr_butions", "curr_contexts", "curr_contextb", "curr_pulls", "curr_butes", "curr_intp", "curr_turns", "curr_controles", "curr_columnerences", "curr_butd", "curr_inces", "curr_outputws", "curr_outputments", "curr_inputw", "curr_turnw", "curr_outputp", "curr_inputments", "curr_outputes", "curr_pulld", "curr_inputp", "curr_inputions", "curr_ints", "curr_refd", "curr_selectes", "curr_outputd", "curr_refments", "curr_columns", "curr_inputes", "curr_buts", "curr_selectb", "curr_columnw", "curr_inputb", "curr_controls", "curr_turnb", "curr_columnb", "curr_contextes", "curr_pullions", "curr_pullb", "curr_intes", "curr_incs", "curr_refes", "curr_inputd", "curr_outputions", "curr_pullments"], "open_inputs": ["open_inputfs", "open_inputfeatures", "open_outputes", "open_ints", "open_pulls", "open_intfs", "open_outputfs", "open_outputfeatures", "open_pullfeatures", "open_outputings", "open_outputs", "open_outputsets", "open_subjectfeatures", "open_pulles", "open_intes", "open_inputes", "open_intings", "open_subjects", "open_columns", "open_columnfs", "open_subjectes", "open_inputings", "open_columnes", "open_pullsets", "open_columnings", "open_subjectsets", "open_inputsets"], "log_ctx": ["logkxc", "loggctx", "lex_ctx", "job_tx", "loggtx", "log_xc", "job_ctx", "log_cas", " log_ci", "log_ctrl", "jobingcas", "job_ctrl", "jobingctx", "logingctx", "loggcas", "logksys", "log_ci", "logenxc", "logenctx", "log_sys", "logingctrl", "lex_xc", "logkctx", "logallctx", "logallcontext", "logallcmp", "Log_context", "Log_cmp", "lex_context", "Log_config", "log_cmp", "logensys", "loggcontext", "lex_sys", "logallconfig", "jobingctrl", "loggctrl", "log_tx", "jobingtx", "log_context", "job_cas", "logingcas", " log_context", "logencontext", "logvalcas", "loggci", "logvaltx", "logingtx", "Log_ctx", "logvalctrl", "log_config", "logvalctx", "logkcontext", " log_tx"], "ret": ["entry", "obj", "al", "ref", "alt", "reg", "r", "nt", "rc", "rt", "fun", "result", "job", "flag", "match", "ext", "run", "mem", "rf", "resp", "rets", "def", "get", "arg", "arr", "att", "val", "empty", "re", "Ret", "pre", "reset", "no", "value", "back", "det", "cat", "hard", "RET", "pat", "red", "rep", "res", "pet", "ft", "reply", "success", "len"], "pad": ["pc", "pt", "part", "scale", "dd", "offset", "db", "pid", "push", "pod", "sp", "Pad", "ping", "buffer", "tick", "type", "var", "padding", "quad", "kid", "index", "ptr", "pos", "adding", "sd", "pointer", "added", "ip", "sk", "fake", "gap", "att", "pg", "pre", "style", "adjust", "reset", "cel", "add", "length", "ad", "start", "delay", "id", "pend", "blank", "span", "paste", "mad", "post", "patch", "off", "crop", "address", "depth", "prep", "pat", "adr", "cap", "pick", "ada", "sid", "addr", "end", "port", "arp", "press", "ady", "amp", "len"], "p": ["pc", "at", "per", "wp", "part", "m", "point", "plugin", "s", "t", "data", "fp", "f", "jp", "op", "sp", "vp", "r", "pe", "n", "pl", "bp", "i", "cp", "lp", "ap", "o", "ip", "l", "pair", "d", "pp", "up", "pi", "pre", "e", "pa", "k", "primary", "v", "parent", "c", "ps", "post", "patch", "b", "pr", "param", "proc", "a", "api", "tp", "port", "np", "P", "u"], "currlinkn": ["currkeyen", "currcheckj", "currlinkns", "currelinkn", "currelinken", "curreLinkns", "currlinkp", "currclinkedconn", "currwalke", "currlinkin", "currclinkedj", "currkeyyn", "currswitchnw", "currlineen", "currlinee", "curreLinkner", "curreLinkyn", "currlinkyn", "currwalknw", "currlinken", "curreLinkin", "currwalkn", "currelinknw", "currelinkner", "currclinkj", "currlinkedp", "currclinkp", "currwalkin", "currLinkns", "currlinener", "currLinkin", "currelinkyn", "currlinkconn", "currlinens", "currelinkin", "currlinkedn", "currkeyn", "curreLinken", "currkeyp", "currclinkedn", "currLinkn", "currkeyner", "currswitchn", "currclinkconn", "currkeyj", "currwalkner", "currLinknw", "curreLinknw", "currcheckn", "currlinkedconn", "currLinken", "currcheckp", "currlinke", "currwalken", "currlinkj", "currclinkedp", "currLinkyn", "currwalkns", "currlinknw", "currlinkner", "currlinen", "currswitchner", "currlinkedj", "currlineyn", "currkeyconn", "currswitchin", "currelinke", "currLinke", "currcheckconn", "curreLinkn", "currLinkner", "currelinkns", "curreLinke", "currclinkn"]}}
{"project": "qemu", "commit_id": "46232aaacb66733d3e16dcbd0d26c32ec388801d", "target": 0, "func": "static void x86_cpu_common_class_init(ObjectClass *oc, void *data)\n\n{\n\n    X86CPUClass *xcc = X86_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(oc);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    xcc->parent_realize = dc->realize;\n\n    dc->realize = x86_cpu_realizefn;\n\n    dc->bus_type = TYPE_ICC_BUS;\n\n    dc->props = x86_cpu_properties;\n\n\n\n    xcc->parent_reset = cc->reset;\n\n    cc->reset = x86_cpu_reset;\n\n    cc->reset_dump_flags = CPU_DUMP_FPU | CPU_DUMP_CCOP;\n\n\n\n    cc->class_by_name = x86_cpu_class_by_name;\n\n    cc->parse_features = x86_cpu_parse_featurestr;\n\n    cc->has_work = x86_cpu_has_work;\n\n    cc->do_interrupt = x86_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = x86_cpu_exec_interrupt;\n\n    cc->dump_state = x86_cpu_dump_state;\n\n    cc->set_pc = x86_cpu_set_pc;\n\n    cc->synchronize_from_tb = x86_cpu_synchronize_from_tb;\n\n    cc->gdb_read_register = x86_cpu_gdb_read_register;\n\n    cc->gdb_write_register = x86_cpu_gdb_write_register;\n\n    cc->get_arch_id = x86_cpu_get_arch_id;\n\n    cc->get_paging_enabled = x86_cpu_get_paging_enabled;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = x86_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_memory_mapping = x86_cpu_get_memory_mapping;\n\n    cc->get_phys_page_debug = x86_cpu_get_phys_page_debug;\n\n    cc->write_elf64_note = x86_cpu_write_elf64_note;\n\n    cc->write_elf64_qemunote = x86_cpu_write_elf64_qemunote;\n\n    cc->write_elf32_note = x86_cpu_write_elf32_note;\n\n    cc->write_elf32_qemunote = x86_cpu_write_elf32_qemunote;\n\n    cc->vmsd = &vmstate_x86_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = CPU_NB_REGS * 2 + 25;\n\n#ifndef CONFIG_USER_ONLY\n\n    cc->debug_excp_handler = breakpoint_handler;\n\n#endif\n\n    cc->cpu_exec_enter = x86_cpu_exec_enter;\n\n    cc->cpu_exec_exit = x86_cpu_exec_exit;\n\n}\n", "idx": 19253, "substitutes": {"oc": ["pc", "org", "cca", "ob", "cus", "rc", "acc", "oca", "ok", "anc", "bc", "toc", "ocr", "loc", "aco", "oper", "mic", "mc", "bb", "object", "o", "roc", "usc", "nc", "ac", "oid", "oci", "tc", "soc", "ucc", "c", "uc", "ogg", "ck", "oco", "output", "ec", "alloc", "unc", "OC", "co", "isc", "mac", "voc"], "data": ["board", "Data", "dd", "func", "rc", "inc", "raw", "di", "def", "load", "d", "rec", "config", "device", "da", "cache", "fee", "dat", "alloc", "DATA", "desc", "fi", "ds", "input"], "xcc": ["xCC", "Xuc", "xccca", "xesuc", "rxcf", "rxcc", "rxcca", " xCC", "fcc", "xccf", "exec", "fcf", "excca", "XCC", "xcuc", " xec", "xcf", "xec", "xccc", "rxuc", "exCC", "xcca", "xcCC", "excc", "Xec", "xescca", "fuc", "fcca", " xcca", "Xcc", "xuc", "xesCC", "Xcca", "xescc"], "cc": ["pc", "code", "cca", "ctl", "vc", "CC", "RC", "conn", "rc", "cm", "inc", "bec", "cf", "acc", "g", "cb", "bc", "PC", "ctx", "fc", "mc", "bb", "ctrl", "lv", "ca", "cs", "pg", "BC", "ce", "nc", "ac", "go", "comp", "ci", "DC", "tc", "xc", "config", "sc", "cu", "ga", "ucc", "cl", " gcc", "c", "lc", "client", "cur", "cmd", "uc", "ck", "cache", "cmp", "ec", "cd", "cn", "cast", "co", "mac", "kk", "cci"], "dc": ["dn", "db", "cdn", "cca", "cci", "vc", "conn", "CC", "rc", "gc", "duc", "cm", "de", "inc", "cf", "acc", "bc", "dt", "di", "mc", "fc", "ca", "design", "d", "df", "ac", "disc", "DC", "tc", "dm", "sc", "ga", "cr", "lc", "c", "da", "uc", "doc", "ck", "dat", "ec", "cd", "mac", "ds", "director"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qpa_init_in (HWVoiceIn *hw, audsettings_t *as)\n\n{\n\n    int error;\n\n    static pa_sample_spec ss;\n\n    audsettings_t obt_as = *as;\n\n    PAVoiceIn *pa = (PAVoiceIn *) hw;\n\n\n\n    ss.format = audfmt_to_pa (as->fmt, as->endianness);\n\n    ss.channels = as->nchannels;\n\n    ss.rate = as->freq;\n\n\n\n    obt_as.fmt = pa_to_audfmt (ss.format, &obt_as.endianness);\n\n\n\n    pa->s = pa_simple_new (\n\n        conf.server,\n\n        \"qemu\",\n\n        PA_STREAM_RECORD,\n\n        conf.source,\n\n        \"pcm.capture\",\n\n        &ss,\n\n        NULL,                   /* channel map */\n\n        NULL,                   /* buffering attributes */\n\n        &error\n\n        );\n\n    if (!pa->s) {\n\n        qpa_logerr (error, \"pa_simple_new for capture failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n    hw->samples = conf.samples;\n\n    pa->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!pa->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&pa->pt, qpa_thread_in, hw, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n fail2:\n\n    pa_simple_free (pa->s);\n\n    pa->s = NULL;\n\n fail1:\n\n    return -1;\n\n}\n", "idx": 19256, "substitutes": {"hw": ["wp", "wei", "instance", "war", "fw", "wx", "aws", "vc", "wi", "gio", "wy", "wo", "wl", "num", "dq", "ohm", "sw", "hop", "rh", "wcs", "ow", "ctx", " HW", "iw", "wd", "kw", "lv", "vm", "wk", "gp", "ht", "him", "sh", "zh", "ww", "wire", "w", "nu", "gpu", "haw", "cu", "bh", "cli", "lc", "nw", "qq", "wm", "hp", "rw", "hm", "tw", "cmp", "hh", "wu", "sys", "wh", "h", "wa", "wn", "iov", "ha", "aff", "hs", "mm", "np", "cow", "conn"], "as": ["ans", "asu", "ms", "at", "ts", "au", "s", "rs", "ras", "conf", "aws", "ais", "ai", "ar", "As", "ams", "or", "ast", "am", "mas", "auth", "nas", "ap", "ass", "asp", "act", "is", "asi", "acs", "ach", "alias", "ac", "av", "ay", "asa", "asm", "bas", "AS", "ps", "rss", "jas", "aw", "a", "ase", "os", "ma", "pas", "an", "sa", "asc"], "error": ["ror", "rr", "data", "info", "core", "err", "call", "name", "all", "f", "op", "comment", "rc", "r", "debug", "result", "exc", "root", "type", "rh", "loc", "warning", "var", "orig", "magic", "self", "ae", "o", "bad", " Error", "unknown", "ERROR", "no", "last", "notice", "e", "danger", "parent", "row", "errors", "ace", "message", "valid", " e", "Error", "order", "success", " err", "bug"], "ss": ["ns", "na", "spec", "au", "s", "bs", "rs", "conf", "settings", "ess", "pe", "sb", "sw", "ross", " ps", "ls", "pb", "ass", "asp", "fs", "cas", "\u00df", "sk", "css", "cs", "tz", "su", "hess", "ssh", " s", "iss", "sn", "config", "pps", "sc", "ssl", "sf", "vs", "ses", "ps", "si", "rss", "sts", "ks", "oss", "params", "es", "uss", " iss", " SS", "se", "sq", "server", "sa", "ds", "SS"], "pa": ["pc", "na", "qua", "au", "ampa", "base", "jp", "media", "pn", "pe", "pd", "fa", "pan", "PA", "apa", "sb", "pm", "bp", "cp", "Pa", "lp", "ctx", "python", "pb", "pai", "ua", "ba", "ca", "po", "appa", "ta", "bank", "gp", "ota", "pi", "audio", "ama", "pse", "ao", "lc", "ka", "ps", "si", "qa", "p", "ana", "ppa", "pr", "va", "la", "ph", "a", "api", "ja", "opa", "pu", "ia", "ma", "pha", "pas", "an", "sa"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_compute_fprf (uint64_t arg, uint32_t set_fprf)\n\n{\n\n    CPU_DoubleU farg;\n\n    int isneg;\n\n    int ret;\n\n    farg.ll = arg;\n\n    isneg = float64_is_neg(farg.d);\n\n    if (unlikely(float64_is_nan(farg.d))) {\n\n        if (float64_is_signaling_nan(farg.d)) {\n\n            /* Signaling NaN: flags are undefined */\n\n            ret = 0x00;\n\n        } else {\n\n            /* Quiet NaN */\n\n            ret = 0x11;\n\n        }\n\n    } else if (unlikely(float64_is_infinity(farg.d))) {\n\n        /* +/- infinity */\n\n        if (isneg)\n\n            ret = 0x09;\n\n        else\n\n            ret = 0x05;\n\n    } else {\n\n        if (float64_is_zero(farg.d)) {\n\n            /* +/- zero */\n\n            if (isneg)\n\n                ret = 0x12;\n\n            else\n\n                ret = 0x02;\n\n        } else {\n\n            if (isden(farg.d)) {\n\n                /* Denormalized numbers */\n\n                ret = 0x10;\n\n            } else {\n\n                /* Normalized numbers */\n\n                ret = 0x00;\n\n            }\n\n            if (isneg) {\n\n                ret |= 0x08;\n\n            } else {\n\n                ret |= 0x04;\n\n            }\n\n        }\n\n    }\n\n    if (set_fprf) {\n\n        /* We update FPSCR_FPRF */\n\n        env->fpscr &= ~(0x1F << FPSCR_FPRF);\n\n        env->fpscr |= ret << FPSCR_FPRF;\n\n    }\n\n    /* We just need fpcc to update Rc1 */\n\n    return ret & 0xF;\n\n}\n", "idx": 19274, "substitutes": {"arg": ["work", "ark", "func", "f", "call", "agg", "reg", "inc", "ar", "option", "result", "g", "flag", "agn", "var", "Arg", "orig", "amp", "arr", "arc", "val", "array", "args", "ax", "ig", "ang", "config", "asm", "ag", "par", "lag", "p", "argument", "play", "inter", "next", "param", "alloc", "opt", "len", "addr", "arp", "aug", "target", "input"], "set_fprf": ["set_fPRfs", "set_fprc", "set_fPRf", "set_rfprc", "set_rfprF", "set_fcrf", "set_fwrF", "set_rfprfx", "set_bPRfs", "set_fwrf", "set_fprF", "set_bprc", "set_bPRc", "set_fprfx", "set_ftrF", "set_ftrfx", "set_fcrc", "set_fcrfs", "set_bprf", "set_fwrc", "set_rfprf", "set_ftrf", "set_fprfs", "set_bPRf", "set_ftrc", "set_fwrfx", "set_bprfs", "set_fPRc"], "farg": ["fnarg", " fark", "fargument", "farm", "targ", "ifarg", "ifarm", " fault", "fag", "ofault", "fack", "forall", "tplay", "bvar", "ofarg", " fag", "ofag", "fargs", "fall", " fall", "fnag", " fack", "fvar", "ifuse", " fArg", "forag", "ball", "frag", "Fargs", "tArg", "forault", " fuse", "barg", "bargument", "frark", " farc", "fArg", "ofark", "forarg", "FArg", "frgen", "frack", "forarm", " fgen", "fnvar", "fgen", "fplay", "fgrad", " fargs", "ofarc", "forvar", "tack", "ifgrad", "fuse", " farm", "ifarc", "forargument", "forark", "fruse", "frplay", "fnuse", "frvar", "ifag", "fault", "Farg", "frarg", " fvar", "ifgen", "forarc", "ifark", " fgrad", "farc", "fark", "tag", "targs", " fargument", "forgrad", " fplay"], "isneg": ["Isneg", "IsNeg", "silrel", " iscoll", "isnan", "risnan", "issNeg", " isnan", "risneg", " isgen", "osnegative", "risnegative", "isspred", "osnan", "risminus", "issgen", "isminus", " ispred", "isscoll", "issnegative", " isbad", "misneg", " isNeg", "silneg", "silNeg", "ipneg", "osneg", "miscoll", "issneg", "isnegative", "ispred", "ipnegative", " isnegative", "osminus", "isgen", "iscoll", "Isnegative", "issbad", "Isbad", "misnegative", "silpred", "Isgen", " isrel", "issrel", "isrel", "isbad", "ipbad", " isminus", "misbad", "isNeg"], "ret": ["offset", "bit", "ref", "nt", "result", "job", "ut", "att", "feat", "id", "fit", "rev", "hard", "ert", "pat", "res", "opt", "mt", "len", "part", "rc", "fun", "arr", "art", "Ret", "bf", "cat", " Ret", "pret", "RET", "gt", "pet", "ft", "status", "code", "alt", "lit", "rt", "match", "mem", "val", "final", "re", "back", "xt", "rl", "sum", "reply", "value", "success", "db", "data", "info", "ort", "let", "reg", "flag", "ext", "def", "rets", "lt", "out", "format", "det", "cur", "error", "red", "eval", "usr"]}}
{"project": "qemu", "commit_id": "df8002103c3e262dc40d7b5e0eb2171ba28b1d63", "target": 0, "func": "void vga_ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    VGACommonState *s = opaque;\n\n    int index;\n\n\n\n    /* check port range access depending on color/monochrome mode */\n\n    if (vga_ioport_invalid(s, addr)) {\n\n        return;\n\n    }\n\n#ifdef DEBUG_VGA\n\n    printf(\"VGA: write addr=0x%04x data=0x%02x\\n\", addr, val);\n\n#endif\n\n\n\n    switch(addr) {\n\n    case VGA_ATT_W:\n\n        if (s->ar_flip_flop == 0) {\n\n            val &= 0x3f;\n\n            s->ar_index = val;\n\n        } else {\n\n            index = s->ar_index & 0x1f;\n\n            switch(index) {\n\n            case VGA_ATC_PALETTE0 ... VGA_ATC_PALETTEF:\n\n                s->ar[index] = val & 0x3f;\n\n                break;\n\n            case VGA_ATC_MODE:\n\n                s->ar[index] = val & ~0x10;\n\n                break;\n\n            case VGA_ATC_OVERSCAN:\n\n                s->ar[index] = val;\n\n                break;\n\n            case VGA_ATC_PLANE_ENABLE:\n\n                s->ar[index] = val & ~0xc0;\n\n                break;\n\n            case VGA_ATC_PEL:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            case VGA_ATC_COLOR_PAGE:\n\n                s->ar[index] = val & ~0xf0;\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n        }\n\n        s->ar_flip_flop ^= 1;\n\n        break;\n\n    case VGA_MIS_W:\n\n        s->msr = val & ~0x10;\n\n        s->update_retrace_info(s);\n\n        break;\n\n    case VGA_SEQ_I:\n\n        s->sr_index = val & 7;\n\n        break;\n\n    case VGA_SEQ_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write SR%x = 0x%02x\\n\", s->sr_index, val);\n\n#endif\n\n        s->sr[s->sr_index] = val & sr_mask[s->sr_index];\n\n        if (s->sr_index == VGA_SEQ_CLOCK_MODE) {\n\n            s->update_retrace_info(s);\n\n        }\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_PEL_IR:\n\n        s->dac_read_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 3;\n\n        break;\n\n    case VGA_PEL_IW:\n\n        s->dac_write_index = val;\n\n        s->dac_sub_index = 0;\n\n        s->dac_state = 0;\n\n        break;\n\n    case VGA_PEL_D:\n\n        s->dac_cache[s->dac_sub_index] = val;\n\n        if (++s->dac_sub_index == 3) {\n\n            memcpy(&s->palette[s->dac_write_index * 3], s->dac_cache, 3);\n\n            s->dac_sub_index = 0;\n\n            s->dac_write_index++;\n\n        }\n\n        break;\n\n    case VGA_GFX_I:\n\n        s->gr_index = val & 0x0f;\n\n        break;\n\n    case VGA_GFX_D:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write GR%x = 0x%02x\\n\", s->gr_index, val);\n\n#endif\n\n        s->gr[s->gr_index] = val & gr_mask[s->gr_index];\n\n        vga_update_memory_access(s);\n\n        break;\n\n    case VGA_CRT_IM:\n\n    case VGA_CRT_IC:\n\n        s->cr_index = val;\n\n        break;\n\n    case VGA_CRT_DM:\n\n    case VGA_CRT_DC:\n\n#ifdef DEBUG_VGA_REG\n\n        printf(\"vga: write CR%x = 0x%02x\\n\", s->cr_index, val);\n\n#endif\n\n        /* handle CR0-7 protection */\n\n        if (s->cr[VGA_CRTC_V_SYNC_END] & VGA_CR11_LOCK_CR0_CR7) {\n\n            if (s->cr_index <= VGA_CRTC_OVERFLOW) {\n\n                /* can always write bit 4 of CR7 */\n\n                if (s->cr_index == VGA_CRTC_OVERFLOW) {\n\n                    s->cr[VGA_CRTC_OVERFLOW] =\n\n                        (s->cr[VGA_CRTC_OVERFLOW] & ~0x10) | (val & 0x10);\n\n                }\n\n                return;\n\n            } else if ((vga_cga_hacks & VGA_CGA_HACK_FONT_HEIGHT) &&\n\n                       !(s->sr[VGA_SEQ_CLOCK_MODE] & VGA_SR01_CHAR_CLK_8DOTS)) {\n\n                /* extra CGA compatibility hacks (not in standard VGA) */\n\n                if (s->cr_index == VGA_CRTC_MAX_SCAN &&\n\n                    val == 7 &&\n\n                    (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    return;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_START &&\n\n                           val == 6 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xd;\n\n                } else if (s->cr_index == VGA_CRTC_CURSOR_END &&\n\n                           val == 7 &&\n\n                           (s->cr[VGA_CRTC_MAX_SCAN] & 0xf) == 0xf) {\n\n                    val = 0xe;\n\n                }\n\n            }\n\n        }\n\n        s->cr[s->cr_index] = val;\n\n\n\n        switch(s->cr_index) {\n\n        case VGA_CRTC_H_TOTAL:\n\n        case VGA_CRTC_H_SYNC_START:\n\n        case VGA_CRTC_H_SYNC_END:\n\n        case VGA_CRTC_V_TOTAL:\n\n        case VGA_CRTC_OVERFLOW:\n\n        case VGA_CRTC_V_SYNC_END:\n\n        case VGA_CRTC_MODE:\n\n            s->update_retrace_info(s);\n\n            break;\n\n        }\n\n        break;\n\n    case VGA_IS1_RM:\n\n    case VGA_IS1_RC:\n\n        s->fcr = val & 0x10;\n\n        break;\n\n    }\n\n}\n", "idx": 19290, "substitutes": {"opaque": ["operacity", "oponymous", "Opaque", "opedoc", "cataque", " opacs", " opoc", " opacity", "operatile", "opedacs", "opatile", "opacity", "cataques", "catacity", "operaque", "opedonymous", "Opoc", "opedaque", " opatile", "opacs", " oponymous", "Opacs", "opoc", "catatile", "Oponymous", "opaques", "operaques", " opaques"], "addr": ["part", "rr", "offset", "db", "code", "mode", "x", "ref", "eth", "rc", "r", "ord", "align", "hop", "ast", "src", "node", "loc", "ext", "ptr", "pos", "slice", "pointer", "ip", "host", "ack", "slot", "layer", "alias", "oid", "socket", "prefix", "ad", "xxx", "dr", "fd", "asm", "buf", "device", "seq", "cmd", "kt", "url", "address", "pad", "arch", "adr", "route", "sid", "interface", "alloc", "ace", "amd", "port", "server", "mac", "attr", "amp"], "val": ["Val", "stat", "al", "x", "ref", "bit", "pl", "var", "pos", "exec", "sol", "nil", "tx", "elt", "lib", "p", "vt", "aval", "valid", "pt", "len", "values", "Value", "cal", "vals", "ld", "pol", "vert", "arg", "arr", "vol", "slot", "fl", "ol", "rot", "key", "xxx", "bl", "v", "update", "item", "ret", "base", "alt", "lit", "loc", "sel", "ind", "mem", "byte", "vl", "VAL", "serv", "buf", "b", "live", "py", "value", "data", "func", "all", "buffer", "sl", "slice", "dim", "def", "bo", "fail", "unit", "col", "eval", "local", "el"], "s": ["ns", "set", "spec", "full", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "us", "sets", "comments", "m", "ts", "sg", "rs", "aws", "self", "o", "sk", "su", "tests", "si", "S", "a", "hs", "an", "ds", "status", "uns", "f", "r", "sb", "as", "l", "ins", "w", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "state", "states", "sq", "sf", "session", "t", "request", "conf", "stats", "services", "n", "g", "i", "sl", "ls", "fs", "xs", "is", "sites", "args", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "its", "os", "server", "se", "south", "y", "u"], "index": ["point", "offset", "x", "element", "full", "inc", "align", "num", "pos", "Index", "run", "label", "new", "path", "length", "config", "prefix", "id", "output", "loop", "end", "valid", "column", "ion", "len", "input", "search", "sort", "count", "pointer", "object", "slot", "size", "xxx", "key", "update", "fff", "condition", "weight", "find", "list", "instance", "f", "image", "match", "loc", "node", "ind", "byte", "date", "host", "sync", "position", "address", "edge", "value", "connect", "success", "version", "data", "i", "module", "ctx", "slice", "dim", "active", "member", "site", "insert", "unit", "error", "level", "number", "body", "section"]}}
{"project": "qemu", "commit_id": "913440249ea2e697177e9d43167ac325a8dfe907", "target": 0, "func": "static int usbnet_can_receive(NetClientState *nc)\n\n{\n\n    USBNetState *s = qemu_get_nic_opaque(nc);\n\n\n\n    if (!s->dev.config) {\n\n        return 0;\n\n    }\n\n\n\n    if (is_rndis(s) && s->rndis_state != RNDIS_DATA_INITIALIZED) {\n\n        return 1;\n\n    }\n\n\n\n    return !s->in_len;\n\n}\n", "idx": 19291, "substitutes": {"nc": ["ns", "pc", "dc", "cdn", "cus", "ct", "conn", "ng", "rc", "nt", "ne", "n", "nic", "nec", "sb", "bc", "ctx", "fc", "mc", "enc", "cs", "nm", "sn", "rn", "NC", "sc", "lc", "c", "nw", "kt", "osc", "ec", "unc", "cn", "nn", "cv", "cc"], "s": ["ns", "ms", "spec", "ts", "sg", "sis", "stats", "rs", "f", "settings", "services", "n", "sb", "g", "i", "sl", "ss", "ls", "src", "ops", "fs", "xs", "self", "is", "o", "cs", "als", "sports", "d", "sn", "qs", "e", "ssl", "k", "ses", "v", "sync", "c", "ps", "si", "js", "sym", "p", "S", "ks", "b", "http", "gs", "sys", "a", "es", "os", "state", "hs", "parts", "states", "sq", "ds", "u"]}}
{"project": "qemu", "commit_id": "b63c7f6b77145c109d66a62bb3b6efe12b80d62b", "target": 0, "func": "static void dhcp_decode(const uint8_t *buf, int size,\n\n                        int *pmsg_type)\n\n{\n\n    const uint8_t *p, *p_end;\n\n    int len, tag;\n\n\n\n    *pmsg_type = 0;\n\n\n\n    p = buf;\n\n    p_end = buf + size;\n\n    if (size < 5)\n\n        return;\n\n    if (memcmp(p, rfc1533_cookie, 4) != 0)\n\n        return;\n\n    p += 4;\n\n    while (p < p_end) {\n\n        tag = p[0];\n\n        if (tag == RFC1533_PAD) {\n\n            p++;\n\n        } else if (tag == RFC1533_END) {\n\n            break;\n\n        } else {\n\n            p++;\n\n            if (p >= p_end)\n\n                break;\n\n            len = *p++;\n\n            dprintf(\"dhcp: tag=0x%02x len=%d\\n\", tag, len);\n\n\n\n            switch(tag) {\n\n            case RFC2132_MSG_TYPE:\n\n                if (len >= 1)\n\n                    *pmsg_type = p[0];\n\n                break;\n\n            default:\n\n                break;\n\n            }\n\n            p += len;\n\n        }\n\n    }\n\n}\n", "idx": 19301, "substitutes": {"buf": ["Buffer", "m", "br", "data", "fp", "f", "pool", "buffer", "rc", "r", "num", "bp", "cb", "cp", "padding", "ctx", "pb", "ptr", "slice", "mem", "count", "header", "array", "path", "ffff", "queue", "config", "length", "fd", "buff", "batch", "v", "c", "tmp", "seq", "rb", "binary", "uc", "b", "cache", "alloc", "port", "bag", "uf", "np"], "size": ["scale", "offset", "s", "code", "small", "data", "capacity", "SIZE", "rc", "from", "n", "sized", "num", "i", "six", "z", "loc", "sec", "pos", "en", "count", "enc", "page", "l", "sn", "ize", "length", "e", "v", "c", "cache", "Size", "end"], "pmsg_type": ["pmessage_id", "pmsg_no", "pmsg_set", "pmessage_unit", "pmsg_port", "pmessage_port", "pmessage_types", "pmsgfport", "pmessage_type", "pmsgfno", "pmsg_unit", "pmsgfid", "pmsg_id", "pmsgftype", "pmsg_types", "pmessage_set", "pmessage_no"], "p": ["pc", "at", "per", "wp", "m", "point", "j", "pid", "code", "t", "data", "fp", "x", "f", "jp", "op", "sp", "r", "pe", "n", "pm", "g", "i", "bp", "cp", "lp", "padding", "python", "pb", "ap", "pos", "pointer", "parser", "o", "po", "dp", "ip", "l", "pair", "d", "pp", "pre", "pi", "length", "e", "pa", "ep", "v", "c", "ps", "patch", "b", "cache", "param", "proc", "api", "tp", "py", "port", "np", "progress", "P", "u"], "p_end": ["P_offset", "p0ad", "p_ending", " p_ending", " p_enter", "p00enter", "P_ad", "P_End", "p_max", "p_start", "p_offset", "P_start", "p00begin", "p00end", "p0start", " p_begin", "p_End", "P_max", "p0offset", "p_begin", "p0end", "p00ending", "p_ad", "p_enter", "p_ended", "P_end", "P_ended"], "len": ["lon", "part", "bin", "pid", "code", "data", "fat", "name", "ref", "f", "sp", "lit", "n", "pl", "str", "num", "loc", "lp", "pos", "min", "en", "count", "enc", "po", "lf", "ln", "l", "label", "val", "fl", "le", "pre", "length", "id", "ler", "limit", "rev", "lc", "c", "seq", "lib", "line", "la", "field", "lin", "end", "lang", "el", "li", "Len"], "tag": ["stat", "code", "data", "name", "token", "ref", "comment", "op", "reg", "r", "pe", "hop", "num", "year", "block", "type", "match", "loc", "var", "month", "method", "pos", "count", "date", "po", "enc", "bad", "ack", "Tag", "prop", "gap", "class", "format", "bug", "feat", "pre", "style", "use", "length", "id", "key", "par", "ag", "cat", "TAG", "c", "seq", "patch", "post", "lc", "line", "cache", "feature", "col", "tail", "field", "co", "lang", "word", "end"]}}
{"project": "qemu", "commit_id": "ddb603ab6c981c1d67cb42266fc700c33e5b2d8f", "target": 0, "func": "static int xhci_fire_ctl_transfer(XHCIState *xhci, XHCITransfer *xfer)\n\n{\n\n    XHCITRB *trb_setup, *trb_status;\n\n    uint8_t bmRequestType;\n\n\n\n    trb_setup = &xfer->trbs[0];\n\n    trb_status = &xfer->trbs[xfer->trb_count-1];\n\n\n\n    trace_usb_xhci_xfer_start(xfer, xfer->epctx->slotid,\n\n                              xfer->epctx->epid, xfer->streamid);\n\n\n\n    /* at most one Event Data TRB allowed after STATUS */\n\n    if (TRB_TYPE(*trb_status) == TR_EVDATA && xfer->trb_count > 2) {\n\n        trb_status--;\n\n    }\n\n\n\n    /* do some sanity checks */\n\n    if (TRB_TYPE(*trb_setup) != TR_SETUP) {\n\n        DPRINTF(\"xhci: ep0 first TD not SETUP: %d\\n\",\n\n                TRB_TYPE(*trb_setup));\n\n        return -1;\n\n    }\n\n    if (TRB_TYPE(*trb_status) != TR_STATUS) {\n\n        DPRINTF(\"xhci: ep0 last TD not STATUS: %d\\n\",\n\n                TRB_TYPE(*trb_status));\n\n        return -1;\n\n    }\n\n    if (!(trb_setup->control & TRB_TR_IDT)) {\n\n        DPRINTF(\"xhci: Setup TRB doesn't have IDT set\\n\");\n\n        return -1;\n\n    }\n\n    if ((trb_setup->status & 0x1ffff) != 8) {\n\n        DPRINTF(\"xhci: Setup TRB has bad length (%d)\\n\",\n\n                (trb_setup->status & 0x1ffff));\n\n        return -1;\n\n    }\n\n\n\n    bmRequestType = trb_setup->parameter;\n\n\n\n    xfer->in_xfer = bmRequestType & USB_DIR_IN;\n\n    xfer->iso_xfer = false;\n\n    xfer->timed_xfer = false;\n\n\n\n    if (xhci_setup_packet(xfer) < 0) {\n\n        return -1;\n\n    }\n\n    xfer->packet.parameter = trb_setup->parameter;\n\n\n\n    usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n\n\n    xhci_try_complete_packet(xfer);\n\n    if (!xfer->running_async && !xfer->running_retry) {\n\n        xhci_kick_epctx(xfer->epctx, 0);\n\n    }\n\n    return 0;\n\n}\n", "idx": 19307, "substitutes": {"xhci": ["Xhdi", "XHci", "xhcci", "xhki", "XHdi", "xHcci", "Xhci", "Xhki", "XHcci", "xHki", "xHci", "xHdi", "xhsdi", "xhski", "Xhcci", "xhscci", "xhsci", "xhdi", "XHki"], "xfer": ["sexporter", "xf", " xclude", "crossfit", "rxf", "fxfar", " xtransfer", "ycer", "workfer", "xfar", "fxporter", " xfen", "hyference", "fxfr", "txfer", "ylference", "helfr", "rxfer", "rxpire", "config", "yfort", "id", "send", "hyfit", "yference", "extransfer", "txfr", "wfer", "xxfr", "workfen", "xce", "yf", " xpire", "axfer", "yxfer", "sexfer", "crossFER", "imference", " xcer", "crossporter", "axporter", "wfen", "xfeature", "crosscer", "ylf", "helfort", "crossfer", "lexference", "axputer", "pxformer", " xferred", "axfar", "nexcer", "rputer", "workpire", "elfort", "xiter", " xfar", "workference", "elference", "worktransfer", "imformer", "uxper", "sexper", "yxfar", "helference", "helfer", "helporter", "yce", " xce", "fxiter", "rxporter", "waporter", "hyfer", "nexporter", "pxtransfer", "uxiter", "xfit", "ylfer", "axiter", "exference", "crossf", " xformer", "exfer", "txference", "transfer", "xsference", " xfeature", "lexclude", "crossference", "excer", "rcf", "ylfen", "lexfer", "lexporter", "wafeature", "wference", "imfer", "axfr", "yxFER", "sexiter", "type", "lextransfer", "xtransfer", "rfar", "function", "crossfar", "this", "xsfen", "xferred", "xfen", "xpire", "wafer", "xcf", " xf", "xfort", "uxfer", "xxfer", "yferred", "axclude", "axcer", "elporter", "xxfar", "c", "rfer", "fxference", " xcf", "hyporter", "waference", "addr", "ylce", "nexfer", "xformer", "reply", "func", "xsporter", " xputer", "xference", "ylferred", "xxFER", " xference", "yporter", "xxference", "g", "xFER", " xporter", "axference", "elfer", "axper", "get", "xclude", "imtransfer", "xsfer", " xFER", "xputer", "workf", "nexfit", "hyfar", "yfer", "pxference", "workfar", "event", "xfr", "axcf", "add", "nexference", "yltransfer", "txFER", "workporter", "xcer", "crossce", "_", " xfr", "xper", "yputer", "wporter", "xporter", "lexcer", "uxporter", "lexfeature", "yxference", "heliter", "pxfer", "fxfer"], "trb_setup": ["trbb_summary", "trbi_set", "trf_login", "trbJsetup", "trx_site", "trf_status", "trf_settings", "trx_update", "trr_trigger", "trbi_setup", "trb2setup", "trb2config", "trx_set", "trb_settings", "trr_setup", "trbJtrigger", "trbi_settings", "trb2set", "trb_site", "trb__setup", "trb_Setup", "trb__Setup", "trb_trigger", "trr_set", "trf_info", "trbb_setup", "trb_update", "trb_login", "trb_sync", "trf_Setup", "trbb_config", "trbi_config", "trbi_status", "trb__lock", "trf_set", "trb_info", "trb__status", "trb_set", "trbb_spec", "trb2boot", "trf_setup", "trbi_boot", "trb_config", "trr_update", "trf_lock", "trb_spec", "trb__info", "trbJupdate", "trx_setup", "trbJset", "trf_sync", "trb_lock", "trb_boot", "trb__settings", "trb_summary"], "trb_status": ["trB_update", "trf_status", "trB_stat", "trb_source", "trb_score", "trb2setup", "trf_state", "trr_status", "trbs_summary", "trr_setup", "trB_setup", "trb2stat", "trb_complete", "trr_complete", "trf_mode", "trb_mode", "trb_update", "trbs_prefix", "trb_id", "trb_prefix", "trb_progress", "trB_status", "trf_type", "trb_stat", "trbs_status", "trb_type", "trr_id", "trB_source", "trB_progress", "trb_state", "trb2status", "trr_stat", "trb2complete", "trb_summary", "trr_score", "trbs_source"], "bmRequestType": ["bmCommandTypes", "bmrequestType", "BMResponseStyle", "nbCommandInfo", "BMResponseType", "bmMessageID", "cmRequestTyp", "nbCommandtype", "bmrequestInfo", "bmResponseType", "cmResponseTyp", "bmCommandStyle", "bmCommandtype", "BMRequestInfo", "bm_Types", "bmResponseTyp", "cmResponseType", "BMRequestTypes", "cmResponseID", "cmRequestTypes", "bm_Info", "nbCommandTypes", "cmRequestID", "bmOperationID", "bmResponseStyle", "BMRequestStyle", "nbRequestTypes", "bmMessageTypes", "bmCommandInfo", "bm_Type", "nbRequestInfo", "bmResponseInfo", "nbRequestType", "cmResponseTypes", "bmRequestInfo", "bmRequestStyle", "bmResponseID", "bmMessageType", "bmrequesttype", "bmrequestStyle", "nbCommandType", "nbRequesttype", "bmOperationTypes", "bmResponseTypes", "bmCommandType", "BMRequestType", "bmOperationTyp", "bmRequestTypes", "bmMessageTyp", "cmRequestType", "bmRequestID", "bmrequestTypes", "bm_type", "BMResponseTypes", "bmRequestTyp", "BMResponseInfo", "bmRequesttype", "bmOperationType"]}}
{"project": "qemu", "commit_id": "cbcfa0418f0c196afa765f5c9837b9344d1adcf3", "target": 0, "func": "void qemu_free_timer(QEMUTimer *ts)\n\n{\n\n    g_free(ts);\n\n}\n", "idx": 19322, "substitutes": {"ts": ["ns", "ms", "types", "tt", "bs", "rates", "rs", "t", "ports", "str", "times", "ats", "ls", "ss", "ags", "fs", "ptr", "cs", "tis", "acs", "arts", "ters", "ims", "Ts", "tx", "tests", "acks", "tc", "qs", "ics", "alls", "TS", "js", "ps", "atts", "ks", "gs", "tes", "ents", "ds"]}}
{"project": "FFmpeg", "commit_id": "816577716bc6170bccfea3b9e865618b69a4b426", "target": 1, "func": "static av_cold int dvdsub_close(AVCodecContext *avctx)\n\n{\n\n    DVDSubContext *ctx = avctx->priv_data;\n\n    av_freep(&ctx->buf);\n\n    ctx->buf_size = 0;\n\n    return 0;\n\n}\n", "idx": 19353, "substitutes": {"avctx": ["AVrc", "afcmp", "AVcmp", "afcontext", "afctx", "afcca", "AVcca", "avrc", " avcmp", "afrc", "AVctx", " avcontext", "avcca", " avrc", "AVcontext", "avcmp", " avcca", "avcontext"], "ctx": ["cc", "data", "obj", "cca", "vc", "component", "cm", "cf", "cb", "anc", "cp", "bc", "loc", "wcs", "src", "acl", "kw", "ctrl", "cas", "Context", "ca", "cs", "context", "pkg", "tx", "aux", "comp", "ci", "tc", "config", "xc", "cu", "cam", "buf", "client", "lc", "c", "qa", "cmd", "ck", "cmp", "alloc", "cn", "sq", "cv", "conn"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static int scsi_disk_emulate_read_toc(SCSIRequest *req, uint8_t *outbuf)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, req->dev);\n\n    int start_track, format, msf, toclen;\n\n    uint64_t nb_sectors;\n\n\n\n    msf = req->cmd.buf[1] & 2;\n\n    format = req->cmd.buf[2] & 0xf;\n\n    start_track = req->cmd.buf[6];\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    DPRINTF(\"Read TOC (track %d format %d msf %d)\\n\", start_track, format, msf >> 1);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    switch (format) {\n\n    case 0:\n\n        toclen = cdrom_read_toc(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    case 1:\n\n        /* multi session : only a single session defined */\n\n        toclen = 12;\n\n        memset(outbuf, 0, 12);\n\n        outbuf[1] = 0x0a;\n\n        outbuf[2] = 0x01;\n\n        outbuf[3] = 0x01;\n\n        break;\n\n    case 2:\n\n        toclen = cdrom_read_toc_raw(nb_sectors, outbuf, msf, start_track);\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n    return toclen;\n\n}\n", "idx": 19373, "substitutes": {"req": ["rx", "require", "org", "required", "rr", "fr", "grad", "spec", "ch", "request", "rs", "wx", "conf", "err", "ref", "jp", "f", "call", "r", "ro", "str", "dq", "comm", "query", "rh", "src", "sem", "sec", "rf", "def", "resp", "crit", "low", "exec", "rec", "rob", "mr", "comp", "ru", "tar", "config", "sr", "q", "qt", "cur", "rb", "seq", "cmd", "rw", "ir", "qq", "Request", "http", "resource", "requ", "wa", "res", "proc", "ra", "pro", "desc", "sq", "gr", "ver", "input"], "outbuf": [" outvec", "execbuffer", "incb", "cacheuf", "execvec", "outcb", "cachecv", "intbuf", "Outcb", "upbuf", "Outuf", "Outbuf", " outfunc", "outvec", "OUTfb", "outputbuffer", "offbuff", "OUTvec", "wordbuff", "cachebuf", "intfunc", "execbuf", "execuf", "OUTbuffer", "outputbuf", "wordcb", "outbuff", "offbuf", "inbuf", "inuf", "OUTbuff", "inbuff", "OUTfunc", "upuf", "offuf", "outuf", "Outbuffer", "OUTuf", " outbuff", "cachebuff", "upbuff", " outcb", "wordbuf", "outfunc", "outputuf", " outbuffer", " outuf", "intuf", "upcv", "offfb", "outfb", "infb", "outputbuff", "OUTbuf", "outcv", "worduf", "Outbuff", "incv", "inbuffer", "outbuffer"], "s": ["ns", "spec", "m", "session", "ts", "sis", "sg", "t", "conf", "f", "services", "service", "r", "n", "sb", "g", "sl", "z", "ss", "ls", "sim", "fs", "o", "d", "su", "w", "serv", "e", "ssl", "sc", "sr", "ses", "v", "sync", "c", "js", "si", "sym", "p", "S", "b", "http", "gs", "sys", "storage", "south", "sq", "sa", "ds"], "start_track": [" start_tracks", "start_rack", "start_mode", " start_trace", " start_tracking", "end_tracking", "end_rack", "end_track", " start_mode", "start_tracking", "start_tracks", "start_trace", "end_tracks"], "format": ["html", "status", "spec", "pattern", "scale", "term", "offset", "time", "mode", "direction", "f", "base", "name", "sort", "file", "duration", "option", "quality", "type", "method", "package", "function", "padding", "ext", "magic", "range", "host", "letter", "pretty", "gap", "space", "feat", "size", "style", "prefix", "length", "unit", "layout", "position", "stage", "frequency", "pad", "feature", "fn", "form", "template", "transform", "frame", "Format", "operation", "value", "source", "period", "version", "len"], "msf": ["mesv", "apscf", "psl", " msF", " mscf", " msm", "MSl", " msaf", "emsf", "ssfe", "ssf", "emsfo", " msn", "MSf", "csc", "msv", "psfe", " msfe", " msfx", " msv", " msc", " msfs", "msfx", "csfe", "psn", "apsaf", "msm", "msF", "Msv", "cusf", "MSfe", "msl", "csf", "lesaf", "msfs", "lescf", "msaf", "csl", "psf", "Msfx", "ssl", "cusfo", "Msl", "msfe", "mesf", "Msf", "apsfs", "ssn", "emsF", "msc", "lesf", "lesfs", "MSc", "msfo", "apsf", "cusm", "msn", "mesl", " msfo", "mesfx", " msl", "mscf", "cusF", "emsm"], "toclen": ["uclf", "tocfat", "cotLen", "ocLen", "uclen", "lclength", "oclon", "discln", "tocLen", "aclon", "lcLen", "gzlen", "aclen", "cotfat", "cotlen", "pclen", "gzLen", "disclength", "ucLen", "aclength", "tclf", "ocsize", "tclength", "uclength", "ocfat", "ocln", "cotlon", "oclength", "oclf", "tocln", "gzln", "tocsize", "cotsize", "disclen", "pclon", "cotlength", "oclen", "lclon", "pclength", "pcfat", "toclon", "toclength", "lclen", "tcLen", "toclf", "tclen", "pcLen", "discLen", "gzlength", "acLen", "pcsize"], "nb_sectors": ["nb_seivers", "nb_pexes", "nb_mectors", "nb_gecs", "nb_pectors", "nb_pector", "nb_vector", "nb_gector", "nb_seors", "nb_chivers", "nb_gexes", "nb_mesections", "nb_gegments", "nb_megments", "nb_pections", "nb_cegments", "nb_segments", "nb_sector", "nb_pecs", "nb_pesections", "nb_sexes", "nb_vexes", "nb_sesections", "nb_veors", "nb_vegments", "nb_gectors", "nb_cectors", "nb_secs", "nb_chgments", "nb_cections", "nb_pegments", "nb_geors", "nb_ceors", "nb_vecs", "nb_gections", "nb_sections", "nb_mections", "nb_vections", "nb_vesections", "nb_vectors", "nb_veivers", "nb_peivers", "nb_chctors", "nb_chctions"]}}
{"project": "qemu", "commit_id": "0d1c5c91607d1c55a8f5db39c57c6e5c76e21131", "target": 0, "func": "void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)\n\n{\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    if (!bs->drv)  {\n\n        return;\n\n    }\n\n\n\n    if (!(bs->open_flags & BDRV_O_INACTIVE)) {\n\n        return;\n\n    }\n\n    bs->open_flags &= ~BDRV_O_INACTIVE;\n\n\n\n    if (bs->drv->bdrv_invalidate_cache) {\n\n        bs->drv->bdrv_invalidate_cache(bs, &local_err);\n\n    } else if (bs->file) {\n\n        bdrv_invalidate_cache(bs->file->bs, &local_err);\n\n    }\n\n    if (local_err) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n\n\n    ret = refresh_total_sectors(bs, bs->total_sectors);\n\n    if (ret < 0) {\n\n        bs->open_flags |= BDRV_O_INACTIVE;\n\n        error_setg_errno(errp, -ret, \"Could not refresh total sector count\");\n\n        return;\n\n    }\n\n}\n", "idx": 19380, "substitutes": {"bs": ["ns", "bi", "ts", "bin", "s", "facebook", "blog", "rs", "db", "obj", "base", "br", "las", "plugins", "bps", "ubs", "sb", "cb", "bc", "ls", "ss", "pb", "fs", "lb", "bb", "abc", "xs", "ba", "bid", "cs", "css", "als", "gb", "bos", "bot", "bf", "ins", "obs", "bu", "outs", "BS", "iss", "blocks", "bis", "qs", "abi", "bl", "vs", "bas", "fb", "ses", "bh", "ps", "sync", "bits", "js", "bn", "b", "cache", "ks", "gs", "its", "bytes", "os", "bes", "us", "banks", "bus", "ds", "bing"], "errp": ["errcp", "Err", " errP", " errcp", "serverps", "err", "errP", "rrpre", "rrr", "errpc", "serverp", "errv", "Ercp", "erpre", "erps", "serverr", "serverpre", "errpre", "erpc", "erp", "Erv", "errr", "rrv", " errr", "rrp", "errps", "rrps", "erP", "rrcp", "rrP", " errpc", " errv", "Erp", "rrpc"], "local_err": ["local6errors", "local_result", " local_error", "localWerrors", "local_Er", " local_magic", " local_result", " local_iter", "local_error", "local_rr", "local6error", " local_rr", "localWerr", "global_error", "global_rr", "global_err", " local_errors", "localWmagic", "local6result", "local_iter", " local_Er", "local6err", "localWerror", "local_magic", "local_errors"], "ret": ["db", "code", "sur", "f", "ref", "bit", "alt", "let", "rc", "nt", "lit", "reg", "rt", "fun", "result", "num", "flag", "match", "bc", "ext", "dt", "fin", "sec", "done", "mem", "rets", "arg", "att", "val", "re", "Ret", "feat", "no", "back", "id", "det", "rev", "cat", "req", "rl", "gt", "RET", "res", "mt", "ft", "iter", "success", "len"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_vt82c686b_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_VIA);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_VIA_UHCI);\n\n\n\n    /* USB misc control 1/2 */\n\n    pci_set_long(pci_conf + 0x40,0x00001000);\n\n    /* PM capability */\n\n    pci_set_long(pci_conf + 0x80,0x00020001);\n\n    /* USB legacy support  */\n\n    pci_set_long(pci_conf + 0xc0,0x00002000);\n\n\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 19389, "substitutes": {"dev": ["grad", "spec", "Dev", "dd", "mod", "ch", "data", "info", "conf", "err", "pub", "comment", "Device", "conn", "engine", "gu", "md", "debug", "reg", "rad", "block", "app", "kind", "development", "def", "der", "self", "d", "adv", "w", "ev", " device", " Dev", "v", "dom", "device", "req", "test", "cmp", "error", "virt", "dem", "priv", "DEV", "serial", "desc", "diff", "ver"], "s": ["spec", "m", "session", "sg", "t", "rs", "conf", "f", "sv", "services", "service", "r", "n", "sb", "g", "sl", "ss", "is", "o", "d", "sh", "w", "sub", "serv", "e", "ssl", "sc", "ses", "v", "sync", "c", "js", "si", "p", "S", "b", "sys", "storage", "a", "state", "server", "south", "sq", "se", "sf"], "pci_conf": ["pcul_conf", "pcixch", "pcul_aff", "pki_state", "pcixaff", "pki_con", "pculJaff", "pki_aff", "pcul_config", "pcixfi", "pki_cal", "pci_conn", "pki_conf", "pci_fi", "pki_fi", "pci_ch", "pciJtype", "pciJconfig", "pcul_type", "pci_config", "pki_conn", "pki_config", "pki_cfg", "pci_aff", "pculJtype", "pculJconfig", "pki_ch", "pciJconf", "pci_Conf", "pki_Conf", "pci_cal", "pcixconf", "pci_state", "pci_cfg", "pcixconfig", "pciJaff", "pci_type", "pcixstate", "pci_con", "pculJconf"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403, "substitutes": {"insn": [" insne", "outsz", "INSn", " insN", "outsne", "tsN", "ainsN", "insN", "outsnc", "outsN", "insnc", "tssn", "INSnot", "insne", "ainsne", "openssn", "ainsn", "INSz", " inssn", "ainsnc", "outsn", "inssn", " insnot", "INSne", "insnot", " insnc", "tsn", "insz", "opensn", "outsnot", " insz", "opensN"], "mask": ["pattern", "offset", "work", "skip", "shape", "mod", "tr", "mode", "conf", "image", "comment", "reg", "random", "mark", "pack", "flag", "master", "match", "Mask", "max", "cp", "amp", "arr", "ask", "gate", "diff", "add", "config", "map", "qq", "patch", "shift", "pad", "test", "lock", "cmp", "black", "allow", "sign", "flags", "mac", "mm", "scan", "card", "dist"], "dest": ["dc", "data", "mode", "conf", "ctr", "dir", "ord", "master", "usr", "src", "orig", "wb", "mem", "imag", "store", "class", "std", "path", " Dest", "img", "config", "sub", "buf", "target", "map", "temp", "dev", "trans", "test", "dist", "dat", "route", "opt", "proc", "Dest", "transform", "desc", "source", "params", " dst"], "tmp": ["dd", "obj", "result", "pb", "copy", "vm", "gb", "dust", "stuff", "config", "buff", "temp", "vt", "pad", "mp", "test", "dat", "boot", "mm", "source", "target", "tt", "txt", "wx", "TB", "td", "obb", "cm", "app", "cp", "bb", "tab", "bg", "gz", "kk", "amp", "wp", "jp", "rm", "sb", "cpp", "src", "wb", "this", "nb", "fake", "start", "buf", "fb", "mk", "project", "py", "np", "now", "db", "data", "ctx", "bt", "slice", "nm", "etc", "img", "st", "tc", "rb", "cmp", "storage", "cro", "proc", "Dest", "tp", "diff", "attr", "dist"]}}
{"project": "qemu", "commit_id": "bdd81addf4033ce26e6cd180b060f63095f3ded9", "target": 1, "func": "static void vfio_vga_probe_nvidia_3d0_quirk(VFIOPCIDevice *vdev)\n\n{\n\n    VFIOQuirk *quirk;\n\n    VFIONvidia3d0Quirk *data;\n\n\n\n    if (!vfio_pci_is(vdev, PCI_VENDOR_ID_NVIDIA, PCI_ANY_ID) ||\n\n        !vdev->bars[1].region.size) {\n\n        return;\n\n    }\n\n\n\n    quirk = g_malloc0(sizeof(*quirk));\n\n    quirk->data = data = g_malloc0(sizeof(*data));\n\n    quirk->mem = g_malloc0(sizeof(MemoryRegion) * 2);\n\n    quirk->nr_mem = 2;\n\n    data->vdev = vdev;\n\n\n\n    memory_region_init_io(&quirk->mem[0], OBJECT(vdev), &vfio_nvidia_3d4_quirk,\n\n                          data, \"vfio-nvidia-3d4-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x14 /* 0x3c0 + 0x14 */, &quirk->mem[0]);\n\n\n\n    memory_region_init_io(&quirk->mem[1], OBJECT(vdev), &vfio_nvidia_3d0_quirk,\n\n                          data, \"vfio-nvidia-3d0-quirk\", 2);\n\n    memory_region_add_subregion(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].mem,\n\n                                0x10 /* 0x3c0 + 0x10 */, &quirk->mem[1]);\n\n\n\n    QLIST_INSERT_HEAD(&vdev->vga.region[QEMU_PCI_VGA_IO_HI].quirks,\n\n                      quirk, next);\n\n\n\n    trace_vfio_quirk_nvidia_3d0_probe(vdev->vbasedev.name);\n\n}\n", "idx": 19408, "substitutes": {"vdev": ["fdev", "ndevice", "mpu", "vdi", "vdiff", " vpack", " vdef", "vdiv", "ppack", "gprof", "Vdem", "elga", "ndiv", "pdev", "cdiff", " vprof", " vdem", "wde", "vev", "hdevice", "qdiv", "lprof", "vda", "eldev", "wdi", "vdef", "qde", "gga", "wdevice", "vvdem", "fdevice", "vpack", "vvdev", "hdev", "ldev", "qdevice", "wdie", "bga", "fdiv", " vde", "qda", "cdev", "vde", "pdef", "Vprof", "svev", " vdie", "vdm", " vdiv", "Vdev", "VDev", "qdev", "Vdm", "qdef", "mdevice", "svdevice", "vdevice", " vconn", "wpack", "vga", "cdevice", "gdev", "ndev", "wdef", "cdiv", "bdem", "gDev", "eldem", "lev", "mdiv", "svprof", "svdev", "wdiff", "gdie", "vvprof", "gdem", "pdevice", "hdiv", " vdiff", "gdevice", "bdevice", "mdev", "Vconn", "hdef", "vprof", "Vdevice", "eldevice", "vpu", "fpu", "wdev", "vdie", " vDev", "npu", " vdm", "gev", "vconn", "vDev", " vdevice", "gdiv", "gdm", "pdiv", "ldevice", "wda", "bdev", "vvconn", "ldef", " vda", "wdiv", "vdem", "pdi", "cdi"], "quirk": ["affird", "QUirk", "aquoise", "aquik", " quack", "squavour", "QUirt", "Quik", " quisk", "qack", "shbug", "quirrel", "QUik", "squirt", "squird", "joirt", "qavour", "guirt", "queark", "shird", "qiq", " quirrel", "qik", "shik", "blbug", "requik", "aquirrel", "guavour", "Quisk", "queirt", "ghirt", "aquark", "qirrel", "squraud", " quirt", "quavour", "aquisk", "quirt", "queiq", "shirt", "qoise", "ghraud", "requird", "guack", "acquirt", " qubug", "Quiece", "affik", "requark", "affirt", "joird", "quisk", "ghirk", "quoise", "guirk", "guark", "queirk", "affirk", "requirt", "aquird", "aquiece", "quack", "acquirk", "quraud", "squirrel", "quird", "joraud", "requirk", "guird", "Quirt", "blirt", "QUird", "queik", "quik", "queird", "aquirk", "squark", "qird", "Quirk", "quiq", "quark", "blirk", "queoise", " quik", "blird", " quird", "aquirt", "ghird", " quark", "joirk", "aquiq", "squik", "qirk", "Quird", "squirk", "Quirrel", "qubug", "acquik", "qark", "qirt", "quiece", " quiece", "guirrel", "shirk", "acquird"], "data": ["result", "gui", "raw", "zip", "rec", "d", "empty", "new", "and", "no", "config", "da", "p", "area", "none", "resource", "dat", "next", "output", "end", "valid", "input", "Data", "bin", "content", "name", "media", "action", "done", "load", "database", "change", "size", "zero", "style", "queue", "update", "parent", "dev", "ata", "connection", "docker", "push", "image", "window", "current", "block", "function", "this", "di", "mem", "model", "bad", "array", "memory", "ad", "start", "batch", "device", "missing", "state", "alpha", "value", "progress", "success", "session", "record", "mode", "info", "buffer", "reg", "wait", "module", "slice", "draw", "ui", "cache", "error", "api", "DATA", "inner"]}}
{"project": "FFmpeg", "commit_id": "919d13d2383bd7318b80ed0c5b723323a79a8996", "target": 0, "func": "static int cookie_string(AVDictionary *dict, char **cookies)\n\n{\n\n    AVDictionaryEntry *e = NULL;\n\n    int len = 1;\n\n\n\n    // determine how much memory is needed for the cookies string\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        len += strlen(e->key) + strlen(e->value) + 1;\n\n\n\n    // reallocate the cookies\n\n    e = NULL;\n\n    if (*cookies) av_free(*cookies);\n\n    *cookies = av_malloc(len);\n\n    if (!cookies) return AVERROR(ENOMEM);\n\n    *cookies[0] = '\\0';\n\n\n\n    // write out the cookies\n\n    while (e = av_dict_get(dict, \"\", e, AV_DICT_IGNORE_SUFFIX))\n\n        av_strlcatf(*cookies, len, \"%s%s\\n\", e->key, e->value);\n\n\n\n    return 0;\n\n}\n", "idx": 19411, "substitutes": {"dict": ["entry", "db", "code", "data", "conf", "f", "dir", "ict", "file", "inc", "str", "document", "coll", "def", "self", "object", "arr", "head", "host", "d", "df", "inf", "path", "w", "config", "id", "map", "dom", "c", "da", "table", "doc", "cache", "lock", "dat", "body", "list", "die"], "cookies": [" cookries", "cssies", "cookiey", "copes", "Cookries", "Cooki", " cookis", "cookes", "cssys", "cooky", "cookis", "caties", "Cookies", " cooky", "cookieis", "cookys", "privy", " cookes", "csss", "catys", "cookieys", "copys", "Cookys", "privys", "cookieies", "Cooky", "cssy", "cookieied", "copy", "cookries", "cooks", "privies", "copies", "Cooks", "privied", "Cookied", "caty", "cooki", "catis", "cookied", "readied", "copi", "reads", "readies", " cooki", " cookys", " cookied", "cookiees", "copries", "readys", " cooks"], "e": ["E", "ei", "m", "eg", "ede", "ell", "element", "f", "eff", "x", "err", "eve", "eu", "ne", "pe", "fe", "de", "see", "je", "i", "enter", "g", "ge", "ie", "entity", "en", "ae", "ee", "eng", "o", "ze", "l", "d", "ce", "ed", "le", "esi", "pse", "ue", "ev", "ep", "oe", "be", "c", "ea", "line", "b", "ele", "ec", "ke", "h", "er", "es", "edge", "end", "me", "he", "el", "se", "ve", "y"]}}
{"project": "qemu", "commit_id": "9fbf4a58c90183b30bb2c8ad971ccce7e6716a16", "target": 1, "func": "static int get_physical_address (CPUMIPSState *env, hwaddr *physical,\n\n                                int *prot, target_ulong real_address,\n\n                                int rw, int access_type)\n\n{\n\n    /* User mode can only access useg/xuseg */\n\n    int user_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_UM;\n\n    int supervisor_mode = (env->hflags & MIPS_HFLAG_MODE) == MIPS_HFLAG_SM;\n\n    int kernel_mode = !user_mode && !supervisor_mode;\n\n#if defined(TARGET_MIPS64)\n\n    int UX = (env->CP0_Status & (1 << CP0St_UX)) != 0;\n\n    int SX = (env->CP0_Status & (1 << CP0St_SX)) != 0;\n\n    int KX = (env->CP0_Status & (1 << CP0St_KX)) != 0;\n\n#endif\n\n    int ret = TLBRET_MATCH;\n\n    /* effective address (modified for KVM T&E kernel segments) */\n\n    target_ulong address = real_address;\n\n\n\n#define USEG_LIMIT      0x7FFFFFFFUL\n\n#define KSEG0_BASE      0x80000000UL\n\n#define KSEG1_BASE      0xA0000000UL\n\n#define KSEG2_BASE      0xC0000000UL\n\n#define KSEG3_BASE      0xE0000000UL\n\n\n\n#define KVM_KSEG0_BASE  0x40000000UL\n\n#define KVM_KSEG2_BASE  0x60000000UL\n\n\n\n    if (kvm_enabled()) {\n\n        /* KVM T&E adds guest kernel segments in useg */\n\n        if (real_address >= KVM_KSEG0_BASE) {\n\n            if (real_address < KVM_KSEG2_BASE) {\n\n                /* kseg0 */\n\n                address += KSEG0_BASE - KVM_KSEG0_BASE;\n\n            } else if (real_address <= USEG_LIMIT) {\n\n                /* kseg2/3 */\n\n                address += KSEG2_BASE - KVM_KSEG2_BASE;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (address <= USEG_LIMIT) {\n\n        /* useg */\n\n        if (env->CP0_Status & (1 << CP0St_ERL)) {\n\n            *physical = address & 0xFFFFFFFF;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        }\n\n#if defined(TARGET_MIPS64)\n\n    } else if (address < 0x4000000000000000ULL) {\n\n        /* xuseg */\n\n        if (UX && address <= (0x3FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0x8000000000000000ULL) {\n\n        /* xsseg */\n\n        if ((supervisor_mode || kernel_mode) &&\n\n            SX && address <= (0x7FFFFFFFFFFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xC000000000000000ULL) {\n\n        /* xkphys */\n\n        if (kernel_mode && KX &&\n\n            (address & 0x07FFFFFFFFFFFFFFULL) <= env->PAMask) {\n\n            *physical = address & env->PAMask;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < 0xFFFFFFFF80000000ULL) {\n\n        /* xkseg */\n\n        if (kernel_mode && KX &&\n\n            address <= (0xFFFFFFFF7FFFFFFFULL & env->SEGMask)) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n#endif\n\n    } else if (address < (int32_t)KSEG1_BASE) {\n\n        /* kseg0 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG0_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG2_BASE) {\n\n        /* kseg1 */\n\n        if (kernel_mode) {\n\n            *physical = address - (int32_t)KSEG1_BASE;\n\n            *prot = PAGE_READ | PAGE_WRITE;\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else if (address < (int32_t)KSEG3_BASE) {\n\n        /* sseg (kseg2) */\n\n        if (supervisor_mode || kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    } else {\n\n        /* kseg3 */\n\n        /* XXX: debug segment is not emulated */\n\n        if (kernel_mode) {\n\n            ret = env->tlb->map_address(env, physical, prot, real_address, rw, access_type);\n\n        } else {\n\n            ret = TLBRET_BADADDR;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 19431, "substitutes": {"env": ["viron", "txt", "db", "session", "code", "global", "cdn", "core", "conf", "esp", "cal", "net", "eu", "ne", "engine", "exc", "cf", "enter", "ou", " environment", "np", "oa", "environment", "ext", "dt", "ctx", "console", "en", "lv", "eng", "her", "enc", "vm", "exec", "pg", "context", "profile", "event", "nc", "args", "site", "Environment", "iss", "ev", "config", "serv", "e", "qt", "v", "inv", "ea", "dev", "osc", "que", "dat", "ec", "et", "ef", "eni", "server", "el", "dict", "conn"], "physical": ["native", "Physical", "phys", "direct", "al", "present", "pixel", "smart", "reference", "ipt", "relative", "protected", "console", "regular", "virtual", "pointer", "ip", "host", "linux", "memory", "network", "prefix", "config", "remote", "primary", "hard", "binary", "address", "secondary", "external", "http", "resource", "intel", "digital", "serial", "local", "port", "specified", "target"], "prot": ["status", "ret", "stat", "phys", "txt", "ocol", "platform", "eth", "mult", "ext", "protected", "phy", "ptr", "normal", "def", "en", "multi", "pos", "prop", "istor", "att", "inet", "format", "reset", "rot", "prefix", "config", "primary", "cl", "selected", "secondary", "binary", "test", "proc", "opt", "pro", "Prot", "port", "server", "transfer", "typ"], "real_address": [" real_addr", "physical_number", "realmemslave", "real_number", "realxaddress", "realerentry", "realmemaddr", "realipnumber", "true_entry", "realxaddr", "trueerlocation", "real67address", "virtual_add", "trueeraddress", "realipaddress", "real67entry", "real_add", "realamslave", "true_location", "virtual_addr", "real_location", "trueeraddr", "real_image", "trueerentry", "physical_address", "realipcondition", "real_slave", "physical_condition", "realeraddress", "virtual_entry", "real67image", "real67addr", "realeraddr", "realximage", "real_entry", " real_name", "realxentry", " real_number", "realmemaddress", "virtual_address", "physical_message", "realamadd", "realamaddress", "true_address", "real_name", "realipmessage", "true_addr", "realmemadd", "virtual_image", "virtual_slave", "real_condition", "realamaddr", "real_message", "real_addr", "realerlocation"], "rw": ["rx", "pattern", "fp", "RW", "pn", "r", "ro", "worker", "sw", "rf", "password", "ww", "ffff", "w", "rot", "prefix", "rb", "slave", "vt", "wh", "proc", "ty", "nn"], "access_type": ["accessvaltype", "accesstypetable", "connection_group", "accessvalgroup", "accessvaltypes", "connection_table", "connection_types", "accesstypetypes", "connection_type", "accesstypegroup", "accesstypetype", "access_table", "connectionvaltable", "access_group", "connectionvalgroup", "access_types", "accessvaltable", "connectionvaltype", "connectionvaltypes"]}}
{"project": "qemu", "commit_id": "82be8e7394b31fd2d740651365b8ebdd0c847529", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434, "substitutes": {"spapr": ["spapar", "spaxpr", "scappar", "spacr", "Spacrs", "pseaprs", "spraper", " spapsr", "sprapper", "spapear", "splapnr", "spapprc", "pseapri", "splupper", "spagrc", "pseagri", "spraprs", "splaprs", "spupr", "spagpr", "spapnr", "Spaprs", "spapper", "spupnr", "spacsr", "sprapri", "Spaplr", "spaper", "spagri", "spagrar", "spaprar", "spapsr", "ppapsnr", "spaprs", "Spacsr", "scaprar", "spupper", "spaperc", "spapsrc", "ppapser", "spampar", "spapsri", "spAPr", "scapr", "spajr", "scapar", "spagar", "scapprc", " spaprc", " spaprar", "Spacr", "Spaclr", "spapprs", "ppapsr", "spagrs", "spappar", "pseapr", "ppaper", "splupnr", "spajlr", "spapppr", "spapsnr", "ppapr", "spuprs", "pseagpr", "spapsar", "splapr", "spajsr", "splupr", "spagr", "ppapnr", "scaprc", " spapsrar", " spapsar", "Spapsr", "spacrs", "spampnr", "spaperar", "spaxr", "splapper", " spapar", "spamprc", "spappr", "spappnr", "spAPrs", "spampri", "Spapr", "spaplr", "spaxri", "ppapri", "pseagr", "spappper", "spapprar", "spluprs", "spAPsr", "spapri", "pseagrs", "sprapnr", "spaprc", "ppapsri", "spappri", "sprapr", "spampr", "scapprar", "spapser", "spamper", "spapsrar", "pseappr", "spaclr", "spAPlr", "spaxrs", "scappr", " spapsrc", "spamprar", "spajrs"]}}
{"project": "qemu", "commit_id": "a9fc37f6bc3f2ab90585cb16493da9f6dcfbfbcf", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441, "substitutes": {"v": ["m", "vid", "V", "j", "t", "x", "f", "sv", "vin", "vp", "r", "n", "g", "i", "self", "vm", "uv", "l", "vol", "vis", "vim", "ev", "q", "k", "ov", "e", "c", "tv", "p", "vt", "b", "iv", "nv", "value", "version", "u"], "name": ["part", "code", "data", "child", "x", "ame", "search", "comment", "call", "n", "str", "i", "type", "nam", "ext", "Name", "self", "object", "o", "label", "d", "NAME", "unknown", "alias", "space", "path", "new", "no", "prefix", "key", "named", "id", "start", "parent", "address", "none", "missing", "null", "error", "names", "a", "word", "value"], "list": ["set", "tree", "List", "global", "code", "data", "view", "x", "call", "all", "base", "pool", "full", "result", "str", "i", "block", "type", "source", "self", "count", "member", "out", "get", "listed", "L", "join", "load", "l", "keep", "array", "chain", "like", "and", "large", "stack", "queue", "id", "length", "e", "bl", "gl", "batch", "cl", "parent", "lc", "map", "p", "test", "can", "cache", "null", "filter", "card", "la", "lists", "live", "local", "allow", "end", "LIST", "li", "len"], "size": ["scale", "offset", "small", "code", "capacity", "shape", "SIZE", "esc", "sp", "ix", "cm", "sized", "num", "g", "six", "max", "sec", "count", "cs", "empty", "complete", "new", "args", "large", "ci", "ize", "length", "si", "iz", "address", "null", "form", "Size", "len"], "errp": [" errP", "derpr", " errfp", "erfp", "derlp", "irc", "err", "errP", "srP", "errpr", "errpc", " errpr", " errap", "erc", " errc", "derp", " errlp", "srp", "rrfp", "irp", "irr", "erap", "rrap", "erpc", "srlp", "erp", "srpr", "errr", "errfp", "derP", " errr", "errlp", "rrp", "errap", " errpc", "irpc", "errc", "rrpc"], "qiv": ["Qoi", "guiver", "qio", "Qiver", "quoi", "Qiv", "sqriv", " qori", "sqadr", "Qori", "Qou", " qoi", "quiv", "qiver", " qiver", "qriv", " qou", "quadr", "quriv", "qualiv", "quiver", "guou", "guiv", "quori", "guIV", "QIV", "qualadr", " qIV", "qIV", "qualio", "sqio", "qoi", "quio", "sqiv", "qou", "qori", "qualriv", "qadr"], "qobj": ["kObj", "wobject", "Qiv", "viewob", "quiv", "viewiv", "qout", " qObj", "kout", "qobject", "wobj", "Qob", "gob", "giv", "pobject", "pObj", "pout", "kiv", "Qobj", "viewobj", "pobj", "qObj", " qob", "Qobject", "quobj", "kobj", "kbr", "quobject", "gobj", "kobject", "Qbr", "wiv", "quob", " qout", "gobject", " qobject", "qob", "qbr", "viewobject", "qubr", "wob"], "entry": ["part", "term", "ner", "data", "ent", "element", "info", "obj", "child", "r", "nt", "counter", "feed", "result", "query", "enter", "or", "match", "ge", "ie", "index", "ry", "member", "object", "her", "array", "parse", "new", "import", "Entry", "add", "id", "key", "q", "e", "ga", "parent", "lc", "cat", "si", "insert", "p", "inter", "la", "row", "er", "connection", "escape", "it", "se", "server", "inner", "li", "reader"]}}
{"project": "qemu", "commit_id": "0a982b1bf3953dc8640c4d6e619fb1132ebbebc3", "target": 0, "func": "static void test_qga_file_write_read(gconstpointer fix)\n\n{\n\n    const TestFixture *fixture = fix;\n\n    const unsigned char helloworld[] = \"Hello World!\\n\";\n\n    const char *b64;\n\n    gchar *cmd, *enc;\n\n    QDict *ret, *val;\n\n    int64_t id, eof;\n\n    gsize count;\n\n\n\n    /* open */\n\n    ret = qmp_fd(fixture->fd, \"{'execute': 'guest-file-open',\"\n\n                 \" 'arguments': { 'path': 'foo', 'mode': 'w+' } }\");\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n    id = qdict_get_int(ret, \"return\");\n\n    QDECREF(ret);\n\n\n\n    enc = g_base64_encode(helloworld, sizeof(helloworld));\n\n    /* write */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-write',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \",\"\n\n                          \" 'buf-b64': '%s' } }\", id, enc);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    g_assert_nonnull(ret);\n\n    qmp_assert_no_error(ret);\n\n\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert_cmpint(eof, ==, 0);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read (check implicit flush) */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, \"\");\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* seek to 0 */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-seek',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \", \"\n\n                          \" 'offset': %d, 'whence': %d } }\",\n\n                          id, 0, SEEK_SET);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    qmp_assert_no_error(ret);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"position\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    g_assert_cmpint(count, ==, 0);\n\n    g_assert(!eof);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n\n\n    /* read */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-read',\"\n\n                          \" 'arguments': { 'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    val = qdict_get_qdict(ret, \"return\");\n\n    count = qdict_get_int(val, \"count\");\n\n    eof = qdict_get_bool(val, \"eof\");\n\n    b64 = qdict_get_str(val, \"buf-b64\");\n\n    g_assert_cmpint(count, ==, sizeof(helloworld));\n\n    g_assert(eof);\n\n    g_assert_cmpstr(b64, ==, enc);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n    g_free(enc);\n\n\n\n    /* close */\n\n    cmd = g_strdup_printf(\"{'execute': 'guest-file-close',\"\n\n                          \" 'arguments': {'handle': %\" PRId64 \"} }\",\n\n                          id);\n\n    ret = qmp_fd(fixture->fd, cmd);\n\n    QDECREF(ret);\n\n    g_free(cmd);\n\n}\n", "idx": 19469, "substitutes": {"fix": ["pattern", "fixes", "init", "data", "conf", "f", "call", "ix", "FIX", "fe", "apply", "make", "Fix", "fc", "def", "setup", "host", "fx", "class", "format", "diff", "new", "pre", "bf", "prefix", "config", "q", " format", "update", "post", "patch", " prefix", "mix", " Fix", "test", "field", "bug"], "fixture": ["froster", "pactory", "dixtures", "dendor", "hactory", "dixture", "ditness", "taint", "hixture", "mixture", "frundle", "fitter", "tendor", "goster", "pixture", "tixture", "gixture", "foster", "titter", "mault", "frault", "daint", "dactory", "hitness", "moster", "fixtures", "dlict", " fixtures", "fendor", " fitter", "fundle", "fitness", "Flict", "gault", "factory", "pestival", "hestival", "Fitness", " faint", "faint", "Fixture", " fitness", "flict", " fendor", "gundle", "mundle", "ditter", "fault", "frixture", "festival", "pitness", " flict", "destival", "Fixtures"], "helloworld": ["hellowsellow", "hellowsworld", "hellowww", "hemowedworld", "clowworld", " hellowarden", "hellowork", "helleworld", "hemowedird", "hellowedird", "hellowingird", "hellowedorld", "hemowellow", "hellowarden", " hellowingarden", "helloyworld", "helloyellow", "kelewella", "kelowww", "hemoworld", "cloyworld", "cloworld", "helloyird", "hellowellow", "hemowird", "helloyorld", "clowellow", "hellowworld", "hellework", " hellowingorld", "hellowingella", " hellowellow", "hellowingellow", "hellewww", "hellowella", "kelewww", " hellowird", "cloyorld", " hellowingird", "hellewella", "kelowork", "hellowsird", " hellowingellow", "keleworld", "hellowsorld", "hellowedarden", "hellowedworld", "kelework", "clowork", "hemowedorld", "hellowedork", "hellowird", "helloyork", "hellowedellow", "hellowingww", "hellowingworld", "hellowsarden", "hellowedella", "keloworld", "hemowedellow", "hellowingarden", "hellowingorld", "kelowella", "cloyork", "cloyellow", "hellowingork", "hellowedww", "hemowworld"], "b64": ["f24", "b62", "base64", "f64", "p64", "eb64", "B64", "b63", "b128", "eb63", "eb65", "base24", "coll", " b58", "baseoll", " b256", "wb65", "wb64", " b62", "f58", "p128", "wb128", "c62", "p63", " b24", "B256", "c256", "base58", " boll", "B62", "boll", "foll", "c64", "b256", "b24", "p65", "wb63", "b58", "eb128", "Boll", "b65"], "cmd": ["grad", "cfg", "child", "gd", "md", "cf", "anc", "cod", "path", "config", "prefix", "cli", "qq", "ck", "gen", "win", "valid", "command", "pt", "cc", "conn", "input", "init", "vc", "fun", "clean", "msg", "arg", "force", "cat", "dom", "parent", "gz", "mac", "dict", "code", "contin", "cookie", "err", "call", "window", "cb", "root", "auth", "help", "ctrl", "crit", "std", "back", "rn", "buf", "cd", "ux", "cn", "bug", "session", "func", "mode", "g", "module", "method", "shell", "ctx", "def", "pkg", "Cmd", "img", "bot", "client", "cl", "req", "seq", "ll", "url", "custom"], "enc": ["Enc", "sg", "ch", "code", "rc", "vec", "inc", "ENC", "exc", "sl", "auth", "anc", "loc", "msg", "ext", "acl", "env", "en", "alg", "encrypted", "eng", "oder", "exec", "wk", "empty", "nc", "iq", "ac", "feat", "img", "emb", "c", "seq", "lib", "binary", "uc", "col", "win", "ec", "eval", "lang", "mac", "el", "conn", "len"], "ret": ["grad", "br", "obj", "al", "ref", "bit", "nt", "ann", "result", "job", "var", "run", "att", "feat", "fit", "rev", "repl", "res", "opt", "valid", "pt", "conn", "part", "fun", "vals", "fin", "resp", "arg", "arr", "art", "flat", "Ret", "bf", "cat", "gt", "RET", "pet", "ft", "dict", "status", "expr", "base", "alt", "lit", "r", "rt", "rel", "des", "final", "re", "back", "buf", "rl", "del", "detail", "reply", "success", "session", "db", "data", "let", "reg", "pass", "ext", "def", "rets", "en", "ber", "img", "response", "det", "dr", "seq", "ll", "url", "eval", "el"], "val": ["Val", "part", "stat", "data", "al", "base", "ref", "x", "alt", "all", "lit", "reg", "fun", "rt", "rel", "vals", "sl", "var", "loc", "sel", "pos", "ind", "VAL", "vert", "arg", "vol", "fl", "bo", "pre", "pal", "cel", "ol", "il", "serv", "bl", "rev", "v", "elt", "unit", "rl", "seq", "lib", "repl", "b", "pr", "col", "la", "bel", "ul", "eval", "res", "aval", "valid", "bal", "el", "value", "pt", "cond", "len"], "id": ["Id", "ify", "grad", "init", "pid", "code", "data", "info", "af", "bit", "name", "ID", "f", "x", "base", "ref", "ape", "md", "aid", "nt", "rid", "num", "i", "root", "type", "ide", "idy", "z", "ie", "in", "kid", "max", "ind", "bid", "ip", "uid", "d", "iq", "oid", "ac", "ident", "mid", "q", "ad", "start", "fd", "cat", "parent", "seq", "ick", "url", "doc", "p", "ids", "gen", "sid", "win", "ension", "cd", "h", "end", "valid", "it", "one", "bug"], "eof": ["neok", "eeOF", "Eout", " eoc", "seOf", "zeop", "eeOf", "eop", "seof", "zeout", "seOF", " eok", "Eop", "aeof", "geOF", "eok", "eOF", "geif", "aeif", "Eoff", "nof", "Eos", "nos", "neOf", "Eiff", "aeOF", "aeoff", "nOF", " eiff", " eout", " eop", "eeof", "Eoc", "Eof", "eout", "nOf", "zeof", "zeiff", "eoff", "neoc", "neos", "peof", "eos", "neof", "geoff", "peok", "Eif", "EOf", "eOf", "peOf", " eOf", "seos", "geof", "eif", " eos", "peos", "eoc", "eeos", "eiff"], "count": ["part", "stat", "ch", "code", "time", "child", "base", "f", "err", "ct", "call", "nt", "inc", "coll", "type", "max", "loc", "Count", "in", "ind", "act", "label", "cond", "l", "keep", "found", "size", "ac", "add", "length", "q", "limit", "gl", "cat", "c", "parent", "catch", "seq", "p", "cache", "b", "sum", "col", "depth", "check", "level", "number", "weight", "cast", "list", "cc", "len"]}}
{"project": "qemu", "commit_id": "b3db211f3c80bb996a704d665fe275619f728bd4", "target": 0, "func": "static void test_visitor_out_native_list_uint16(TestOutputVisitorData *data,\n\n                                                const void *unused)\n\n{\n\n    test_native_list(data, unused, USER_DEF_NATIVE_LIST_UNION_KIND_U16);\n\n}\n", "idx": 19473, "substitutes": {"data": ["Data", "code", "base", "image", "options", "media", "buffer", "input", "result", "window", "devices", "as", "index", "done", "def", "empty", "class", "array", "draw", "memory", "style", "args", "ad", "xxx", "batch", "parent", "device", "used", "da", "test", "none", "missing", "cache", "dat", "next", "null", "a", "DATA", "valid", "writer", "value", "reader"], "unused": [" unuse", "Unused", "Unavailable", "unus", "umusing", "umus", "Unusing", "umused", "nonavailable", "nonuse", "unavailable", "Unuse", " unus", "Unus", "umuse", " unavailable", "unuse", "nonused", " unusing", "unusing"]}}
{"project": "qemu", "commit_id": "01cd90b641e1aed40cf13a577e6a737af94d55e7", "target": 0, "func": "static int xen_9pfs_connect(struct XenDevice *xendev)\n\n{\n\n    int i;\n\n    Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev);\n\n    V9fsState *s = &xen_9pdev->state;\n\n    QemuOpts *fsdev;\n\n\n\n    if (xenstore_read_fe_int(&xen_9pdev->xendev, \"num-rings\",\n\n                             &xen_9pdev->num_rings) == -1 ||\n\n        xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) {\n\n        return -1;\n\n    }\n\n\n\n    xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing));\n\n    for (i = 0; i < xen_9pdev->num_rings; i++) {\n\n        char *str;\n\n        int ring_order;\n\n\n\n        xen_9pdev->rings[i].priv = xen_9pdev;\n\n        xen_9pdev->rings[i].evtchn = -1;\n\n        xen_9pdev->rings[i].local_port = -1;\n\n\n\n        str = g_strdup_printf(\"ring-ref%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].ref) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n        str = g_strdup_printf(\"event-channel-%u\", i);\n\n        if (xenstore_read_fe_int(&xen_9pdev->xendev, str,\n\n                                 &xen_9pdev->rings[i].evtchn) == -1) {\n\n            g_free(str);\n\n            goto out;\n\n        }\n\n        g_free(str);\n\n\n\n        xen_9pdev->rings[i].intf =  xengnttab_map_grant_ref(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].intf) {\n\n            goto out;\n\n        }\n\n        ring_order = xen_9pdev->rings[i].intf->ring_order;\n\n        if (ring_order > MAX_RING_ORDER) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring_order = ring_order;\n\n        xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs(\n\n                xen_9pdev->xendev.gnttabdev,\n\n                (1 << ring_order),\n\n                xen_9pdev->xendev.dom,\n\n                xen_9pdev->rings[i].intf->ref,\n\n                PROT_READ | PROT_WRITE);\n\n        if (!xen_9pdev->rings[i].data) {\n\n            goto out;\n\n        }\n\n        xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data;\n\n        xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data +\n\n                                       XEN_FLEX_RING_SIZE(ring_order);\n\n\n\n        xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]);\n\n        xen_9pdev->rings[i].out_cons = 0;\n\n        xen_9pdev->rings[i].out_size = 0;\n\n        xen_9pdev->rings[i].inprogress = false;\n\n\n\n\n\n        xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0);\n\n        if (xen_9pdev->rings[i].evtchndev == NULL) {\n\n            goto out;\n\n        }\n\n        fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC);\n\n        xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain\n\n                                            (xen_9pdev->rings[i].evtchndev,\n\n                                             xendev->dom,\n\n                                             xen_9pdev->rings[i].evtchn);\n\n        if (xen_9pdev->rings[i].local_port == -1) {\n\n            xen_pv_printf(xendev, 0,\n\n                          \"xenevtchn_bind_interdomain failed port=%d\\n\",\n\n                          xen_9pdev->rings[i].evtchn);\n\n            goto out;\n\n        }\n\n        xen_pv_printf(xendev, 2, \"bind evtchn port %d\\n\", xendev->local_port);\n\n        qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev),\n\n                xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]);\n\n    }\n\n\n\n    xen_9pdev->security_model = xenstore_read_be_str(xendev, \"security_model\");\n\n    xen_9pdev->path = xenstore_read_be_str(xendev, \"path\");\n\n    xen_9pdev->id = s->fsconf.fsdev_id =\n\n        g_strdup_printf(\"xen9p%d\", xendev->dev);\n\n    xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, \"tag\");\n\n    v9fs_register_transport(s, &xen_9p_transport);\n\n    fsdev = qemu_opts_create(qemu_find_opts(\"fsdev\"),\n\n            s->fsconf.tag,\n\n            1, NULL);\n\n    qemu_opt_set(fsdev, \"fsdriver\", \"local\", NULL);\n\n    qemu_opt_set(fsdev, \"path\", xen_9pdev->path, NULL);\n\n    qemu_opt_set(fsdev, \"security_model\", xen_9pdev->security_model, NULL);\n\n    qemu_opts_set_id(fsdev, s->fsconf.fsdev_id);\n\n    qemu_fsdev_add(fsdev);\n\n    v9fs_device_realize_common(s, NULL);\n\n\n\n    return 0;\n\n\n\nout:\n\n    xen_9pfs_free(xendev);\n\n    return -1;\n\n}\n", "idx": 19490, "substitutes": {"xendev": ["wxendov", "xndev", "exenderv", "xendown", "wxendedov", "zenddev", "exendev", "genddiv", "zendedev", "zendee", "gendedev", "xendedove", "gendev", "xendep", "xEndep", "xnderv", "xtendev", "xpendev", "xtentev", "xendee", "genderv", "zendedee", "exendedruction", "xndeva", "xnddev", "xentev", "xtendov", "xndown", "exndev", "xendsev", "xedgediv", " xendove", "zendedov", "wxenderv", "zendev", "xenderv", "xstarterv", "xendedev", "exendedep", "wxendedev", "zendov", "exendown", "xentown", "xtentep", "wxendedeva", "exendedev", "xtendep", "xndov", " xendedev", "xtentov", "xEnderv", "xentee", "xendeddev", "xendederv", "xendsep", " xenddev", "xendedov", "exnderv", "xenterv", "wxendev", "xendedruction", "xendedown", "xendedep", "exnddev", "xstartov", " xenderv", "exendep", "xentov", "xedgeerv", "wxendederv", " xendederv", "gendederv", "xEndev", "xenddev", "xendeddiv", "xendedeva", "xendedee", "xedgeov", "exenddev", "xendov", "xendeva", "xenddiv", "exendederv", "xedgeev", "xpendov", "xstartev", "gendeddiv", "xtenderv", "gendedov", "xendserv", " xendov", "gendov", "exndown", "xpenderv", "wxendeva", "xendruction", " xendedov", "xndee", "xentove", "xendsruction", "xstartdiv", "xpendeva", "xtenterv", "xentdev", "xentep", "xEndruction", "zendeddev", "exendruction", " xendown", "xendove", " xendeddev"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "hi", "gui", "ie", "d", "pi", "id", "cli", "ni", "xi", "p", "\u0438", "interface", "it", "fi", "source", "gi", "m", "init", "j", "ix", "ini", "iu", "I", "count", "o", "v", "lc", "si", "ri", "field", "a", "iv", "ti", "f", "r", "mi", "ii", "di", "ind", "multi", "zi", "l", "yi", "ci", "abi", "c", "line", "b", "eni", "reply", "mu", "t", "info", "io", "n", "g", "z", "ij", "slice", "index", "ip", "adi", "idi", "ui", "isin", "e", "isi", "api", "inner", "y", "li", "u"], "xen_9pdev": ["xen_ninepadv", "xen_09pengine", "xen_9pfail", "xen_ninepmode", "xen_9badv", "xen_9fpdev", "xen_9lpdem", "xen_9fapp", "xen_9peadv", "xen_9pedef", "xen_10papp", "xen_9cdev", "xen_9fdevice", "xen_9pdevice", "xen_9psvalid", "xen_9fadv", "xen_9fpvalid", "xen_9pidevice", "xen_9cpconf", "xen_8ddevice", "xen_9pudev", "xen_ninedrad", "xen_09fdef", "xen_nineddev", "xen_ninefdev", "xen_9qdevice", "xen_9psde", "xen_9padv", "xen_10pcdevice", "xen_9cpdev", "xen_9cde", "xen_9fcomment", "xen_9pivalid", "xen_109pdev", "xen_09phome", "xen_9fconf", "xen_9psconf", "xen_09fdev", "xen_9ldevice", "xen_10pdev", "xen_ninepcdevice", "xen_9phome", "xen_9pcde", "xen_10pdevice", "xen_9dod", "xen_9pediv", "xen_09fdem", "xen_9piconf", "xen_9vengine", "xen_9cprad", "xen_9bdev", "xen_ninepconf", "xen_9dadv", "xen_09pdem", "xen_09pde", "xen_9frad", "xen_9pvalid", "xen_ninefdevice", "xen_09ffail", "xen_19pcd", "xen_09pdef", "xen_109prad", "xen_9fde", "xen_9pedev", "xen_nineddevice", "xen_9ppdevice", "xen_9prad", "xen_9pdem", "xen_975pdev", "xen_9pde", "xen_ninepcmode", "xen_8pconf", "xen_09fadv", "xen_9fdc", "xen_9fmode", "xen_9lconf", "xen_09fengine", "xen_9lrad", "xen_09pev", "xen_9psdebug", "xen_9pmode", "xen_09pdc", "xen_9fdef", "xen_9puadv", "xen_09pfail", "xen_9drad", "xen_9qdev", "xen_09fdi", "xen_9pdiv", "xen_9pengine", "xen_9ppod", "xen_9bpdev", "xen_9ppdev", "xen_9fod", "xen_9bpcd", "xen_ninepdiv", "xen_9pcapp", "xen_9fvalid", "xen_8ddev", "xen_9fdi", "xen_8pod", "xen_9lpengine", "xen_19pdev", "xen_9pufail", "xen_9pev", "xen_9qdi", "xen_9pconf", "xen_19pvalid", "xen_9pcdev", "xen_9vdev", "xen_19bpvalid", "xen_nineprad", "xen_109pconf", "xen_9ppfail", "xen_9picomment", "xen_ninebdev", "xen_8dod", "xen_09fdc", "xen_9pdi", "xen_9pcmode", "xen_9cdi", "xen_09fhome", "xen_9ddebug", "xen_9pirad", "xen_19bpcd", "xen_109ddev", "xen_9ddem", "xen_ninepdef", "xen_9vdem", "xen_975fpdev", "xen_9papp", "xen_9fdiv", "xen_ninecdev", "xen_10pcapp", "xen_19bpdev", "xen_9pcdevice", "xen_9qde", "xen_9ffail", "xen_9bdiv", "xen_9ppev", "xen_ninepdev", "xen_9fev", "xen_975pcomment", "xen_09fdevice", "xen_9pod", "xen_9ldev", "xen_8drad", "xen_975pvalid", "xen_9bpvalid", "xen_9ddef", "xen_9fengine", "xen_9dhome", "xen_ninepdebug", "xen_9pdebug", "xen_9npdev", "xen_09pcd", "xen_9cdevice", "xen_ninecconf", "xen_9nprad", "xen_9fdem", "xen_109dconf", "xen_9prdevice", "xen_09fcd", "xen_09fev", "xen_9pscd", "xen_ninecde", "xen_9dapp", "xen_09padv", "xen_9qdef", "xen_9psdev", "xen_9lpdevice", "xen_975fpcomment", "xen_ninepcdev", "xen_ninebadv", "xen_8pdevice", "xen_9fhome", "xen_9dconf", "xen_ninepdevice", "xen_8pdev", "xen_8dconf", "xen_ninepde", "xen_9pehome", "xen_09pdi", "xen_9pude", "xen_9pdef", "xen_9ddc", "xen_9puev", "xen_9dde", "xen_9lpmode", "xen_09fde", "xen_ninefdef", "xen_09pdev", "xen_9npdevice", "xen_975fpvalid", "xen_ninecdebug", "xen_9cconf", "xen_09pdevice", "xen_8prad", "xen_9fcd", "xen_9prdev", "xen_9pidev", "xen_9pdc", "xen_9lpdev", "xen_109ddevice", "xen_109pdevice", "xen_9cdebug", "xen_9dcd", "xen_9pcd", "xen_9pcomment", "xen_9fdev", "xen_9ddev", "xen_9lpdc", "xen_9ddevice", "xen_9fpcomment", "xen_ninebdiv", "xen_10pcdev", "xen_9cpdevice", "xen_9prcd", "xen_109drad", "xen_9lpdef"], "s": ["spec", "m", "session", "stats", "t", "f", "settings", "services", "r", "service", "n", "g", "sa", "fs", "o", "d", "w", "e", "ssl", "sync", "v", "c", "p", "S", "b", "server", "states", "params"], "fsdev": ["wsconf", "wsdev", "wsdef", "fsdef", "nsDev", "fsDev", "nsdev", "dsconf", "dsdef", "wsDev", "dsDev", "fsconf", "dsdev", "nsdef", "nsconf"], "str": ["fr", "txt", "br", "code", "tr", "text", "rs", "obj", "err", "name", "ctr", "f", "sp", "expr", "ct", "r", "hr", "try", "sl", "z", "ocr", "pass", "var", "stri", "ss", "orig", "ext", "kr", "STR", "arr", "sta", "exec", "enc", "dict", "read", "style", "st", "sr", "dr", "bl", "e", "sc", "cr", "cl", "cur", "c", "req", "temp", "Str", "doc", "wr", "strike", "pr", "h", "er", "iter", "list", "inner", "input"], "ring_order": ["ringparray", " ring_info", "ringpoffset", " ring_array", "ring_array", "ring__order", "ring__info", "ring__array", "ringporder", "ring_offset", "ring_info", "ringpinfo", "ring__offset", " ring_offset"]}}
{"project": "qemu", "commit_id": "299f80130401153af1a6ddb3cc011781bcd47600", "target": 0, "func": "static void tcg_opt_gen_mov(TCGContext *s, TCGOp *op, TCGArg *args,\n\n                            TCGArg dst, TCGArg src)\n\n{\n\n    if (temps_are_copies(dst, src)) {\n\n        tcg_op_remove(s, op);\n\n        return;\n\n    }\n\n\n\n    if (temp_is_const(src)) {\n\n        tcg_opt_gen_movi(s, op, args, dst, temps[src].val);\n\n        return;\n\n    }\n\n\n\n    TCGOpcode new_op = op_to_mov(op->opc);\n\n    tcg_target_ulong mask;\n\n\n\n    op->opc = new_op;\n\n\n\n    reset_temp(dst);\n\n    mask = temps[src].mask;\n\n    if (TCG_TARGET_REG_BITS > 32 && new_op == INDEX_op_mov_i32) {\n\n        /* High bits of the destination are now garbage.  */\n\n        mask |= ~0xffffffffull;\n\n    }\n\n    temps[dst].mask = mask;\n\n\n\n    assert(!temp_is_const(src));\n\n\n\n    if (s->temps[src].type == s->temps[dst].type) {\n\n        temps[dst].next_copy = temps[src].next_copy;\n\n        temps[dst].prev_copy = src;\n\n        temps[temps[dst].next_copy].prev_copy = dst;\n\n        temps[src].next_copy = dst;\n\n        temps[dst].is_const = false;\n\n    }\n\n\n\n    args[0] = dst;\n\n    args[1] = src;\n\n}\n", "idx": 19492, "substitutes": {"s": ["ns", "spec", "m", "sup", "session", "sg", "bs", "t", "stats", "obj", "f", "sv", "services", "settings", "service", "r", "n", "sb", "g", "i", "ops", "scope", "self", "xs", "is", "o", "cs", "d", "space", "new", "site", "e", "ssl", "ses", "client", "sync", "c", "ps", "js", "sym", "p", "S", "b", "http", "sys", "h", "os", "us", "sq", "source", "u"], "op": ["ic", "oc", "wp", "init", "info", "obj", "omp", "jp", "sp", "ob", "hop", "option", "num", "or", "block", "type", "Op", "app", "oper", "node", "ops", "top", "root", "opus", "vert", "opp", "o", "ip", "oop", "prop", "exec", "arg", "pp", "up", "prev", "cop", "open", "cmd", "p", "mp", "cmp", "pop", "http", "OP", "opt", "inst", "operation", "operator"], "args": ["ans", "ns", "ms", "oc", "extra", "stats", "data", "ras", "err", "obj", "fields", "options", "sp", "vals", "objects", "ams", "g", "ips", "loc", "points", "ops", "acl", "pos", "ass", "arg", "arr", "changes", "cs", "parse", "ins", "ig", "config", "ics", "vs", "ars", "uments", "ps", "atts", "js", "p", "ids", "gs", "ants", " arguments", "parts", "flags", "pres", "py", "states", "dict", "Args", "params", "ds"], "dst": ["prest", "idrc", "dstr", "indsp", "dset", "ndsth", "jST", "DST", "indst", "didist", "dsc", "Dsts", "datst", "idsc", "pst", "Dput", " dsrc", "dost", "datsts", " dstr", " dST", "ydsc", "frc", "idput", "nsth", "ldsc", "ndsts", "indrest", "ldst", "dsp", " dsp", "addist", "ddist", "idsts", "Dsp", "ndST", "fsrc", " dsth", "dsrc", "frest", "fsc", "Dsrc", "jst", " drest", "bdost", "indsth", "idbl", " dsc", "disc", "bdsc", "addest", "datput", "jost", "idST", "idset", "adsc", "psp", "drc", "idsp", "bdst", "datsth", "Dst", "adset", "hst", "nsp", "hdest", "adsrc", "idst", "ndst", "prc", "yddest", "datST", "ldost", "diost", " ddest", " drc", "dput", "jsrc", "iddest", "ydst", " dsts", "fdest", "nrest", "fST", "jstr", "adost", " dbl", "jsc", "fst", "fbl", "hST", " ddist", " dost", "ddest", "ldrest", "adst", "adST", "nst", "ydset", "fsp", "drest", "hsp", "dist", "dST", "fsts", "dsts", "dbl", "bdstr", "dsth"], "src": ["spec", "obj", "usb", "supp", "ptr", "sec", "reverse", "rec", "secure", "new", "config", "impl", "lib", "resource", "hh", "source", "cv", "target", "sup", "rs", "rest", "dest", "rc", "hr", "stream", "bc", "scope", "share", "rob", "usc", "sub", "sc", "tmp", "uc", "gz", "null", "iv", "desc", " dest", "fp", "core", "RC", "r", "sb", "cpp", "cb", "loc", "sel", "filename", "host", "sn", "sr", "ruby", "sync", "rl", "obl", "sys", "inst", "origin", "sq", "params", "dep", "sl", "ctx", "fc", "low", "conv", "site", "img", "st", "front", "ssl", "bh", "ource", "req", "cur", "rb", "support", "url", "cmp", "http", "proc", "server", "usr", "attr", "dist"], "mask": ["scale", "offset", "skip", "shape", "code", "shadow", "info", "conf", "bit", "image", "comment", "reg", "mark", "result", "pack", "flag", "block", "clean", "match", "Mask", "max", "type", "index", "ck", "hack", "tag", "count", "copy", "sk", "ask", "ack", "cover", "cost", "iq", "stack", "size", "length", "key", "delay", "asm", "fix", "map", "bits", "qa", "patch", "pad", "sum", "lock", "arch", "filter", "depth", "black", "field", "ban", "feature", "cache", "cap", "weight", "sign", "cast", "allow", "flags", "scan", "target", "bug"]}}
{"project": "FFmpeg", "commit_id": "3594554a064d76e3514fab9781c0e63ea9e08ea9", "target": 0, "func": "av_cold void ff_dsputil_init_vis(DSPContext *c, AVCodecContext *avctx)\n\n{\n\n  /* VIS-specific optimizations */\n\n  int accel = vis_level ();\n\n  const int high_bit_depth = avctx->bits_per_raw_sample > 8;\n\n\n\n  if (accel & ACCEL_SPARC_VIS) {\n\n      if (avctx->bits_per_raw_sample <= 8 &&\n\n          avctx->idct_algo == FF_IDCT_SIMPLEVIS) {\n\n          c->idct_put = ff_simple_idct_put_vis;\n\n          c->idct_add = ff_simple_idct_add_vis;\n\n          c->idct     = ff_simple_idct_vis;\n\n          c->idct_permutation_type = FF_TRANSPOSE_IDCT_PERM;\n\n      }\n\n\n\n      if (!high_bit_depth) {\n\n      c->put_pixels_tab[0][0] = MC_put_o_16_vis;\n\n      c->put_pixels_tab[0][1] = MC_put_x_16_vis;\n\n      c->put_pixels_tab[0][2] = MC_put_y_16_vis;\n\n      c->put_pixels_tab[0][3] = MC_put_xy_16_vis;\n\n\n\n      c->put_pixels_tab[1][0] = MC_put_o_8_vis;\n\n      c->put_pixels_tab[1][1] = MC_put_x_8_vis;\n\n      c->put_pixels_tab[1][2] = MC_put_y_8_vis;\n\n      c->put_pixels_tab[1][3] = MC_put_xy_8_vis;\n\n\n\n      c->avg_pixels_tab[0][0] = MC_avg_o_16_vis;\n\n      c->avg_pixels_tab[0][1] = MC_avg_x_16_vis;\n\n      c->avg_pixels_tab[0][2] = MC_avg_y_16_vis;\n\n      c->avg_pixels_tab[0][3] = MC_avg_xy_16_vis;\n\n\n\n      c->avg_pixels_tab[1][0] = MC_avg_o_8_vis;\n\n      c->avg_pixels_tab[1][1] = MC_avg_x_8_vis;\n\n      c->avg_pixels_tab[1][2] = MC_avg_y_8_vis;\n\n      c->avg_pixels_tab[1][3] = MC_avg_xy_8_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[0][0] = MC_put_no_round_o_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][1] = MC_put_no_round_x_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][2] = MC_put_no_round_y_16_vis;\n\n      c->put_no_rnd_pixels_tab[0][3] = MC_put_no_round_xy_16_vis;\n\n\n\n      c->put_no_rnd_pixels_tab[1][0] = MC_put_no_round_o_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][1] = MC_put_no_round_x_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][2] = MC_put_no_round_y_8_vis;\n\n      c->put_no_rnd_pixels_tab[1][3] = MC_put_no_round_xy_8_vis;\n\n\n\n      c->avg_no_rnd_pixels_tab[0] = MC_avg_no_round_o_16_vis;\n\n      c->avg_no_rnd_pixels_tab[1] = MC_avg_no_round_x_16_vis;\n\n      c->avg_no_rnd_pixels_tab[2] = MC_avg_no_round_y_16_vis;\n\n      c->avg_no_rnd_pixels_tab[3] = MC_avg_no_round_xy_16_vis;\n\n      }\n\n  }\n\n}\n", "idx": 19494, "substitutes": {"c": ["dc", "pc", "oc", "ic", "s", "ch", "t", "conf", "f", "vc", "ct", "rc", "r", "w", "cm", "n", "cf", "g", "coll", "cb", "bc", "cp", "z", "ctx", "fc", "mc", "ctrl", "ca", "enc", "cs", "l", "d", "ce", "nc", "ac", "ci", "com", "con", "config", "xc", "tc", "e", "cu", "sc", "k", "cr", "cl", "lc", "cur", "p", "uc", "b", "cmp", "cache", "col", "cit", "ec", "cd", "h", "co", "C", "cc", "u"], "avctx": ["AVcp", "afctl", "afcmp", "avctl", " avloc", "aircontext", "avcp", "AVcmp", "airctl", "afcontext", "avconn", "afctx", "abctx", " avxc", "avxc", "aircmp", "abcontext", "AVloc", " avcp", "abctl", "abcmp", "afloc", "navloc", " avcmp", "navcp", "avloc", "afconn", "afxc", "AVctx", " avcontext", "navctx", "AVcontext", "avcmp", "navcontext", "navxc", "avcontext", "airctx", " avconn", "navconn"]}}
{"project": "FFmpeg", "commit_id": "5ad4335c2233d5a6d9487d2d56387b7484aecded", "target": 0, "func": "void vp8_mc(VP8Context *s, int luma,\n\n            uint8_t *dst, uint8_t *src, const VP56mv *mv,\n\n            int x_off, int y_off, int block_w, int block_h,\n\n            int width, int height, int linesize,\n\n            vp8_mc_func mc_func[3][3])\n\n{\n\n    if (AV_RN32A(mv)) {\n\n        static const uint8_t idx[3][8] = {\n\n            { 0, 1, 2, 1, 2, 1, 2, 1 }, // nr. of left extra pixels,\n\n                                        // also function pointer index\n\n            { 0, 3, 5, 3, 5, 3, 5, 3 }, // nr. of extra pixels required\n\n            { 0, 2, 3, 2, 3, 2, 3, 2 }, // nr. of right extra pixels\n\n        };\n\n        int mx = (mv->x << luma)&7, mx_idx = idx[0][mx];\n\n        int my = (mv->y << luma)&7, my_idx = idx[0][my];\n\n\n\n        x_off += mv->x >> (3 - luma);\n\n        y_off += mv->y >> (3 - luma);\n\n\n\n        // edge emulation\n\n        src += y_off * linesize + x_off;\n\n        if (x_off < mx_idx || x_off >= width  - block_w - idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - idx[2][my]) {\n\n            s->dsp.emulated_edge_mc(s->edge_emu_buffer, src - my_idx * linesize - mx_idx, linesize,\n\n                                block_w + idx[1][mx], block_h + idx[1][my],\n\n                                x_off - mx_idx, y_off - my_idx, width, height);\n\n            src = s->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n        }\n\n        mc_func[my_idx][mx_idx](dst, linesize, src, linesize, block_h, mx, my);\n\n    } else\n\n        mc_func[0][0](dst, linesize, src + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n}\n", "idx": 19538, "substitutes": {"s": ["ns", "spec", "m", "session", "sg", "stats", "t", "request", "rs", "f", "conf", "services", "sp", "service", "r", "n", "sb", "g", "sl", "ss", "ops", "fs", "self", "cs", "d", "su", "space", "site", "w", "qs", "e", "ssl", "ses", "sync", "private", "c", "js", "si", "p", "secondary", "S", "b", "http", "gs", "sys", "a", "south", "server", "sq", "sf"], "luma": ["Lama", "laea", "sluna", "sluca", "maea", "mama", " lamin", "duma", "dumo", "litaea", "laos", "lumo", "lasm", " lama", "elama", "lamin", "luna", "lituna", "maga", "maos", "luca", "plaea", "slaga", "litumen", "elta", "lama", "flasm", "lituma", "muca", "fluma", "muma", " laga", " luca", "plama", "litaos", "lcasm", "duna", "sluma", "lcama", " lumen", "lta", "litumo", " lumo", "dumen", "plaos", "lumen", " lta", "eluma", "Luca", "lcuma", "lcamin", "flamin", "pluma", "litama", "Luma", "Lta", " luna", "muna", "eluca", " lasm", "laga", "flama"], "dst": ["nsc", "nsts", "dsp", "Dst", " dsp", "bst", "Dsp", "bbl", "fst", "fbl", "wsp", "bsp", "wst", "nsp", "fsc", "Dsc", "idst", " dost", "dsc", "Dsts", "idft", "idost", "wsts", " dft", "nst", " dsc", "idsc", "fsp", "fft", "dost", "bsts", " dsts", "fsts", "wbl", "dsts", "dbl", "dft", "fost"], "src": ["href", "sur", "rs", "wx", "rest", "irc", "dest", "cdn", "rc", "border", "syn", "rel", "sb", "channel", "gin", "cb", "sl", "attr", "stream", "loc", "ls", "sel", "ctx", "slice", "zx", "sec", "filename", "replace", "low", "gb", "rob", "path", "background", "rib", "use", "sn", "sub", "img", "config", "sr", "sc", "gl", "ssl", "ruby", "sync", "send", "target", "req", "rb", "tmp", "bg", "uc", "url", "lib", "rss", "sci", "seq", "http", "gz", "output", "inst", "origin", "sq", "source", "dist", "input"], "mv": [" mvp", "hvc", "pvs", "pj", "pf", "mf", "amj", "cmh", "Mj", "Mq", "hvs", "mrvc", "mvc", " mvc", "Mf", " mself", "Mself", "amf", "pvc", "mrvs", "rc", "mw", "pq", " mver", " mx", "pv", "mver", "mself", "hv", "cmx", "mc", "amq", "Mx", "hvp", "vself", "Mb", "mov", " mw", "vver", "cmver", "mq", "amv", "mj", " mvs", " mov", "pvp", "mrver", "mb", "cmv", "vov", "mx", "rb", "rw", "Mw", "mvp", "vv", " mc", "Mov", "rv", "hver", "mh", "Mc", "Mv", "mrv", " mh", " mb", "mvs", "vh", "vx"], "x_off": [" x_ff", "x_offset", "tx67offs", "tx67error", "X_off", "tx_off", " x_fail", "xPoff", "x67off", "x_ff", "x__ff", "tx_error", "x_Off", "x__online", "x_no", "y_no", "x_OFF", " x_offs", "x67offs", "x_online", "x_mode", "x_fail", "x_on", "X_on", "y_mode", "x__off", "x_error", "X_Off", " x_online", "xPno", "tx67off", " x_offset", "tx_offs", "x_offs", "xPmode", "x67error", "X_OFF", " x_OFF", "x__OFF"], "y_off": ["yPOff", "yalloff", "y_left", "y_Off", "ry_OFF", " y_obj", "yallleft", " y_OFF", "y67dead", "y67off", "y_error", "x_Off", "y_max", "yallOFF", "y67down", "yPobj", "x_OFF", "ry_offs", "ry_over", "ry_off", "my_on", " y_ON", "y_obj", "yPoff", "x_error", "y_over", "yPoffs", "y_down", "my_max", "y_offs", "x_offs", "y_ON", "y_OFF", " y_offs", " y_left", "yalloffs", "y_on", "y_dead", "y67ON", "x_left", " y_down", " y_dead", "yPleft", "my_off"], "block_w": ["blockshw", "block67tw", "blockJw", "block_b", "blockshh", "blockJh", " block_b", " block_wall", " block_v", " block_tw", "byte_w", "byte_h", "byte_wt", "blockshv", "blockJwt", "block67w", "block6w", "byte_we", "block_wt", "blocklexb", "blocklextw", "blockshwall", "block_tw", "block_wall", "block_we", "block6h", "block6wall", "block67we", "block67h", "block_v", "block67b", "block6v", "blocklexw", "blockJwe", "block67wt", "blocklexh"], "block_h": ["blockrictsh", "block1w", "block_ht", "block1bh", " block_bh", "block67h", "Block_hs", "block1m", "blockrictht", "block_hs", "block17w", "block_n", "blocklexht", "Block_n", "blockrictw", "blocklexsh", "blocklexh", "block27hs", "block27w", "block_sh", "blocklexbh", "block27n", "Block_h", "block17bh", "block_bh", "block67n", " block_height", "block17h", "blockrictbh", "blockricth", "blockrictheight", " block_sh", "block_m", " block_m", "block1h", "block17m", "block27h", "block_height", "block67hs", "block67w", " block_ht", "Block_w"], "height": ["rank", "thin", "shape", "view", "x", "wrap", "volume", "window", "gh", "block", "rh", "th", "padding", "resolution", "dim", "alpha", "upper", "han", "gap", " heights", "hold", "size", "hang", "build", "style", "dy", "w", "length", "pull", "layout", "ths", "history", "rows", "crop", "Height", "depth", "hh", "h", "row", "ty", "holes", "density", "y", "bottom"], "linesize": ["linksgment", "pagesization", "worksize", "linksIZE", "elinesIZE", "timesizing", "lesizer", "linessize", "linersize", "linersizes", "linesizer", "limitsizing", "linesizing", "timesization", "linesized", "pagessize", " lines8", "linedgment", "elinesizer", "linedizes", "insizing", " linesizing", "linersIZE", "pagesizer", "linesization", "pagesize", " lines\n", "linedize", "lesize", "timesIZE", "lineserial", "inesIZE", "insize", "linersizer", "lesization", "lines8", "linksiz", "linksization", "limitsize", "elineserial", "linksizer", "timesize", "linesIZE", "pagesIZE", "linersized", "limitsIZE", "linersgment", "elinesize", "linerssize", "pagesizing", "worksIZE", "worksizing", "line8", "lines\n", "insization", "linksized", "lesiz", "inesize", " linesizer", "pagesized", "linesizes", "lins\n", " linesization", "linkssize", " linesiz", "inesizing", "insIZE", "limitsizer", "linksizes", "line\n", "linksize", "linedizer", "worksizer", "linesgment", " linesIZE", "inesization", " lineserial", "linesiz", "linerserial", "lins8"], "mc_func": ["MC2fun", "mc_function", "pc_callback", "mc2fun", "MC_fun", "pc_function", "MC_func", "pc_func", "pc_fun", "mcallfunction", "mcallcallback", "MC2cc", "mc5unc", "mcallfunc", "mc_unc", "MC2function", "MC_unc", "MC_cc", "mc2cc", "MC_fn", "mc5fn", "mc5func", "mc_fn", "MC2func", "MC_function", "mc2func", "mc_cc", "mc_callback", "mc2function", "mc_fun", "mcallfun", "mc5cc"], "idx": ["sidw", "idxc", "Idw", "idw", "idsxes", "namexs", "idX", "namex", " idxc", "Idz", "sidy", "idsf", "namey", "IDns", "idz", "idsxc", "idy", "IDy", "idns", "idex", "idsX", "aidy", " idns", "idexes", "sidX", "aidx", "idsxs", "namexes", " idz", "Idf", "idsy", "Idx", "Idxes", "sidxc", "IDX", "idf", "sidns", "sidxs", "Idxs", " idX", "idsx", "IDz", "IDw", "IdX", "idxes", "sidx", "IDxc", "idey", "ideX", " idf", "idxs", "Idy", "Idxc", " idxs", "aidz", "aidX", " idy", "IDx", "IDxs"]}}
{"project": "qemu", "commit_id": "449041d4db1f82f281fe097e832f07cd9ee1e864", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554, "substitutes": {"dev": ["grad", "Dev", "dd", "br", "mod", "ch", "data", "gd", "conf", "err", "obj", "md", "debug", "de", "rad", "dt", "wd", "def", "prom", "sd", "self", "d", "sh", "comp", "w", "ev", "prof", "private", "dom", "device", "req", "od", "proc", "inst", "dem", "priv", "iv", "pro", "gr", "attr", "ver"], "prop": ["part", "data", "info", "pred", "obj", "ref", "dep", "name", "op", "f", "property", "lit", "r", "rt", "root", "type", "ctx", "pb", "phy", "pos", "def", "pointer", "Prop", "val", "device", "tmp", "p", "pr", "proc", "properties", "priv", "pro", "prot", "attr", "pt"], "str": ["spec", "part", "fr", "strings", "br", "code", "tr", "text", "data", "rs", "err", "name", "ctr", "obj", "sp", "expr", "r", "hr", "ext", "stri", "sec", "arr", "STR", "enc", "val", "st", "sr", "dr", "cr", "cur", "Str", "test", "pr", "attr", "pt"], "ptr": ["pc", "fr", "offset", "tr", "t", "fp", "func", "err", "ref", "sp", "tty", "r", "nt", "rt", "src", "loc", "pos", "pointer", "val", "st", "length", "dr", "fd", "buf", "p", "vt", "pad", "inter", "pr", "spr", "inst", "addr", "Ptr", "py", "prot", "pt", "len"], "fmt": ["fnt", "Frt", "defnt", "tfMT", "frrt", "fMT", "defmbol", "frtr", "defmt", " fnt", "frmt", "sfMT", "Fmt", "fmbol", "Fmbol", " fmbol", "tfprintf", "sfmt", "tfrt", "FMT", "frMT", "Fnt", "ftr", "sftr", " fMT", " frt", "frt", "Fprintf", "tfmt", "defMT", "Ftr", "sfrt"]}}
{"project": "FFmpeg", "commit_id": "ac4b32df71bd932838043a4838b86d11e169707f", "target": 1, "func": "DECLARE_LOOP_FILTER(mmxext)\n\nDECLARE_LOOP_FILTER(sse2)\n\nDECLARE_LOOP_FILTER(ssse3)\n\nDECLARE_LOOP_FILTER(sse4)\n\n\n\n#endif /* HAVE_YASM */\n\n\n\n#define VP8_LUMA_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][2] = ff_put_vp8_epel ## SIZE ## _h6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][0] = ff_put_vp8_epel ## SIZE ## _v6_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][2] = ff_put_vp8_epel ## SIZE ## _h6v6_ ## OPT\n\n\n\n#define VP8_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_epel_pixels_tab[IDX][0][1] = ff_put_vp8_epel ## SIZE ## _h4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][0] = ff_put_vp8_epel ## SIZE ## _v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][1] = ff_put_vp8_epel ## SIZE ## _h4v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][1][2] = ff_put_vp8_epel ## SIZE ## _h6v4_ ## OPT; \\\n\n    c->put_vp8_epel_pixels_tab[IDX][2][1] = ff_put_vp8_epel ## SIZE ## _h4v6_ ## OPT; \\\n\n    VP8_LUMA_MC_FUNC(IDX, SIZE, OPT)\n\n\n\n#define VP8_BILINEAR_MC_FUNC(IDX, SIZE, OPT) \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][1] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][0][2] = ff_put_vp8_bilinear ## SIZE ## _h_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][1][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][0] = ff_put_vp8_bilinear ## SIZE ## _v_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][1] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT; \\\n\n    c->put_vp8_bilinear_pixels_tab[IDX][2][2] = ff_put_vp8_bilinear ## SIZE ## _hv_ ## OPT\n\n\n\n\n\nav_cold void ff_vp8dsp_init_x86(VP8DSPContext* c)\n\n{\n\n#if HAVE_YASM\n\n    int cpu_flags = av_get_cpu_flags();\n\n\n\n    if (EXTERNAL_MMX(cpu_flags)) {\n\n        c->vp8_idct_dc_add    = ff_vp8_idct_dc_add_mmx;\n\n        c->vp8_idct_dc_add4uv = ff_vp8_idct_dc_add4uv_mmx;\n\n#if ARCH_X86_32\n\n        c->vp8_idct_dc_add4y  = ff_vp8_idct_dc_add4y_mmx;\n\n        c->vp8_idct_add       = ff_vp8_idct_add_mmx;\n\n        c->vp8_luma_dc_wht    = ff_vp8_luma_dc_wht_mmx;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_mmx;\n\n#endif\n\n        c->put_vp8_epel_pixels_tab[1][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[1][0][0] = ff_put_vp8_pixels8_mmx;\n\n\n\n#if ARCH_X86_32\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_mmx;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_mmx;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmx;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmx;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmx;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmx;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmx;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmx;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmx;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmx;\n\n#endif\n\n    }\n\n\n\n    /* note that 4-tap width=16 functions are missing because w=16\n\n     * is only used for luma, and luma is always a copy or sixtap. */\n\n    if (EXTERNAL_MMXEXT(cpu_flags)) {\n\n        VP8_MC_FUNC(2, 4, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, mmxext);\n\n#if ARCH_X86_32\n\n        VP8_LUMA_MC_FUNC(0, 16, mmxext);\n\n        VP8_MC_FUNC(1, 8, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, mmxext);\n\n        VP8_BILINEAR_MC_FUNC(1,  8, mmxext);\n\n\n\n        c->vp8_v_loop_filter_simple   = ff_vp8_v_loop_filter_simple_mmxext;\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_mmxext;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_mmxext;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_mmxext;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_mmxext;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_mmxext;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_mmxext;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_mmxext;\n\n#endif\n\n    }\n\n\n\n    if (EXTERNAL_SSE(cpu_flags)) {\n\n        c->vp8_idct_add                         = ff_vp8_idct_add_sse;\n\n        c->vp8_luma_dc_wht                      = ff_vp8_luma_dc_wht_sse;\n\n        c->put_vp8_epel_pixels_tab[0][0][0]     =\n\n        c->put_vp8_bilinear_pixels_tab[0][0][0] = ff_put_vp8_pixels16_sse;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags) && (cpu_flags & AV_CPU_FLAG_SSE2SLOW)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, sse2);\n\n        VP8_MC_FUNC(1, 8, sse2);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, sse2);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, sse2);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_sse2;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_sse2;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_sse2;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSE2(cpu_flags)) {\n\n        c->vp8_idct_dc_add4y          = ff_vp8_idct_dc_add4y_sse2;\n\n\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_sse2;\n\n\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_sse2;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_sse2;\n\n\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse2;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse2;\n\n    }\n\n\n\n    if (EXTERNAL_SSSE3(cpu_flags)) {\n\n        VP8_LUMA_MC_FUNC(0, 16, ssse3);\n\n        VP8_MC_FUNC(1, 8, ssse3);\n\n        VP8_MC_FUNC(2, 4, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(0, 16, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(1, 8, ssse3);\n\n        VP8_BILINEAR_MC_FUNC(2, 4, ssse3);\n\n\n\n        c->vp8_v_loop_filter_simple = ff_vp8_v_loop_filter_simple_ssse3;\n\n        c->vp8_h_loop_filter_simple = ff_vp8_h_loop_filter_simple_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y_inner = ff_vp8_v_loop_filter16y_inner_ssse3;\n\n        c->vp8_h_loop_filter16y_inner = ff_vp8_h_loop_filter16y_inner_ssse3;\n\n        c->vp8_v_loop_filter8uv_inner = ff_vp8_v_loop_filter8uv_inner_ssse3;\n\n        c->vp8_h_loop_filter8uv_inner = ff_vp8_h_loop_filter8uv_inner_ssse3;\n\n\n\n        c->vp8_v_loop_filter16y       = ff_vp8_v_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_ssse3;\n\n        c->vp8_v_loop_filter8uv       = ff_vp8_v_loop_filter8uv_mbedge_ssse3;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_ssse3;\n\n    }\n\n\n\n    if (EXTERNAL_SSE4(cpu_flags)) {\n\n        c->vp8_idct_dc_add                  = ff_vp8_idct_dc_add_sse4;\n\n\n\n        c->vp8_h_loop_filter_simple   = ff_vp8_h_loop_filter_simple_sse4;\n\n        c->vp8_h_loop_filter16y       = ff_vp8_h_loop_filter16y_mbedge_sse4;\n\n        c->vp8_h_loop_filter8uv       = ff_vp8_h_loop_filter8uv_mbedge_sse4;\n\n    }\n\n#endif /* HAVE_YASM */\n\n}\n", "idx": 19557, "substitutes": {}}
{"project": "qemu", "commit_id": "b227a8e9aa5f27d29f77ba90d5eb9d0662a1175e", "target": 0, "func": "static int get_bat (CPUState *env, mmu_ctx_t *ctx,\n\n                    target_ulong virtual, int rw, int type)\n\n{\n\n    target_ulong *BATlt, *BATut, *BATu, *BATl;\n\n    target_ulong base, BEPIl, BEPIu, bl;\n\n    int i;\n\n    int ret = -1;\n\n\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    switch (type) {\n\n    case ACCESS_CODE:\n\n        BATlt = env->IBAT[1];\n\n        BATut = env->IBAT[0];\n\n        break;\n\n    default:\n\n        BATlt = env->DBAT[1];\n\n        BATut = env->DBAT[0];\n\n        break;\n\n    }\n\n#if defined (DEBUG_BATS)\n\n    if (loglevel != 0) {\n\n        fprintf(logfile, \"%s...: %cBAT v 0x\" ADDRX \"\\n\", __func__,\n\n                type == ACCESS_CODE ? 'I' : 'D', virtual);\n\n    }\n\n#endif\n\n    base = virtual & 0xFFFC0000;\n\n    for (i = 0; i < 4; i++) {\n\n        BATu = &BATut[i];\n\n        BATl = &BATlt[i];\n\n        BEPIu = *BATu & 0xF0000000;\n\n        BEPIl = *BATu & 0x0FFE0000;\n\n        bl = (*BATu & 0x00001FFC) << 15;\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                    \" BATl 0x\" ADDRX \"\\n\",\n\n                    __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                    *BATu, *BATl);\n\n        }\n\n#endif\n\n        if ((virtual & 0xF0000000) == BEPIu &&\n\n            ((virtual & 0x0FFE0000) & ~bl) == BEPIl) {\n\n            /* BAT matches */\n\n            if ((msr_pr == 0 && (*BATu & 0x00000002)) ||\n\n                (msr_pr == 1 && (*BATu & 0x00000001))) {\n\n                /* Get physical address */\n\n                ctx->raddr = (*BATl & 0xF0000000) |\n\n                    ((virtual & 0x0FFE0000 & bl) | (*BATl & 0x0FFE0000)) |\n\n                    (virtual & 0x0001F000);\n\n                if (*BATl & 0x00000001)\n\n                    ctx->prot = PAGE_READ;\n\n                if (*BATl & 0x00000002)\n\n                    ctx->prot = PAGE_WRITE | PAGE_READ;\n\n#if defined (DEBUG_BATS)\n\n                if (loglevel != 0) {\n\n                    fprintf(logfile, \"BAT %d match: r 0x\" PADDRX\n\n                            \" prot=%c%c\\n\",\n\n                            i, ctx->raddr, ctx->prot & PAGE_READ ? 'R' : '-',\n\n                            ctx->prot & PAGE_WRITE ? 'W' : '-');\n\n                }\n\n#endif\n\n                ret = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n    if (ret < 0) {\n\n#if defined (DEBUG_BATS)\n\n        if (loglevel != 0) {\n\n            fprintf(logfile, \"no BAT match for 0x\" ADDRX \":\\n\", virtual);\n\n            for (i = 0; i < 4; i++) {\n\n                BATu = &BATut[i];\n\n                BATl = &BATlt[i];\n\n                BEPIu = *BATu & 0xF0000000;\n\n                BEPIl = *BATu & 0x0FFE0000;\n\n                bl = (*BATu & 0x00001FFC) << 15;\n\n                fprintf(logfile, \"%s: %cBAT%d v 0x\" ADDRX \" BATu 0x\" ADDRX\n\n                        \" BATl 0x\" ADDRX \" \\n\\t\"\n\n                        \"0x\" ADDRX \" 0x\" ADDRX \" 0x\" ADDRX \"\\n\",\n\n                        __func__, type == ACCESS_CODE ? 'I' : 'D', i, virtual,\n\n                        *BATu, *BATl, BEPIu, BEPIl, bl);\n\n            }\n\n        }\n\n#endif\n\n    }\n\n    /* No hit */\n\n    return ret;\n\n}\n", "idx": 19567, "substitutes": {"env": ["operator", "viron", "txt", "db", "global", "esp", "code", "cal", "eu", "ne", "assets", "exc", "current", "ou", "oa", "np", "chal", "environment", "ext", "scope", "dt", "manager", "console", "en", "her", "enc", "equ", "exec", "context", "inet", "nc", "event", "network", "iss", "ev", "config", "e", "vs", "qt", "v", "inv", "ea", "que", "dat", "eur", "ec", "proc", "inst", "iv", "et", "end", "eni", "server", "Environment", "cv", "conn"], "ctx": ["grad", "cc", "fp", "obj", "vc", "ct", "rc", "exc", "cf", "cb", "cp", "loc", "bc", "src", "environment", "scope", "ctrl", "cas", "Context", "ca", "exec", "context", "hw", "cms", "conv", "nc", "tx", "config", "sc", "qt", "cl", "client", "lc", "qq", "qa", "cmd", "sci", "ec", "fn", "proc", "inst", "connection", "sq", "cv", "conn"], "virtual": [" Virtual", "uri", "visible", "vid", "physical", "complex", "required", "global", "text", "view", "optional", "component", "net", "lit", "ne", "current", "bitcoin", "setting", "public", "environment", "protected", "mini", "console", "active", "lv", "vert", "vm", "fake", "plain", "context", "final", "format", "NV", "mobile", "initial", "hidden", "config", "front", "remote", "dirty", "v", "unit", "hard", "variable", "binary", "special", "external", "volt", "actual", "resource", "output", "total", "Virtual", "virt", "intel", "iv", "connection", "visual", "enabled", "server", "valid", "fi", "real", "version", "target"], "rw": ["fp", "ref", "vc", "fe", "rc", "io", "nt", "rt", "result", "self", "ip", "rec", "nc", "ww", "wire", "ig", "w", "lr", "ih", "rb", "rl", "vt", "ive", "res", "weight", "iv", "outer", "ib"], "type": ["types", "status", "part", "time", "t", "code", "info", "user", "name", "ref", "bit", "f", "full", "action", "lit", "op", "pe", "ping", "file", "role", "block", "method", "var", "loc", "source", "function", "kind", "model", "val", "class", "format", "Type", "event", "pre", "like", "style", "rule", "site", "call", "size", "config", "id", "open", "parent", "unit", "by", "TYPE", "test", "none", "resource", "error", "level", "len", "ty", "state", "py", "port", "valid", "value", "ype", "y", "version", "target", "typ"], "BATlt": [" BATnat", "BATLT", "BGLT", "BATnat", "BTLT", "ATli", "NATelt", "ATut", "MATLT", "BTli", "MATnat", "ATelt", " BATli", "ATlt", "BTelt", "BGlt", "BATli", "BGnat", "BTlt", "ATLT", "BATelt", "NATl", "NATLT", " BATLT", "MATlt", "NATlt", "BTut", "MATut", "BGl", "BTl", "MATl", "ATl"], "BATut": ["BGlett", "MATUT", "BATlet", "BATLT", "BGLT", "BTLT", "BATlett", "MATutil", "BGlet", "BATutil", "ATut", "BGut", "MATLT", "BTlit", "BGuint", "MATu", "ATutt", "BITlit", "ATlt", "MATlett", "BATutt", "BGlt", "BITut", "ATlit", "BTUT", "BTuint", "BTlt", "BTutt", "BGUT", "MATlet", "BITlt", "MATuint", "BITutt", "BATuint", "BATUT", "BTlett", "ATutil", "MATlt", " BATutil", "BTut", "MATut", "BATlit", "BTlet", "ATu"], "BATu": ["BUSur", "CHATut", "BTur", "BATlu", "ATui", " BATU", "BTus", "BATt", "CHATul", "BATui", "APPus", "MATu", "BATus", "MATui", "NATur", "ATul", "CHATou", " BATt", "BTui", "NATu", " BATur", " BATou", "BATou", "BATul", "BUSui", "NATul", "MATul", "BITut", "BITlu", "APPui", "BATU", "MATt", "MATou", "BATur", "BUSU", "APPu", "MATus", "BITu", "MATur", " BATui", "APPul", " BATul", "MATlu", "BTut", "MATut", "BTlu", "ATur", "BTl", "CHATu", "MATl", "BTul", "BTt", "NATui", "BTu", "BTU", "ATu", "BITur", "BUSu"], "BATl": ["BITv", "s", "BITl", "MATn", "r", "MATu", "ATul", " BATL", "g", "MATL", "BTn", " BATv", "BATul", "MATul", "BATv", "BATL", "BITL", "MATv", "BITu", " BATn", "_", "BATn", " BATul", "BTl", "MATl", "addr", "BTu", "ATu", "ATl", "ATL"], "base": ["bi", "scale", "bin", "physical", " baseline", "core", "al", "bit", "name", "Base", "buffer", "rc", "file", " bias", "bc", " bases", "protected", " last", " fe", "object", "is", "ip", "val", " v", "config", "id", "bas", " unit", "v", "unit", "si", "soft", "BL", "area", "b", " mini", "Virtual", "boot", "et", "basic", "local", "live", "end", "it"], "BEPIl": ["BIPIl", "BIPUrl", "BEPEntity", "BepLt", " BEPExc", "BMPAlt", "BEPInc", "BepAlt", "BEMIl", " BTPInc", "BepEl", "BepIl", " BEPLt", "BMPEl", " BMPExc", " BMPEl", " BIPNL", "BEEPEntity", " BIPUrl", " BTPEntity", "BTPLt", "BepEntity", "BIPIns", "BEMUrl", " BMPAlt", "BepExc", "BepInc", "BMPIl", "BEPNL", "BEPUrl", "BEPExc", "BNPExc", " BEPNL", " BEPAlt", "BEPEl", " BTPLt", "BNPEl", "BEEPIl", " BEPInc", "BIPNL", " BEPUrl", " BTPIl", "BepIns", "BEEPLt", "BNPIl", "BepUrl", " BEPEntity", "BTPInc", "BEPLt", "BNPAlt", " BMPIl", "BEMNL", "BMPExc", " BEPEl", "BTPIl", " BIPIl", "BEEPInc", "BEPAlt", "BTPEntity", "BepNL", "BEMIns", " BEPIns", " BIPIns", "BEPIns"], "BEPIu": ["BEPUou", "BEPIue", "BEPUui", "BEPKIul", "BEPUcu", "BEPIDEul", "BMPIu", "BEPSIo", "BEPEq", "BECIIul", "BEPITou", "BAPSIu", "BEPIo", "BEPIDEcu", "BEPIIcu", "BEPKIcu", "BEPIou", "BMPIui", "BEPEu", "BMPIIou", "BEPITui", "BEPSIue", "BEPIcu", "BAPIq", "BECIIcu", "BEPIIu", "BEPIui", "BEPIIui", "BEPNue", "BEPUu", "BMPIou", "BAPSIue", "BAPIu", "BEPEo", "BECIIut", "BEPEue", "BEPNo", "BMPIcu", "BECIIu", "BEPIul", "BEPNq", "BECIul", "BMPIIu", "BEPITcu", "BEPNu", "BMPIIcu", "BEPSIu", "BEPIq", "BECIu", "BEPIIou", "BECIcu", "BAPIo", "BEPKIu", "BEPKIut", "BEPITu", "BEPIDEu", "BAPSIo", "BECIut", "BEPIDEut", "BAPIue", "BEPIIut", "BAPSIq", "BEPIut", "BEPSIq", "BEPIIul", "BMPIIui"], "bl": ["eb", "typ", "Bl", " Bl", "lit", "abl", "pl", "rel", "lu", "ble", "kl", "block", "sl", "nl", "loc", "ld", "pb", "lb", "iol", "dl", "ml", "label", "tl", "val", "fl", " BL", "ali", "sil", "il", "gl", "bh", "cl", "rl", "bg", "ll", "BL", "obl", "lock", "ly", "bel", "isl", "yl", "blast", "el", "ill", "pt", "li", "ib", "len"], "i": ["ti", "gi", "m", "j", "ji", "t", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "mi", "n", "phi", "gu", "io", "hi", "z", "ii", "in", "iu", "index", "di", "mini", "I", "multi", "out", "is", "ip", "chi", "l", "adi", "yi", "pi", "ui", "ci", "id", "start", "e", "v", "ni", "c", "si", "ri", "p", "xi", "b", "mu", "uli", "anti", "h", "end", "it", "eni", "fi", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "2ff30257974e19ebe2a97baad32ac29c06da5fb9", "target": 0, "func": "static void *migration_thread(void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n    /* Used by the bandwidth calcs, updated later */\n\n    int64_t initial_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n    int64_t setup_start = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n\n    int64_t initial_bytes = 0;\n\n    int64_t max_size = 0;\n\n    int64_t start_time = initial_time;\n\n    int64_t end_time;\n\n    bool old_vm_running = false;\n\n    bool entered_postcopy = false;\n\n    /* The active state we expect to be in; ACTIVE or POSTCOPY_ACTIVE */\n\n    enum MigrationStatus current_active_state = MIGRATION_STATUS_ACTIVE;\n\n\n\n    rcu_register_thread();\n\n\n\n    qemu_savevm_state_header(s->to_dst_file);\n\n\n\n    if (migrate_postcopy_ram()) {\n\n        /* Now tell the dest that it should open its end so it can reply */\n\n        qemu_savevm_send_open_return_path(s->to_dst_file);\n\n\n\n        /* And do a ping that will make stuff easier to debug */\n\n        qemu_savevm_send_ping(s->to_dst_file, 1);\n\n\n\n        /*\n\n         * Tell the destination that we *might* want to do postcopy later;\n\n         * if the other end can't do postcopy it should fail now, nice and\n\n         * early.\n\n         */\n\n        qemu_savevm_send_postcopy_advise(s->to_dst_file);\n\n    }\n\n\n\n    qemu_savevm_state_begin(s->to_dst_file, &s->params);\n\n\n\n    s->setup_time = qemu_clock_get_ms(QEMU_CLOCK_HOST) - setup_start;\n\n    current_active_state = MIGRATION_STATUS_ACTIVE;\n\n    migrate_set_state(&s->state, MIGRATION_STATUS_SETUP,\n\n                      MIGRATION_STATUS_ACTIVE);\n\n\n\n    trace_migration_thread_setup_complete();\n\n\n\n    while (s->state == MIGRATION_STATUS_ACTIVE ||\n\n           s->state == MIGRATION_STATUS_POSTCOPY_ACTIVE) {\n\n        int64_t current_time;\n\n        uint64_t pending_size;\n\n\n\n        if (!qemu_file_rate_limit(s->to_dst_file)) {\n\n            uint64_t pend_post, pend_nonpost;\n\n\n\n            qemu_savevm_state_pending(s->to_dst_file, max_size, &pend_nonpost,\n\n                                      &pend_post);\n\n            pending_size = pend_nonpost + pend_post;\n\n            trace_migrate_pending(pending_size, max_size,\n\n                                  pend_post, pend_nonpost);\n\n            if (pending_size && pending_size >= max_size) {\n\n                /* Still a significant amount to transfer */\n\n\n\n                if (migrate_postcopy_ram() &&\n\n                    s->state != MIGRATION_STATUS_POSTCOPY_ACTIVE &&\n\n                    pend_nonpost <= max_size &&\n\n                    atomic_read(&s->start_postcopy)) {\n\n\n\n                    if (!postcopy_start(s, &old_vm_running)) {\n\n                        current_active_state = MIGRATION_STATUS_POSTCOPY_ACTIVE;\n\n                        entered_postcopy = true;\n\n                    }\n\n\n\n                    continue;\n\n                }\n\n                /* Just another iteration step */\n\n                qemu_savevm_state_iterate(s->to_dst_file, entered_postcopy);\n\n            } else {\n\n                trace_migration_thread_low_pending(pending_size);\n\n                migration_completion(s, current_active_state,\n\n                                     &old_vm_running, &start_time);\n\n                break;\n\n            }\n\n        }\n\n\n\n        if (qemu_file_get_error(s->to_dst_file)) {\n\n            migrate_set_state(&s->state, current_active_state,\n\n                              MIGRATION_STATUS_FAILED);\n\n            trace_migration_thread_file_err();\n\n            break;\n\n        }\n\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n        if (current_time >= initial_time + BUFFER_DELAY) {\n\n            uint64_t transferred_bytes = qemu_ftell(s->to_dst_file) -\n\n                                         initial_bytes;\n\n            uint64_t time_spent = current_time - initial_time;\n\n            double bandwidth = (double)transferred_bytes / time_spent;\n\n            max_size = bandwidth * migrate_max_downtime() / 1000000;\n\n\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                    ((double) time_spent / 1000.0)) / 1000.0 / 1000.0;\n\n\n\n            trace_migrate_transferred(transferred_bytes, time_spent,\n\n                                      bandwidth, max_size);\n\n            /* if we haven't sent anything, we don't want to recalculate\n\n               10000 is a small enough number for our purposes */\n\n            if (s->dirty_bytes_rate && transferred_bytes > 10000) {\n\n                s->expected_downtime = s->dirty_bytes_rate / bandwidth;\n\n            }\n\n\n\n            qemu_file_reset_rate_limit(s->to_dst_file);\n\n            initial_time = current_time;\n\n            initial_bytes = qemu_ftell(s->to_dst_file);\n\n        }\n\n        if (qemu_file_rate_limit(s->to_dst_file)) {\n\n            /* usleep expects microseconds */\n\n            g_usleep((initial_time + BUFFER_DELAY - current_time)*1000);\n\n        }\n\n    }\n\n\n\n    trace_migration_thread_after_loop();\n\n    /* If we enabled cpu throttling for auto-converge, turn it off. */\n\n    cpu_throttle_stop();\n\n    end_time = qemu_clock_get_ms(QEMU_CLOCK_REALTIME);\n\n\n\n    qemu_mutex_lock_iothread();\n\n    qemu_savevm_state_cleanup();\n\n    if (s->state == MIGRATION_STATUS_COMPLETED) {\n\n        uint64_t transferred_bytes = qemu_ftell(s->to_dst_file);\n\n        s->total_time = end_time - s->total_time;\n\n        if (!entered_postcopy) {\n\n            s->downtime = end_time - start_time;\n\n        }\n\n        if (s->total_time) {\n\n            s->mbps = (((double) transferred_bytes * 8.0) /\n\n                       ((double) s->total_time)) / 1000;\n\n        }\n\n        runstate_set(RUN_STATE_POSTMIGRATE);\n\n    } else {\n\n        if (old_vm_running && !entered_postcopy) {\n\n            vm_start();\n\n        } else {\n\n            if (runstate_check(RUN_STATE_FINISH_MIGRATE)) {\n\n                runstate_set(RUN_STATE_POSTMIGRATE);\n\n            }\n\n        }\n\n    }\n\n    qemu_bh_schedule(s->cleanup_bh);\n\n    qemu_mutex_unlock_iothread();\n\n\n\n    rcu_unregister_thread();\n\n    return NULL;\n\n}\n", "idx": 19574, "substitutes": {"opaque": [" opque", "OPhole", "oppac", "ophole", " opacity", "opac", "opec", "operec", "opacity", "phole", " opac", "pacity", "oppaque", "operaque", " ophole", "OPaques", " opec", "paques", "operque", "paque", "OPaque", "OPacity", "operac", "opaques", "oppque", "opque", " opaques", "oppec"], "s": ["ns", "spec", "m", "ts", "sg", "stats", "rs", "conf", "f", "aws", "t", "settings", "services", "service", "sie", "sb", "g", "i", "sl", "ss", "ls", "scope", "fs", "is", "o", "cs", "l", "submit", "d", "su", "new", "args", "site", "w", "qs", "serv", "ssl", "side", "e", "ses", "sync", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "b", "ks", "http", "gs", "sys", "your", "storage", "h", "a", "es", "os", "state", "hs", "south", "states", "sq", "sets", "server", "source", "y", "ds", "sf"], "end_time": ["end___time", "start_size", "start_time", "end\u00b7time", "end___money", "end\u00b7money", "start_money", "end\u00b7offset", "end___size", "start_offset", "end\u00b7size", "end_money", "end_offset", "end_size", "end___offset"], "current_time": ["reported_mode", "current00times", "current_mode", "reported_time", "reported_times", "current00time", "current00speed", "current_speed", "current67times", "current67speed", "current67mode", "current_times", "reported_speed", "current00mode", "current67time"], "pending_size": ["pending_bytes", "pended_bytes", "pending_page", "pended_page", "pended_time", "pending_time", "pended_size"], "pend_post": ["pend00pre", "pend2post", "pend_posts", "pend_type", "pend2posts", "pend_pre", "end_pre", "pend2type", "pend2pre", "pend00post", "end_type", "end_posts", "pend00type", "end_post", "pend00posts"], "pend_nonpost": ["pend_preproc", "pend_nonproc", "pend_preupload", "pend_unpadding", "pend_unproc", "pend_prepost", "pend_prepadding", "pend_nonpadding", "pend_nonupload", "pend_unpost", "pend_unupload"]}}
{"project": "qemu", "commit_id": "b6954712abea03afd686b724060f9873e2c61f2b", "target": 0, "func": "void replay_input_event(QemuConsole *src, InputEvent *evt)\n\n{\n\n    if (replay_mode == REPLAY_MODE_PLAY) {\n\n        /* Nothing */\n\n    } else if (replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_add_input_event(qapi_clone_InputEvent(evt));\n\n    } else {\n\n        qemu_input_event_send_impl(src, evt);\n\n    }\n\n}\n", "idx": 19576, "substitutes": {"src": ["rs", "func", "dest", "vc", "rc", "scene", "sb", "cb", "bc", "loc", "hub", "sel", "ctx", "node", "host", "gb", "rob", "socket", "ipl", "comp", "img", "sc", "gl", "sth", "bh", "sync", "req", "bg", "rb", "rl", "support", "url", "lib", "http", "sys", "scenes", "inst", "iv", "proc", "source", "target"], "evt": ["ecd", "epp", "ect", "Evd", "evtt", "Evc", "ektt", "evv", "Evts", "evp", "evts", "epv", "evl", "epts", "ervt", "ervp", "Evl", "everc", "everl", "epc", "ept", "evd", "everts", "ecc", "Evt", "ekp", "epd", "ervc", "ekt", "ekc", "evc", "eptt", "epl", "ecv", "Evv", "evert", "ervtt"]}}
{"project": "FFmpeg", "commit_id": "7b6a51f59c467ab9f4b73122dc269206fb517425", "target": 1, "func": "static inline unsigned int get_uint(ShortenContext *s, int k)\n\n{\n\n    if (s->version != 0)\n\n        k = get_ur_golomb_shorten(&s->gb, ULONGSIZE);\n\n    return get_ur_golomb_shorten(&s->gb, k);\n\n}\n", "idx": 19593, "substitutes": {"s": ["ns", "spec", "sup", "ts", "sg", "session", "stats", "t", "aws", "rs", "f", "sv", "settings", "services", "service", "sb", "ges", "ss", "ls", "in", "ops", "ctx", "fs", "self", "o", "cs", "su", "args", "sr", "e", "ssl", "ses", "sync", "c", "js", "si", "ps", "sym", "p", "S", "gs", "sys", "u", "storage", "a", "es", "sets", "sq", "ds", "sf"], "k": ["spec", "m", "j", "ik", "kick", "f", "x", "ek", "n", "uk", "g", "ok", "K", "i", "kind", "kid", "kw", "get", "o", "sk", "d", "size", "ko", "kn", "w", "length", "key", "id", "q", "ak", "v", "p", "ku", "ks", "b", "ke", "dk", "kk", "u"]}}
{"project": "FFmpeg", "commit_id": "136ce8baa4fc16cf38690cb457f7356c00e00a28", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595, "substitutes": {"dst": ["dsl", "idrc", "dstr", "ndsc", "dset", "idsta", "pdst", "Dstr", "ldss", "pdsc", "dss", "lsta", "dsc", "Dsts", " dset", "pdsts", "idsc", "deste", "adsts", "Dstd", " dstr", "frc", "ldsc", "ldste", "ldest", "ldst", "dest", "dste", "idsts", "frest", "Dsc", "Dset", "Drc", " dsc", "idss", "addest", "lddest", "idset", " dest", "adsc", "drc", "idrest", "Dst", "sdsl", "adset", "lsts", " dste", "dstd", "idst", "ndst", "adstd", "sddest", "Dsl", "Drest", "sdsts", "lst", " ddest", "ndsl", "ldsts", "iddest", " dsts", "lsc", " dstd", "destd", "dests", "fst", "ldsl", "ddest", "dsta", "sdst", "ldstd", "pdset", "adst", "idstr", " dsta", "drest", "idest", " dss", "fsts", "idsl", "nddest", "dsts", " dsl"], "src": ["spec", "gn", "sup", "grad", "btn", "txt", "sit", "sur", "stat", "func", "rest", "irc", "dest", "sort", "rc", "supp", "sb", "cb", "sl", "attr", "loc", "sel", "ctx", "sec", "low", "gb", "rob", "usc", "inf", "secure", "conv", "feat", "ins", "stack", "www", "sites", "sn", "st", "img", "sub", "sr", "sc", "config", "sth", "ssl", "sync", "start", "gl", "rb", "seq", "lib", "support", "uc", "rss", "sci", "tmp", "url", "obl", "sys", "split", "proc", "inst", "iv", "ser", "rect", "desc", "sq", "kk", "source", "dist"], "dynrng": ["dynrface", "dynamrface", "dblRgen", "dynarng", "dynRgn", "dynsrNG", "dyncrNG", "dynrreg", "dynframp", "dynfrNG", "dynfrng", "dynamicrNG", "dynargen", "dblrgn", "dynsrng", "dynrNG", "dynRNG", "dynrangeface", "dblrng", "dynamrrng", "dynamrNG", "dynrrng", "dynRamp", "dynamrrNG", "dynsrgn", "dynrrface", "dynamicfrng", "dyncrgn", "dynRng", "dynamrng", "dynrangeNG", "dynrangereg", "dynrgen", "dynRreg", "dynamrrface", "dynamicrgen", "dynRface", "dynRgen", "dblRNG", "dynamrrreg", "dynamicfrNG", "dynrrNG", "dynamicframp", "dynrangeng", "dyncrng", "dblRgn", "dynfrgen", "dynamrreg", "dyncrgen", "dynramp", "dblrNG", "dynaramp", "dynamicrng", "dynrrreg", "dynamicramp", "dynsrgen", "dynarNG", "dynrgn", "dynamicfrgen", "dblRng", "dblrgen"], "len": ["lon", "bin", "offset", "lim", "alt", "all", "lit", "n", "num", "sl", "z", "loc", "ld", "pos", "dl", "dim", "en", "lf", "ln", "l", "val", "fl", "size", "length", "limit", "bl", "lc", "ll", "lvl", "depth", "lock", "fn", "split", "lin", "list", "el", "li", "Len"], "i": ["uri", "ic", "bi", "ji", "x", "jit", "qi", "ai", "phi", "hi", "ie", "d", "pi", "id", "cli", "ni", "p", "xi", "h", "us", "it", "me", "fi", "source", "gi", "m", "sup", "ei", "init", "j", "ix", "ini", "iu", "I", "o", "key", "k", "v", "si", "ki", "iv", "list", "ti", "f", "image", "r", "mi", "try", "ii", "di", "ind", "mini", "multi", "zi", "page", "l", "oi", "yi", "ci", "start", "q", "c", "line", "b", "eni", "mu", "info", "io", "n", "wait", "g", "ani", "z", "index", "slice", "is", "ip", "ui", "site", "isin", "e", "isi", "api", "my", "inner", "y", "li", "u"], "shift": ["set", "offset", "sample", "center", "align", "pack", "late", "pos", "zip", "reverse", "wind", "range", "ress", "sh", "select", "box", "length", "send", "mix", "crop", "pad", "pop", "loop", "repeat", "end", "scale", "sup", "init", "ff", "frac", "ix", "sort", "lower", "count", "vert", "share", "force", "load", "size", "patch", "off", "depth", "field", "flower", "cart", "order", "transfer", "push", "hift", "drop", "ice", "keep", "back", "ize", "start", "delay", "power", "gravity", "transform", "sq", "version", "sleep", "shape", "small", "throw", "hide", "slice", "ip", "half", "space", "seed", "roll", "use", "adjust", "pull", "limit", "fix", "pick", "cap", "error", "radius", "Shift", "diff", "escape", "dist"], "round": ["vel", "scale", "offset", "ff", "shape", "push", "ort", "call", "track", "alt", "ound", "sort", "scroll", "r", "feed", "drop", "Round", "type", "method", "control", "slice", "run", "low", "half", "range", "wind", "pair", "keep", "sound", "close", "rol", "hold", "build", "seed", "tab", "roll", "length", "key", "pull", "wave", "high", "shock", "patch", "render", "crop", "mix", "play", "lock", "rounded", "col", "cell", "field", "form", "row", "flower", "sign", "rect", "loop", "end", "port", "diff", "order", "attr", "grow", "version"], "mul": ["Mul", " muse", "amul", "Muli", " mil", "pmule", "nulus", "str", " mold", "Mule", "nuli", "pulus", "emula", "dil", "luse", "Mpull", " mulus", "tmUL", "pmula", "Male", "nul", "dUL", "amull", "pil", " mulation", "cmul", "mUL", "frac", "emule", "eff", "ctr", "mmold", "amule", "emul", "lesh", "lush", "mpull", "pmull", "mulus", "smul", " mun", "smUL", "mull", "smulation", "duse", "pUL", "null", " mull", "ampull", "dulation", "emull", "lUL", "dul", "dold", "amUL", "mmUL", "mula", "pale", "mmula", "mule", " mpull", "jull", "r", "Mush", " male", "mmul", "mun", "jesh", " mush", "mmuli", " mula", "smush", "smull", "cmull", "jUL", "mulation", "mush", "Mesh", "pmul", "Mulation", "mesh", "tmull", "lule", "amuli", " mule", "muli", " muli", "mil", "dull", "tmuli", "mold", "amulus", "tmul", "s", "pun", "dush", "Mil", "g", "lale", "jul", "muse", "cmun", "male", "pul", "dule", "MUL", "lull", "lula", " mUL", "add", "pull", "pmuli", "_", "Mull", "cmulus", "dale", "mmule", "mmull", "lul", "dula"], "temp": ["extra", "full", "pack", "copy", "empty", "cu", "comb", "cli", "mix", "p", "test", "tw", "dat", "output", "valid", "source", "pt", "input", "Temp", "tem", "m", "thin", "txt", "content", "mag", "dest", "mist", "stable", "clean", "cp", "timeout", "min", "magic", "count", "flat", "pre", "style", "flow", "key", "tmp", "null", "iter", "dc", "wave", "time", "base", "mi", "current", "toc", "loc", "orig", "mini", "model", "ctrl", "atom", "fake", "keep", "white", "w", "c", "emp", "cut", "template", "pure", "pot", "small", "data", "wrap", "buffer", "wait", "get", "porary", "partial", "seed", "cel", "tc", "unit", "perature", "cache", "form", "wa", "level", "api", "sign", "tp"], "temp1": ["fake1", "tem4", "temp0", "tmp1", "tem3", "fake0", "Temp15", " temp15", "tmp01", "Temp5", "Temp1", "fake3", "tmp2", "tmp15", "Temp01", "tem1", "tem5", " temp0", "tem2", " temp01", "Temp0", "fake4", "Temp3", "temp15", "tem0", "temp01", "Temp2"], "temp2": ["test5", "tem4", "temp0", "temp72", "tem3", "emp2", "test3", "tmp72", "pt4", "tem8", " temp72", "temp8", "tempB", "tmpB", "Temp5", " tempB", "Temp1", "pt2", "tmp2", "tem6", " temp02", "tem5", "tem1", "pt02", "Temp4", " temp0", "tem2", "Temp8", "tmp8", "emp72", "test2", "Temp0", "Temp3", "tem02", "tem0", "pt6", "emp8", "Temp2", " temp8", "empB", "test4", "temp02"], "temp3": ["tem4", "fake1", "test5", "temp03", "tem3", "tem7", "test3", " temp23", "emp23", "fake03", "emp3", "Temp5", "Temp1", "fake3", "emp30", " temp03", "tem5", "tem1", "test03", "Temp4", "tem2", "test2", "fake4", "temp30", "tempThree", " temp30", "Temp3", "tem30", "Temp7", "temp23", "tem23", "Temp2", "fake5", "fake2", " tempThree", "temThree", "empThree"], "temp4": ["tem4", "fake1", "iter1", "Temp6", "emp400", "emp40", "tmp400", " temp40", "fake6", "Temp5", "Temp1", "tem6", "temp400", "iter5", "tem5", "tem1", "emp5", "Temp4", "tem2", "test2", "test6", "fake4", "tmp4", "tmp5", "emp4", "test1", "tmp40", "iter4", "temp40", "Temp2", "fake5", "fake2", "test4", " temp400", "iter2"], "temp5": ["tem4", "iter1", "temp55", "tem3", " temp53", "Temp6", "iter6", " temp50", "tem53", " temp55", "Temp5", "fake6", "Temp1", "tem6", "iter3", "iter5", "tem5", "tem1", "Temp4", "tem2", "tem55", "fake4", "Temp3", "tmp55", "tmp5", "tmp50", "tem50", "tmp53", "Temp2", "temp50", "fake5", "fake2", "temp53"], "temp6": ["test5", "tem4", "tem7", "tem8", "Temp6", "tmp66", "fake8", "temp8", "temp06", "fake6", "Temp5", "tem6", "Temp68", "tmp06", " temp66", "tem5", "Temp4", "Temp8", "tmp8", "test6", "fake4", " temp68", "tmp6", "tmp5", "Temp7", " temp06", "Temp66", "Temp2", "tmp68", " temp8", "temp68", "fake2", "test4", "test8", "tem06", "temp66"], "temp7": ["temp13", "tem7", "temp67", "tem8", " temp87", "Temp6", "tem67", "tmp47", "tmp7", "temp8", " temp47", "tem87", "fake7", "fake6", "Temp5", "test67", "temp47", "tmp17", "temp17", "Temp4", "Temp47", "tmp8", " temp67", "test6", "test13", "fake4", "temp87", " temp13", "tmp6", "tmp5", "tmp67", "Temp7", "Temp67", "test7", " temp8", "fake5", "Temp13", "Temp17", " temp17", "tmp87"]}}
{"project": "qemu", "commit_id": "db3b3c7281ca82e2647e072a1f97db111313dd73", "target": 1, "func": "static int handle_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)\n{\n    const char *sec_model = qemu_opt_get(opts, \"security_model\");\n    const char *path = qemu_opt_get(opts, \"path\");\n    if (sec_model) {\n        error_report(\"Invalid argument security_model specified with handle fsdriver\");\n        return -1;\n    }\n    if (!path) {\n        error_report(\"fsdev: No path specified\");\n        return -1;\n    }\n    fse->path = g_strdup(path);\n    return 0;\n}", "idx": 19612, "substitutes": {"opts": [" oppt", "otts", "opter", "experts", "OPts", "experpt", "experls", "opouts", " opTs", "OPty", "ops", "optTs", "oplets", "opps", "opTs", "experTs", "oppt", "opls", "prets", "otlets", " opter", "optts", "obts", "obs", "preps", "obty", "OPps", "obps", "optls", " opouts", "opty", "OPs", " opls", "experlets", "otpt", " oplets", "prety", "pres", "otter", "experter", "experouts", "optouts"], "fse": ["rfsu", "psle", " fsle", "lfze", "ppse", "fme", " fpse", "pze", "lfse", " fme", "rfme", "lfsle", "rfSE", "fze", "fsu", "Fsu", " fSE", "fsle", "pse", "fpse", "rfse", "Fme", "fSE", "FSE", "Fse", "lfpse", " fsu", " fze"], "errp": ["erp", "erP", "Err", "erc", " errP", " errc", "errr", "err", "errP", "Erc", " errr", "Erp", "errc", "ErP"], "sec_model": ["Sec_model", "sec_models", "sec_mode", "sec_pattern", "Sec_module", "Sec_mode", "sec_module", "Sec_models", "Sec_pattern"], "path": ["inner", "part", "pattern", "point", "content", "text", "data", "name", "call", "dir", "image", "ith", "file", "str", "root", "type", "method", "ath", "rh", "node", "loc", "wd", "model", "password", "pointer", "enc", "po", "prop", "arc", "context", "PATH", "location", "alias", "chain", "args", "prefix", "key", "id", "mount", "config", "parent", "device", "Path", "patch", "cmd", "p", "url", "filter", "error", "route", "api", "port", "value", "source", "target"]}}
{"project": "qemu", "commit_id": "302d9d6fd8cb34e393cc9bb101a1748bd53899d3", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633, "substitutes": {"vs": ["ns", "ves", "ms", "values", "ums", "vas", "ts", "s", "bs", "stats", "rs", "words", "sv", "otes", "services", "ports", "vp", "ils", "vals", "cf", "forces", "ys", "ss", "ls", "as", "ii", "ops", "utils", "fs", "vi", "xs", "cons", "vers", "sk", "cs", "css", "VS", "als", "ins", "Vs", "obs", "args", "iss", "qs", "ov", "ses", "verts", "v", "alls", "ps", "js", "ets", "orts", "versions", "sts", "vt", "ks", "events", "gs", "va", "ues", "its", "iv", "es", "os", "state", "flags", "env", "eps", "ds", "oss"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643, "substitutes": {"dev": ["m", "Dev", "dn", "dd", "mod", "tr", "gd", "pub", "md", "ver", "nt", "de", "rad", "devices", "sw", "di", "dt", "def", "prom", "sd", "self", "link", "d", "hw", "sh", "av", "w", "ev", "dm", "ad", "serv", "temp", "device", "dom", "driver", "od", "dem", "serial", "DEV", "pro", "die", "bus", "ve", "conn", "ds"], "s": ["ns", "set", "spec", "x", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "none", "ks", "h", "us", "sets", "ms", "m", "ts", "sg", "rs", "self", "o", "su", "xxx", "side", "v", "si", "S", "a", "ds", "status", "bs", "uns", "f", "r", "sb", "l", "w", "serv", "sync", "c", "ps", "b", "sum", "sys", "your", "es", "states", "less", "params", "session", "stats", "t", "conf", "data", "services", "n", "g", "i", "sl", "ls", "fs", "is", "args", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "se", "south", "server", "y", "u"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650, "substitutes": {"obj": ["ns", "ab", "j", "bs", "code", "data", "bj", "ob", "alt", "nt", "adj", "n", "str", "sb", "oa", "src", "node", "ops", "ctx", "pos", "ass", "nb", "act", "object", "o", "po", "arr", "val", "args", "elt", "js", "cat", "tmp", "rb", "lib", "od", "Object", "az", "os", "pt", "Obj", "amp"]}}
{"project": "FFmpeg", "commit_id": "8f4020d8a4b2e6264f54accbcb881577316c3ca6", "target": 0, "func": "static int svq1_decode_frame_header(GetBitContext *bitbuf, MpegEncContext *s)\n\n{\n\n    int frame_size_code;\n\n\n\n    skip_bits(bitbuf, 8); /* temporal_reference */\n\n\n\n    /* frame type */\n\n    s->pict_type = get_bits(bitbuf, 2) + 1;\n\n    if (s->pict_type == 4)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    if (s->pict_type == AV_PICTURE_TYPE_I) {\n\n        /* unknown fields */\n\n        if (s->f_code == 0x50 || s->f_code == 0x60) {\n\n            int csum = get_bits(bitbuf, 16);\n\n\n\n            csum = ff_svq1_packet_checksum(bitbuf->buffer,\n\n                                           bitbuf->size_in_bits >> 3,\n\n                                           csum);\n\n\n\n            av_dlog(s->avctx, \"%s checksum (%02x) for packet data\\n\",\n\n                    (csum == 0) ? \"correct\" : \"incorrect\", csum);\n\n        }\n\n\n\n        if ((s->f_code ^ 0x10) >= 0x50) {\n\n            uint8_t msg[256];\n\n\n\n            svq1_parse_string(bitbuf, msg);\n\n\n\n            av_log(s->avctx, AV_LOG_ERROR,\n\n                   \"embedded message: \\\"%s\\\"\\n\", (char *)msg);\n\n        }\n\n\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits(bitbuf, 2);\n\n        skip_bits1(bitbuf);\n\n\n\n        /* load frame size */\n\n        frame_size_code = get_bits(bitbuf, 3);\n\n\n\n        if (frame_size_code == 7) {\n\n            /* load width, height (12 bits each) */\n\n            s->width  = get_bits(bitbuf, 12);\n\n            s->height = get_bits(bitbuf, 12);\n\n\n\n            if (!s->width || !s->height)\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            /* get width, height from table */\n\n            s->width  = ff_svq1_frame_size_table[frame_size_code].width;\n\n            s->height = ff_svq1_frame_size_table[frame_size_code].height;\n\n        }\n\n    }\n\n\n\n    /* unknown fields */\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);    /* use packet checksum if (1) */\n\n        skip_bits1(bitbuf);    /* component checksums after image data if (1) */\n\n\n\n        if (get_bits(bitbuf, 2) != 0)\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (get_bits1(bitbuf) == 1) {\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 4);\n\n        skip_bits1(bitbuf);\n\n        skip_bits(bitbuf, 2);\n\n\n\n        while (get_bits1(bitbuf) == 1)\n\n            skip_bits(bitbuf, 8);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19654, "substitutes": {"bitbuf": ["bitvec", "bugctx", "loguf", "logbuf", "bonbox", "bugbuff", "bituf", "Bitbuffer", "bootvec", "lockbuff", "loaduf", "catcb", "Bitcb", "bugbuf", "bytebuff", "bonbag", "bonbuff", "bugbuffer", "bincb", "lockuf", "banduf", "bitsuf", "bitsbuf", "catbuff", "bitscb", "lockbuffer", "Bitbuf", "itbuffer", "bitsbag", "bonbuf", "logbuff", "bugcb", "bonbatch", "bytebuffer", "bitsbuff", "bitbox", "bootbuf", "bitbatch", " bitcb", " bitbuffer", "bootbatch", "loadbox", "itbuf", "bandbatch", "bandbuff", " bitbuff", "catbuf", "binbuffer", "bootcb", "bootuf", "bitctx", "bootbuffer", "logctx", "binbuff", "bitbuffer", "bitbag", "lockbuf", "bitbuff", "binbuf", "bonvec", "itbuff", "catuf", "bitsboard", "buguf", "bugboard", "binuf", "loadbuff", "bonuf", "loadbuf", "ituf", "bootbox", "Bitbuff", "loadcb", "bitboard", "bootctx", "bugbag", "bitcb", "bootbuff", "loadbuffer", "bitsbuffer", "bytebuf", "bytecb", "bytevec", " bituf", "bandbuf", "byteuf", "bonboard"], "s": ["ns", "spec", "words", "service", "details", "ss", "cons", "cs", "d", "new", "qs", "sym", "p", "ks", "h", "sets", "comments", "m", "ts", "sg", "rs", "aws", "sim", "manager", "self", "o", "su", "sc", "si", "S", "ds", "uns", "f", "r", "sb", "l", "ins", "w", "bis", "sync", "c", "ps", "b", "sys", "your", "es", "states", "sq", "sf", "session", "stats", "t", "conf", "services", "n", "g", "i", "sl", "ls", "fs", "xs", "is", "e", "ssl", "ses", "js", "http", "gs", "its", "os", "se", "y", "u"], "frame_size_code": ["frame_sizexcount", "frame_sizexcode", "frame_shape_code", "frame_sizevalcoded", "frame_genderfulllevel", "frame_scale_const", "frame_scale_code", "frame_shape_32", "frame_sizefullcoded", "frame_scale_str", "frame_sizeingcode", "frame_size_length", "frame_genderfullcoded", "frame_scale_count", "frame_size_coded", "frame_size_const", "frame_sizefullvalue", "frame_size_id", "frame_sizeingstr", "frame_shape_length", "frame_size_level", "frame_sizefulllevel", "frame_sizexnumber", "frame_size_str", "frame_size_cycle", "frame_gender_code", "frame_gender_coded", "frame_gender_value", "frame_sizeingcount", "frame_sizeingnumber", "frame_size_codes", "frame_sizevalcode", "frame_size_32", "frame_sizefullcode", "frame_size_number", "frame_sizexstr", "frame_gender_level", "frame_size_count", "frame_sizevalvalue", "frame_genderfullcode", "frame_shape_count", "frame_genderfullvalue", "frame_scale_codes", "frame_scale_cycle", "frame_sizevallevel", "frame_scale_id", "frame_scale_number", "frame_size_value"], "msg": ["ms", "html", "m", "gram", "sg", "og", "code", "data", "text", "err", "op", "md", "debug", "essage", "str", "g", "i", "comm", "type", "bc", "node", "mess", "orig", "raw", "loc", "byte", "arg", "enc", "nm", "empty", "header", "args", "asm", "ag", "req", "Msg", "seq", "cmd", "sym", "doc", "b", "gen", "gs", "error", "alloc", "bytes", "message", "mt", "frame", "desc"]}}
{"project": "FFmpeg", "commit_id": "bf5af5687569e34d6e3a4d31fc6bb5dc44efdb29", "target": 1, "func": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n", "idx": 19665, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "92e483f8ed70d88d4f64337f65bae212502735d4", "target": 1, "func": "static int compare_codec_desc(const void *a, const void *b)\n\n{\n\n    const AVCodecDescriptor * const *da = a;\n\n    const AVCodecDescriptor * const *db = b;\n\n\n\n    return (*da)->type != (*db)->type ? (*da)->type - (*db)->type :\n\n           strcmp((*da)->name, (*db)->name);\n\n}\n", "idx": 19667, "substitutes": {"a": ["na", "ab", "s", "f", "n", "ar", "A", "i", "am", "as", "self", "ae", "ba", "ca", "art", "d", "ac", "ama", "aa", "ad", "asa", "e", "ak", "c", "p", "ada", "va", "la", "ra", "an", "sa"], "b": ["ab", "eb", "bs", "s", "x", "f", "ob", "sb", "i", "cb", "as", "wb", "B", "xb", "bb", "lb", "abb", "ba", "d", "arb", "bur", "bd", "mb", "e", "k", "fb", "v", "be", "c", "emb", "rb", "p", "boot", "ub", "y", "ib"], "da": ["na", "dd", "data", "gd", "aka", "lla", "aea", "pd", "de", "Da", "fa", "onda", "as", "ld", "bb", "ba", "sta", "ca", "oda", "ta", "d", "aa", "ad", "bd", "asa", "ga", "DA", "pa", "lambda", "ea", "ada", "ppa", "dat", "va", "la", "wa", "ra", "ke", "ja", "ma", "sa", "ds"], "db": ["ab", "eb", "bi", "dd", "bs", "data", "ah", "gd", "base", "ob", "dir", "ib", "sb", "cb", "bc", "loc", "vd", "bb", "ae", "sd", "ba", "d", "deb", "gb", "database", "bf", "aa", "dy", "bd", "ad", "fd", "fb", "bh", "rb", "ade", "lib", "DB", "doc", "ada", "ud", "Db", "ub", "lab", "ds"]}}
{"project": "qemu", "commit_id": "c3fecea50dc0f27198b8658a0c9c4fbfdd0f95db", "target": 1, "func": "static int coroutine_fn add_aio_request(BDRVSheepdogState *s, AIOReq *aio_req,\n\n                           struct iovec *iov, int niov, int create,\n\n                           enum AIOCBState aiocb_type)\n\n{\n\n    int nr_copies = s->inode.nr_copies;\n\n    SheepdogObjReq hdr;\n\n    unsigned int wlen;\n\n    int ret;\n\n    uint64_t oid = aio_req->oid;\n\n    unsigned int datalen = aio_req->data_len;\n\n    uint64_t offset = aio_req->offset;\n\n    uint8_t flags = aio_req->flags;\n\n    uint64_t old_oid = aio_req->base_oid;\n\n\n\n    if (!nr_copies) {\n\n        error_report(\"bug\");\n\n    }\n\n\n\n    memset(&hdr, 0, sizeof(hdr));\n\n\n\n    if (aiocb_type == AIOCB_READ_UDATA) {\n\n        wlen = 0;\n\n        hdr.opcode = SD_OP_READ_OBJ;\n\n        hdr.flags = flags;\n\n    } else if (create) {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_CREATE_AND_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    } else {\n\n        wlen = datalen;\n\n        hdr.opcode = SD_OP_WRITE_OBJ;\n\n        hdr.flags = SD_FLAG_CMD_WRITE | flags;\n\n    }\n\n\n\n    hdr.oid = oid;\n\n    hdr.cow_oid = old_oid;\n\n    hdr.copies = s->inode.nr_copies;\n\n\n\n    hdr.data_length = datalen;\n\n    hdr.offset = offset;\n\n\n\n    hdr.id = aio_req->id;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    s->co_send = qemu_coroutine_self();\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, co_write_request,\n\n                            aio_flush_request, NULL, s);\n\n    set_cork(s->fd, 1);\n\n\n\n    /* send a header */\n\n    ret = do_write(s->fd, &hdr, sizeof(hdr));\n\n    if (ret) {\n\n\n        error_report(\"failed to send a req, %s\", strerror(errno));\n\n        return -EIO;\n\n    }\n\n\n\n    if (wlen) {\n\n        ret = do_writev(s->fd, iov, wlen, aio_req->iov_offset);\n\n        if (ret) {\n\n\n            error_report(\"failed to send a data, %s\", strerror(errno));\n\n            return -EIO;\n\n        }\n\n    }\n\n\n\n    set_cork(s->fd, 0);\n\n    qemu_aio_set_fd_handler(s->fd, co_read_response, NULL,\n\n                            aio_flush_request, NULL, s);\n\n\n\n\n    return 0;\n\n}", "idx": 19684, "substitutes": {"s": ["ns", "set", "spec", "m", "session", "sg", "sis", "stats", "t", "conf", "f", "full", "so", "services", "service", "r", "n", "sie", "sb", "g", "i", "sl", "current", "ss", "ls", "this", "sim", "scope", "fs", "self", "is", "o", "cs", "l", "submit", "su", "new", "sed", "iss", "w", "serv", "e", "ssl", "ses", "sync", "v", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "sci", "b", "http", "gs", "sys", "storage", "os", "state", "sq", "us", "south", "states", "server", "se", "sa", "ds"], "aio_req": ["aIO_req", "aiol_requ", "aiol__req", "aIO_request", "aio__requ", "aio5rec", "aio_fr", "aio_rt", "aios_rt", "aio2err", "aiol_req", "aio2rec", "aio5rt", "aio_ref", "aio67desc", "aiosrequire", "aio_tar", "aiol__requ", "aio2request", "aio67req", "acho_req", "aio5req", "aio__tar", "aio67request", "aio_err", "acho_desc", "aio2req", "aios_ref", "aiol_tar", "aio_rec", "aio_request", "aios_ocr", "aio_desc", "aiosreq", "aio67required", "aiol__request", "aio_requ", "aiol_request", "aIO_rec", "aios_req", "aios_rec", "aio_comp", "aiosrequest", "acho_required", "aios_require", "aIO_err", "aio__req", "aiosocr", "aio_require", "aio_ocr", "aios_request", "aio5request", "aio__request", "aiol__tar", "acho_request", "aio_required"], "iov": ["org", "ei", "iii", " ov", "eve", "eu", "gc", "io", "ro", "wo", "ou", "ii", "iop", "cons", "rio", "roc", "rob", "uu", "oci", "man", "mx", "uncle", "ir", "fee", "ive", "unc", "iv", "uno"], "niov": ["naiv", "niove", "eiove", "eiow", "eniow", "eiiv", "eniov", "naove", "niow", "naow", "naov", "eiov", "eniiv", "niiv", "eniove"], "create": ["set", "enable", "raise", "creat", "init", "code", "shape", "child", "destroy", "delete", "clone", "drop", "wait", "make", "construct", "password", "copy", "execute", "activate", "fake", "change", "draw", "complete", "new", "add", "use", "when", "send", "open", "update", "parent", "clear", "Create", "gen", "check", "write", "children", "save", "desc", "created", "custom"], "aiocb_type": ["aiocsb_lock", "aiocsb_style", "aiocsb_ype", "aiocb__lock", "aiocb__type", "aiocbfrel", "aiocbfype", "aiocsb_type", "aiocb_rel", "aiocsb_Type", "aiocb_style", "aiocb__style", "aiocb_lock", "aiocb_Type", "aiocbftype", "aiocbfType", "aiocb_ype", "aiocsb_rel"], "hdr": ["shhr", " hric", "rhDr", "handct", "phbr", "ehstr", "hstr", "hdc", "handvar", "hrs", "wdr", "ghder", "hrder", "wder", " hrc", "rhbr", "hder", "bhhr", "ohdr", "phr", "hrhr", "hrid", "hsder", "hmr", "Hmr", "hshr", "bhder", "ohder", "Hdr", "ohheader", "enhicit", "wtr", "ohhr", " Hicit", " htr", "htr", "rhrt", "enhr", "hr", "hDR", "hrc", "rhr", "ohtr", "hmhr", "rhdr", "shDr", "hyrc", "uhdr", "hrdr", "enhdr", "uhric", " hvar", "adhrs", "hhDR", "hheader", " hDR", "uhrc", " hrs", "phrc", "HDR", "Hdi", " hct", "Hrid", "ghhr", "hlrc", "shrr", "shdr", "hicit", " hrr", "Hct", "bhdr", "rhder", "handdr", "hrt", "hct", "hdi", "rhrc", "hlDR", "hvar", "hhr", " hstr", "enhder", "adhDR", "hihr", "rhhr", "handrid", "rhdi", "hyvar", "hidr", "hydr", "hiheader", " hhr", "ohDr", "ihstr", "hmheader", "shDR", "rhDR", "hsdr", "phric", "hmder", "ihdr", "ohrs", "adhrid", " hicit", " hdi", " hrt", " hder", "rhtr", "handDR", "Hhr", "ehrid", "ihrid", "Hrc", " hr", "hDr", "hrdc", "hider", "hmdr", "hhrt", "ihr", "ghdr", "hhhr", "shrid", " hbr", "handrc", "ohDR", "hlmr", "adhdr", "adhtr", " Hdr", "ehdr", "hbr", "ghdc", "rhdc", "whr", " Hr", "hldr", " Hder", "adhhr", "hrr", " hmr", "hric", "hyrid", " hrid", "shtr", "hhdr", "phdr", "ehr", "adhrr"], "wlen": ["rwlon", " wln", "owlen", "owln", "ewen", "ewlen", "swlen", "waln", "kwlength", "owen", "wordln", "wlf", "wln", "wlength", "wordlength", "swln", " wlon", "ewlf", "wen", " wlf", "rwlen", "wwlen", "wordlon", "swlf", "owlon", "wlon", "rwlength", "swlength", "walen", "walength", "wwen", " wlength", "swen", "swlon", "walon", "wwlon", " wen", "kwlen", "wwln", "wordlen", "kwln", "ewlength", "kwlon", "rwln"], "ret": ["status", "code", "data", "bit", "ref", "alt", "let", "reg", "nt", "rc", "lit", "rt", "fun", "result", "num", "mem", "resp", "rets", "count", "arr", "arg", "att", "val", "re", "Ret", "feat", "det", "cat", " Ret", "RET", "red", "res", "len", "addr", "reply", "success"]}}
{"project": "qemu", "commit_id": "2b3de6ada5d180130ba083d5b45ed51ce8e4def2", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685, "substitutes": {"p": ["pc", "wp", "m", "j", "pid", "t", "op", "pe", "n", "pm", "bp", "i", "lp", "pb", "o", "po", "pg", "ip", "pp", "pkg", "pi", "pre", "w", "queue", "pa", "e", "qt", "c", "ps", "post", "patch", "pr", "h", "tp", "np", "press", "P", "u"], "q": ["s", "ch", "t", "request", "view", "f", "comment", "ct", "qi", "r", "cf", "dq", "g", "query", "Q", "ctx", "self", "pg", "ack", "quick", "qu", "sh", "ce", "pkg", "iq", "event", "ue", "queue", "config", "qs", "e", "k", "qt", "sync", "cl", "client", "c", "req", "qq", "qa", "cur", "cmd", "v", "ck", "que", "cache", "question", "patch", "check", "form", "h", "local", "sq", "u"], "state": ["part", "stat", "instance", "m", "code", "un", "where", "mode", "al", "call", "name", "f", "err", "info", "comment", "pe", "type", "match", "ate", "run", "self", "what", "tag", "out", "is", "State", "ask", "force", "parse", "new", "event", "t", "seed", "rule", "style", "back", "use", "length", "config", "start", "key", "e", "id", "k", "parent", "STATE", "none", "resource", "ace", "port", "an"]}}
{"project": "qemu", "commit_id": "36c6711bbe79642b0102416a9dd4243505e874a6", "target": 1, "func": "static void gen_ldst_pair (DisasContext *ctx, uint32_t opc, int rd,\n\n                           int base, int16_t offset)\n\n{\n\n    const char *opn = \"ldst_pair\";\n\n    TCGv t0, t1;\n\n\n\n    if (ctx->hflags & MIPS_HFLAG_BMASK || rd == 31 || rd == base) {\n\n        generate_exception(ctx, EXCP_RI);\n\n        return;\n\n    }\n\n\n\n    t0 = tcg_temp_new();\n\n    t1 = tcg_temp_new();\n\n\n\n    gen_base_offset_addr(ctx, t0, base, offset);\n\n\n\n    switch (opc) {\n\n    case LWP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_lw(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"lwp\";\n\n        break;\n\n    case SWP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sw(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 4);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sw(t1, t0, ctx);\n\n        opn = \"swp\";\n\n        break;\n\n#ifdef TARGET_MIPS64\n\n    case LDP:\n\n        save_cpu_state(ctx, 0);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        op_ld_ld(t1, t0, ctx);\n\n        gen_store_gpr(t1, rd+1);\n\n        opn = \"ldp\";\n\n        break;\n\n    case SDP:\n\n        save_cpu_state(ctx, 0);\n\n        gen_load_gpr(t1, rd);\n\n        op_st_sd(t1, t0, ctx);\n\n        tcg_gen_movi_tl(t1, 8);\n\n        gen_op_addr_add(ctx, t0, t0, t1);\n\n        gen_load_gpr(t1, rd+1);\n\n        op_st_sd(t1, t0, ctx);\n\n        opn = \"sdp\";\n\n        break;\n\n#endif\n\n    }\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s, %s, %d(%s)\", opn, regnames[rd], offset, regnames[base]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 19709, "substitutes": {"ctx": ["grad", "cf", "anc", "gru", "cas", "Context", "exec", "cs", "tx", "stack", "config", "xc", "cu", "general", "cli", "lib", "cv", "cc", "conn", "rx", "txt", "wx", "cca", "vc", "rc", "cm", "bc", "cp", "wcs", "scope", "hw", "cms", "sc", "parent", "lc", "gz", "la", "connection", "cgi", "mac", "na", "fp", "jp", "ct", "cb", "src", "loc", "utils", "ctrl", "crit", "ca", "kb", "ci", "ga", "sync", "scl", "c", "history", "qa", "sci", "cn", "sq", "progress", "acl", "context", "conv", "pkg", "nc", "tc", "cam", "cl", "client", "req", " cx", "cmd", "kt", "cmp"], "opc": ["hopcn", "opf", "opnc", " opf", "ospC", "ipn", "hopc", " opcs", "ospc", "ospcs", "ospf", "opcs", " opC", "opC", "hopnc", "hopn", " opcn", "ipnc", "OPc", "OPC", "ipcn", "opcn", "OPf", "OPcs", " opnc", "ipc"], "rd": ["rx", "dra", "dd", "rr", "nd", "rs", "rest", "typ", "dir", "td", "raid", "rc", "hr", "rid", "rm", "rt", "ord", "r", "ro", "md", "RF", "rh", "src", "ld", "rg", "ind", "rf", "ptr", "index", "dim", "rod", "lt", "wd", "d", "val", "rob", "std", "ru", "rn", "mid", "dr", "fd", "lr", "cr", "xd", "rb", "rl", "ri", "rw", "rss", "ud", "od", "dig", "RD", "red", "cd", "ra", "wn", "addr", "rect", "pt", "ds", "round"], "base": ["part", "fr", "scale", "db", "ite", "core", "x", "ref", "rest", "Base", "name", "rc", "r", "bp", "based", "root", "loc", "index", "range", "val", "old", "le", "bf", "ffff", "zero", "back", "reset", "last", "prefix", "site", "pre", "start", "bas", "cr", "rb", "address", "area", "b", "ra", "ase", "addr", "end", "server", "len"], "offset": ["set", "part", "data", "af", "Offset", "ref", "align", "type", "loc", "padding", "acl", "index", "pos", "ptr", "bound", "range", "slot", "array", "format", "size", "adjust", "reset", "prefix", "start", "rot", "position", "seq", "off", "url", "address", "area", "b", "route", "api", "addr", "end", "len"], "opn": ["opns", "hopcn", " opd", " opns", "ropN", "OPn", "optd", "opercn", "hopc", "optN", "OPN", "optnot", "blockc", "optc", "hopn", "opern", "blockd", " opN", "ropn", " opcn", "opnot", "ropnot", "OPc", "operc", "OPns", "opcn", "opd", "opN", "hopN", "blockN", " opnot", "ropc", "hopns", "optn", "blockn"], "t0": ["p4", "T2", " t3", " t9", " t4", "at0", "t01", "ta20", "T0", "p0", "p2", "f3", "ta2", "t2", "ott1", "at01", "tt0", "t4", "at1", "ott0", " t2", "p01", " t20", "f2", "T20", "T9", "at9", "f1", "ta0", "p3", "t20", "tt2", "at2", "ott20", "t9", "T3", "T01", "T1", "ta1", "f0", "tt1", "f4", "ott2", "tt20", "T4", "p1", "t3"], "t1": ["t5", "taOne", "T2", "t11", "pt4", "atONE", "t4", "T41", "ta30", "at2", "atone", "T11", "T6", "ta10", "f6", "it2", "it100", "at121", "T81", "at30", "taone", "T0", "t100", "p591", "T30", "p8", "tOne", "it1", "T5", "tt100", "ptONE", "it0", "t121", "itOne", "t10", "p41", "T3", "ta1", "it3", "tt1", "it11", "tone", "ta121", "it5", "ta81", "p1", "pONE", "at41", "at4", " t4", "at0", "it6", "t2", "TONE", "pone", " t2", "f2", "Tone", "p3", "te81", "ta61", "T8", "tt2", "at100", "teOne", "T1", "tONE", "t61", "f0", "atOne", "p100", "tt591", "t8", "p4", "T100", "at591", "ta100", "te0", "p2", "p0", "T10", "itone", "ta2", "t7", "at1", "pt2", "t41", "p5", "ta0", "f1", "t591", "t81", "itONE", "t6", "ta7", " tone", "TOne", "t30", "pt1", "f4", "at61", "T121", "te1", "it81", "T4", "it8", "f11", "T7", "it7", "p10", "T61", "t3"]}}
{"project": "qemu", "commit_id": "84ebd3e8c7d4fe955b359b9aac84395907b0412e", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716, "substitutes": {"klass": ["klf", " kcl", "kazz", "sklass", "Kazz", "skazz", "cklasses", "skclass", "Klass", " kazz", "Klasses", "klasses", "kcl", "sklasses", "Kclass", "sklf", " klasses", "skcl", "kclass", "cklass", "ckcl", "Klf", " klf", " kclass", "ckclass"], "data": ["Data", "dd", "info", "buffer", "result", "loader", "i", "cb", "bc", "def", "after", "exec", "load", "array", "ui", "config", "parent", "da", "ata", "cache", "dat", "DATA", "ds", "input"], "dc": ["pc", "jc", "cc", "spec", "cfg", "db", "cdn", "deck", "cca", "vc", "rc", "gc", "cm", "cf", "enter", "bc", "dt", "fc", "mc", "di", "abc", "ctrl", "controller", "dp", "design", " DC", "d", "df", "std", "nc", "ac", "disc", "DC", "tc", "config", "sc", "ga", "dr", "lc", "c", "da", "uc", "doc", "cache", "ec", "cd", "dk", "conn", "ds", "director"], "diag288": ["Diag280", "adiag288", "Diig288", "diag128", "diagger142", "adiarg128", "diagger280", "adiag280", "diig280", "diac280", "diig142", "diac188", "adiarg280", "diang28", "adiag188", "diag28", "diig28", "diag188", "diarg188", "diac128", "diang142", "diag280", "diarg280", "diagger288", "Diag142", "diag142", "diarg128", "diig128", "diang280", "diang288", "adiag128", "Diig280", "diig188", "adiarg288", "diig288", "diac288", "Diag28", "Diig142", "diagger28", "Diag288", "adiarg188", "Diig28", "diarg288"]}}
{"project": "FFmpeg", "commit_id": "0d21a84605bad4e75dacb8196e5859902ed36f01", "target": 0, "func": "int ff_estimate_motion_b(MpegEncContext * s,\n\n                       int mb_x, int mb_y, int16_t (*mv_table)[2], uint8_t *ref_picture, int f_code)\n\n{\n\n    int mx, my, range, dmin;\n\n    int xmin, ymin, xmax, ymax;\n\n    int rel_xmin, rel_ymin, rel_xmax, rel_ymax;\n\n    int pred_x=0, pred_y=0;\n\n    int P[6][2];\n\n    const int shift= 1+s->quarter_sample;\n\n    const int mot_stride = s->mb_width + 2;\n\n    const int mot_xy = (mb_y + 1)*mot_stride + mb_x + 1;\n\n    \n\n    get_limits(s, &range, &xmin, &ymin, &xmax, &ymax, f_code);\n\n\n\n    switch(s->me_method) {\n\n    case ME_ZERO:\n\n    default:\n\n\tno_motion_search(s, &mx, &my);\n\n        dmin = 0;\n\n        break;\n\n    case ME_FULL:\n\n\tdmin = full_motion_search(s, &mx, &my, range, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_LOG:\n\n\tdmin = log_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_PHODS:\n\n\tdmin = phods_motion_search(s, &mx, &my, range / 2, xmin, ymin, xmax, ymax, ref_picture);\n\n        break;\n\n    case ME_X1:\n\n    case ME_EPZS:\n\n       {\n\n\n\n            rel_xmin= xmin - mb_x*16;\n\n            rel_xmax= xmax - mb_x*16;\n\n            rel_ymin= ymin - mb_y*16;\n\n            rel_ymax= ymax - mb_y*16;\n\n\n\n            P[0][0] = mv_table[mot_xy    ][0];\n\n            P[0][1] = mv_table[mot_xy    ][1];\n\n            P[1][0] = mv_table[mot_xy - 1][0];\n\n            P[1][1] = mv_table[mot_xy - 1][1];\n\n            if(P[1][0] > (rel_xmax<<shift)) P[1][0]= (rel_xmax<<shift);\n\n\n\n            /* special case for first line */\n\n            if ((mb_y == 0 || s->first_slice_line || s->first_gob_line)) {\n\n                P[4][0] = P[1][0];\n\n                P[4][1] = P[1][1];\n\n            } else {\n\n                P[2][0] = mv_table[mot_xy - mot_stride             ][0];\n\n                P[2][1] = mv_table[mot_xy - mot_stride             ][1];\n\n                P[3][0] = mv_table[mot_xy - mot_stride + 1         ][0];\n\n                P[3][1] = mv_table[mot_xy - mot_stride + 1         ][1];\n\n                if(P[2][1] > (rel_ymax<<shift)) P[2][1]= (rel_ymax<<shift);\n\n                if(P[3][0] < (rel_xmin<<shift)) P[3][0]= (rel_xmin<<shift);\n\n                if(P[3][1] > (rel_ymax<<shift)) P[3][1]= (rel_ymax<<shift);\n\n        \n\n                P[4][0]= mid_pred(P[1][0], P[2][0], P[3][0]);\n\n                P[4][1]= mid_pred(P[1][1], P[2][1], P[3][1]);\n\n            }\n\n            pred_x= P[1][0];\n\n            pred_y= P[1][1];\n\n        }\n\n        dmin = epzs_motion_search(s, &mx, &my, P, pred_x, pred_y, rel_xmin, rel_ymin, rel_xmax, rel_ymax, ref_picture);\n\n \n\n        mx+= mb_x*16;\n\n        my+= mb_y*16;\n\n        break;\n\n    }\n\n    \n\n    /* intra / predictive decision */\n\n//    xx = mb_x * 16;\n\n//    yy = mb_y * 16;\n\n\n\n//    pix = s->new_picture[0] + (yy * s->linesize) + xx;\n\n    /* At this point (mx,my) are full-pell and the absolute displacement */\n\n//    ppix = ref_picture + (my * s->linesize) + mx;\n\n    \n\n    dmin= halfpel_motion_search(s, &mx, &my, dmin, xmin, ymin, xmax, ymax, pred_x, pred_y, ref_picture);\n\n\n\n//    s->mb_type[mb_y*s->mb_width + mb_x]= mb_type;\n\n    mv_table[mot_xy][0]= mx;\n\n    mv_table[mot_xy][1]= my;\n\n    return dmin;\n\n}\n", "idx": 19721, "substitutes": {"s": ["ns", "spec", "stat", "settings", "service", "ions", "details", "ss", "cs", "d", "qs", "p", "ks", "groups", "us", "sets", "ms", "m", "ts", "sg", "sis", "rs", "sim", "lines", "o", "su", "tests", "sc", "v", "si", "S", "an", "ches", "ds", "phys", "f", "sv", "ess", "sb", "sports", "bis", "sync", "c", "sci", "b", "sys", "es", "states", "sq", "sf", "session", "t", "stats", "conf", "services", "n", "g", "i", "sl", "ops", "fs", "site", "com", "e", "ssl", "ses", "client", "js", "http", "gs", "storage", "its", "os", "se", "south", "server", "y", "u"], "mb_x": ["MB_ex", "mm_ey", "mm_x", "mbacey", "mb5ux", "mp_y", "mm_y", "mb_ex", "mb_ey", "MB_width", "mb_ux", "mb_xy", "mb2width", "mb33y", "mm_xs", "mbacxs", "mb_xs", "MB_xy", "mbacx", "mb2x", "mp_xy", "mb2ex", "MB_x", "mb2y", "MB_ux", "mb5xy", "mb33ey", "mp_x", "MB_y", "mb33x", "mb5x", "mbacy", "mb33xs", "mb_width", "mb_px", "mp_px", "mb5y"], "mb_y": ["mb__y", "mp_Y", "mb01hop", "mm_z", "mb_ny", "mb_dy", "mb01x", "mb14dy", "mm_x", "mb25x", "mb_Y", "mb__x", "mb5vy", "mp_y", "mm_y", "mb_yo", "mb0hop", "mm_yo", "mb25y", "mb0x", "mb01ny", "mb0y", "mb0ny", "mm_dy", "mb67y", "mb14x", "mb_hop", "mb67x", "mb67z", "mb5Y", "mb14height", "mp_vy", "mb_z", "mm_height", "mp_x", "mb_vy", "mm_hop", "mb25dy", "mb_height", "mb67yo", "mb5x", "mb25height", "mb14y", "mb__vy", "mb__Y", "mb01y", "mm_ny", "mb5y"], "mv_table": ["mf_file", "mv_system", "mv1system", "mv1test", "mv_list", "mv7table", "mv1cache", "mv__file", "mf_source", "mv__interface", "mv_machine", "mv5table", "mf_tab", "mf_test", "mf_cache", "mv7machine", "mv__machine", "mv_source", "mv__source", "mv__table", "mv_tab", "mv5test", "mv1table", "mv7cache", "mv5cache", "mf_system", "mf_machine", "mf_table", "mv7tab", "mf_interface", "mf_list", "mv_test", "mv5system", "mv_interface", "mv_cache", "mv__list", "mv_file", "mv__cache"], "ref_picture": ["refacvideo", "ref_cache", "reference_storage", "refacpicture", "refplepic", "reference_memory", "ref_storage", "refvalsummary", "refvalpic", "ref_memory", "Ref_picture", "reference_view", "refsimage", "refplevideo", " ref_pic", "ref_statement", "refvalimage", "reference_cache", "refacview", "Ref_pic", "Ref_summary", "ref_image", "refplepicture", "reference_video", "ref_video", "refssummary", "refspic", "refaccache", " ref_video", "reference_picture", "refplestatement", "ref_view", "Ref_image", "refvalpicture", "ref_pic", "refspicture", "ref_summary", " ref_statement"], "f_code": ["f_codes", "f__type", "f__codes", "fc__type", "firmtype", "fc__code", "famerror", "f_error", "fc_code", "f2error", "fpamcall", "fc_codes", "f2code", "fc_type", "famclass", "famcode", "fp_call", "f2class", "fp_error", "f__map", "f__code", "fc_map", "famcall", "fc__codes", "fpamclass", "fp_class", "f2call", "firmcode", "f_call", "fp_code", "fpamerror", "firmcodes", "firmmap", "fpamcode", "f_type", "f_map", "f_class", "fc__map"], "mx": ["rx", "ns", "ms", "m", "dn", "mod", "mag", "yx", "lim", "x", "wx", "sample", "px", "mi", "cm", "bm", "mn", "pm", "module", "km", "max", "xy", "loc", "lex", "cp", "mc", "mus", "min", "ml", "xp", "vm", "nr", "mouse", "mr", "tx", "mos", "dm", "X", "wm", "p", "xml", "mes", "mp", "fm", "many", "MX", "im", "me", "zx", "mm", "y", "wy", "mu"], "my": ["rx", "ms", "mine", "m", "bi", "mod", "x", "ng", "mys", "md", "mi", "mn", "pm", "ym", "ya", "i", "am", "max", "mic", "python", "mc", "mini", "mon", "mem", "any", "min", "self", "cy", "nm", "mr", "mis", "dy", "mos", "sam", "sym", "MY", "fy", "oy", "your", "gy", "yo", "body", "py", "ma", "mm", "me", "mac", "My", "y", "dist"], "range": ["m", "scale", "fr", "rage", "offset", "lim", "mode", "base", "ref", "sample", "err", "view", "conf", "random", "r", "from", "theme", "role", "angle", "channel", "query", "block", "year", "Range", "loc", "max", "ge", " Range", "slice", "run", "model", "spread", "multi", "low", "gap", "force", "broad", "array", "chain", "size", "grade", "use", "no", "mid", "remote", "line", "area", "feature", "resource", "cache", "route", "domain", "error", "row", "ange", "repeat", "frame", "edge", "distance", "scan", "target"], "dmin": ["Dmid", "dymin", "dmain", "dpos", "dd0", "nrupt", " dpri", "dmid", "dserv", "fdmax", "fdmain", "Dmins", "Dpos", "smin", "dmins", "ddpos", "dpri", "yserv", " dpos", "nmin", "Dmain", "smins", "DMIN", "D0", " dmine", " dMIN", "ddmin", "ldminimum", "Drupt", " dmid", "Dserv", "ldMIN", "dMIN", " dminimum", "nmax", "dmax", "fdmin", "yMIN", "sserv", "Dpri", "ymid", "ymins", "dyminimum", "dymine", "fdrupt", " d0", "dyMIN", "Dmin", "sMIN", "nmain", "dminimum", "ldmin", "dmine", "Dmax", "drupt", "ddpri", "ldmine", "d0"], "xmin": ["ixmax", "Xmini", "Xstart", "xmini", "Xmins", "rxmin", " xpos", "Xmin", "rxstart", "vmax", "XMin", "ixmins", "ystart", " xMin", "ixmini", "rxMin", "vMin", "ixmin", "yMin", "vmin", " xmins", " xstart", "ymins", "vmins", "xpos", " xmini", "rxpos", "xstart", "rxmax", "ypos", "xmins", "xMin", "Xmax", "ymini"], "ymin": ["eymid", "yymin", "mymini", "symax", "xmini", "symin", "eymin", "systat", " ystat", "ynext", "skymin", "skystart", "yrange", "symini", "xstat", "xmid", "yymins", " ysum", "ystart", "sysum", "zmin", "zstart", "xsum", "ysum", "yonly", "mystart", "yymax", "myonly", "eymax", "xrange", "skymax", "ystat", "ymid", "eymini", "xonly", "mymin", "mymins", "zmax", "xstart", "yystart", "symid", "skynext", "mymax", "syonly", "xmins", "syrange", "ymins", " yonly", "ymini", "xnext", "znext", " yrange"], "xmax": ["yax", "ixmax", "eyrange", "xax", "yrand", "Xmin", "txstart", "eymin", "eypress", "yrange", " xrange", "yMax", "xpress", "Xax", "xMax", "xwrap", "ystart", "ywrap", " xMax", "yactive", "mypress", "eyactive", "oxax", "oxrand", "xrand", "myactive", "ixax", "oxmin", "mystart", "eymax", "ixmin", "ypress", "xrange", "mywrap", "exmax", "txmin", "exstart", "txmax", "txax", "eyMax", "eywrap", "Xrand", "oxmax", "mymin", "xstart", "xactive", "eystart", "exmin", "mymax", "Xmax", "exax"], "ymax": ["ypase", "ymmase", "yax", "ypaxy", "symac", "ymode", "symax", "ymaz", "ymmaz", "ymase", "symake", "yraxy", "iemoss", "ypark", "ypaz", "yanode", "ypas", "yposs", "mmaz", "ypax", "yanark", "ymmaxy", "ymmax", "emin", "ypac", "iemake", "yrak", "symay", "ypmax", "ymake", "emmax", "iemac", "ymark", "pmark", "yoss", "ypin", "emax", "emase", "ypak", "ymmas", "ypode", "yras", "pmin", "yanax", "ymaxy", "ymazon", "ymate", "iemay", "ymas", "iemax", "yate", "mmase", "pmode", "iemmax", "pmax", "ypake", "ymay", "ymac", "pmmax", "ymmak", "pmase", "ymoss", "ymak", "ymmazon", "ypazon", "mmax", "iemate", "ypay", "yrax", "ypate", "yanmax", "mmazon"], "rel_xmin": ["rel_Xmax", "rel_Xmins", "rel_axmin", "rel_xf", "rel_xmins", "rel_txpos", "rel_xpos", "rel_txmin", "rel_xyf", "rel_xypos", "rel_yf", "rel_txmax", "rel_ypos", "rel_axmins", "rel_xymax", "rel_txf", "rel_ymins", "rel_Xmin", "rel_axmax", "rel_xymin"], "rel_ymin": ["rel_xmid", "rel_ymonly", "rel_yamid", "rel_xonly", "rel_ymmax", "rel_yaonly", "rel_xstat", "rel_ymid", "rel_yamin", "rel_tymin", "rel_yastat", "rel_yamax", "rel_tymax", "rel_tystat", "rel_ymmin", "rel_yonly", "rel_tymid", "rel_ystat"], "rel_xmax": ["rel_xax", "rel_eymax", "rel_Xmax", "rel_zmin", "rel_eyax", "rel_zmed", "rel_hax", "rel_eyfrom", "rel_yfrom", "rel_hmax", "rel_Xmed", "rel_eymin", "rel_hmin", "rel_xmed", "rel_hfrom", "rel_ymed", "rel_zmax", "rel_Xmin", "rel_yax", "rel_xfrom"], "rel_ymax": ["rel_mmax", "rel_pmmax", "rel_yin", "rel_ypax", "rel_mxin", "rel_yaz", "rel_ymaz", "rel_ymmax", "rel_mxmin", "rel_pmaz", "rel_mmin", "rel_mxmax", "rel_ypmax", "rel_ymap", "rel_pmap", "rel_mxax", "rel_pmax", "rel_ypap", "rel_yap", "rel_ymmin", "rel_ypaz", "rel_mmmin", "rel_mmmax", "rel_yax"], "P": ["E", "V", "T", "Point", "M", "API", "R", "PA", "N", "A", "PUT", "K", "Q", "B", "Picture", "Ps", "PRE", "L", " p", "Y", "PR", "U", "G", " N", "J", "X", "PS", "F", "D", "BP", "p", "S", "PO", "Port", "O", "PIN", "PT", "C", "H"]}}
{"project": "FFmpeg", "commit_id": "ecb14b8af73b92e5a1be47c119d2f528ff402ebd", "target": 0, "func": "static int decode_nal_units(H264Context *h, const uint8_t *buf, int buf_size){\n\n    MpegEncContext * const s = &h->s;\n\n    AVCodecContext * const avctx= s->avctx;\n\n    H264Context *hx; ///< thread context\n\n    int buf_index;\n\n    int context_count;\n\n    int next_avc;\n\n    int pass = !(avctx->active_thread_type & FF_THREAD_FRAME);\n\n    int nals_needed=0; ///< number of NALs that need decoding before the next frame thread starts\n\n    int nal_index;\n\n\n\n    h->nal_unit_type= 0;\n\n\n\n    h->max_contexts = (HAVE_THREADS && (s->avctx->active_thread_type&FF_THREAD_SLICE)) ? avctx->thread_count : 1;\n\n    if(!(s->flags2 & CODEC_FLAG2_CHUNKS)){\n\n        h->current_slice = 0;\n\n        if (!s->first_field)\n\n            s->current_picture_ptr= NULL;\n\n        ff_h264_reset_sei(h);\n\n    }\n\n\n\n    for(;pass <= 1;pass++){\n\n        buf_index = 0;\n\n        context_count = 0;\n\n        next_avc = h->is_avc ? 0 : buf_size;\n\n        nal_index = 0;\n\n    for(;;){\n\n        int consumed;\n\n        int dst_length;\n\n        int bit_length;\n\n        uint8_t *ptr;\n\n        int i, nalsize = 0;\n\n        int err;\n\n\n\n        if(buf_index >= next_avc) {\n\n            if (buf_index >= buf_size - h->nal_length_size) break;\n\n            nalsize = 0;\n\n            for(i = 0; i < h->nal_length_size; i++)\n\n                nalsize = (nalsize << 8) | buf[buf_index++];\n\n            if(nalsize <= 0 || nalsize > buf_size - buf_index){\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"AVC: nal size %d\\n\", nalsize);\n\n                break;\n\n            }\n\n            next_avc= buf_index + nalsize;\n\n        } else {\n\n            // start code prefix search\n\n            for(; buf_index + 3 < next_avc; buf_index++){\n\n                // This should always succeed in the first iteration.\n\n                if(buf[buf_index] == 0 && buf[buf_index+1] == 0 && buf[buf_index+2] == 1)\n\n                    break;\n\n            }\n\n\n\n            if(buf_index+3 >= buf_size) break;\n\n\n\n            buf_index+=3;\n\n            if(buf_index >= next_avc) continue;\n\n        }\n\n\n\n        hx = h->thread_context[context_count];\n\n\n\n        ptr= ff_h264_decode_nal(hx, buf + buf_index, &dst_length, &consumed, next_avc - buf_index);\n\n        if (ptr==NULL || dst_length < 0){\n\n            return -1;\n\n        }\n\n        i= buf_index + consumed;\n\n        if((s->workaround_bugs & FF_BUG_AUTODETECT) && i+3<next_avc &&\n\n           buf[i]==0x00 && buf[i+1]==0x00 && buf[i+2]==0x01 && buf[i+3]==0xE0)\n\n            s->workaround_bugs |= FF_BUG_TRUNCATED;\n\n\n\n        if(!(s->workaround_bugs & FF_BUG_TRUNCATED)){\n\n        while(dst_length > 0 && ptr[dst_length - 1] == 0)\n\n            dst_length--;\n\n        }\n\n        bit_length= !dst_length ? 0 : (8*dst_length - ff_h264_decode_rbsp_trailing(h, ptr + dst_length - 1));\n\n\n\n        if(s->avctx->debug&FF_DEBUG_STARTCODE){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"NAL %d/%d at %d/%d length %d pass %d\\n\", hx->nal_unit_type, hx->nal_ref_idc, buf_index, buf_size, dst_length, pass);\n\n        }\n\n\n\n        if (h->is_avc && (nalsize != consumed) && nalsize){\n\n            av_log(h->s.avctx, AV_LOG_DEBUG, \"AVC: Consumed only %d bytes instead of %d\\n\", consumed, nalsize);\n\n        }\n\n\n\n        buf_index += consumed;\n\n        nal_index++;\n\n\n\n        if(pass == 0) {\n\n            // packets can sometimes contain multiple PPS/SPS\n\n            // e.g. two PAFF field pictures in one packet, or a demuxer which splits NALs strangely\n\n            // if so, when frame threading we can't start the next thread until we've read all of them\n\n            switch (hx->nal_unit_type) {\n\n                case NAL_SPS:\n\n                case NAL_PPS:\n\n                    nals_needed = nal_index;\n\n                    break;\n\n                case NAL_IDR_SLICE:\n\n                case NAL_SLICE:\n\n                    init_get_bits(&hx->s.gb, ptr, bit_length);\n\n                    if (!get_ue_golomb(&hx->s.gb))\n\n                        nals_needed = nal_index;\n\n            }\n\n            continue;\n\n        }\n\n\n\n        //FIXME do not discard SEI id\n\n        if(avctx->skip_frame >= AVDISCARD_NONREF && h->nal_ref_idc  == 0)\n\n            continue;\n\n\n\n      again:\n\n        err = 0;\n\n        switch(hx->nal_unit_type){\n\n        case NAL_IDR_SLICE:\n\n            if (h->nal_unit_type != NAL_IDR_SLICE) {\n\n                av_log(h->s.avctx, AV_LOG_ERROR, \"Invalid mix of idr and non-idr slices\");\n\n                return -1;\n\n            }\n\n            idr(h); // FIXME ensure we don't lose some frames if there is reordering\n\n        case NAL_SLICE:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= &hx->s.gb;\n\n            hx->s.data_partitioning = 0;\n\n\n\n            if((err = decode_slice_header(hx, h)))\n\n               break;\n\n\n\n            if (   h->sei_recovery_frame_cnt >= 0\n\n                && ((h->recovery_frame - h->frame_num) & ((1 << h->sps.log2_max_frame_num)-1)) > h->sei_recovery_frame_cnt) {\n\n                h->recovery_frame = (h->frame_num + h->sei_recovery_frame_cnt) %\n\n                                    (1 << h->sps.log2_max_frame_num);\n\n            }\n\n\n\n            s->current_picture_ptr->f.key_frame |=\n\n                    (hx->nal_unit_type == NAL_IDR_SLICE);\n\n\n\n            if (h->recovery_frame == h->frame_num) {\n\n                h->sync |= 1;\n\n                h->recovery_frame = -1;\n\n            }\n\n\n\n            h->sync |= !!s->current_picture_ptr->f.key_frame;\n\n            h->sync |= 3*!!(s->flags2 & CODEC_FLAG2_SHOW_ALL);\n\n            s->current_picture_ptr->sync = h->sync;\n\n\n\n            if (h->current_slice == 1) {\n\n                if(!(s->flags2 & CODEC_FLAG2_CHUNKS)) {\n\n                    decode_postinit(h, nal_index >= nals_needed);\n\n                }\n\n\n\n                if (s->avctx->hwaccel && s->avctx->hwaccel->start_frame(s->avctx, NULL, 0) < 0)\n\n                    return -1;\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    ff_vdpau_h264_picture_start(s);\n\n            }\n\n\n\n            if(hx->redundant_pic_count==0\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL){\n\n                if(avctx->hwaccel) {\n\n                    if (avctx->hwaccel->decode_slice(avctx, &buf[buf_index - consumed], consumed) < 0)\n\n                        return -1;\n\n                }else\n\n                if(CONFIG_H264_VDPAU_DECODER && s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU){\n\n                    static const uint8_t start_code[] = {0x00, 0x00, 0x01};\n\n                    ff_vdpau_add_data_chunk(s, start_code, sizeof(start_code));\n\n                    ff_vdpau_add_data_chunk(s, &buf[buf_index - consumed], consumed );\n\n                }else\n\n                    context_count++;\n\n            }\n\n            break;\n\n        case NAL_DPA:\n\n            init_get_bits(&hx->s.gb, ptr, bit_length);\n\n            hx->intra_gb_ptr=\n\n            hx->inter_gb_ptr= NULL;\n\n\n\n            if ((err = decode_slice_header(hx, h)) < 0)\n\n                break;\n\n\n\n            hx->s.data_partitioning = 1;\n\n\n\n            break;\n\n        case NAL_DPB:\n\n            init_get_bits(&hx->intra_gb, ptr, bit_length);\n\n            hx->intra_gb_ptr= &hx->intra_gb;\n\n            break;\n\n        case NAL_DPC:\n\n            init_get_bits(&hx->inter_gb, ptr, bit_length);\n\n            hx->inter_gb_ptr= &hx->inter_gb;\n\n\n\n            if(hx->redundant_pic_count==0 && hx->intra_gb_ptr && hx->s.data_partitioning\n\n               && s->context_initialized\n\n               && (avctx->skip_frame < AVDISCARD_NONREF || hx->nal_ref_idc)\n\n               && (avctx->skip_frame < AVDISCARD_BIDIR  || hx->slice_type_nos!=AV_PICTURE_TYPE_B)\n\n               && (avctx->skip_frame < AVDISCARD_NONKEY || hx->slice_type_nos==AV_PICTURE_TYPE_I)\n\n               && avctx->skip_frame < AVDISCARD_ALL)\n\n                context_count++;\n\n            break;\n\n        case NAL_SEI:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            ff_h264_decode_sei(h);\n\n            break;\n\n        case NAL_SPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n            if(ff_h264_decode_seq_parameter_set(h) < 0 && (h->is_avc ? (nalsize != consumed) && nalsize : 1)){\n\n                av_log(h->s.avctx, AV_LOG_DEBUG, \"SPS decoding failure, trying alternative mode\\n\");\n\n                if(h->is_avc) av_assert0(next_avc - buf_index + consumed == nalsize);\n\n                init_get_bits(&s->gb, &buf[buf_index + 1 - consumed], 8*(next_avc - buf_index + consumed));\n\n                ff_h264_decode_seq_parameter_set(h);\n\n            }\n\n\n\n            if (s->flags& CODEC_FLAG_LOW_DELAY ||\n\n                (h->sps.bitstream_restriction_flag && !h->sps.num_reorder_frames))\n\n                s->low_delay=1;\n\n\n\n            if(avctx->has_b_frames < 2)\n\n                avctx->has_b_frames= !s->low_delay;\n\n            break;\n\n        case NAL_PPS:\n\n            init_get_bits(&s->gb, ptr, bit_length);\n\n\n\n            ff_h264_decode_picture_parameter_set(h, bit_length);\n\n\n\n            break;\n\n        case NAL_AUD:\n\n        case NAL_END_SEQUENCE:\n\n        case NAL_END_STREAM:\n\n        case NAL_FILLER_DATA:\n\n        case NAL_SPS_EXT:\n\n        case NAL_AUXILIARY_SLICE:\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_DEBUG, \"Unknown NAL code: %d (%d bits)\\n\", hx->nal_unit_type, bit_length);\n\n        }\n\n\n\n        if(context_count == h->max_contexts) {\n\n            execute_decode_slices(h, context_count);\n\n            context_count = 0;\n\n        }\n\n\n\n        if (err < 0)\n\n            av_log(h->s.avctx, AV_LOG_ERROR, \"decode_slice_header error\\n\");\n\n        else if(err == 1) {\n\n            /* Slice could not be decoded in parallel mode, copy down\n\n             * NAL unit stuff to context 0 and restart. Note that\n\n             * rbsp_buffer is not transferred, but since we no longer\n\n             * run in parallel mode this should not be an issue. */\n\n            h->nal_unit_type = hx->nal_unit_type;\n\n            h->nal_ref_idc   = hx->nal_ref_idc;\n\n            hx = h;\n\n            goto again;\n\n        }\n\n    }\n\n    }\n\n    if(context_count)\n\n        execute_decode_slices(h, context_count);\n\n    return buf_index;\n\n}\n", "idx": 19724, "substitutes": {"h": ["m", "ch", "j", "t", "eh", "f", "oh", "hist", "hr", "g", "gh", "hi", "hd", "rh", "th", "ctx", "uh", "o", "han", "home", "host", "l", "d", "hw", "header", "ht", "sh", "w", "hl", "e", "q", "handler", "bh", "v", "ih", "c", "history", "hp", "p", "hm", "b", "http", "hh", "ph", "ha", "hs", "he", "ah", "H", "u"], "buf": ["Buffer", "grad", "br", "grab", "ff", "code", "data", "text", "pool", "buffer", "rc", "vec", "cf", "cb", "bc", "src", "Buff", "wb", "ctx", "pb", "context", "header", "begin", "conv", "box", "img", "queue", "config", "buff", "batch", "v", "map", "fb", "cur", "rb", "seq", "cmd", "uc", "que", "b", "cmp", "cap", "output", "alloc", "port", "bag", "uf", "bus", "cv", "input"], "buf_size": ["buf_sync", " buf_number", "buf_scale", "queue_size", "buf0number", "bufjsize", "buf_length", "queue_length", "buf_source", " buf_offset", " buf_scale", "buf0size", "queue_index", " buf_sync", "bufjnumber", "buf_loc", " buf_SIZE", "queue_count", "buf_offset", " buf_source", "buf0index", "buf_SIZE", "buf_number", "bufjoffset", "buf0offset", " buf_loc", "bufjindex", "buf_count"], "s": ["ns", "spec", "settings", "op", "service", "ss", "cs", "d", "sh", "qs", "cli", "p", "resource", "us", "sa", "input", "m", "sup", "ts", "sg", "rs", "in", "o", "share", "setup", "su", "sc", "v", "si", "S", "hs", "ds", "f", "sv", "r", "sb", "ys", "l", "network", "w", "sync", "c", "ps", "sci", "b", "sys", "es", "sq", "sf", "session", "t", "conf", "services", "n", "g", "sl", "ls", "ctx", "fs", "xs", "is", "site", "sch", "e", "ssl", "ses", "client", "js", "support", "http", "gs", "storage", "server", "u"], "avctx": ["evcmp", "avectx", "afcmp", "AVscl", "avconfig", "AVconfig", "afcu", "evscl", "broadcmp", "avcb", " avcb", "avecu", "broadcci", "AVcmp", "afcontext", "afctx", "abctx", "abcu", "evctx", "broadctx", "abcontext", "abcmp", "afcb", "afconfig", "avconf", "AVconf", "avscl", "broadcontext", " avscl", "abconfig", "AVcci", " avcmp", "avecontext", " avconfig", "afcci", "avcci", "AVctx", " avcontext", "afconf", "avecmp", "AVcontext", "avcmp", " avconf", "avcu", "avcontext", "evconf", "abcb"], "hx": ["phxc", "phct", "rhct", "rhtx", "phtx", "rhx", "rhxc", " hct", "hxc", "hct", "phx", " htx", "htx", " hxc"], "buf_index": ["fp00number", "bufPind", "buf_ini", "bufCdefault", "uf_update", "fp00ind", "fp00index", "bufamIndex", "fb_ini", "buf_body", "bufCdate", "buf_handle", "buflexcount", "uf_Index", "bufamcondition", "buf00site", "uf_index", "queue_size", "fp_prefix", "bufamnumber", "bufPdiff", "buf00size", "bufallnumber", "bufPsite", "buf_condition", "seq_site", "buflexbody", "seqPprefix", "bufPcount", "buf_length", "buf00index", "buf0type", "queue_label", "buf_label", "buf1index", "buf_inc", "fp_ind", "fp_index", "buflexheight", "uf_prefix", "queue_length", "buf1site", "vecPdiff", "buf64index", "bufallprefix", "buffer_size", "seqPind", "seq_index", "buf_site", "buf00number", "vecPcount", "bufamindex", "fp_number", "buf0size", "bufMsite", "buf00prefix", "cv_site", "buf64count", "cv_index", "vecPinc", "queue_index", "buffer_height", "bufallind", "buf_date", "bufMsize", "bufsindex", "seqPsite", "uf_body", "bufMindex", "fb_index", "buffer_index", "bufallindex", "seq_prefix", "buf1ind", "bufPprefix", "buf00label", "buf00length", "buf_ind", "buf1prefix", "bufamprefix", "bufamind", "bufamsite", "fp00prefix", "bufCindex", "buf_height", "buflexindex", "buf_prefix", "bufamsize", "cv_size", "bufPindex", "buf64diff", "bufCini", "buf64inc", "buf_default", "fb_date", "buf0inc", "seq_ind", "buf0index", "bufMhandle", "buf_diff", "uf_size", "buflexsize", "vec_inc", "bufamhandle", "bufsupdate", "buf00ind", "buflexupdate", "buf_number", "vecPindex", "bufPinc", "vec_diff", "buf_type", "buf_Index", "uf_condition", "vec_index", "queue_inc", "bufsbody", "cv_handle", "seqPindex", "buffer_count", "vec_count", "queue_type", "buf_update", "bufssize", "buf_count", "fb_default"], "context_count": [" contextsnum", "contextslimit", "context0group", "context__group", "contextalllimit", " context_num", "context_number", "contextfcount", "contextfnumber", "contextslen", "contextfsize", "context__number", " context0count", " contextscount", "context_len", " context0size", "contextscount", "contextsnum", "context_group", "context_size", "context0size", "contextallcount", " context_group", "context0number", "contextalllen", " context_size", "contextfgroup", " context0number", " context_number", " contextslimit", " context0group", "context0count", " context_limit", " contextslen", " context_len", "context__size", "context_num", "context_limit", "context__count", "contextallnum"], "next_avc": ["next_awcu", "next_afarc", "next_alp", "next_avepc", "next_awc", "next_afcu", "next_awci", "next_AVrc", "next_avci", "next_AVac", "next_ajc", "next_aff", "next_alc", "next_alci", "next_ajrc", "next_averc", "next_avep", "next_afcs", "next_umci", "next_afc", "next_avlc", "next_umcu", "next_awcs", "next_afci", "next_avf", "next_afrc", "next_awarc", "next_afp", "next_ajlc", "next_awp", "next_umc", "next_allc", "next_ajac", "next_avef", "next_calp", "next_aflc", "next_afpc", "next_umarc", "next_avarc", "next_avpc", "next_avp", "next_avec", "next_calci", "next_avac", "next_calc", "next_aveci", "next_avcu", "next_AVlc", "next_avecs", "next_ajf", "next_ajpc", "next_AVc", "next_avrc", "next_afac", "next_avcs", "next_callc"], "nal_index": ["nals_index", "nal_size", "nals_type", "naler_size", "nals_count", "nal_i", "naler_Index", "nal_count", "nal_type", "naler_i", "nals_Index", "naler_index", "nal_Index"], "pass": ["process", "skip", "j", "code", "rupt", "push", "call", "thread", "feed", "PASS", "acc", "result", "sw", "match", "ass", "run", "pos", "password", "act", "fast", "parse", "step", "fail", "flow", "ride", "pull", "sc", "cr", "parent", "catch", "strip", "post", "stage", "access", "test", "gen", "level", "proc", "loop", "row", "Pass", "port", "asses", "miss", "scan", "section", "success"], "consumed": [" unconserved", "cosensus", "coserved", "resumption", "cosumed", "conserved", "resensus", " unconsumption", "consumption", " unconsumed", "reserved", "cosumption", "consensus", " unconsensus", "resumed"], "dst_length": ["dst___address", "dst_long", "dbl_length", "dst_len", "dst___length", "dbl_long", "dst___len", "dbl_len", "dst___long", "dst_address", "dbl_address"], "bit_length": ["bit___width", "bit_limit", "bit___limit", "byte_width", "bit___len", "byte_length", "bit___length", "bit_width", "byte_limit", "bit_len", "byte_len"], "ptr": ["grad", "code", "tr", "data", "buffer", "rc", "vec", "str", "src", "loc", "slice", "pos", "dim", "pointer", "val", "fd", "buff", "seq", "pad", "cmp", "alloc", "proc", "addr", "port", "desc", "attr", "pt"], "i": ["gi", "ti", "uri", "bi", "j", "ji", "info", "x", "f", "jit", "ini", "qi", "io", "ai", "n", "phi", "mi", "z", "ii", "di", "index", "slice", "mini", "iu", "I", "multi", "zi", "ip", "chi", "l", "d", "pi", "ui", "ci", "id", "e", "ni", "si", "ki", "ri", "p", "xi", "uli", "eni", "fi", "attr", "li", "len"], "err": ["rx", "init", "frac", "code", "f", "result", "pack", " res", "in", "pos", "resp", "def", " errors", " arr", "found", " error", "comp", "aa", "e", "ea", "error", " rc", "res", " r", " success", "inner", "success"]}}
{"project": "FFmpeg", "commit_id": "611b35627488a8d0763e75c25ee0875c5b7987dd", "target": 1, "func": "static int dnxhd_find_frame_end(DNXHDParserContext *dctx,\n\n                                const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext *pc = &dctx->pc;\n\n    uint64_t state = pc->state64;\n\n    int pic_found = pc->frame_start_found;\n\n    int i = 0;\n\n\n\n    if (!pic_found) {\n\n        for (i = 0; i < buf_size; i++) {\n\n            state = (state << 8) | buf[i];\n\n            if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {\n\n                i++;\n\n                pic_found = 1;\n\n                dctx->cur_byte = 0;\n\n                dctx->remaining = 0;\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (pic_found && !dctx->remaining) {\n\n        if (!buf_size) /* EOF considered as end of frame */\n\n            return 0;\n\n        for (; i < buf_size; i++) {\n\n            dctx->cur_byte++;\n\n            state = (state << 8) | buf[i];\n\n\n\n            if (dctx->cur_byte == 24) {\n\n                dctx->h = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 26) {\n\n                dctx->w = (state >> 32) & 0xFFFF;\n\n            } else if (dctx->cur_byte == 42) {\n\n                int cid = (state >> 32) & 0xFFFFFFFF;\n\n\n\n                if (cid <= 0)\n\n                    continue;\n\n\n\n                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);\n\n                if (dctx->remaining <= 0) {\n\n                    dctx->remaining = ff_dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);\n\n                    if (dctx->remaining <= 0)\n\n                        return dctx->remaining;\n\n                }\n\n                if (buf_size - i + 47 >= dctx->remaining) {\n\n                    int remaining = dctx->remaining;\n\n\n\n                    pc->frame_start_found = 0;\n\n                    pc->state64 = -1;\n\n                    dctx->cur_byte = 0;\n\n                    dctx->remaining = 0;\n\n                    return remaining;\n\n                } else {\n\n                    dctx->remaining -= buf_size;\n\n                }\n\n            }\n\n        }\n\n    } else if (pic_found) {\n\n        if (dctx->remaining > buf_size) {\n\n            dctx->remaining -= buf_size;\n\n        } else {\n\n            int remaining = dctx->remaining;\n\n\n\n            pc->frame_start_found = 0;\n\n            pc->state64 = -1;\n\n            dctx->cur_byte = 0;\n\n            dctx->remaining = 0;\n\n            return remaining;\n\n        }\n\n    }\n\n    pc->frame_start_found = pic_found;\n\n    pc->state64 = state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 19728, "substitutes": {"dctx": ["madcontext", "dxc", "dhctx", "edcam", "Dcontext", " dbc", " dgc", "pdlc", "zcontext", "dcfg", "pdpkg", "sdctx", "dcss", "edcf", "pos", "dcontext", "daycontext", "ldlc", "dogb", "madloc", "sdcas", "datcp", "dhcfg", "dlctx", "ncontext", "comp", "datpkg", "Dcli", "dsbc", "ldctx", "Dcp", "dcache", "dscf", "sdpkg", "datcmp", "docf", "zctx", "delctx", "ndctx", "doctrl", "pdgc", "dhctrl", "bdcontext", "sdcp", "dpkg", "dhcam", "vdcontext", " dchan", " dloc", "sdgc", "zgc", "datchan", "ctr", "dlcache", "ndcontext", "odcca", "sdcmp", "pdctrl", "dcf", " dqa", "edctx", "daycache", "dgc", "docfg", "edcontext", "madctx", "bdpkg", "pdcfg", "datctx", "dlloc", "dgb", "sdcf", "edcca", " dgb", " dcfg", "dscontext", "Dcss", "sdchan", "pdcam", "odcp", " dkb", "odqa", "dcam", "dtx", "delcmp", "nkb", "zcf", "Dcca", "dcmp", "dkb", "pdcontext", "dlcontext", " dcss", "dsctx", "dctrl", "dcas", "r", "dogc", " dcp", "block", " dcmp", "ndcf", "this", "dchan", "bdcli", "dlcam", "zlc", "vdcp", "pdcli", "Dcache", "bdctx", "nlc", "dayctx", "ndlc", "Dcf", "dloc", "sdcontext", "Dloc", "Dkb", "vdpkg", "Dpkg", "sdbc", "dsci", "sdsci", "dotx", "sdlc", "odcam", " dxc", "addr", "dlc", "ldcmp", " dcontext", "odctx", "delcss", "pdsci", "ncus", "doctx", " dsci", "s", "vdctx", "nloc", "func", "odcontext", "Dcmp", "ztx", "dscp", " dlc", " dtx", "datsci", "Dctx", "ldcf", "dbc", "datcfg", " dpkg", " dcli", "daycam", "delcontext", "nctx", "edgb", "dslc", "ldcas", "dcli", "sdcfg", "Dxc", "docontext", " dcas", "madkb", "ldcontext", "Dlc", "_", "dcp", "pdctx", "dqa", "docam", "Dqa", " dcus", "ndxc", "dcus", "dcca", " dcf", "dlcus", "Dcam"], "buf": ["Buffer", "ab", "br", "grab", "ff", "data", "func", "pool", "buffer", "rc", "vec", "fi", "cf", "num", "sb", "cb", "block", "bc", "src", "wb", "pb", "ptr", "pos", "mem", "cas", "context", "header", "conv", "aux", "box", "img", "queue", "config", "fd", "buff", "fb", "batch", "rb", "seq", "cmd", "uc", "que", "cap", "alloc", "proc", "port", "bag", "uf", "cv", "wave"], "buf_size": ["queue_time", "bufkloc", "buf_width", " buf_length", "buf_handle", "seq_handle", "buf_scale", "buf_end", "queue_size", "buf_found", "seq_loc", "seq_number", "buf_chain", "bufkhandle", " buf_Size", "buf_length", "buflenchain", "buf4Size", "queue_SIZE", " buf_shape", "cb_width", "queue_scale", "bufknumber", "buf4size", "queue_sized", "buf_shape", "bufksize", "buf_time", "cb_end", "buf_Size", "cb_Size", "buf_loc", " buf_chain", "buf4width", "queue_found", "buflenlength", "buf_SIZE", "seq_size", "cb_size", "buf_number", "buflensize", "buf4end", "buf_sized"], "pc": ["dc", "plugin", "jc", "pid", "fp", "cca", "cus", "vc", "ct", "conn", "px", "pd", "inc", "pm", "bp", "anc", "bc", "cp", "toc", "PC", "loc", "ctx", "fc", "pb", "mc", "lp", "cz", "sa", "wcs", "pac", "ca", "enc", "cs", "arc", "roc", "gb", "cms", "nc", "ac", "pre", "ci", "tc", "xc", "con", "sc", "pa", "cr", "client", "lc", "c", "si", "p", "uc", "pr", "ec", "sys", "proc", "py", "pt", "cc", "amp", "pin"], "i": ["ti", "gi", "uri", "m", "bi", "init", "j", "ji", "ami", "info", "x", "f", "ix", "ini", "qi", "r", "ai", "io", "mi", "phi", "n", "g", "hi", "z", "ii", "ori", "ie", "di", "iu", "index", "slice", "I", "multi", "zi", "o", "ip", "l", "oi", "yi", "pi", "ui", "ci", "id", "e", "k", "v", "ni", "c", "si", "ki", "ri", "p", "xi", "b", "h", "state", "it", "eni", "my", "fi", "esi", "y", "li", "u"], "cur_byte": ["curJframe", "cur_large", "cur_layer", " cur_binary", "curIPlarge", "char_bit", " cur_layer", "cur_bit", "curJbinary", "curIPword", "cur_channel", " cur_word", "char_frame", " cur_bit", " cur_bytes", "cur__binary", "cur__channel", "cur__byte", "cur__word", "curJbit", "curJword", " cur_channel", "cur_source", "cur_binary", "curIPlayer", "charJbit", "cur__bytes", "charJbinary", " cur_hop", "cur_bytes", " cur_source", "char_binary", "cur__bit", "charJbyte", "curJbyte", "curIPbyte", " cur_pixel", "cur__source", "cur_word", "cur_hop", "char_byte", "charJframe", "cur_frame", " cur_large", "cur_pixel"]}}
{"project": "FFmpeg", "commit_id": "c8241e730f116f1c9cfc0b34110aa7f052e05332", "target": 0, "func": "static av_cold int vaapi_encode_h264_init_constant_bitrate(AVCodecContext *avctx)\n\n{\n\n    VAAPIEncodeContext      *ctx = avctx->priv_data;\n\n    VAAPIEncodeH264Context *priv = ctx->priv_data;\n\n    int hrd_buffer_size;\n\n    int hrd_initial_buffer_fullness;\n\n\n\n    if (avctx->bit_rate > INT32_MAX) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Target bitrate of 2^31 bps or \"\n\n               \"higher is not supported.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (avctx->rc_buffer_size)\n\n        hrd_buffer_size = avctx->rc_buffer_size;\n\n    else\n\n        hrd_buffer_size = avctx->bit_rate;\n\n    if (avctx->rc_initial_buffer_occupancy)\n\n        hrd_initial_buffer_fullness = avctx->rc_initial_buffer_occupancy;\n\n    else\n\n        hrd_initial_buffer_fullness = hrd_buffer_size * 3 / 4;\n\n\n\n    priv->rc_params.misc.type = VAEncMiscParameterTypeRateControl;\n\n    priv->rc_params.rc = (VAEncMiscParameterRateControl) {\n\n        .bits_per_second   = avctx->bit_rate,\n\n        .target_percentage = 66,\n\n        .window_size       = 1000,\n\n        .initial_qp        = (avctx->qmax >= 0 ? avctx->qmax : 40),\n\n        .min_qp            = (avctx->qmin >= 0 ? avctx->qmin : 18),\n\n        .basic_unit_size   = 0,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->rc_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->rc_params);\n\n\n\n    priv->hrd_params.misc.type = VAEncMiscParameterTypeHRD;\n\n    priv->hrd_params.hrd = (VAEncMiscParameterHRD) {\n\n        .initial_buffer_fullness = hrd_initial_buffer_fullness,\n\n        .buffer_size             = hrd_buffer_size,\n\n    };\n\n    ctx->global_params[ctx->nb_global_params] =\n\n        &priv->hrd_params.misc;\n\n    ctx->global_params_size[ctx->nb_global_params++] =\n\n        sizeof(priv->hrd_params);\n\n\n\n    // These still need to be  set for pic_init_qp/slice_qp_delta.\n\n    priv->fixed_qp_idr = 26;\n\n    priv->fixed_qp_p   = 26;\n\n    priv->fixed_qp_b   = 26;\n\n\n\n    av_log(avctx, AV_LOG_DEBUG, \"Using constant-bitrate = %\"PRId64\" bps.\\n\",\n\n           avctx->bit_rate);\n\n    return 0;\n\n}\n", "idx": 19759, "substitutes": {"avctx": ["avalcoll", "AVcrit", "afcmp", "awctrl", "varcomponent", "verkb", "avcdn", "avecf", "avcoll", "avpkg", "AVcmp", "AVcu", "avctrl", "avcrit", "evcu", "ovcontext", "Avloc", "evcontext", "avsc", "afloc", "AVcli", "navctrl", "verconn", "AVctx", " avcontext", "varsc", "avcca", " avctl", " avqa", "aucmp", "navcontext", "Avctx", "evcf", "afcas", "avctl", "awcas", "avalcms", "AVcoll", "avcb", "avecu", "auctx", "aucontext", "varcam", "afctrl", "AVloc", "navcas", "vercmp", "navctl", "AVcca", "avcas", "navcli", "AVcam", "avalcb", "varconn", "navctx", "avcmp", "avcam", "varcontext", "avcli", "vercontext", "AVpkg", "AVqa", "awctx", "AVsc", "afsc", "AVctl", "avcomponent", "Avcontext", "AVcb", "AVcms", "ovcca", "avcf", "varcdn", "ovctx", "varctl", "avloc", "AVcontext", "navcms", "avalctx", " avcca", "afpkg", "avalcomponent", " avconn", "avalcontext", "avectx", "avalcrit", "avcms", "AVcomponent", "verctx", " avcli", "varcmp", "afcam", "avalcdn", "AVcdn", "navcb", "avkb", "awcontext", "AVkb", "afcontext", "avconn", "afctx", "evctx", "navcrit", "ovqa", "avecontext", "AVcf", "varctx", "afconn", "AVconn", "navcoll", "avqa", "afkb", "Avconn", "avcu", "avcontext", "aupkg"], "ctx": ["cf", "anc", " context", "cas", "Context", "exec", "cs", "tx", "config", "xc", "cu", "cli", "lib", "ck", "cv", "cc", "conn", "cdn", "cca", "cus", "vc", "rc", "cm", "cp", "bc", "wcs", "hw", "sc", "lc", "fp", "jp", "component", "r", "cb", "src", "loc", "utils", "this", "git", "ctrl", "act", "crit", "ca", "kb", "ci", "sync", "c", "qa", "sci", "sys", "cn", "sq", "np", "voc", "s", "func", "all", "g", "acl", "context", "pkg", "nc", "tc", "cam", "client", "_", "cmd", "url", "cmp"], "priv": ["pc", "spec", "stat", "org", "cfg", "txt", "ch", "data", "info", "pub", "typ", "conf", "obj", "vc", "rc", "Priv", "cf", "anc", "auth", "cp", "public", "ocr", "bc", "utils", "pb", "ptr", "sec", "git", "kr", "kw", "cy", "cert", "ca", "sk", "exec", "cs", "context", "auc", "gb", "rec", "ce", "pkg", "tx", "pi", "rib", "ci", "pri", "config", "soc", "prof", "private", "req", "lc", "temp", "dev", "neg", "access", "uc", "cache", "cmp", "cap", "sys", "storage", "proc", "api", "pro", "riv", "prem", "gr", "attr", "conn", "voc"], "hrd_buffer_size": ["hrd_buffer___fee", "hrd_queue_size", "hrd_reference___width", "hrd_buffer_fee", "hrd_queue_strength", "hrd_bufferamsize", "hrd_reference_size", "hrd_bufferactype", "hrd_reference_fee", "hrd_buffer___size", "hrd_queue_rate", "hrd_queue_capacity", "hrd_buffer_width", "hrd_bufferacstrength", "hrd_buffer_ize", "hrd_buffer_type", "hrd_reference___size", "hrd_buffer_strength", "hrd_buffer64size", "hrd_reference_exclusive", "hrd_buffer64exclusive", "hrd_buffer_rate", "hrd_bufferamstrength", "hrd_queue_length", "hrd_bufferaccapacity", "hrd_buffer_small", "hrd_queue_scale", "hrd_queue_ize", "hrd_buffer__rate", "hrd_bufferacize", "hrd_buffer___exclusive", "hrd_reference___exclusive", "hrd_buffer_capacity", "hrd_buffer_length", "hrd_buffer___width", "hrd_buffer64width", "hrd_buffer64fee", "hrd_bufferamcapacity", "hrd_bufferamtype", "hrd_bufferacsize", "hrd_reference___fee", "hrd_buffer__size", "hrd_buffer_exclusive", "hrd_queue_small", "hrd_buffer_scale", "hrd_buffer__small", "hrd_reference_width", "hrd_queue_type"], "hrd_initial_buffer_fullness": ["hrd_initial_buffer__fullsize", "hrd_initial_buffer_shortment", "hrd_initial_buffer__fullment", "hrd_initial_buffer_fuliness", "hrd_initial_buffer__fulment", "hrd_initial_buffer_fullity", "hrd_initial_buffer_shortlength", "hrd_initial_buffer_freeity", "hrd_initial_buffer__fulliness", "hrd_initial_buffer_longlength", "hrd_initial_buffer__fulness", "hrd_initial_buffer_fness", "hrd_initial_buffer_fsize", "hrd_initial_buffer_halfness", "hrd_initial_buffer_halfstrength", "hrd_initial_buffer_minlength", "hrd_initial_buffer_widesize", "hrd_initial_buffer_longocity", "hrd_initial_buffer_freeness", "hrd_initial_buffer_minocity", "hrd_initial_buffer_minness", "hrd_initial_buffer_fullocity", "hrd_initial_buffer_fullment", "hrd_initial_buffer__fulsize", "hrd_initial_buffer_longness", "hrd_initial_buffer_freestrength", "hrd_initial_buffer__fullness", "hrd_initial_buffer_fullstrength", "hrd_initial_buffer_minsize", "hrd_initial_buffer_halflength", "hrd_initial_buffer_freesize", "hrd_initial_buffer_halfsize", "hrd_initial_buffer_wideness", "hrd_initial_buffer_fulllength", "hrd_initial_buffer_longsize", "hrd_initial_buffer_widelength", "hrd_initial_buffer_shortsize", "hrd_initial_buffer_fity", "hrd_initial_buffer_shortstrength", "hrd_initial_buffer_shortiness", "hrd_initial_buffer__fuliness", "hrd_initial_buffer_fstrength", "hrd_initial_buffer_fullsize", "hrd_initial_buffer_shortness", "hrd_initial_buffer_fulment", "hrd_initial_buffer_wideocity", "hrd_initial_buffer_fulsize", "hrd_initial_buffer_fulness", "hrd_initial_buffer_fulliness"]}}
{"project": "FFmpeg", "commit_id": "6e42e6c4b410dbef8b593c2d796a5dad95f89ee4", "target": 1, "func": "static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)\n\n{\n\n\tlong x,y;\n\n\n\n\tdst[0]= src[0];\n\n\n\n\t// first line\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n\n\n        dst+= dstStride;\n\n\n\n\tfor(y=1; y<srcHeight; y++){\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\t\tconst long mmxSize= srcWidth&~15;\n\n\t\tasm volatile(\n\n\t\t\t\"mov %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_a\"), %%mm1\t\\n\\t\"\n\n\t\t\t\"movq 1(%0, %%\"REG_a\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"movq 1(%1, %%\"REG_a\"), %%mm3\t\\n\\t\"\n\n\t\t\t\"movq -1(%0, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movq -1(%1, %%\"REG_a\"), %%mm5\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\"\n\n#if 1\n\n\t\t\tMOVNTQ\" %%mm5, (%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, (%3, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#else\n\n\t\t\t\"movq %%mm5, (%2, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\t\"movq %%mm4, (%3, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#endif\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\t:: \"r\" (src + mmxSize  ), \"r\" (src + srcStride + mmxSize  ),\n\n\t\t\t   \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2),\n\n\t\t\t   \"g\" (-mmxSize)\n\n\t\t\t: \"%\"REG_a\n\n\n\n\t\t);\n\n#else\n\n\t\tconst long mmxSize=1;\n\n#endif\n\n\t\tdst[0        ]= (3*src[0] +   src[srcStride])>>2;\n\n\t\tdst[dstStride]= (  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 19782, "substitutes": {"src": ["spec", "supp", "pack", "upload", "sec", "uv", "gb", "secure", "feat", "rib", "comp", "config", "gl", "chrom", "impl", "lib", "rect", "lat", "source", "cv", "asc", "sup", "sur", "rs", "dest", "rc", "stream", "rob", "sub", "sc", "sth", "uc", "gz", "scenes", "iv", "desc", "bs", "image", "RC", "sb", "loc", "sel", "expl", "filename", "sr", "ruby", "buf", "sync", "scl", "rss", "sci", "b", "sys", "split", "inst", "transform", "ser", "sq", "reflect", "sl", "ctx", "fc", "slice", "conv", "st", "img", "ssl", "cur", "req", "rb", "seq", "support", "url", "http", "proc", "usr", "dist"], "dst": ["dsl", "dssc", "ndsts", "Dste", "idrest", "Dconst", "dsconst", "Dst", "adconst", "dste", "lste", "adste", " dconst", "dssrc", "adost", " dbl", "ndST", "fsrc", "fst", "dsrc", "dconst", "fsc", "pdst", " dste", "pdbl", "DST", "idst", " dost", "dsst", "ddest", "ndst", "Dsts", "dsc", " drest", "idost", "adst", "idbl", "pdsts", " dsc", "fconst", "adrest", "lst", " ddest", "ndconst", "adbl", "drest", "addest", " dsrc", " drc", "dost", "adsts", " dsts", "dssts", "pddest", "dST", "fsts", "lsc", " dST", "lsl", "dsts", "adsl", "dbl", " dsl", "frc", "adsc", "drc"], "srcWidth": ["sourceHeight", " srcwidth", "sourcewidth", "destWidth", "srcwidth", "rcSize", "sourceSize", "rcLen", "destHeight", "rcHeight", "sourceLength", " srcSize", "srcLen", "destLength", "destwidth", "rcWidth", "srcSize", " srcLen", "rcLength", "rcwidth", "sourceWidth", "sourceLen", "srcLength", " srcLength"], "srcHeight": ["stLevel", "sourceHeight", "rcTop", "stLength", "srcTop", "rcHeight", "srcLevel", "sourceLength", "stHeight", "rcWidth", " srcLevel", "stWidth", "sourceLevel", "rcLength", "sourceWidth", "sourceTop", "srcLength", " srcLength", " srcTop"], "srcStride": ["sourceRestair", "srcWrite", "srcWride", "rcStide", "srcEstide", "srcRestride", "srcRestr", "rcStride", "rcStrip", "srcWair", "srcShrict", "srcStair", "srcShide", "srcShrip", "rcstrip", "sourceRestrite", "sourceStair", "srcstide", "srcStrite", "sourceStrite", "rcstide", "srcStrict", "srcstrite", "srcstr", "srcEstrip", "srcEstrict", "srcShride", "srcStr", "srcstrip", "srcStrip", "rcstrict", "srcRestrite", "srcstair", "rcStrict", "srcWr", "srcStide", "rcstride", "srcstride", "sourceStr", "srcstrict", "sourceRestride", "sourceRestr", "sourceStride", "srcRestair", "srcEstride"], "dstStride": ["dsrcTro", "dstRestro", "dstStide", "dsrcTr", "dsrcStride", "destStride", "dstSTrip", "destStide", "dstRestride", "destStrip", "dstTr", "dstStrip", "destStrite", "dstStrite", "dsrcTrip", "dstStro", "deststide", "dstTro", "dstSTide", "dstRestr", "dstEstride", "dsrcTride", "dstDestrip", "dstEstr", "dsrcStro", "dststride", "dstRestrip", "dstTride", "dststrite", "dstDestrite", "dstDestride", "dstTrip", "dstSTrite", "deststrite", "deststrip", "deststride", "dstDestide", "dstEstrip", "dstSTride", "dststide", "dsrcStr", "dstEstro", "dstStr", "dststrip", "dsrcStrip"], "x": ["rx", "m", "sex", "xx", "code", "t", "yx", "wx", "f", "name", "bit", "ct", "ix", "image", "plus", "px", "pe", "xes", "n", "num", "on", "i", "sw", "xe", "z", "xy", "lex", "ctx", "index", "any", "min", "xs", "xp", "host", "l", "fx", "d", "val", "key", "step", "tx", "ww", "height", "w", "dx", "ex", "ax", "X", "id", "e", "xxx", "v", "sync", "c", "xt", "k", "p", "xi", "b", "cross", "h", "ux", "a", "ty", "my", "xc", "wy", "u"], "y": ["m", "j", "ky", "t", "f", "yd", "n", "ya", "i", "g", "ym", "type", "z", "ny", "xy", "year", "cy", "Y", "l", "d", "yi", "ye", "dy", "ay", "w", "height", "yy", "ey", "id", "yt", "yr", "c", "yn", "p", "b", "col", "oy", "h", "vy", "yo", "gy", "ty", "yl", "py", "sy", "wy", "ady"]}}
{"project": "qemu", "commit_id": "9b2fadda3e0196ffd485adde4fe9cdd6fae35300", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808, "substitutes": {"ctx": ["cfg", "concept", "cf", "anc", "gru", "console", "cas", "Context", "cs", "exec", "tx", "config", "xc", "gpu", "cu", "cli", "qq", "ck", "cv", "cc", "conn", "txt", "wx", "cca", "cus", "vc", "rc", "cm", "cp", "bc", "wcs", "msg", "kw", "hw", "cms", "sc", "cr", "lc", "la", "connection", "cgi", "na", "fp", "jp", "component", "cpu", "cpp", "cb", "loc", "lex", "git", "ctrl", "crit", "ca", "kb", "ci", "ga", "sync", "c", "history", "qa", "sci", "cn", "np", "progress", "ch", "fc", "pai", "context", "ce", "nc", "pkg", "tc", "cam", "cl", "client", "req", "cmd", "kt", "support", "cmp"]}}
{"project": "qemu", "commit_id": "447b0d0b9ee8a0ac216c3186e0f3c427a1001f0c", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809, "substitutes": {"view": ["entry", "child", "name", "image", "comment", "action", "show", "see", "block", "match", "face", "node", "package", "index", "model", "watch", "object", "page", "link", "alias", "event", "build", "style", "use", "seen", "client", "update", "layout", "url", "feature", "http", "route", "VIEW", "form", "row", "template", "project", "server", "View", "source"]}}
{"project": "FFmpeg", "commit_id": "2162b862eba5aadb59c0cf7cc304c67f4a5fb946", "target": 1, "func": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}", "idx": 19827, "substitutes": {"vlc": ["hlpc", "vlt", "llpc", "vrci", "svch", "vlci", "llch", "llp", "lvlc", "svc", "vlpc", "vlp", "llc", "nlci", "lvci", "vrt", "llt", "nlc", "vlch", "vrc", "vrpc", "svt", "lvc", "llci", "lllc", "svpc", "vllc", "svci", "lvp", "nllc", "hlci", "hlc", "nlp", "hlch"], "len": ["lon", "part", "bin", "data", "lim", "lif", "base", "lit", "lic", "n", "syn", "lu", "num", "block", "z", "index", "pos", "fin", "dl", "dim", "min", "en", "enc", "lf", "label", "ln", "l", "low", "val", "fl", "size", "le", "kn", "dy", "con", "length", "ler", "limit", "den", "rev", "lc", "seq", "lib", "ll", "line", "sym", "cache", "lock", "norm", "lan", "la", "fn", "split", "lin", "list", "sy", "el", "li", "Len"], "he": ["ache", "work", "che", "hel", "here", "HE", "ve", "fe", "ne", "pe", "hy", "we", "iche", "gh", "see", "He", "hi", "ge", "rh", "hes", "four", "index", "en", "ae", "fen", "create", "ee", "her", "han", "his", "they", "she", "chi", "header", "re", "hess", "ce", "the", "rule", "there", "hu", "fore", "ue", "e", "be", "you", "ale", "cache", "cle", "hen", "sche", "h", "ke", "wa", "ph", "ha", "ense", "hs", "se", "hea", "one", "apache"], "codes": ["classes", "ns", "values", "resses", "fixes", "cycles", "planes", "rates", "jobs", "x", "fields", "ports", "modules", "seconds", "objects", "comm", "cod", "ints", "ls", "items", "lines", "cons", "checks", "Code", "coded", "changes", "cs", "breaks", "cells", "ins", "comp", "ci", "config", "blocks", "cards", "levels", "maps", "frames", "seq", "cats", "odes", "ones", "names", "keys", "rules", "errors", "bytes", "cases", "flags", "hops", "opens", "states", "locks"], "bits": ["classes", "bugs", "values", "limits", "fixes", "cycles", "bs", "planes", "pieces", "words", "x", "bit", "settings", "ports", "plugins", "details", "ips", "ints", "ls", "ops", "items", "pos", "lines", "cs", "cells", "ins", "outs", "gets", "features", "blocks", "config", "ries", "pins", "frames", "alls", "ps", "rows", "bands", "b", "odes", "lins", "its", "keys", "bytes", "parts", "cases", "flags", "locks"], "syms": ["eyps", "gymm", "tyns", "asym", "tymes", "lyms", "asyms", "fymm", "synps", "cyvs", " symn", "lyns", "asyns", "eyml", "syml", "Syms", "zyms", " syml", "zyns", "gyml", "cymes", "Symes", "symes", "tymb", " sym", "Sym", "zyml", "fyml", " symm", "lymes", "zyps", "symn", "syps", "synns", "gymn", "eyns", "cym", "fymn", "fyms", "symb", "asymb", " syvs", "syvs", "Symm", "sym", "asymes", "asyvs", "synml", "lymb", " symes", "syns", "asymm", "synms", "tyms", "symm", "eyms", "cyms", "gyms"], "code": ["scale", "ch", "core", "x", "bit", "call", "name", "fe", "cm", "cb", "type", "cod", "bc", "index", "sec", "cycle", "byte", "zip", "Code", "count", "copy", "create", "change", "ce", "complete", "nc", "size", "go", "ci", "length", "id", "key", "sync", "cur", "c", "seq", "p", "address", "que", "cache", "error", "ec", "second", "message", "sequence", "co", "one", "order", "cc", "bug"], "i": ["uri", "bi", "ji", "x", "qi", "ai", "phi", "result", "hi", "ie", "d", "pi", "id", "cli", "ni", "p", "xi", "resource", "it", "fi", "gi", "m", "ei", "init", "j", "ix", "ini", "in", "iu", "I", "o", "k", "v", "si", "ki", "ri", "a", "iv", "ti", "f", "r", "mi", "ii", "di", "ind", "multi", "zi", "vi", "chi", "l", "oi", "yi", "ci", "start", "c", "b", "inst", "eni", "mu", "ik", "info", "io", "n", "g", "module", "z", "index", "ip", "ui", "isin", "e", "isi", "api", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "937470bb5470825e781ae50e92ff973a6b54d80f", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834, "substitutes": {"task": ["process", "instance", "session", "work", "t", "data", "func", "call", "trip", "thread", "job", "result", "worker", "pack", "block", "cb", "type", "app", "clean", "Task", "ass", "act", "object", "exec", "ask", "pg", "pp", "complete", "event", "tx", "tc", "sync", "test", "ck", "resource", "tf", "project", "message", "kk", "source", "target"], "obj": ["ns", "org", "instance", "init", "j", "db", "code", "t", "data", "func", "bj", "ob", "so", "ref", "obb", "n", "objects", "sb", "cb", "coll", "ctx", "pos", "ass", "nb", "self", "act", "object", "o", "po", "arr", "exec", "class", "fl", "pkg", "img", "st", "id", "sync", "parent", "js", "tmp", "rb", "lib", "test", "url", "b", "od", "fn", "Object", "inst", "boot", "api", "os", "source", "Obj"], "src": ["spec", "instance", "super", "record", "func", "data", "fp", "dest", "ref", "rc", "proxy", "sb", "java", "cb", "stream", "sl", "loc", "node", "ources", "ctx", "sel", "ptr", "Source", "object", "setup", "class", "std", "socket", "sn", "img", "config", "sc", "sync", "ource", "target", "rb", "tmp", "url", "test", "resource", "null", "sys", "fn", "inst", "callback", "source", "dist", "input"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int nut_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    NUTContext *nut = s->priv_data;\n\n    ByteIOContext *bc = &s->pb;\n\n    int64_t pos;\n\n    int inited_stream_count;\n\n\n\n    nut->avf= s;\n\n    \n\n    av_set_pts_info(s, 60, 1, AV_TIME_BASE);\n\n\n\n    /* main header */\n\n    pos=0;\n\n    for(;;){\n\n        if (find_startcode(bc, MAIN_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"no main startcode found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_main_header(nut) >= 0)\n\n            break;\n\n    }\n\n    \n\n    \n\n    s->bit_rate = 0;\n\n\n\n    nut->stream = av_malloc(sizeof(StreamContext)*nut->stream_count);\n\n\n\n    /* stream headers */\n\n    pos=0;\n\n    for(inited_stream_count=0; inited_stream_count < nut->stream_count;){\n\n        if (find_startcode(bc, STREAM_STARTCODE, pos)<0){\n\n            av_log(s, AV_LOG_ERROR, \"not all stream headers found\\n\");\n\n            return -1;\n\n        }\n\n        pos= url_ftell(bc);\n\n        if(decode_stream_header(nut) >= 0)\n\n            inited_stream_count++;\n\n    }\n\n\n\n    /* info headers */\n\n    pos=0;\n\n    for(;;){\n\n        uint64_t startcode= find_any_startcode(bc, pos);\n\n        pos= url_ftell(bc);\n\n\n\n        if(startcode==0){\n\n            av_log(s, AV_LOG_ERROR, \"EOF before video frames\\n\");\n\n            return -1;\n\n        }else if(startcode == KEYFRAME_STARTCODE){\n\n            url_fseek(bc, -8, SEEK_CUR); //FIXME\n\n            break;\n\n        }else if(startcode != INFO_STARTCODE){\n\n            continue;\n\n        }\n\n\n\n        decode_info_header(nut);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 19886, "substitutes": {"s": ["ns", "spec", "stat", "settings", "service", "ss", "sec", "cs", "d", "qs", "sym", "p", "sts", "ks", "us", "sets", "sa", "ms", "m", "sup", "ts", "sg", "aws", "self", "o", "su", "sac", "sc", "v", "si", "S", "a", "an", "ds", "bs", "f", "sv", "r", "sb", "this", "sn", "bis", "sync", "c", "ps", "b", "sys", "your", "es", "sq", "less", "session", "small", "t", "stats", "conf", "services", "n", "g", "i", "sl", "ats", "ls", "ops", "fs", "is", "e", "ssl", "ses", "js", "http", "gs", "storage", "sign", "os", "se", "server", "south"], "ap": ["pc", "wp", "au", "op", "sp", "ai", "ar", "ams", "bp", "am", "cp", "pac", "arr", "ip", "att", "aps", "ac", "pi", "pa", "hp", "cap", "proc", "api", "pro", "tp", "mac", "arp", "attr", "amp"], "nut": ["stone", "obj", "nt", "anc", "ut", "piece", "feat", "config", "fit", "qt", "boot", "conn", "oven", "not", "tun", "txt", "cht", "cdn", "ot", "fat", "ctr", "annot", "ocr", "dt", "done", "art", "rob", "rot", "nuts", "nw", "tmp", "ox", "Nut", "gt", "gat", "uts", "ft", "nv", "cart", "aug", "nah", "ct", "rt", "nit", "cb", "ou", "or", "node", "nas", "nat", "ott", "sn", "rn", "aft", "tube", "Nat", "orb", "cit", "fn", "cn", "cut", "oren", "np", "pot", "cot", "t", "orn", "note", "n", "bt", "ore", "roy", "bd", "utt", "cro"], "bc": ["pc", "dc", "CBC", "oc", "org", "cc", "bi", "jc", "ic", "db", "bs", "cca", "cus", "vc", "rc", "gc", "cm", "gg", "exc", "sb", "comm", "cb", "anc", "loc", "ocr", "wb", "ctx", "fc", "pb", "mc", "acl", "web", "sec", "ca", "ml", "exec", "auc", "gb", "bo", "BC", "cms", "bos", "nc", "bf", "ac", "com", "con", "bd", "tc", "config", "sc", "soc", "fb", "cl", "lc", "c", "lib", "uc", "bn", "ec", "mac", "conn", "ib"], "pos": ["spec", "offset", "skip", "ref", "op", "str", "nos", "POS", "po", "feat", "pi", "no", "length", "config", "p", "pose", "gen", "win", "end", "lang", "pt", "len", "pc", "part", "resp", "min", "pointer", "slot", "axis", "size", "style", "open", "off", "port", "push", "base", "aos", "block", "type", "loc", "Pos", "val", "start", "ps", "position", "post", "doc", "pro", "state", "pres", "cond", "pid", "conf", "sp", "pass", "index", "def", "tag", "is", "prop", "ac", "args", "fail", "limit", "unit", "neg", "seq", "cache", "col", "proc", "os", "diff"], "inited_stream_count": ["inited_stream\u00b7counter", "inited_thread_Count", "inited_systemdcounter", "inited_stream_id", "inited_systemdsum", "inited_stream_base", "inited_stream\u00b7count", "inited_thread_base", "inited_thread_id", "inited_streamdcounter", "inited_system_count", "inited_stream_c", "inited_stream_sum", "inited_streamscount", "inited_stream_counter", "inited_systemdcount", "inited_streamdcount", "inited_thread_cache", "inited_system_sum", "inited_system_counter", "inited_streamsc", "inited_streamdsum", "inited_stream_Count", "inited_stream_cache", "inited_streamsid", "inited_stream\u00b7sum", "inited_thread_count", "inited_streamscache"]}}
{"project": "FFmpeg", "commit_id": "a0c624e299730c8c5800375c2f5f3c6c200053ff", "target": 1, "func": "int ff_v4l2_m2m_codec_reinit(V4L2m2mContext* s)\n\n{\n\n    int ret;\n\n\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"reinit context\\n\");\n\n\n\n    /* 1. streamoff */\n\n    ret = ff_v4l2_context_set_status(&s->capture, VIDIOC_STREAMOFF);\n\n    if (ret)\n\n        av_log(s->avctx, AV_LOG_ERROR, \"capture VIDIOC_STREAMOFF\\n\");\n\n\n\n    /* 2. unmap the capture buffers (v4l2 and ffmpeg):\n\n     *    we must wait for all references to be released before being allowed\n\n     *    to queue new buffers.\n\n     */\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"waiting for user to release AVBufferRefs\\n\");\n\n    if (atomic_load(&s->refcount))\n\n        while(sem_wait(&s->refsync) == -1 && errno == EINTR);\n\n\n\n    ff_v4l2_context_release(&s->capture);\n\n\n\n    /* 3. get the new capture format */\n\n    ret = ff_v4l2_context_get_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"query the new capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 4. set the capture format */\n\n    ret = ff_v4l2_context_set_format(&s->capture);\n\n    if (ret) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"setting capture format\\n\");\n\n        return ret;\n\n    }\n\n\n\n    /* 5. complete reinit */\n\n    sem_destroy(&s->refsync);\n\n    sem_init(&s->refsync, 0, 0);\n\n    s->draining = 0;\n\n    s->reinit = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 19889, "substitutes": {"s": ["ns", "ms", "spec", "ts", "sg", "session", "t", "rs", "conf", "f", "settings", "services", "options", "service", "n", "sb", "i", "g", "ss", "ls", "ops", "fs", "self", "is", "o", "cs", "l", "d", "su", "new", "args", "site", "iss", "qs", "e", "ssl", "side", "ses", "c", "ps", "si", "js", "sym", "p", "secondary", "S", "ks", "gs", "sys", "u", "h", "its", "a", "es", "states", "parts", "os", "hs", "us", "sets", "se", "sq", "ds", "sf"], "ret": ["bit", "ref", "full", "nt", "debug", "result", "job", "str", "run", "att", "feat", "reset", "id", "fit", "rev", "pat", "res", "opt", "mt", "valid", "len", "part", "bin", "pub", "fun", "rf", "arg", "art", "Ret", "bf", "key", "cat", " Ret", "gt", "RET", "pet", "ft", "code", "base", "alt", "lit", "rt", "sb", "match", "bad", "val", "re", " RET", "back", "py", "reply", "success", "data", "af", "let", "reg", "flag", "pass", "ext", "def", "rets", "lt", "en", "format", "fail", "bd", "det", "bot", "url", "error", "red", "usr"]}}
{"project": "FFmpeg", "commit_id": "e3123856c79c36507772ada1bcda6cfe36a1e297", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892, "substitutes": {"s": ["ns", "ans", "spec", "ts", "sg", "bs", "t", "rs", "aws", "f", "sv", "services", "service", "sb", "g", "sl", "ss", "src", "ls", "sec", "sim", "fs", "xs", "is", "cs", "su", "ins", "sn", "w", "bis", "qs", "sc", "ssl", "sr", "fts", "ses", "vs", "c", "si", "p", "S", "sts", "sci", "ks", "gs", "sys", "its", "es", "os", "us", "sets", "se", "sq", "sa", "ds", "sf"], "ap": ["pc", "wp", "au", "al", "sp", "pl", "ar", "ams", "ast", "am", "cp", "np", "pac", "att", "aps", "pp", "AP", "ac", "pi", "pa", "capt", "mp", "cap", "api", "pro", "tp", "arp", "attr", "amp"], "wsvqa": ["wssvcca", "wssvqa", "wordsvcca", "Wssvasa", "wsvqi", "Wsvqa", "wsVqi", "Wssvq", "wsvq", "wsvraga", "wsvasa", "wsvrq", "wsVcca", "Wssvaga", "wslvqa", "wsvcqi", "wsvcaga", "Wssvqa", "wssvq", "wssvaga", "wordsvqi", "wslvq", "Wsvasa", "wslvaga", "wordsvcqa", "wsvccca", "wordsvccca", "wordsvqa", "Wsvaga", "wslvasa", "wordsvaga", "Wsvq", "wsvrasa", "wssvasa", "wsVaga", "wsvaga", "wsVqa", "wssvqi", "wordsvcaga", "wsvcqa", "wsvrqa", "wsvcca", "wordsvcqi"], "pb": ["pc", "wp", "ab", "eb", "db", "bs", "aph", "fp", "platform", "vp", "pit", "pl", "bm", "ib", "sb", "pm", "bp", "cpp", "cb", "bc", "hub", "cp", "lp", "wb", "src", "fc", "xb", "lb", "PB", "dp", "prop", "pg", "gb", "rob", "summary", "bf", "bps", "queue", "pa", "bh", "fb", "buf", "rb", "afi", "p", "mp", "ppa", "orb", "param", "tp", "prot", "ub", "pt", "amp", "typ"], "st": ["set", "ist", "stat", "dd", "nt", "str", "ss", "ut", "ST", "store", "d", "sh", "irst", "stack", " est", "sts", "mt", "end", "pt", "sa", "est", "tt", "ts", "nd", "stim", "rest", "dest", "ste", "td", "ld", "stand", "art", "stop", "tta", "sc", "bl", "sth", "stress", "cr", "stage", "play", "St", "et", "ft", "fr", "sv", "ct", "ess", "fe", "sb", "src", "th", "sd", "sta", "l", "std", "back", "sn", "ad", "start", "sr", " St", "post", "ust", "put", "inst", "ace", "t", "sp", "ost", "sw", "sl", "ast", "lt", "cl", "cur", "kt", "storage", "se"], "header": ["offset", "user", "comment", "result", "num", "padding", "Header", "layer", "protection", "feature", "h", "carry", "input", "column", "bin", "content", "metadata", "name", "handle", "bridge", "document", "description", "summary", "title", "parent", "table", "tail", "iter", "port", "ver", "status", "code", "hash", "border", "block", "type", "match", "player", "byte", "filename", "date", "head", "page", "host", "digit", "yer", "position", "detail", "filter", "er", "frame", "version", "request", "data", "buffer", "option", "pixel", "channel", "headers", "index", "tag", "her", "cover", "event", "response", "dr", "driver", "error", "body", "message", "server", "section", "gender"], "scratch": ["encores", "ncores", " scores", "ncratch", "scores", "encratch"], "chunk_tag": ["chunk_length", "chunk_count", "chack2count", "chack_mode", "chack_tag", "chunk2length", "chack2tag", "chunk2mode", "chack_length", "chunk2tag", "chunk_mode", "chunk2count", "chack2length", "chack_count", "chack2mode"], "chunk_size": ["chunk_count", "chunks_SIZE", "chunk2weight", "chunk2size", "chunk_weight", "chunks_count", "chunk_SIZE", "chunk2count", "chunk2SIZE", "chunks_weight", "chunks_size"]}}
{"project": "FFmpeg", "commit_id": "984add64a41c3296a8a82051cc90bff2eb449609", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908, "substitutes": {"avctx": [" avtx", "devctx", "afcmp", "afcu", "ajcontext", "avecf", "avcmd", "devcf", "avpkg", "averctx", "AVcmp", "avctrl", "AVcu", "afbc", "ovcf", "abcontext", "vercf", "ovcontext", "ajpkg", "airconn", "afloc", " avcmp", "devctrl", "avectrl", "avtx", "AVctx", " avcontext", "avbc", "avcca", "avecmp", "ajcmp", "navcontext", "airctx", "avallc", "ajconn", "avlc", "aveqa", "avctl", "aveconn", "avectl", "avercontext", "ajctl", "avecu", "ajctrl", "AVtx", "afctrl", " avcf", "ovcn", "averbc", "avelc", "avalqa", "navcmd", "afcmd", " avctrl", "navctx", "afqa", "avecca", "avcmp", "afcf", "aftx", "ajcu", "vercontext", "aveloc", "ajctx", "AVpkg", "AVctl", "airctl", "navcf", "avalcca", "afcca", "avcf", "ovctx", "abloc", "avloc", "vercn", "AVcontext", "AVmc", "afmc", "avertx", "avalctx", "afpkg", "avmc", "devcontext", "avalcontext", "avectx", "ajcf", "afctl", "verctx", "avalcn", " avbc", "afcn", "aflc", "avcn", "aircontext", "afcontext", "avconn", "afctx", "abctx", "avecontext", "avecn", "afconn", "AVconn", "abconn", "avqa", "ajmc", "ajcmd", "avcu", "avcontext"], "flags2": ["Flags2", "bits1", "mask4", "args2", "args4", "bits2", "bits3", " flags1", "flags1", " flags3", "flag2", "Flags3", "Flags1", "flags4", "flag4", "flags3", "mask2"], "s": ["ns", "spec", "words", "full", "settings", "service", "ions", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "sets", "m", "sup", "ts", "sg", "rs", "aws", "times", "self", "lines", "o", "su", "v", "si", "S", "ds", "f", "r", "this", "l", "ins", "w", "features", "sync", "c", "ps", "secondary", "sys", "es", "states", "sq", "params", "sf", "session", "stats", "t", "rates", "conf", "services", "g", "ls", "ops", "ctx", "fs", "xs", "is", "site", "e", "ssl", "ses", "js", "http", "gs", "storage", "its", "os", "parts", "server"], "i": ["ti", "m", "f", "ai", "io", "ii", "iu", "slice", "I", "multi", "ip", "d", "pi", "uni", "ui", "ci", "abi", "batch", "v", "cli", "c", "ni", "si", "p", "li"], "bps1": ["bytes0", "bps0", " pins1", " bytes1", " bytes0", " pins0", "bytes1"], "high_freq": ["high_funq", "high_Freq", "high_FreQ", "high_freeg", "high_freeq", "high_Freg", "high_Frecharge", "high_hardch", "high_freQ", "high_hardq", "high_funcharge", "high_frecharge", "high_freqs", "high_freix", "high_hardQ", "high_hardix", "high_Frech", "high_Freqs", "high_condix", "high_freg", "high_Freix", "high_fung", "high_freecharge", "high_condch", "high_condq", "high_freeqs", "high_funqs", "high_frech", "high_condQ"], "bps": ["ns", " pins", "fps", "base", " fps", "sb", "bp", "cb", "ips", "ls", "pb", "bb", " bytes", "abytes", "bis", "batch", "bits", "ps", " bits", "seq", "p", "SB", "bytes", "Mbps", "eps"], "sample_rate1": ["sample_buffer6", "sample_num001", "sample_rate001", "sample_rate6", "sample_rate4", "sample_slice10", "sample_scale4", "sample_rule6", "sample_rule1", "sample_sum6", "sample_num1", "sample_scale1", "sample_slice1", "sample_time1", "sample_num10", "sampleacrate001", "sample_sum1", "sample_slice001", "sample_rate10", "sample_level1", "sampleacslice001", "sampleacslice10", "sample_rule4", "sampleacslice1", "sample_rates1", "sample_level6", "sample_scale6", "sample_level4", "sampleacrate1", "sample_buffer1", "sampleacrate10"], "coef_vlc_table": ["coef_vlc_db", "coef_vlc_count", "coef_vlc8db", "coef_vlf_count", "coef_vlc8table", "coef_vlf_type", "coef_vlf_db", "coef_vlc8type", "coef_vlf_table", "coef_vlc8count", "coef_vlc_type"], "nb_max": ["np_diff", "bb00index", "nb_rest", "nbjmax", "nb_ax", "lb_rest", "nb67rest", "bb00size", "nb_sum", "nb_scale", "nb24sum", "nb67only", "nb49warm", "nbIPMax", "nbjonly", "nb_warm", "nb_size", "lb_only", "nbjrest", "nb_diff", "nbIPrest", "bb00sum", "nb00size", "bb_index", "nb24max", "nb67count", "bb_size", "lib_max", "np_max", "lb_max", "nb49scale", "nb00index", "bb00max", "nbIPonly", "bb_max", "nb00max", "bb_sum", "lbIPMax", "nb67Max", "nb_only", "nb49max", "nb_cat", "lbIPmax", "lib_count", "nb24size", "lib_cat", "lbIPrest", "nb67cat", "lbIPonly", "nbIPmax", "nb_index", "nb_Max", "nb00sum", "nbjMax", "nb67max", "np_scale", "nb24index", "nb49diff", "nb67ax", "lib_ax", "lb_Max", "np_warm", "nb_count"], "nb": ["ns", "ab", "bin", "bi", "db", "eb", "nd", "obj", "note", "obb", "qi", "ne", "nt", "adj", "bm", "num", "sb", "bp", "cb", "kl", "lab", "bc", "ny", "nl", "quad", "wb", "pb", "abb", "bb", "nob", "zip", "count", "nm", "gb", "kb", "NB", "bf", "uni", "dy", "nu", "bis", "length", "batch", "fb", "spin", "ni", "bits", "rb", "lib", "bn", "sci", "fee", "nz", "split", "api", "nn", "np", "li", "ib", "len"]}}
{"project": "FFmpeg", "commit_id": "12dea8a5a15343e9c404376c40ca8a1cc9d1479e", "target": 1, "func": "av_cold int ff_ivi_decode_close(AVCodecContext *avctx)\n{\n    IVI45DecContext *ctx = avctx->priv_data;\n    ivi_free_buffers(&ctx->planes[0]);\n    if (ctx->mb_vlc.cust_tab.table)\n        ff_free_vlc(&ctx->mb_vlc.cust_tab);\n    av_frame_free(&ctx->p_frame);\n    return 0;\n}", "idx": 19912, "substitutes": {"avctx": ["aveloc", "avectx", "avalcontext", "cvcu", "avalloc", "AVchan", "avechan", "AVcmp", "AVcu", " avcu", "cvctx", "AVloc", "avecontext", " avcmp", "avloc", "AVctx", "AVcontext", "avcmp", " avchan", "avalctx", "avcu", "avcontext", "avchan", "avalchan", "cvchan", "cvcmp"], "ctx": ["pc", "instance", "fw", "data", "fp", "conf", "cca", "func", "vc", "ct", "conn", "component", "cci", "coe", "cm", "cf", "coll", "cb", "anc", "cp", "bc", "loc", "wcs", "fc", "ctrl", "cas", "Context", "ca", "cs", "context", "hw", "cms", "conv", "kb", "nc", "pkg", "tx", "aux", "comp", "ci", "config", "xc", "sc", "cu", "cam", "buff", "lc", "c", "qa", "cmd", "ck", "cmp", "cn", "connection", "cv", "cc", "voc"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,\n\n                              const char *default_model)\n\n{\n\n    int i, exit_status = 0;\n\n\n\n    if (!nd->model)\n\n        nd->model = strdup(default_model);\n\n\n\n    if (strcmp(nd->model, \"?\") != 0) {\n\n        for (i = 0 ; models[i]; i++)\n\n            if (strcmp(nd->model, models[i]) == 0)\n\n                return i;\n\n\n\n        fprintf(stderr, \"qemu: Unsupported NIC model: %s\\n\", nd->model);\n\n        exit_status = 1;\n\n    }\n\n\n\n    fprintf(stderr, \"qemu: Supported NIC models: \");\n\n    for (i = 0 ; models[i]; i++)\n\n        fprintf(stderr, \"%s%c\", models[i], models[i+1] ? ',' : '\\n');\n\n\n\n    exit(exit_status);\n\n}\n", "idx": 19916, "substitutes": {"nd": ["gn", "dd", "dn", "cdn", "gd", "inn", "td", "ng", "ND", "md", "nt", "ne", "pd", "inc", "ani", "hd", "vd", "ld", "ind", "dl", "wd", "nb", "sd", "ln", "ond", "d", "rd", "std", "inf", "nc", "nda", "bd", "rn", "nu", "fd", "ant", "xd", "idd", "nw", "dev", "da", "cmd", "ck", "ud", "zn", "od", "dat", "cd", "wn", "nn", "end", "dk", "und", "ds"], "models": ["classes", "bugs", "ms", "move", "m", "strings", "mod", "data", "mode", "jobs", "x", "image", "grid", "settings", "services", "media", "faces", "view", "modules", "flows", "plugins", "cm", "objects", "forms", "module", "files", "users", "gui", "mas", "cod", "items", "index", "model", "apps", "xs", "views", "links", "rooms", "agents", "cms", "cells", "args", "features", "config", "blocks", "codes", "gl", "chains", "id", "women", "ima", "xml", "Model", "ids", "projects", "names", "dem", "rules", "members", "groups", "parents", "sql", "im", "keys", "images", "custom", "params", "bug"], "default_model": ["Default_module", " default_service", "defaultusermodule", " default_models", "default_method", "Default_models", "default_models", "defaultusermethod", "default_service", "defaultuserservice", "default_module", "Default_model", "defaultusermodel", "Default_method", "defaultusermodels"], "i": ["uri", "bi", "x", "qi", "gu", "ai", "phi", "hi", "ie", "d", "pi", "id", "cli", "ni", "xi", "p", "h", "end", "it", "fi", "source", "gi", "ei", "m", "init", "j", "name", "ix", "ini", "in", "iu", "I", "count", "o", "key", "v", "si", "ri", "a", "ti", "code", "f", "r", "mi", "type", "ii", "di", "ind", "multi", "zi", "l", "val", "oi", "yi", "ci", "w", "start", "c", "b", "eni", "one", "mu", "data", "info", "io", "n", "index", "ip", "ui", "e", "api", "diff", "inner", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "8103b4d161d7c00ea3ff89ffe66bb2bc2c67de5d", "target": 0, "func": "static void virtio_s390_notify(void *opaque, uint16_t vector)\n\n{\n\n    VirtIOS390Device *dev = (VirtIOS390Device*)opaque;\n\n    uint64_t token = s390_virtio_device_vq_token(dev, vector);\n\n\n\n    /* XXX kvm dependency! */\n\n    kvm_s390_virtio_irq(s390_cpu_addr2state(0), 0, token);\n\n}\n", "idx": 19927, "substitutes": {"opaque": ["oppacle", " opque", "operacity", "Opaque", "OPhole", "oppacho", "ophole", " opacity", "operhole", "Opque", "Opacle", "opac", "opacity", " opac", " opacle", "oppaque", "Opacho", "operaque", " ophole", " opacho", "opacho", "OPaque", "OPac", "OPacity", "operac", "oppque", "opque", "opacle"], "vector": ["Vector", "creator", "reader", "token", "buffer", "vec", "io", "service", "family", "roller", "root", "normal", "pointer", "array", "zero", "queue", "buf", "v", "parent", "device", "driver", "ensor", "iterator", " token", "serial", "sequence", "server", "collection", "writer", "version"], "dev": ["grad", "Dev", "data", "info", "conf", "pub", " def", "conn", "engine", "reg", "de", "rad", "block", "auth", "app", "var", "node", "di", "def", "prom", "d", "ev", "ad", " device", "bus", "ov", "serv", "device", "driver", "proc", "dem", "iv", "DEV", "api", "serial", "priv", "valid", "env", "ve", "ver"]}}
{"project": "qemu", "commit_id": "d5851089a8a77d5c23e8d5fffb5b99265009ba62", "target": 0, "func": "static bool check_throttle_config(ThrottleConfig *cfg, Error **errp)\n\n{\n\n    if (throttle_conflicting(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (!throttle_is_valid(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    if (throttle_max_is_missing_limit(cfg, errp)) {\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 19962, "substitutes": {"cfg": ["gi", "org", "fg", "init", "sg", "gnu", "gd", "conf", "metadata", "ctr", "core", "forge", "ini", "gc", "cm", "fine", "gg", "cf", "g", "cb", "cp", "ext", "ctx", "mc", "alg", "gov", "oga", "cs", "css", "gb", "gate", "ci", "nova", "config", "ga", "cr", "cli", "lc", "nw", "c", "ea", "cmd", "gz", "fm", "cn", "gm", "cgi"], "errp": [" errP", " errfp", "erfp", " errcp", "ercp", "iterp", "err", "erpp", "errP", "errper", "errpc", "iterfp", "errorper", "iterpp", "iterP", "errorP", " errlp", "errorp", "nerfp", "erpc", "erp", "iterlp", " erp", "errr", "nerp", "errfp", " errr", "errlp", " erpc", " errper", "errorfp", "nerP", " erfp", "itercp", "nerper", " errpc", "errorlp", " errpp", "errpp", " err", "errcp"]}}
{"project": "FFmpeg", "commit_id": "101ef19ef4dc9f5c3d536aee8fcc10fff2af4d9e", "target": 1, "func": "static void decode_block(BinkAudioContext *s, short *out, int use_dct)\n\n{\n\n    int ch, i, j, k;\n\n    float q, quant[25];\n\n    int width, coeff;\n\n    GetBitContext *gb = &s->gb;\n\n\n\n    if (use_dct)\n\n        skip_bits(gb, 2);\n\n\n\n    for (ch = 0; ch < s->channels; ch++) {\n\n        FFTSample *coeffs = s->coeffs_ptr[ch];\n\n        if (s->version_b) {\n\n            coeffs[0] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n            coeffs[1] = av_int2flt(get_bits(gb, 32)) * s->root;\n\n        } else {\n\n            coeffs[0] = get_float(gb) * s->root;\n\n            coeffs[1] = get_float(gb) * s->root;\n\n        }\n\n\n\n        for (i = 0; i < s->num_bands; i++) {\n\n            /* constant is result of 0.066399999/log10(M_E) */\n\n            int value = get_bits(gb, 8);\n\n            quant[i] = expf(FFMIN(value, 95) * 0.15289164787221953823f) * s->root;\n\n        }\n\n\n\n        k = 0;\n\n        q = quant[0];\n\n\n\n        // parse coefficients\n\n        i = 2;\n\n        while (i < s->frame_len) {\n\n            if (s->version_b) {\n\n                j = i + 16;\n\n            } else if (get_bits1(gb)) {\n\n                j = i + rle_length_tab[get_bits(gb, 4)] * 8;\n\n            } else {\n\n                j = i + 8;\n\n            }\n\n\n\n            j = FFMIN(j, s->frame_len);\n\n\n\n            width = get_bits(gb, 4);\n\n            if (width == 0) {\n\n                memset(coeffs + i, 0, (j - i) * sizeof(*coeffs));\n\n                i = j;\n\n                while (s->bands[k] < i)\n\n                    q = quant[k++];\n\n            } else {\n\n                while (i < j) {\n\n                    if (s->bands[k] == i)\n\n                        q = quant[k++];\n\n                    coeff = get_bits(gb, width);\n\n                    if (coeff) {\n\n                        if (get_bits1(gb))\n\n                            coeffs[i] = -q * coeff;\n\n                        else\n\n                            coeffs[i] =  q * coeff;\n\n                    } else {\n\n                        coeffs[i] = 0.0f;\n\n                    }\n\n                    i++;\n\n                }\n\n            }\n\n        }\n\n\n\n        if (CONFIG_BINKAUDIO_DCT_DECODER && use_dct) {\n\n            coeffs[0] /= 0.5;\n\n            s->trans.dct.dct_calc(&s->trans.dct,  coeffs);\n\n            s->dsp.vector_fmul_scalar(coeffs, coeffs, s->frame_len / 2, s->frame_len);\n\n        }\n\n        else if (CONFIG_BINKAUDIO_RDFT_DECODER)\n\n            s->trans.rdft.rdft_calc(&s->trans.rdft, coeffs);\n\n    }\n\n\n\n    s->fmt_conv.float_to_int16_interleave(out, (const float **)s->coeffs_ptr,\n\n                                          s->frame_len, s->channels);\n\n\n\n    if (!s->first) {\n\n        int count = s->overlap_len * s->channels;\n\n        int shift = av_log2(count);\n\n        for (i = 0; i < count; i++) {\n\n            out[i] = (s->previous[i] * (count - i) + out[i] * i) >> shift;\n\n        }\n\n    }\n\n\n\n    memcpy(s->previous, out + s->block_size,\n\n           s->overlap_len * s->channels * sizeof(*out));\n\n\n\n    s->first = 0;\n\n}\n", "idx": 19965, "substitutes": {"s": ["ns", "spec", "full", "settings", "service", "ss", "cs", "d", "qs", "sym", "p", "ks", "h", "us", "sets", "sa", "m", "sup", "ts", "sg", "rs", "in", "sim", "self", "o", "su", "side", "sc", "v", "si", "S", "a", "hs", "ds", "native", "core", "f", "sv", "sb", "l", "features", "bis", "sync", "c", "ps", "b", "sys", "es", "states", "sq", "sf", "session", "t", "conf", "services", "n", "g", "sl", "ls", "ops", "fs", "xs", "is", "sites", "site", "e", "ssl", "ses", "js", "support", "gs", "its", "parts", "os", "se", "server", "y", "u"], "out": ["m", "bin", "obj", "err", "image", "op", "buffer", "io", "Out", "in", "raw", "o", "arr", "array", "outs", "w", "img", "png", "bl", "buff", "c", "cmd", "p", "OUT", "output", "input"], "use_dct": ["use_bdCT", "use_bdcc", "use_pcc", "use_nCT", "use_dkt", "use_Dct", "use_bdct", "use_fct", "use_fcc", "use_dcc", "use_ncc", "use_fCT", "use_fkt", "use_nont", "use_nct", "use_pont", "use_bdkt", "use_pct", "use_Dkt", "use_DCT", "use_Dcc", "use_Dont", "use_pCT", "use_dCT", "use_dont"], "ch": ["fr", "code", "och", "cht", "che", "x", "f", "cor", "core", "vc", "conf", "conn", "child", "prot", "ver", "cm", "channel", "g", "cho", "cb", "z", "cp", "mot", "ie", "th", "ctx", "CH", "ich", "count", "cy", "sk", "chi", "cs", "l", "range", "qu", "ach", "ht", "sh", "zh", "ci", "Ch", "chu", "sch", " chunk", "chrom", "batch", "v", "cur", "chan", "c", "p", "b", "col", "h", "ph", "chn", "el", "y", "chip"], "i": ["uri", "ti", "gi", "m", "bi", "init", "ik", "ji", "info", "x", "f", "ix", "ini", "qi", "ai", "mi", "n", "phi", "io", "g", "hi", "ij", "z", "ii", "in", "ie", "iu", "di", "index", "slice", "I", "mini", "multi", "zi", "vi", "ind", "o", "ip", "l", "d", "oi", "yi", "pi", "ui", "ci", "id", "e", "v", "cli", "ni", "c", "si", "ki", "ri", "p", "xi", "line", "b", "api", "it", "eni", "me", "fi", "inner", "y", "li", "ori", "u"], "j": ["jo", "jc", "m", "fr", "jl", "ji", "t", "x", "jp", "f", "uj", "ix", "qi", "r", "ne", "adj", "n", "jj", "job", "g", "je", "z", "ii", "ij", "ie", "jet", "index", "aj", "dj", "o", "l", "d", "size", "ui", "dy", "w", "J", "start", "kj", "e", "v", "c", "js", "ki", "si", "p", "b", "h", "ja", "y", "li", "u"], "k": ["m", "ik", "ky", "work", "ijk", "x", "f", "kick", "ek", "qi", "n", "uk", "g", "K", "ok", "gh", "z", "kid", "kw", "o", "sk", "l", "d", "kh", "ko", "kn", "w", "key", "e", "v", "ka", "c", "_", "ki", "p", "kg", "ck", "ku", "ks", "b", "h", "ke", "dk", "kk", "y", "u"], "q": ["m", "t", "x", "f", "ix", "qi", "r", "g", "quality", "query", "charge", "z", "Q", " l", " p", "fx", "l", "qu", "d", " Q", " qual", "iq", "ig", "w", "qs", " quality", "qt", "v", "c", "req", "qq", "qa", "p", "b", " query", "h", "end", " w", "sq", "y", "u"], "quant": ["util", "spec", "rank", "complex", "scale", "integer", "frac", "comment", "component", "qual", "mult", "pure", "wait", "quiet", "window", "charge", "query", "quad", "Q", "sim", "auc", "gap", "qu", "final", "parse", "pp", "draw", "compl", "cost", "percent", "iq", "secure", "select", "comp", "sc", "buff", "client", "cur", "req", "qq", "patch", "post", "p", "private", "pad", "total", "sum", "requ", "check", "product", "tax", "proc", "Quant", "quart", "valid", "progress", "press", "quick"], "coeff": ["coneff", "Coefficient", "coef", "koef", "Coff", " coaff", " coefficient", "canef", "koefficients", "noeff", "coaff", " coff", "coefficient", "coefficients", "coff", "Coeff", "goef", "canefficient", "koeff", " coef", "goaff", "caneff", "goeff", "Coef", "noef", "noefficient", "noff", " coefficients", "goefficient", "conefficient", "koefficient", "conaff", "canefficients", "conef"], "gb": ["pc", "band", "eb", "cfg", "gram", "db", "gnu", "GB", "gd", "bin", "gal", "gio", "gow", "usb", "gg", "bm", "cm", "gom", "sb", "g", "channel", "cb", "gin", "bp", "bc", "hub", "xy", "gui", "gru", "wb", "gam", "rg", "abb", "bb", "phy", "nb", "lb", "game", "gold", "range", "uv", "gp", "kb", "bf", "go", "ui", "mb", "gpu", "gh", "sc", "ga", "general", "gl", "bg", "rb", "wm", "bands", "binary", "gt", "hm", "b", "gz", "gs", "storage", "boot", "gy", "gm", "py", "cgi", "tm", "cv"], "coeffs": ["coeffls", "coeffici", "coeffsets", "coeffn", "coEFFn", "coefficients", "coEFFp", " coefis", "coefi", "Coffi", "coefficientsp", "coefficp", " coeffd", "coeffecte", "coefficientsets", " coeffp", "coaccs", " coefn", "coefficientssets", "coefficientsis", " coefls", "coefes", " coeffls", "coeffi", "coffn", "coefficientses", "Coffs", " coefp", "coefficientls", "Coffes", " coeffn", "coefls", "coefe", "coeffects", "coeffes", "coffp", "coeffices", "coefficiente", "Coeffes", "coefficis", " coefd", "Coeffs", " coeffsets", "coefficienti", "coefn", "coffes", "coefficientss", "coefficientsd", " coefi", "coaffs", "coefp", "coffi", "coeffectls", " coeffes", "coaffe", "coefficientes", "coefs", "coEFFs", " coefe", "coefficientsi", " coefsets", "coaccp", "coefd", "coffs", " coefes", "coeffectes", "Coeffi", " coeffe", "coefis", " coefs", "coEFFi", "coeffics", "coeffe", "Coeffp", "coeffd", "coefsets", "coeffis", "coeffp", " coeffis", "coaffes", "Coffp", "coefficientd", " coeffi"]}}
{"project": "qemu", "commit_id": "12d4536f7d911b6d87a766ad7300482ea663cea2", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "0dbb48d91e9e97c7eb11f4ebc03c4ff4b6f5b692", "target": 1, "func": "static int mpeg_mux_write_packet(AVFormatContext *ctx, int stream_index,\n\n                                 const uint8_t *buf, int size, int64_t pts)\n\n{\n\n    MpegMuxContext *s = ctx->priv_data;\n\n    AVStream *st = ctx->streams[stream_index];\n\n    StreamInfo *stream = st->priv_data;\n\n    int64_t dts;\n\n    int len;\n\n\n\n    /* XXX: system clock should be computed precisely, especially for\n\n       CBR case. The current mode gives at least something coherent */\n\n    if (stream_index == s->scr_stream_index)\n\n        s->last_scr = pts;\n\n    \n\n#if 0\n\n    printf(\"%d: pts=%0.3f scr=%0.3f\\n\", \n\n           stream_index, pts / 90000.0, s->last_scr / 90000.0);\n\n#endif\n\n    \n\n    /* XXX: currently no way to pass dts, will change soon */\n\n    dts = AV_NOPTS_VALUE;\n\n\n\n    /* we assume here that pts != AV_NOPTS_VALUE */\n\n    if (stream->start_pts == AV_NOPTS_VALUE) {\n\n        stream->start_pts = pts;\n\n        stream->start_dts = dts;\n\n    }\n\n    while (size > 0) {\n\n        len = s->packet_data_max_size - stream->buffer_ptr;\n\n        if (len > size)\n\n            len = size;\n\n        memcpy(stream->buffer + stream->buffer_ptr, buf, len);\n\n        stream->buffer_ptr += len;\n\n        buf += len;\n\n        size -= len;\n\n        while (stream->buffer_ptr >= s->packet_data_max_size) {\n\n            /* output the packet */\n\n            flush_packet(ctx, stream_index,\n\n                         stream->start_pts, stream->start_dts, s->last_scr);\n\n            /* Make sure only the FIRST pes packet for this frame has\n\n               a timestamp */\n\n            stream->start_pts = AV_NOPTS_VALUE;\n\n            stream->start_dts = AV_NOPTS_VALUE;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 19976, "substitutes": {"ctx": ["pc", "cc", "fp", "cca", "jp", "cus", "ct", "rc", "gc", "cm", "cf", "cpp", "cb", "anc", "bc", "loc", "cp", "src", "cas", "Context", "ca", "cs", "exec", "context", "hw", "cms", "conv", "kb", "pkg", "nc", "tx", "ci", "tc", "xc", "config", "sc", "cu", "cam", "client", "cli", "lc", "c", "cmd", "p", "ck", "sci", "cmp", "cn", "cv", "conn"], "stream_index": ["streamdbroute", "stream_level", "stream_name", "stream_block", "stream_slice", "streamamelist", " stream_name", "streamdbindex", "channel_Index", "stream_route", "stream_Index", " stream_Index", "channel_slice", "channel_level", " stream_range", "streamamerange", " stream_block", " stream_list", "thread_Index", "thread_index", " stream_route", "streamdbreference", "stream_ref", "thread_position", "thread_ref", "stream_reference", "stream_position", "streamameIndex", "stream_list", " stream_reference", "stream_range", "channel_index", "streamameindex"], "buf": ["ff", "data", "pool", "buffer", "rc", "vec", "feed", "cf", "cb", "block", "bc", "src", "loc", "msg", "raw", "wb", "pb", "mem", "count", "cas", "prop", "context", "val", "box", "queue", "blocks", "fd", "buff", "fb", "cur", "rb", "seq", "cmd", "uc", "b", "cap", "la", "alloc", "bytes", "port", "bag", "uf", "cv"], "size": ["izes", "term", "scale", "offset", "content", "capacity", "shape", "small", "time", "SIZE", "name", "data", "code", "mode", "rc", "n", "cm", "sized", "g", "z", "max", "loc", "function", "sec", "pos", "timeout", "min", "en", "count", "speed", "cs", "page", "empty", "fl", "new", "large", "ize", "length", "limit", "send", "sync", "lc", "c", "needed", "line", "address", " sizes", "sum", "cap", "cache", "body", "es", "bytes", "Size", "el", "grow"], "pts": ["ointments", "ointsize", "putd", "ctts", "ptd", "ctsets", "iptd", "ntd", "iptls", "PTd", "ipts", "iptts", "colts", "ctls", "ppd", "ctd", "cts", "ppls", "ptls", "ptsets", "ptsize", "putments", "ctments", "iptsets", "ointd", "PTs", "cold", "pps", "nts", "ptts", "PTsize", "cols", "ppsize", "ntsets", "iptsize", "ctsize", "PTsets", "ptments", "ntsize", "colsets", "putsize", "oints"], "s": ["ns", "ans", "spec", "session", "sg", "ts", "data", "aws", "rs", "f", "sv", "services", "service", "sb", "g", "sl", "sw", "ss", "ls", "src", "this", "fs", "xs", "sd", "self", "is", "cs", "l", "d", "su", "space", "qs", "serv", "ssl", "ses", "client", "sync", "c", "ps", "si", "sam", "sym", "p", "support", "S", "sts", "sci", "ks", "gs", "sys", "h", "es", "sign", "hs", "se", "sq", "sa", "ds", "sf"], "st": ["ts", "steam", "t", "sv", "sp", "ste", "r", "service", "str", "sb", "sw", "sl", "ss", "src", "ST", "sd", "sta", "sk", "d", "std", "stop", "sn", "start", "sc", "sth", "cl", "cr", "stage", "p", "sts", "St", "inst", "sa", "sf"], "stream": ["child", "user", "full", "thread", "file", "result", "cf", "upload", "raw", "control", "enc", "rec", "path", "stack", "config", "length", "resource", "output", "loop", "source", "reader", "input", "content", "document", "clean", "Stream", "load", "hw", "sc", "stage", "uc", "can", "row", "iv", "port", "wave", "time", "view", "window", "coll", "forward", "model", "prom", "head", "sm", "host", "ack", "sync", "post", "wrapper", "own", "progress", "draft", "steam", "record", "request", "data", "pool", "buffer", "feed", "channel", "ream", "sw", "sl", "public", "slice", "context", "header", "draw", "event", "standard", "ssl", "cl", "client", "cur", "trans", "form", "server"], "dts": ["ddcs", "sdts", "dytl", "dds", "dycs", "dttt", " dcs", "dtTS", "dtes", " dds", "dtts", " dtt", "ddtes", "dytes", "dtl", " dTS", " dtl", "dyts", "sdTS", "dtds", "sdtt", "dtt", "Dts", "ddts", "Dds", " dtes", "DTS", "ddtl", "sdds", "dTS", "dcs"], "len": ["lon", "bin", "data", "lim", "err", "f", "ix", "lit", "vec", "n", "fun", "str", "late", "coll", "sl", "z", "ls", "loc", "led", "fin", "dl", "pos", "min", "en", "zi", "count", "lt", " el", "lf", "low", "ln", "l", "val", "fl", "le", "pre", "dy", "length", " length", "il", "limit", "ler", "hl", "rev", "span", "lc", "ni", "elt", " lang", "line", "lan", "la", "body", "lin", "el", "li", "Len"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987, "substitutes": {"cpu_model": ["cpu_id", "processor_Model", "cpu__block", " cpu_Model", "cpu__model", "cpu_Model", "cpu__Model", " cpu_id", "cpu__path", "cpu_block", "processor_model", "processor_block", "cpu_path", "processor_path"], "id": ["uri", "Id", "vid", "pid", "code", "child", "info", "core", "name", "bit", "ID", "base", "ref", "rc", "rid", "proxy", "worker", "num", "i", "root", "type", "ctx", " fid", "index", "kid", "count", "head", "ip", "uid", "path", "oid", "mid", "start", "fd", "cat", "parent", "c", "seq", "url", "pad", "ids", "sid", " ID", "kill", "proc", "len", "it", "version", " pid"], "prom_addr": ["promaldata", "promalattr", "promaladdr", "prom_add", "promfaddress", "Prom_data", "Prom_attr", "prom_data", "prom_align", "promemdata", "prompaddress", "prompadd", "Prom_add", "Prom_len", "promemattr", "Prom_address", "promfalign", "prom_attr", "promemaddress", "promfaddr", "promaladdress", "Prom_addr", "prom_len", "promemaddr", "promplen", "prom_address", "promflen", "prompaddr", "Prom_align", "prompalign"], "cpu_irqs": ["cpu_pircs", "cpu_rcs", "cpu_iperqs", "cpu_arfs", "cpu_pirqs", "cpu_arq", "cpu_irfs", "cpu_pirfs", "cpu_rqu", "cpu_ircs", "cpu_pirq", "cpu_arqs", "cpu_pirks", "cpu__irqs", "cpu__irqu", "cpu__ircs", "cpu_iperq", "cpu_arks", "cpu_iperfs", "cpu_pirqu", "cpu_rq", "cpu_irks", "cpu_irqu", "cpu_rqs", "cpu_irq", "cpu__irq", "cpu_iperks"], "cs": ["pc", "ns", "spec", "s", "bs", "core", "cus", "conn", "rc", "ils", "cf", "Cs", "CS", "cp", "ss", "utils", "ls", "ctx", "fs", "cons", "cas", "sk", "ca", "css", "nc", "sc", "vs", "lc", "c", "ps", "js", "cache", "ks", "sys", "ec", "cn", "co", "cc", "ds"], "cpu": ["pc", "process", "instance", "pid", "core", "obj", "fp", "uci", "net", "px", "gc", "cm", "nic", "loader", "cpp", "cp", "node", "lp", "utils", "ctx", "colo", "python", "pb", "fc", "console", "computer", "bench", "vm", "auc", "css", "roc", "hw", "linux", " CPU", "nc", "CPU", "gpu", "config", "nu", "cu", "processor", "cli", "lc", "c", "ni", "kernel", "ync", "hp", "none", "ck", "cache", "cmp", "null", "ec", "clock", "proc", "cn", "uno", "pu", "mac", "eni", "np", "cow", "conn"], "env": ["enable", "session", "viron", "db", "cfg", "init", "global", "core", "conf", "estate", "net", "eu", "ne", "skin", "exc", "loader", "oa", "np", "shell", "gui", "environment", "ctx", "scope", "ext", "console", "en", "enc", "vm", "exec", "context", "profile", "inet", "nc", "args", "config", "ev", "e", "vs", "v", "cli", "c", "ea", "si", "stage", "kernel", "que", "cache", "ec", "proc", "ef", "priv", "et", "export", "agent", "state", "eni", "el", "Environment", "conn", "ds"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "av_cold void avcodec_register(AVCodec *codec)\n\n{\n\n    AVCodec **p;\n\n    avcodec_init();\n\n    p = &first_avcodec;\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n    *p          = codec;\n\n    codec->next = NULL;\n\n\n\n    if (codec->init_static_data)\n\n        codec->init_static_data(codec);\n\n}\n", "idx": 19998, "substitutes": {"codec": [" codcc", " codesc", " codcode", "Codeca", "Codoc", "CodEC", "capesc", " codenc", "codenc", "Coderc", "copcc", "Codef", "pedesc", "cateca", "cartesc", "copec", "codef", "capdc", "coddc", "caterc", "Codac", "codcc", "odec", "codecc", "capec", "pedcode", "cartdc", " codEC", "codeec", "catef", "Codesc", "odenc", " coddc", "codeca", "odef", " codac", "codEC", "copoc", "carterc", " codef", "codesc", "caperc", "pedec", "codeesc", "oderc", "odac", "Codcode", "catec", "odoc", "pedenc", " codoc", "coderc", "codcode", "odeca", "codoc", "odEC", "codac", " coderc", "codeoc", "cartec", "Codenc", "copesc", "Codec"], "p": ["pc", "per", "wp", "m", "point", "j", "t", "data", "fp", "x", "f", "jp", "op", "r", "pe", "n", "g", "i", "bp", "cp", "lp", "python", "ap", "pointer", "o", "ip", "po", "dp", "l", "d", "pp", "up", "pi", "pre", "e", "pa", "q", "k", "ep", "v", "parent", "c", "ps", "b", "pr", "cache", "next", "a", "api", "tp", "before", "np", "y", "P", "u"]}}
{"project": "qemu", "commit_id": "95a5befc2f8b359e72926f89cd661d063c2cf06c", "target": 1, "func": "static int read_naa_id(const uint8_t *p, uint64_t *p_wwn)\n\n{\n\n    int i;\n\n\n\n    if ((p[1] & 0xF) == 3) {\n\n        /* NAA designator type */\n\n        if (p[3] != 8) {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = ldq_be_p(p + 4);\n\n        return 0;\n\n    }\n\n\n\n    if ((p[1] & 0xF) == 8) {\n\n        /* SCSI name string designator type */\n\n        if (p[3] < 20 || memcmp(&p[4], \"naa.\", 4)) {\n\n            return -EINVAL;\n\n        }\n\n        if (p[3] > 20 && p[24] != ',') {\n\n            return -EINVAL;\n\n        }\n\n        *p_wwn = 0;\n\n        for (i = 8; i < 24; i++) {\n\n            char c = toupper(p[i]);\n\n            c -= (c >= '0' && c <= '9' ? '0' : 'A' - 10);\n\n            *p_wwn = (*p_wwn << 4) | c;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -EINVAL;\n\n}\n", "idx": 19999, "substitutes": {"p": ["pc", "part", "m", "point", "j", "s", "code", "t", "data", "x", "f", "op", "sp", "r", "pe", "n", "g", "bp", "cp", "lp", "python", "ap", "pointer", "o", "ip", "po", "l", "d", "pp", "pi", "pre", "comp", "e", "pa", "q", "k", "v", "c", "ps", "post", "patch", "pad", "b", "pr", "param", "h", "proc", "a", "api", "tp", "port", "np", "y", "P", "u"], "p_wwn": ["p_Wkn", "p_WWN", "p_Wwn", "p_wdwn", "p_www", "p_nwww", "p_awww", "p_whawn", "p_wwwn", "p_nwwn", "p_fwwan", "p_fwbl", "p_fwwn", "p_wdgn", "p_whgn", "p_wsiw", "p_wkn", "p_Wclaim", "p_wawn", "p_wwawn", "p_wwan", "p_wwwan", "p_fwgn", "p_Wwan", "p_wbl", "p_whww", "p_wswn", "p_wwgn", "p_Wiw", "p_whwd", "p_nwgn", "p_wWN", "p_whwn", "p_wgn", "p_wdclaim", "p_Wgn", "p_wwd", "p_wskn", "p_wiw", "p_wclaim", "p_awclaim", "p_nwWN", "p_wsgn", "p_wwwd", "p_wwbl", "p_awwn", "p_whWN", "p_awgn", "p_Wbl", "p_Www", "p_wdww"], "i": ["gi", "ti", "m", "bi", "j", "t", "x", "f", "base", "ini", "qi", "io", "ai", "n", "phi", "mi", "g", "hi", "type", "z", "ii", "ie", "di", "index", "iu", "I", "multi", "o", "ip", "chi", "l", "d", "oi", "pi", "ui", "ci", "e", "v", "lc", "c", "ni", "si", "ri", "xi", "b", "mu", "a", "it", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_i_picture_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int pqindex, status = 0;\n\n\n\n    /* Prolog common to all frametypes should be done in caller */\n\n    //BF = Buffer Fullness\n\n    if (v->profile <= PROFILE_MAIN && get_bits(gb, 7))\n\n    {\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"I BufferFullness not 0\\n\");\n\n    }\n\n\n\n    /* Quantizer stuff */\n\n    pqindex = get_bits(gb, 5);\n\n    if (v->quantizer_mode == QUANT_FRAME_IMPLICIT)\n\n        v->pq = pquant_table[0][pqindex];\n\n    else\n\n    {\n\n        v->pq = pquant_table[v->quantizer_mode-1][pqindex];\n\n    }\n\n    if (pqindex < 9) v->halfpq = get_bits(gb, 1);\n\n    if (v->quantizer_mode == QUANT_FRAME_EXPLICIT)\n\n        v->pquantizer = get_bits(gb, 1);\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"I frame: QP=%i (+%i/2)\\n\",\n\n           v->pq, v->halfpq);\n\n#if HAS_ADVANCED_PROFILE\n\n    if (v->profile <= PROFILE_MAIN)\n\n#endif\n\n    {\n\n        if (v->extended_mv) v->mvrange = get_prefix(gb, 0, 3);\n\n        if (v->multires) v->respic = get_bits(gb, 2);\n\n    }\n\n#if HAS_ADVANCED_PROFILE\n\n    else\n\n    {\n\n        v->s.ac_pred = get_bits(gb, 1);\n\n        if (v->postprocflag) v->postproc = get_bits(gb, 1);\n\n        /* 7.1.1.34 + 8.5.2 */\n\n        if (v->overlap && v->pq<9)\n\n        {\n\n            v->condover = get_bits(gb, 1);\n\n            if (v->condover)\n\n            {\n\n                v->condover = 2+get_bits(gb, 1);\n\n                if (v->condover == 3)\n\n                {\n\n                    status = bitplane_decoding(&v->over_flags_plane, v);\n\n                    if (status < 0) return -1;\n\n#if TRACE\n\n                    av_log(v->s.avctx, AV_LOG_DEBUG, \"Overflags plane encoding: \"\n\n                           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n                }\n\n            }\n\n        }\n\n    }\n\n#endif\n\n\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return status;\n\n}\n", "idx": 20000, "substitutes": {"v": ["m", "V", "s", "j", "t", "vr", "f", "view", "sv", "vc", "vin", "vp", "ver", "gu", "n", "g", "i", "var", "qv", "vd", "vi", "en", "lv", "vert", "o", "vm", "uv", "l", "nav", "d", "vol", "val", "conv", "av", "vim", "value", "ev", "serv", "q", "k", "vs", "ov", "rev", "e", "c", "inv", "tv", "dev", "p", "vt", "video", "volt", "b", "vv", "va", "h", "iv", "api", "nv", "ve", "cv", "version", "u"], "gb": ["pc", "eb", "cfg", "sg", "db", "vg", "bi", "gnu", "GB", "gd", "vc", "agg", "gio", "ged", "usb", "gc", "du", "gow", "bridge", "gg", "bm", "gae", "gom", "sb", "g", "gin", "cb", "gh", "hd", "bc", "hub", "gui", "gru", "cod", "ctx", "gam", "rg", "abb", "bb", "lb", "nb", "git", "phy", "game", "gp", "bo", "kb", "bf", "ko", "gpu", "mb", "ga", "bg", "rb", "lib", "gt", "ogg", "b", "gz", "mobi", "gs", "storage", "gy", "gm", "cgi", "Gb"], "pqindex": ["pqlen", "pfxnumber", "pkgpath", "pquloc", "pdqactive", "pquinfo", "prfxindex", "hqusite", " pqloc", " pqIndex", " p_index", "pqactive", " pqpath", "pqweight", "prqnumber", " pdqweight", "pqind", "pfxlen", "pquIndex", "pdqpath", "hquindex", "pqaIndex", "pqengine", "pdqweight", "pksize", " pdqindex", "pqnumber", "pkind", "pqupath", "prfxnumber", "pqsite", "pquweight", "pqqlen", " p_Index", "pqainfo", "pqlindex", "pkgweight", "pqtsize", "pqqengine", "cqind", "pqloc", "cqsize", "cdqindex", "pqulen", "cdqsize", "cdqind", "pqinfo", "cqindex", "pquindex", "pfxengine", "p_Index", "prfxlen", "pqaloc", "prqengine", "pdqind", "pdqindex", "pqsize", "hquactive", "prqindex", "pqlsite", "p_index", "hqsite", " p_loc", "pqaindex", "pqusite", " p_info", "pqlactive", " pqweight", "hqactive", " pdqpath", "prqlen", "pkindex", "pquactive", "pquengine", "pqqindex", "pqqnumber", "pqtindex", "pdqsize", "pdqsite", "pqIndex", "pfxindex", "p_info", " pqinfo", "pkgindex", "prfxengine", "pqpath", "hqindex", "pqunumber", "p_loc", "pqtind"]}}
{"project": "FFmpeg", "commit_id": "3a8c95f730732b9f1ffacdbfbf79a01b202a67af", "target": 0, "func": "static void show_stream(AVFormatContext *fmt_ctx, int stream_idx)\n\n{\n\n    AVStream *stream = fmt_ctx->streams[stream_idx];\n\n    AVCodecContext *dec_ctx;\n\n    AVCodec *dec;\n\n    char val_str[128];\n\n    AVDictionaryEntry *tag = NULL;\n\n    AVRational display_aspect_ratio;\n\n\n\n    printf(\"[STREAM]\\n\");\n\n\n\n    printf(\"index=%d\\n\", stream->index);\n\n\n\n    if ((dec_ctx = stream->codec)) {\n\n        if ((dec = dec_ctx->codec)) {\n\n            printf(\"codec_name=%s\\n\", dec->name);\n\n            printf(\"codec_long_name=%s\\n\", dec->long_name);\n\n        } else {\n\n            printf(\"codec_name=unknown\\n\");\n\n        }\n\n\n\n        printf(\"codec_type=%s\\n\", media_type_string(dec_ctx->codec_type));\n\n        printf(\"codec_time_base=%d/%d\\n\",\n\n               dec_ctx->time_base.num, dec_ctx->time_base.den);\n\n\n\n        /* print AVI/FourCC tag */\n\n        av_get_codec_tag_string(val_str, sizeof(val_str), dec_ctx->codec_tag);\n\n        printf(\"codec_tag_string=%s\\n\", val_str);\n\n        printf(\"codec_tag=0x%04x\\n\", dec_ctx->codec_tag);\n\n\n\n        switch (dec_ctx->codec_type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            printf(\"width=%d\\n\", dec_ctx->width);\n\n            printf(\"height=%d\\n\", dec_ctx->height);\n\n            printf(\"has_b_frames=%d\\n\", dec_ctx->has_b_frames);\n\n            if (dec_ctx->sample_aspect_ratio.num) {\n\n                printf(\"sample_aspect_ratio=%d:%d\\n\",\n\n                       dec_ctx->sample_aspect_ratio.num,\n\n                       dec_ctx->sample_aspect_ratio.den);\n\n                av_reduce(&display_aspect_ratio.num, &display_aspect_ratio.den,\n\n                          dec_ctx->width  * dec_ctx->sample_aspect_ratio.num,\n\n                          dec_ctx->height * dec_ctx->sample_aspect_ratio.den,\n\n                          1024*1024);\n\n                printf(\"display_aspect_ratio=%d:%d\\n\",\n\n                       display_aspect_ratio.num, display_aspect_ratio.den);\n\n            }\n\n            printf(\"pix_fmt=%s\\n\",\n\n                   dec_ctx->pix_fmt != PIX_FMT_NONE ? av_pix_fmt_descriptors[dec_ctx->pix_fmt].name\n\n                                                    : \"unknown\");\n\n            printf(\"level=%d\\n\", dec_ctx->level);\n\n            break;\n\n\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            printf(\"sample_rate=%s\\n\", value_string(val_str, sizeof(val_str),\n\n                                                    dec_ctx->sample_rate,\n\n                                                    unit_hertz_str));\n\n            printf(\"channels=%d\\n\", dec_ctx->channels);\n\n            printf(\"bits_per_sample=%d\\n\",\n\n                   av_get_bits_per_sample(dec_ctx->codec_id));\n\n            break;\n\n        }\n\n    } else {\n\n        printf(\"codec_type=unknown\\n\");\n\n    }\n\n\n\n    if (fmt_ctx->iformat->flags & AVFMT_SHOW_IDS)\n\n        printf(\"id=0x%x\\n\", stream->id);\n\n    printf(\"r_frame_rate=%d/%d\\n\",\n\n           stream->r_frame_rate.num, stream->r_frame_rate.den);\n\n    printf(\"avg_frame_rate=%d/%d\\n\",\n\n           stream->avg_frame_rate.num, stream->avg_frame_rate.den);\n\n    printf(\"time_base=%d/%d\\n\",\n\n           stream->time_base.num, stream->time_base.den);\n\n    printf(\"start_time=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->start_time, &stream->time_base));\n\n    printf(\"duration=%s\\n\",\n\n           time_value_string(val_str, sizeof(val_str),\n\n                             stream->duration, &stream->time_base));\n\n    if (stream->nb_frames)\n\n        printf(\"nb_frames=%\"PRId64\"\\n\", stream->nb_frames);\n\n\n\n    while ((tag = av_dict_get(stream->metadata, \"\", tag,\n\n                              AV_DICT_IGNORE_SUFFIX)))\n\n        printf(\"TAG:%s=%s\\n\", tag->key, tag->value);\n\n\n\n    printf(\"[/STREAM]\\n\");\n\n}\n", "idx": 20005, "substitutes": {"fmt_ctx": ["fmt_context", "fmt_loc", "fmp_loc", "fmt_lc", "fmt2ca", "fmp2hw", "fmp_hw", "fmp_context", "fmp2ctx", "fmt2hw", "fmt2lc", "fmp_ctx", "fmp_lc", "fmt2ctx", "fmp2ca", "fmp2lc", "fmt_ca", "fmp_ca", "fmt_hw"], "stream_idx": ["stream_idsx", "stream_needx", "stream_lenindex", "stream_lenx", "stream_Idx", "stream_needxes", "stream_Idxes", "stream_idsy", "stream_party", "stream_lenxes", "stream_idxs", "stream_partxes", "stream_idindex", "stream_needy", "stream_partx", "stream_partindex", "stream_idy", "stream_leny", "stream_idxes", "stream_Idindex", "stream_Idy", "stream_idsxes", "stream_needxs", "stream_idsxs"], "stream": ["draft", "time", "func", "view", "reader", "track", "image", "round", "pool", "feed", "channel", "ream", "document", "src", "model", "Stream", "object", "context", "rec", "draw", "path", "length", "wave", "unk", "client", "hook", "stage", "uc", "filter", "output", "form", "loop", "transform", "row", "sign", "valid", "writer", "source", "down", "input"], "dec_ctx": ["devalllc", "decalloc", "ec_loc", "decallcontext", "dec_cb", "decaccf", "decalctx", "decallcmp", "decacloc", "Dec_cb", "decacsrc", "del_cn", "Dec_ctx", "decalllc", "ec_cmp", "decaccu", "decjqa", "loc_cu", "delLcn", "decjcb", "decalcas", "devallloc", "decPctx", " dec_loc", "delLcus", "dec__loc", "dec_cca", "dec1cn", "decPscope", "dev_anc", "decaccas", "loc_hw", "decallcas", " dec_context", "dev_cf", "decjproc", "decjscope", "decaccontext", "ec_hw", "devallctx", "decpcontext", "ec_tx", "dec__gal", "Dec_loc", "decallsrc", "dec_cf", "dec_gal", "ec_gal", " dec_sync", "dec1ctx", " dec_ci", "dec_src", "dev_loc", "decpctx", "loc_loc", " dec_cu", "dec__canon", "decscontext", " dec_fc", "del_ctx", "decallcf", "dec_vc", "ec_sys", "devacctx", "decLanc", "dec_cu", " dec_qa", "devacanc", "decjcontext", "decLcca", "dec__ctx", "decPcb", "dec_cas", "dec1lc", "dec_anc", "dec_scope", " dec_proc", "decalsci", "decLctx", "ec_lc", " dec_sci", "decLfact", "ec_ctx", "dec1cca", "decingsync", "decLcus", " dec_cmp", "devalltx", "decjctx", "dec_canon", " dec_tx", "dec_sci", "dec_ci", "decallfc", "dec_proc", "dec1cus", "dec1loc", "decacanc", "decallanc", "dev_src", "dec_voc", "decallctx", "dec_cus", "decacfc", "decalltx", "dec_cmp", "decLcn", "dec_fc", "decPcontext", "dec_sync", "decpproc", "del_cca", "dec_lc", "delLctx", "dec_cn", "Dec_context", "decingloc", "decsctx", "dev_tx", "decLsrc", "ec_canon", " dec_voc", "dec_fact", "Dec_scope", "decpqa", " dec_cas", "decacctx", " dec_fact", "devaccf", "decingcu", "Dec_rec", "decLcontext", "dec_context", "dec_sys", "loc_ctx", " dec_vc", "dec1sys", "ec_context", "dec_qa", "decallloc", "decLloc", "dev_ctx", "delLcca", "dec_hw", "dec_conn", "dec_tx", "decallrec", "del_cus", "dec_loc", "decingctx", "dev_lc", " dec_conn", "decLcf", "devacsrc", "decsloc", "dec_rec", "decstx", "Dec_tx", "decacsync"], "val_str": ["valxlen", "val_len", "valingSTR", "str_len", "strxset", "valpStr", "str_exec", "val_STR", "val64str", "val_exec", "val_text", "str_str", " val_STR", "val24seq", "val_seq", "val64STR", "val_set", "val2text", "eval_name", " val_tr", "strxlen", "valxstr", "val_tr", "strxexec", "strxstr", "val_string", "val2Str", "valingarr", "valptext", "eval_string", "valxstring", "val24name", " val_arr", "val24exec", " val_Str", "val2arr", "val24len", "val_Str", "val64tr", "valpstr", "valingtr", "valxname", "val24str", "eval_seq", "valparr", "val64arr", "valingstr", "val_arr", " val_text", "val_name", "str_set", "valxexec", "eval_str", "val24string", "val2str", "valxset", "val24set", "valxseq"], "tag": ["mod", "code", "category", "comment", "reg", "year", "block", "match", "type", "pos", "count", "date", "Tag", "enc", "val", "format", "length", "key", "id", "ag", "TAG", "cat", "doc", "cache", "col", "row", "attr"], "display_aspect_ratio": ["display_aspect_ratios", "display_aspect_ratior", "display_aspect_radios", "display_aspect_Ratio", "display_aspect_rad0", "display_aspect_rat0", "display_aspectingbasiod", "display_aspect_tagior", "display_aspect_ratelo", "display_aspect_basatio", "display_aspect_accios", "display_aspect_tagi", "display_aspect_statlo", "display_aspect_latiod", "display_aspect_Rat0", "display_aspect_reportatio", "display_aspect_reportiod", "display_aspect_ratogram", "display_aspectingratiod", "display_aspect_acc0", "display_aspect_Rati", "display_aspect_latio", "display_aspectingratios", "display_aspect_atio", "display_aspectingbasios", "display_aspect_dimio", "display_aspect_basiod", "display_aspect_Ratios", "display_aspect_rotlo", "display_aspect_rotio", "display_aspect_rateogram", "display_aspect_dimi", "display_aspect_accio", "display_aspect_ratric", "display_aspect_ratlo", "display_aspect_ratatio", "display_aspectingbasatio", "display_aspect_dimior", "display_aspect_dimric", "display_aspect_accii", "display_aspect_radio", "display_aspect_rateios", "display_aspect_tagio", "display_aspect_dimios", "display_aspect_ratiod", "display_aspect_rati", "display_aspect_Ratial", "display_aspect_statios", "display_aspect_statogram", "display_aspect_dimial", "display_aspect_rotios", "display_aspect_ratii", "display_aspect_Ratior", "display_aspect_latios", "display_aspect_basio", "display_aspectingratio", "display_aspect_Ratric", "display_aspect_latatio", "display_aspectingbasio", "display_aspect_atial", "display_aspect_reportio", "display_aspect_reportios", "display_aspect_statio", "display_aspect_rotogram", "display_aspect_Ratii", "display_aspect_atios", "display_aspect_ratial", "display_aspect_basios", "display_aspectingratatio", "display_aspect_radii", "display_aspect_tagric", "display_aspect_rateio"]}}
{"project": "FFmpeg", "commit_id": "3e1507a9547ac09b6ff4372123cde09f19218f3d", "target": 0, "func": "static void encode_block(MpegEncContext *s, int16_t *block, int n)\n\n{\n\n    int i, j, table_id;\n\n    int component, dc, last_index, val, run;\n\n    MJpegContext *m = s->mjpeg_ctx;\n\n\n\n    /* DC coef */\n\n    component = (n <= 3 ? 0 : (n&1) + 1);\n\n    table_id = (n <= 3 ? 0 : 1);\n\n    dc = block[0]; /* overflow is impossible */\n\n    val = dc - s->last_dc[component];\n\n\n\n    ff_mjpeg_encode_coef(m, table_id, val, 0);\n\n\n\n    s->last_dc[component] = dc;\n\n\n\n    /* AC coefs */\n\n\n\n    run = 0;\n\n    last_index = s->block_last_index[n];\n\n    table_id |= 2;\n\n\n\n    for(i=1;i<=last_index;i++) {\n\n        j = s->intra_scantable.permutated[i];\n\n        val = block[j];\n\n\n\n        if (val == 0) {\n\n            run++;\n\n        } else {\n\n            while (run >= 16) {\n\n                ff_mjpeg_encode_code(m, table_id, 0xf0);\n\n                run -= 16;\n\n            }\n\n            ff_mjpeg_encode_coef(m, table_id, val, run);\n\n            run = 0;\n\n        }\n\n    }\n\n\n\n    /* output EOB only if not already 64 values */\n\n    if (last_index < 63 || run != 0)\n\n        ff_mjpeg_encode_code(m, table_id, 0);\n\n}\n", "idx": 20019, "substitutes": {"s": ["ns", "spec", "ts", "sg", "session", "t", "conf", "f", "sv", "settings", "services", "r", "service", "sb", "comm", "g", "sl", "ss", "ls", "ctx", "sim", "fs", "xs", "is", "o", "sm", "cs", "l", "su", "space", "w", "e", "ssl", "ses", "sync", "v", "c", "sam", "si", "js", "ps", "p", "S", "b", "gs", "params", "sys", "es", "os", "south", "sets", "sq", "an", "sa", "ds", "sf"], "block": ["session", "group", "work", "record", "time", "un", "view", "name", "image", "call", "comment", "buffer", "pack", "clean", "type", "match", "node", "object", "ip", "join", "load", "event", "pre", "box", "rule", "Block", "config", "blocks", "length", "id", "batch", "sync", "cl", "map", "unit", "position", "patch", "line", "cache", "lock", "check", "error", "field", "clock", "row", "number", "frame", "panel", "value"], "n": ["ns", "na", "code", "t", "x", "f", "name", "pn", "net", "nt", "r", "ne", "num", "mn", "N", "g", "nor", "z", "nl", "node", "nb", "en", "o", "l", "non", "d", " N", "nc", "common", "size", "network", "sn", "nu", "no", "k", "e", "span", "v", "c", "p", "b", "cn", "number", "a", "nn", "y", "conn", "u"], "i": ["gi", "ti", "uri", "bi", "ji", "info", "x", "f", "ix", "ini", "qi", "r", "io", "mi", "ai", "z", "ii", "ori", "ie", "iu", "index", "di", "mini", "I", "ind", "zi", "ip", "l", "d", "pi", "ui", "ci", "id", "e", "k", "v", "c", "ni", "si", "ri", "p", "xi", "b", "eni", "fi", "y", "li", "u"], "j": ["jo", "jc", "jl", "ji", "un", "jp", "f", "jit", "uj", "r", "adj", "jj", "job", "g", "je", "z", "ie", "jet", "ij", "ii", "index", "ind", "aj", "o", "exec", "l", "d", "ci", "J", "k", "e", "sync", "v", "c", "unit", "ni", "si", "js", "p", "b", "ja", "li", "u"], "table_id": ["last_name", "table__head", "tableingindex", "tableingname", " table_ids", "cache_id", "tablebookid", "machine_sid", "tableCsize", "tableappid", "table_form", " table_form", "cache_ID", "last_id", "table__id", "table_type", " tableingid", "tableCid", "tableingid", "tableCversion", "table_ids", "table_head", "tableappsid", "tablebookform", "table_ID", "table_kid", "table_version", " tableingname", "table_name", "table_source", "table_sid", "tablebookbase", " table_base", "table_index", "machine_type", "stable_id", "table_base", "cache_name", "stable_name", "tableapptype", " table_ID", " tableingkid", "table__sid", "machine_id", "tableingID", " table_kid", "last_version", "table_uri", "tableapphead", "stable_uri", "machine_head", "tableingtype", "stable_source", "table__type", "table_size", " table_ide", "cache_index", "table_ide", "tableCname", " table_type", "last_size", "tableingkid", "tablebookids", " table_name", " tableingtype"], "component": ["shape", "onents", "production", "core", " components", "name", "element", "comment", "category", "direction", "attribute", "code", "dimension", "du", "service", "duration", "channel", "module", "coll", "method", "package", "node", "function", "conference", "index", "cycle", "division", "member", "controller", "container", "host", "context", "mode", "ce", "draw", "event", "common", "uni", "rule", "comp", "com", "config", "chrom", "processor", "unit", "c", "position", "patch", "company", "Component", "cmp", "cell", "character", "quarter", "sample", "connection", "project", "compatible", "circ", "section", "card"], "dc": ["pc", "db", "cdn", "dir", "du", "center", "inc", "de", "cm", "cf", "coll", "anc", "bc", "loc", "di", "mc", "index", "fc", "dim", "design", "exec", "container", "d", "draw", "nc", "ac", "disc", "comp", "DC", "config", "dm", "id", "dr", "ga", "sc", "lc", "dom", "c", "cat", "da", "uc", "cmd", "doc", "depth", "cd", "desc", "cc", "dist"], "last_index": [" last_number", "last_position", "last__id", " lastCposition", "lastOid", "last__number", "lastWorkindex", "lastWorkid", " last__index", "one_id", " last_ind", "lastFposition", "last_id", "lastOweight", "last__search", "lastOoffset", "lastWorknumber", "max_index", "max_position", " last__search", "last__index", " last_position", "last__ind", "lastOindex", " lastCnumber", "lastCid", "lastCposition", " last__ind", "one_offset", "lastFind", " last_search", "last__position", "one_weight", "max_length", "lastCindex", "lastWorkposition", "lastFsearch", " last__position", "last_ind", "last_offset", "last_condition", "last_length", "last_number", "lastCnumber", "lastFindex", "max_condition", " last_id", "last_weight", " lastCid", "last_search", " lastCindex", "one_index"], "val": ["Val", "ret", "db", "data", "view", "al", "f", "base", "ref", "err", "fat", "x", "reg", "r", "ann", "rel", "vals", "sl", "bc", "loc", "trial", "sel", "pass", "index", "pos", "ind", "vi", "def", "ee", "VAL", "arg", "po", "exec", "vol", "slot", "d", "comp", "ol", "il", "v", "lc", "unit", "update", "seq", "dev", "p", "lib", "doc", "b", "fee", "col", "win", "eval", "live", "aval", "valid", "el", "value", "version", "len"], "run": ["work", "mod", "un", "view", "call", "runner", "running", "thread", "reg", "r", "ann", "rc", "fun", "ro", "Run", "num", "clean", "year", "type", "pass", "index", "pos", "min", "day", "exec", "rown", "read", "old", "go", "use", "ru", "con", "ride", "length", "no", "sync", "update", "man", "unit", "mix", "play", "mor", "don", "rate", "win", "route", "row", "loop", "len", "end", "UN", "ran", "order", "round"], "m": ["ms", "t", "f", "md", "M", "cm", "bm", "mi", "mn", "pm", "g", "module", "ym", "machine", "om", "em", "um", "am", "mo", "mc", "manager", "sm", "vm", "l", "d", "mr", "mos", "dm", "e", "man", "v", "c", "wm", "p", "hm", "b", "fm", "gm", "message", "im", "mac", "mm", "y"]}}
{"project": "FFmpeg", "commit_id": "6ff0ad6bfd0f00a3d54705811ee91a7ce3c22cda", "target": 0, "func": "static void RENAME(swScale)(SwsContext *c, uint8_t* srcParam[], int srcStrideParam[], int srcSliceY,\n\n             int srcSliceH, uint8_t* dstParam[], int dstStride[]){\n\n\n\n\t/* load a few things into local vars to make the code more readable? and faster */\n\n\tconst int srcW= c->srcW;\n\n\tconst int dstW= c->dstW;\n\n\tconst int dstH= c->dstH;\n\n\tconst int chrDstW= c->chrDstW;\n\n\tconst int lumXInc= c->lumXInc;\n\n\tconst int chrXInc= c->chrXInc;\n\n\tconst int dstFormat= c->dstFormat;\n\n\tconst int flags= c->flags;\n\n\tconst int canMMX2BeUsed= c->canMMX2BeUsed;\n\n\tint16_t *vLumFilterPos= c->vLumFilterPos;\n\n\tint16_t *vChrFilterPos= c->vChrFilterPos;\n\n\tint16_t *hLumFilterPos= c->hLumFilterPos;\n\n\tint16_t *hChrFilterPos= c->hChrFilterPos;\n\n\tint16_t *vLumFilter= c->vLumFilter;\n\n\tint16_t *vChrFilter= c->vChrFilter;\n\n\tint16_t *hLumFilter= c->hLumFilter;\n\n\tint16_t *hChrFilter= c->hChrFilter;\n\n\tint16_t *lumMmxFilter= c->lumMmxFilter;\n\n\tint16_t *chrMmxFilter= c->chrMmxFilter;\n\n\tconst int vLumFilterSize= c->vLumFilterSize;\n\n\tconst int vChrFilterSize= c->vChrFilterSize;\n\n\tconst int hLumFilterSize= c->hLumFilterSize;\n\n\tconst int hChrFilterSize= c->hChrFilterSize;\n\n\tint16_t **lumPixBuf= c->lumPixBuf;\n\n\tint16_t **chrPixBuf= c->chrPixBuf;\n\n\tconst int vLumBufSize= c->vLumBufSize;\n\n\tconst int vChrBufSize= c->vChrBufSize;\n\n\tuint8_t *funnyYCode= c->funnyYCode;\n\n\tuint8_t *funnyUVCode= c->funnyUVCode;\n\n\tuint8_t *formatConvBuffer= c->formatConvBuffer;\n\n\n\n\t/* vars whch will change and which we need to storw back in the context */\n\n\tint dstY= c->dstY;\n\n\tint lumBufIndex= c->lumBufIndex;\n\n\tint chrBufIndex= c->chrBufIndex;\n\n\tint lastInLumBuf= c->lastInLumBuf;\n\n\tint lastInChrBuf= c->lastInChrBuf;\n\n\tint srcStride[3];\n\n\tuint8_t *src[3];\n\n\tuint8_t *dst[3];\n\n\t\n\n\tif((c->srcFormat == IMGFMT_IYUV) || (c->srcFormat == IMGFMT_I420)){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[2];\n\n\t\tsrc[2]= srcParam[1];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[2];\n\n\t\tsrcStride[2]= srcStrideParam[1];\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_YV12){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]= srcParam[1];\n\n\t\tsrc[2]= srcParam[2];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]= srcStrideParam[1];\n\n\t\tsrcStride[2]= srcStrideParam[2];\n\n\t}\n\n\telse if(isPacked(c->srcFormat)){\n\n\t\tsrc[0]=\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= srcParam[0];\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= srcStrideParam[0]<<1;\n\n\t}\n\n\telse if(c->srcFormat==IMGFMT_Y8){\n\n\t\tsrc[0]= srcParam[0];\n\n\t\tsrc[1]=\n\n\t\tsrc[2]= NULL;\n\n\t\tsrcStride[0]= srcStrideParam[0];\n\n\t\tsrcStride[1]=\n\n\t\tsrcStride[2]= 0;\n\n\t}\n\n\n\n\tif((c->dstFormat == IMGFMT_IYUV) || (c->dstFormat == IMGFMT_I420)){\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[2];\n\n\t\tdst[2]= dstParam[1];\n\n\t\t\n\n\t}else{\n\n\t\tdst[0]= dstParam[0];\n\n\t\tdst[1]= dstParam[1];\n\n\t\tdst[2]= dstParam[2];\n\n\t}\n\n\t\n\n\n\n\tif(dstStride[0]%8 !=0 || dstStride[1]%8 !=0 || dstStride[2]%8 !=0)\n\n\t{\n\n\t\tstatic int firstTime=1; //FIXME move this into the context perhaps\n\n\t\tif(flags & SWS_PRINT_INFO && firstTime)\n\n\t\t{\n\n\t\t\tfprintf(stderr, \"SwScaler: Warning: dstStride is not aligned!\\n\"\n\n\t\t\t\t\t\"SwScaler:          ->cannot do aligned memory acesses anymore\\n\");\n\n\t\t\tfirstTime=0;\n\n\t\t}\n\n\t}\n\n\n\n\t/* Note the user might start scaling the picture in the middle so this will not get executed\n\n\t   this is not really intended but works currently, so ppl might do it */\n\n\tif(srcSliceY ==0){\n\n\t\tlumBufIndex=0;\n\n\t\tchrBufIndex=0;\n\n\t\tdstY=0;\t\n\n\t\tlastInLumBuf= -1;\n\n\t\tlastInChrBuf= -1;\n\n\t}\n\n\n\n\tfor(;dstY < dstH; dstY++){\n\n\t\tunsigned char *dest =dst[0]+dstStride[0]*dstY;\n\n\t\tunsigned char *uDest=dst[1]+dstStride[1]*(dstY>>1);\n\n\t\tunsigned char *vDest=dst[2]+dstStride[2]*(dstY>>1);\n\n\t\tconst int chrDstY= isHalfChrV(dstFormat) ? (dstY>>1) : dstY;\n\n\n\n\t\tconst int firstLumSrcY= vLumFilterPos[dstY]; //First line needed as input\n\n\t\tconst int firstChrSrcY= vChrFilterPos[chrDstY]; //First line needed as input\n\n\t\tconst int lastLumSrcY= firstLumSrcY + vLumFilterSize -1; // Last line needed as input\n\n\t\tconst int lastChrSrcY= firstChrSrcY + vChrFilterSize -1; // Last line needed as input\n\n\n\n\t\t//handle holes (FAST_BILINEAR & weird filters)\n\n\t\tif(firstLumSrcY > lastInLumBuf) lastInLumBuf= firstLumSrcY-1;\n\n\t\tif(firstChrSrcY > lastInChrBuf) lastInChrBuf= firstChrSrcY-1;\n\n//printf(\"%d %d %d\\n\", firstChrSrcY, lastInChrBuf, vChrBufSize);\n\n\t\tASSERT(firstLumSrcY >= lastInLumBuf - vLumBufSize + 1)\n\n\t\tASSERT(firstChrSrcY >= lastInChrBuf - vChrBufSize + 1)\n\n\n\n\t\t// Do we have enough lines in this slice to output the dstY line\n\n\t\tif(lastLumSrcY < srcSliceY + srcSliceH && lastChrSrcY < ((srcSliceY + srcSliceH)>>1))\n\n\t\t{\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf < lastLumSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n//\t\t\t\tprintf(\"%d %d %d %d\\n\", lumBufIndex, vLumBufSize, lastInLumBuf,  lastLumSrcY);\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n//\t\t\t\tprintf(\"%d %d\\n\", lumBufIndex, vLumBufSize);\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf < lastChrSrcY)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\t//FIXME replace parameters through context struct (some at least)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t}\n\n\t\telse // not enough lines left in this slice -> load the rest in the buffer\n\n\t\t{\n\n/*\t\tprintf(\"%d %d Last:%d %d LastInBuf:%d %d Index:%d %d Y:%d FSize: %d %d BSize: %d %d\\n\",\n\n\t\t\tfirstChrSrcY,firstLumSrcY,lastChrSrcY,lastLumSrcY,\n\n\t\t\tlastInChrBuf,lastInLumBuf,chrBufIndex,lumBufIndex,dstY,vChrFilterSize,vLumFilterSize,\n\n\t\t\tvChrBufSize, vLumBufSize);\n\n*/\n\n\t\t\t//Do horizontal scaling\n\n\t\t\twhile(lastInLumBuf+1 < srcSliceY + srcSliceH)\n\n\t\t\t{\n\n\t\t\t\tuint8_t *s= src[0]+(lastInLumBuf + 1 - srcSliceY)*srcStride[0];\n\n\t\t\t\tlumBufIndex++;\n\n\t\t\t\tASSERT(lumBufIndex < 2*vLumBufSize)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY < srcSliceH)\n\n\t\t\t\tASSERT(lastInLumBuf + 1 - srcSliceY >= 0)\n\n\t\t\t\tRENAME(hyscale)(lumPixBuf[ lumBufIndex ], dstW, s, srcW, lumXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hLumFilter, hLumFilterPos, hLumFilterSize,\n\n\t\t\t\t\t\tfunnyYCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInLumBuf++;\n\n\t\t\t}\n\n\t\t\twhile(lastInChrBuf+1 < ((srcSliceY + srcSliceH)>>1))\n\n\t\t\t{\n\n\t\t\t\tuint8_t *src1= src[1]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[1];\n\n\t\t\t\tuint8_t *src2= src[2]+(lastInChrBuf + 1 - (srcSliceY>>1))*srcStride[2];\n\n\t\t\t\tchrBufIndex++;\n\n\t\t\t\tASSERT(chrBufIndex < 2*vChrBufSize)\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) < (srcSliceH>>1))\n\n\t\t\t\tASSERT(lastInChrBuf + 1 - (srcSliceY>>1) >= 0)\n\n\t\t\t\tRENAME(hcscale)(chrPixBuf[ chrBufIndex ], chrDstW, src1, src2, (srcW+1)>>1, chrXInc,\n\n\t\t\t\t\t\tflags, canMMX2BeUsed, hChrFilter, hChrFilterPos, hChrFilterSize,\n\n\t\t\t\t\t\tfunnyUVCode, c->srcFormat, formatConvBuffer);\n\n\t\t\t\tlastInChrBuf++;\n\n\t\t\t}\n\n\t\t\t//wrap buf index around to stay inside the ring buffer\n\n\t\t\tif(lumBufIndex >= vLumBufSize ) lumBufIndex-= vLumBufSize;\n\n\t\t\tif(chrBufIndex >= vChrBufSize ) chrBufIndex-= vChrBufSize;\n\n\t\t\tbreak; //we cant output a dstY line so lets try with the next slice\n\n\t\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t\tb5Dither= dither8[dstY&1];\n\n\t\tg6Dither= dither4[dstY&1];\n\n\t\tg5Dither= dither8[dstY&1];\n\n\t\tr5Dither= dither8[(dstY+1)&1];\n\n#endif\n\n\t    if(dstY < dstH-2)\n\n\t    {\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12 like\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 1) // Unscaled YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t *lumBuf = lumPixBuf[0];\n\n\t\t\t\tint16_t *chrBuf= chrPixBuf[0];\n\n\t\t\t\tRENAME(yuv2yuv1)(lumBuf, chrBuf, dest, uDest, vDest, dstW);\n\n\t\t\t}\n\n\t\t\telse //General YV12\n\n\t\t\t{\n\n\t\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\t\t\tRENAME(yuv2yuvX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, uDest, vDest, dstW,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+(dstY>>1)*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tif(vLumFilterSize == 1 && vChrFilterSize == 2) //Unscaled RGB\n\n\t\t\t{\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb1)(*lumSrcPtr, *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse if(vLumFilterSize == 2 && vChrFilterSize == 2) //BiLinear Upscale RGB\n\n\t\t\t{\n\n\t\t\t\tint lumAlpha= vLumFilter[2*dstY+1];\n\n\t\t\t\tint chrAlpha= vChrFilter[2*dstY+1];\n\n\n\n\t\t\t\tRENAME(yuv2rgb2)(*lumSrcPtr, *(lumSrcPtr+1), *chrSrcPtr, *(chrSrcPtr+1),\n\n\t\t\t\t\t\t dest, dstW, lumAlpha, chrAlpha, dstFormat, flags);\n\n\t\t\t}\n\n\t\t\telse //General RGB\n\n\t\t\t{\n\n\t\t\t\tRENAME(yuv2rgbX)(\n\n\t\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\t\tdest, dstW, dstFormat,\n\n\t\t\t\t\tlumMmxFilter+dstY*vLumFilterSize*4, chrMmxFilter+dstY*vChrFilterSize*4);\n\n\t\t\t}\n\n\t\t}\n\n            }\n\n\t    else // hmm looks like we cant use MMX here without overwriting this arrays tail\n\n\t    {\n\n\t\tint16_t **lumSrcPtr= lumPixBuf + lumBufIndex + firstLumSrcY - lastInLumBuf + vLumBufSize;\n\n\t\tint16_t **chrSrcPtr= chrPixBuf + chrBufIndex + firstChrSrcY - lastInChrBuf + vChrBufSize;\n\n\t\tif(isPlanarYUV(dstFormat)) //YV12\n\n\t\t{\n\n\t\t\tif(dstY&1) uDest=vDest= NULL; //FIXME split functions in lumi / chromi\n\n\t\t\tyuv2yuvXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize     , lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+(dstY>>1)*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, uDest, vDest, dstW);\n\n\t\t}\n\n\t\telse\n\n\t\t{\n\n\t\t\tASSERT(lumSrcPtr + vLumFilterSize - 1 < lumPixBuf + vLumBufSize*2);\n\n\t\t\tASSERT(chrSrcPtr + vChrFilterSize - 1 < chrPixBuf + vChrBufSize*2);\n\n\t\t\tyuv2rgbXinC(\n\n\t\t\t\tvLumFilter+dstY*vLumFilterSize, lumSrcPtr, vLumFilterSize,\n\n\t\t\t\tvChrFilter+dstY*vChrFilterSize, chrSrcPtr, vChrFilterSize,\n\n\t\t\t\tdest, dstW, dstFormat);\n\n\t\t}\n\n\t    }\n\n\t}\n\n\n\n#ifdef HAVE_MMX\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n#endif\n\n\t/* store changed local vars back in the context */\n\n\tc->dstY= dstY;\n\n\tc->lumBufIndex= lumBufIndex;\n\n\tc->chrBufIndex= chrBufIndex;\n\n\tc->lastInLumBuf= lastInLumBuf;\n\n\tc->lastInChrBuf= lastInChrBuf;\n\n}\n", "idx": 20022, "substitutes": {"c": ["dc", "pc", "ic", "spec", "m", "ch", "t", "conf", "f", "vc", "ct", "rc", "center", "n", "cm", "cf", "g", "i", "coll", "cb", "cp", "bc", "ctx", "mc", "ctrl", "o", "ca", "enc", "cs", "l", "d", "rec", "cont", "ce", "nc", "ac", "ci", "com", "con", "xc", "tc", "config", "e", "cu", "sc", "k", "client", "cr", "lc", "cur", "v", "p", "uc", "cache", "col", "cit", "ec", "cn", "co", "C", "y", "cc", "u"], "srcParam": ["rcParam", "srcMem", " srcPart", "rcMem", " srcPar", " srcMem", "selMem", "srcPart", "selParam", "rcPart", "selPar", "selPart", "srcPar", "rcPar"], "srcStrideParam": ["srcStripNum", "srcRestrideParam", "srcStridePar", "srcRestridePar", "srcStriteNum", "srcStritePar", "srcStrParam", "srcRestripPar", "srcStrideNum", "srcStripPar", "srcRestrideNum", "srcStrideMin", "srcStriteMin", "srcRestripNum", "srcStrPar", "srcStrNum", "srcStripMin", "srcStriteParam", "srcRestripParam", "srcStripParam", "srcRestripMin", "srcRestrideMin", "srcStrMin"], "srcSliceY": ["srcFliceW", "srcSlueW", "srcSlangeW", "srcSlicey", "srcFliceY", "srcSluey", "srcFlueY", "srcSlueYY", "srcFlueYY", "srcFliceYY", "srcFlueW", "srcSlineY", "srcSlueY", "srcSliceYY", "srcSlangey", "srcSlineW", "srcSlineYY", "srcSlangeYY", "srcSlangeY", "srcFluey", "srcSliney", "srcFlicey", "srcSliceW"], "srcSliceH": ["srcSlaceG", "srcSlaceY", "srcSlueW", "srcSlashH", "srcPliceH", "srcPliceY", "srcPliceW", "srcSlueY", "srcSlashW", "srcSlashG", "srcSlaceW", "srcSlaceH", "srcPliceG", "srcPlaceH", "srcPlaceG", "srcSlueG", "srcPlaceY", "srcSlueH", "srcSliceG", "srcPlaceW", "srcSlashY", "srcSliceW"], "dstParam": ["DndPar", "DstParameter", "drdPar", "dstParameter", "DstMem", "dstMem", "DndParameter", "DndParam", "dndParam", "dndPar", "drdParameter", "dSTPar", "DstPar", "dSTMem", "drdMem", "DstParam", "dndParameter", "dSTParam", "dstPar", "DndMem", "drdParam", "dndMem", "dSTParameter"], "dstStride": ["dscDestructure", "dstStide", "dscStructure", "dscDestOverride", "dscStide", "dstStructure", "dscStOverride", "dscDestride", "dstStOverride", "dstSTOverride", "dstSTide", "dscStride", "dscDestide", "dststructure", "dststride", "dststOverride", "dstDestide", "dstDestructure", "dstSTride", "dststide", "dstDestOverride", "dstSTructure", "dstDestride"], "vLumFilterPos": ["vLumLimitMin", "vLUMNumberPos", "vLumControlLoc", "vLumFPos", "vLumFilterLen", "vLumFeaturePos", "vLumLimitLoc", "vLUMNumberLoc", "vLUMNumberPOS", "vLUMFilterPOS", "vLumNumberPosition", "vLUMNumberPosition", "vLumControlPos", "vLumFilterLoc", "vLumFeatureMin", "vLumFilterPosition", "vLumFLoc", "vLumLimitLen", "vLumFPosition", "vLumFeatureLen", "vLumFilterMin", "vLUMMaskLoc", "vLUMFilterLoc", "vLumControlPOS", "vLumNumberPOS", "vLumFPOS", "vLUMMaskMin", "vLumNumberLoc", "vLumFeatureLoc", "vLUMFilterMin", "vLUMFilterLen", "vLumControlPosition", "vLumLimitPos", "vLUMFilterPosition", "vLumMaskLen", "vLumFilterPOS", "vLumNumberPos", "vLUMMaskPos", "vLumMaskPos", "vLumMaskMin", "vLUMMaskLen", "vLUMFilterPos", "vLumMaskLoc"], "vChrFilterPos": ["vCharFilterDir", "vCharFilterPOS", "vChrRulePOS", "vChrFilterDir", "vChrNumberPOS", "vChrNumberPos", "vCharUserpos", "vChrFilterPOS", "vChrNumberDir", "vChrFPos", "vChruFactorRes", "vChruFactorPosition", "vChrUserDir", "vChrUserPOS", "vChruFilterPer", "vChrFilterpos", "vChrFactorPos", "vChrFPer", "vChrUserpos", "vChruFilterRes", "vCharUserPOS", "vChruFilterPosition", "vCharUserPos", "vChruFactorPos", "vChrListenerRes", "vCharFilterpos", "vChrListenerPos", "vChrFactorPer", "vChrUserPos", "vChrRulePos", "vChrFRes", "vChrFPosition", "vChrFilterPer", "vChrFactorRes", "vChrFilterRes", "vChrListenerPer", "vChruFactorPer", "vChrRulepos", "vCharUserDir", "vChrFilterPosition", "vChrFactorPosition", "vCharFilterPos", "vChrRuleDir", "vChrNumberpos", "vChrListenerPosition", "vChruFilterPos"], "hLumFilterPos": ["hLumaHeaderPosition", "hLumValueSize", "hLumControlpos", "hLumFilePos", "hLumFileTrans", "hLumValueTrans", "hLumHeaderTrans", "hLumFilepos", "hLumaHeaderPos", "hLumGrouppos", "hLumaHeaderTrans", "hLumGroupPos", "hLumGroupStart", "hLumerGroupPos", "hLumHeaderSize", "hLumaFilterSize", "hLumHeaderPosition", "hLumFileSize", "hLumerGroupPosition", "hLumFilterTrans", "hLumerFilterStart", "hLumerGrouppos", "hLumerFilterPos", "hLumaFilterPosition", "hLumerFilterpos", "hLumValuePosition", "hLumControlPos", "hLumaFilterTrans", "hLumControlPosition", "hLumaHeaderSize", "hLumFilePosition", "hLumFileStart", "hLumGroupPosition", "hLumerFilterPosition", "hLumHeaderPos", "hLumerGroupStart", "hLumControlStart", "hLumFilterStart", "hLumaFilterPos", "hLumValuePos", "hLumFilterSize", "hLumFilterpos", "hLumFilterPosition"], "hChrFilterPos": ["hChrControlPos", "hChrHandlerLoc", "hChrHandlerPos", "hChrMasterPos", "hChrSearchPo", "hChrFilterLoc", "hChrHandlerPo", "hChmLimitOff", "hChrLimitEx", "hChrFilterNeg", "hChrSearchPos", "hChrControlEx", "hChmFilterPo", "hChrLimitOff", "hChrFilterEx", "hChrbSearchLoc", "hChrSearchNeg", "hChrMasterNeg", "hChrbSearchNeg", "hChmLimitPo", "hChrbFilterNeg", "hChrLimitPo", "hChrbFilterPos", "hChrbSearchPo", "hChrbFilterLoc", "hChmLimitEx", "hChmFilterPos", "hChrbSearchPos", "hChrbFilterPo", "hChrLimitPos", "hChrFilterPo", "hChrMasterPo", "hChrMasterLoc", "hChmLimitPos", "hChrManagerEx", "hChrManagerPo", "hChrFilterOff", "hChmFilterOff", "hChrManagerOff", "hChrControlPo", "hChmFilterEx", "hChrManagerPos", "hChrSearchLoc", "hChrHandlerNeg", "hChrControlOff"], "vLumFilter": ["vPlumbLevel", "vBlumFlow", "vLumeLimit", "vLumLimit", "vLumGroup", "vLrumFlow", "vBlumbLimit", "vLumbFlow", "vLumerLevel", "vLmpFilter", "vLumbSort", "vLumeGroup", "vLumbControl", "vLumerControl", "vLrumGroup", "vBlumGroup", "vLumFlow", "vPlumFilter", "vBlumbGroup", "vLumbLevel", "vPlumbControl", "vPlumbFilter", "vLmpControl", "vLumbFilter", "vLumLevel", "vLumerSort", "vLumbLimit", "vPlumbSort", "vLumbGroup", "vLmpLevel", "vLumeFlow", "vBlumFilter", "vLumSort", "vBlumbFlow", "vLrumLimit", "vLumeFilter", "vLrumFilter", "vPlumSort", "vPlumControl", "vLmpSort", "vLumerFilter", "vBlumLimit", "vLumControl", "vBlumbFilter", "vPlumLevel"], "vChrFilter": ["vCHrLayer", "vChrFile", "vchrLimit", "vCHrFilter", "vChrbLayer", "vChlLimit", "vchrcFilter", "vCHrcLayer", "vChrtControl", "vChrtFilter", "vChrLimit", "vChrbLimit", "vChrcControl", "vChlFilter", "vChlMask", "vCHrcFile", "vChrLayer", "vChrcLimit", "vChrtLimit", "vChrbFile", "vChrMask", "vChrcLayer", "vchrFilter", "vchrcMask", "vChrControl", "vChbLayer", "vchrControl", "vCHrLimit", "vChbFilter", "vCHrcFilter", "vChrcFilter", "vCHrcLimit", "vChrcMask", "vChlControl", "vChrbFilter", "vChrtMask", "vCHrFile", "vchrcControl", "vChbLimit", "vChbFile", "vChrcFile", "vchrcLimit", "vchrMask"], "hLumFilter": ["hElumbPath", "hElumFilter", "hElumPath", "hLumRule", "hElumbFilter", "hLulRule", "hLumaControl", "hElumSort", "hLmFilter", "hLumaSort", "hLummerControl", "hLummerFilter", "hLuncFilter", "hLumbSort", "hLumFlow", "hLuncFlow", "hLuncSort", "hSlumFlow", "hSlumSort", "hLumControl", "hLumaFilter", "hSlulRule", "hLulSort", "hElumControl", "hLmFlow", "hLulFilter", "hLumbFilter", "hLumSort", "hLumaPath", "hSlulFlow", "hLmSort", "hSlulFilter", "hSlumFilter", "hSlulSort", "hLumbPath", "hLmRule", "hLuncRule", "hLummerPath", "hLumPath", "hElumbControl", "hLumbControl", "hElumbSort", "hLulFlow", "hSlumRule", "hLummerSort"], "hChrFilter": ["hChpFactor", "hChrLimit", "hColrRule", "hChrgHandler", "hChruHandler", "hCharSort", "hChmSort", "hPhrLimit", "hChrcFilter", "hColrFilter", "hChrcLimit", "hChruFilter", "hChrHandler", "hChrcSort", "hColrHandler", "hColrgFilter", "hChrFactor", "hCharFilter", "hChrgFilter", "hChrgRule", "hChruRule", "hPhrcFilter", "hPhrcFactor", "hChmLimit", "hPhrSort", "hColrgHandler", "hChrRule", "hChrgSort", "hPhrcSort", "hPhrFilter", "hPhrcLimit", "hChmFactor", "hChrSort", "hChpLimit", "hChruSort", "hColrgRule", "hColrgSort", "hChmFilter", "hPhrFactor", "hColrSort", "hCharHandler", "hChrcFactor", "hChpFilter", "hCharRule", "hChpSort"], "lumMmxFilter": ["lumMmxSort", "lumMmxConfig", "lumMpxLimit", "lumMwmMask", "lumMwmLimit", "lumMaxSort", "lumMaxConfig", "lumMxSort", "lumMxConfig", "lumRmxConfig", "lumRmxLimit", "lumMwmFilter", "lumMuxMask", "lumMxFilter", "lumMuxFilter", "lumMappingLimit", "lumRmxFilter", "lumMuxLimit", "lumMappingMask", "lumMaxLimit", "lumMpxFilter", "lumMpxConfig", "lumRmxSort", "lumMappingFilter", "lumMmxLimit", "lumMmxMask", "lumRaxConfig", "lumRaxFilter", "lumMuxFile", "lumMxLimit", "lumMappingFile", "lumMpxSort", "lumMwmFile", "lumRaxLimit", "lumMmxFile", "lumMaxFilter", "lumRaxSort"], "chrMmxFilter": ["chrMappedControl", "chrLpxFilter", "chrMmxFi", "chrMiasRule", "chrMpxFi", "chrMuxSort", "chrVmxFilter", "chrMMXLimit", "chrMuxRule", "chrMexControl", "chrMexFilter", "chrMiasSort", "chrViasFilter", "chrVmxSort", "chrLmxLimit", "chrMuxControl", "chrMMXFi", "chrVmxControl", "chrMpxFilter", "chrMappedLimit", "chrMmxControl", "chrViasSort", "chrViasRule", "chrMMXFilter", "chrLmxControl", "chrMappedFilter", "chrMuxFilter", "chrMexRule", "chrLpxLimit", "chrMpxControl", "chrMmxLimit", "chrLpxFi", "chrMmxSort", "chrViasControl", "chrMiasFilter", "chrVmxRule", "chrLpxControl", "chrLmxFi", "chrMappedFi", "chrLmxFilter", "chrMiasControl", "chrMexSort", "chrMMXControl", "chrMpxLimit", "chrMmxRule"], "lumPixBuf": ["lumPixFaf", "lumPxCuff", "lumPixBoff", "lumPixFluff", "lumPxCuf", "lumPixCiff", "lumPexAmp", "lumPixFmp", "lumPixAuf", "lumPxCoff", "lumPexBuf", "lumPxCiff", "lumPixLuff", "lumPixCuff", "lumPixLmp", "lumPexAuff", "lumPixLuf", "lumPexBuff", "lumPixBaf", "lumPexBmp", "lumPxBuf", "lumPexBaf", "lumPixFluf", "lumPixBiff", "lumPexAuf", "lumPixCoff", "lumPixLiff", "lumPixBuff", "lumPxBuff", "lumPxBoff", "lumPixLaf", "lumPixFliff", "lumPixFuff", "lumPixLoff", "lumPixAaf", "lumPixFuf", "lumPixFloff", "lumPixBmp", "lumPixAuff", "lumPixCuf", "lumPixAmp", "lumPexAaf", "lumPxBiff"], "chrPixBuf": ["chrPxAaf", "chrPxBoff", "chrPxBuff", "chrPixFaf", "chrPixFoff", "chrPixCuf", "chrPxAoff", "chrPiusBuf", "chrPiusBundle", "chrPixPuf", "chrPixBab", "chrPxAuf", "chrPixFuf", "chrPixPab", "chrPiusMump", "chrPiusMundle", "chrPixFuff", "chrPixLump", "chrPiusMab", "chrPixPump", "chrPixMump", "chrPxAuff", "chrPixBoff", "chrPixAaf", "chrPixMab", "chrPxBuf", "chrPixLab", "chrPixCaf", "chrPixAuf", "chrPixLuf", "chrPixBundle", "chrPixAoff", "chrPixBump", "chrPixBaf", "chrPixMuf", "chrPixBuff", "chrPiusMuf", "chrPixCuff", "chrPixLundle", "chrPixMundle", "chrPiusBab", "chrPiusBump", "chrPixPundle", "chrPixAuff", "chrPixCoff", "chrPxBaf"]}}
{"project": "qemu", "commit_id": "5c6c0e513600ba57c3e73b7151d3c0664438f7b5", "target": 1, "func": "static int vscsi_queue_cmd(VSCSIState *s, vscsi_req *req)\n\n{\n\n    union srp_iu *srp = &req->iu.srp;\n\n    SCSIDevice *sdev;\n\n    int n, id, lun;\n\n\n\n    vscsi_decode_id_lun(be64_to_cpu(srp->cmd.lun), &id, &lun);\n\n\n\n    /* Qemu vs. linux issue with LUNs to be sorted out ... */\n\n    sdev = (id < 8 && lun < 16) ? s->bus.devs[id] : NULL;\n\n    if (!sdev) {\n\n        dprintf(\"VSCSI: Command for id %d with no drive\\n\", id);\n\n        if (srp->cmd.cdb[0] == INQUIRY) {\n\n            vscsi_inquiry_no_target(s, req);\n\n        } else {\n\n            vscsi_makeup_sense(s, req, ILLEGAL_REQUEST, 0x24, 0x00);\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        } return 1;\n\n    }\n\n\n\n    req->sdev = sdev;\n\n    req->lun = lun;\n\n    n = sdev->info->send_command(sdev, req->qtag, srp->cmd.cdb, lun);\n\n\n\n    dprintf(\"VSCSI: Queued command tag 0x%x CMD 0x%x ID %d LUN %d ret: %d\\n\",\n\n            req->qtag, srp->cmd.cdb[0], id, lun, n);\n\n\n\n    if (n) {\n\n        /* Transfer direction must be set before preprocessing the\n\n         * descriptors\n\n         */\n\n        req->writing = (n < 1);\n\n\n\n        /* Preprocess RDMA descriptors */\n\n        vscsi_preprocess_desc(req);\n\n    }\n\n\n\n    /* Get transfer direction and initiate transfer */\n\n    if (n > 0) {\n\n        req->data_len = n;\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    } else if (n < 0) {\n\n        req->data_len = -n;\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    }\n\n    /* Don't touch req here, it may have been recycled already */\n\n\n\n    return 0;\n\n}\n", "idx": 20026, "substitutes": {"s": ["ns", "spec", "m", "ts", "session", "sg", "t", "rs", "conf", "f", "services", "r", "service", "g", "sb", "i", "ops", "fs", "self", "is", "o", "cs", "d", "e", "ssl", "q", "ses", "v", "sync", "js", "c", "ps", "sym", "p", "secondary", "S", "b", "http", "ks", "gs", "sys", "u", "es", "os", "state", "server", "states", "sq", "ds", "sf"], "req": ["require", "spec", "grab", "user", "ref", "str", "cf", "sec", "release", "exec", "rec", "comp", "tar", "pri", "config", "qt", "qq", "xml", "resource", "next", "res", "gr", "input", "rx", "j", "ctr", "hr", "dq", "query", "app", "sem", "rf", "resp", "min", "arg", "load", "mr", "dev", "ir", "off", "ec", "ra", "desc", "ver", "org", "required", "fr", "war", "quest", "err", "call", "f", "jp", "r", "rt", "ro", "worker", "cb", "rh", "ry", "need", "crit", "iq", "w", "serv", "q", "c", "qa", "Request", " request", "er", "pro", "sq", "progress", "rr", "request", "tr", "conf", "reg", "ext", "ctx", "def", "get", "low", "dr", "e", "client", "cur", "seq", "cmd", "rw", "cache", "cmp", "http", "requ", "wa", "proc"], "srp": ["vrpe", "srf", "krP", "hrf", "lerf", "trp", "krpc", "irpt", "srP", "drpr", "yrpe", "crf", "rtpe", "rtpatch", "crps", "sprc", "yrp", "srper", "rrpatch", "src", "irpr", "trpt", "vrp", "hrp", "krpe", "rrpe", "trpe", "crc", "yrpt", "sprp", "drpe", "rrpt", "irp", "sprf", "lerp", "hrper", "drpt", "yrpatch", "srps", "vrc", "lerper", "srpr", "irpe", "drpc", "vrps", "vrpc", "srpe", "rtp", "yrpc", "rrpr", "rrp", "trpi", "srpt", "srpatch", "vrpi", "lerpc", "drP", "drp", "krp", "crp", "vrf", "vrpt", "sprps", "hrpe", "srpc", "hrP", "vrper", "yrpi", "srpi", "hrpc", "rtpc", "rrpc"], "sdev": ["fdev", "tsconn", "dsdiv", "dsvalid", "esdi", "pdev", " sgu", "dsdef", " sconn", "ssval", "tsdevice", " sdebug", "nsdi", " sdi", "sdebug", "ssdiv", "physdev", "esconn", "gsvalid", "sval", "sgu", "gsdiv", "southdiv", "Sdevice", " sev", "fdiv", "setsdem", "gsdev", "cdev", "sev", "sDev", "physdevice", "Sev", "cdebug", "dsdev", "Svalid", "sDEV", " sdevice", "svalid", " sdiv", "SDev", "physDEV", "gsval", "servicesdev", "servicescomp", "srad", "psdiv", "psdem", "esdevice", "servicesrad", "sconn", "setsval", "psDev", "esdev", "nsconn", " sDev", "dsev", " srad", "cdiv", "lsdev", "dsDev", "lsdevice", "lsconn", "lsdebug", " spub", "southprof", "esdebug", "cgu", "ssdev", "southdem", "sprof", "Sdev", "csdevice", "setsdev", "servicesev", "csdev", "csconn", " svalid", "setsprof", "nsdev", "setsvalid", "ppub", "fgu", "Sdebug", "scomp", "pdevice", "fdebug", "sdef", " scomp", "spub", "sdi", "psdef", " sdef", "SDEV", "tsdebug", "setsdiv", "sdem", " sDEV", "southdev", "physdebug", "nsdevice", "ssvalid", "psdev", "tsdev", "sdevice", "psprof", "csdebug", "sdiv"], "n": ["ns", " len", "na", "not", "m", "dn", "j", "t", "un", "x", "name", "f", "pn", "net", "ng", "nt", "ne", "r", "adj", "num", "on", "N", "g", "i", "nor", "z", "nl", "max", "in", "nb", "en", "count", "nat", "o", "ln", "l", "non", "d", "nc", "no", "sn", "w", "nu", "k", "e", "v", "ni", "c", "nw", "p", "none", "b", "fn", "anon", "cn", "number", "a", "nn", "an", "y", "len"], "id": ["uri", "Id", "vid", "pid", "code", "db", "data", "info", "x", "name", "f", "ID", "bit", "ref", "du", "md", "aid", "rid", "num", "i", "type", "max", "ide", "in", "kid", "active", "head", "ip", "bid", "d", "uid", "size", "did", "oid", "ident", "length", "start", "q", "ad", "mid", "key", "dev", "seq", "p", "url", "ids", "sid", "len", "end", "it", "bug"], "lun": [" lnum", "dlunt", "kluna", " lban", "lund", "llune", "Lunt", "slund", "luno", "rlun", "fluna", "lcun", "lbUN", "elban", "llUN", "Luc", "plunt", "klnum", "flune", "len", "lon", "klun", "flun", "lcune", "luna", "rlUN", "olun", " lul", "LUN", "pluna", " lune", "dlun", "lunt", "olund", " lunt", "slun", "dlen", "lune", "llun", "lban", "plUN", "lbunt", "clune", "Lul", " len", "Lun", "sluna", "clund", "elen", "klune", "clun", "dlban", "lbuna", "Lon", "lcUN", "elun", "lcunt", "lnum", "oluno", "rluc", "dluc", "elunt", "lluc", "slune", "flnum", "slon", "Luna", " luna", " lUN", "lUN", " luc", "dlUN", "rlune", "plun", "llul", "lbun", "llunt", "sluno", "Lune", "cluno", "olune", "dlune", "lul", "luc", " lon"]}}
{"project": "qemu", "commit_id": "3e80bf9351f8fec9085c46df6da075efd5e71003", "target": 1, "func": "static int do_sendv_recvv(int sockfd, struct iovec *iov, int len, int offset,\n\n                          int do_sendv)\n\n{\n\n    int ret, diff, iovlen;\n\n    struct iovec *last_iov;\n\n\n\n    /* last_iov is inclusive, so count from one.  */\n\n    iovlen = 1;\n\n    last_iov = iov;\n\n    len += offset;\n\n\n\n    while (last_iov->iov_len < len) {\n\n        len -= last_iov->iov_len;\n\n\n\n        last_iov++;\n\n        iovlen++;\n\n    }\n\n\n\n    diff = last_iov->iov_len - len;\n\n    last_iov->iov_len -= diff;\n\n\n\n    while (iov->iov_len <= offset) {\n\n        offset -= iov->iov_len;\n\n\n\n        iov++;\n\n        iovlen--;\n\n    }\n\n\n\n    iov->iov_base = (char *) iov->iov_base + offset;\n\n    iov->iov_len -= offset;\n\n\n\n    {\n\n#if defined CONFIG_IOVEC && defined CONFIG_POSIX\n\n        struct msghdr msg;\n\n        memset(&msg, 0, sizeof(msg));\n\n        msg.msg_iov = iov;\n\n        msg.msg_iovlen = iovlen;\n\n\n\n        do {\n\n            if (do_sendv) {\n\n                ret = sendmsg(sockfd, &msg, 0);\n\n            } else {\n\n                ret = recvmsg(sockfd, &msg, 0);\n\n            }\n\n        } while (ret == -1 && errno == EINTR);\n\n#else\n\n        struct iovec *p = iov;\n\n        ret = 0;\n\n        while (iovlen > 0) {\n\n            int rc;\n\n            if (do_sendv) {\n\n                rc = send(sockfd, p->iov_base, p->iov_len, 0);\n\n            } else {\n\n                rc = qemu_recv(sockfd, p->iov_base, p->iov_len, 0);\n\n            }\n\n            if (rc == -1) {\n\n                if (errno == EINTR) {\n\n                    continue;\n\n                }\n\n                if (ret == 0) {\n\n                    ret = -1;\n\n                }\n\n                break;\n\n            }\n\n            if (rc == 0) {\n\n                break;\n\n            }\n\n            ret += rc;\n\n            iovlen--, p++;\n\n        }\n\n#endif\n\n    }\n\n\n\n    /* Undo the changes above */\n\n    iov->iov_base = (char *) iov->iov_base - offset;\n\n    iov->iov_len += offset;\n\n    last_iov->iov_len += diff;\n\n    return ret;\n\n}\n", "idx": 20032, "substitutes": {"sockfd": ["svchandle", "opensighdc", "sckfun", "opensighfd", "sighfat", "sesockfd", "sOCKfd", "splayfd", "fslockfa", "sockshandle", "sesockshandle", "fsockfd", " sockfile", "sockfx", "opensockfat", "sockfat", "sessfat", "sockstream", "slockfd", "sinkflo", "sockfa", " socksfd", "socksFD", " socksfile", "sessfd", "socksfile", "opensockdc", "sockfile", "sOCKflo", "sessstream", "slockfa", "splaydc", " socksfeed", "svcFD", "fsockflo", " socksfat", "sesocksfun", "slockflo", " sockfat", "sighfx", "svcfd", "fslockfun", "fslockflo", "fsockfun", "sinkfa", "socksfun", "socksfd", "sessfeed", "sportstream", "fsockfa", "socksfeed", "socksfat", "opensockfd", "sockFD", "sesockfun", "sighdc", "sckFD", "sesocksFD", "sportfeed", "sipfat", "splayfat", "sessfile", "sinkfun", "sinkfd", "slockdc", "opensighfx", "sipfeed", "fslockfd", "sockfeed", "sOCKfa", "slockfx", "opensighfat", "sockfun", "sipfile", "sockflo", "sipstream", "sesockFD", "sckfd", "sipfd", "sesocksfd", "sOCKfun", "sportfat", "sportfd", " sockfeed", "sesockhandle", "slockfat", "sockdc", "splayfx", "slockfun", "svcfun", "sckhandle", "opensockfx", "sighfd", "sockhandle"], "iov": ["oc", "mn", "gru", "hub", "colo", "mus", "iol", "mom", "drm", "uu", "uni", "chrom", "ov", "fm", "mpeg", "yo", "photo", "wav", "icho", "obo", "iam", "\u00ef", "nov", "rf", "hw", "liv", "imedia", "soc", "anova", "ir", "kov", "norm", "anon", "iv", "wikipedia", "voice", "ilo", "iro", "vg", "club", "micro", "respond", "omnia", "anim", "mun", "loc", "iop", "four", "inet", "iq", "oir", "vre", "mx", "oji", "rss", "rolet", "oren", "uno", "oyer", "gener", "lore", "voc", "mu", "gmail", "orman", "inn", "io", "syn", "ij", "pai", "username", "nox", "conv", "userc", "mos", "iris", "lov", "ibl", "ilan", "ilib", "music", "software", "dyl", "yout"], "len": ["lon", "part", "lim", "lif", "base", "f", "alt", "net", "vec", "ann", "fun", "syn", "n", "lu", "num", "coll", "loc", "lp", "fin", "dl", "pos", "min", "en", "lt", "count", "low", "lf", "ln", "l", "non", "val", "fl", "size", "pre", "le", "ol", "length", "il", "limit", "den", "lc", "unit", "seq", "ll", "line", "lib", "lan", "split", "lin", "el", "li", "Len"], "offset": ["set", "ref", "align", "num", "padding", "pos", "range", "location", "layer", "initial", "reset", "length", "prefix", "area", "aff", "end", "lon", "part", "ff", "Offset", "phase", "online", "o", "size", "ol", "off", "shift", "null", "et", "fp", "base", "alt", "loc", "bound", "l", "start", "delay", "fee", "split", "enabled", "origin", "addr", "alpha", "af", "info", "i", "index", "ip", "lf", "low", "format", "adjust", "disabled", "limit", "seq", "cmp", "col", "error", "attr", "dist"], "do_sendv": ["do_useiv", "do_endf", "do_sendp", "do_sentiv", "do_sendb", "do__setvs", "do_reciv", "do_recu", "do_enu", "do_enp", "do_endb", "do_sentv", "do__sendf", "do_recv", "do_recev", "do_sendvs", "do_sentu", "do_sentp", "do_sendu", "do_sendiv", "do_env", "do_recp", "do__setv", "do_useb", "do_setvs", "do__sendb", "do_endvs", "do_recb", "do_setf", "do__sendv", "do_sentvs", "do_sentf", "do_endv", "do_sendev", "do_recf", "do_usev", "do_setv", "do_sentb", "do_sendf", "do_useev", "do__setf", "do_enf", "do_setb", "do__sendvs", "do_sentev", "do__setb"], "ret": ["status", "rr", "code", "data", "err", "ref", "f", "alt", "reg", "nt", "r", "fun", "rt", "lit", "result", "num", "rel", "fi", "cb", "match", "bc", "fin", "mem", "rf", "resp", "rets", "count", "lt", "def", "get", "art", "att", "arg", "val", "re", "Ret", "bf", "back", "rot", "id", "det", "bot", "rev", "cur", "cat", "req", "success", "rl", "post", "repl", "gt", "RET", "gen", "pat", "error", "rep", "res", "opt", "pet", "mt", "iter", "valid", "ft", "reply", "pt", "ver"], "diff": ["part", "extra", "ff", "frac", "info", "conf", "err", "ref", "dir", "alt", "comment", "eff", "f", "fe", "fun", "rel", "result", "done", "pos", "def", " difference", "low", "lf", "range", "iff", "d", "change", "found", "Diff", "fail", "add", "different", "length", "changed", "comp", "rev", "update", "lc", "req", "unit", "dev", "qa", "del", "none", "missing", "cmp", "col", "error", "field", "split", "progress", "version", "dist"], "iovlen": ["loven", "iovlength", "novlen", "iovlan", "muslen", "chromlc", "chromlin", "orenlan", "voiceln", "ilolc", "lovline", "musln", "iovfat", "ovcount", "orenline", "iovlc", "iovbase", "orenen", "mulen", "voicebase", "oven", "ioven", "iovlin", "liven", "roletlen", "wavlen", "livln", "chromen", "iliblc", "orenlen", "ilolen", "ilodata", "chromln", "muelt", "drmlength", "drmden", "iovden", "ilibfat", "wavden", "ilolin", "mudata", "chromlen", "musicln", "ilolan", "roletlin", "iovcount", "wavlength", "lovlen", "livlen", "roletlan", "iovdata", "ovln", "drmlen", "chromlimit", "iovelt", "ilolim", "novlan", "chromfat", "voicelen", "musiclen", "novline", "lovlan", "voiceen", "iovline", "livbase", "chromcount", "ilolimit", "mulim", "musbase", "lovcount", "iovlim", "lovln", "iloln", "ilofat", "iovln", "musiclength", "wavln", "roletlimit", "noven", "iliblen", "iloelt", "musicden", "ilibln", "musen", "ovlen", "drmln", "chromlan", "iovlimit"], "last_iov": ["lastPiop", "lastWilib", "lastPiov", " last_iro", "last__iro", "last__ilo", "last_ilib", " last_imedia", " last_mus", "lastWiop", "lastJilo", "last_voice", "lastWkov", "last_iol", "last_nox", "last_soc", "lastPkov", " last_nikov", " last_voice", " last_ilib", "lastJsoc", "last_rolet", "last_nikov", " last_kov", "lastJrolet", " last_iol", " last_iop", "lastWiov", " last_nox", "last__iop", " last_rolet", "last_iop", "lastPilib", "last_ilo", "last_imedia", "last__iov", "last_iro", "last_kov", " last_soc", "lastJiov", " last_ilo", "last_mus"], "msg": ["stat", "cfg", "op", "debug", "bm", "pack", "num", "mn", "comm", "hub", "mom", "enc", "mid", "send", "mp", "gen", "mt", "input", "ms", "m", "init", "sg", "pub", "cm", "ge", "sim", "resp", "arg", "v", "gm", "wave", "gram", "og", "text", "block", "node", "loc", "mem", "game", "mit", "go", "dm", "buf", "ag", "Msg", "doc", "sent", "mor", "live", "mail", "reply", "mu", "db", "data", "info", "ages", "g", "module", "mess", "mon", "def", "irm", "pkg", "dr", "client", "req", "seq", "cmd", "gs", "message", "mo"], "p": ["pc", "per", "wp", "part", "m", "prov", "j", "t", "fp", "f", "jp", "ref", "op", "pn", "r", "pe", "n", "pl", "g", "bp", "i", "cp", "lp", "pb", "ap", "pos", "pai", "po", "ip", "pg", "l", "att", "gp", "re", "pp", "up", "pkg", "pi", "pre", "comp", "pse", "e", "pa", "par", "parent", "c", "ps", "post", "hp", "b", "pr", "pat", "param", "h", "proc", "api", "pro", "tp", "py", "port", "it", "np", "pt", "P", "u"], "rc": ["pc", "dc", "rx", "ror", "rr", "code", "wx", "irc", "err", "cor", "RC", "r", "reg", "rt", "inc", "result", "num", "ok", "cb", "bc", "src", "rh", "loc", "fc", "rg", "bb", "abc", "ry", "auc", "ack", "roc", "rec", "nc", "ac", "ru", "back", "hl", "rn", "sr", "sc", "cr", "rev", "cur", "lc", "c", "rb", "rl", "uc", "ck", "cmp", "error", "co", "reply", "cc", "bug"]}}
{"project": "FFmpeg", "commit_id": "55d7371fe0c44c025eb0e75215e0685870f31874", "target": 1, "func": "static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n\n                            int *got_frame, AVPacket *pkt)\n\n{\n\n    const uint8_t *data = pkt->data;\n\n    int size = pkt->size;\n\n    VP9Context *s = ctx->priv_data;\n\n    int res, tile_row, tile_col, i, ref, row, col;\n\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n\n    ptrdiff_t yoff, uvoff, ls_y, ls_uv;\n\n    AVFrame *f;\n\n    int bytesperpixel;\n\n\n\n    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {\n\n        return res;\n\n    } else if (res == 0) {\n\n        if (!s->s.refs[ref].f->buf[0]) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n\n            return res;\n\n        ((AVFrame *)frame)->pts = pkt->pts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        ((AVFrame *)frame)->pkt_pts = pkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n        ((AVFrame *)frame)->pkt_dts = pkt->dts;\n\n        for (i = 0; i < 8; i++) {\n\n            if (s->next_refs[i].f->buf[0])\n\n                ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n            if (s->s.refs[i].f->buf[0] &&\n\n                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)\n\n                return res;\n\n        }\n\n        *got_frame = 1;\n\n        return pkt->size;\n\n    }\n\n    data += res;\n\n    size -= res;\n\n\n\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {\n\n        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])\n\n            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)\n\n            return res;\n\n    }\n\n    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);\n\n    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    if (s->s.frames[CUR_FRAME].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);\n\n    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    f = s->s.frames[CUR_FRAME].tf.f;\n\n    f->key_frame = s->s.h.keyframe;\n\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    ls_y = f->linesize[0];\n\n    ls_uv =f->linesize[1];\n\n\n\n    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&\n\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n    }\n\n\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->next_refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        if (s->s.h.refreshrefmask & (1 << i)) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);\n\n        } else if (s->s.refs[i].f->buf[0]) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);\n\n        }\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (ctx->hwaccel) {\n\n        res = ctx->hwaccel->start_frame(ctx, NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->end_frame(ctx);\n\n        if (res < 0)\n\n            return res;\n\n        goto finish;\n\n    }\n\n\n\n    // main tile decode loop\n\n    bytesperpixel = s->bytesperpixel;\n\n    memset(s->above_partition_ctx, 0, s->cols);\n\n    memset(s->above_skip_ctx, 0, s->cols);\n\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n\n    } else {\n\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n\n    }\n\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_segpred_ctx, 0, s->cols);\n\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n\n        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n\n    if ((res = update_block_buffers(ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Failed to allocate block buffers\\n\");\n\n        return res;\n\n    }\n\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n\n        int j, k, l, m;\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            for (j = 0; j < 2; j++)\n\n                for (k = 0; k < 2; k++)\n\n                    for (l = 0; l < 6; l++)\n\n                        for (m = 0; m < 6; m++)\n\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n\n                                   s->prob.coef[i][j][k][l][m], 3);\n\n            if (s->s.h.txfmmode == i)\n\n                break;\n\n        }\n\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n\n        ff_thread_finish_setup(ctx);\n\n    } else if (!s->s.h.refreshctx) {\n\n        ff_thread_finish_setup(ctx);\n\n    }\n\n\n\n    do {\n\n        yoff = uvoff = 0;\n\n        s->b = s->b_base;\n\n        s->block = s->block_base;\n\n        s->uvblock[0] = s->uvblock_base[0];\n\n        s->uvblock[1] = s->uvblock_base[1];\n\n        s->eob = s->eob_base;\n\n        s->uveob[0] = s->uveob_base[0];\n\n        s->uveob[1] = s->uveob_base[1];\n\n\n\n        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n\n            set_tile_offset(&s->tile_row_start, &s->tile_row_end,\n\n                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);\n\n            if (s->pass != 2) {\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    int64_t tile_size;\n\n\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n\n                        tile_size = size;\n\n                    } else {\n\n                        tile_size = AV_RB32(data);\n\n                        data += 4;\n\n                        size -= 4;\n\n                    }\n\n                    if (tile_size > size) {\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n\n                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    data += tile_size;\n\n                    size -= tile_size;\n\n                }\n\n            }\n\n\n\n            for (row = s->tile_row_start; row < s->tile_row_end;\n\n                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n\n                struct VP9Filter *lflvl_ptr = s->lflvl;\n\n                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;\n\n\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,\n\n                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);\n\n\n\n                    if (s->pass != 2) {\n\n                        memset(s->left_partition_ctx, 0, 8);\n\n                        memset(s->left_skip_ctx, 0, 8);\n\n                        if (s->s.h.keyframe || s->s.h.intraonly) {\n\n                            memset(s->left_mode_ctx, DC_PRED, 16);\n\n                        } else {\n\n                            memset(s->left_mode_ctx, NEARESTMV, 8);\n\n                        }\n\n                        memset(s->left_y_nnz_ctx, 0, 16);\n\n                        memset(s->left_uv_nnz_ctx, 0, 32);\n\n                        memset(s->left_segpred_ctx, 0, 8);\n\n\n\n                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n\n                    }\n\n\n\n                    for (col = s->tile_col_start;\n\n                         col < s->tile_col_end;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        // FIXME integrate with lf code (i.e. zero after each\n\n                        // use, similar to invtxfm coefficients, or similar)\n\n                        if (s->pass != 1) {\n\n                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n\n                        }\n\n\n\n                        if (s->pass == 2) {\n\n                            decode_sb_mem(ctx, row, col, lflvl_ptr,\n\n                                          yoff2, uvoff2, BL_64X64);\n\n                        } else {\n\n                            decode_sb(ctx, row, col, lflvl_ptr,\n\n                                      yoff2, uvoff2, BL_64X64);\n\n                        }\n\n                    }\n\n                    if (s->pass != 2) {\n\n                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n\n                    }\n\n                }\n\n\n\n                if (s->pass == 1) {\n\n                    continue;\n\n                }\n\n\n\n                // backup pre-loopfilter reconstruction data for intra\n\n                // prediction of next row of sb64s\n\n                if (row + 8 < s->rows) {\n\n                    memcpy(s->intra_pred_data[0],\n\n                           f->data[0] + yoff + 63 * ls_y,\n\n                           8 * s->cols * bytesperpixel);\n\n                    memcpy(s->intra_pred_data[1],\n\n                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                    memcpy(s->intra_pred_data[2],\n\n                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                }\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n", "idx": 20035, "substitutes": {"ctx": ["pc", "cc", "cfg", "cca", "jp", "component", "rc", "gc", "cm", "cf", "window", "cpp", "cb", "anc", "cp", "loc", "bc", "wcs", "mc", "scope", "kw", "cas", "Context", "ca", "cs", "context", "hw", "linux", "cms", "conv", "kb", "pkg", "nc", "tx", "ci", "config", "xc", "sc", "cu", "cam", "sync", "cli", "lc", "c", "client", "cl", "cmd", "kt", "ck", "sci", "ks", "cmp", "connection", "mac", "sq", "cv", "conn", "ds"], "frame": ["part", "point", "fr", "code", "time", "view", "element", "image", "call", "buffer", "fe", "file", "fi", "cf", "window", "document", "iframe", "block", "node", "function", "fc", "slice", "za", "game", "object", "ze", "setup", "range", "d", "draw", "ce", "feat", "dy", "flow", "pse", "hole", "e", "fb", "frames", "dom", "c", "position", "kt", "p", "video", "b", "feature", "rame", "body", "flower", "ace", "fram", "figure", "state", "framework", "Frame"], "got_frame": ["get\n", "got2data", "got_data", "gotjframes", "got2fram", "got\n", "gotjdata", "get_frames", "got_frames", " got\n", "gotbuffer", "got_fram", "get_data", "gotjfram", "get_fram", "got2frames", "seen\n", " gotbuffer", "seenbuffer", "get_frame", "getbuffer", "gotjframe", "got2frame"], "pkt": ["fnt", "pnt", "Piece", "Pki", "bwk", "spkg", "tacket", "fkt", "Pet", "biece", "beth", "bkt", "Packet", "cpct", "tkt", "tki", "pKT", "cpKT", " pct", "packet", " pet", "spkt", "spacket", " piece", " packet", "spki", "pwk", " pnt", "Pwk", "bet", "PKT", " pki", "Pkg", "pkg", "piece", "facket", "backet", " pwk", "cpkt", "fct", " peth", "pct", "Peth", "peth", "bnt", "Pkt", "Pct", " pkg", "pki", "pet", "cpacket", "bct", " pKT", "tet"], "data": ["board", "Data", "dd", "content", "record", "info", "reader", "sample", "image", "base", "media", "buffer", "results", "feed", "result", "window", "module", "block", "raw", "slice", "object", "load", "d", "empty", "rec", "val", "draw", "size", "memory", "length", "start", "queue", "response", "buff", "buf", "batch", "e", "device", "da", "p", "binary", "cache", "ata", "dat", "next", "body", "len", "bytes", "DATA", "connection", "message", "a", "input"], "s": ["ns", "spec", "settings", "service", "comm", "ss", "cs", "d", "sh", "path", "qs", "sym", "p", "ks", "h", "us", "sets", "sup", "ts", "sg", "rs", "self", "o", "sk", "su", "ssh", "tests", "sc", "v", "si", "S", "a", "hs", "ds", "bs", "r", "sb", "auth", "utils", "this", "ins", "w", "bis", "vs", "sync", "c", "ps", "secondary", "b", "sys", "es", "states", "sq", "session", "t", "info", "conf", "services", "n", "g", "sl", "z", "ls", "ops", "fs", "xs", "is", "context", "args", "site", "e", "ssl", "ses", "js", "hm", "http", "gs", "os", "parts", "y", "u"], "res": ["ms", "values", "ros", "ret", "bs", "rates", "rs", "rest", "err", "obj", "ras", "fields", "reg", "results", "rc", "vec", "details", "vals", "result", "rel", "reed", "has", "nos", "rh", "resolution", "Res", "msg", "des", "RES", "resp", "def", "arr", "changes", "cs", "ris", "sol", "css", "val", "re", "ress", "breaks", "resh", " results", "mr", "args", "reset", "features", "response", "rev", "js", "req", "ps", "rus", "rss", "cache", "ids", "rep", "errors", "os", "pres", "rem", "gr", "runs", "ver"], "tile_row": ["tile_loc", "tile32col", "tile_rows", " tile32rows", " tile_rows", "tile32row", "tile32rows", " tile32col", " tile32loc", " tile_loc", "tile32loc", " tile32row"], "tile_col": ["tile_loc", "ls2pos", "ls2col", "ls_pos", "ls2column", "ls_col", "tile2column", "tile_pos", "tile2col", "tile_column", "ls_column", "tile1col", "tile2loc", "tile1pos", "ls_loc", "tile1loc", "tile1column", "tile2pos", "ls2loc"], "i": ["uri", "bi", "ji", "x", "jit", "full", "qi", "ai", "phi", "hi", "reference", "ie", "ori", "pos", "range", "d", "pi", "id", "ni", "p", "xi", "it", "fi", "gi", "part", "init", "ix", "ini", "in", "iu", "I", "o", "key", "v", "ki", "si", "ri", "field", "iv", "a", "ti", "r", "mi", "block", "type", "ii", "di", "multi", "zi", "oi", "yi", "ci", "start", "q", "c", "b", "eni", "mu", "info", "io", "g", "index", "slice", "ip", "ui", "e", "my", "inner", "y", "li", "u"], "ref": ["href", "ab", "part", "fr", "br", "offset", "conf", " Ref", "obj", "base", "alt", "buffer", "ob", "reg", "reb", "Ref", "rc", "r", "rel", "loc", "reference", "index", "pos", "rf", "def", "resp", "count", "pointer", "lf", "range", "label", "rec", "val", "re", "inf", "diff", "bf", "pre", "rib", "img", "id", "remote", "cl", "rev", "req", "c", "p", "url", "cache", "b", "rep", "ef", "aff", " reference", "el", "REF", "len"], "row": ["entry", "mod", "rc", "r", "feed", "family", "ro", "rel", "num", "block", "coll", "src", "raw", "index", "pos", "Row", "ry", "range", "pg", "w", "key", "rows", "rw", "port", "ver"], "col": ["part", "COL", "offset", "ch", "Col", "rel", "num", "coll", "cp", "loc", "index", "pos", "count", "val", "fl", "column", "cl", "cat", "c", "temp", "seq", "p", "cell", "el", "len"], "yoff": ["zoffset", "noff", "xoff", "zoff", "xoffs", "noffset", "zoffs", "yoffset", "xoffset", "noffs", "yoffs"], "uvoff": ["uzw", "cvoff", "svoffs", "uvoffs", "cvw", "svw", "uvw", "svoff", "uzoff", "uzoffs", "cvoffs"], "ls_y": ["vs_ii", "ls_ii", "ls_vy", "vs_y", "vs_vy", "ls_py", "vs_py"], "ls_uv": ["vs_vr", "ls_cv", "ls_v", "vs_cv", "ls_vr", "vs_uv", "vs_v"], "f": ["fr", "fw", "ff", "t", "fp", "info", "full", "of", "fe", "r", "elf", "fa", "cf", "g", "z", "fc", "fs", "rf", "fen", "o", "lf", "fo", "fx", "d", "df", "inf", "w", "fd", "e", "q", "fb", "v", "c", "F", "p", "b", "fm", "fn", "form", "h", "uf", "sf"], "bytesperpixel": ["bytesbypixel", "bytesbycpu", "bytesbyrow", "bitsPerbyte", "bitsperpixel", "bytesPERbyte", "bitsperbyte", "bytesbybyte", "bytesperbyte", "bitsperrow", "bytesPERcpu", "bitsPerpixel", "bitsPercpu", "bytesPERpixel", "bytesPerbyte", "bitspercpu", "bytesPERrow", "bitsPerrow", "bytesPerrow", "bytesPercpu", "bytesperrow", "bytespercpu", "bytesPerpixel"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t gt64120_readl (void *opaque,\n\n                               target_phys_addr_t addr, unsigned size)\n\n{\n\n    GT64120State *s = opaque;\n\n    PCIHostState *phb = PCI_HOST_BRIDGE(s);\n\n    uint32_t val;\n\n    uint32_t saddr;\n\n\n\n    saddr = (addr & 0xfff) >> 2;\n\n    switch (saddr) {\n\n\n\n    /* CPU Configuration */\n\n    case GT_MULTI:\n\n        /* Only one GT64xxx is present on the CPU bus, return\n\n           the initial value */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Error Report */\n\n    case GT_CPUERR_ADDRLO:\n\n    case GT_CPUERR_ADDRHI:\n\n    case GT_CPUERR_DATALO:\n\n    case GT_CPUERR_DATAHI:\n\n    case GT_CPUERR_PARITY:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* CPU Sync Barrier */\n\n    case GT_PCI0SYNC:\n\n    case GT_PCI1SYNC:\n\n        /* Reading those register should empty all FIFO on the PCI\n\n           bus, which are not emulated. The return value should be\n\n           a random value that should be ignored. */\n\n        val = 0xc000ffee;\n\n        break;\n\n\n\n    /* ECC */\n\n    case GT_ECC_ERRDATALO:\n\n    case GT_ECC_ERRDATAHI:\n\n    case GT_ECC_MEM:\n\n    case GT_ECC_CALC:\n\n    case GT_ECC_ERRADDR:\n\n        /* Emulated memory has no error, always return the initial\n\n           values */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    case GT_CPU:\n\n    case GT_SCS10LD:\n\n    case GT_SCS10HD:\n\n    case GT_SCS32LD:\n\n    case GT_SCS32HD:\n\n    case GT_CS20LD:\n\n    case GT_CS20HD:\n\n    case GT_CS3BOOTLD:\n\n    case GT_CS3BOOTHD:\n\n    case GT_SCS10AR:\n\n    case GT_SCS32AR:\n\n    case GT_CS20R:\n\n    case GT_CS3BOOTR:\n\n    case GT_PCI0IOLD:\n\n    case GT_PCI0M0LD:\n\n    case GT_PCI0M1LD:\n\n    case GT_PCI1IOLD:\n\n    case GT_PCI1M0LD:\n\n    case GT_PCI1M1LD:\n\n    case GT_PCI0IOHD:\n\n    case GT_PCI0M0HD:\n\n    case GT_PCI0M1HD:\n\n    case GT_PCI1IOHD:\n\n    case GT_PCI1M0HD:\n\n    case GT_PCI1M1HD:\n\n    case GT_PCI0IOREMAP:\n\n    case GT_PCI0M0REMAP:\n\n    case GT_PCI0M1REMAP:\n\n    case GT_PCI1IOREMAP:\n\n    case GT_PCI1M0REMAP:\n\n    case GT_PCI1M1REMAP:\n\n    case GT_ISD:\n\n        val = s->regs[saddr];\n\n        break;\n\n    case GT_PCI0_IACK:\n\n        /* Read the IRQ number */\n\n        val = pic_read_irq(isa_pic);\n\n        break;\n\n\n\n    /* SDRAM and Device Address Decode */\n\n    case GT_SCS0LD:\n\n    case GT_SCS0HD:\n\n    case GT_SCS1LD:\n\n    case GT_SCS1HD:\n\n    case GT_SCS2LD:\n\n    case GT_SCS2HD:\n\n    case GT_SCS3LD:\n\n    case GT_SCS3HD:\n\n    case GT_CS0LD:\n\n    case GT_CS0HD:\n\n    case GT_CS1LD:\n\n    case GT_CS1HD:\n\n    case GT_CS2LD:\n\n    case GT_CS2HD:\n\n    case GT_CS3LD:\n\n    case GT_CS3HD:\n\n    case GT_BOOTLD:\n\n    case GT_BOOTHD:\n\n    case GT_ADERR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Configuration */\n\n    case GT_SDRAM_CFG:\n\n    case GT_SDRAM_OPMODE:\n\n    case GT_SDRAM_BM:\n\n    case GT_SDRAM_ADDRDECODE:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* SDRAM Parameters */\n\n    case GT_SDRAM_B0:\n\n    case GT_SDRAM_B1:\n\n    case GT_SDRAM_B2:\n\n    case GT_SDRAM_B3:\n\n        /* We don't simulate electrical parameters of the SDRAM.\n\n           Just return the last written value. */\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Device Parameters */\n\n    case GT_DEV_B0:\n\n    case GT_DEV_B1:\n\n    case GT_DEV_B2:\n\n    case GT_DEV_B3:\n\n    case GT_DEV_BOOT:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Record */\n\n    case GT_DMA0_CNT:\n\n    case GT_DMA1_CNT:\n\n    case GT_DMA2_CNT:\n\n    case GT_DMA3_CNT:\n\n    case GT_DMA0_SA:\n\n    case GT_DMA1_SA:\n\n    case GT_DMA2_SA:\n\n    case GT_DMA3_SA:\n\n    case GT_DMA0_DA:\n\n    case GT_DMA1_DA:\n\n    case GT_DMA2_DA:\n\n    case GT_DMA3_DA:\n\n    case GT_DMA0_NEXT:\n\n    case GT_DMA1_NEXT:\n\n    case GT_DMA2_NEXT:\n\n    case GT_DMA3_NEXT:\n\n    case GT_DMA0_CUR:\n\n    case GT_DMA1_CUR:\n\n    case GT_DMA2_CUR:\n\n    case GT_DMA3_CUR:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Channel Control */\n\n    case GT_DMA0_CTRL:\n\n    case GT_DMA1_CTRL:\n\n    case GT_DMA2_CTRL:\n\n    case GT_DMA3_CTRL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* DMA Arbiter */\n\n    case GT_DMA_ARB:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Timer/Counter */\n\n    case GT_TC0:\n\n    case GT_TC1:\n\n    case GT_TC2:\n\n    case GT_TC3:\n\n    case GT_TC_CONTROL:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* PCI Internal */\n\n    case GT_PCI0_CFGADDR:\n\n        val = phb->config_reg;\n\n        break;\n\n    case GT_PCI0_CFGDATA:\n\n        if (!(phb->config_reg & (1 << 31))) {\n\n            val = 0xffffffff;\n\n        } else {\n\n            val = pci_data_read(phb->bus, phb->config_reg, 4);\n\n        }\n\n        if (!(s->regs[GT_PCI0_CMD] & 1) && (phb->config_reg & 0x00fff800)) {\n\n            val = bswap32(val);\n\n        }\n\n        break;\n\n\n\n    case GT_PCI0_CMD:\n\n    case GT_PCI0_TOR:\n\n    case GT_PCI0_BS_SCS10:\n\n    case GT_PCI0_BS_SCS32:\n\n    case GT_PCI0_BS_CS20:\n\n    case GT_PCI0_BS_CS3BT:\n\n    case GT_PCI1_IACK:\n\n    case GT_PCI0_BARE:\n\n    case GT_PCI0_PREFMBR:\n\n    case GT_PCI0_SCS10_BAR:\n\n    case GT_PCI0_SCS32_BAR:\n\n    case GT_PCI0_CS20_BAR:\n\n    case GT_PCI0_CS3BT_BAR:\n\n    case GT_PCI0_SSCS10_BAR:\n\n    case GT_PCI0_SSCS32_BAR:\n\n    case GT_PCI0_SCS3BT_BAR:\n\n    case GT_PCI1_CMD:\n\n    case GT_PCI1_TOR:\n\n    case GT_PCI1_BS_SCS10:\n\n    case GT_PCI1_BS_SCS32:\n\n    case GT_PCI1_BS_CS20:\n\n    case GT_PCI1_BS_CS3BT:\n\n    case GT_PCI1_BARE:\n\n    case GT_PCI1_PREFMBR:\n\n    case GT_PCI1_SCS10_BAR:\n\n    case GT_PCI1_SCS32_BAR:\n\n    case GT_PCI1_CS20_BAR:\n\n    case GT_PCI1_CS3BT_BAR:\n\n    case GT_PCI1_SSCS10_BAR:\n\n    case GT_PCI1_SSCS32_BAR:\n\n    case GT_PCI1_SCS3BT_BAR:\n\n    case GT_PCI1_CFGADDR:\n\n    case GT_PCI1_CFGDATA:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    /* Interrupts */\n\n    case GT_INTRCAUSE:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRCAUSE %x\\n\", val);\n\n        break;\n\n    case GT_INTRMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"INTRMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_ICMASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"ICMASK %x\\n\", val);\n\n        break;\n\n    case GT_PCI0_SERR0MASK:\n\n        val = s->regs[saddr];\n\n        DPRINTF(\"SERR0MASK %x\\n\", val);\n\n        break;\n\n\n\n    /* Reserved when only PCI_0 is configured. */\n\n    case GT_HINTRCAUSE:\n\n    case GT_CPU_INTSEL:\n\n    case GT_PCI0_INTSEL:\n\n    case GT_HINTRMASK:\n\n    case GT_PCI0_HICMASK:\n\n    case GT_PCI1_SERR1MASK:\n\n        val = s->regs[saddr];\n\n        break;\n\n\n\n    default:\n\n        val = s->regs[saddr];\n\n        DPRINTF (\"Bad register offset 0x%x\\n\", (int)addr);\n\n        break;\n\n    }\n\n\n\n    if (!(s->regs[GT_CPU] & 0x00001000))\n\n        val = bswap32(val);\n\n\n\n    return val;\n\n}\n", "idx": 20054, "substitutes": {"opaque": ["ipa", "Opaque", "Opa", "ipace", "OPa", "Opac", "opac", "opusaques", "opuschid", "ipac", " opchid", "OPaques", "opusaque", "OPaque", "opace", "ipaque", "OPac", "opaques", "OPace", "opa", "OPchid", "Opace", "opchid", " opaques"], "addr": ["part", "offset", "db", "data", "base", "ref", "reg", "md", "ord", "rt", "str", "channel", "oa", "src", "node", "ext", "index", "ptr", "pos", "byte", "pointer", "arr", "sta", "host", "slot", "alias", "nr", "config", "ad", "dr", "side", "asm", "seq", "url", "address", "pad", "adr", "sid", "ace", "conn", "len"], "size": [" len", "data", "SIZE", " bytes", " data", "ize", "length", " Size", "address", " sizes", "bytes", "Size", " length", "len"], "s": ["ns", "spec", "m", "session", "sg", "t", "stats", "aws", "f", "sv", "services", "service", "n", "sie", "sb", "i", "sl", "ss", "scope", "fs", "slice", "is", "o", "d", "su", "ssh", "sites", "socket", "site", "w", "bis", "serv", "e", "ssl", "side", "ses", "v", "sync", "c", "si", "sym", "p", "S", "single", "b", "gs", "sys", "storage", "os", "server", "states", "sq", "south", "sets", "sa", "ds", "sf"], "phb": [" phB", "tha", "thb", "ppa", "ppbs", " pha", "ppB", "ppb", "phbs", "phB", "thB", "pha", "thbs", " phbs"], "val": ["util", "Val", "ret", "grad", "data", "cal", "al", "base", "ref", "x", "alt", "all", "ct", "lit", "ann", "rel", "vals", "num", "sl", "loc", "sel", "pos", "ind", "byte", "def", "VAL", "arg", "slot", "rol", "fail", "ol", "rot", "ival", "il", "serv", "bl", "v", "rl", " aval", "b", "col", "eval", "split", "aval", "valid", "el", "value", "pt", "cond", "len"], "saddr": ["sadr", "Slayer", "sysaddress", " slayer", "srm", "sitesrc", "secondarydr", "secondaryaddress", " sptr", "sord", " sdr", "secondaryaddr", "sitehost", "sinaddress", " srm", "sinaddr", "tdb", "sptr", "tadr", "siteaddress", "faddr", "siteaddr", " ssrc", "syshost", "slayer", "Srm", "shost", "sysord", "fhost", "syslayer", "Sadd", "Sdr", " sord", "sysptr", "Saddress", "sysadr", "sysdr", "saddress", "sattr", "fattr", "siteattr", "sysdb", " sattr", "Sord", "sadd", "sdb", "siteadd", " saddress", "taddr", "sysaddr", " shost", "secondaryptr", "ssrc", "Shost", "faddress", "Sattr", "taddress", "sinadr", "Saddr", "sysrm", "Ssrc", "sindb", "sdr", " sadd"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "int qemu_opt_set(QemuOpts *opts, const char *name, const char *value)\n\n{\n\n    QemuOpt *opt;\n\n\n\n    opt = qemu_opt_find(opts, name);\n\n    if (!opt) {\n\n        QemuOptDesc *desc = opts->list->desc;\n\n        int i;\n\n\n\n        for (i = 0; desc[i].name != NULL; i++) {\n\n            if (strcmp(desc[i].name, name) == 0) {\n\n                break;\n\n            }\n\n        }\n\n        if (desc[i].name == NULL) {\n\n            if (i == 0) {\n\n                /* empty list -> allow any */;\n\n            } else {\n\n                fprintf(stderr, \"option \\\"%s\\\" is not valid for %s\\n\",\n\n                        name, opts->list->name);\n\n                return -1;\n\n            }\n\n        }\n\n        opt = qemu_mallocz(sizeof(*opt));\n\n        opt->name = qemu_strdup(name);\n\n        opt->opts = opts;\n\n        TAILQ_INSERT_TAIL(&opts->head, opt, next);\n\n        if (desc[i].name != NULL) {\n\n            opt->desc = desc+i;\n\n        }\n\n    }\n\n    qemu_free((/* !const */ char*)opt->str);\n\n    opt->str = NULL;\n\n    if (value) {\n\n        opt->str = qemu_strdup(value);\n\n    }\n\n    if (qemu_opt_parse(opt) < 0) {\n\n        fprintf(stderr, \"Failed to parse \\\"%s\\\" for \\\"%s.%s\\\"\\n\", opt->str,\n\n                opts->list->name, opt->name);\n\n        qemu_opt_del(opt);\n\n        return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 20070, "substitutes": {"opts": ["opttd", "optks", "operTS", " opters", " oputs", "omts", "omters", "ropments", "deputs", "obfs", "otks", "hopks", "operters", "operks", "optts", "opjs", " optd", "otcs", "otments", "dept", "oputs", " opfs", "opths", "okuts", "catters", "hopds", "opters", "opps", "obls", "otls", "okts", "opks", "otters", "operts", "obts", "catts", "OPters", "depts", "operjs", "operfs", "omps", "hopfs", "omtd", "OPls", "hopls", "hopments", "OPt", "oklets", "optd", " opps", "opments", " opments", "OPfs", "opcs", "depths", "okments", "otuts", "hopts", "otTS", " opTS", "optps", "OPths", "catcs", " oplets", " opths", "otts", "obters", "OPts", "ropts", "catks", "otds", "operuts", "hopjs", "oplets", "opls", "opfs", "operls", "operments", "roputs", "otjs", " opks", "opTS", "optters", "optcs", "roplets", "OPuts", "operds", "opds"], "name": ["spec", "extra", "x", "dot", "comment", "full", "str", "num", "var", "label", "new", "path", "initial", "no", "prefix", "id", "none", "resource", "end", "word", "source", "conn", "part", "search", "min", "description", "arg", "size", "named", "key", "parent", "null", "field", "a", "list", "na", "time", "code", "base", "call", "image", "ame", "block", "type", "Name", "filename", "val", "NAME", "common", "nice", "w", "start", "doc", "address", "missing", "one", "version", "custom", "group", "data", "info", "all", "sp", "n", "option", "nam", "nm", "alias", "old", "e", "names", "attr"], "value": ["set", "values", "term", "content", "Value", "text", "data", "comment", "alt", "json", "anything", "property", "r", "option", "str", "type", "function", "description", "object", "other", "range", "val", "change", "new", "size", "format", "w", "prefix", "key", "v", "parent", "unit", "VALUE", "none", "field", "number", "iv", "message", "end", "valid", "list", "source", "version"], "opt": ["oc", "skip", "obj", "al", "op", "options", "nt", "pl", "num", "str", "max", "optim", "pos", "Opt", "path", "tx", "no", "id", "comb", "temp", "p", "xml", "next", "h", "oo", "loop", "end", "it", "word", "conn", "init", "txt", "eff", "dest", "hop", "vert", "object", "o", "arg", "inf", "open", "v", "cat", "parent", "update", "tmp", "off", "iter", "ver", "term", "ret", "text", "expr", "f", "call", "err", "alt", "json", "cho", "root", "type", "or", "loc", "oper", "orig", "fo", "val", "close", "ott", "go", "prev", "serv", "c", "post", "aut", "fn", "OP", "py", "oss", "pot", "tr", "info", "ort", "ord", "n", "option", "ok", "sl", "z", "ext", "def", "lt", "out", "prop", "step", "neg", "cmd", "error", "proc", "usr", "attr"], "desc": ["dc", "entry", "sup", "code", "data", "dep", "esc", "info", "dest", "dir", "text", "comment", "sort", "rc", "acc", "str", "anc", "toc", "loc", "src", "ext", "des", "sec", "help", "resp", "def", "description", "enc", "exec", "contract", "rec", "cont", "path", "disc", "pri", "sub", "config", "id", "sc", "prev", "req", "neg", "c", "seq", "meta", "uc", "Desc", "doc", "dist", "next", "ec", "decl", "diff", "section", "progress", "conn", "asc"], "i": ["ti", "gi", "uri", "bi", "j", "s", "code", "ji", "data", "x", "f", "ix", "ini", "qi", "io", "ai", "n", "mi", "phi", "hi", "z", "ii", "in", "ie", "di", "index", "ind", "ori", "I", "iu", "multi", "zi", "count", "slice", "o", "ip", "chi", "l", "d", "val", "oi", "iq", "pi", "ui", "ci", "id", "key", "e", "k", "q", "start", "v", "ni", "c", "si", "ri", "xi", "p", "b", "mu", "h", "a", "it", "eni", "fi", "y", "li", "u"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_initfn(SCSIDevice *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, dev);\n\n    Error *err = NULL;\n\n\n\n    if (!s->qdev.conf.bs) {\n\n        error_report(\"drive property not set\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n        !bdrv_is_inserted(s->qdev.conf.bs)) {\n\n        error_report(\"Device needs media, but drive is empty\");\n\n        return -1;\n\n    }\n\n\n\n    blkconf_serial(&s->qdev.conf, &s->serial);\n\n    if (dev->type == TYPE_DISK) {\n\n        blkconf_geometry(&dev->conf, NULL, 65535, 255, 255, &err);\n\n        if (err) {\n\n            error_report(\"%s\", error_get_pretty(err));\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (s->qdev.conf.discard_granularity == -1) {\n\n        s->qdev.conf.discard_granularity =\n\n            MAX(s->qdev.conf.logical_block_size, DEFAULT_DISCARD_GRANULARITY);\n\n    }\n\n\n\n    if (!s->version) {\n\n        s->version = g_strdup(qemu_get_version());\n\n    }\n\n    if (!s->vendor) {\n\n        s->vendor = g_strdup(\"QEMU\");\n\n    }\n\n\n\n    if (bdrv_is_sg(s->qdev.conf.bs)) {\n\n        error_report(\"unwanted /dev/sg*\");\n\n        return -1;\n\n    }\n\n\n\n    if ((s->features & (1 << SCSI_DISK_F_REMOVABLE)) &&\n\n            !(s->features & (1 << SCSI_DISK_F_NO_REMOVABLE_DEVOPS))) {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_removable_block_ops, s);\n\n    } else {\n\n        bdrv_set_dev_ops(s->qdev.conf.bs, &scsi_disk_block_ops, s);\n\n    }\n\n    bdrv_set_guest_block_size(s->qdev.conf.bs, s->qdev.blocksize);\n\n\n\n    bdrv_iostatus_enable(s->qdev.conf.bs);\n\n    add_boot_device_path(s->qdev.conf.bootindex, &dev->qdev, NULL);\n\n    return 0;\n\n}\n", "idx": 20086, "substitutes": {"dev": ["dc", "spec", "grad", "Dev", "dd", "mod", "ch", "data", "info", "conf", "dot", "comment", "conn", "md", "gu", "debug", "de", "block", "app", "var", "di", "der", "development", "def", "prom", "self", "sk", "d", "hw", "adv", "w", "ev", "config", " Dev", "cam", "client", "v", "dom", "device", "req", "driver", "error", "dem", "serial", "DEV", "server", "diff", "ve", "ver", "bug"], "s": ["ns", "spec", "full", "service", "ss", "sec", "cs", "d", "sh", "new", "qs", "sym", "p", "ks", "h", "sets", "m", "sup", "ts", "sg", "j", "rs", "aws", "sim", "self", "o", "sk", "su", "tests", "v", "si", "S", "a", "hs", "an", "ds", "f", "r", "sb", "current", "sd", "l", "serv", "sync", "c", "ps", "b", "sys", "your", "state", "sq", "less", "params", "sf", "session", "t", "stats", "request", "conf", "services", "sp", "n", "g", "i", "sl", "ls", "ops", "fs", "xs", "is", "args", "site", "e", "ssl", "ses", "client", "js", "http", "gs", "storage", "os", "server", "se", "south", "y", "u"], "err": ["m", "rr", "fr", "br", "fg", "ch", "rage", "rs", "ah", "conf", "ref", "eor", "better", "rc", "r", "inc", "ar", "str", "result", "g", "cb", "rh", "var", "msg", "finder", "ind", "cer", "kr", "der", "resp", "magic", "arr", "ln", "erer", "nr", "aster", "mr", "rag", "rar", "order", "sr", "dr", "e", "lr", "ler", "cr", "yr", "req", "acer", "ir", "doc", "fee", "pr", "good", "fy", "error", "sys", "Er", "res", "er", "errors", "Error", "gr", "bug"]}}
{"project": "qemu", "commit_id": "9359a58b122187964d7465d48165680eadbf69d3", "target": 0, "func": "static void ehci_update_frindex(EHCIState *ehci, int frames)\n\n{\n\n    int i;\n\n\n\n    if (!ehci_enabled(ehci)) {\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < frames; i++) {\n\n        ehci->frindex += 8;\n\n\n\n        if (ehci->frindex == 0x00002000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n        }\n\n\n\n        if (ehci->frindex == 0x00004000) {\n\n            ehci_raise_irq(ehci, USBSTS_FLR);\n\n            ehci->frindex = 0;\n\n            if (ehci->usbsts_frindex >= 0x00004000) {\n\n                ehci->usbsts_frindex -= 0x00004000;\n\n            } else {\n\n                ehci->usbsts_frindex = 0;\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 20095, "substitutes": {"ehci": ["khcu", "khlc", "ohcit", "ohdi", "ohco", "ohca", "khki", "evcu", "ohlc", "ahci", "ehsci", "khcci", "ahdi", "evdi", "khci", "echco", "eksci", "hessci", "khcit", "ethsci", "hesscci", "ethlc", "ehdi", "herci", "ehco", "herco", "hessc", "evci", "ahco", "echcu", "ahlc", "hesski", "eccu", "hcu", "ehki", "khc", "ethci", "ehcit", "ehc", "hlc", "eccin", "eclc", "ehlc", "ahcin", "ehca", "ethcu", "ohcci", "eklc", "hcci", "ahc", "evcci", "echci", "ehcu", "ecsci", "ahsci", "khca", "ahcci", "echsci", "ohc", "echcin", "ahcit", "ekcci", "herdi", "ohcu", "ahcu", "ecco", "ecci", "ahki", "ehcin", "hca", "hercu", "ohci", "ehcci", "hci", "hc", "khsci", "eccci", "echcci", "ekci"], "frames": ["classes", "values", "cycles", "planes", "fps", "tones", "pages", "stars", "series", "faces", "flows", "plugins", "seconds", "objects", "videos", "files", "points", "lines", "inches", "links", "quarters", "cells", "features", "blocks", "codes", "Frames", "bits", "steps", "rows", "events", "interface", "tracks", "frame", "states", "images"], "i": ["uri", "gi", "ti", "m", "bi", "j", "ji", "f", "ini", "qi", "io", "ai", "n", "phi", "fi", "hi", "z", "ie", "ii", "ori", "di", "index", "mini", "iu", "I", "multi", "zi", "o", "ip", "l", "adi", "oi", "yi", "pi", "ui", "ci", "abi", "e", "k", "cli", "v", "ni", "c", "si", "ri", "xi", "p", "mu", "interface", "anti", "eni", "diff", "inner", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "c9c55a56996836e7783fb27018834f230c553c98", "target": 0, "func": "static const MXFCodecUL *mxf_get_codec_ul(const MXFCodecUL *uls, UID *uid)\n\n{\n\n    while (uls->id != CODEC_ID_NONE) {\n\n        if(mxf_match_uid(uls->uid, *uid, 16))\n\n            break;\n\n        uls++;\n\n    }\n\n    return uls;\n\n}\n", "idx": 20102, "substitutes": {"uls": [" pulses", "ums", "UL", " los", "ols", "lbs", "phones", "rs", "uns", "rates", "flies", "cus", "usher", "sels", "ports", "ils", "ulates", "ubs", "illes", " offspring", "kids", "ips", "ls", "ults", "ruits", "nas", "ushes", "oos", "rets", "cons", "checks", "mods", " fees", "ricks", "cs", "clus", "acs", "nox", "offs", "ins", "los", "outs", "acks", "laus", "pull", " legions", "ets", "lus", "ools", "laws", "orts", " settlers", "rows", " supplies", " imports", "uses", "lins", "uli", "aunts", "ul", "ups", "its", "packs", "uss", "arers", "us", "opens", "asses", "flags", "ails", " feats"], "uid": ["uri", "gi", "vid", "bin", "pid", "code", "shape", "data", "user", "udi", "name", "base", "bit", "du", "version", "family", "num", "users", "type", "auth", "kind", "kid", "wd", "mask", "ua", "username", "bid", "ip", "uv", "alias", "uu", "oid", "uni", "ui", "ticket", "gpu", "id", "parent", "ug", "umi", "uc", "url", "ud", "uin", "ids", "UID", "sid", "null", "upid", "card", "ul", "nn", "us", "port", "mac", "uds", "u"]}}
{"project": "qemu", "commit_id": "85a67692d04e15a6b7d5a0e2b9d573d8bffbe108", "target": 0, "func": "static void pty_chr_state(CharDriverState *chr, int connected)\n\n{\n\n    PtyCharDriver *s = chr->opaque;\n\n\n\n    if (!connected) {\n\n        if (s->fd_tag) {\n\n            g_source_remove(s->fd_tag);\n\n            s->fd_tag = 0;\n\n        }\n\n        s->connected = 0;\n\n        s->polling = 0;\n\n        /* (re-)connect poll interval for idle guests: once per second.\n\n         * We check more frequently in case the guests sends data to\n\n         * the virtual device linked to our pty. */\n\n        pty_chr_rearm_timer(chr, 1000);\n\n    } else {\n\n        if (!s->connected)\n\n            qemu_chr_be_generic_open(chr);\n\n        s->connected = 1;\n\n    }\n\n}\n", "idx": 20105, "substitutes": {"chr": ["charpr", " chri", "ichlr", "charlr", "chpr", "ichra", "phra", "shri", " chpr", "chrc", "echrc", "Chrc", "ichr", "Char", "chlr", "ichpr", " chlr", "chro", "charar", " chra", "charr", "charp", "schr", "schra", "echr", "Chri", "phr", "charri", "chp", "shra", "ichri", " chp", "shro", "chra", "chri", "echar", "charrc", "Chr", "echri", "ichp", "schro", "phlr", "phri", " chro", "charra", "shr", "schri"], "connected": ["not", "dc", "broken", "built", "visible", "responsive", "known", "registered", "connect", "linked", "finished", "updated", "checked", "initialized", "conn", " connection", "thread", "running", " closed", "current", "established", "called", "bc", "index", "done", "normal", "started", "active", "graph", "encrypted", "rolled", "loaded", "wired", "online", "functional", "bound", "opened", "container", "handled", "close", "unknown", "empty", " disconnected", "ed", "socket", "config", "id", "selected", "client", "open", "powered", "controlled", "modified", "closed", "enabled", "ended", "compatible", "connection", "valid", "supported", "colored", "less", "cond", "locked"], "s": ["ns", "spec", "m", "session", "sg", "ts", "t", "rs", "f", "services", "r", "n", "sie", "sb", "g", "i", "sl", "ss", "ls", "fs", "self", "is", "o", "cs", "css", "l", "d", "new", "ins", "args", "e", "ssl", "ses", "sync", "c", "js", "si", "ps", "sym", "p", "secondary", "S", "b", "gs", "sys", "h", "es", "os", "hs", "opens", "se", "sets", "ds", "u"]}}
{"project": "FFmpeg", "commit_id": "544286b3d39365b30298ae07e66a755200b0895c", "target": 1, "func": "int h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format, width, height;\n\n\n\n    /* picture header */\n\n    if (get_bits(&s->gb, 22) != 0x20)\n\n        return -1;\n\n    skip_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1)\n\n        return -1;\t/* marker */\n\n    if (get_bits1(&s->gb) != 0)\n\n        return -1;\t/* h263 id */\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n\n\n    if (format != 7) {\n\n        s->h263_plus = 0;\n\n        /* H.263v1 */\n\n        width = h263_format[format][0];\n\n        height = h263_format[format][1];\n\n        if (!width)\n\n            return -1;\n\n\n\n        s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n\n\n        s->unrestricted_mv = get_bits1(&s->gb); \n\n        s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* SAC: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* advanced prediction mode: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* not PB frame */\n\n\n\n        s->qscale = get_bits(&s->gb, 5);\n\n        skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n    } else {\n\n        s->h263_plus = 1;\n\n        /* H.263v2 */\n\n        /* OPPTYPE */\n\n     \n\n        if (get_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n", "idx": 20109, "substitutes": {"s": ["ns", "set", "spec", "strings", "words", "x", "full", "settings", "service", "ions", "ss", "cs", "d", "qs", "sym", "p", "ks", "res", "us", "sets", "comments", "ms", "sup", "ts", "sg", "rs", "in", "self", "o", "su", "side", "si", "S", "a", "ds", "uns", "f", "sb", "as", "this", "l", "w", "features", "bis", "sync", "ps", "b", "sys", "your", "es", "states", "sq", "less", "session", "t", "stats", "conf", "services", "n", "plugins", "g", "i", "ls", "ops", "fs", "xs", "is", "css", "sites", "args", "site", "e", "ssl", "ses", "js", "http", "gs", "its", "parts", "os", "y", "u"], "format": ["html", "spec", "pattern", "plot", "offset", "category", "settings", "op", "dimension", "file", "quality", "package", "feat", "large", "length", "prefix", "language", "qt", "temp", "layout", "frequency", "feature", "it", "lat", "source", "len", " fmt", "scale", "direction", "sort", "flat", "size", "style", "lc", "cat", "stage", "at", "status", "band", "text", "f", "image", "base", "alt", "type", "function", "filename", "date", "act", "pretty", "gap", "position", "fn", "template", "transform", "frame", "version", "mode", "attribute", "theme", "option", "method", "slice", "dim", "letter", "space", "event", "fd", "unit", "url", "form", "api", "Format", "section", "attr", "period"], "height": ["thin", "direction", "image", "center", "input", "window", "max", "resolution", "padding", "slice", "index", "stroke", "above", "dim", "inches", "join", "gap", "gain", "definition", " heights", "build", "size", "density", "length", "img", "pull", "arrow", "gravity", "layout", "position", "crop", "Height", "total", "depth", "h", "row", "origin", "alpha", "bottom"]}}
{"project": "qemu", "commit_id": "f3d8b1eb105199a1d6bf063a8a574e782689909a", "target": 1, "func": "static void stellaris_init(const char *kernel_filename, const char *cpu_model,\n\n                           DisplayState *ds, stellaris_board_info *board)\n\n{\n\n    static const int uart_irq[] = {5, 6, 33, 34};\n\n    static const int timer_irq[] = {19, 21, 23, 35};\n\n    static const uint32_t gpio_addr[7] =\n\n      { 0x40004000, 0x40005000, 0x40006000, 0x40007000,\n\n        0x40024000, 0x40025000, 0x40026000};\n\n    static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31};\n\n\n\n    qemu_irq *pic;\n\n    qemu_irq *gpio_in[5];\n\n    qemu_irq *gpio_out[5];\n\n    qemu_irq adc;\n\n    int sram_size;\n\n    int flash_size;\n\n    i2c_bus *i2c;\n\n    int i;\n\n\n\n    flash_size = ((board->dc0 & 0xffff) + 1) << 1;\n\n    sram_size = (board->dc0 >> 18) + 1;\n\n    pic = armv7m_init(flash_size, sram_size, kernel_filename, cpu_model);\n\n\n\n    if (board->dc1 & (1 << 16)) {\n\n        adc = stellaris_adc_init(0x40038000, pic[14]);\n\n    } else {\n\n        adc = NULL;\n\n    }\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (0x10000 << i)) {\n\n            stellaris_gptm_init(0x40030000 + i * 0x1000,\n\n                                pic[timer_irq[i]], adc);\n\n        }\n\n    }\n\n\n\n    stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr);\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (board->dc4 & (1 << i)) {\n\n            gpio_in[i] = pl061_init(gpio_addr[i], pic[gpio_irq[i]],\n\n                                    &gpio_out[i]);\n\n        }\n\n    }\n\n\n\n    if (board->dc2 & (1 << 12)) {\n\n        i2c = i2c_init_bus();\n\n        stellaris_i2c_init(0x40020000, pic[8], i2c);\n\n        if (board->peripherals & BP_OLED_I2C) {\n\n            ssd0303_init(ds, i2c, 0x3d);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        if (board->dc2 & (1 << i)) {\n\n            pl011_init(0x4000c000 + i * 0x1000, pic[uart_irq[i]],\n\n                       serial_hds[i], PL011_LUMINARY);\n\n        }\n\n    }\n\n    if (board->dc2 & (1 << 4)) {\n\n        if (board->peripherals & BP_OLED_SSI) {\n\n            void * oled;\n\n            void * sd;\n\n            void *ssi_bus;\n\n            int index;\n\n\n\n            oled = ssd0323_init(ds, &gpio_out[GPIO_C][7]);\n\n            index = drive_get_index(IF_SD, 0, 0);\n\n            sd = ssi_sd_init(drives_table[index].bdrv);\n\n\n\n            ssi_bus = stellaris_ssi_bus_init(&gpio_out[GPIO_D][0],\n\n                                             ssi_sd_xfer, sd,\n\n                                             ssd0323_xfer_ssi, oled);\n\n\n\n            pl022_init(0x40008000, pic[7], stellaris_ssi_bus_xfer, ssi_bus);\n\n            /* Make sure the select pin is high.  */\n\n            qemu_irq_raise(gpio_out[GPIO_D][0]);\n\n        } else {\n\n            pl022_init(0x40008000, pic[7], NULL, NULL);\n\n        }\n\n    }\n\n    if (board->dc4 & (1 << 28)) {\n\n        /* FIXME: Obey network model.  */\n\n        stellaris_enet_init(&nd_table[0], 0x40048000, pic[42]);\n\n    }\n\n    if (board->peripherals & BP_GAMEPAD) {\n\n        qemu_irq gpad_irq[5];\n\n        static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d };\n\n\n\n        gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); /* up */\n\n        gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); /* down */\n\n        gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); /* left */\n\n        gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); /* right */\n\n        gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); /* select */\n\n\n\n        stellaris_gamepad_init(5, gpad_irq, gpad_keycode);\n\n    }\n\n}\n", "idx": 20110, "substitutes": {"kernel_filename": ["kernel_username", "pixel_filename", "kernelacfilename", "kernel_length", "kernel_surface", "kernelPusername", "cell_filename", "pixel_label", "kernelprofilename", "kernel_path", "kernelPfilename", "kernel_buf", "cell_surface", "kernelprosurface", "kernelpropath", "kernel_label", "kernelPlength", "cell_buf", "kernelacusername", "pixel_length", "kernelPlabel", "cell_path", "kernelaclabel", "kernelprobuf", "kernelaclength", "pixel_username"], "cpu_model": ["screen_image", "processor_memory", "cpu_memory", "screenlogmodel", "cpu64mode", "cpu64address", "cpulogimage", "cpulogaddress", "cpualmemory", "cpulogmodel", "screenlogmemory", "cpualimage", "processor_image", "cpu64model", "cpu_image", "cpu64memory", "cpulogmemory", "cpu_address", "cpu_mode", "screen_address", "processor_mode", "cpualmode", "screen_memory", "screen_model", "processor_model", "cpu64image", "cpualmodel", "screenlogaddress", "screenlogimage"], "ds": ["ros", "dd", "db", "cdn", "dds", "gd", "rs", "pd", "de", "dos", "cb", "ys", "ss", "vd", "ops", "dt", "di", "des", "fs", "der", "cs", "gb", "df", "DS", "dm", "sync", "ps", "da", "ks"], "board": ["plate", "pc", "plugin", "data", "deck", "core", "view", "comment", "image", "reader", "pod", "buffer", "bridge", "boarding", "feed", "channel", "stream", "block", "coll", "bc", "node", "hub", "control", "player", "stroke", "model", "lane", "game", "object", "controller", "o", "home", "design", "ack", "bro", "bo", "d", "database", "bank", "flow", "hole", "config", "cam", "phone", "sync", "client", "device", "boards", "layout", "driver", "builder", "flo", "line", "que", "b", "ck", "table", "cell", "clock", "row", "Board", "loop", "state", "frame", "server", "room", "bus", "card", "bug"], "uart_irq": ["timer_mirqq", "timer_ireqq", "timer_iriq", "timer_ireqs", "timer_irqs", "timer_iriQ", "timer_ireQ", "timer_irqq", "timer_iriqs", "timer_ireq", "timer_mirQ", "timer_iriqq", "timer_irQ", "timer_mirq", "timer_mirqs"], "timer_irq": ["timer__rinqq", "timer_iriq", "timer_IRqq", "timer_ireqs", "timer_irqs", "timer_irequest", "timer_iriQ", "timer_IRQ", "timer_IRq", "timer_ireQ", "timer_irqq", "timer_irquest", "timer__irQ", "timer__irq", "timer_iriqs", "timer__irqs", "timer_rinqq", "timer_ireq", "timer_mirQ", "timer__rinQ", "timer_rinqs", "timer_iriqq", "timer__rinq", "timer__rinqs", "timer_irQ", "timer__irqq", "timer_rinq", "timer_IRqs", "timer_mirq", "timer_mirquest", "timer_rinQ", "timer_IRquest", "timer_mirqs"], "gpio_addr": ["gpio_id", "gpios_address", "gpio_inner", "gpio__address", "gpio_address", "gpio_ix", "gpios_in", "gpio_adder", "gpios_addr", "gpios_id", "gpios_inner", "gpio__ix", "gpios_adder", "gpio__addr", "gpios_ix", "gpio__id"], "gpio_irq": ["gpio_mirqt", "gpio_irtqt", "gpio_srqu", "gpio_pirqq", "gpio_mirQ", "gpio_srqt", "gpio_pirq", "gpio_mirqq", "gpio_mirque", "gpio_mirqu", "gpio_irtv", "gpio_srv", "gpio_iraque", "gpio_irqu", "gpio_pirque", "gpio_srq", "gpio_irtq", "gpio_pirQ", "gpio_iraqq", "gpio_irqq", "gpio_irQ", "gpio_mirq", "gpio_iraq", "gpio_iraQ", "gpio_irque", "gpio_mirv", "gpio_irqt", "gpio_irv", "gpio_irtqu"], "pic": ["ic", "pc", "plugin", "jc", "pict", "pot", "pid", "court", "image", "cus", "ping", "cci", "pin", "tick", "vec", "nic", "plan", "Pic", "pixel", "iac", "mot", "gui", "PC", "quad", "mic", "mini", "cycle", "study", "arc", "fig", "parse", "piece", "feat", "chat", "ac", "pi", "ig", "config", "pipe", "aci", "soc", "pins", "cam", "sync", "cube", "cat", "lc", "lib", "capt", "xi", "circ", "doc", "plug", "feature", "cache", "cap", "fn", "proc", "picture", "py", "photo", "icc", "fi", "bus", "typ"], "gpio_in": ["gpIO_inc", "gpio_ins", "gpio_input", "gpios_out", "gpios_in", "gpIO_in", "gpIO_input", "gpios_ins", "gpios_inc", "gpio_inc", "gpIO_out"], "gpio_out": ["gpios_not", "gpioPout", "gpio_init", "gpios_size", "gpios_outs", "gpios_init", "gpioPsize", "gpios_out", "gpioPnot", "gpios_in", "gpio_size", "gpioPin", "gpio_not", "gpio_outs"], "adc": ["dc", "Adf", "adct", "Adcr", " adrc", "madc", "agct", " adpc", "aidf", "agrc", "aidsc", "Adcu", "Adsc", "Adce", "ajci", "madct", "adrc", "madci", "abce", " adcu", " adcr", "agc", "aidce", "absc", "adl", "abc", "agp", "dp", "madm", "aidl", "agpc", "ajc", "adce", "aidcr", "aidc", "adpc", "Adl", "adcr", "abf", "adci", "adf", "dpc", "agci", " adl", "ajm", "Adc", "agm", " adp", "adp", "aidcu", "adm", "adcu", "adsc", "drc", "ajct"], "sram_size": ["sgram_core", "sram_storage", "sram1ize", "sram_ize", "srayxsize", "slam_storage", "sramxname", "sram1shape", "sram_name", "sray_name", "sgram_sized", "sgram_loc", "sram1size", "sramxterm", "sramxlength", "sramxsize", "sram_shape", "sray_length", "sram_sized", "sram_core", "srayxname", "sgram_size", "slam_ize", "sram1storage", "sram_length", "sram_term", "srayxlength", "sray_term", "slam_shape", "srayxterm", "sray_size", "slam_size", "sram_loc"], "flash_size": ["flash_area", "flash67area", "flashkshift", "flash_shape", "flash\u00b7member", "flash_strength", "burst_shift", " flash_shape", "flash_shift", "flashksize", "flash\u00b7size", "flash67strength", "flash_max", "burst_size", " flash_area", " flash_strength", "burst_max", "flashkmax", "flash_member", "flash67size", " flash_member", "flash\u00b7shape"], "i2c": ["i5cc", "i5c", "pi5cs", "i1cc", "i1c", "i8cs", "i5cs", "pi2f", "pi5f", "i2cc", "pi2cc", "pi5c", "pi5cc", "pi2cs", "i5f", "i2cs", "i2f", "i1cs", "i8f", "i8cc", "pi2c", "i8c", "i1f"], "i": ["uri", "bi", "x", "qi", "ai", "phi", "hi", "ie", "ori", "d", "pi", "id", "cli", "ni", "p", "xi", "uli", "interface", "h", "it", "fi", "gi", "m", "j", "ix", "ini", "in", "iu", "I", "o", "axis", "k", "v", "si", "ri", "a", "iv", "ti", "f", "image", "r", "mi", "ii", "di", "mini", "multi", "zi", "page", "l", "oi", "yi", "ci", "c", "b", "eni", "t", "info", "io", "n", "pixel", "g", "z", "slice", "ip", "ui", "e", "my", "inner", "y", "li", "u"]}}
{"project": "FFmpeg", "commit_id": "47219e1c0c2f8a159e70b58e6293c169c7dd62cc", "target": 1, "func": "static void do_video_out(AVFormatContext *s,\n\n                         OutputStream *ost,\n\n                         InputStream *ist,\n\n                         AVFrame *in_picture,\n\n                         int *frame_size, float quality)\n\n{\n\n    int nb_frames, i, ret, av_unused resample_changed;\n\n    AVFrame *final_picture, *formatted_picture;\n\n    AVCodecContext *enc, *dec;\n\n    double sync_ipts;\n\n\n\n    enc = ost->st->codec;\n\n    dec = ist->st->codec;\n\n\n\n    sync_ipts = get_sync_ipts(ost) / av_q2d(enc->time_base);\n\n\n\n    /* by default, we output a single frame */\n\n    nb_frames = 1;\n\n\n\n    *frame_size = 0;\n\n\n\n    if(video_sync_method){\n\n        double vdelta = sync_ipts - ost->sync_opts;\n\n        //FIXME set to 0.5 after we fix some dts/pts bugs like in avidec.c\n\n        if (vdelta < -1.1)\n\n            nb_frames = 0;\n\n        else if (video_sync_method == 2 || (video_sync_method<0 && (s->oformat->flags & AVFMT_VARIABLE_FPS))){\n\n            if(vdelta<=-0.6){\n\n                nb_frames=0;\n\n            }else if(vdelta>0.6)\n\n                ost->sync_opts= lrintf(sync_ipts);\n\n        }else if (vdelta > 1.1)\n\n            nb_frames = lrintf(vdelta);\n\n//fprintf(stderr, \"vdelta:%f, ost->sync_opts:%\"PRId64\", ost->sync_ipts:%f nb_frames:%d\\n\", vdelta, ost->sync_opts, get_sync_ipts(ost), nb_frames);\n\n        if (nb_frames == 0){\n\n            ++nb_frames_drop;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** drop!\\n\");\n\n        }else if (nb_frames > 1) {\n\n            nb_frames_dup += nb_frames - 1;\n\n            if (verbose>2)\n\n                fprintf(stderr, \"*** %d dup!\\n\", nb_frames-1);\n\n        }\n\n    }else\n\n        ost->sync_opts= lrintf(sync_ipts);\n\n\n\n    nb_frames= FFMIN(nb_frames, max_frames[AVMEDIA_TYPE_VIDEO] - ost->frame_number);\n\n    if (nb_frames <= 0)\n\n        return;\n\n\n\n    formatted_picture = in_picture;\n\n    final_picture = formatted_picture;\n\n\n\n#if !CONFIG_AVFILTER\n\n    resample_changed = ost->resample_width   != dec->width  ||\n\n                       ost->resample_height  != dec->height ||\n\n                       ost->resample_pix_fmt != dec->pix_fmt;\n\n\n\n    if (resample_changed) {\n\n        av_log(NULL, AV_LOG_INFO,\n\n               \"Input stream #%d.%d frame changed from size:%dx%d fmt:%s to size:%dx%d fmt:%s\\n\",\n\n               ist->file_index, ist->st->index,\n\n               ost->resample_width, ost->resample_height, av_get_pix_fmt_name(ost->resample_pix_fmt),\n\n               dec->width         , dec->height         , av_get_pix_fmt_name(dec->pix_fmt));\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    ost->video_resample = dec->width   != enc->width  ||\n\n                          dec->height  != enc->height ||\n\n                          dec->pix_fmt != enc->pix_fmt;\n\n\n\n    if (ost->video_resample) {\n\n        final_picture = &ost->resample_frame;\n\n        if (!ost->img_resample_ctx || resample_changed) {\n\n            /* initialize the destination picture */\n\n            if (!ost->resample_frame.data[0]) {\n\n                avcodec_get_frame_defaults(&ost->resample_frame);\n\n                if (avpicture_alloc((AVPicture *)&ost->resample_frame, enc->pix_fmt,\n\n                                    enc->width, enc->height)) {\n\n                    fprintf(stderr, \"Cannot allocate temp picture, check pix fmt\\n\");\n\n                    exit_program(1);\n\n                }\n\n            }\n\n            /* initialize a new scaler context */\n\n            sws_freeContext(ost->img_resample_ctx);\n\n            ost->img_resample_ctx = sws_getContext(dec->width, dec->height, dec->pix_fmt,\n\n                                                   enc->width, enc->height, enc->pix_fmt,\n\n                                                   ost->sws_flags, NULL, NULL, NULL);\n\n            if (ost->img_resample_ctx == NULL) {\n\n                fprintf(stderr, \"Cannot get resampling context\\n\");\n\n                exit_program(1);\n\n            }\n\n        }\n\n        sws_scale(ost->img_resample_ctx, formatted_picture->data, formatted_picture->linesize,\n\n              0, ost->resample_height, final_picture->data, final_picture->linesize);\n\n    }\n\n#else\n\n    if (resample_changed) {\n\n        avfilter_graph_free(&ost->graph);\n\n        if (configure_video_filters(ist, ost)) {\n\n            fprintf(stderr, \"Error reinitialising filters!\\n\");\n\n            exit_program(1);\n\n        }\n\n    }\n\n#endif\n\n    if (resample_changed) {\n\n        ost->resample_width   = dec->width;\n\n        ost->resample_height  = dec->height;\n\n        ost->resample_pix_fmt = dec->pix_fmt;\n\n    }\n\n\n\n    /* duplicates frame if needed */\n\n    for(i=0;i<nb_frames;i++) {\n\n        AVPacket pkt;\n\n        av_init_packet(&pkt);\n\n        pkt.stream_index= ost->index;\n\n\n\n        if (s->oformat->flags & AVFMT_RAWPICTURE) {\n\n            /* raw pictures are written as AVPicture structure to\n\n               avoid any copies. We support temorarily the older\n\n               method. */\n\n            AVFrame* old_frame = enc->coded_frame;\n\n            enc->coded_frame = dec->coded_frame; //FIXME/XXX remove this hack\n\n            pkt.data= (uint8_t *)final_picture;\n\n            pkt.size=  sizeof(AVPicture);\n\n            pkt.pts= av_rescale_q(ost->sync_opts, enc->time_base, ost->st->time_base);\n\n            pkt.flags |= AV_PKT_FLAG_KEY;\n\n\n\n            write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n            enc->coded_frame = old_frame;\n\n        } else {\n\n            AVFrame big_picture;\n\n\n\n            big_picture= *final_picture;\n\n            /* better than nothing: use input picture interlaced\n\n               settings */\n\n            big_picture.interlaced_frame = in_picture->interlaced_frame;\n\n            if (ost->st->codec->flags & (CODEC_FLAG_INTERLACED_DCT|CODEC_FLAG_INTERLACED_ME)) {\n\n                if(top_field_first == -1)\n\n                    big_picture.top_field_first = in_picture->top_field_first;\n\n                else\n\n                    big_picture.top_field_first = top_field_first;\n\n            }\n\n\n\n            /* handles sameq here. This is not correct because it may\n\n               not be a global option */\n\n            big_picture.quality = quality;\n\n            if(!me_threshold)\n\n                big_picture.pict_type = 0;\n\n//            big_picture.pts = AV_NOPTS_VALUE;\n\n            big_picture.pts= ost->sync_opts;\n\n//            big_picture.pts= av_rescale(ost->sync_opts, AV_TIME_BASE*(int64_t)enc->time_base.num, enc->time_base.den);\n\n//av_log(NULL, AV_LOG_DEBUG, \"%\"PRId64\" -> encoder\\n\", ost->sync_opts);\n\n            if (ost->forced_kf_index < ost->forced_kf_count &&\n\n                big_picture.pts >= ost->forced_kf_pts[ost->forced_kf_index]) {\n\n                big_picture.pict_type = AV_PICTURE_TYPE_I;\n\n                ost->forced_kf_index++;\n\n            }\n\n            ret = avcodec_encode_video(enc,\n\n                                       bit_buffer, bit_buffer_size,\n\n                                       &big_picture);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"Video encoding failed\\n\");\n\n                exit_program(1);\n\n            }\n\n\n\n            if(ret>0){\n\n                pkt.data= bit_buffer;\n\n                pkt.size= ret;\n\n                if(enc->coded_frame->pts != AV_NOPTS_VALUE)\n\n                    pkt.pts= av_rescale_q(enc->coded_frame->pts, enc->time_base, ost->st->time_base);\n\n/*av_log(NULL, AV_LOG_DEBUG, \"encoder -> %\"PRId64\"/%\"PRId64\"\\n\",\n\n   pkt.pts != AV_NOPTS_VALUE ? av_rescale(pkt.pts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1,\n\n   pkt.dts != AV_NOPTS_VALUE ? av_rescale(pkt.dts, enc->time_base.den, AV_TIME_BASE*(int64_t)enc->time_base.num) : -1);*/\n\n\n\n                if(enc->coded_frame->key_frame)\n\n                    pkt.flags |= AV_PKT_FLAG_KEY;\n\n                write_frame(s, &pkt, ost->st->codec, ost->bitstream_filters);\n\n                *frame_size = ret;\n\n                video_size += ret;\n\n                //fprintf(stderr,\"\\nFrame: %3d size: %5d type: %d\",\n\n                //        enc->frame_number-1, ret, enc->pict_type);\n\n                /* if two pass, output log */\n\n                if (ost->logfile && enc->stats_out) {\n\n                    fprintf(ost->logfile, \"%s\", enc->stats_out);\n\n                }\n\n            }\n\n        }\n\n        ost->sync_opts++;\n\n        ost->frame_number++;\n\n    }\n\n}\n", "idx": 20129, "substitutes": {"s": ["spec", "sit", "rs", "so", "op", "ess", "sv", "service", "sb", "g", "sl", "ast", "ss", "ls", "ops", "ctx", "fs", "sec", "o", "cs", "acs", "sed", "st", "serv", "ssl", "ses", "sam", "c", "si", "js", "sts", "sci", "gs", "sys", "es", "os", "sq", "sa", "ds", "oss"], "ost": ["oc", "est", "org", "tt", "rost", "ot", "ob", "obj", "oh", "op", "so", "rest", "ort", "obb", "obo", "nt", "ct", "osi", "hop", "ast", "om", "src", "ocr", "oper", "ops", "ld", "iol", "ST", "ods", "opp", "o", "sta", "oop", "tto", "ont", "host", "roc", "store", "object", "ott", "omm", "irst", "osta", "oid", "obs", "sn", "st", "ad", "sth", "ov", "OST", "oe", "lov", "post", "lib", "rss", "ust", "osc", "ud", "od", "http", "omp", "inst", "odi", "ood", "os", "oster", "co", "isc", "oss"], "ist": ["wp", "ilst", "ists", "irc", "lda", "ict", "ess", "edit", "pit", "osi", "ast", "isu", "gest", "wd", "isd", "ld", "dit", "sta", "imet", "istor", "asi", "irst", "ird", "alist", "st", "ad", "sth", "isi", "iste", "aint", "od", "adr", "ism", "IST", "inst", "et", "ace", "rist", "esi", "pt", "dist"], "in_picture": ["orig_picture", "in_memory", "orig_feature", "orig_fine", "current_memory", "in_fine", "inLogimage", "inLogmemory", "inLogpicture", "in_image", "current_video", "inLogvideo", "in_feature", "in_uri", "current_picture", "in_video", "current_image", "orig_uri"], "frame_size": ["framesscale", "frame_count", "cycle_number", "framescount", "frame_sized", "framessize", "image_resolution", "frame\u00b7scale", "frame\u00b7resolution", "framesresolution", "cycle_capacity", "frame_scale", "image_scale", "image_size", "frame_resolution", "frame\u00b7size", "image_count", "frame_capacity", "cycle_sized", "frame\u00b7count", "cycle_size"], "quality": [" gain", " alpha", " fidelity", " crit", " pad", " score", " fraction", " filter", " perf", " wa", " calib", "Quality", " progress", " gamma", " pause", " Q", " confidence", " refresh", " qual", " Quality", " resolution", " depth", " compression", " aspect", " weight", " FPS", " accuracy", " frequency"], "nb_frames": ["nn_steps", "nn_hops", "ni_tracks", "bn_views", "bn_words", "num_dates", "nbKmodules", "nr_steps", "nb_views", "nb__quarters", "nbJflows", "num_frames", "num_objects", "nb_lines", "nrJflows", "nb67hops", "nb67steps", "nbCframes", "num_flows", "niXframes", "num_videos", "nn67hops", "num_pages", "nblexflows", "nb33steps", "nb67pages", "niXvideos", "nb48lines", "nn67frames", "nbCflows", "nb_plugins", "nbCobjects", "ni_modules", "nbXtracks", "nb_cycles", "ni_frames", "bn_flows", "nbxsteps", "num_steps", "nbJsteps", "nbXframes", "nb_effects", "nb_modules", "nb64effects", "nb67frames", "nb_words", "nb68frames", "nb00features", "nb__frames", "num_cells", "nb68lines", "nb48features", "nb68fps", "nbJmodules", "nb67cycles", "niXtracks", "nn_frames", "nrJcycles", "ni_videos", "nb64flows", "nbCdates", "nb48steps", "nb_planes", "num_states", "nb00frames", "nb48frames", "nbJframes", "nb48quarters", "nbKvideos", "nr_flows", "nbenfps", "nblexframes", "nn67steps", "nbxquarters", "nb_docs", "num_lines", "num_docs", "bn_frames", "nb__flows", "nb33frames", "nrJframes", "nbJtracks", "nn_videos", "nb67views", "nb67fps", "nb_pages", "nb_tracks", "nblexplugins", "nbXvideos", "nbxvideos", "nblexquarters", "nb_cells", "bn67views", "nb__plugins", "num_cycles", "nbxpages", "nb_hops", "nb_dates", "nb_objects", "nb_states", "niXmodules", "nb68docs", "nbJcycles", "nb00steps", "nb_features", "num_quarters", "nbenstates", "nb_quarters", "nb33videos", "nb67docs", "num_planes", "bn67words", "nbensteps", "nr_frames", "nb_steps", "nbKtracks", "nb67flows", "nb00quarters", "bn67flows", "nr_cycles", "num_features", "nb_videos", "nb_fps", "num_effects", "bn67frames", "nb_flows", "num_plugins", "nb33hops", "nbenframes", "nb67quarters", "nb67lines", "nrJsteps", "nb48flows", "nbKframes", "nb67words", "nb64frames", "nb64lines", "num_fps", "nn67videos", "nbJvideos", "nbXmodules", "nb48effects", "nb67videos", "nbxframes", "nbxhops"], "i": ["ti", "j", "info", "f", "io", "mi", "n", "ai", "ii", "ie", "iu", "index", "slice", "I", "ip", "pi", "uni", "ui", "ci", "id", "cli", "c", "si", "p", "b", "it", "inner", "li"], "ret": ["status", "ref", "rc", "gc", "mi", "fi", "result", "cb", "mem", "resp", "def", "arr", "val", "rec", "re", "aux", "back", "fd", "rev", "fn", "rep", "res", "wa", "rem", "reply", "len"], "resample_changed": ["resplay_change", "resamples_changes", "resample__changed", "resamples_change", "resamples_error", "resample_edited", "resplay_changed", "resample_change", "resample_error", "resample__modified", "resamples_changed", "resample__change", "resplay_modified", "resplay_edited", "resample_changes", "resample__edited", "resample_modified"], "final_picture": ["original_photo", "original_images", "finaledimages", "reporteditypic", "finalOpicture", "finalOimages", "finalisedframe", "finalisedpicture", "finalityframe", "reported_picture", "finalitypicture", "reported_frame", "original_memory", "final_frame", "final__media", "final__picture", "final_images", "finaledpicture", "final__frame", "final__pic", "finalisedmedia", "finaledmemory", "finalisedpic", "final_photo", "final_memory", "finalOmemory", "finalOphoto", "reportedityframe", "finaledphoto", "reported_pic", "final_media", "reporteditymedia", "finalitypic", "original_picture", "reported_media", "finalitymedia", "final_pic", "reporteditypicture"], "formatted_picture": ["formatted_image", "formated_image", "formlied_piece", "formattedOpicture", "formlied_image", "formlied_pic", "formatted_frame", "formattedOpic", "formatted_Picture", "formated_Picture", "formured_picture", "formured_image", "formated_picture", "formatted_piece", "formattedOimage", "formured_Picture", "formated_frame", "formlied_picture", "formattedOpiece", "formatted_profile", "formatted_pic", "formured_profile"], "enc": ["dc", "oc", "pc", "Enc", "cc", "ch", "code", "ent", "obj", "vc", "eu", "de", "inc", "nec", "anc", "sl", "cod", "loc", "ou", "ctx", "fc", "sec", "oder", "en", "eng", "equ", "exec", "roc", "rec", "nc", "ac", "cel", "con", "ant", "lc", "c", "cat", "emb", "osc", "od", "ec", "sys", "orc", "unc", "iv", "env", "cv", "conn"], "sync_ipts": ["sync_ctsets", "sync_ptls", "sync_emptsets", "sync_ipss", "sync_ipn", "sync_iptsets", "sync_ipls", "sync_rtn", "sync_opn", "sync_ivs", "sync_ipsps", "sync_ops", "sync_ippls", "sync_ippt", "sync_ipst", "sync_ippn", "sync_iptts", "sync_owns", "sync_iptd", "sync_ippps", "sync_ivts", "sync_ctns", "sync_ownts", "sync_ippsets", "sync_iptls", "sync_ipps", "sync_ctn", "sync_ivps", "sync_ptsets", "sync_rtns", "sync_ippts", "sync_empts", "sync_ipd", "sync_ptts", "sync_opns", "sync_pts", "sync_emptls", "sync_rtts", "sync_ivt", "sync_iptn", "sync_ptns", "sync_ptn", "sync_ownn", "sync_ippd", "sync_rts", "sync_ipsts", "sync_ipsets", "sync_iptns", "sync_ips", "sync_cts", "sync_iptps", "sync_emptd", "sync_iptt", "sync_ownns", "sync_ippns"], "nb_frames_drop": ["nb_flows_add", "nb_frames_change", "nb_flows_drop", "nb_frames_add", "nb_flows_change", "nb_flows_0", "nb_frames_0"], "sync_opts": ["sync_optts", "sync_ots", "sync_optitions", "sync_opcs", "sync_optms", "sync_opitions", "sync_operts", "sync_effts", "sync_optcs", "sync_OPs", "sync_efftt", "sync_effitions", "sync_OPcs", "sync_pros", "sync_opers", "sync_OPts", "sync_opms", "sync_otitions", "sync_OPps", "sync_OPms", "sync_optt", "sync_opttt", "sync_optps", "sync_ottt", "sync_procs", "sync_prots", "sync_opercs", "sync_effs", "sync_ops", "sync_operps", "sync_proms", "sync_otts", "sync_opps"], "frame_number": ["video_number", "framealposition", "framealno", "frame64no", "video_no", "frame64index", "frame_index", "framealindex", "frame64position", "frame64number", "video_position", "frame_position", "frame_no", "framealnumber", "video_index"]}}
{"project": "qemu", "commit_id": "e95205e1f9cd2c4262b7a7b1c992a94512c86d0e", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131, "substitutes": {"opaque": ["openque", "octaque", " opque", "Opaque", "openaque", "octaques", "ophole", "Opque", "Ophole", "opacity", "Opifice", "octhole", "OPque", " ophole", " opifice", "OPaques", "openacity", "opifice", "OPaque", "octque", "OPacity", "opaques", "openaques", "opque", "octacity", "octifice"], "dbs": ["ldba", " dps", "dba", " dbc", "dsBS", "idps", "dBS", "sdps", "ldbes", "dbcs", "Dbs", " dBS", " dcs", "ldbc", "sdBS", "Dba", "idbis", " dbi", "dsbs", "Dbi", "dbbs", "idBS", "Dcs", "dsbi", "dbc", "dbes", "dbps", "dbBS", " dbis", "sdbis", "ldbs", "dps", "idbs", "dbis", "sdbs", "Dps", " dbes", " dba", "Dbc", "dsba", "dcs", "DBS", "dbi", "Dbes"]}}
{"project": "qemu", "commit_id": "3a21532626bb5c3ecb0f916843f75ccce6501a9d", "target": 0, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n\n{\n\n    EHCIState *s = ptr;\n\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n\n    uint32_t old = *mmio;\n\n    int i;\n\n\n\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n\n\n\n    /* Only aligned reads are allowed on OHCI */\n\n    if (addr & 3) {\n\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n        return;\n\n    }\n\n\n\n    if (addr < OPREGBASE) {\n\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n\n                TARGET_FMT_plx \"\\n\", addr);\n\n        return;\n\n    }\n\n\n\n\n\n    /* Do any register specific pre-write processing here.  */\n\n    switch(addr) {\n\n    case USBCMD:\n\n        if (val & USBCMD_HCRESET) {\n\n            ehci_reset(s);\n\n            val = s->usbcmd;\n\n            break;\n\n        }\n\n\n\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n\n            if (!ehci_enabled(s)) {\n\n                qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n\n                SET_LAST_RUN_CLOCK(s);\n\n            }\n\n            ehci_update_halt(s);\n\n        }\n\n\n\n        /* not supporting dynamic frame list size at the moment */\n\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n\n                    val & USBCMD_FLS);\n\n            val &= ~USBCMD_FLS;\n\n        }\n\n        break;\n\n\n\n    case USBSTS:\n\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n\n        val = s->usbsts;\n\n        ehci_set_interrupt(s, 0);\n\n        break;\n\n\n\n    case USBINTR:\n\n        val &= USBINTR_MASK;\n\n        break;\n\n\n\n    case FRINDEX:\n\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n\n        break;\n\n\n\n    case CONFIGFLAG:\n\n        val &= 0x1;\n\n        if (val) {\n\n            for(i = 0; i < NB_PORTS; i++)\n\n                handle_port_owner_write(s, i, 0);\n\n        }\n\n        break;\n\n\n\n    case PERIODICLISTBASE:\n\n        if (ehci_periodic_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n\n\n    case ASYNCLISTADDR:\n\n        if (ehci_async_enabled(s)) {\n\n            fprintf(stderr,\n\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n\n              \"      is enabled and HC is enabled\\n\");\n\n        }\n\n        break;\n\n    }\n\n\n\n    *mmio = val;\n\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n\n}\n", "idx": 20148, "substitutes": {"ptr": ["ts", "t", "tr", "fp", "f", "ctr", "ref", "tty", "eth", "r", "buffer", "str", "sb", "sl", "src", "scope", "pointer", "sh", "tc", "fd", "dr", "sth", "buf", "e", "tmp", "si", "p", "address", "inter", "proc", "inst", "Ptr", "port", "fi", "dll", "pt"], "addr": ["grad", "point", "offset", "vr", "x", "ref", "md", "align", "ar", "str", "arm", "adder", "padding", "pos", "layer", "anne", "config", "id", "asm", "ea", "afi", "p", "pad", "od", "adr", "mt", "conn", "len", "pc", "rx", "part", "eth", "rc", "ne", "hop", "ld", "pointer", "arr", "hw", "slot", "size", "xd", "route", "mac", "port", "aug", "amp", "dc", "code", "base", "alt", "r", "rt", "src", "node", "loc", "sta", "xp", "host", "nr", "ad", "start", "address", "inter", "ace", "amd", "frame", "edge", "eni", "rr", "db", "data", "mode", "ord", "coord", "oa", "ext", "ctx", "index", "slice", "nm", "rd", "alias", "pkg", "nc", "hl", "dr", "seq", "cmd", "kt", "url", "intel", "nn", "attr"], "val": ["Val", "al", "x", "ref", "pl", "num", "var", "pos", "store", "new", "elt", "p", "test", "aval", "valid", "bal", "fi", "ve", "pt", "len", "values", "part", "Value", "cal", "ne", "vals", " old", "ld", "pol", "count", "arg", "arr", "slot", "fl", "vol", "pre", "ol", "key", "bl", "v", "update", "pret", "play", "ret", "base", "err", "f", "alt", "sel", "ind", "VAL", "serv", "b", "live", "value", "cond", "db", "data", "all", "reg", "sl", "pass", "index", "def", " value", "prop", "bo", "old", "fail", "unit", "eval", "local", "el", "li"], "s": ["ns", "spec", "x", "settings", "service", "sie", "details", "ss", "cs", "d", "new", "socket", "qs", "slave", "sym", "p", "h", "sets", "m", "ts", "sg", "j", "rs", "scope", "self", "o", "su", "v", "si", "S", "a", "an", "ds", "ves", "instance", "f", "sv", "r", "sb", "this", "ins", "w", "serv", "sync", "c", "ps", "secondary", "b", "sys", "es", "state", "states", "sq", "sf", "session", "t", "stats", "request", "conf", "services", "n", "g", "sl", "ls", "ops", "fs", "is", "site", "e", "ssl", "ses", "js", "http", "gs", "os", "server", "se", "u"], "mmio": ["mmmno", "mbio", "mbni", "memio", " mmIO", "mbri", "mmmni", "memri", "mpno", "memo", "mIO", "memni", "mmmios", "mmios", "memios", "mbios", "mmri", "mio", " mmiao", "mmmiao", "mbIO", "mmIO", "mmo", " mmri", "mmno", "memori", "mmmio", " mmios", "mios", " mmo", "mmmori", "mpio", "memIO", "mpiao", "mmiao", "mmni", "mpios", "mbori", " mmno", "mo", "mmori"], "i": ["m", "j", "x", "f", "err", "r", "io", "n", "z", "I", "is", "l", "d", "ed", "e", "v", "c", "p", "b", "a", "end"]}}
{"project": "qemu", "commit_id": "f5babeacc4abccbb32f318278135a43477bdaa20", "target": 0, "func": "sPAPRDRConnector *spapr_drc_by_index(uint32_t index)\n\n{\n\n    Object *obj;\n\n    char name[256];\n\n\n\n    snprintf(name, sizeof(name), \"%s/%x\", DRC_CONTAINER_PATH, index);\n\n    obj = object_resolve_path(name, NULL);\n\n\n\n    return !obj ? NULL : SPAPR_DR_CONNECTOR(obj);\n\n}\n", "idx": 20151, "substitutes": {"index": ["instance", "point", "offset", "data", "x", "ix", "inc", "num", "i", "root", "type", "match", "loc", "Index", "ind", "pos", "pointer", "object", "NAME", "alias", "path", "size", "prefix", "key", "config", "length", "id", "position", "url", "address", "cache", "level", "number", "addr", "connection", "value", "version", "column"], "obj": ["ns", "init", "j", "code", "data", "ob", "ref", "bj", "x", "conn", "err", "eff", "nt", "adj", "n", "cb", "oa", "node", "wb", "ext", "ctx", "pos", "ass", "nb", "act", "object", "o", "po", "art", "arr", "val", "path", "nc", "args", "prefix", "key", "id", "buff", "elt", "js", "tmp", "rb", "fn", "Object", "cn", "inst", "addr", "os", "attr", "pt", "Obj", "typ"], "name": ["part", "instance", "data", "x", "comment", "base", "dot", "ref", "call", "search", "n", "num", "str", "root", "block", "type", "package", "ext", "Name", "filename", "out", "object", "NAME", "alias", "old", "new", "path", "size", "space", "prefix", "key", "id", "e", "named", "parent", " path", " prefix", "table", "url", "address", " parent", "resource", "names", "connection", "addr", "word", "desc", "attr"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint64_t helper_fnmadd (uint64_t arg1, uint64_t arg2, uint64_t arg3)\n\n{\n\n    CPU_DoubleU farg1, farg2, farg3;\n\n\n\n    farg1.ll = arg1;\n\n    farg2.ll = arg2;\n\n    farg3.ll = arg3;\n\n\n\n    if (unlikely(float64_is_signaling_nan(farg1.d) ||\n\n                 float64_is_signaling_nan(farg2.d) ||\n\n                 float64_is_signaling_nan(farg3.d))) {\n\n        /* sNaN operation */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXSNAN);\n\n    } else if (unlikely((float64_is_infinity(farg1.d) && float64_is_zero(farg2.d)) ||\n\n                        (float64_is_zero(farg1.d) && float64_is_infinity(farg2.d)))) {\n\n        /* Multiplication of zero by infinity */\n\n        farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXIMZ);\n\n    } else {\n\n#if USE_PRECISE_EMULATION\n\n#ifdef FLOAT128\n\n        /* This is the way the PowerPC specification defines it */\n\n        float128 ft0_128, ft1_128;\n\n\n\n        ft0_128 = float64_to_float128(farg1.d, &env->fp_status);\n\n        ft1_128 = float64_to_float128(farg2.d, &env->fp_status);\n\n        ft0_128 = float128_mul(ft0_128, ft1_128, &env->fp_status);\n\n        if (unlikely(float128_is_infinity(ft0_128) && float64_is_infinity(farg3.d) &&\n\n                     float128_is_neg(ft0_128) != float64_is_neg(farg3.d))) {\n\n            /* Magnitude subtraction of infinities */\n\n            farg1.ll = fload_invalid_op_excp(POWERPC_EXCP_FP_VXISI);\n\n        } else {\n\n            ft1_128 = float64_to_float128(farg3.d, &env->fp_status);\n\n            ft0_128 = float128_add(ft0_128, ft1_128, &env->fp_status);\n\n            farg1.d = float128_to_float64(ft0_128, &env->fp_status);\n\n        }\n\n#else\n\n        /* This is OK on x86 hosts */\n\n        farg1.d = (farg1.d * farg2.d) + farg3.d;\n\n#endif\n\n#else\n\n        farg1.d = float64_mul(farg1.d, farg2.d, &env->fp_status);\n\n        farg1.d = float64_add(farg1.d, farg3.d, &env->fp_status);\n\n#endif\n\n        if (likely(!float64_is_nan(farg1.d)))\n\n            farg1.d = float64_chs(farg1.d);\n\n    }\n\n    return farg1.ll;\n\n}\n", "idx": 20158, "substitutes": {"arg1": ["argone", "argument3", "argument1", "ax3", "ax2", "Arg01", "ax01", "argument01", "arg01", "Arg1", "Argone", "ax1", "argument2", " argone", "axone", "Arg2", " arg01"], "arg2": ["arm2", "argument3", "argument1", "ax2", "arm4", "ax4", "args2", "args02", "args4", "ax1", "argument2", "argument4", "arg4", "ax02", "args1", "arg02", "arm1", "arm3", " arg4", " arg02"], "arg3": ["argument3", "arg53", " arg03", "argument1", "ax3", " arg53", "argument03", "Arg1", "ax1", "argument2", "ax53", "Arg3", "Arg03", "Arg53", "Arg2", "arg03", "ax03"], "farg1": ["fargumentone", "fargs81", "afargument91", "fArg3", "fang3", "far6", "faccessN", "fargument1", "fang81", " fark81", " far6", "farkOne", " farg11", "fark0", " fargfirst", "farc3", "fgen11", "frparam61", "fvar3", "fvar01", "fArgOne", "targs81", "fargs2", " farg6", " fark0", "frparam3", "fark81", "farg4", "FArg01", " far1", "fang1", "fargs3", "fargN", "fark01", "fang01", "frparamOne", "targN", "farkfirst", " far4", "fark1", "frg61", "frarg1", "fArgone", "fax4", "farg11", "faccess1", "fargone", "fArg91", "fparam1", " fark01", " farg01", "fargs1", "fArg81", " fark3", "fvar0", "targs01", "fargs6", "far4", "farc0", "fargOne", "faccess01", "far1", "frarg3", "targ01", "frparam1", "fargument3", " fark1", "farc81", "farg61", "fvarfirst", "targsN", "afargument3", "fvar1", "farg81", "farg0", "farkN", "afarg3", "fgen2", "farc1", "fvarOne", "fark61", "fax1", "farg01", "far3", "faccess81", "afarg91", "Farg1", "afargone", "FArg1", "FArg3", "frg3", "fargs91", "fparam3", "fargsN", "farg6", "fargfirst", "targs1", " fargOne", "FArg81", "fArg01", "targ1", "farg91", "Farg81", "fargsfirst", " farg81", "targ81", "fax6", "frg1", "fgen3", "fargs11", "fargs01", "afargumentone", "afargument1", "fargsone", "fargs0", " farg0", "fark3", "afarg1", "fArg1", "frgOne", "Farg01", " farg4", "frargOne", "fparam61", "fax3", " farkOne", "Farg3", "fparamOne", "fargument91", " farkfirst", "fgen1", "frarg61", " far3", "fargs4"], "farg2": ["pArg2", "fralletwo", "fplay0", "fallesecond", "fArg3", "fralle2", "fang3", "fag2", "fcresultsecond", "fitem2", "fdr3", "forargTwo", "Farg0", "fplay2", "afallesecond", "fitem3", "fresult62", "fagenTwo", "forarg2", "fagsecond", "fargs2", "fplay22", "fordr22", "fitem0", "fvar182", "afargsecond", "farg62", "pArg4", "farg4", "pArg0", "Fang2", "fcargsecond", "fargTwo", "Farg2", "fplay182", "parg4", "farntwo", "fordr2", "falleTwo", "fang2", "fagTwo", "frarg2", "parg182", "falle02", "farn72", "fagen2", "fplayTwo", "fArg2", "fralle72", "fralle3", "fvar0", "Fang3", "fArgTwo", "afalle2", "afalleTwo", "parg0", "falle62", "frarg3", "farg182", "fark22", "fdr22", "fresult02", "farkTwo", "fordrTwo", "farg0", "fordr3", "fcresult02", "frarg72", "falle72", "fargtwo", "farg72", "Fang0", "fvar4", "fvar2", "fang0", "falle2", "farg22", "fcarg2", "forarg3", "fangTwo", "parg2", "falletwo", "fArg4", "fagensecond", "farg02", "fark2", "fcarg62", "fargsecond", "fargs02", "fcarg02", "fcresult2", "frargtwo", "fdr2", "fdrTwo", "falle3", "fargssecond", "fark3", "fplay3", "forarg22", "fArg0", "fplay4", "pArg182", "FangTwo", "fark72", "fresultsecond", "fresult2", "afargtwo", "Farg3", "fagentwo", "fitemTwo", "fargs62", "fArg182", "FargTwo", "farktwo", "afalletwo", "afarg2", "fagtwo", "fcresult62", "afargTwo", "farn2", "farn3"], "farg3": ["fArg40", " ferg23", "fack12", "fcall3", "fArg3", "fang3", "ferg3", " fargThree", "ferg12", "farg23", "frarg15", "carg53", "carg03", "fvalid1", " farg40", "fok3", "farc3", "fcall23", "fargs2", "fok03", "farg9", "frarg53", "falle1", "cang53", "carg9", "farg4", "fcall03", "fargs3", "fArgthird", " fArg1", " ferg12", "fark1", " fArg03", "fax23", " fargthird", "fArg03", "frcall23", "farc53", "fang53", "carg3", "fang9", "farg53", "fargs1", "fArg2", "fcall53", "fargThree", " fArg40", "fargthird", "cang03", "frarg3", "fcall15", " farg03", " fargs3", "fvalid3", " farg12", "farg12", "frcall15", " ferg03", " fArgthird", "farc15", "fall03", " ferg3", "fall9", "frcall3", "ferg03", "farkThree", "ferg23", "fax15", "fack3", " farg23", "fax03", "farg03", "fall3", "farc23", "fax9", "falle40", "fack23", "fvalid40", "fokThree", "cang3", " fargs4", "fArg4", "farg40", "fok1", " fArgThree", "falle3", "fark3", "fArg1", " fArg3", " fargs1", " farg4", "fax53", "fang03", "fcall12", "fax3", "fark03", "farg15", "frcall53", " fargs2", "cang9", "fall53", "frarg23", "fallethird", "fargs4", "fArgThree", "fack03", "fvalidthird"], "ft0_128": ["ft1_58", "ft0j58", "ft5_128", "ft1_384", "ft0j256", "ft0j128", "ft0_1024", "ft80_1024", "ft1_257", "ft2_188", "ft0_256", "ft1_512", "ft1_048", "ft5_208", "ft2_48", "ft5_256", "ft5_512", "ft80_128", "ft0_48", "ft0_167", "ft80_256", "ft2_048", "ft0_208", "ft0j13", "ft0_512", "ft0_188", "ft0_384", "ft0_13", "ft0_58", "ft1_256", "ft0_257", "ft1_13", "ft0_048", "ft80_167", "ft2_128"], "ft1_128": ["ft0_32", "ft1_32", "ft0_48", "ft1_257", "ft0_126", "ftone_48", "ft1_188", "ft1_48", "ft1_126", "ft0_256", "ft1_256", "ftone_128", "ft0_257", "ftone_188"]}}
{"project": "qemu", "commit_id": "550830f9351291c585c963204ad9127998b1c1ce", "target": 0, "func": "static int cow_probe(const uint8_t *buf, int buf_size, const char *filename)\n\n{\n\n    const struct cow_header_v2 *cow_header = (const void *)buf;\n\n\n\n    if (buf_size >= sizeof(struct cow_header_v2) &&\n\n        be32_to_cpu(cow_header->magic) == COW_MAGIC &&\n\n        be32_to_cpu(cow_header->version) == COW_VERSION)\n\n        return 100;\n\n    else\n\n        return 0;\n\n}\n", "idx": 20189, "substitutes": {"buf": ["Buffer", "data", "fp", "obj", "f", "pool", "buffer", "rc", "file", "fi", "result", "cf", "loader", "cb", "cp", "src", "Buff", "ctx", "pb", "ptr", "writer", "header", "array", "bf", "img", "config", "queue", "fd", "buff", "fb", "batch", "rb", "seq", "cmd", "binary", "b", "cache", "alloc", "bag", "uf", "cv"], "buf_size": ["bufroffset", "buf_ize", "buf2size", "buf_capacity", " buf_ize", "buf2offset", "bufrsize", "cb_size", " buf_offset", "bufrize", "buf_sum", "buf2ize", "buf_offset", "cb_capacity", "cb_sum"], "filename": ["func", "name", "image", "tty", "file", "loader", "window", "src", "wb", "ctx", "fs", "console", "tif", "username", "enc", "nm", "path", "w", "prefix", "config", "png", "fd", "rb", "binary", "fn", "callback", "writer", "dll"], "cow_header": ["cow_author", "cowingpair", "cowingcache", " cow_writer", "cow_cache", "cowingdefinition", "cca_author", "cca_version", "cow_head", "cowingversion", "cow_magic", " cow_pair", "ow_magic", "ow_buffer", "cow_writer", "cow_definition", "cca_header", "cca_definition", "cow_version", "cowingheader", " cow_cache", "cowingauthor", "cow_buffer", "cowingwriter", "ow_header", "cow_pair", "ow_head"]}}
{"project": "qemu", "commit_id": "ad96090a01d848df67d70c5259ed8aa321fa8716", "target": 0, "func": "uint64_t ram_bytes_remaining(void)\n\n{\n\n    return ram_save_remaining() * TARGET_PAGE_SIZE;\n\n}\n", "idx": 20197, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "aac0eda40754c010ab5156dcd5d0d1554937e9a7", "target": 0, "func": "static int decode_ics(AACContext * ac, SingleChannelElement * sce, GetBitContext * gb, int common_window, int scale_flag) {\n\n    Pulse pulse;\n\n    TemporalNoiseShaping * tns = &sce->tns;\n\n    IndividualChannelStream * ics = &sce->ics;\n\n    float * out = sce->coeffs;\n\n    int global_gain, pulse_present = 0;\n\n\n\n    /* This assignment is to silence a GCC warning about the variable being used\n\n     * uninitialized when in fact it always is.\n\n     */\n\n    pulse.num_pulse = 0;\n\n\n\n    global_gain = get_bits(gb, 8);\n\n\n\n    if (!common_window && !scale_flag) {\n\n        if (decode_ics_info(ac, ics, gb, 0) < 0)\n\n            return -1;\n\n    }\n\n\n\n    if (decode_band_types(ac, sce->band_type, sce->band_type_run_end, gb, ics) < 0)\n\n        return -1;\n\n    if (decode_scalefactors(ac, sce->sf, gb, global_gain, ics, sce->band_type, sce->band_type_run_end) < 0)\n\n        return -1;\n\n\n\n    pulse_present = 0;\n\n    if (!scale_flag) {\n\n        if ((pulse_present = get_bits1(gb))) {\n\n            if (ics->window_sequence[0] == EIGHT_SHORT_SEQUENCE) {\n\n                av_log(ac->avccontext, AV_LOG_ERROR, \"Pulse tool not allowed in eight short sequence.\\n\");\n\n                return -1;\n\n            }\n\n            decode_pulses(&pulse, gb, ics->swb_offset);\n\n        }\n\n        if ((tns->present = get_bits1(gb)) && decode_tns(ac, tns, gb, ics))\n\n            return -1;\n\n        if (get_bits1(gb)) {\n\n            av_log_missing_feature(ac->avccontext, \"SSR\", 1);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (decode_spectrum_and_dequant(ac, out, gb, sce->sf, pulse_present, &pulse, ics, sce->band_type) < 0)\n\n        return -1;\n\n    return 0;\n\n}\n", "idx": 20199, "substitutes": {"ac": ["pc", "oc", "ic", "dc", "af", "vc", "ct", "gc", "inc", "acc", "aic", "iac", "anc", "app", "bc", "am", "jac", "fac", "as", "mic", "acl", "mc", "Ac", "abc", "act", "AC", "ae", "pac", "ca", "auc", "att", "ack", "cs", "acs", "ach", "kit", "ax", "tc", "config", "ad", "sac", "k", "cu", "ga", "com", "ag", "acer", "c", "cat", "uc", "ck", "aut", "cache", "ec", "ace", "a", "api", "mac", "an", "cc"], "sce": ["SCE", "gske", "iske", "gsced", "spose", "ske", "Scast", "vesce", "scca", " scent", "sste", "dscent", "oscel", " scca", "Sce", "gscel", "psce", "insse", "openske", "unske", "Ske", "scent", "insces", "yscer", "sced", "esce", "sescent", "dsCE", " scel", "vescel", " sste", "opensce", " ske", "sject", " scer", "scel", "gsste", "sCE", "pscel", "insce", " sces", "opensse", "ospose", "openscel", "esces", "pscast", "iscca", "inscent", " scast", "insCE", "sse", "osce", "dsce", "inscast", "seske", "unsce", "isject", "scast", " sject", "wske", "sesCE", "vesste", "escel", "wsce", " sse", "dske", "isce", "sesce", "wscel", "osced", " sCE", "scer", "inscel", "unsCE", "ysce", "sces", "wsces", "opensces", "yske", "unscent", "pske", "eske", "veske", "gspose", "gsce", "inske"], "gb": ["pc", "gi", "eb", "gram", "sg", "db", "cfg", "og", "gnu", "GB", "gd", "bin", "cca", "gal", "yg", "agg", "vc", "gio", "ged", "usb", "gc", "gg", "bm", "sb", "g", "gin", "gh", "cb", "hd", "bc", "hub", "ym", "ctx", "gam", "rg", "bb", "lb", "nb", "kw", "range", "cs", "generic", "gp", "gate", "kb", "bf", "ko", "go", "ci", "ig", "mb", "ga", "buff", "bits", "bg", "rb", "gt", "b", "gz", "gs", "boot", "gy", "gm", "cgi", "Gb", "ub"], "common_window": ["commoniangroup", " commonitycount", "commonitydepth", " common_mode", "commoniancount", "commonmwindow", "commoniandepth", " common_depth", "commonarygroup", "commonianwindow", "commonitymode", "commonityevent", "common_event", " common_event", "commonarydepth", " common_group", " commonitywindow", "commonmevent", "commonmmode", "commonitygroup", "common_mode", "commonarywindow", " commonitydepth", "common_count", "common_depth", "commonarycount", "commonitywindow", " common_count", "common_group", " commonitygroup", "commonitycount"], "scale_flag": ["scalevalwin", "scaleoinfo", "scaleallinfo", "cale_window", "cale_bit", "cale_flag", " scale_type", " scale_window", "scalevalwindow", "scale_win", " scale_file", "scalevalbit", "scaleoflag", " scale_info", "scale_file", "scale_bit", "cale_win", "scalealltype", "scalevalflag", "scaleotype", "scale_window", "scaleallflag", "scale_info", "scale_type"], "pulse": ["vpulse", "pixels", "pushitch", "epuls", "patilot", "compurchase", "lpulse", "epipe", "pitch", " puls", "purchase", "pixel", "lpuls", "compitch", "copitch", "pushulsion", "puls", "epulse", "pulsion", "copixel", "lpilot", "compulse", "pair", "vpulsion", "compulsion", "Pulsion", "Pilot", "pipe", " pilot", "ppixels", "patair", "patulse", "copulse", "patulsion", "epilot", "paramitch", "paramixel", "pushurchase", "pilot", "vpitch", "ppitch", " pair", " pulsion", "vpurchase", "pushulse", "lpipe", "paramixels", "ppixel", "ppulse", "Pair", " pipe", "paramulse", "Pulse", "copixels"], "tns": ["touts", "Tnas", "tbs", "dds", " tls", "fna", "atsn", "Tls", "atds", "tsbs", "tsns", "tscons", "fls", " ticks", "pns", "dsn", "atnc", "fcs", "atns", "tticks", "fns", "otds", "ttbs", "tnc", "dnc", "pls", "ttcons", "ticks", "Tna", " tcs", " tbs", "Tns", " touts", "pouts", " tcons", "Tcs", "otnc", "tsicks", "tnas", "dns", "ttns", "tls", "tds", "tsn", "tcons", " tnas", "tcs", "Touts", "pnas", " tna", "otns", "tna", "otsn"], "ics": ["ic", "ns", "spec", "cfg", "x", "xes", "gg", "details", "cf", "str", "aic", "igs", "cons", "cs", "icons", "aps", "acks", "qs", "codes", "cli", "xml", "ks", "gy", "icc", "isc", "fi", "icing", "ts", "fps", "cus", "ix", "omics", "osi", "times", "iac", "ips", "bc", "wcs", "mic", "magic", "acs", "inf", "rics", "outs", "ig", "xxx", "ick", "uses", "gz", "status", "nic", "ico", "IC", "fits", "nas", "items", "wic", "cells", "ins", "ci", "ga", "events", "sys", "cases", "rates", "stats", "amples", "gc", "io", "g", "ats", "ls", "ops", "fc", "fs", "abc", "icks", "xs", "is", "css", "args", "inas", "isi", "bits", "ICS", "gs", "its", "ipes"], "out": ["at", "bin", "cfg", "init", "extra", "obj", "err", "image", "full", "ix", "op", "bit", "gc", "io", "Out", "g", "i", "cb", "bc", "in", "wcs", "ext", "raw", "orig", "bb", "copy", "o", "again", "new", "go", "args", "outs", "ui", "img", "prefix", "sync", "temp", "c", "lib", "cache", "gen", "output", "co", "amp", "input"], "global_gain": ["global67gen", "Global_band", "global_generation", "global67gain", "global_wall", "global67wall", "global_band", " global_speed", "global67generation", "global67band", "Global_gen", "global5wall", "global_speed", "global5gain", " global_generation", "Global_growth", "global_gen", "global67growth", " global_wall", "global_growth", "global5generation", " global_gen", "Global_gain"]}}
{"project": "qemu", "commit_id": "0d82d0e8b98cf0ea03a45f8542d835ebd3a84cd3", "target": 0, "func": "static ssize_t buffered_flush(QEMUFileBuffered *s)\n\n{\n\n    size_t offset = 0;\n\n    ssize_t ret = 0;\n\n\n\n    DPRINTF(\"flushing %zu byte(s) of data\\n\", s->buffer_size);\n\n\n\n    while (s->bytes_xfer < s->xfer_limit && offset < s->buffer_size) {\n\n        size_t to_send = MIN(s->buffer_size - offset, s->xfer_limit - s->bytes_xfer);\n\n        ret = migrate_fd_put_buffer(s->migration_state, s->buffer + offset,\n\n                                    to_send);\n\n        if (ret <= 0) {\n\n            DPRINTF(\"error flushing data, %zd\\n\", ret);\n\n            break;\n\n        } else {\n\n            DPRINTF(\"flushed %zd byte(s)\\n\", ret);\n\n            offset += ret;\n\n            s->bytes_xfer += ret;\n\n        }\n\n    }\n\n\n\n    DPRINTF(\"flushed %zu of %zu byte(s)\\n\", offset, s->buffer_size);\n\n    memmove(s->buffer, s->buffer + offset, s->buffer_size - offset);\n\n    s->buffer_size -= offset;\n\n\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    return offset;\n\n}\n", "idx": 20200, "substitutes": {"s": ["ns", "spec", "full", "settings", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "h", "us", "sets", "comments", "ms", "m", "ts", "sg", "rs", "aws", "o", "su", "the", "side", "v", "si", "S", "a", "ds", "uns", "f", "r", "sb", "as", "this", "l", "ins", "sync", "c", "ps", "secondary", "b", "sys", "your", "es", "sq", "less", "sf", "session", "t", "conf", "services", "n", "g", "i", "ls", "ops", "fs", "xs", "en", "is", "site", "e", "ssl", "ses", "js", "gs", "its", "os", "server", "u"]}}
{"project": "qemu", "commit_id": "10c4c98ab7dc18169b37b76f6ea5e60ebe65222b", "target": 0, "func": "void pci_qdev_register(PCIDeviceInfo *info)\n\n{\n\n    info->qdev.init = pci_qdev_init;\n\n    info->qdev.bus_type = BUS_TYPE_PCI;\n\n    qdev_register(&info->qdev);\n\n}\n", "idx": 20213, "substitutes": {"info": ["entry", "gi", "Info", "init", "extra", "fw", "data", "conf", "name", "image", "base", "options", "f", "af", "comment", "rc", "op", "io", "rt", "feed", "i", "app", "INFO", "type", "ii", "kind", "this", "index", "manager", "def", "ip", "fo", "link", "parse", "inf", "build", "ignore", "ui", "add", "config", "id", "start", "update", "si", "off", "http", "check", "error", "opt", "a", "api", "end", "it", "py", "die", "fi", "inner"]}}
{"project": "qemu", "commit_id": "2d2507ef23d2a28eaeea5507ff4ec68657f1792f", "target": 0, "func": "static void vhost_net_stop_one(struct vhost_net *net,\n\n                               VirtIODevice *dev)\n\n{\n\n    struct vhost_vring_file file = { .fd = -1 };\n\n\n\n    if (!net->dev.started) {\n\n        return;\n\n    }\n\n\n\n    if (net->nc->info->type == NET_CLIENT_OPTIONS_KIND_TAP) {\n\n        for (file.index = 0; file.index < net->dev.nvqs; ++file.index) {\n\n            const VhostOps *vhost_ops = net->dev.vhost_ops;\n\n            int r = vhost_ops->vhost_call(&net->dev, VHOST_NET_SET_BACKEND,\n\n                                          &file);\n\n            assert(r >= 0);\n\n        }\n\n    }\n\n    if (net->nc->info->poll) {\n\n        net->nc->info->poll(net->nc, true);\n\n    }\n\n    vhost_dev_stop(&net->dev, dev);\n\n    vhost_dev_disable_notifiers(&net->dev, dev);\n\n}\n", "idx": 20233, "substitutes": {"net": ["not", "tun", "set", "plugin", "pot", "ner", "cot", "db", "un", "text", "user", "fat", "ot", "ct", "ne", "nt", "ver", "n", "nic", "io", "fun", "num", "nec", "channel", "nit", "module", "six", "mot", "ut", "jet", "dt", "mat", "web", "en", "virtual", "act", "eng", "nat", "nets", "vm", "art", "contract", "inet", "Net", "nc", "iot", "site", "network", "nu", "config", "key", "cat", "ni", "unit", "resource", "dat", "NET", "boot", "cn", "et", "service", "connection", "server", "np", "conn"], "dev": ["grad", "dd", "user", "gd", "gu", "md", "debug", "package", "design", "d", "ev", "temp", "dat", "serial", "end", "env", "ve", "conn", "Dev", "init", "mod", "engine", "de", "rad", "nov", "app", "devices", "dt", "develop", "der", "development", "hw", "adv", "dom", "ver", "dc", "ner", "image", "call", "block", "di", "unknown", "w", "ad", " device", "private", "device", "priv", "bug", "dn", "group", "db", "data", "info", "conf", "dir", "module", "dim", "def", "disk", "nc", "dr", "client", "req", "driver", "error", "DEV", "server", "diff", "dist"], "file": ["entry", "uri", "db", "time", "un", "data", "fp", "conf", "f", "image", "base", "name", "dir", "pool", "comment", "fun", "feed", "worker", "channel", "module", "block", "ile", "files", "type", "function", "zip", "model", "out", "object", "load", "link", "d", "class", " File", "path", "rule", "use", "w", "queue", "id", "config", "key", "il", "parent", "unit", "lib", "line", "binary", "url", "play", "cache", "resource", "check", "http", "feature", "route", "folder", "put", "connection", "port", "fi", "File", "bug"], "index": ["part", "point", "offset", "db", "shape", "x", "name", "ref", "base", "action", "ini", "inc", "num", "i", "type", "loc", "di", "slice", "ind", "count", "pointer", "head", "label", "page", "old", "prefix", "key", "id", "length", "config", "open", "update", "unit", "position", "address", "level", "body", "weight", "find", "connection", "write", "number", "end", "degree", "diff", "value", "conn"], "vhost_ops": ["vhostpapps", "vhost2op", "vHost_oper", "vhost_flags", "vHost_op", "vHost_ops", "vHost_opens", "vhost__flags", "vhostnetnets", "vhost2ops", "vhost_apps", "vhost_nets", "vhostpoper", "vhostnetoper", "vhostnetops", "vhost_op", "vhost__ops", "vhost__oper", "vhost2opens", "vhost_opens", "vhost_oper", "vhost__apps", "vhost2oper", "vhostpflags", "vhostpops", "vhostnetop"]}}
{"project": "FFmpeg", "commit_id": "b7b8fc340632d15cb3b26a57915ebea84f37d03e", "target": 0, "func": "static int rtsp_read_header(AVFormatContext *s,\n\n                            AVFormatParameters *ap)\n\n{\n\n    RTSPState *rt = s->priv_data;\n\n    char host[1024], path[1024], tcpname[1024], cmd[2048];\n\n    URLContext *rtsp_hd;\n\n    int port, i, ret, err;\n\n    RTSPHeader reply1, *reply = &reply1;\n\n    unsigned char *content = NULL;\n\n    AVStream *st;\n\n    RTSPStream *rtsp_st;\n\n    int protocol_mask;\n\n\n\n    rtsp_abort_req = 0;\n\n    \n\n    /* extract hostname and port */\n\n    url_split(NULL, 0,\n\n              host, sizeof(host), &port, path, sizeof(path), s->filename);\n\n    if (port < 0)\n\n        port = RTSP_DEFAULT_PORT;\n\n\n\n    /* open the tcp connexion */\n\n    snprintf(tcpname, sizeof(tcpname), \"tcp://%s:%d\", host, port);\n\n    if (url_open(&rtsp_hd, tcpname, URL_RDWR) < 0)\n\n        return AVERROR_IO;\n\n    rt->rtsp_hd = rtsp_hd;\n\n    rt->seq = 0;\n\n    \n\n    /* describe the stream */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"DESCRIBE %s RTSP/1.0\\r\\n\"\n\n             \"Accept: application/sdp\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, &content);\n\n    if (!content) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n        \n\n    /* now we got the SDP description, we parse it */\n\n    ret = sdp_parse(s, (const char *)content);\n\n    av_freep(&content);\n\n    if (ret < 0) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n    \n\n    protocol_mask = rtsp_default_protocols;\n\n\n\n    /* for each stream, make the setup request */\n\n    /* XXX: we assume the same server is used for the control of each\n\n       RTSP stream */\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        char transport[2048];\n\n        AVInputFormat *fmt;\n\n\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n\n\n        /* compute available transports */\n\n        transport[0] = '\\0';\n\n\n\n        /* RTP/UDP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP)) {\n\n            char buf[256];\n\n            int j;\n\n\n\n            /* first try in specified port range */\n\n            if (rtsp_rtp_port_min != 0) {\n\n                for(j=rtsp_rtp_port_min;j<=rtsp_rtp_port_max;j++) {\n\n                    snprintf(buf, sizeof(buf), \"rtp://?localport=%d\", j);\n\n                    if (!av_open_input_file(&rtsp_st->ic, buf, \n\n                                            &rtp_demux, 0, NULL))\n\n                        goto rtp_opened;\n\n                }\n\n            }\n\n\n\n            /* then try on any port */\n\n            if (av_open_input_file(&rtsp_st->ic, \"rtp://\", \n\n                                       &rtp_demux, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n            }\n\n\n\n        rtp_opened:\n\n            port = rtp_get_local_port(url_fileno(&rtsp_st->ic->pb));\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;unicast;client_port=%d-%d\",\n\n                     port, port + 1);\n\n        }\n\n\n\n        /* RTP/TCP */\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_TCP)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/TCP\");\n\n        }\n\n\n\n        if (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP_MULTICAST)) {\n\n            if (transport[0] != '\\0')\n\n                pstrcat(transport, sizeof(transport), \",\");\n\n            snprintf(transport + strlen(transport), \n\n                     sizeof(transport) - strlen(transport) - 1,\n\n                     \"RTP/AVP/UDP;multicast\");\n\n        }\n\n        snprintf(cmd, sizeof(cmd), \n\n                 \"SETUP %s RTSP/1.0\\r\\n\"\n\n                 \"Transport: %s\\r\\n\",\n\n                 rtsp_st->control_url, transport);\n\n        rtsp_send_cmd(s, cmd, reply, NULL);\n\n        if (reply->status_code != RTSP_STATUS_OK ||\n\n            reply->nb_transports != 1) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n\n\n        /* XXX: same protocol for all streams is required */\n\n        if (i > 0) {\n\n            if (reply->transports[0].protocol != rt->protocol) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n        } else {\n\n            rt->protocol = reply->transports[0].protocol;\n\n        }\n\n\n\n        /* close RTP connection if not choosen */\n\n        if (reply->transports[0].protocol != RTSP_PROTOCOL_RTP_UDP &&\n\n            (protocol_mask & (1 << RTSP_PROTOCOL_RTP_UDP))) {\n\n            av_close_input_file(rtsp_st->ic);\n\n            rtsp_st->ic = NULL;\n\n        }\n\n\n\n        switch(reply->transports[0].protocol) {\n\n        case RTSP_PROTOCOL_RTP_TCP:\n\n            fmt = &rtp_demux;\n\n            if (av_open_input_file(&rtsp_st->ic, \"null\", fmt, 0, NULL) < 0) {\n\n                err = AVERROR_INVALIDDATA;\n\n                goto fail;\n\n            }\n\n            rtsp_st->interleaved_min = reply->transports[0].interleaved_min;\n\n            rtsp_st->interleaved_max = reply->transports[0].interleaved_max;\n\n            break;\n\n            \n\n        case RTSP_PROTOCOL_RTP_UDP:\n\n            {\n\n                char url[1024];\n\n                \n\n                /* XXX: also use address if specified */\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d\", \n\n                         host, reply->transports[0].server_port_min);\n\n                if (rtp_set_remote_url(url_fileno(&rtsp_st->ic->pb), url) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        case RTSP_PROTOCOL_RTP_UDP_MULTICAST:\n\n            {\n\n                char url[1024];\n\n                int ttl;\n\n\n\n                fmt = &rtp_demux;\n\n                ttl = reply->transports[0].ttl;\n\n                if (!ttl)\n\n                    ttl = 16;\n\n                snprintf(url, sizeof(url), \"rtp://%s:%d?multicast=1&ttl=%d\", \n\n                         host, \n\n                         reply->transports[0].server_port_min,\n\n                         ttl);\n\n                if (av_open_input_file(&rtsp_st->ic, url, fmt, 0, NULL) < 0) {\n\n                    err = AVERROR_INVALIDDATA;\n\n                    goto fail;\n\n                }\n\n            }\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* use callback if available to extend setup */\n\n    if (ff_rtsp_callback) {\n\n        if (ff_rtsp_callback(RTSP_ACTION_CLIENT_SETUP, rt->session_id, \n\n                             NULL, 0, rt->last_reply) < 0) {\n\n            err = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n    }\n\n                         \n\n    /* start playing */\n\n    snprintf(cmd, sizeof(cmd), \n\n             \"PLAY %s RTSP/1.0\\r\\n\"\n\n             \"Range: npt=0-\\r\\n\",\n\n             s->filename);\n\n    rtsp_send_cmd(s, cmd, reply, NULL);\n\n    if (reply->status_code != RTSP_STATUS_OK) {\n\n        err = AVERROR_INVALIDDATA;\n\n        goto fail;\n\n    }\n\n\n\n#if 0\n\n    /* open TCP with bufferized input */\n\n    if (rt->protocol == RTSP_PROTOCOL_RTP_TCP) {\n\n        if (url_fdopen(&rt->rtsp_gb, rt->rtsp_hd) < 0) {\n\n            err = AVERROR_NOMEM;\n\n            goto fail;\n\n        }\n\n    }\n\n#endif\n\n\n\n    return 0;\n\n fail:\n\n    for(i=0;i<s->nb_streams;i++) {\n\n        st = s->streams[i];\n\n        rtsp_st = st->priv_data;\n\n        if (rtsp_st) {\n\n            if (rtsp_st->ic)\n\n                av_close_input_file(rtsp_st->ic);\n\n        }\n\n        av_free(rtsp_st);\n\n    }\n\n    av_freep(&content);\n\n    url_close(rt->rtsp_hd);\n\n    return err;\n\n}\n", "idx": 20237, "substitutes": {"s": ["ns", "spec", "settings", "series", "service", "ss", "cs", "d", "new", "qs", "sym", "p", "ks", "sets", "sa", "ts", "sg", "rs", "aws", "self", "o", "su", "v", "si", "S", "ds", "f", "r", "sb", "src", "this", "l", "sync", "private", "c", "ps", "sci", "b", "sys", "your", "es", "sq", "session", "t", "conf", "services", "n", "g", "sl", "ls", "shell", "fs", "xs", "is", "space", "args", "site", "e", "ssl", "client", "ses", "js", "support", "gs", "storage", "parts", "tp", "os", "server", "se", "y"], "ap": ["wp", "au", "al", "jp", "op", "sp", "ar", "ams", "am", "as", "pac", "arr", "att", "aps", "pp", "AP", "ac", "ax", "ad", "pa", "ars", "apt", "mp", "cap", "api", "tp", "arp", "attr", "sa"], "rt": ["rx", "RT", "rr", "tt", "fr", "t", "rs", "vr", "ot", "NT", "tr", "vc", "ct", "rc", "r", "nt", "rm", "rh", "ut", "dt", "bt", "irt", "rf", "art", "att", "rd", "ht", "rn", "rot", "sr", "dr", "qt", "ant", "cr", "req", "rl", "rb", "rss", "vt", "gt", "adr", "sys", "boot", "mt", "ft", "pt"], "host": ["uri", "pattern", "name", "full", "dir", "component", "proxy", "file", "hop", "stream", "method", "type", "node", "src", "localhost", "loc", "password", "object", "head", "ip", "home", "container", "context", "uid", "header", "format", "prefix", "config", "key", "id", "client", "driver", "address", "http", "route", "domain", "h", "Host", "addr", "connection", "frame", "server", "source", "conn", "target"], "path": ["uri", "pattern", "code", "request", "text", "data", "core", "name", "image", "dir", "file", "root", "method", "auth", "ath", "node", "loc", "pass", "ctx", "password", "prop", "container", "PATH", "prefix", "key", "id", "config", "cli", "parent", "temp", "Path", "address", "resource", "route", "desc", "source", "conn", "input"], "tcpname": ["fcppath", "tpname", "tmpname", "fcpname", "tpnam", "fcpurl", "Tcppath", "tcpName", "Tmpname", "tpurl", "twpname", "tfpName", "tppath", "tfpname", "fcpName", "TcpName", "tpprefix", "TmpName", "twpnames", "fmpurl", "tpnames", "Tcpnames", "tchurl", " tcpName", "Tmppath", "tcppath", "tportprefix", "tcpprefix", "tfppath", "tmpurl", "tmppath", "tportnam", "tpName", "tportName", " tportprefix", "Tmpnames", "tchpath", " tcpnam", "twppath", "tmpName", "tcpnames", "tcpurl", "tcpnam", "fmpname", "tchname", " tportName", " tportname", "twpName", " tcpprefix", "fmppath", "tportname", "Tcpname", "fmpName", "tmpnames", "tchName", " tportnam", "tmpprefix"], "cmd": ["cfg", "code", "text", "mode", "cookie", "name", "md", "file", "cf", "comm", "module", "cb", "method", "cp", "src", "auth", "msg", "shell", "ext", "ctx", "password", "filename", "head", "setup", "crypt", "header", "pkg", "Cmd", "config", "pipe", "prefix", "client", "cl", "cat", "req", "cli", "seq", "patch", "cmp", "route", "domain", "cd", "message", "mac", "command", "conn", "target"], "rtsp_hd": ["rtsnp_cd", "rtsp_conn", "rtsc_vd", "rtsp_ctx", "rtsc_hd", "rtsp_xd", "rtsp_dh", "rtsp_rh", "rtsnp_dh", "rtsnp_vd", "rtsp_vd", "rtsnp_ctx", "rtsc_conn", "rtsp_cd", "rtsc_cd", "rtsp_ld", "rtsnp_hd", "rtsnp_hm", "rtsnp_xd", "rtsp_hm", "rtsnp_ld", "rtsnp_rh"], "port": ["part", "m", "offset", "time", "text", "mode", "direction", "ort", "name", "ports", "file", "n", "hop", "stream", "method", "type", "cp", "index", "pos", "priority", "zip", "timeout", "count", "ip", "size", "PORT", "length", "id", "key", "config", "limit", "phone", "parent", "position", "p", "address", "test", "line", "Port", "col", "route", "export", "number", "message", "connection", "end", "server", "source", "version", "target", "len"], "i": ["uri", "gi", "ti", "m", "ami", "info", "x", "image", "jit", "ix", "ini", "qi", "gu", "io", "mi", "ai", "phi", "n", "hi", "type", "ii", "ori", "ie", "iu", "index", "di", "I", "multi", "ip", "chi", "l", "yi", "idi", "pi", "ui", "ci", "id", "start", "key", "e", "k", "v", "ni", "c", "si", "ri", "p", "xi", "b", "u", "h", "iter", "it", "eni", "fi", "inner", "y", "li", "mu"], "ret": ["status", "code", "info", "bit", "ref", "alt", "reg", "r", "rc", "nt", "fun", "lit", "result", "str", "num", "flag", "match", "ut", "msg", "pass", "mem", "resp", "rets", "count", "en", "def", "arg", "arr", "att", "val", "re", "Ret", "read", "feat", "no", "det", "sr", "rev", "RET", "pat", "rep", "res", "fi", "success", "len"], "err": ["raise", "rr", "fr", "rage", "ner", "br", "code", "fg", "r", "hr", "result", "str", "ar", "cb", "rh", "msg", "orig", "ind", "der", "kr", "arr", "fer", "mr", "order", "ler", "dr", "e", "lr", "cr", "cur", "req", "acer", "ir", "Error", "pr", "fy", "error", "er", "iter", "fi", "gr", "ver", "bug"], "reply1": ["request2", "replyOne", "resp1", " replyOne", "Reply2", "resp0", "Reply1", "requestOne", " reply0", " reply2", "request1", "Reply0", "reply2", "reply0", "ReplyOne", "resp2"], "reply": ["entry", "status", "rr", "fr", "request", "info", "data", "f", "call", "comment", "sp", "buffer", "rc", "proxy", "respond", "r", "service", "report", "result", "query", "shell", "msg", "ry", "resp", "replace", "link", "rec", "answer", "parse", "re", "response", "sr", "serv", "prev", "send", "sync", "rev", "req", "repl", "address", "b", "resource", "next", " replies", "sys", "rep", "write", "message", "server", "sq", "Reply", "transfer"], "content": ["status", "ch", "code", "data", "text", "x", "connect", "comment", "media", "reg", "results", "rc", "file", "cm", "script", "result", "cf", "clean", "match", "msg", "accept", "ext", "ctx", "resp", "enc", "exec", "load", "cs", "rec", "header", "found", "read", "cont", "cms", "complete", "size", "resh", "con", "config", "response", "temp", "c", "address", "xml", "resource", "Content", "output", "body", "message", "desc", "server", "command", "conn"], "st": ["ist", "est", "part", "fr", "nd", "t", "rest", "ct", "sp", "ste", "td", "fe", "str", "sb", "ost", "stream", "sl", "ast", "ss", "src", "ut", "ld", "ptr", "ST", "sa", "sd", "sta", "d", "std", "sn", "start", "sc", "dr", "sth", "stage", "sts", "St", "inst", "mt", "ft", "se", "pt"], "rtsp_st": ["rtsf__ct", "rtsf_stream", "rtsf__st", "rtsp__st", "rtsf_sth", "rtsf_ct", "rtsp_sth", "rtsv_hd", "rtsf_st", "rtsp__ct", "rtsp_stream", "rtsp_ct", "rtsv_sth", "rtsv_da", "rtsv_st", "rtsp_da", "rtsp__stream", "rtsf__stream", "rtsp__sth", "rtsf__sth"], "protocol_mask": ["protocol__mask", "protocol__depth", "protolution_Mask", "protolution_mask", "protocol_delay", "protchannel_delay", "protocol_count", "protocol_depth", "protocol_Mask", "protchannel_count", "protocol_pad", "protolution_ask", "protchannel_mask", "protocol__pad", "protocol_ask"], "transport": ["traport", " transpose", "ranscode", "transocol", " transocol", "trapose", "Transmission", "Transport", "transpose", "transferpose", "transmission", "Transports", "transferocol", "tramission", "traports", "ransport", "ranspose", "transports", "transcode", "transferport", "ransocol", "transfercode", " transcode", " transmission", "Transpose", " transports"], "fmt": [" fm", "cfmt", "cfkt", "FMT", "Fmt", "fm", " fkt", " fMT", "fMT", "fkt", "cfMT", "Fkt", "Fm", "cfm"], "buf": ["Buffer", "br", "func", "data", "bind", "ref", "pool", "buffer", "feed", "block", "stream", "method", "ba", "xff", "box", "buff", "map", "seq", "off", "pad", "cap", "alloc", "cast", "bag", "uf"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_s390x_handle_mmu_fault (CPUState *env, target_ulong address, int rw,\n\n                                int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong phys;\n\n    int prot;\n\n\n\n    /* XXX: implement mmu */\n\n\n\n    phys = address;\n\n    prot = PAGE_READ | PAGE_WRITE;\n\n\n\n    return tlb_set_page(env, address & TARGET_PAGE_MASK,\n\n                        phys & TARGET_PAGE_MASK, prot,\n\n                        mmu_idx, is_softmmu);\n\n}\n", "idx": 20238, "substitutes": {"env": ["enable", "viron", "txt", "db", "conf", "forge", "eu", "exc", "np", "chal", "erv", "environment", "ext", "en", "eng", "pect", "energy", "enc", "equ", "profile", "inet", "esi", "iss", "ev", "det", "e", "esm", "qt", "inv", "ea", "osc", "ec", "et", "ef", "priv", "eni", "fi", "dict", "conn", "ens"], "address": ["uri", "instance", "offset", "shape", "Address", "data", "mode", "base", "attribute", "enter", "master", "type", "reference", "localhost", "padding", "index", "ptr", "pointer", "object", "ip", "host", "pair", "array", "path", "memory", "socket", "network", "config", "length", "prefix", "primary", "device", "position", "area", "inter", "resource", "output", "route", "interface", "ace", "number", "addr", "state", "message", "port", "attr", "target"], "rw": ["rx", "wp", "work", "mode", "RW", "wo", "worker", "sw", "src", "padding", "password", "hw", "nr", "ww", "w", "prefix", "lr", "nw", "slave", "resource", "wh", "proc", "row", "nn", "conn"], "mmu_idx": ["mmu_Idxs", "mmu_Idc", "mmu_Idz", "mmu_idc", "mmu_pidx", "mmu_pidc", "mmu_idz", "mmu_indexz", "mmu_indexx", "mmu_idxs", "mmu_pidz", "mmu_indexy", "mmu_idsx", "mmu_idsy", "mmu_idsc", "mmu_idsz", "mmu_Idx", "mmu_pidxs", "mmu_idy", "mmu_indexc"], "is_softmmu": ["is_softmmtu", "is_softmu", "is_softmemc", "is_softmmnu", "is_softcmtu", "is_softcmcu", "is_softcmu", "is_softMMu", "is_softmnu", "is_softmmc", "is_softmme", "is_hardmme", "is_hardmmnu", "is_softMMe", "is_softmemcu", "is_softmmcu", "is_hardmmc", "is_softMMcu", "is_softmtu", "is_softcmnu", "is_hardmmtu", "is_softmcu", "is_softMMc", "is_hardmmcu", "is_softmemu", "is_hardmmu", "is_softmeme"], "phys": ["pty", "status", "part", "stat", "spec", "physical", "data", "info", "base", "ref", "platform", "eth", "proxy", "bridge", "rel", "cpu", "type", "phase", "padding", "Phys", "ptr", "phy", "pos", "pointer", "prop", "host", "class", "path", "pre", "socket", "config", "prefix", "rot", "phone", "primary", "sync", "temp", "device", "tech", "p", "interface", "sys", "intel", "proc", "number", "addr", "state", "tp", "port", "attr", "params", "conn", "target"], "prot": ["status", "part", "offset", "data", "fp", "mode", "ref", "platform", "mult", "channel", "type", "padding", "ext", "ptr", "phy", "protected", "pos", "cert", "pointer", "nat", "prop", "att", "gap", "cont", "format", "path", "pre", "reset", "prefix", "config", "rot", "primary", "sync", "seq", "secondary", "col", "period", "addr", "Prot", "server", "pt", "transfer", "len"]}}
