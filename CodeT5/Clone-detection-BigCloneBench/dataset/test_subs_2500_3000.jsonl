{"id1": "932225", "id2": "5723876", "code1": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "code2": "    public static final String calculate(File f) {\n        MessageDigest md;\n        BufferedReader rd;\n        StringBuffer buffer = new StringBuffer(\"\");\n        try {\n            rd = new BufferedReader(new FileReader(f));\n            md = MessageDigest.getInstance(\"SHA\");\n            String line = \"\";\n            while ((line = rd.readLine()) != null) buffer.append(line);\n            md.update(buffer.toString().getBytes());\n            byte[] digest = md.digest();\n            String result = \"\";\n            for (byte b : digest) result += String.format(\"%h\", b & 0xFF);\n            return result;\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            return \"\";\n        }\n    }\n", "label": 1, "substitutes": {"createVendorSignature": ["createVendorSignig", "createVendorFormature", "createVendorsigna", "createVendorSignatures", "createVendorForma", "createVendorSig", "createVendsignatures", "createVendorSigna", "createVendSignatures", "createVendorSatures", "createVendorsignature", "createVendorsignig", "createVendsignig", "createVendorsignatures", "createVendsigna", "createVendorSa", "createVendSignature", "createVendSigna", "createVendorFormig", "createVendorSature", "createVendSignig", "createVendorFormatures", "createVendsignature"], "b": ["buffer", "bytes", "i", "s", "bb", "Buffer", "sb", "bc", "a", " buffer", "be", "Bytes", "B", "binary", "buf", "base", "data", "ba", " eb", "body", " bc", "Builder", "cb", "c", " buf"], "_vendorMessageDigest": ["_vendorMessageDigested", "_vendorFileSignest", "_vendorFileDigester", "_vendorMessageDiger", "_vendorMessageDester", "_vendorMessageGested", "_vendorMessageIntegest", "_vendorFileDester", "_vendorMessageGest", "_vendorMessageDigEST", "_vendorApplicationdigess", "_vendorMessageEdHash", "_vendorFileSignester", "_vendorMessageDEST", "_vendorMessageDest", "_vendorMessageIngest", "_vendorMessageIntegester", "_vendorMessageIntegener", "_vendorApplicationDigener", "_vendorMessageSignener", "_vendorFileSignener", "_vendorFileDigest", "_vendorFileDested", "_vendorFileDigener", "_vendorMessageSigness", "_vendorApplicationDigess", "_vendorMessageEdener", "_vendorApplicationDigest", "_vendorMessagediger", "_vendorMessageEdest", "_vendorMessageDested", "_vendorMessageMarkested", "_vendorMessagedigener", "_vendorMessageDigHash", "_vendorMessageSigner", "_vendorMessageDigester", "_vendorMessageIngess", "_vendorFileDigEST", "_vendorApplicationdigest", "_vendorMessageMarkEST", "_vendorMessageMarkester", "_vendorMessageIngener", "_vendorFileDEST", "_vendorApplicationdigener", "_vendorMessageInger", "_vendorApplicationdiger", "_vendorMessageDigener", "_vendorMessageSignester", "_vendorMessagedigest", "_vendorFileDest", "_vendorMessagedigess", "_vendorMessageGester", "_vendorApplicationDiger", "_vendorFileSignHash", "_vendorMessageMarkest", "_vendorMessageSignHash", "_vendorMessageEdester", "_vendorMessageIntegHash", "_vendorMessageDigess", "_vendorMessageGEST", "_vendorMessageSignest", "_vendorFileDigHash", "_vendorFileDigested"], "_vendorSig": ["_vendorCig", "_venderPresig", "_vendorAsIG", "_vendorPres2", "_venderUsigs", "_vendSib", "_vendorSature", "_vendorCigma", "_vendorPresub", "_vendPresig", "_vendorUsigs", "_vendSIG", "_vendorSignature", "_vendorAs2", "_venderCigs", "_vendorResigma", "_vendorSignigs", "_venderCig", "_vendorAsib", "_venderUsub", "_vendorPresIG", "_vendorIsib", "_venderUsig", "_venderSigs", "_vendorUsig", "_venderSature", "_vendorsig", "_venderUsIG", "_vendorsub", "_vendorResig", "_vendorCIG", "_vendS2", "_vendorSigma", "_venderSig", "_vendorCigs", "_vendorSuature", "_vendorUsub", "_vendorSuigs", "_vendorS2", "_vendPres2", "_vendorIsig", "_vendorSigs", "_vendorUsIG", "_vendPresib", "_vendPresIG", "_vendSig", "_vendorSignig", "_vendorCature", "_venderPresIG", "_vendorPresature", "_vendorSIG", "_vendorsIG", "_venderCigma", "_vendorResature", "_vendorAsig", "_vendorPresig", "_vendorsigs", "_vendorSub", "_venderSIG", "_vendorSuig", "_vendorSuigma", "_vendorPresigs", "_vendorSignIG", "_venderCature", "_venderSigma", "_venderPresigs", "_vendorIsIG", "_vendorPresib", "_vendorSib", "_venderSub", "_venderPresature", "_vendorIs2", "_vendorResigs"], "_vendorMessageDigestBytes": ["_vendorMessageDestCode", "_vendorMessagedigestsBytes", "_vendorMessageDestedbytes", "_vendorMessagedigestBytes", "_vendorMessageDigestCode", "_vendorMessagedigestBuffer", "_vendorMessageDestBytes", "_vendorMessageDigestsBuffer", "_vendorMessageDigesterbytes", "_vendorMessageDiggestBuffer", "_vendorMessageDiggestBytes", "_vendorMessageDigestBuffer", "_vendorMessageDiggestImpl", "_vendorMessageDigedCode", "_vendorMessageDigestByte", "_vendorMessageDigestedbytes", "_vendorMessageDigedbytes", "_vendorMessageDigestedImpl", "_vendorMessageDestByte", "_vendorMessageDigestedByte", "_vendorMessageDigestsBytes", "_vendorMessageDestedByte", "_vendorMessageDestedCode", "_vendorMessageDigesterCode", "_vendorMessageDigesterBytes", "_vendorMessageDigedBytes", "_vendorMessageDestbytes", "_vendorMessageDigedByte", "_vendorMessageDigestedBuffer", "_vendorMessagedigestsBuffer", "_vendorMessageDigestImpl", "_vendorMessageDestedBytes", "_vendorMessageDigestbytes", "_vendorMessageDigestedBytes", "_vendorMessagedigestImpl", "_vendorMessageDigestedCode", "_vendorMessageDigesterByte", "_vendorMessageDigestsImpl", "_vendorMessagedigestsImpl"], "_vendorSignatureBytes": ["_vendorSignalbytes", "_vendorSignaturebytes", "_vendorSignatureParts", "_vendorSignmentBytes", "_vendorDesignmentBytes", "_vendorDesignaturebytes", "_vendorSignmentParts", "_vendorSignifierParts", "_vendorDesignatureBytes", "_vendorSignalBytes", "_vendorSignifierBytes", "_vendorDesignmentbytes", "_vendorSignmentbytes", "_vendorDesignatureParts", "_vendorDesignmentParts", "_vendorSignalParts", "_vendorSignifierbytes"]}}
{"id1": "2396191", "id2": "19667000", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public static Reader getReader(String url) throws MalformedURLException, IOException {\n        if (url.startsWith(\"file:\")) return new FileReader(url.substring(5)); else if (url.startsWith(\"http:\")) return new InputStreamReader(new URL(url).openStream());\n        throw new MalformedURLException(\"Invalid URI schema, file: or http: expected.\");\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromUrlFast", "getLinksFromStringSafe", "getLinksFromStringFast", "getLinksfromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLFast", "getLinksFromURLSafe", "getLinksfromUrlSafe", "getLinksFromUrlfast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksfromUrlfast", "getLinksFromURLfast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromSSLSafe", "getLinksfromURLSafe", "getLinksfromURLfast", "getLinksFromStringfast", "getLinksFromStringSlow", "getLinksFromUrlSlow"], "p_url": ["pxroot", "pklayer", "tp24url", "p__url", "p_link", "tp_link", "tp24root", "pamurl", "pamhtml", "pxline", "p_domain", "e_layer", " p_line", "pe_root", "p24url", "p_layer", "p24file", "p64url", "pkurl", "tp24link", "p_resource", "pxconfig", "tp_file", "p__resource", "pe_config", "piplink", "p64page", "p_name", "pipfile", "p25html", "pamlayer", "ekurl", "e_html", " p_resource", "p__name", "p6url", "tp_root", "p9domain", "p_line", "p6line", "p9service", " p_page", "p64line", "pe_url", "p9resource", "p_root", "p64path", "p6config", "pipurl", "x_resource", "p25layer", "pe_line", "eklayer", "pfurl", "p_page", "eklink", "p_config", "e_link", "p24root", "ekhtml", "pxurl", "p_html", " p_path", "p25url", "p__path", "piproot", "p6root", "e_url", " p_name", "x_service", "x_domain", "pflink", "pklink", "p_path", "p9url", "tp24file", "pfpage", "p25link", "pkhtml", "pamlink", "p24link", "pfline", "p_file", "tp_url", "pfroot", "p_service", "pffile", "pfpath"], "x_url": ["x_ssl", " x_log", " x_resource", "x_resource", "x_log", "p_host", " x_ssl", "x_host", "p_conn", "p_loc", "x_loc"], "x_conn": ["x___conn", "x___con", "p_db", "x_conv", "x_client", "x___client", "x___db", "wx_cat", "x_cat", "x_con", "x_db", "wx_con", "p_conn", "wx_conn", "p_client", "p_con", "wx_conv"], "x_is_reader": ["x_ismldraft", "x_ismlstream", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlmanager", "x_is_pointer", "x_is_resource", "x_is_writer", "x_ismlreader"], "x_reader": ["x67reader", "x24stream", "X_reader", "cross_parser", "x_parser", "X_result", "x_stream", "cross8url", "x67url", "x67root", "x8parser", "x8reader", "x24result", "x24parser", "x24reader", "X_stream", "cross_reader", "cross_url", "x8url", "cross8root", "cross_root", "cross8parser", "x67parser", "cross8reader", "x8root", "X_parser"], "x_line": ["ex_cell", "x_record", "x__url", "x_comment", "ex_page", "x24line", "x24comment", "x__line", "xingcell", "ex_line", "xx_link", "xingpage", "x__link", "p_link", "xx_line", "x24link", "ex_record", "p_page", "xx_comment", "xingline", "x__page", "x24lin", "x_cell", "x_lin", "xingrecord", "p_line", "xx_lin"], "e": ["r", "error", "ne", "match", "eu", "m", "eur", "ace", "p", "oe", "ie", "element", "n", "g", "entry", "ue", "ce", "el", "eve", "ee", "ze", "es", "t", "ente", "fe", "code", "se", "esi", "line", "E", "file", " E", "end", "ge", "en", "eb", "ev", "f", "o", "engine", "exec", "edge", "pe", "b", "y", "er", "v", "eps", "ele", "he", "je", "entity", "me", "l", "driver", "body", "d", "ae", "le", "te", "event", "re", "ea", "c", "ec"], "x_match": ["p__match", "x_info", "p_match", "e___matched", "e_meet", "xamreplace", "ext_pattern", "x_group", "xltag", "x__case", "p__url", " x_slice", "xjurl", "x_slice", "xlpattern", "x__replace", "ax5link", "x5match", "x__slice", "ax5info", "x_tag", " x_date", "xJsearch", "x__matched", "e_matched", "x__url", "x_date", "e_match", "x_meet", " x_group", " x__case", "p__matched", "x__pattern", "x__match", "xjmatched", "xjmatch", "ax_info", "xJmember", " x__replace", "ax_case", " x__slice", "e___meet", "x_check", "x___check", "e___check", "xlgroup", "e_check", "xldate", "e___match", "p_matched", " x_tag", "p__pattern", "ax_match", "x___meet", "ext_member", "xlmember", "ax5match", "x5link", "ext_search", "xlmatch", "extJsearch", "xJmatch", "xJpattern", "extJpattern", "p_pattern", "xlsearch", "x5info", " x__match", "x_pattern", "extJmember", "ext_match", "x___matched", "x5case", "x_member", "xamslice", " x_case", "xammatch", "x_case", "x_search", "extJmatch", "x_matched", "x_replace", "x___match", "xjpattern", "ax_link", "ax5case", " x_replace", "xamcase"], "x_dir": ["xnetdir", " x_group", "x6dir", " x_file", "x_group", "xnetfile", "xneturl", "x6url", "x6group", "x_file", "xnetgroup", "x6file"], "x_root": ["xml_alias", "x7root", "x_path", "x_alias", "x_directory", "xml_directory", "x7directory", "x7alias", "x7path", "xml_root", "xml_path"], "x_links": ["x_lines", "x67points", " x_points", "x_points", " x_lines", "x67ids", "x67lines", "x67links", " x_ids", "x_ids"], "x_texts": ["x_paths", "x_urls", "x_pathls", "x_textes", "x_textches", "x_pathches", "x_logches", "x_urles", "x_pathes", "x_textls", "x_loges", "x_logls", "x_urlls", "x_urlches", "x_logs"], "x_buf": ["x1tmp", "x64uf", "x___buf", "ex__buf", "x_buff", "x1cb", "x64rc", "x1buf", "x_cb", "ex__buff", "x_tmp", "x__tmp", "ex__tmp", "ex_cb", "x_rc", "y__rc", "y__bag", "X_wb", "ex_tmp", "X_buff", "x___uf", "x_bag", "ex__cb", "x64bag", "y_bag", "x___bag", "X_buffer", "y__buf", "x_buffer", "x64buf", "x__uf", "x___rc", "x_wb", "x__buffer", "ex_buf", "x__buf", "x1buff", "y_rc", "y__uf", "y_buf", "x__wb", "ex_buff", "x__cb", "y_uf", "X_buf", "x__bag", "x__buff", "x_uf", "x__rc"], "x_matches": ["xKtexthes", "x_patches", "x_textings", "x_matcher", "x_Matchers", "x__matures", "x_bathes", "x_attcks", "x_morhes", "x_matcks", "xKmatches", "x_texthes", "x_matchcks", "x__matchers", "x_patcher", "x_morches", "x_matchers", "x_attched", "xKtextoms", "x_matchoms", "x_matings", "x_atthes", "x_textoms", "x_calches", "x_patchers", "x_calings", "x_caloms", "x_matchings", "x_calhes", "xKmatings", "x_locches", "x_matoms", "x_locched", "x_matchches", "x_matchchers", "x_batches", "xKmathes", "x__mathes", "x_mathes", "x_patcks", "xKtextings", "x_loches", "x_Matcher", "x_Matures", "x_matures", "xKmatoms", "x_locting", "x_textches", "x_matting", "x_attches", "x_matchcher", "x_matchting", "x_morched", "x_matchched", "x_Mathes", "x_pathes", "x__matches", "x_patched", "xKtextches", "x_morting", "x_batures", "x_batchers", "x_matched", "x_Matches", "x_matchhes"], "x_page": ["X_url", "X_line", "tx_feed", "tx_link", "tx_page", "ex_page", "ex_loc", "xerfeed", "x67link", "x67page", "ex_link", "xerline", "x_path", "x67file", "xerpage", "X_path", "xerlink", "x67loc", "ex_file", "x_loc", "tx_line", "x_file", "x_feed", "X_page"], "x_link": ["ex_page", "xpubloc", "ex_line", "ex_url", "ex_link", " x_loc", "xpubtarget", "x_target", "xpublink", "x_loc", " x_target", "xpubline"], "i": ["r", "ai", "in", "j", "p", "n", "ie", "eni", "key", "multi", "ix", "phi", "id", "ci", "gi", "info", "ui", "a", "zi", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "count", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "oi", "it", "di", "hi", "si", "chi", "qi", "uri", "iv", "I", "c"]}}
{"id1": "2396191", "id2": "20275821", "code1": "    public static Vector[] getLinksFromURLFast(String p_url) throws Exception {\n        timeCheck(\"getLinksFromURLFast \");\n        URL x_url = new URL(p_url);\n        URLConnection x_conn = x_url.openConnection();\n        InputStreamReader x_is_reader = new InputStreamReader(x_conn.getInputStream());\n        BufferedReader x_reader = new BufferedReader(x_is_reader);\n        String x_line = null;\n        RE e = new RE(\"(.*/)\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        REMatch x_match = e.getMatch(p_url);\n        String x_dir = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"(http://.*?)/?\", RE.REG_ICASE);\n        x_match = e.getMatch(p_url);\n        String x_root = p_url.substring(x_match.getSubStartIndex(1), x_match.getSubEndIndex(1));\n        e = new RE(\"<a href=\\\"?(.*?)\\\"?>(.*?)</a>\", RE.REG_ICASE);\n        System.out.println(\"RE: \" + e.toString());\n        Vector x_links = new Vector(100);\n        Vector x_texts = new Vector(100);\n        StringBuffer x_buf = new StringBuffer(10000);\n        REMatch[] x_matches = null;\n        timeCheck(\"starting parsing \");\n        while ((x_line = x_reader.readLine()) != null) {\n            x_buf.append(x_line);\n        }\n        String x_page = x_buf.toString();\n        String x_link = null;\n        x_matches = e.getAllMatches(x_page);\n        for (int i = 0; i < x_matches.length; i++) {\n            x_link = x_page.substring(x_matches[i].getSubStartIndex(1), x_matches[i].getSubEndIndex(1));\n            if (x_link.indexOf(\"mailto:\") != -1) continue;\n            x_link = toAbsolute(x_root, x_dir, x_link);\n            x_links.addElement(x_link);\n            x_texts.addElement(x_page.substring(x_matches[i].getSubStartIndex(2), x_matches[i].getSubEndIndex(2)));\n        }\n        Vector[] x_result = new Vector[2];\n        x_result[0] = x_links;\n        x_result[1] = x_texts;\n        timeCheck(\"end parsing \");\n        return x_result;\n    }\n", "code2": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getLinksFromURLFast": ["getLinksFromUrlFast", "getLinksFromStringSafe", "getLinksFromStringFast", "getLinksfromUrlSlow", "getLinksfromURLFast", "getLinksFromSSLFast", "getLinksFromURLSafe", "getLinksfromUrlSafe", "getLinksFromUrlfast", "getLinksfromUrlFast", "getLinksfromURLSlow", "getLinksFromURLSlow", "getLinksFromUrlSafe", "getLinksfromUrlfast", "getLinksFromURLfast", "getLinksFromSSLfast", "getLinksFromSSLSlow", "getLinksFromSSLSafe", "getLinksfromURLSafe", "getLinksfromURLfast", "getLinksFromStringfast", "getLinksFromStringSlow", "getLinksFromUrlSlow"], "p_url": ["pxroot", "pklayer", "tp24url", "p__url", "p_link", "tp_link", "tp24root", "pamurl", "pamhtml", "pxline", "p_domain", "e_layer", " p_line", "pe_root", "p24url", "p_layer", "p24file", "p64url", "pkurl", "tp24link", "p_resource", "pxconfig", "tp_file", "p__resource", "pe_config", "piplink", "p64page", "p_name", "pipfile", "p25html", "pamlayer", "ekurl", "e_html", " p_resource", "p__name", "p6url", "tp_root", "p9domain", "p_line", "p6line", "p9service", " p_page", "p64line", "pe_url", "p9resource", "p_root", "p64path", "p6config", "pipurl", "x_resource", "p25layer", "pe_line", "eklayer", "pfurl", "p_page", "eklink", "p_config", "e_link", "p24root", "ekhtml", "pxurl", "p_html", " p_path", "p25url", "p__path", "piproot", "p6root", "e_url", " p_name", "x_service", "x_domain", "pflink", "pklink", "p_path", "p9url", "tp24file", "pfpage", "p25link", "pkhtml", "pamlink", "p24link", "pfline", "p_file", "tp_url", "pfroot", "p_service", "pffile", "pfpath"], "x_url": ["x_ssl", " x_log", " x_resource", "x_resource", "x_log", "p_host", " x_ssl", "x_host", "p_conn", "p_loc", "x_loc"], "x_conn": ["x___conn", "x___con", "p_db", "x_conv", "x_client", "x___client", "x___db", "wx_cat", "x_cat", "x_con", "x_db", "wx_con", "p_conn", "wx_conn", "p_client", "p_con", "wx_conv"], "x_is_reader": ["x_ismldraft", "x_ismlstream", "x_is_manager", "x_is_stream", "x_is_draft", "x_ismlmanager", "x_is_pointer", "x_is_resource", "x_is_writer", "x_ismlreader"], "x_reader": ["x67reader", "x24stream", "X_reader", "cross_parser", "x_parser", "X_result", "x_stream", "cross8url", "x67url", "x67root", "x8parser", "x8reader", "x24result", "x24parser", "x24reader", "X_stream", "cross_reader", "cross_url", "x8url", "cross8root", "cross_root", "cross8parser", "x67parser", "cross8reader", "x8root", "X_parser"], "x_line": ["ex_cell", "x_record", "x__url", "x_comment", "ex_page", "x24line", "x24comment", "x__line", "xingcell", "ex_line", "xx_link", "xingpage", "x__link", "p_link", "xx_line", "x24link", "ex_record", "p_page", "xx_comment", "xingline", "x__page", "x24lin", "x_cell", "x_lin", "xingrecord", "p_line", "xx_lin"], "e": ["r", "error", "ne", "match", "eu", "m", "eur", "ace", "p", "oe", "ie", "element", "n", "g", "entry", "ue", "ce", "el", "eve", "ee", "ze", "es", "t", "ente", "fe", "code", "se", "esi", "line", "E", "file", " E", "end", "ge", "en", "eb", "ev", "f", "o", "engine", "exec", "edge", "pe", "b", "y", "er", "v", "eps", "ele", "he", "je", "entity", "me", "l", "driver", "body", "d", "ae", "le", "te", "event", "re", "ea", "c", "ec"], "x_match": ["p__match", "x_info", "p_match", "e___matched", "e_meet", "xamreplace", "ext_pattern", "x_group", "xltag", "x__case", "p__url", " x_slice", "xjurl", "x_slice", "xlpattern", "x__replace", "ax5link", "x5match", "x__slice", "ax5info", "x_tag", " x_date", "xJsearch", "x__matched", "e_matched", "x__url", "x_date", "e_match", "x_meet", " x_group", " x__case", "p__matched", "x__pattern", "x__match", "xjmatched", "xjmatch", "ax_info", "xJmember", " x__replace", "ax_case", " x__slice", "e___meet", "x_check", "x___check", "e___check", "xlgroup", "e_check", "xldate", "e___match", "p_matched", " x_tag", "p__pattern", "ax_match", "x___meet", "ext_member", "xlmember", "ax5match", "x5link", "ext_search", "xlmatch", "extJsearch", "xJmatch", "xJpattern", "extJpattern", "p_pattern", "xlsearch", "x5info", " x__match", "x_pattern", "extJmember", "ext_match", "x___matched", "x5case", "x_member", "xamslice", " x_case", "xammatch", "x_case", "x_search", "extJmatch", "x_matched", "x_replace", "x___match", "xjpattern", "ax_link", "ax5case", " x_replace", "xamcase"], "x_dir": ["xnetdir", " x_group", "x6dir", " x_file", "x_group", "xnetfile", "xneturl", "x6url", "x6group", "x_file", "xnetgroup", "x6file"], "x_root": ["xml_alias", "x7root", "x_path", "x_alias", "x_directory", "xml_directory", "x7directory", "x7alias", "x7path", "xml_root", "xml_path"], "x_links": ["x_lines", "x67points", " x_points", "x_points", " x_lines", "x67ids", "x67lines", "x67links", " x_ids", "x_ids"], "x_texts": ["x_paths", "x_urls", "x_pathls", "x_textes", "x_textches", "x_pathches", "x_logches", "x_urles", "x_pathes", "x_textls", "x_loges", "x_logls", "x_urlls", "x_urlches", "x_logs"], "x_buf": ["x1tmp", "x64uf", "x___buf", "ex__buf", "x_buff", "x1cb", "x64rc", "x1buf", "x_cb", "ex__buff", "x_tmp", "x__tmp", "ex__tmp", "ex_cb", "x_rc", "y__rc", "y__bag", "X_wb", "ex_tmp", "X_buff", "x___uf", "x_bag", "ex__cb", "x64bag", "y_bag", "x___bag", "X_buffer", "y__buf", "x_buffer", "x64buf", "x__uf", "x___rc", "x_wb", "x__buffer", "ex_buf", "x__buf", "x1buff", "y_rc", "y__uf", "y_buf", "x__wb", "ex_buff", "x__cb", "y_uf", "X_buf", "x__bag", "x__buff", "x_uf", "x__rc"], "x_matches": ["xKtexthes", "x_patches", "x_textings", "x_matcher", "x_Matchers", "x__matures", "x_bathes", "x_attcks", "x_morhes", "x_matcks", "xKmatches", "x_texthes", "x_matchcks", "x__matchers", "x_patcher", "x_morches", "x_matchers", "x_attched", "xKtextoms", "x_matchoms", "x_matings", "x_atthes", "x_textoms", "x_calches", "x_patchers", "x_calings", "x_caloms", "x_matchings", "x_calhes", "xKmatings", "x_locches", "x_matoms", "x_locched", "x_matchches", "x_matchchers", "x_batches", "xKmathes", "x__mathes", "x_mathes", "x_patcks", "xKtextings", "x_loches", "x_Matcher", "x_Matures", "x_matures", "xKmatoms", "x_locting", "x_textches", "x_matting", "x_attches", "x_matchcher", "x_matchting", "x_morched", "x_matchched", "x_Mathes", "x_pathes", "x__matches", "x_patched", "xKtextches", "x_morting", "x_batures", "x_batchers", "x_matched", "x_Matches", "x_matchhes"], "x_page": ["X_url", "X_line", "tx_feed", "tx_link", "tx_page", "ex_page", "ex_loc", "xerfeed", "x67link", "x67page", "ex_link", "xerline", "x_path", "x67file", "xerpage", "X_path", "xerlink", "x67loc", "ex_file", "x_loc", "tx_line", "x_file", "x_feed", "X_page"], "x_link": ["ex_page", "xpubloc", "ex_line", "ex_url", "ex_link", " x_loc", "xpubtarget", "x_target", "xpublink", "x_loc", " x_target", "xpubline"], "i": ["r", "ai", "in", "j", "p", "n", "ie", "eni", "key", "multi", "ix", "phi", "id", "ci", "gi", "info", "ui", "a", "zi", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "count", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "oi", "it", "di", "hi", "si", "chi", "qi", "uri", "iv", "I", "c"]}}
{"id1": "14609912", "id2": "7118860", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    private String getEncoding() throws IOException {\n        BufferedReader reader = null;\n        String encoding = null;\n        try {\n            URLConnection connection = url.openConnection();\n            Map<String, List<String>> header = connection.getHeaderFields();\n            for (Map.Entry<String, List<String>> entry : header.entrySet()) {\n                if (entry.getKey().toLowerCase().equals(\"content-type\")) {\n                    String item = entry.getValue().toString().toLowerCase();\n                    if (item.contains(\"charset\")) {\n                        encoding = extractEncoding(item);\n                        if (encoding != null && !encoding.isEmpty()) return encoding;\n                    }\n                }\n            }\n            reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) {\n                line = line.toLowerCase();\n                if (line.contains(\"charset\") || line.contains(\"encoding\")) {\n                    encoding = extractEncoding(line);\n                    if (encoding != null && !encoding.isEmpty()) return encoding;\n                }\n            }\n            return STANDARDENCODING;\n        } finally {\n            if (reader != null) reader.close();\n        }\n    }\n", "label": 0, "substitutes": {"lastModified": ["lastmodification", "lastMerIFIED", "nextMODified", "lastModached", "lastMODified", "nextMODification", "lastMerached", "nextMODIFIED", "lastmodified", "nextModification", "lastModification", "nextModified", "lastMODification", "lastmodIFIED", "lastMerification", "nextModached", "lastmodached", "lastModIFIED", "nextMODached", "nextModIFIED", "lastMODIFIED", "lastMODached", "lastMerified"], "url": ["image", "client", "sl", "obj", "host", "object", "ls", "id", "page", "server", "address", "open", "loc", "connection", "location", "http", "URL", "resource", "path", "ssl", "file", "str", "secure", "link", "Url", "base", "data", "org", "https", "ll", "name", "l", "browser", "string", "href", "uri", "source", "config", "www"], "conn": ["client", "connect", "Conn", "obj", "ctx", "n", "sync", "cp", "rc", "cn", "nt", "ci", "cache", "coll", "cb", "open", "loc", "ann", "connection", "nc", "http", "cm", "ssl", "con", "conf", "ch", "enc", "col", "exec", "serv", "conv", "ac", "rt", "ct", "l", "Connection", "act", "config", "c"]}}
{"id1": "21092340", "id2": "19910627", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"addToArchive": ["addToSlives", "addToSlIVE", "addToAsIVE", "addtoArchively", "addtoAsive", "addToAdaptives", "addtoAsively", "addtoAsives", "addToArchIVE", "addtoArchIVE", "addtoAsIVE", "addToAsive", "addToArchively", "addToSlively", "addToArchives", "addToAdaptively", "addToAsively", "addToSlive", "addToAdaptive", "addtoArchive", "addToAdaptIVE", "addToAsives", "addtoArchives"], "pod": ["pad", "component", "p", "host", "ce", "object", "tmp", "Pod", "ad", "pkg", "po", "cache", "per", "child", "module", "od", "proc", "product", "post", "part", "pi", "peer", "plug", "zip", "pe", "loader", "pc", "node", "cer", "ods", "bean", "table", "project", "plugin", "pot", "pid", "pl"], "podArchiveOutputStream": ["podArchivesOutputFile", "podArchivingOutputPath", "podArchIVEOutputDirectory", "podArchiveOutputResource", "podArchiveWritePath", "podArchiveFileFile", "podArchiveIOResource", "podArchivesOutputStream", "podArchiveIOStream", "podArchIVEOutputSteam", "podArchIVEInputFile", "podArchIVEOutputFile", "podArchiveWriteStream", "podArchivesFileSteam", "podArchiveOperationStream", "podArchiveOutputFile", "podArchiveOperationFile", "podArchiveFilePath", "podArchiveByteDirectory", "podArchiveOperationSteam", "podArchiveInputDirectory", "podArchiveByteSteam", "podArchivesFileStream", "podArchiveOutputSteam", "podArchIVEInputDirectory", "podArchIVEInputStream", "podArchiveByteStream", "podArchiveIOSteam", "podArchivingOutputSteam", "podArchiveOutputDirectory", "podArchiveOutputPath", "podArchivingWriteStream", "podArchiveOperationResource", "podArchivingOutputFile", "podArchivingOutputStream", "podArchivesOutputResource", "podArchiveByteFile", "podArchiveInputSteam", "podArchiveIOFile", "podArchiveInputStream", "podArchIVEInputSteam", "podArchiveWriteFile", "podArchiveFileStream", "podArchiveFileSteam", "podArchivesOutputSteam", "podArchivesFileResource", "podArchiveFileResource", "podArchiveInputFile", "podArchiveIODirectory", "podArchivesFileFile", "podArchivingWriteSteam", "podArchiveInputPath", "podArchiveWriteSteam", "podArchIVEOutputStream", "podArchivingWriteFile", "podArchivingWritePath", "podArchiveFileDirectory"], "filename": ["ppa", "Filename", "label", "files", "sequence", "title", "il", "route", "directory", "archive", "sf", "module", "alias", "property", "location", "path", "fp", "word", "fn", "FILE", "file", "which", "kn", "f", "url", "prefix", "binary", "nil", "platform", "download", "loader", "fil", "database", "subject", "kl", "SourceFile", "application", "name", "l", "ename", "string", "named", "folder", "uri", "dll", "username"], "source": ["image", "service", "sl", "stream", "src", "output", "use", "proxy", "input", "slice", "slave", "copy", "parent", "archive", "stack", "target", "result", "connection", "path", "resource", "file", "Source", "url", "unit", "zip", "loader", "SOURCE", "text", "document", "driver", "reader", "string", "seed", "uri", "ource", "config"], "entry": ["image", "iterator", "auto", "r", "obj", "ie", "element", "stream", "object", "feed", "e", "parent", "archive", "address", "child", "result", "or", "pointer", "connection", "index", "resource", "path", "se", "line", "row", "file", "post", "ge", "letter", "this", "zip", "data", "article", "it", "record", "Entry", "reader", "string", "add", "event"]}}
{"id1": "19147279", "id2": "14733078", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    private static String encrypt(String algorithm, String password, Long digestSeed) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(algorithm);\n            digest.reset();\n            digest.update(password.getBytes(\"UTF-8\"));\n            digest.update(digestSeed.toString().getBytes(\"UTF-8\"));\n            byte[] messageDigest = digest.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString((0xf0 & messageDigest[i]) >> 4));\n                hexString.append(Integer.toHexString(0x0f & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new RuntimeException(e);\n        } catch (NullPointerException e) {\n            return new StringBuffer().toString();\n        }\n    }\n", "label": 0, "substitutes": {"actualizarDatosFinal": [" actualizarDatOSFinal", " actualizarDatosResult", " actualizarDatocFinal", " actualizarDatocTotal", " actualizarBatosTotal", " actualizarDataoComplete", " actualizarDataoTotal", " actualizarDatOSComplete", " actualizarBatocResult", " actualizarDataoFinal", " actualizarBatosResult", " actualizarDatOSTotal", " actualizarBatocFinal", " actualizarDataoResult", " actualizarDatOSResult", " actualizarBatocComplete", " actualizarBatosFinal", " actualizarDatosTotal", " actualizarDatocComplete", " actualizarDatocResult", " actualizarBatocTotal", " actualizarBatosComplete", " actualizarDatosComplete"], "idJugadorDiv": ["idJudadeDec", "idJugordDec", "idJugaderDec", "idJugordOrd", "idJugrarDoc", "idJugaderDoc", "idJugaderDIV", "idJubordDiv", "idJugordDiv", "idJugadorDIV", "idJubadorDec", "idJugordDIV", "idJudadorDiv", "idJubadorDoc", "idJugadorDec", "idJudadorDIV", "idJudadorDec", "idJugrarDiv", "idJugaderDiv", "idJubordDoc", "idJugordDoc", "idJugadeDec", "idJugadorOrd", "idJubordOrd", "idJugaderOrd", "idJugadorDoc", "idJubordDec", "idJudadeDIV", "idJubadorOrd", "idJubadorDiv", "idJugadeDiv", "idJugadeDIV", "idJugrarOrd", "idJugrarDec", "idJudadeDiv"], "idRonda": ["idrora", "idRona", "idRado", "idRhonda", "idGrora", "idRhanna", " idRora", "pidRhado", "idRhado", "idRora", "idRhona", " idRanna", "pidRhora", "pidRado", " idrora", "idGrado", "idRhora", "idrado", "idrona", "pidRonda", "idGronda", "pidRhona", " idronda", "idGrona", " idRona", "pidRhonda", "idronda", "idranna", " idrona", " idranna", "pidRona", "pidRora", "idRanna"], "unjxdxr": ["unjxfexr", "unjddxxR", "unjxdxxl", "unjxdxl", "unjxdddR", "unjxfexR", "unjxdxtr", "unjddxl", "unjxdddrs", "unjxdexer", "unjddxxl", "unjxdxrs", "unjxdxtrs", "unjxdxter", "unjxfxR", "unjxdxxr", "unjxfxr", "unjxdddr", "unjxdxxR", "unjxfexrs", "unjddxxer", "unjddxr", "unjxdexl", "unjxdexR", "unjxdxtl", "unjddxer", "unjxdxR", "unjxdexr", "unjxdxer", "unjxdxxer", "unjxdxtR", "unjddxR", "unjxdexrs", "unjddxxr", "unjxfxrs"], "intResult": ["IntReturn", "longResult", "intRes", " intOrder", " intRest", "INTReturn", "intCode", "ntCode", "IntCode", "intReturn", "mintRate", "longRes", "longResponse", "INTRest", "IntRate", "intRate", "ntResult", "IntResponse", "INTResult", "intRest", " intReturn", "mintResult", "ntRes", " intRes", "longCode", "intOrder", "mintOrder", "intResponse", " intRate", "IntRes", "ntResponse", "IntResult", "IntOrder", "INTRes", "mintReturn", "IntRest"], "sql": ["job", "db", "query", "sl", "sync", "msg", "QL", "socket", "comment", "pg", "select", "section", "statement", " SQL", "limit", "SQL", "sb", "conn", "params", "ssl", "fn", "str", "plan", "url", "sq", "log", "printf", "dl", "database", "eps", "joined", "mt", "search", "l", "ql", "string", "nl", "cmd", "join", "dd", "pr"], "connection": ["position", "db", "client", "connect", "BC", "writer", "query", "ctx", "cp", "relation", "socket", "cc", "proxy", "character", "context", "pg", "environment", "section", "statement", "handler", "server", "conn", "loc", "bc", "container", "index", "manager", "con", "function", "connected", "engine", "session", "log", "database", "collection", "application", "document", "driver", "table", "reader", "ion", "communication", "Connection", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "details", "ping", "p", "PS", "qs", "pp", "pa", "cp", "bs", "cs", "proxy", "pg", "syn", "rs", "ls", "ns", "ips", "po", "conn", "ks", "pers", "posts", "params", "ds", "changes", "ts", "relations", "pe", "eps", "hs", "ins", "pc", "ops", "mp", "Ps", "pse", "gs", "pps", "ms", "ports", "pr", "sp"]}}
{"id1": "9996334", "id2": "15768167", "code1": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"generateToken": ["generATEKey", "generatedTokens", " GenerateToken", "generateTokens", "generationKey", " GenerATESecret", " GenerateSecret", "generATESecret", "generATEToken", "generATETokens", "generationTokens", " GenerateTokens", "generateKey", "generationSecret", "generatedKey", "generatedToken", " GenerateKey", " GenerATEKey", "generatedSecret", "generationToken", "generateSecret", " GenerATETokens", " GenerATEToken"], "code": ["mac", "next", "buffer", "script", "key", "output", "input", "ode", "id", "cache", "address", "info", "state", "content", "message", "coded", "codes", "value", "str", "prefix", "data", "token", "tag", "text", "name", "password", "body", "string", "header", "Code", "cod", "hash", "source", "config", "c", "hex"], "md": ["mm", "mac", "mo", "ind", "m", "kg", "dig", "grad", "ad", "po", "mu", "pd", "metadata", "ma", "od", "cd", "rm", "editor", "amd", "mb", "cm", "df", "wd", "ds", "gd", "mand", "bd", "f", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "mc", "mod", "mag", "hd", "d", "ms", "meta", "hash", "cmd", "dd", " MD"], "bytes": ["words", "files", "output", "les", "s", "bs", "units", "strings", "ips", "es", "address", "lines", "objects", "boot", "seconds", "tes", "bps", "Bytes", "codes", "pieces", "classes", "bits", "binary", "buf", "zip", "data", "blocks", "b", "values", "groups", "bles", "vs", "bin", "body", "string", "parts", "outs"]}}
{"id1": "12055086", "id2": "942693", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeletting", " copyDequeing", " copydeleting", " copyDeletter", " copyDeletging", " copydeleing", " copyDequeter", " copydeletter", " copyDeleteting", " copydeletting", " copyDeleing", " copyDeleteter", " copyDeleteging", " copyDequeting", " copyDequeging", " copydeleging", " copyDeleging", " copyDeleteing", " copydeletging", " copyDeleter", " copydeleter"], "source": ["image", "service", "ie", "stream", "src", "master", "i", "view", "use", "s", "input", "copy", "e", "route", "sin", "archive", "cache", "from", "target", "connection", "inner", "path", "resource", "file", "Source", "storage", "down", "iter", "f", "base", "SOURCE", "site", "reader", "remote", "ource", "config", "ources"], "dest": ["de", "src", "master", "class", "default", "comb", "tmp", "opt", "slice", "slave", "thin", "home", "Dest", "target", "result", "content", "desc", "path", "orig", "exit", "destruct", "later", "img", "file", "dist", "dir", "die", "wb", "null", "temp", "flat", "trans", "done", "bin", " destination", "folder", "destroy", "pipe"], "buf": ["pad", "bp", "buffer", "seq", "bytes", "batch", "bf", "ctx", "br", "off", "pos", "src", "queue", "cp", "rc", "ff", "tmp", "feed", "Buffer", "port", "loc", "result", "bc", "rb", "fb", "code", "buff", "img", "raw", "uc", "bag", "len", "config", "bh", "bd", "feat", "base", "vec", "data", "append", "b", "cv", "uf", "cmd", "cb", "length", "txt"], "in": ["image", "p", "pin", "n", "inn", "gin", "isin", "src", "i", "is", "stream", "socket", "init", "input", "tin", "thin", "id", "sin", "din", "conn", "plus", "inner", "io", "nin", "rin", "con", "ini", "file", "inside", "min", "f", "url", "exec", "login", "data", "b", "ins", "bin", "In", "again", "IN", "reader", "read", "win", "up", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "n", "i", "output", "socket", "app", "parent", "ex", "conn", "exp", "inner", "ext", "io", "pool", "img", "file", "at", "part", "down", "f", "o", "lib", "exec", "err", "b", "w", "bin", "again", "OUT", "outs", "outer", "win", "up", "inc"], "count": ["ind", "buffer", "size", "max", "n", "cond", "Count", "all", "key", "current", "use", "feed", "parent", "id", "limit", "coll", "cache", "val", "child", "length", "handle", "code", "sum", "index", "num", "weight", "path", "pool", "part", "len", "start", "f", "close", "depth", "ch", "base", "zip", "type", "b", "offset", "number", "allow", "name", "lock", "read", "c"]}}
{"id1": "7276377", "id2": "2381663", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    @Test(expected = GadgetException.class)\n    public void malformedGadgetSpecIsCachedAndThrows() throws Exception {\n        HttpRequest request = createCacheableRequest();\n        expect(pipeline.execute(request)).andReturn(new HttpResponse(\"malformed junk\")).once();\n        replay(pipeline);\n        try {\n            specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n            fail(\"No exception thrown on bad parse\");\n        } catch (GadgetException e) {\n        }\n        specFactory.getGadgetSpec(createContext(SPEC_URL, false));\n    }\n", "label": 0, "substitutes": {"checksum": ["decumb", "cksums", "checksums", "ckssum", "decums", "cksumb", "cksum", " checkssum", " checksumb", "checkssum", "decum", " checksums", "checksumb", "decsum"], "url": ["image", "fr", "email", "service", "sl", "cert", "stream", "host", "src", "feed", "proxy", "user", "id", "server", "rule", "address", "loc", "or", "connection", "filename", "http", "location", "URL", "path", "resource", "ssl", "manager", "file", "str", "f", "Url", "base", "download", "gl", "loader", "ll", "text", "name", "l", "string", "href", "ur", "uri", "source", "config", "username"], "algorithm": ["malgebra", "algebra", "algo", "ALgebra", "Alignment", "exgo", "malignment", "Algebra", "Algorithm", " algorith", " alignment", " algo", "allgorithm", "allgo", "allgorith", "Algorith", "ALgo", "malgorith", " algebra", "ALgorith", "malgo", "alignment", "exgorithm", "allgebra", "malgorithm", "exgebra", "Algo", "exgorith", "algorith", "ALgorithm"], "messageDigest": ["messageRegator", "messageDester", "messageDigade", "messagediger", "messageMixpe", "messageDiger", "messageDigge", "messageDest", "MessageDest", "messageDigess", "messagedigester", "messageSignester", "messageDesignator", "messageDigester", "messageMixest", "messageDse", "messageSignge", "messageDge", "messageRegess", "MessageMixpe", "messageDesignester", "MessageDesignest", "MessageDester", "messageDade", "MessageDigest", "MessageSignester", "messagedigpe", "messageDesigness", "MessageDigess", "MessageDesignester", "MessageDigade", "messageDigpe", "MessageMixer", "messageDpe", "messagedigade", "messageMixer", "messagedigse", "messageSignest", "MessageMixest", "MessageDigse", "messagedigess", "MessageDigator", "messageDigator", "MessageDesignator", "messagedigge", "MessageSignest", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDigse", "MessageDigge", "MessageDade", "MessageSignge", "MessageSignse", "MessageDse", "MessageDesigness", "messageDesignest", "messageSignse", "messagedigator", "messagedigest", "messageRegest", "messageRegester", "MessageDigpe", "MessageDigester"], "bytes": ["items", "vals", "os", "buffer", "words", "size", "ipes", "steps", "files", "loads", "limits", "bs", "units", "cells", "resses", "ls", "ips", "reads", "es", "lines", "gets", "objects", "boot", "seconds", "tes", "bps", "Bytes", "resources", "frames", "pieces", "classes", "bits", "pages", "ones", "zip", "blocks", "values", "errors", "eps", "rows", "bles", "vs", "parts", "outs"], "in": ["r", "fr", "m", "client", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "impl", "input", "version", "id", "ex", "din", "conn", "fe", "a", "inner", "nin", "ssl", "out", "ini", "con", "rin", "file", "kin", "min", "f", "serv", "login", "data", "ac", "err", "b", "token", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "gen", "win", "source", "c", "inc"], "nBytesRead": ["nPagesLength", " nBytesCount", "nFramesFound", "nFramesLength", "nByteFound", "nBytesLength", "nCharactersLength", "nBytesCount", "nBytesFound", "nWordsWritten", "nWordsRead", " nByteCount", " nByteLength", "nBytesLoad", "nPartsRead", " nBytesLoad", "nCharactersRead", " nBytesFound", " nByteFound", " nByteWritten", " nByteRead", "nByteLoad", "nPagesRead", "nCharactersCount", "nPagesFound", "nPartsWritten", "nByteRead", " nBytesLength", "nPartsLoad", "nFramesWritten", "nBytesWritten", "nByteCount", "nWordsLength", "nByteWritten", "nFramesRead", "nPagesWritten", " nByteLoad", "nCharactersWritten", " nBytesWritten", "nByteLength", "nWordsCount"], "checksumValue": ["checksupString", "checksramArray", " checkssumString", "checkssumText", "checksummVal", "checksummArray", " checkssumVal", "checksupValue", " checkssumText", " checksumString", "checksumberValue", "checkssumValue", " checkssumData", " checksumText", "checksramPath", "checksummValue", "checksumData", "checksumArray", "checksumberText", " checkssumPath", "checkssumVal", "checksummPath", " checksumVal", "checksupData", " checkssumArray", " checkssumValue", "checksupText", "checksumString", "checksramValue", "checksumText", "checkssumArray", "checksumberData", " checksumArray", "checksumPath", " checksumData", "checksumberString", "checkssumPath", "checkssumData", " checksumPath", "checksramVal", "checkssumString", "checksumVal"]}}
{"id1": "3024992", "id2": "19113613", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_nulls"], "baout": ["Baash", "aeOUT", "BAin", "bonin", "baouts", "BaOut", "BAout", "BAouter", " bain", "bain", "aeouter", " baOut", "Bain", "baOUT", "baash", "bonash", "Baio", "baio", "BAio", "BaOUT", "BAOut", "Baout", "BAouts", "baouter", "Baouter", "bonout", "bonio", "aeout", " baouts", "baOut", "Baouts", "BAOUT", "aeOut", "BAash"], "out": ["Out", "r", "in", "buffer", "flow", "output", "class", "s", "write", "copy", "Writer", "array", "io", "line", "file", "Output", "null", "err", "er", "test", "reader", "outs", "outer", "OUT", "able"], "writer": ["r", "in", "buffer", "worker", "entry", "output", "class", "write", "copy", "ee", "Writer", "pointer", "writers", "io", "work", "file", "riter", "x", "rw", "letter", "null", "unit", "data", "temp", "wer", "builder", "her", "player", "er", "wa", "w", "driver", "writ", "reader", "outer", "writing", "source", "RW"]}}
{"id1": "10131427", "id2": "2199604", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "inn", "i", "input", "copy", "id", "ex", "diff", "or", "a", "inner", "index", "resource", "io", "work", "ini", "at", "file", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "source", "config", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "off", "n", "output", "object", "copy", "ex", "cache", "conn", "target", "connection", "io", "dest", "file", "at", "part", "x", "prefix", "o", "base", "exec", "data", "temp", "v", "w", "name", "external", "string", "point", "outs", "source", "OUT", "c"], "sourceChannel": ["srcChannel", "SourceStream", " sourceSocket", "ourceChan", "sourceChan", " sourceStream", "ourcechannel", "srcChan", "ourceStream", " sourceQueue", "targetStream", "srcQueue", "srcConnection", "ourceChannel", "targetChannel", "sourceQueue", "SourceSocket", "targetchannel", "SourceConnection", "targetChan", "sourceStream", "srcStream", " sourceManager", "sourceManager", "sourceConnection", " sourceChan", "srcSocket", " sourcechannel", "SourceChannel", " sourceConnection", "Sourcechannel", "srcManager", "SourceManager", "SourceQueue", "sourcechannel", "SourceChan", "sourceSocket"], "destinationChannel": ["DestinationStream", "DestinationChannel", "destationChan", "destinatedChannel", "DestinationCh", "destinateConnection", "Destinatorchannel", "destinatedConnection", "destinationsChannel", "DestinationConnection", "destinatorConnection", "destinatedCh", "destinatechannel", "destinationschannel", "destinationCh", "destationchannel", "destinateStream", "destationConnection", "destationChannel", "destinatorchannel", "destinationConnection", "destinatorChannel", "destinationchannel", "Destinationchannel", "destinateChannel", "destationCh", "DestinationChan", "destinationsStream", "DestinatorConnection", "destinationStream", "destinationsConnection", "destinatorCh", "destinatorChan", "DestinatorCh", "DestinatorChan", "DestinatorChannel", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "16388708", "id2": "19276022", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "11153282", "id2": "16798376", "code1": "    public static boolean existsURL(String urlStr) {\n        try {\n            URL url = ProxyURLFactory.createHttpUrl(urlStr);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.connect();\n            int responseCode = con.getResponseCode();\n            con.disconnect();\n            return !(responseCode == HttpURLConnection.HTTP_NOT_FOUND);\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"existsURL": ["exiesURL", "exainsUrl", "contistsurl", "exainsURL", "exitsUrl", "existsURI", "exiesURI", "containsUrl", "contistsUrl", "exitsURI", "exitsURL", "containsurl", "exainsURI", "exitsurl", "exainsurl", "containsURL", "existsurl", "exiesurl", "containsURI", "exiesUrl", "existsUrl", "contistsURI", "contistsURL"], "urlStr": ["resourceString", "uriSTR", "uriSt", "urlUrl", " urlUrl", "urlSt", "uriString", "httpStr", "URLUrl", " urlSt", "urlSTR", "httpSTR", "URLString", "URLSt", "resourceSt", "URLStr", " urlSTR", "resourceUrl", "resourceStr", "httpString", "urlString", "httpSt", " urlString", "uriStr"], "url": ["blog", "client", "sl", "ul", "host", "el", "proxy", "fl", "bb", "e", "ls", "lc", "www", "server", "bel", "conn", "loc", "open", "connection", "http", "URL", "resource", "aur", "ssl", "fc", "file", "secure", "f", "Url", "api", "base", "log", "b", "ll", "l", "web", "ur", "config", "c"], "con": ["plain", "client", "ca", "connect", "Conn", "fa", "rc", "cc", "cn", "syn", "bn", "common", "fl", "ln", "cons", "on", "CON", "cf", "run", "conn", "open", "ann", "ran", "connection", "bc", "http", "bon", "ver", "cm", "xc", "conf", "fc", "cover", "Con", "x", "ctrl", "en", "close", "exec", "conv", "can", " conn", "ct", "pc", "co", "un", "ocon", "web", "Connection", "gen", "c", "ec"], "responseCode": ["statusCount", "ResponseStatus", "statusType", "ResponseCode", " responsecode", "respCount", "ResponseType", "statusCode", "respStatus", "responseType", "resourceType", "ResponseCount", "statusStatus", "responseStatus", " responseType", "respType", "responseCount", "resourceCode", "respCode", "Responsecode", "responsecode", "resourcecode"]}}
{"id1": "17583193", "id2": "9347451", "code1": "    public boolean populateRecord(int[] attrIDs) throws IOException {\n        if (device == null) {\n            throw new RuntimeException(\"This is local device service record\");\n        }\n        if (attrIDs == null) {\n            throw new NullPointerException(\"attrIDs is null\");\n        }\n        if (attrIDs.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        for (int i = 0; i < attrIDs.length; i++) {\n            if (attrIDs[i] < 0x0000 || attrIDs[i] > 0xffff) {\n                throw new IllegalArgumentException();\n            }\n        }\n        int[] sortIDs = new int[attrIDs.length];\n        System.arraycopy(attrIDs, 0, sortIDs, 0, attrIDs.length);\n        for (int i = 0; i < sortIDs.length; i++) {\n            for (int j = 0; j < sortIDs.length - i - 1; j++) {\n                if (sortIDs[j] > sortIDs[j + 1]) {\n                    int temp = sortIDs[j];\n                    sortIDs[j] = sortIDs[j + 1];\n                    sortIDs[j + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < sortIDs.length - 1; i++) {\n            if (sortIDs[i] == sortIDs[i + 1]) {\n                throw new IllegalArgumentException();\n            }\n            DebugLog.debug0x(\"query for \", sortIDs[i]);\n        }\n        DebugLog.debug0x(\"query for \", sortIDs[sortIDs.length - 1]);\n        return this.bluetoothStack.populateServicesRecordAttributeValues(this, sortIDs);\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"populateRecord": ["poputeRecord", "extractAll", "popractAll", "popractRecord", "extulateAll", "extractInstance", "extractModel", "populatesAll", "popractInstance", "extulateModel", "extractRecord", "poputeModel", "popractModel", "populatesInstance", "extulateRecord", "poputeInstance", "populateModel", "populateInstance", "populatesModel", "populatesRecord", "extulateInstance", "populateAll", "poputeAll"], "attrIDs": ["addrENTS", "tagIDs", "attrids", "attIDS", "attributeIDES", "attrID", "attributeIDs", "sortIDS", "attIDs", "tagIDES", "attENTS", "attributeIDS", "sortID", "addrID", "tagIDS", "attributeENTS", "attrIDS", "addrIDS", "attrIDES", "attrENTS", "attributeids", "attIDES", "attID", "sortIDES", "attids", "addrIDs", "sortids", "attributeID", "tagID"], "i": ["g", "my", "ik", "key", "ci", "gi", "info", "a", "x", "api", "u", "v", "yi", "uri", "I", "length", "ind", "ip", "p", "eni", "is", "multi", "fi", "ix", "phi", "inner", "li", "index", "io", "iu", "bi", "ami", "ti", "b", "mi", "l", "d", "si", "ai", "in", "m", "init", "slice", "e", "id", "cli", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "c", "ki", "h", "left", "ie", "n", "ui", "ori", "ii", "ij", "pi", "f", "ni", "di", "qi"], "sortIDs": ["allIDES", "searchIDs", "ortIDES", "searchids", "allID", "useIDs", "orderADS", "updateID", "updateIDs", "orderFiles", "SortID", " sortUID", "filterID", "ortIDS", "SortIDES", "orderID", "filterIDs", "syncID", " sortID", " sortIDS", "altIDS", " sortADS", "altIDs", "attrID", "sortIDS", "updateIDS", "searchID", "syncIDES", "orderIDES", "ortids", "filterIDS", "altID", "updateIDES", "useIDES", "ortID", "attrADS", "allIDS", "sortID", " sortFiles", "attrFiles", "useIDS", "orderIDs", "attrIDS", "updateFiles", "attrUID", "SortIDs", " sortIDES", " sortids", "sortIDES", "altIDES", "ortIDs", "searchIDES", "ortUID", "orderIDS", "SortUID", "filterUID", "sortADS", "useID", "sortFiles", "SortIDS", "allIDs", "syncIDs", "sortids", "syncIDS", "orderids", "sortUID", "searchIDS"], "j": ["next", "job", "fr", "oj", "p", "h", "n", "ie", "obj", "br", "q", "key", "uj", "J", "ix", "e", "section", "aj", "ui", "last", "adj", "jj", "ja", "dj", "li", "ii", "jl", "z", "bj", "ij", "part", "x", "f", "o", "xi", "k", "jp", "u", "b", "y", "v", "ji", "w", "jc", "di", "je", "l", "d", "js", "jet", "qi", "pr", "left", "jo"], "temp": ["get", "fake", "max", "ed", "ash", " temporary", "key", " Temp", "tmp", "used", " tmp", "Temp", "ex", " result", "orig", "pack", "modified", "needed", "tc", " test", "iter", "tem", "stable", "alt", " original", "porary", "emp", " fake", "flat", "partial", "test", " dummy", " orig", "holder", "wrap", " modified", "tr", "empty", " unused", "non"]}}
{"id1": "949327", "id2": "7908169", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public String execute() {\n        String dir = \"E:\\\\ganymede_workspace\\\\training01\\\\web\\\\user_imgs\\\\\";\n        HomeMap map = new HomeMap();\n        map.setDescription(description);\n        Integer id = homeMapDao.saveHomeMap(map);\n        FileOutputStream fos;\n        try {\n            fos = new FileOutputStream(dir + id);\n            IOUtils.copy(new FileInputStream(imageFile), fos);\n            IOUtils.closeQuietly(fos);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return list();\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "339517", "id2": "4501356", "code1": "    ClassFile getClassFile(String name) throws IOException, ConstantPoolException {\n        URL url = getClass().getResource(name);\n        InputStream in = url.openStream();\n        try {\n            return ClassFile.read(in);\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    static String calculateProfileDiffDigest(String profileDiff, boolean normaliseWhitespace) throws Exception {\n        if (normaliseWhitespace) {\n            profileDiff = removeWhitespaces(profileDiff);\n        }\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(profileDiff.getBytes());\n        return new BASE64Encoder().encode(md.digest());\n    }\n", "label": 0, "substitutes": {"getClassFile": ["createClassCode", "createCodeLoader", "getCacheCode", "getCacheLoader", "getClassCode", "createCodeFiles", "getCacheFile", "getSourceCode", "getSourceLoader", "getCodeFiles", "createCodeCode", "createCodeFile", "getCacheFiles", "getClassLoader", "getSourceFiles", "createClassFile", "getSourceFile", "getClassFiles", "getCodeFile", "createClassFiles", "getCodeCode", "getCodeLoader", "createClassLoader"], "name": ["request", "size", "n", "key", "class", "i", "object", "default", "parent", "id", "address", "ame", "info", "connection", "path", "resource", "file", "str", "config", "NAME", "part", "prefix", "this", "pass", "base", "definition", "data", "type", "loader", "Name", "names", "string", "named", "uri", "source", "filename"], "url": ["r", "image", "service", "sl", "rl", "i", "class", "host", "el", "feed", "user", "instance", "ls", "id", "page", "server", "rule", "open", "connection", "found", "http", "URL", "resource", "io", "resources", "ssl", "file", "f", "Url", "this", "base", "loader", "b", "ll", "l", "reader", "string", "uri", "source", "config"], "in": ["r", "image", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "input", "id", "ex", "din", "inas", "ax", "lin", "inner", "resource", "nin", "ssl", "out", "ini", "con", "rin", "inside", "f", "login", "data", "err", "b", "token", "ins", "bin", "In", "reader", "IN", "as", "again", "read", "win", "source", "ac", "inc"]}}
{"id1": "6908537", "id2": "8024375", "code1": "    public String login() {\n        System.out.println(\"Logging in to LOLA\");\n        try {\n            String data = URLEncoder.encode(\"email\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_email(), \"UTF-8\");\n            data += \"&\" + URLEncoder.encode(\"pw\", \"UTF-8\") + \"=\" + URLEncoder.encode(get_pw(), \"UTF-8\");\n            URL url = new URL(URL_LOLA + FILE_LOGIN);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line, sessid;\n            line = rd.readLine();\n            sessid = get_sessid(line);\n            this.set_session(sessid);\n            wr.close();\n            rd.close();\n            return sessid;\n        } catch (Exception e) {\n            System.out.println(\"Login Error\");\n            return \"\";\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"login": [" Login", "get", "blog", "request", "in", "connect", "ping", "pin", "profile", "output", "user", "online", "register", "info", "Login", "session", "update", "download", "log", "bind", "ins", "name", "auth", "password", "config", "username"], "data": ["plain", "email", "html", "key", "output", "layout", "feed", "action", "input", "id", "picture", "json", "address", "complete", "info", "result", "connection", "format", "content", "response", "message", "code", "raw", "function", "value", "str", "part", "this", "api", "session", "update", "zip", "append", "database", "done", "text", "method", "name", "auth", "body", "string", "DATA", "ata", "addr", "uri", "dat", "up"], "url": ["lr", "r", "blog", "db", "fr", "client", "sl", "rl", "host", "socket", "fl", "ls", "page", "server", "loc", "open", "connection", "http", "URL", "path", "resource", "pull", "ob", "ssl", "file", "link", "Url", "this", "channel", "session", "loader", "log", "org", "ll", "l", "web", "ur", "uri", "www"], "conn": ["r", "db", "client", "connect", "Conn", "sync", "ctx", "n", "cp", "socket", "cn", "nt", "ci", "www", "lc", "coll", "loc", "open", "ann", "dn", "connection", "nc", "dc", "ver", "http", "cur", "ssl", "out", "con", "resp", "ch", "enc", "col", "exec", "sql", "conv", "session", "err", "rt", "org", "ct", "pc", "co", "l", "Connection", "cmp", "act", "lock", "ws", "cb", "c"], "wr": ["r", "fw", "fr", "writer", "sw", "wal", "worker", "WR", "Wr", "raft", "rl", "fd", "rs", "write", "cr", "rx", "Writer", "wav", "dr", "ru", "wh", "rb", "war", "rh", "rr", "shr", "rar", "nr", "hr", "rw", "wb", "wer", "wa", "rt", "wp", "w", "nw", "yr", "vr", "reader", "wx", "wt", "ws", "RW", "pr", "wm"], "rd": ["lr", "r", "RD", "fr", "writer", "rl", "rer", "fd", "rc", "rs", "cr", "rx", "pd", "dra", "cd", "dr", "ru", "rb", "rh", "ra", "rr", "wd", "rod", "rar", "hr", "bd", "rw", "sr", "mr", "rf", "rt", "xd", "rn", "vr", "vd", "rg", "reader", "ld", "ws", "dd", "rob", "pr"], "line": ["r", "sync", "sl", "entry", "block", "i", "cell", "comment", "user", "write", "e", "parse", "id", "page", "lc", "cr", "rule", "lines", "Line", "result", "lin", "code", "connection", "response", "message", "word", "out", "row", "raw", "file", "str", "part", "link", "ge", "end", "unit", "inline", "type", "err", "pe", "log", "LINE", "text", "record", "co", "name", "l", "frame", "string", "header", "read", "dd"], "sessid": ["sasskid", " sessiondata", " sessionint", "sessinfo", " sesskid", " sessident", "schatint", "sassint", "sessionid", "sangname", "sanginfo", "scessid", "sysurl", "sessident", "sessint", "sesskid", "sesssid", " sessit", " sessdata", " sesssid", "sessionsid", " sessionkid", "sessdata", "sockident", "scesssid", "sassname", "sockit", "sessurl", "sessionint", "sysit", "sossid", "scessId", "sockdata", "sessionit", "sessioninfo", "sessionident", "sockid", "sossname", " sessionsid", " sessint", " sessionident", "sysdata", "sysid", "sessId", " sessurl", "sossinfo", "sosssid", "schatid", "sassid", "schatname", " sessionid", " sessionId", "sysId", "sessionkid", "scessurl", " sessionit", " sessname", "schatkid", "sangsid", "sessname", "sysident", "sessionId", " sessionurl", " sessionname", "sessionname", "sessit", "sangid", "sessiondata", "sessionurl", "syssid", " sessId"]}}
{"id1": "18731843", "id2": "8000624", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    private void CopyTo(File dest) throws IOException {\n        FileReader in = null;\n        FileWriter out = null;\n        int c;\n        try {\n            in = new FileReader(image);\n            out = new FileWriter(dest);\n            while ((c = in.read()) != -1) out.write(c);\n        } finally {\n            if (in != null) try {\n                in.close();\n            } catch (Exception e) {\n            }\n            if (out != null) try {\n                out.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doBody": ["doResponse", "doFile", " doFile", " doBytes", "handleResponse", "DoFile", "handleBytes", "DoBody", "handleFile", " doResponse", "doBytes", "DoBytes", "DoResponse", "handleBody"], "req": ["request", "r", "fr", "obj", "query", "src", "q", "def", "qq", "rx", "reg", "conn", "info", "cgi", "rss", "http", "report", "ref", "resource", "rh", "rr", "proc", "qt", "rec", "crit", "this", "serv", "data", "err", "jp", "download", "spec", "comp", "requ", "sem", "Request", "res", "reader", "respond", "config"], "resp": ["request", "r", "job", "p", "obj", "html", "pos", "reply", "pre", "respons", "bb", "cache", "val", "result", "response", "ref", "report", "ret", "rr", "Response", "proc", "Resp", "rec", "exc", "part", "prot", "rev", "serv", "api", "rep", "data", "err", "jp", "download", "b", "comp", "inv", "res", "respond", "cmp", "re", "cb", "sp"], "bis": ["lis", "os", "mis", "obi", "isin", "oris", "is", "bs", "ois", "phis", "bb", "usb", "abi", "ses", "lins", "sin", "sb", "bid", "ris", "alis", "boot", "los", "ubis", "obs", "iss", "ios", "bps", "ori", "nis", "bes", "atis", "fb", "iris", "bi", "bas", "bh", "ais", "bits", "binary", "sis", "bian", "pins", "b", "bin", "obb", "obos", "rots", "tis", "uds"], "bos": ["os", "obi", "oos", "zos", "oops", "bris", "bs", "ois", "bott", "phis", "lol", "lins", "bo", "abi", "ros", "aos", "los", "boot", "ubis", "obs", "ios", "bps", "bes", "oses", "osa", "antis", "bas", "bi", "bh", "osi", "zo", "bits", "oks", "mos", "oS", "las", "fits", "ops", "bin", "obb", "bones", "oros", "obos", "obo", "opus", "tis", "uds"]}}
{"id1": "21998571", "id2": "310182", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadTwitterFleee", "downloadTwitterJrequency", "downloadTwitterFee", "downloadTwitterFees", "downloadFacebookJee", "downloadFacebookJrequency", "downloadTwitterJead", "downloadTwitterFFrequency", "downloadTwitterFleees", "downloadFacebookFees", "downloadTwitterFlerequency", "downloadFacebookFrequency", "downloadTwitterFleead", "downloadTwitterFFees", "downloadTwitterJee", "downloadFacebookFead", "downloadFacebookFee", "downloadTwitterFrequency", "downloadTwitterFFee", "downloadFacebookJead", "downloadTwitterFead", "downloadTwitterFFead", "downloadTwitterJees", "downloadFacebookJees"], "builder": ["r", "image", "db", "buffer", "writer", "worker", "block", "entry", "object", "trace", "instance", "sb", "server", "address", "sf", "result", "board", "builders", "http", "array", "message", "editor", "container", "keeper", "row", "we", "build", "building", "iter", "store", "f", "url", "letter", "null", "base", "wrapper", "loader", "b", "er", "oder", "runner", "database", "atter", "built", "driver", "bean", "upper", "string", "parser", "Builder", "holder", "layer"], "client": ["request", "get", "connect", "service", "google", "queue", "i", "ce", "class", "socket", "host", "app", "proxy", "cli", "handler", "server", "per", "conn", "connection", "http", "resource", "io", "con", "tc", "cloud", "Client", "url", "api", "channel", "session", "contact", "https", "application", "force", "method", "bird", "plugin", "project", "config", "c"], "httpGet": ["httpget", "urlget", " httpSend", "HttpPut", "ttpSplit", "HTTPget", "httpFind", "HttpDo", "HTTPFind", "HttpSplit", " httpDo", "httpSplit", "httpPut", " httpget", " httpSplit", " httpFind", "httpSend", "HttpGet", "urlFind", "httpDo", "HTTPSend", "urlGet", "ttpDo", "ttpPut", " httpPut", "urlSend", "HTTPGet", "ttpGet"], "response": ["request", "error", "success", "writer", "service", "stream", "received", "full", "output", "reply", "object", "page", "handler", "server", "json", "result", "connection", "http", "message", "resource", "successful", "report", "Response", "resp", "ception", "api", "onse", "session", "data", "collection", "status", "application", "wave", "document", "body", "respond", "event"], "statusLine": ["StatusEntry", "statusEntry", "httpLine", "statResponse", "statusResponse", "statLine", "httpStatus", " statusResponse", "httpEntry", "responseEntry", " statusEntry", "responseCode", "statCode", "StatusStatus", "StatusLine", "statusStatus", "contentEntry", "contentLine", "responseLine", "statEntry", "statusBlock", "httpBlock", "contentStatus", "contentBlock", "StatusBlock", "responseResponse"], "statusCode": ["statusCount", "contentCode", "statusType", "contentType", "stateType", " statusCount", "stateCode", "stateStatus", "StatusStatus", "contentCount", " statusType", "StatusType", "StatusLine", " statusStatus", "StatusCount", "StatusCode", "statusStatus", "contentLine"], "entity": ["writer", "element", "entry", "stream", "object", "el", "e", "page", "json", "coll", "server", "agent", "result", "code", "media", "http", "resource", "Entity", "connection", "xml", "file", "enc", "model", "data", "type", "er", "ent", "article", "activity", "status", "collection", "application", "document", "et", "body", "event", "person", "source"], "content": ["image", "writer", "buffer", "entry", "stream", "Content", "output", "object", "load", "feed", "input", "layer", "page", "handler", "json", "server", "conn", "child", "result", "media", "pointer", "resource", "message", "xml", "raw", "file", "channel", "data", "loader", "activity", "status", "collection", "text", "driver", "body", "cont", "read", "source"], "reader": ["r", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "input", "handler", "server", "per", "ler", "or", "editor", "resource", "io", "rr", "row", "reading", "rar", "iter", "data", "ri", "loader", "er", "oder", "parser", "ser", "read", "bird"], "line": ["r", "ip", "buffer", "sl", "lf", "sync", "one", "entry", "block", "i", "key", "cell", "object", "comment", "feed", "character", "sheet", "write", "e", "id", "page", "lc", "lines", "Line", "lin", "code", "connection", "message", "row", "file", "str", "liner", "iter", "link", "part", "url", "letter", "end", "pass", "base", "inline", "data", "pe", "char", "LINE", "text", "name", "l", "style", "string", "body", "le", "point", "source"]}}
{"id1": "3584508", "id2": "19549577", "code1": "    private void copyResource() throws Exception {\n        URL url = getResource(source);\n        InputStream input;\n        if (url != null) {\n            input = url.openStream();\n        } else if (new File(source).exists()) {\n            input = new FileInputStream(source);\n        } else {\n            throw new Exception(\"Could not load resource: \" + source);\n        }\n        OutputStream output = new FileOutputStream(destinationFile());\n        int b;\n        while ((b = input.read()) != -1) output.write(b);\n        input.close();\n        output.close();\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"copyResource": ["copyFile", " copyresource", "transferUrl", "transferresource", " downloadFile", "copyUrl", "transferFile", "copyresource", " downloadresource", " copyUrl", " downloadUrl", " downloadResource", " copyFile", "transferResource"], "url": ["lr", "r", "image", "sl", "stream", "src", "host", "object", "feed", "ls", "id", "page", "server", "address", "bel", "loc", "connection", "http", "URL", "resource", "path", "ref", "xml", "ssl", "file", "f", "Url", "base", "data", "download", "loader", "name", "l", "remote", "string", "web", "uri", "re", "ource", "source", "www"], "input": ["request", "image", "get", "in", "error", "client", "buffer", "accept", "progress", "upload", "element", "stream", "i", "form", "socket", "but", "feed", "load", "context", "instance", "bb", "parse", "cache", "address", "plus", "open", "inf", "connection", "http", "inner", "index", "resource", "audio", "pull", "xml", "ssl", "out", "qa", "file", "f", "active", "this", "api", "base", "exec", "binary", "session", "data", "temp", "ack", "Input", "l", "bin", "reader", "act", "current", "source", "config", "inc"], "output": ["image", "writer", "buffer", "console", "stream", "queue", "flow", "socket", "object", "default", "ou", "layer", "write", "copy", "environment", "cache", "address", "result", "target", "connection", "response", "resource", "operation", "out", "file", "Output", "binary", "unit", "production", "data", "control", "log", "put", "application", "other", "document", "external", "network", "web", "outer", "current", "source", "config"], "b": ["r", "db", "m", "buffer", "h", "p", "batch", "bf", "br", "n", "bit", "ab", "i", "lb", "bs", "bb", "e", "sb", "bc", "rb", "a", "fb", "be", "mb", "ob", "line", "file", "bi", "pb", "abs", "B", "x", "f", "buf", "binary", "base", "k", "bar", "v", "bin", "l", "d", "nb", "cb", "c"]}}
{"id1": "1362", "id2": "4458076", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public InputStream getInputStream() throws TGBrowserException {\n        try {\n            if (!this.isFolder()) {\n                URL url = new URL(this.url);\n                InputStream stream = url.openStream();\n                return stream;\n            }\n        } catch (Throwable throwable) {\n            throw new TGBrowserException(throwable);\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["ubblingCompare", "bubblingsort", "ubblesort", "ubbleCompare", "bubblesort", "ubblingOrder", "ubbleSort", "bubblessort", "bubblingSort", "bubblesCompare", "bubblersort", "bubbleCompare", "ubblingSort", "ubbleOrder", "bubblingOrder", "bubbleOrder", "bubblerCompare", "bubblesSort", "bubblerSort", "bubblingCompare", "ubblingsort", "bubblesOrder", "bubblerOrder"], "a": ["auto", "an", "la", "m", "p", "access", "alpha", "all", "ab", "ga", "s", "na", "ad", "sa", "e", "address", "aaa", "aj", "A", "ma", "aux", "tta", "result", "va", "array", "index", "something", "img", "apps", "work", "aw", "at", "sup", "oa", "abs", "another", "f", "area", "active", "o", "data", "ac", "ans", "u", "ama", "b", "ack", "ba", "any", "aa", "l", "d", "as", "ae", "ata", "am", "list", "empty", "au", "c"], "swapped": ["swaps", "swoped", "flapped", "waps", "rewoped", "rewapping", "rewaped", "flapping", " swaped", " swap", "Swapped", "flap", "swap", "Swap", "floped", " swaps", "swapping", " swapping", "Swoped", "wap", "Swapping", "wapped", "swaped", "rewaps", "wapping", "waped", "rewap", "Swaped", "rewapped"], "i": ["next", "ind", "ai", "ip", "in", "m", "ki", "h", "p", "j", "ie", "eni", "key", "init", "multi", "fi", "ix", "e", "id", "ci", "gi", "ui", "info", "module", "mini", "adi", "index", "li", "ii", "ori", "io", "iu", "ini", "anti", "sup", "bi", "uni", "start", "x", "pi", "f", "xi", "api", "ami", "ti", "k", "ri", "u", "ni", "b", "y", "v", "mi", "oi", "it", "di", "hi", "l", "d", "si", "qi", "uri", "iv", "I"], "tmp": ["pad", "amp", "m", "j", "p", "opp", "obj", "alpha", "pp", "ie", " ff", "vt", "pre", "qq", "bb", "t", "stuff", "tt", "foo", "tv", "dest", "sup", "angle", "part", "tc", "x", "f", "area", "st", "xxx", "yy", "temp", "emp", "append", "b", "v", "test", "mp", "kk", "front", "mmm", "nb", "prev", "addr", "cmp", "txt"]}}
{"id1": "7396682", "id2": "18570190", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "    public Processing getProcess(long processId) throws BookKeeprCommunicationException {\n        try {\n            synchronized (httpClient) {\n                HttpGet req = new HttpGet(remoteHost.getUrl() + \"/id/\" + Long.toHexString(processId));\n                HttpResponse resp = httpClient.execute(req);\n                if (resp.getStatusLine().getStatusCode() == HttpStatus.SC_OK) {\n                    try {\n                        XMLAble xmlable = XMLReader.read(resp.getEntity().getContent());\n                        if (xmlable instanceof Processing) {\n                            Processing p = (Processing) xmlable;\n                            return p;\n                        } else {\n                            throw new BookKeeprCommunicationException(\"BookKeepr returned the wrong thing for pointingID\");\n                        }\n                    } catch (SAXException ex) {\n                        Logger.getLogger(BookKeeprConnection.class.getName()).log(Level.WARNING, \"Got a malformed message from the bookkeepr\", ex);\n                        throw new BookKeeprCommunicationException(ex);\n                    }\n                } else {\n                    resp.getEntity().consumeContent();\n                    throw new BookKeeprCommunicationException(\"Got a \" + resp.getStatusLine().getStatusCode() + \" from the BookKeepr\");\n                }\n            }\n        } catch (HttpException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (IOException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        } catch (URISyntaxException ex) {\n            throw new BookKeeprCommunicationException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["get", "clone", "sync", "save", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "archive", " cp", "replace", "source", "share", "clip", "path", "rm", "cop", "change", "file", "link", "url", "update", "download", "create", "paste", "drop", "split", "remote", "dump", "opy", "move"], "srcFS": ["sbFP", "sourceFS", "sourcefs", " srcTS", "rubyFs", "srcfs", "sourceFB", "rcFC", " srcFP", " srcFB", "srcFB", "srcFP", "sourceFs", "srcFC", "sbfs", "rubyfs", "sourceFC", "rubyFS", "rcfs", "rubyFB", "sbFS", "rcTS", "srcFs", "srcTS", " srcFs", " srcFC", "rcFS", " srcfs", "sbFs", "rcFs", "rcFP", "sourceTS"], "src": ["sc", "sl", "obj", "upload", "attr", "sec", "stream", "ctx", "host", "sync", "rc", "view", "sit", "slice", "sn", "sin", "core", "RC", "sb", "cb", "loc", "source", "inf", "target", "share", "rss", "rb", "inst", "path", "code", "fp", "resource", "http", "ssl", "img", "supp", "gb", "dest", "sup", "Source", "dist", "secure", "feat", "sr", "sel", "file", "url", "req", "st", "bh", "config", "rest", "spec", "SourceFile", "name", "project", "href", "sth", "sys", "uri", "cmp", "ource", "sub", "filename", "username"], "dst": ["cdst", " drc", " dsts", "lST", "lst", "dsts", "ddst", "pdST", "pdsc", "cdrc", "ddsc", "pdrc", "drest", "Drest", "ddest", " dST", "Dsts", "lsts", " drest", "Drc", " ddest", "idsts", "idrest", "dST", "Ddest", "ddrc", "cddest", "Dst", "drc", "idst", "dsc", " dsc", "iddest", "ldest", "cdST", "pdst", "ddST", "DST"], "deleteSource": ["DeleteSources", "delTarget", " deleteOrigin", "delMode", "DeleteMode", "delOrigin", "destroyTarget", "DeleteTarget", "DeleteOrigin", "destroyOrigin", "deleteType", "deleteSources", "DeleteType", " deleteSources", "deleteOrigin", "delSource", "destroySource", "deleteMode", "copyOrigin", "deleteTarget", "delType", "copySource", "destroyMode", "DeleteSource", " deleteMode", "delSources", " deleteType", "copyMode", "copyTarget", " deleteTarget"], "conf": ["sc", "client", "ca", "ctx", "def", "cs", "cn", "cc", "context", "fi", "comment", "bug", "cr", "cli", "lc", "cf", "ci", "cache", "const", "cb", "conn", "info", "cd", "bc", "ref", "raf", "cor", "cm", "param", " Conf", "con", "Conf", "uc", "f", "ch", "confirmed", "conv", "cl", "cfg", "prop", "cmp", "config", "c"], "contents": ["contContents", "contentents", "containers", " contients", "Content", "latents", "CONTENTS", "ContContents", "stents", "CONTents", "stacts", "contacts", "CONTacts", " contENTS", "CONTils", "Contains", "content", "stences", "contences", "stENTS", "CONTients", "Contents", "CONTains", "ContENTS", "locains", "locents", "contENTS", "Contences", "Contacts", "contentients", "contentent", "CONTContents", "latacts", "contains", "Containers", "Contils", "contils", "CONTainers", "contients", "latent", "contentENTS", "locContents", "CONTent", "latils", "CONTences", " content", "locainers"], "i": ["ai", "ip", "m", "j", "p", "h", "n", "ie", "key", "init", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "diff", "inner", "li", "index", "ii", "io", "ori", "iu", "ini", "count", "uni", "start", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "type", "u", "data", "b", "y", "v", "ji", "oi", "name", "di", "hi", "d", "si", "qi", "uri", "iv", "I", "c"], "in": ["r", "inn", "gin", "is", "socket", "input", "thin", "id", "sin", "din", "inas", "conn", "ax", "connection", "a", "nin", "out", "ini", "con", "rin", "file", "kin", "part", "min", "f", "pass", "serv", "doc", "login", "data", "ac", "b", "ins", "bin", "In", "l", "IN", "as", "win", "source", "c", "inc"]}}
{"id1": "4938100", "id2": "3745402", "code1": "    public static String sha1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"sha1": ["hashOne", "SHAOne", "shaOne", "sha256", " SHA1", " SHAOne", " SHA256", "hash1", "hash64", "SHA256", "SHA64", " SHA64", "sha64", "hash256", "SHA1"], "text": ["image", "font", "template", "bytes", " Text", "key", "output", "class", "object", "pattern", "input", "Text", "version", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "editor", "word", "translation", "value", "EXT", "str", "url", "letter", "this", "data", " TEXT", "struct", "secret", "token", "test", "number", "contract", "name", "password", "string", "source", "config", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncodedception", "UnsupportedEncodingception", "UnsupportedEncodingEx", "UnsupportedEncoderception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedEncasingEx", "UnsupportedEncasingException", "UnsupportedEncodedEx", "UnsupportedEncoderException", "UnsupportedEncoderEx"], "md": ["mac", "mm", "mo", "ind", "m", "Cmd", "dig", "bf", "mad", "map", "ad", "mn", "pd", "metadata", "valid", "ma", "cd", "code", "od", "rm", "editor", "message", "mb", "amd", "nm", "df", "wd", "gd", "mand", "bd", "sm", "mg", "mode", "dm", "data", "pm", "sha", "mt", "MD", "mp", "di", "me", "mc", "mod", "hd", "mag", "d", "body", "vd", "ld", "ms", "meta", "hash", "am", "cmd", "dd", " MD"], "sha1hash": ["sha4hash", "sha256sha", "sha5sha", "sha4hex", "sha001hash", "sha2address", "sha41sum", "SHA1check", "wa3dash", "sha3sum", "sha1dash", "SHA2sha", "wa3sum", "sha5Hash", "sha91address", "sha2hash", "SHA2hash", "sha4dash", "sha1Hash", "sha3hex", "wa1hash", "SHA1hash", "SHA2check", "wa1dash", "sha4sum", "sha256Hash", "sha91hash", "sha1address", "wa3hex", "sha5sum", "SHA2Hash", "sha001dash", "sha3dash", "SHA1sha", "SHA1sum", "sha41address", "sha001sum", "sha2sha", "sha91sum", "sha1check", "SHA1Hash", "sha001hex", "wa1sum", "wa1hex", "sha256hash", "sha41hash", "sha91check", "sha2sum", "sha2Hash", "sha256sum", "sha2check", "SHA2sum", "sha1sum", "sha41check", "sha3hash", "sha1hex", "wa3hash", "sha1sha", "SHA2address", "SHA1address", "sha5hash"]}}
{"id1": "23532405", "id2": "13783549", "code1": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"persist": ["persistence", "plist", " Persist", "plister", " Persists", "Persistence", " Persister", "Persister", " Persistence", "persister", "plistence", "Persist", "Persists", "plists", "persists"], "ffConfigurable": ["effConfigurable", "ffSegurable", "ffconfigurable", "ffConfurable", "ffLogure", "effConfigurer", "uffLoguring", "ffConfigural", "ffLogurer", "FFConfural", "effConfural", "ffConfurred", "ffSegurer", "uffConfigurable", "uffLogurable", "effConfured", "ffSegurred", "ffConfigure", "effConfigural", "ffPlurer", "ffLogurable", "ffConfiguring", "ffConfuring", "ffGurable", "ffConfigurer", "FFConfigurable", "ffFured", "ffLogured", "ffGur", "FFConfurer", "ffLoguring", "effConfurer", "FFConfurred", "ffConfigured", "ffConfigur", "FFConfigurred", "ffConfur", "ffGuring", "uffConfiguring", "ffSegured", "ffconfigurer", "ffLogural", "ffFurable", "effConfigured", "FFConfigur", "uffLogure", "FFConfur", "FFConfuring", "uffConfigured", "ffFuring", "ffSegural", "ffGurer", "FFConfurable", "ffConfurer", "ffFure", "uffLogured", "effConfurable", "ffConfure", "ffconfigurred", "FFConfigurer", "FFConfigural", "ffConfured", "ffConfural", "ffConfigurred", "ffPlurable", "ffPluring", "FFConfiguring", "ffconfigural", "uffConfigure", "ffPlur"], "relativePath": ["protectedpath", "protectedFile", "absolutepath", "relativeFile", "absolutePath", " relativepath", " relativePoint", "absoluteUrl", "absoluteLocation", "relativepath", "ativeLocation", " relativeUrl", "relativePoint", "protectedPath", "absoluteFile", "absolutePoint", "ativeUrl", "ativeName", "absoluteName", "relativeLocation", " relativeLocation", "protectedPoint", "relativeName", "ativePath", " relativeFile", "relativeUrl", " relativeName"], "file": ["get", "image", "db", "in", "self", "full", "stream", "files", "class", "form", "object", "use", "el", "il", "e", "parent", "cf", "directory", "handler", "File", "cache", "fe", "sf", "module", "filename", "http", "php", "path", "location", "fp", "show", "io", "single", " File", "out", "work", "FILE", "ile", "part", "store", "dir", "f", "url", "unit", "base", "model", "zip", "data", "pe", "temp", "type", "b", "log", "local", "it", "name", "l", "place", "folder", "le", "source", "config"], "is": ["ip", "in", "mis", "Is", "ai", "us", "bis", "iso", "oss", "isa", "i", "was", "isi", "es", "ris", "gets", "IS", "info", "ui", "iss", "ios", "nis", "io", "ii", "ir", "out", "iris", "ais", "fs", "api", "does", "ics", "as", "si", "ps", "ms", "ws"], "os": ["ils", "us", "oos", "iso", "oss", "ies", "uns", "s", "oid", "ou", "rs", "ol", "ips", "ows", "ens", "aos", "los", "obs", "cos", "ios", "ori", "oses", "io", " bos", "ais", "oa", "OS", "osi", "o", "fs", "oS", "ops", "bos", "as", "ms", "Os", "outs", "oes"]}}
{"id1": "6379126", "id2": "16798376", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTinyPage", "riarTinyDir", "riartourpage", "riarTourDir", "riarTutorialElement", "riartutorialPage", "riarTutorialDir", "riarTourElement", "riarTravispage", "riartutorialDir", "riarTinypage", "riarTinyElement", "riarTourPage", "riarTutorialPage", "riarTravisElement", "riartourElement", "riarTravisPage", "riartutorialElement", "riarTourpage", "riartutorialpage", "riarTutorialpage", "riartourPage", "riartourDir", "riarTravisDir"], "indexDir": ["IndexTier", "includeJar", "zipJar", "indexJar", "includeTier", "zipTier", "IndexDir", "zipDir", "zipDIR", "IndexDIR", "includeDir", "indexDIR", "indexTier", "includeDIR", "IndexJar"], "cssDir": ["catsDoc", "javascriptDir", "CSSLen", "ssUrl", "fontDIR", "fontDir", "cssDIR", "piecesDie", "cssDie", "ssD", "CSSDir", "catsDir", "javascriptDb", "CSSDirectory", "javascriptDar", "ssDIR", "CSSDar", "gzDir", "cssDb", "fontD", "cssD", "CSSDIR", "codesDoc", "javascriptDIR", "CSSDb", "ssDir", "cssDar", "codesDir", "catsLen", "piecesD", "ssDb", "gzDIR", "CSSDoc", "cssLen", "cssDirectory", "fontDie", "gzDirectory", "gzUrl", "piecesDir", "ssDar", "codesLen", "ssDie", "CSSUrl", "ssDirectory", "cssDoc", "cssUrl", "piecesDIR"], "capDir": ["capdir", "CapVol", "capDirectory", "casDir", "casdir", "Capdir", "CapDirectory", "casVol", "apsDir", "apsdir", "casDirectory", "apsVol", "CapDir", "capVol", "apsDirectory"], "licDir": ["volDoc", "lifManager", "lifDir", "libManager", "licManager", "libDoc", "lifDoc", "voldir", "volDir", "licdir", "volManager", "lifdir", "licDoc", "libdir", "libDir"], "midDir": ["middir", "casDir", "limTier", "mindDir", "limDir", "midTier", "casDIR", "casdir", "limDIR", "casTier", "mindTier", "mindDIR", "minddir", "midDIR", "limdir"], "filesDir": ["ballsPos", "ballsVol", "filesFolder", "pagesVol", "ballsDir", "pagesPos", "stylesDir", "FilesDir", "filesVol", "videosFile", "videosFolder", "imagesFile", " filesVol", "filesDur", "opensDIR", "stylesDirectory", "stylesDIR", "videosDirectory", "filesPos", "filesDirectory", "opensDirectory", "filesDIR", "opensDur", "stylesDur", "locksDirectory", "imagesDir", "locksDIR", "imagesDirectory", " filesPos", "FilesFolder", "FilesDirectory", "pagesDir", "imagesFolder", "FilesFile", "opensDir", "filesFile", "locksDir", "locksDur"], "videosDir": ["viewsUrl", "videosDb", "videoUrl", "videoFile", " videosDb", " videosDirectory", "videosFile", "viewsDir", "viewsDirectory", "videosDirectory", "viewsFile", "imagesDir", " videosFile", "videoDb", " videosUrl", "imagesDb", "videosUrl", "videoDirectory", "videoDir"], "imagensDir": ["imgentsFile", " imagensDirectory", " imagersDirectory", "imagentsFile", "imagenciesDir", "imgensDir", " imagensFile", " imagersFile", "imgensDirectory", "imagersDirectory", "imgentsDirectory", "imgentsDIR", " imagersJar", "imagentsJar", "imgentsDir", "imagersDIR", "imagenJar", "imagenFile", "imagensDirectory", "imagersDir", " imagersDir", "imagenciesDirectory", "imgensFile", "imgensDIR", "imagensDIR", "imagenDirectory", "imagenciesDIR", "imagenciesFile", "imagensJar", "imagersJar", "imagenDir", " imagensJar", "imagersFile", "imagentsDir", "imagentsDIR", "imagentsDirectory", "imagensFile"], "local": ["request", "where", "localhost", "shared", "p", "upload", "same", "defined", "tmp", "global", "user", "basic", "managed", "internal", "serial", "pal", "input", "directory", "valid", "json", "home", "loc", "relative", "state", "location", "safe", "path", "inner", "standard", "http", "conf", "file", "available", "part", "dir", "util", "active", "Location", "prefix", "pass", "base", "Local", "data", "temp", "LOC", "log", "partial", "personal", "total", "name", "l", "small", "specified", "d", " Local", "remote", "present", "lock", "current", "back", "self", "initial", "username"], "srcCss1": ["srcRcss0", "srcCpe4", "srcCrss1", "srcCss11", "srcCrss3", "srcRss2", "srcPss81", "srcRss0", "srcCcss0", "srcPcss1", "srcPssPre", "srcCss81", "srcRss1", "srcCse1", "srcCcss1", "srcRcss2", "srcCrss2", "srcPss1", "srcCass2", "srcCass0", "srcCcssPre", "srcPcss2", "srcPcss3", "srcCpe1", "srcPcssPre", "srcCpe2", "srcCcss81", "srcCpePre", "srcRcss11", "srcCass1", "srcCssPre", "srcRss81", "srcRss11", "srcCfg1", "srcCass3", "srcCrss11", "srcCcss3", "srcRcss81", "srcPcss4", "srcCse2", "srcPss3", "srcCcss4", "srcRcss1", "srcPcss81", "srcCcss2", "srcCse11", "srcCfg4", "srcCass81", "srcCcss11", "srcCrss81", "srcCass11", "srcCse0", "srcCss0", "srcCfg2", "srcPss4", "srcPss2", "srcCfgPre"], "destCss1": ["destCass1", "destPcss3", "destPssCard", "destCcss3", "destCfg3", "destPcss81", "destPss2", "destCss0", "destCrss81", "destCxxCard", "destPcss1", "destCxx1", "destCass81", "destCass3", "destCss81", "destCssCard", "destPss0", "destCcss2", "destCcss1", "destCcssCard", "destCfg1", "destPcss2", "destCass2", "destCrss1", "destCcss0", "destCfg0", "destCassCard", "destCrss0", "destCfg2", "destCrss2", "destPcssCard", "destCxx3", "destPss1", "destCrss3", "destPss3", "destPcss0", "destCxx2", "destCcss81", "destPss81"], "srcCss2": ["srcCcssL", "srcCass52", "srcCrssL", "srcCssTwo", "srcCrss1", "srcChessTwo", "srcCssB", "srcCrss3", "srcCss27", "srcChess1", "srcUcssTwo", "srcCfgL", "srcCng27", "srcCross4", "srcPss27", "srcChessB", "srcAcss2", "srcPcss1", "srcUssTwo", "srcCross1", "srcCrss2", "srcCcss1", "srcPss1", "srcUcss1", "srcCass2", "srcUcssB", "srcAccss2", "srcAccss52", "srcPcss27", "srcCross2", "srcPcss2", "srcPcss3", "srcCng1", "srcCng2", "srcCass1", "srcPssL", "srcCcss27", "srcUcss2", "srcChess2", "srcCfg1", "srcAcss4", "srcPcssL", "srcCcss3", "srcPss3", "srcCcss4", "srcCcss52", "srcCssL", "srcCcssB", "srcCfg3", "srcCfgB", "srcAccss1", "srcCass4", "srcCcss2", "srcCcssTwo", "srcUss1", "srcUss2", "srcAcss52", "srcCfgTwo", "srcCss52", "srcUssB", "srcAccss4", "srcCross52", "srcCrss27", "srcAcss1", "srcCfg2", "srcPss2"], "destCss2": ["destCess1", "destCfg3", "destCcss72", "destCcss3", "destNcss32", "destNcss2", "destNss1", "destCess32", "destCest2", "destCcss4", "destCcssB", "destCess4", "destNcss3", "destNcssB", "destNss2", "destNss32", "destCcss32", "destCfg32", "destNss4", "destCest3", "destCcss2", "destCcss1", "destNssB", "destNcss4", "destCfg1", "destNss72", "destCess72", "destCfgB", "destCfg4", "destNss3", "destCess2", "destCestB", "destCssB", "destCfg2", "destNcss72", "destCfg72", "destCest1", "destCss32", "destNcss1", "destCss72"], "srcCss3": ["srcRss2", "srcCsh183", "srcScss3", "srcCsl183", "srcRss1", "srcScstyle93", "srcCssThird", "srcCstyle6", "srcScstyle2", "srcCsh2", "srcCcss4", "srcCstyleAND", "srcPss6", "srcCstyle15", "srcCstyle93", "srcCfg2", "srcCcss93", "srcCss15", "srcCssAND", "srcCsl3", "srcCstyle3", "srcCss183", "srcCass2", "srcRcss3", "srcCcss15", "srcCrss6", "srcRss3", "srcCass1", "srcCfg1", "srcCcss3", "srcPss3", "srcClass3", "srcRcss1", "srcCss93", "srcPcss6", "srcCass4", "srcCcssThird", "srcCrss3", "srcScstyle3", "srcCstyle2", "srcCcss6", "srcClass2", "srcRcss183", "srcClass15", "srcPcss2", "srcPssAND", "srcCrssAND", "srcClass93", "srcCass3", "srcRssThird", "srcCslThird", "srcCsh3", "srcRss183", "srcCsl2", "srcRcss4", "srcCfg3", "srcCfg4", "srcRss4", "srcRcssThird", "srcPcss3", "srcScss93", "srcCcss183", "srcCrss2", "srcRcss2", "srcCcss1", "srcScss15", "srcPcssAND", "srcCcssAND", "srcScss2", "srcCshThird", "srcScstyle15", "srcCcss2", "srcPss2"], "destCss3": ["destPcss3", "destCcss3", "destCross3", "destNcss2", "destCstyle2", "destScss183", "destCstyle03", "destCja6", "destPss2", "destScss3", "destCrss183", "destCss43", "destCross03", "destCstyle53", "destCstyle43", "destCross53", "destNcss3", "destScrss2", "destCrss6", "destNss2", "destNss43", "destScrss6", "destCass3", "destNcss43", "destCss53", "destScss6", "destCja3", "destPcss53", "destPcss03", "destCcss2", "destScrss3", "destCstyle3", "destPcss2", "destCass2", "destCss03", "destPss53", "destScrss183", "destCss183", "destNss3", "destCja183", "destScss2", "destCja2", "destCrss2", "destCcss6", "destCross2", "destCrss3", "destPss3", "destCcss183", "destPss03", "destCcss53", "destCcss03", "destCcss43", "destCass43"], "srcCss4": ["srcCrss1", "srcPcss1", "srcPssFour", "srcCrss2", "srcCcss1", "srcPss1", "srcCass2", "srcPcss2", "srcCass1", "srcCssFour", "srcCassFour", "srcCrss4", "srcCrssFour", "srcCcssFour", "srcPcss4", "srcCcss4", "srcPcssFour", "srcCcss2", "srcCass4", "srcPss4", "srcPss2"]}}
{"id1": "3731077", "id2": "8778962", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "transferfile", "transferSourceFile", "importFiles", " copySourceFile", "copyFiles", "copyfile", "importfile", "transferFile", "importFile", "transferFiles", "importSourceFile"], "from": ["before", "From", "client", "ca", "original", "left", "src", "form", "ce", "old", "user", "id", "address", "origin", "or", "a", "path", "resource", "io", "se", "at", "file", "of", "part", "start", "f", "url", "o", "this", "base", "data", "with", "range", "name", "by", " form", "d", "front", "without", "as", "remote", "about", "add", "back", "source", "config", "c"], "to": ["auto", "os", "toc", "client", "p", "size", "one", "too", "output", "socket", "object", "parent", "copy", "po", "office", "To", "t", "target", "or", "location", "TO", "top", "io", "into", "at", "file", "dest", "of", "root", "storage", "f", "o", "eto", "null", "until", "api", "base", "this", "temp", "type", "with", "b", "database", "token", "so", "name", "by", "site", "again", "as", "two", "point", "about", "source"], "parentDir": ["parentFile", "rootDir", "parentDirectory", "rootFolder", "ParentDirectory", "ParentFolder", "parentFolder", "currentDir", "currentFolder", "ParentFile", " parentDirectory", "currentdir", "rootDirectory", "rootFile", " parentdir", "outDir", "parentdir", " parentFile", "outFile", "ParentDir", "currentFile", "outFolder", "Parentdir", " parentFolder", "outDirectory"], "in": ["r", "image", "m", "pin", "sync", "ie", "inn", "isin", "gin", "i", "form", "rc", "pre", "init", "cin", "input", "on", "id", "arin", "din", "conn", "diff", "or", "lin", "inner", "vin", "io", "nin", "con", "ini", "fc", "rec", "kin", "work", "part", "inside", "rin", "min", "url", "o", "exec", "login", "err", "with", "trial", "it", "ins", "pc", "bin", "In", "l", "plugin", "again", "IN", "reader", "win", "source", "ac", "inc"], "out": ["Out", "ico", "auto", "client", "writer", "p", "sync", "off", "gin", "output", "init", "app", "cin", "input", "user", "ou", "win", "on", "cy", "ex", "option", "conn", "or", "inner", "io", "op", "at", "ot", "o", "channel", "exec", "vert", "can", "org", "w", "other", "net", "co", "call", "bin", "plugin", "again", "outer", "outs", "about", "c", "OUT", "ac", "inc"], "ic": ["ico", "aic", "ai", "auto", "irc", "cus", "sync", "IC", "i", "ik", "rc", "cc", "cs", "cin", "ix", "input", "ex", "ci", "lc", "conn", "loc", "or", "cu", "bc", "dc", "io", "op", "voc", "uc", "fc", "xc", "pic", "enc", "o", "vc", "ac", "iac", "cl", "nic", "ct", "pc", "co", "anc", "ig", "mc", "ics", "acs", "icc", "c", "inc", "ec"], "oc": ["aic", "toc", "sc", "ca", "cus", "i", "cc", "aco", "cy", "ci", "circ", "OC", "alloc", "loc", "or", "bc", "dc", "cur", "ocol", "io", "ob", "op", "wic", "voc", "uc", "fc", "xc", "oca", "oci", "roc", "o", "enc", "vc", "ac", "can", "ack", "org", "AC", "soc", "nic", "pc", "co", "anc", "mc", "ocon", "acs", "og", "mic", "oco", "c", "inc", "ec"]}}
{"id1": "23215235", "id2": "2113444", "code1": "    public void readFile(URL url) throws PedroException, IOException, ParserConfigurationException, SAXException {\n        this.zipFileName = url.toString();\n        URLConnection urlConnection = url.openConnection();\n        InputStream inputStream = urlConnection.getInputStream();\n        unzipNativeFormatFile(inputStream);\n        parseAlertFiles();\n        deleteAlertFiles();\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"readFile": ["readContent", "readZip", "readFiles", "loadFile", " readZip", "loadZip", " readContent", "importFiles", "importZip", "loadContent", " readFiles", "importContent", "importFile", "loadFiles"], "url": ["image", "job", "client", "buffer", "service", "sl", "stream", "host", "class", "object", "feed", "input", "user", "bug", "page", "server", "address", "filename", "connection", "location", "http", "path", "resource", "URL", "io", "xml", "ssl", "file", "str", "link", "f", "Url", "base", "zip", "data", "download", "loader", " URL", "name", "l", "browser", "reader", "uri", "source", "config"], "IOException": ["IPInterface", " IOInterface", "IOInterface", "TimeoutInterface", "TimeoutException", "IPException"], "ParserConfigurationException": ["ParserConfigurationAPE", "ParserDefinitionException", "ParserDefinitionEX", "ParserConstructionEX", "InvalidConfigAPE", "ParserConfigurationEX", "ParserDefinitionAPE", "InvalidConfigurationAPE", "ParserConfigAPE", "ParserConstructionAPE", "InvalidConfigurationException", "InvalidConfigException", "InvalidConfigurationEX", "ParserConstructionException", "InvalidConfigEX", "ParserConfigEX", "ParserConfigException"], "SAXException": [" SAXPception", "SAXception", "SAXPException", "SAFEception", "SAXPception", " SAXception", "SAXMException", " SAXPException", "SAFEException", "SAXMception"], "zipFileName": ["zipFolderDirectory", "archiveFileDirectory", "zipFilesPath", "zipDirDirectory", "zipFolderPath", "archiveFilesType", "zipDirPath", "zipFilesDirectory", "archiveFilesPath", "zipFilesType", "zipDirType", "archiveFilesDirectory", "archiveFileName", "zipFilesName", "archiveFileType", "zipFileType", "zipFolderName", "zipDirName", "archiveFilesName", "archiveFilePath", "zipFilePath", "zipFolderType", "zipFileDirectory"], "urlConnection": ["webChannel", " urlResponse", "webconnection", "httpConnection", "URLconnection", " urlChannel", "inputConn", "urlconnection", "urlConn", "httpManager", "inputPool", "URLChannel", "httpPool", "httpConn", "inputConnection", "webResponse", "urlManager", "filePool", "inputManager", "urlChannel", "fileConn", " urlconnection", "webConnection", "URLResponse", "urlPool", "URLConnection", "fileManager", "urlResponse", "fileConnection"], "inputStream": ["outputContext", "InputFile", "inputChannel", "outputstream", "inputContext", "urlStream", "Inputstream", "InputChannel", "outputStream", "urlSession", " inputstream", "InputSession", " inputFeed", "outputChannel", "urlFeed", "urlFile", " inputFile", " inputSession", "InputStream", " inputContext", " inputChannel", "InputFeed", "InputContext", "inputFile", "inputSession", "inputFeed", "inputstream"]}}
{"id1": "701029", "id2": "20602651", "code1": "    public void loadSourceCode() {\n        int length = MAX_SOURCE_LENGTH;\n        try {\n            File file = new File(filename);\n            length = (int) file.length();\n        } catch (SecurityException ex) {\n        }\n        char[] buff = new char[length];\n        InputStream is;\n        InputStreamReader isr;\n        CodeViewer cv = new CodeViewer();\n        URL url;\n        try {\n            url = getClass().getResource(filename);\n            is = url.openStream();\n            isr = new InputStreamReader(is);\n            BufferedReader reader = new BufferedReader(isr);\n            sourceCode = new String(\"<html><pre>\");\n            String line = reader.readLine();\n            while (line != null) {\n                sourceCode += cv.syntaxHighlight(line) + \" \\n \";\n                line = reader.readLine();\n            }\n            sourceCode += \"</pre></html>\";\n        } catch (Exception ex) {\n            sourceCode = getString(\"SourceCode.error\");\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 1, "substitutes": {"loadSourceCode": ["getSourcecode", "loadSourcecode", "loadCodecode", "getSourceCode", "loadCodeCode", "loadSourceFile", "getSourceFile", "loadCodeFile", "loadsourceFile", "loadsourcecode", "loadsourceCode"], "length": ["position", "buffer", "size", "shape", "ph", "capacity", "block", "full", "key", "class", "load", "version", "delay", "page", "id", "limit", "address", "open", "th", "Length", "code", "content", "time", "path", "weight", "ext", "library", "value", "count", "work", "build", "angle", "len", "part", "end", "depth", "base", "zip", "data", "type", "L", "number", "text", "width", "total", "name", "l", "style", "string", "duration", "lock", "read", "filename"], "file": ["get", "image", "db", "buffer", "full", "files", "flow", "class", "object", "use", "feed", "il", "e", "page", "File", "check", "fe", "connection", "filename", "http", "path", "resource", "io", "fp", "FILE", "book", "f", "fs", "base", "data", "pe", "loader", "log", "b", "force", "name", "l", "folder", "play", "source", "self"], "buff": ["buffer", " background", "bb", " style", "Buffer", " Buffer", " text", " chunk", " buffer", " char", "Buff", " arr", "buf", " chars", "ch", " ch", "uf", "comp", "text", "utf", " rest", " buffers", " buf", "txt"], "is": ["get", "r", "os", "in", "ip", "fr", "Is", "p", "bis", "ie", "isl", "isa", "src", "i", "s", "ib", "il", "isi", "es", "address", "ris", "loc", "IS", "ui", "or", "iss", "http", "isc", "resource", "io", "ob", "ir", "out", "ais", "abs", "sr", "api", "serv", "ri", "err", "are", "it", "l", "res", "ar", "as", "web", "ur", "uri", "iv"], "isr": ["issri", "ISrc", "Isrs", "arsr", "isrr", "isri", "ISri", "Isrb", " isrb", "isrc", "asr", " isrc", "bsrt", "bsr", "isrb", "asrb", " isri", "isrt", " islr", "servrr", "servr", "servrt", "aslr", "bsrar", "issrb", "Islr", "asrs", "bsrr", "israr", "islr", " isrs", "arsrt", "ISrb", "Isr", "issrc", "isrs", "arsrar", "servrar", "arsrr", "issr", "ISr"], "cv": ["sc", "ctx", "cp", "rc", "view", "cc", "VC", "uv", "ctr", "nv", "gg", "lc", "cf", "lv", "vm", "cu", "bc", "cur", "cm", "vp", "vv", "fc", "tc", "hw", "ctrl", "CV", "conv", "vc", "vert", "b", "v", "cam", "cpp", "vr", "vs", "mc", "sv", "cb", "c"], "url": ["lr", "r", "image", "blog", "fr", "sl", "stream", "rl", "host", "view", "el", "feed", "fl", "il", "id", "page", "server", "address", "loc", "http", "location", "URL", "resource", "path", "ob", "ssl", "str", "link", "f", "Url", "api", "base", "err", "download", "loader", "log", "name", "l", "string", "web", "ur", "uri", "re", "source"], "reader": ["r", "in", "buffer", "writer", "ner", "cher", "worker", "Reader", "stream", "rer", "i", "rc", "roller", "ger", "rx", "ry", "handler", "server", "or", "ler", "http", "inner", "war", "resource", "editor", "io", "ir", "rr", " readers", "row", "reading", "rar", "iter", "re", "ri", "builder", "loader", "player", "er", "oder", "l", "parser", "ser", "read", "holder", "source", "bird"], "sourceCode": ["SourceScript", " sourceContent", " sourceFile", "ourcecode", "proxyCode", "parentText", "Sourcecode", "parentCode", " sourceText", "ourceContent", "SourceLine", " sourceScript", "ourceFile", "byteCode", "parentcode", "proxyFile", "SourceContent", "SourceCode", "sourceScript", "byteLine", "sourceLine", "sourceFile", "ourceScript", "sourcecode", "ourceCode", "proxycode", "sourceText", "ourceText", "bytecode", "sourceContent", " sourceLine", " sourcecode"], "line": ["next", "auto", "error", "ip", "in", "position", "sync", "one", "lf", "sl", "entry", "element", "key", "cell", "pre", "comment", "object", "character", "write", "on", "parse", "id", "page", "lc", "office", "lines", "Line", "lin", "code", "content", "li", "message", "day", "word", "hide", "row", "str", "end", "link", "part", "liner", "letter", "no", "none", "base", "unit", "inline", "model", "data", "LINE", "number", "text", "record", "l", "frame", "body", "string", "le", "source", "c", "non"]}}
{"id1": "19050432", "id2": "9096319", "code1": "    private static InputStream openNamedResource(String name) throws java.io.IOException {\n        InputStream in = null;\n        boolean result = false;\n        boolean httpURL = true;\n        URL propsURL = null;\n        try {\n            propsURL = new URL(name);\n        } catch (MalformedURLException ex) {\n            httpURL = false;\n            propsURL = null;\n        }\n        if (propsURL == null) {\n            propsURL = UserProperties.class.getResource(name);\n        }\n        if (propsURL != null) {\n            URLConnection urlConn = propsURL.openConnection();\n            if (httpURL) {\n                String hdrVal = urlConn.getHeaderField(0);\n                if (hdrVal != null) {\n                    String code = HTTPUtilities.getResultCode(hdrVal);\n                    if (code != null) {\n                        if (!code.equals(\"200\")) {\n                            throw new java.io.IOException(\"status code = \" + code);\n                        }\n                    }\n                }\n            }\n            in = urlConn.getInputStream();\n        }\n        return in;\n    }\n", "code2": "    private void handleNodeRegainedService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement outageUpdater = dbConn.prepareStatement(OutageConstants.DB_UPDATE_OUTAGE_FOR_SERVICE);\n                outageUpdater.setLong(1, eventID);\n                outageUpdater.setTimestamp(2, convertEventTimeIntoTimestamp(eventTime));\n                outageUpdater.setLong(3, nodeID);\n                outageUpdater.setString(4, ipAddr);\n                outageUpdater.setLong(5, serviceID);\n                outageUpdater.executeUpdate();\n                outageUpdater.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeRegainedService: closed outage for nodeid/ip/service \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeRegainedService could not be recorded  for nodeId/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            } else {\n                log.warn(\"\\'\" + EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" does not have open record.\");\n            }\n        } catch (SQLException se) {\n            log.warn(\"SQL exception while handling \\'nodeRegainedService\\'\", se);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"openNamedResource": ["openNestedResources", "openParamedresource", "openNnamedResource", "openParamingURI", "openParamedResources", "openNamingResources", "openNestedResource", "openNestedresource", "openParamingResources", "openNestedURI", "openNnamedURI", "openNamedURI", "openNnamedResources", "openNnamedresource", "openParamedResource", "openNamedresource", "openNamingresource", "openNamingResource", "openNamedResources", "openParamedURI", "openParamingresource", "openParamingResource", "openNamingURI"], "name": ["size", "n", "full", "key", "class", "old", "version", "sea", "parent", "id", "address", "ame", "info", "path", "resource", "word", "value", "file", "str", "part", "NAME", "url", "prefix", "base", "definition", "data", "type", "Name", "names", "string", "named", "uri", "source", "filename", "username"], "in": ["get", "r", "pin", "ic", "inn", "gin", "i", "socket", "cin", "input", "thin", "din", "edIn", "val", "conn", "result", "connection", "inner", "resource", "vin", "nin", "out", "con", "rin", "kin", "ini", " out", "rec", "fc", "f", "url", "login", "data", "err", "b", "token", "oin", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "win", "source", "ac", "inc"], "propsURL": [" propsSSL", "perrsURL", "propsUR", "proopsLL", "prodsUrl", "procsurl", "prosUrl", " prodsurl", "prolsURI", "probsLL", " propsLL", "prodsCL", "prosURI", "prorsUrl", "proportsUrl", " prodsURI", "pronsLL", "proportsURL", " proportsLL", "proopsurl", "prosLL", "probsURL", " propsUR", "prodsLL", "pronsUR", "progsURI", "perpsURL", "proportsSSL", " proportsELF", "ProsUrl", "proppsUR", "proppsUrl", " prolsSSL", "prorsURL", "probsUL", "propsurl", " propsCL", " prodsCL", " propsUrl", "perpsFile", "propsELF", "prodsURL", "proppsLL", "perpsurl", "propdsURL", "perrsurl", "proportsurl", "propsUrl", "prorsFile", "propsCL", "prosUL", "pronsURL", "proopsURL", "prodsURI", " proportsURL", "prodsUR", "prodsSSL", "propsUL", "procsURL", " proportsUR", " propsUL", " prolsURI", "PropsSSL", "prosURL", "propsSSL", "proopsCL", " prolsurl", "prodsFile", "prolsSSL", "progsURL", "progsurl", "procsURI", "proportsUL", "propsFile", "proopsELF", "proportsURI", "progsCL", "proppsURL", "procsUrl", "protsURL", "procsSSL", " proportsUrl", "PropsUrl", "proopsUR", "perrsFile", "PropsURL", "prorsELF", "PropsURI", " propsurl", " propsELF", "ProsSSL", "proopsURI", "proportsELF", "protsurl", "propdsLL", "propsLL", "ProsURI", "protsFile", "proopsUrl", "pronsUrl", "prolsurl", "proportsLL", "probsUrl", "prorsurl", "prolsURL", " propsURI", "proportsUR", " proportsUL", " prolsURL", " prodsURL", "prorsUR", "propdsUrl", "propsURI", "ProsURL", "prosSSL", "prodsurl", "propdsUR"], "urlConn": [" urlCmd", "urlCod", " urlConnect", " urlconn", "httpContext", " urlConf", "sslCod", "fileCmd", "urlCond", "sslconn", "httpConn", "sslCond", "fileConnect", "httpconn", "urlConnect", "urlCmd", "urlContext", "URLConf", "sslConn", " urlCod", "URLContext", "httpConf", "URLConnect", "fileConn", "sslConnect", "fileCond", "httpCod", "URLConn", "sslCmd", "urlconn", "urlConf", "httpConnect", " urlCond", " urlContext"], "httpURL": ["apiUrl", "HttpML", "apiURL", "httpsurl", "autourl", "httpsSSL", "httpsURI", "apiUR", "autoUrl", "autoURL", " httpURI", " httpML", "HttpUR", "autoSSL", "httpUrl", "httpSSL", " httpUrl", "HttpURL", " httpSSL", "httpURI", "apiML", "HttpUrl", "httpUR", " httpurl", "httpML", "httpsUR", "HttpURI", "httpsURL", " httpUR", "httpsUrl", "httpurl"], "hdrVal": [" hheaderStr", "hheaderStr", "hndDef", "hhrDef", "hDRval", "hrcBu", "hdValues", "hhrValues", "hhrval", "hdrValue", "hhrBu", " hheaderValue", "hDRValues", "hdrBu", "hdval", "HdrVal", "hDRVal", "hheaderVol", "hdrval", "HhrValues", "hdrStr", "hrVal", "hhrVal", "HdrBu", " hdrValue", " hheaderVal", "hrcDef", "hdrValues", "HdrValues", "hreqStr", "hheaderValue", "HhrBu", "hheaderVal", " hdrVol", "HhrValue", "hreqValue", "HdrValue", "HhrDef", "Hdrval", "hdrDef", "hreqVol", "hreqVal", "hhrValue", "hrValue", "hrcValue", "hrStr", " hheaderVol", "hdVal", " hdrStr", "hdValue", "HdrDef", "hrVol", "hndBu", "hndVal", "Hhrval", "hDRValue", "HhrVal", "hrcVal", "hdrVol", "hndValue"], "code": ["category", "expected", "error", "success", "rate", "level", "one", "ie", "go", "msg", "key", "ce", "rc", "cc", "comment", "class", "version", "cat", "e", "ode", "id", "core", "rule", "const", "check", "fail", "info", "result", "state", "content", "desc", "reason", "message", "coded", "response", "grade", "index", "see", "codes", "zone", "line", "value", "count", "ge", "url", "no", "zip", "mode", "data", "type", "pe", "charge", "ack", "xx", "test", "status", "number", "text", "pc", "co", "age", "string", "score", "Code", "cod", "header", "c", "ec"]}}
{"id1": "6260216", "id2": "19134229", "code1": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"send": ["request", "get", "process", "Send", "transfer", "reply", "sent", "write", "open", "from", "submit", "report", "pack", "exec", "update", "download", "execute", "append", "transform", "text", "method", "export", "call", "invoke", "command", "flush", "dump"], "s": ["S", "os", "details", "bytes", "p", "n", "qs", "files", "i", "is", "bs", "strings", "its", "ls", "ns", "ips", "ses", "es", "t", "sb", "lines", "objects", "services", "aws", "params", "ssl", "ions", "ings", "abs", "f", "opens", "sets", "uploads", "o", "u", "b", "rows", "ops", "ids", "l", "d", "string", "ps", "gs"], "s1": ["S1", "p1", "strings1", "s81", "s2", "ssl0", "strings2", "p0", "ses81", "ssl2", "p01", "S0", "S2", "ses1", "ses0", "strings0", "s0", "S01", "ses2", "s01", "ssl1", "S81", "strings01", "ssl81", "p2"], "httpurlconnection": ["httpstringsystem", "httpstringConnection", " httpurlsystem", "httplookconnect", "httpllconnect", "Httpurlproblem", "httpurlconnect", "httpreturnposition", "httpsurlconnect", "workhttpconnection", "urlllconnection", " httpshellConnection", "httphttpconnection", "httphttpconnect", "httpwebreference", "httpwebconn", "httpsurlConnection", "urlURLurl", "httpresourceconnection", "httpurlmanager", "httphttpcreation", "httpsbaserelation", "httplproblem", "httpshellconnection", "httpsurlcommunication", "httpwebrelation", " httpshellchannel", "httppullconnect", "httpURLconn", "Httpurlposition", "httpslcommunication", "workurlconn", " httpurlConnection", "Httpfileposition", "urlurlConnection", "httpwebconnection", "httpbreakcreation", "httpfileproblem", "httpweburl", "httpsurlmanager", "httpresourceconnect", "httpstringchannel", "httpshellConnection", "httpurlservice", "httpllrelation", "httpurlposition", "httplogrelation", "httplookrelation", "httpslreference", "httpslogcommunication", "httpURLurl", "httpURLcommunication", "httpurlreference", "httpllconnection", "httpcollconnection", "httplconnect", "httplogcommunication", "httpwebcommunication", "httpurlconn", "httplogConnection", "httpURLreference", "httpsurlfunction", "httpurlfunction", " httpresourceposition", "httpsbaseconnect", "httpresourceconn", "httpslconnection", "Httpurlconnection", "httpcollconn", "httpurlsystem", "httpresourceposition", "httpreturnconnection", "httplcommunication", " httpurlconn", "httpslservice", "httpslurl", "httpstringconnection", "httpscollservice", "httphttpConnection", "httpURLservice", " httpshellconnection", " httpresourceconnection", "httphttpcommunication", "httpsurlconnection", " httpshellsystem", " httpresourceconn", "workhttpconnect", "urlllConnection", "httpbasefunction", "workhttpconn", "urlllcommunication", "httpfileposition", "httplconn", "httpbreakconn", "httpreturnConnection", "httpsbaseconnection", "httpURLconnection", "Httpfilecommunication", " httpurlposition", "urlurlcommunication", "httpshellchannel", "httpsurlservice", " httpurlchannel", "workhttpcreation", "urlURLcommunication", "httpurlurl", "httpreturnproblem", "httpsURLrelation", "httpsbasefunction", " httpurlconnect", "httpfilecommunication", "httplconnection", "httplogconn", "httplogconnect", "httplookconnection", "httpslconn", "httppullConnection", "httpbreakconnect", "httpurlchannel", "httpcollchannel", "Httpfileproblem", "httplookfunction", "httpshellsystem", "urlURLconnection", "httpsURLconnection", "httpllConnection", "httpreturncommunication", "httpslogconn", "httpurlrelation", "httpsurlrelation", "httpbreakconnection", "httpurlcreation", "urlURLreference", " httpresourceconnect", "Httpurlcommunication", "httpurlproblem", "httpsurlconn", "httpscollconnection", "httplposition", "httpcollservice", "httpslogconnection", "urlurlreference", "urlllconnect", "httpURLmanager", "httpscollmanager", "httpscollconn", "httpbaserelation", "httpbaseconnection", "Httpfileconnection", "httplogfunction", "httpslmanager", "httpURLrelation", "httpsURLcommunication", "httpcollConnection", "workurlconnection", "httplConnection", "httpslogConnection", "httpsURLconn", "httpfileconnection", "httpbaseconnect", "urlurlconnection", "httpurlcommunication", "httpcollsystem", "workurlcreation", "httpllconn", "httpcollmanager", "httpreturnconnect", "urlurlurl", "httpllcommunication", "urlurlconnect", "httppullcommunication", "httppullconnection", "httplogposition", "workurlconnect", "httpurlConnection", "httphttpconn", "httplogconnection", "httpllcreation"], "datainputstream": ["datrainoutputpath", "datanacutpath", "datainlogstream", "dataincutpath", "datainlogsw", "datainststream", "datrainputsw", "datainoutputpath", "dataincutview", "datainstform", "datainstructform", "datainoutputStream", "datanacutstream", "datainlogpath", "datainstructpath", "datanaputsw", "datanacutview", "dataincutsw", "datainutpath", "datanaputstream", "datainstructstream", "datainutstream", "datainutview", "datrainoutputsw", "datanaputview", "datrainoutputform", "datainputsw", "datainputStream", "datrainputpath", "datainvalsw", "datainstructStream", "datainvalstream", "datainlogview", "datainstpath", "datrainputStream", "datanacutsw", "datainutsw", "dataincutstream", "datainoutputsw", "datrainputstream", "datainutStream", "datainvalStream", "datainoutputform", "datrainoutputstream", "datainvalpath", "datrainoutputStream", "datainoutputstream", "datainputpath", "datanaputpath", "datainstStream", "datainputview", "datainputform", "datrainputform"], "url": ["fr", "sl", "ul", "g", "stream", "rl", "host", "feed", "fl", "ls", "bb", "lc", "www", "page", "server", "address", "conn", "loc", "connection", "http", "li", "URL", "resource", "ob", "ssl", "file", "f", "Url", "api", "base", "gl", "log", "org", "ll", "l", "string", "web", "ur", "uri", "source", "config", "c"], "dataoutputstream": [" dataoutputpath", "dataOutputStream", "dataOutputpath", "datainputchannel", " dataoutputStream", " dataputpath", " dataoutputchannel", "datainputStream", "dataoutputchannel", " dataputstream", " dataputchannel", "dataOutputchannel", "dataputchannel", " dataputStream", "dataputpath", "dataputStream", "dataoutputpath", "dataputstream", "dataoutputStream", "datainputpath", "dataOutputstream"]}}
{"id1": "949327", "id2": "6501291", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "9275622", "id2": "23611215", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copyFolder", "transferfile", "copyFolder", "transferFolder", "copyFiles", "copyfile", "moveFolder", "transferFile", "moveFiles", "transferFiles", "moveFile", "movefile"], "_file1": ["_fileOne", "_file0", "_files1", "_zipone", "_mail2", "_resourceFirst", "_mail1", "_resourceone", "_File0", "_zipOne", "_fOne", "_File01", "_resource1", "_fone", "_fileone", "_files2", "_fileFirst", "_files01", "_mail0", "_mail01", "_files0", "_file01", "_File1", "_zipFirst", "_resourceOne", "_f1", "_fFirst", "_File2", "_zip1"], "_file2": ["jfile5", "jfile2", " _file3", "jmodelsecond", "_playTwo", "_play4", "_fileTwo", " _files4", "_play2", " _filesTwo", "_play5", "_model1", "_playsecond", "_play3", " _fileTwo", "jfilesecond", "_play1", "_files4", "jmodel2", "_filesTwo", " _files3", "_File5", "_filesecond", "jmodel5", "_files2", "_file5", "_model5", " _files2", " _file4", "_File1", "_file3", "_Filesecond", "jfile1", "_modelsecond", "_model2", "_file4", "_File2", "_files3", "jmodel1"], "fis": ["afais", "cfris", "cfos", "lfiss", "fi", " fas", "infis", " fris", "cfiss", "Fos", "infos", "infils", " fi", "afiss", "infiss", " fiss", "lfi", "cfis", "afis", "Fas", "lfis", "lfais", " fils", "fris", "Fils", " fais", "fiss", "fils", "fas", "Fris", "fais", "afi", "Fis", "cfas", "Fiss"], "fos": ["lis", "Faos", "infros", "Fros", "gus", "feus", "loes", "infus", "pos", "fOS", "foes", "gis", "fros", "fios", "flos", " foos", "pis", "infoos", "faos", "Fus", "fo", "Fos", "infos", "foses", "flis", "Foses", "los", "info", "foos", "infaos", "feoses", "floes", " fus", "goses", " faos", "feis", "Fo", " fo", " fios", "poes", "Fios", "gos", "infios", "flOS", "lOS", " fros", "pOS", "Foos", "fus", "feos", "Fis"], "canalFuente": ["canalBuente", "canalFuestro", "canalBuento", "canalCraencia", "canalBuze", "canaledBuje", "canallBuence", "canalBuencia", "canalFUestro", "canalsBuento", "canalFuencia", "canalFuze", "canallBuze", "canalFuento", "canallBuente", "canallFuencia", "canalKuente", "canaledFuente", "canaledFuje", "canalKuze", "canalCraence", "canalBuestro", "canaledBuente", "canalBuje", "canalFUze", "canaledFuze", "canalsFuento", "canalFuence", "canalsBuence", "canalFuje", "canalFUente", "canalSuente", "canalKuence", "canallFuze", "canallFuence", "canalCraente", "canalsBuente", "canalFUencia", "canallBuencia", "canalCraento", "canaledBuze", "canalFUence", "canalsFuence", "canalsFuencia", "canalBuence", "canalSuze", "canaledBuestro", "canalsBuencia", "canalsFuente", "canallFuente", "canaledFuestro", "canalKuento", "canalSuestro", "canalKuencia", "canalFUje", "canalSuje"]}}
{"id1": "22046596", "id2": "13891080", "code1": "        public void copy(File s, File t) throws IOException {\n            FileChannel in = (new FileInputStream(s)).getChannel();\n            FileChannel out = (new FileOutputStream(t)).getChannel();\n            in.transferTo(0, s.length(), out);\n            in.close();\n            out.close();\n        }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        logger.debug(\"copyFile(srcFile={}, destFile={}) - start\", srcFile, destFile);\n        FileChannel srcChannel = new FileInputStream(srcFile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destFile).getChannel();\n        try {\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "p", "sync", "upload", "Transfer", "all", "cp", "transfer", "Copy", "write", " cp", "to", " copied", "clip", "io", " copying", "file", " dup", "exec", "zip", "download", "paste", "put", " Copy", " copies", " transfer"], "s": ["S", "os", "m", "p", "sl", "g", "files", "i", "src", "is", "input", "xs", "ls", "ns", "e", "ses", "sin", "es", "sb", "sf", "sh", "a", "services", "se", "ssl", "ds", "storage", "x", "f", "fs", "o", "u", "b", "v", "south", "w", "ins", "l", "ss", "as", "si", "ps", "gs", "sv", "outs", "less", "source", "c", "ts"], "t": ["r", "T", "m", "template", "p", "n", "g", "i", "object", "e", "ty", "to", "target", "ta", "z", "at", "file", "tc", "x", "down", "f", "ot", "o", "tp", "temp", "b", "y", "v", "it", "l", " T", "tty", "tf", "tr", "tor", "pt", "c", "ts"], "in": ["r", "m", "h", "p", "pin", "sync", "g", "n", "inn", "i", "is", "socket", "init", "input", "e", "id", "sin", "din", "conn", "inner", "io", "pull", "nin", "ssl", "rin", "file", "min", "f", "url", "login", "b", "ins", "bin", "In", "l", "reader", "IN", "d", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "plain", "client", "writer", "p", "obj", "sync", "off", "n", "g", "output", "user", "parent", "ex", "conn", "connection", "ext", "not", "io", "at", "file", "x", "f", "o", "channel", "null", "err", "temp", "b", "v", "w", "net", "call", "l", "bin", "d", "again", "outs", "OUT", "c", "inc"]}}
{"id1": "5759961", "id2": "21489105", "code1": "    @Override\n    public User saveUser(User user) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(user.getPassword().getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            BigInteger bigInt = new BigInteger(1, hash);\n            String hashtext = bigInt.toString(16);\n            while (hashtext.length() < 32) {\n                hashtext = \"0\" + hashtext;\n            }\n            user.setPassword(hashtext);\n            user.setDataRegjistrimit(new Date());\n            return em.merge(user);\n        } catch (Exception e) {\n            throw new NestedException(e.getMessage(), e);\n        }\n    }\n", "code2": "    public static String md5(String message, boolean base64) {\n        MessageDigest md5 = null;\n        String digest = message;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(message.getBytes());\n            byte[] digestData = md5.digest();\n            if (base64) {\n                Base64Encoder enc = new Base64Encoder();\n                enc.translate(digestData);\n                digest = new String(enc.getCharArray());\n            } else {\n                digest = byteArrayToHex(digestData);\n            }\n        } catch (NoSuchAlgorithmException e) {\n            LOG.warn(\"MD5 not supported. Using plain string as password!\");\n        } catch (Exception e) {\n            LOG.warn(\"Digest creation failed. Using plain string as password!\");\n        }\n        return digest;\n    }\n", "label": 1, "substitutes": {"saveUser": ["submitAccount", "saveAccount", "submitUser", "savePerson", " savePerson", "submitPerson", "saveuser", "SaveAccount", "submituser", " saveAccount", "Saveuser", "SavePerson", " saveuser", "SaveUser"], "user": ["request", "job", "account", "db", "clean", "blog", "service", "creator", "User", "query", "one", "tool", "full", "author", "profile", "class", "up", "object", "use", "you", "USER", "app", "used", "bug", "e", "parent", "entry", "valid", "rule", "home", "per", "replace", "group", "module", "result", "or", "ver", "content", "editor", "resource", "word", "student", "book", "config", "uid", "this", "base", "model", "data", "log", "users", "force", "record", "name", "me", "password", "plugin", "project", "string", "facebook", "style", "team", "usr", "person", "self", "username"], "digest": ["signest", "Digit", " digert", "DigEST", "mdest", "signEST", "mdit", "diger", "Digert", "Diger", " digEST", "bigester", "bigge", "Digest", " digge", "Digge", " diger", "digit", "Digester", " digester", "mdge", "genit", "digge", "digester", "genest", "genge", "bigert", "digEST", "mdEST", "digert", "genEST", "signer", "biger", "bigest", "signester"], "hash": ["mac", "image", "db", "match", "h", "max", "query", "html", "ash", "full", "block", "key", "version", "id", "cache", "check", "code", "sum", "array", "index", "message", "num", "count", "Hash", "build", "fill", "url", "depth", "base", "update", "her", "sha", "number", "search", "total", "memory", "password", "math", "string", "empty", "current", "hex"], "bigInt": ["BigString", "hashInteger", "hugeUrl", "hashInt", "bigString", "bigint", "hugeInteger", "largeInteger", "largeInt", "hugeint", "hugeInt", "hashUrl", "BigInt", " bigInteger", "bigInteger", "largeint", "largeString", "bigUrl", "hashint", " bigint", " bigString", "BigInteger", "Bigint", " bigUrl"], "hashtext": ["ashfeed", "hashTEXT", "HashTEXT", "ashText", "hashstring", "hashword", "Hashword", "ashtext", "ashstring", "hashpath", "sumtext", "Hashstring", "sumfeed", " hashpath", " hashTEXT", "ashword", "HashText", "Hashpath", " hashText", "sumword", "sumText", "sumstring", "ashpath", "Hashfeed", "ashTEXT", "hashfeed", "hashText", "sumTEXT", " hashstring", " hashword", "Hashtext"]}}
{"id1": "11484416", "id2": "18433984", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "20275821", "id2": "8452134", "code1": "    public FileAttribute getAttribute(URL url) throws VFSException {\n        try {\n            con = (HttpURLConnection) url.openConnection();\n            con.setInstanceFollowRedirects(false);\n            int response = con.getResponseCode();\n            if (response >= 400) {\n                return new DefaultFileAttribute(false, 0, null, FileType.NOT_EXISTS);\n            }\n            boolean redirect = (response >= 300 && response <= 399);\n            if (redirect) {\n                String location = con.getHeaderField(\"Location\");\n                return getAttribute(new URL(url, location));\n            }\n            return new DefaultFileAttribute(true, con.getContentLength(), new Date(con.getLastModified()), url.toString().endsWith(\"/\") ? FileType.DIRECTORY : FileType.FILE);\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n            throw new WrongPathException(file.getAbsolutePath());\n        } catch (IOException e) {\n            throw new VFSIOException(\"IOException opening \" + file.getAbsolutePath(), e);\n        } finally {\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public int exists(String fileToCheck) throws IOException {\n        FTPClient ftp = new FTPClient();\n        int found = 0;\n        try {\n            int reply = 0;\n            ftp.connect(this.endpointURL, this.endpointPort);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                throw new IOException(\"Ftp exists server refused connection.\");\n            }\n            if (!ftp.login(\"anonymous\", \"\")) {\n                ftp.logout();\n                throw new IOException(\"FTP: server wrong passwd\");\n            }\n            ftp.enterLocalPassiveMode();\n            if (ftp.listNames(fileToCheck) != null) {\n                found = 1;\n            }\n            ftp.logout();\n        } catch (Exception e) {\n            throw new IOException(e.getMessage());\n        }\n        return found;\n    }\n", "label": 0, "substitutes": {"getAttribute": ["createattribute", "setAtt", "GetFeature", "setAttributes", "createFile", " getAttributes", "createAtt", " getAtt", " getFile", "GetAttribute", "Getattribute", "getattribute", " getFeature", "getAtt", "getFeature", "createFeature", "setattribute", "getFile", "createAttribute", "setAttribute", "GetFile", "getAttributes", " getattribute", "createAttributes"], "url": ["request", "image", "client", "email", "sl", "rl", "host", "class", "socket", "object", "el", "proxy", "context", "user", "bug", "version", "il", "route", "page", "lc", "server", "cache", "address", "conn", "loc", "connection", "http", "path", "resource", "URL", "ssl", "file", "link", "f", "Url", "api", "base", "log", "name", "l", "string", "ur", "uri", "source", "config", "c"], "con": ["plain", "db", "client", "ca", "connect", "fa", "rc", "cn", "cc", "socket", "fl", "user", "version", "ln", "cons", "cr", "on", "CON", "lc", "cf", "com", "ex", "cache", "coll", "run", "per", "conn", "open", "ran", "ver", "connection", "http", "bc", "cur", "ob", "cm", "ssl", "conf", "fc", "uc", "fn", "Con", "fun", "cover", "ctrl", "en", "file", "close", "rev", "f", "exec", "ch", "conv", "login", "can", "log", "cl", "pc", "co", "un", "ocon", "non", "re", "sub", "func", "c", "ec"], "response": ["request", "next", "image", "error", "success", "size", "received", "output", "reply", "respons", "version", "route", "server", "json", "answer", "result", "connection", "code", "http", "resource", "index", "reason", "successful", "message", "Response", "value", "function", "resp", "ception", "onse", "xx", "status", "number", "site", "body", "respond", "uri", "length"], "redirect": ["reriff", "undred", "rediff", "radirection", "undirection", "Redirection", "redocol", "redred", "Redication", "undiff", "redirection", "Redocol", " redirection", "undirect", "Redirect", " redred", "radirect", "rdirection", "radocol", "rerirection", "rdirect", "rdication", "redication", "rerirect", " rediff", "radication", "rdocol", "rerred"], "location": ["position", "error", "localhost", "object", "layout", "reference", "route", "directory", "address", "origin", "loc", "connection", "format", "region", "resource", "path", "content", "message", "direction", "description", "file", "link", "Location", "area", "feature", "null", "data", "type", "LOC", "local", "collection", "language", "document", "remote", "href", "string", "uri", "layer", "filename", "length"]}}
{"id1": "18748516", "id2": "18696387", "code1": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["clone", "p", "sync", "all", "transfer", "Copy", "write", "replace", "diff", "Cop", " copied", "clip", "cop", "change", " copying", "file", "zip", "download", "append", "paste", "put", "split", " Copy", "cmp", " clipboard", "dump", "move"], "fromFile": [" fromfile", "fromPlace", "fromFilename", "sourcefile", "FromFile", " fromDirectory", "FromDirectory", "fromfile", " fromPlace", "FromFilename", "fromDirectory", "Fromfile", "sourceFile", "sourceDirectory", "addressDirectory", "FromPlace", "addressFilename", "addressfile", "addressFile", "sourcePlace", "sourceFilename"], "toFile": [" tofile", "tofile", "targetFILE", "toString", "outputFILE", "ToString", "targetPlace", "throughFILE", "toPlace", "toFilename", "throughFile", " toString", "targetfile", "toFILE", "throughPlace", "targetString", "targetFilename", "ToFilename", " toFilename", "ToFile", "outputPlace", "throughfile", "targetFile", "outputfile", "Tofile"], "inputFile": ["InputFile", " inputPage", "fromPlace", "outStream", " inputLibrary", " inputPlace", "outStyle", " inputfile", "fromfile", "InputStyle", " inputStream", "fromLibrary", "inputPlace", "currentLibrary", "currentPlace", "currentfile", "outPage", "InputStream", "InputPage", " inputStyle", "inputLibrary", "inputStyle", "inputfile", "outFile", "inputPage", "currentFile", "inputStream"], "outputFile": ["targetDir", "targetFolder", "outputPath", "outputDir", "outputStyle", "targetPath", "inputFolder", "targetfile", "Outputfile", "outputFolder", " outputStyle", " outputfile", "OutputDir", "OutputFile", "OutputPath", "inputfile", "OutputFolder", " outputDir", "outputfile", "OutputStyle", "targetFile", "targetStyle", "inputPath"], "in": ["r", "image", "get", "pin", "ic", "inn", "gin", "isin", "i", "socket", "s", "init", "cin", "input", "ln", "sin", "din", "lin", "connection", "a", "inner", "pull", "nin", "con", "rin", "ini", "into", "file", "inside", "min", "f", "login", "ins", "bin", "In", "l", "reader", "IN", "again", "win", "issue", "source", "up", "inc"], "out": ["Out", "image", "error", "plain", "client", "writer", "sync", "one", "n", "off", "up", "i", "output", "s", "write", "parent", "ex", "cache", "outside", "to", "io", "at", "file", "raw", "line", "o", "null", "exec", "lib", "b", "v", "over", "w", "other", "net", "again", "as", "outs", "outer", "OUT", "inc"], "c": ["r", "C", "sc", "m", "p", "n", "i", "ce", "rc", "cc", "character", "cr", "e", "id", "cy", "ci", "lc", "cf", "t", "cu", "code", "nc", "pointer", "dc", "index", "oc", "cm", "uc", "fc", "xc", "count", "esc", "x", "f", "col", "ch", "enc", "o", "k", "ac", "u", "b", "v", "char", "cl", "ct", "pc", "l", "d", "current", "ec"]}}
{"id1": "149935", "id2": "3184073", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(String fromPath, String toPath) {\n        try {\n            File inputFile = new File(fromPath);\n            String dirImg = (new File(toPath)).getParent();\n            File tmp = new File(dirImg);\n            if (!tmp.exists()) {\n                tmp.mkdir();\n            }\n            File outputFile = new File(toPath);\n            if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                FileInputStream in = new FileInputStream(inputFile);\n                FileOutputStream out = new FileOutputStream(outputFile);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconvert", "Convert", "unvert", "unverted", "subversion", "oconverted", "CONversion", "converting", "subverted", "subverting", "unception", "unversion", " deconverted", " deconvert", "conversion", "subvert", "CONverting", "CONception", "Converted", "CONverted", " deconverting", "conception", " deconversion", "oconverting", "CONvert", "oconversion", "Conception", "Conversion", "Converting", "converted"], "src": ["video", "feat", "stage", "sc", "component", "obj", "upload", "ctx", "attr", "stream", "rl", "rc", "tmp", "load", "s", "impl", "input", "slice", "sit", "sn", "sin", "RC", "sb", "cb", "scene", "Dest", "loc", "code", "rb", "ource", "inst", "path", "ref", "fp", "resource", "ssl", "img", "proc", "gb", "fn", "file", "Source", "supp", "config", "storage", "secure", "sel", "dist", "url", "buf", "st", "prot", "req", "download", "spec", "cpp", "SourceFile", "name", "reader", "string", "href", "sth", "sys", "uri", "gz", "cmp", "back", "source", "filename", "username"], "dest": ["obj", "class", "tmp", "std", "home", "Dest", "target", "dc", "path", "orig", "disk", "img", "fn", "dist", "dir", "lib", "null", "temp", "test", "di", "bin", " destination", " dst", "cont", "dat", "source", "txt"], "in": ["r", "pin", "n", "inn", "stream", "isin", "i", "is", "input", "ex", "din", "t", "val", "inas", "inf", "a", "io", "ini", "file", "f", "pass", "doc", "login", "data", "err", "ins", "bin", "In", "d", "IN", "reader", "as", "ps", "win", "source", "up", "inc"], "p": ["r", "bp", "m", "h", "j", "P", "pp", "g", "pa", "cp", "i", "pre", "s", "pg", "e", "po", "pd", "t", "py", "per", "lp", "fp", "op", "cop", "pb", "part", "pi", "f", "tp", "o", "pe", "jp", "b", "v", "pm", "wp", "pc", "l", "d", "ps", "parser", "np", "c", "pr", "sp"], "ds": ["os", "ups", "words", "sync", "ipes", "styles", "cs", "s", "bs", "xs", "dds", "DS", "gd", "icks", "dm", "dl", "hs", "ins", "vs", "da", "dat", " DS", "tests", "dates", "dp", "db", "dos", "nas", "cons", "ths", "lines", "docs", "posts", "tools", "dist", "ays", "ans", " sd", "utils", "ss", "d", "parts", "js", "ded", "ts", "qs", "models", "rs", "ls", "pd", "ges", "ks", "obs", "services", "lp", "groups", "ys", " props", "ps", "ld", "dd", "uds", "Ds", "plugins", "vals", "sts", "ils", "points", "scripts", "ns", "els", "dc", "ads", "ants", "dt", "df", " ps", "des", "data", "eps", "di", "amps", "gs", "sys"], "format": ["template", "host", "form", "pattern", "class", "layout", "sche", "fd", "version", "handler", "t", "Format", "filename", "path", "fp", "magic", "function", "ant", "at", "file", "fn", "part", "feat", "f", "url", "letter", "prefix", "unit", "api", "model", "scale", "data", "type", "struct", "spec", "tag", "atter", "record", "language", "nat", "name", "table", "frame", "style", "plugin", "string", "parser", "filter", "act", "source", "config"], "hasPixelData": ["hasByteSize", "showsPixeldata", "hasPixeldata", "showsPixelStyle", "hasBytedata", "hasByteStyle", "hasPictureData", "hasByteData", "hasPixelStyle", "haspixelData", "showsByteDATA", "hasPictureSize", " hasPixelSize", " hasPixeldata", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPixelDATA", "showsByteData", "haspixeldata", "haspixelSize", "hasPicturedata", "showsPixelDATA", "showsPixelData", "hasPixelSize"], "inflate": ["invenode", "infolate", "inadequate", "infface", "inadequATE", "insvenode", "insflate", "Inflace", "inflation", "infloation", "inflATE", "inffation", "infloate", "inflace", "insvenating", "infloated", "infloace", "invenATE", "inffate", "inflode", "Inflate", "inFlate", "InFlate", "inFlated", "insflATE", "invenating", "Inflated", "infolating", "invenate", "inFlace", "inflated", "insflating", "infolode", "insvenate", "inadequode", "inffated", "InFlated", "insvenATE", "Inflation", "insflode", "InFlace", "inflating", "inFlation", "inadequating", "infolATE", "InFlation"], "pxlen": ["axln", "fxln", "axlon", "mxsize", "pgl", "xpcount", "pplen", "pngcount", "camlen", "pxpos", "pxlon", "xplength", "pclin", "fxl", "pgden", "axlin", "pxcount", "pngsize", "pxLen", "fxpos", "mxlength", "pgLen", "campos", "fxdata", "pxl", "fxden", "ppl", "mxpos", "pnglength", "mxln", "axlen", "pxdata", "txlin", "xpsize", "txlon", "ppden", "pglen", "pnglen", "mxlen", "pxln", "fxLen", "mxcount", "xplen", "mxdata", "txln", "camln", "pcln", "pxden", "camdata", "fxlen", "pclon", "pclen", "txlen", "pxlength", "pxlin", "pxsize", "ppLen"], "out": ["Out", "pad", "error", "obj", "query", "up", "output", "user", "copy", "parent", "cli", "page", "server", "cache", "conn", "group", "state", "io", "line", "work", "step", "post", "store", "lib", "session", "re", "err", "log", "v", "inter", "co", "again", "list", "point", "sys", "outs", "lock", "gen", "dump", "OUT"]}}
{"id1": "6906419", "id2": "12078471", "code1": "    public static String encryptPassword(String password) {\n        try {\n            MessageDigest digest = java.security.MessageDigest.getInstance(\"SHA1\");\n            digest.update(password.getBytes(\"UTF-8\"));\n            byte[] hash = digest.digest();\n            StringBuffer buf = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                int halfbyte = (hash[i] >>> 4) & 0x0F;\n                int two_halfs = 0;\n                do {\n                    if ((0 <= halfbyte) && (halfbyte <= 9)) {\n                        buf.append((char) ('0' + halfbyte));\n                    } else {\n                        buf.append((char) ('a' + (halfbyte - 10)));\n                    }\n                    halfbyte = hash[i] & 0x0F;\n                } while (two_halfs++ < 1);\n            }\n            return buf.toString();\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"encryptPassword": ["decipherHash", "decipherString", "encipherPassword", "encryptString", "decryptpassword", "encryptHash", "encratepassword", "decryptString", "decryptPassword", "encipherpassword", "decipherpassword", "encipherHash", "enccryptHash", "encipherString", "enccryptpassword", "decipherPassword", "encrateHash", "enccryptPassword", "encrateString", "enccryptString", "encryptpassword", "decryptHash", "encratePassword"], "password": ["buffer", "words", "p", "crypt", "key", "pattern", "user", "input", "sword", "phrase", "address", "padding", "Password", "content", "array", "path", "message", "word", "wd", "prefix", "pass", "confirmed", "data", "token", "secret", "database", "text", " passwords", "name", "auth", "string", "project", "seed", "PASS", "username"], "digest": ["hashester", " digested", "signest", " digeter", "hasher", "digeter", "DigEST", "diffest", "DigText", "initests", " digests", "signEST", " digText", "Digeter", "diger", "digText", "diffester", "diffested", "Diger", " digEST", "digests", "initEST", "Digest", " diger", "Digester", " digester", "hashest", "Digests", "digester", "initText", "diffEST", "digEST", "hasheter", "signer", "digested", "initest", "Digested", "signester"], "hash": ["ha", "image", "error", "match", "buffer", "h", "batch", "query", "html", "ash", "block", "key", "map", "bug", "version", "id", "mask", "cache", "check", "address", "history", "sh", "diff", "handle", "code", "sum", "array", "index", "message", "value", "count", "Hash", "cover", "build", "ashes", "bh", "f", "url", "log", "char", "secret", "sha", "number", "search", "wave", "memory", "bin", "auth", "body", "header", "filter", "kh", "hed", "hex"], "buf": ["db", "pad", "abb", "la", "buffer", "cas", "bu", "fw", "bf", "ctx", "src", "ab", "queue", "func", "tmp", "uv", "bb", "pkg", "Buffer", "port", "sb", "coll", "home", "aux", "bc", "rb", "fb", "af", "va", "cur", "fp", "ob", "buff", "img", "out", "uber", "uc", "box", "pb", "Buff", "bh", "bag", "config", "f", "url", "wb", "abc", "conv", "vec", "builder", "data", "append", "b", "cv", "v", "uf", "ba", "cap", "runner", "vr", "bin", "nb", "cmp", "cb"], "i": ["ai", "ip", "h", "p", "j", "n", "ie", "key", "init", "multi", "fi", "ix", "slice", "e", "phi", "abi", "mu", "ci", "id", "gi", "ui", "info", "length", "mini", "a", "index", "li", "ii", "io", "iu", "ini", "count", "uni", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "b", "v", "ji", "oi", "it", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"], "halfbyte": ["superchar", "quartersecond", "sideByte", " halfabyte", "postbit", "thirdnumber", "littleByte", "wardbytes", "halfsecond", " halfByte", "quarterabyte", "halfnumber", "halfByte", "halfbytes", "sidereference", "postbyte", "Halfbyte", "quarterByte", "thirdbyte", "Halfchar", "halfabyte", "wardbyte", " halfurl", "quarterbyte", "thirdsecond", "littlereference", "littlebit", "halfbit", " halfchar", "sidebit", " halfbit", "littlebyte", "postabyte", "superbit", "quarterbit", "quarterurl", "halfchar", "halfurl", "wardurl", "halfreference", "HalfByte", " halfbytes", "sidebyte", " halfsecond", "quarterbytes", "quarternumber", " halfnumber", " halfreference", "superbyte", "Halfbit"], "two_halfs": ["two_halfrows", "two_halfbytes", "two_thirdrows", "two_halfis", "two_Halfbytes", "two_partis", "two_hatows", "two_hatrows", "two_commons", "two_thirds", "two_commonrows", "two_quarterrows", "two_thirdbytes", "two_Halfis", "two_thirdis", "two_quarterions", "two_partrows", "two_halfions", "two_Halfrows", "two_quarterows", "two_commonions", "two_halfows", "two_parts", "two_hations", "two_quarters", "two_commonows", "two_hats", "two_Halfs", "two_partbytes"]}}
{"id1": "2461169", "id2": "23666867", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "3731077", "id2": "3430784", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "transferfile", "transferSourceFile", "importFiles", " copySourceFile", "copyFiles", "copyfile", "importfile", "transferFile", "importFile", "transferFiles", "importSourceFile"], "from": ["before", "From", "client", "ca", "original", "left", "src", "form", "ce", "old", "user", "id", "address", "origin", "or", "a", "path", "resource", "io", "se", "at", "file", "of", "part", "start", "f", "url", "o", "this", "base", "data", "with", "range", "name", "by", " form", "d", "front", "without", "as", "remote", "about", "add", "back", "source", "config", "c"], "to": ["auto", "os", "toc", "client", "p", "size", "one", "too", "output", "socket", "object", "parent", "copy", "po", "office", "To", "t", "target", "or", "location", "TO", "top", "io", "into", "at", "file", "dest", "of", "root", "storage", "f", "o", "eto", "null", "until", "api", "base", "this", "temp", "type", "with", "b", "database", "token", "so", "name", "by", "site", "again", "as", "two", "point", "about", "source"], "parentDir": ["parentFile", "rootDir", "parentDirectory", "rootFolder", "ParentDirectory", "ParentFolder", "parentFolder", "currentDir", "currentFolder", "ParentFile", " parentDirectory", "currentdir", "rootDirectory", "rootFile", " parentdir", "outDir", "parentdir", " parentFile", "outFile", "ParentDir", "currentFile", "outFolder", "Parentdir", " parentFolder", "outDirectory"], "in": ["r", "image", "m", "pin", "sync", "ie", "inn", "isin", "gin", "i", "form", "rc", "pre", "init", "cin", "input", "on", "id", "arin", "din", "conn", "diff", "or", "lin", "inner", "vin", "io", "nin", "con", "ini", "fc", "rec", "kin", "work", "part", "inside", "rin", "min", "url", "o", "exec", "login", "err", "with", "trial", "it", "ins", "pc", "bin", "In", "l", "plugin", "again", "IN", "reader", "win", "source", "ac", "inc"], "out": ["Out", "ico", "auto", "client", "writer", "p", "sync", "off", "gin", "output", "init", "app", "cin", "input", "user", "ou", "win", "on", "cy", "ex", "option", "conn", "or", "inner", "io", "op", "at", "ot", "o", "channel", "exec", "vert", "can", "org", "w", "other", "net", "co", "call", "bin", "plugin", "again", "outer", "outs", "about", "c", "OUT", "ac", "inc"], "ic": ["ico", "aic", "ai", "auto", "irc", "cus", "sync", "IC", "i", "ik", "rc", "cc", "cs", "cin", "ix", "input", "ex", "ci", "lc", "conn", "loc", "or", "cu", "bc", "dc", "io", "op", "voc", "uc", "fc", "xc", "pic", "enc", "o", "vc", "ac", "iac", "cl", "nic", "ct", "pc", "co", "anc", "ig", "mc", "ics", "acs", "icc", "c", "inc", "ec"], "oc": ["aic", "toc", "sc", "ca", "cus", "i", "cc", "aco", "cy", "ci", "circ", "OC", "alloc", "loc", "or", "bc", "dc", "cur", "ocol", "io", "ob", "op", "wic", "voc", "uc", "fc", "xc", "oca", "oci", "roc", "o", "enc", "vc", "ac", "can", "ack", "org", "AC", "soc", "nic", "pc", "co", "anc", "mc", "ocon", "acs", "og", "mic", "oco", "c", "inc", "ec"]}}
{"id1": "21224967", "id2": "1141361", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"crear": ["generar", "Creas", "generare", "Crear", "generas", " Creare", " creare", " Crear", "Crea", "Creare", " crea", " creas", "genera", " Crea", " Creas"], "result": ["success", "error", "match", "db", "rate", "entry", "order", "currency", "comment", "default", "user", "page", "limit", "valid", "diff", "ver", "found", "grade", "response", "message", "Result", "ret", "df", "results", "out", "count", "function", "date", "value", "cash", "die", "feature", "err", "type", "mark", "status", "number", "force", "record", "res", "counter", "score", "ure", "event", "sign", "up", "length"], "sql": ["job", "db", "where", "query", "script", "sync", "sl", "q", "comment", "pg", "action", "install", "statement", " SQL", "SQL", "conn", "params", "fp", "ssl", "fn", "plan", "url", "serv", "exec", "base", "session", "update", "zip", "sq", "log", "printf", "dl", "database", "ql", "string", "seed", "setup", "cmd", "join", "up", "select", "repl"], "connection": ["position", "db", "error", "client", "connect", "BC", "union", "writer", "p", "query", "ctx", "cond", "relation", "socket", "proxy", "context", "pg", "environment", "section", "statement", "server", "cache", "Exception", "conn", "loc", "bc", "container", "graph", "index", "manager", "con", "function", "tc", "which", "connected", "engine", "session", "system", "log", "database", "collection", "application", "document", "driver", "table", "ion", "communication", "Connection", "lock", "event", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "p", "PS", "query", "pp", "qs", "pos", "pa", "cp", "cs", "bs", "proxy", "pg", "pre", "ns", "po", "ips", "pd", "properties", "conn", "ks", "pers", "cop", "params", "posts", "proc", "ds", "changes", "gres", "pe", "jp", "eps", "hs", "ins", "pc", "ops", "settings", "Ps", "vs", "ss", "pse", "gs", "pps", "ports", "pt", "pr", "sp"]}}
{"id1": "5676111", "id2": "21438069", "code1": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "code2": "    public ProjectDeploymentConfiguration createNewProjectDeploymentConfig(int projectID, String name, String description) throws AdaptationException {\n        ProjectDeploymentConfiguration config = null;\n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        try {\n            String query = \"INSERT INTO ProjectDeploymentConfigurations\" + \"(projectID, name, description) VALUES (\" + projectID + \", '\" + name + \"', '\" + description + \"')\";\n            connection = DriverManager.getConnection(CONN_STR);\n            statement = connection.createStatement();\n            statement.executeUpdate(query);\n            query = \"SELECT * FROM ProjectDeploymentConfigurations WHERE \" + \" projectID   = \" + projectID + \"  AND \" + \" name        = '\" + name + \"' AND \" + \" description = '\" + description + \"'\";\n            resultSet = statement.executeQuery(query);\n            if (!resultSet.next()) {\n                connection.rollback();\n                String msg = \"Attempt to create \" + \"ProjectDeploymentConfiguration failed.\";\n                log.error(msg);\n                throw new AdaptationException(msg);\n            }\n            config = getProjectDeploymentConfiguration(resultSet);\n            connection.commit();\n        } catch (SQLException ex) {\n            try {\n                connection.rollback();\n            } catch (Exception e) {\n            }\n            String msg = \"SQLException in createNewProjectDeploymentConfig\";\n            log.error(msg, ex);\n            throw new AdaptationException(msg, ex);\n        } finally {\n            try {\n                resultSet.close();\n            } catch (Exception ex) {\n            }\n            try {\n                statement.close();\n            } catch (Exception ex) {\n            }\n            try {\n                connection.close();\n            } catch (Exception ex) {\n            }\n        }\n        return config;\n    }\n", "label": 0, "substitutes": {"get": ["process", " quit", " download", "output", "print", "init", " exit", "run", " upload", "open", "info", "let", " extract", " it", "build", "end", "start", " this", "close", "exec", "download", "it", "export"], "cnt": [" cst", " cnn", "Cnc", "cwd", "Count", "Cwd", "encnt", "cNT", "rcnc", "cnd", "rcNT", " cnc", "rcnd", "count", "cnn", "Cnt", "fwd", "CNT", "encnn", "Cnn", "encNT", "fnt", "cst", "rcnt", " cnd", "fount", "encst", "cnc", "Cnd", "fNT", " cNT", " count", " cwd", "Cst"], "url": ["r", "blog", "image", "client", "sl", "host", "socket", "git", "impl", "ls", "bb", "page", "www", "server", "cache", "bel", "coll", "loc", "open", "connection", "http", "URL", "path", "resource", "cur", "ssl", "ir", "file", "str", "f", "Url", "channel", "session", "download", "b", "log", "org", "ll", "name", "l", "web", "ur", "uri", "source", "config", "c"], "conn": ["os", "ai", "client", "connect", "ca", "Conn", "p", "ctx", "n", "oss", "cp", "socket", "cn", "init", "cli", "ci", "ens", "server", "coll", "loc", "ann", "open", "connection", "nc", "http", "dc", "not", "cur", "io", "cm", "ob", "ssl", "out", "con", "en", "ch", "enc", "col", "exec", "api", "conv", "err", "org", "ct", "co", "Connection", "act", "cb", "c", "ec"], "is": ["lis", "os", "ip", "in", "ai", "Is", "us", "bis", "ie", "isl", "iso", "isa", "src", "i", "bs", "s", "init", "ois", "ib", "il", "id", "ci", "isi", "es", "ris", "loc", "IS", "info", "ui", "or", "open", "iss", "http", "ios", "isc", "io", "ob", "ir", "ssl", "iris", "ais", "iter", "close", "api", "ri", "are", "im", "res", "as", "uri", "ws"], "filename": ["ername", "size", "Filename", "files", "queue", "output", "class", "fd", "key", "title", "il", "directory", "phrase", "sf", "loc", "family", "format", "connection", "location", "path", "fp", "fn", "file", "f", "prefix", "nil", "login", "fil", "name", "l", "password", "ename", "string", "nl", "utf", "folder", "uri", "source", "length", "username"], "fos": ["lo", "fdis", " foss", "go", "fios", "efus", "fdos", "Fus", "gios", "foss", "fo", "Fos", "foses", "los", "Foses", "efoss", "Foss", "lios", "Ficks", " fus", "goses", "fdo", "efose", "Fo", " fo", " ficks", "ficks", "Fios", "gos", " fis", "loses", "efos", " fose", "Fose", "fus", "Fis", "fose", "fdicks", "fis"], "buffer": ["pause", "position", "bytes", "shape", "batch", "size", "queue", "output", "transfer", "feed", "input", "sequence", "reference", "bb", "page", "Buffer", "limit", "cache", "server", "phrase", "address", "source", "result", "padding", "fb", "buff", "uffer", "file", "iter", "buf", "binary", "channel", "base", "null", "data", "b", "border", "offset", "number", "wave", "document", "memory", "reader", "counter", "header", "seed", "vector", "duration", "read", "flush", "layer", "length"]}}
{"id1": "12782570", "id2": "4164833", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"logging": ["Logger", "Loguring", "loging", "Logging", "configing", "configuring", " loging", " logger", "logger", "loguring", "configging", " loguring", "configger", "Loging"], "wrap": ["get", "process", "image", "wire", "sw", "p", "h", "ow", "flash", "html", "stream", "use", " wrapped", "init", "ad", "parse", "handler", "core", "cache", "run", "or", "handle", "format", "war", "message", "word", "work", "we", "cover", "build", "box", "now", "bag", "util", "f", "binary", "api", "wb", "wrapper", "zip", "div", "builder", "wa", "b", " Wrap", "wp", "w", "nw", "transform", "force", "rap", "frame", "web", "wra", "lock", "ws", "widget", "create", "self", "pipe"], "buffer": ["pause", "pad", "writer", "template", "batch", "flash", "msg", "queue", "surface", "reply", "object", "transfer", "print", "feed", "view", "reference", "bb", "copy", "Buffer", "cache", "server", "source", "result", "board", "fb", "bm", "response", "ref", "report", "http", "buff", "message", "manager", "cover", "pb", "iter", "BU", "buf", "binary", "base", "wrapper", "builder", "player", "log", "b", "bar", "loader", "shell", "bin", "table", "frame", "reader", "header", "nb", "bridge", " buffers", "layer", "cb", " buf"], "encoding": ["coder", "encording", "decoded", "Encoded", "enoder", "cording", "ecryption", "challoder", "enaching", "challoded", "enoding", "coded", "decaching", "Encoder", "ecoded", "encryption", "encoded", "ecoder", "Encryption", "decoder", "coding", "ecoding", "Encoding", "decoding", "encoder", "enoded", "ecording", "encaching", "enording", "challaching", "decryption", "challoding"], "getEncoding": [" getEncoded", "getEncasing", " getEncocol", "getCoding", "getCoded", "getencoding", "getEncoded", "getEncocol", " getEncasing", "getCasing", "getEncression", "getencasing", "getCocol", " getEnoder", "getencocol", "getEnocol", " getEnression", "getCompression", "getEncoder", "getEnoder", "getCoder", "getencoder", "getEnoding", "getCression", " getEnoded", " getEncoder", "getEnression", "getCompoded", " getEnoding", " getEnocol", "getCompoder", "getCompoding", " getEnasing", " getEncression", "getEnoded", "getEnasing"], "headers": ["vals", "details", "h", "files", "types", "host", "s", "strings", "rs", "dict", "events", "workers", "links", "properties", "features", "lines", "keys", "objects", "padding", "writers", "http", "params", "frames", "breaks", "ings", "str", "options", "bits", "relations", "wrapper", "ints", "caps", "values", "blocks", "groups", "names", "ids", "settings", "heads", "body", "header", "parts", "ports", "ers", "head", "ppers", "fields", "plugins"], "is": ["lis", "os", "in", "mis", "Is", "us", "bis", "iso", "oss", "isl", "isa", "i", "bs", "s", "ois", "was", "its", "ses", "aos", "isi", "es", "ris", "IS", "ui", "or", "iss", "obs", "http", "ios", "ori", "nis", "has", "out", "iris", "bas", "ais", "abs", "fs", "api", "sis", "are", "isol", "las", "ins", "so", "ops", "as", "js", "ms", "cms", "ists", "ws", "tis"], "bos": ["os", "mis", "obi", "bots", "bis", "oos", "zos", "oops", "bs", "proxy", "ois", "bott", "was", "lins", "bo", "ubs", "ros", "ses", "aos", "abi", "home", "los", "android", "mobi", "ubis", "obs", "bc", "ios", "cos", "kb", "bes", "oses", "ob", "bps", "osa", "ko", "bas", "bi", "bh", "osi", "abs", "zo", " Bos", "bits", "fs", "oks", "mos", "pins", "shadow", "org", "bot", "so", "fits", "ops", "bones", "beans", "js", "obos", "cms", "obo", "outs", "ws", "oes", "opus", "tis", "uds"], "e": ["error", "ne", "de", "p", "one", "ie", "oe", "element", "i", "ce", "ee", "ze", "fe", "a", "ite", "be", "se", "esi", "E", "ale", "exc", "x", "ke", "f", "ception", "die", "o", "ev", "type", "pe", "err", "er", "ele", "je", "d", "ae", "re", "ea", "c", "ec"]}}
{"id1": "20623709", "id2": "20128728", "code1": "    public Long split(File targetDirectory, String prefix, long maxUnitBases, long maxUnitEntries) throws Exception {\n        if (!targetDirectory.exists()) {\n            if (!targetDirectory.mkdirs()) throw new Exception(\"Could not create target directory \" + targetDirectory.getAbsolutePath());\n        }\n        if (!size.isUnknown() && size.getBases() < maxUnitBases && (maxUnitEntries <= 0 || size.getEntries() < maxUnitEntries)) {\n            FileInputStream fis = new FileInputStream(this);\n            FileChannel fci = fis.getChannel();\n            FileOutputStream fos = new FileOutputStream(new File(targetDirectory, prefix + \"_0\" + \".fasta\"));\n            FileChannel fco = fos.getChannel();\n            ByteBuffer buffer = ByteBuffer.allocate(64000);\n            while (fci.read(buffer) > 0) {\n                buffer.flip();\n                fco.write(buffer);\n                buffer.clear();\n            }\n            fci.close();\n            fco.close();\n            return (long) 1;\n        } else {\n            long currentBasesCount = 0;\n            long currentEntriesCount = 0;\n            int targetCount = 0;\n            FileChannel fastaChannel = new FileInputStream(this).getChannel();\n            int totalSeqCount = 0;\n            long totalResiduesCount = 0;\n            try {\n                long prevTime = System.currentTimeMillis();\n                long fastaFileSize = this.length();\n                long fastaFileReadOffset = 0L;\n                long partitionStartOffset = 0L;\n                final int bufferSize = 1024 * 1024;\n                ByteBuffer fastaBuffer = ByteBuffer.allocateDirect(bufferSize);\n                int fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                for (; fastaFileReadOffset < fastaFileSize; ) {\n                    long nBytes = fastaChannel.read(fastaBuffer);\n                    if (nBytes <= 0) {\n                        fastaBuffer.limit(0);\n                        break;\n                    } else {\n                        fastaBuffer.flip();\n                        fastaFileReadOffset += nBytes;\n                    }\n                    for (; ; ) {\n                        if (!fastaBuffer.hasRemaining()) {\n                            fastaBuffer.clear();\n                            break;\n                        }\n                        int b = fastaBuffer.get();\n                        if (b == '\\r') {\n                        } else if (b == '\\n') {\n                            if (fastaReadState == FASTAFileTokenizer.DEFLINE) {\n                                fastaReadState = FASTAFileTokenizer.SEQUENCELINE;\n                            }\n                        } else if (b == '>') {\n                            if (fastaReadState == FASTAFileTokenizer.UNKNOWN) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            } else if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                fastaReadState = FASTAFileTokenizer.STARTDEFLINE;\n                            }\n                            if (fastaReadState == FASTAFileTokenizer.STARTDEFLINE) {\n                                if (currentBasesCount >= maxUnitBases || maxUnitEntries > 0 && currentEntriesCount >= maxUnitEntries) {\n                                    fastaBuffer.position(fastaBuffer.position() - 1);\n                                    long currentTime = System.currentTimeMillis();\n                                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileReadOffset - fastaBuffer.remaining()) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                                    prevTime = currentTime;\n                                    long partitionEndOffset = fastaFileReadOffset - fastaBuffer.remaining();\n                                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                                    nBytes = fastaChannel.transferTo(partitionStartOffset, partitionEndOffset - partitionStartOffset, partitionChannel);\n                                    partitionChannel.force(true);\n                                    partitionChannel.close();\n                                    targetCount++;\n                                    partitionStartOffset += nBytes;\n                                    currentBasesCount = 0;\n                                    currentEntriesCount = 0;\n                                    fastaReadState = FASTAFileTokenizer.UNKNOWN;\n                                } else {\n                                    fastaReadState = FASTAFileTokenizer.DEFLINE;\n                                    currentEntriesCount++;\n                                }\n                                totalSeqCount++;\n                            }\n                        } else {\n                            if (fastaReadState == FASTAFileTokenizer.SEQUENCELINE) {\n                                totalResiduesCount++;\n                                currentBasesCount++;\n                            }\n                        }\n                    }\n                }\n                if (partitionStartOffset < fastaFileSize) {\n                    long currentTime = System.currentTimeMillis();\n                    System.out.println(new java.util.Date() + \" Partition \" + targetCount + \" containing \" + currentEntriesCount + \" sequences and \" + currentBasesCount + \" residues ends at \" + (fastaFileSize) + \" and was created in \" + (currentTime - prevTime) + \" ms\");\n                    FileChannel partitionChannel = new FileOutputStream(new File(targetDirectory, prefix + \"_\" + targetCount + \".fasta\")).getChannel();\n                    fastaChannel.transferTo(partitionStartOffset, fastaFileSize - partitionStartOffset, partitionChannel);\n                    partitionChannel.force(true);\n                    partitionChannel.close();\n                    targetCount++;\n                }\n                if (size.isUnknown()) {\n                    size.setBases(totalResiduesCount);\n                    size.setEntries(totalSeqCount);\n                }\n            } finally {\n                fastaChannel.close();\n            }\n            return (long) targetCount;\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"split": ["process", "match", "sort", "sync", "delete", "transfer", "init", "parse", "Split", "copy", "archive", "run", "open", "diff", "share", "format", "build", "part", "start", "exec", "set", "update", "execute", "append", "cmp", "add", "join"], "targetDirectory": ["outputDirectory", "targetDir", " targetDir", "masterDirectory", "targetFolder", " targetFile", " targetPath", "baseDatabase", "outputFile", "baseFolder", "targetRoot", "basePath", "targetDatabase", "outputDir", "currentPath", "masterDatabase", "targetPath", "destDir", "destDirectory", "TargetRoot", "destFolder", "currentDir", "currentFolder", "baseDirectory", " targetRoot", "outputFolder", " targetFolder", "destFile", "TargetDirectory", "TargetFolder", "masterDir", "masterPath", "baseFile", "baseDir", "currentRoot", "TargetDir", "TargetPath", "currentDirectory", "targetFile", "TargetFile", "TargetDatabase"], "prefix": ["domain", "timeout", "template", "queue", "pattern", "pre", "username", "ix", "sequence", "patch", "directory", "cache", "padding", "format", "path", "resource", "index", "fp", "fixed", "root", "config", "prot", "unit", "base", "Pref", "temp", "type", " suffix", "append", "offset", "number", "FIX", "name", "string", "resolution", "folder", "uri", "fix", "first", "filename", "txt"], "maxUnitBases": ["maxUnitBasing", "maxUnitChase", "maxunitAliaches", "maxUnitAliase", "maxunitAliases", "maxUnitAliases", "maxUnitEaches", "maxunitAliasing", "maxUnitBails", "maxUnitBase", "maxUnitEase", "maxUnitQuease", "maxUnitAliues", "maxunitBails", "maxUnitChases", "maxUnitAliaches", "maxUnitEases", "maxUnitQueues", "maxunitAliase", "maxUnitChasing", "maxunitAliails", "maxUnitPlases", "maxUnitAliails", "maxUnitPlails", "maxunitBase", "maxunitBases", "maxUnitChues", "maxunitAliues", "maxUnitQueases", "maxUnitQueasing", "maxUnitPlase", "maxunitBasing", "maxunitBues", "maxUnitEails", "maxUnitPlaches", "maxUnitAliasing", "maxUnitBues", "maxUnitBaches", "maxunitBaches"], "maxUnitEntries": ["maxUnitEntures", "maxUnitCountry", "maxLineEntines", "maxUnitIntresses", "maxLineEntry", "maxUnitErines", "maxUnitEntryures", "maxUnitErrations", "maxUnitEntry", "maxUnitOrdries", "maxUnitIntries", "maxUnitOrdresses", "maxunitEntryresses", "maxunitEntrys", "maxUnitEntrys", "maxUnitEntresses", "maxunitEntryries", "maxUnitCountries", "maxUnitEntrations", "maxUnitAddries", "maxLineEntrations", "maxUnitAddry", "maxUnitEntryry", "maxunitEntries", "maxLineOrdries", "maxUnitEntryries", "maxUnitCountrations", "maxLineOrdrations", "maxUnitIntrys", "maxUnitEntryresses", "maxUnitAddures", "maxUnitEntryies", "maxUnitEnties", "maxUnitEntryrys", "maxunitEntryrys", "maxLineOrdry", "maxUnitErry", "maxLineOrdines", "maxUnitCountines", "maxUnitAddresses", "maxunitEntryies", "maxUnitEntines", "maxUnitOrdies", "maxUnitInties", "maxUnitOrdry", "maxunitEntresses", "maxUnitOrdrations", "maxUnitErries", "maxunitEnties", "maxUnitOrdines", "maxLineEntries", "maxUnitOrdrys"], "fis": ["foris", "fai", "vis", "visa", " fris", "fIs", "vIs", "forai", " fai", "forisa", " fIs", " fisa", "fisc", " fiss", "foriss", "vai", "forris", " fisc", "fris", "forIs", "Fisc", "forisc", "fiss", "Fris", "fisa", "Fis", "Fiss"], "fci": ["hco", "fai", "bis", "dci", "Fii", "efcos", "bco", "efco", "dii", "efai", "hci", "fcos", "vco", "dco", "Fai", "fii", " fai", "hcos", "Fco", "vci", "efci", "vai", "bai", "hai", "Fci", " fii", "doci", "Foci", " foci", "vcos", "foci", "Fis", "bci"], "fos": ["toss", "fso", "ifo", "foes", "fios", "ifios", "infis", "foss", "fo", "Fos", "infoss", "ifcos", "infos", "fcos", "fsos", " fcos", "fsios", "Foss", "toes", "fscos", "tos", " fo", " fios", "ifos", "infoes", "Foes", "Fis", "tis"], "fco": ["hco", " fbo", "dci", "Fico", "fgo", "hgo", "fileico", "hci", "fileci", "fico", "fcos", "dco", " fro", "hcos", " fcos", "Fco", "fro", " fico", "lgo", "dro", "fbo", "lro", "lci", "fileco", "Fci", "lco", "filebo", "dcos", "Fbo", " fgo", "lcos"], "buffer": ["request", "pause", "image", "pad", "position", "timeout", "writer", "rate", "size", "batch", "capacity", "entry", "block", "queue", "read", "transfer", "view", "comment", "feed", "context", "input", "layer", "reference", "copy", "expression", "Buffer", "cache", "server", "info", "source", "result", "bc", "resource", "response", "message", "zero", "buff", "translation", "uffer", "iter", "buf", "binary", "channel", "base", "callback", "null", "scale", "data", "loader", "border", "bar", "offset", "document", "memory", "bin", "reader", "counter", "header", "window", "texture", "flush", "device", "length"], "currentBasesCount": ["currentBasecount", "currentBaseNum", "currentBatchesCounter", "currentBatchescount", "currentBatchesCount", "currentBasesCounter", "currentChasesCounter", "currentChasecount", "currentBasesNum", "currentChasesNum", "currentBasingNum", "currentChaseCount", "currentBatchesNum", "currentBaseCounter", "currentChasescount", "currentBasingCount", "currentBasescount", "currentChasesCount", "currentChaseNum", "currentBaseCount", "currentChaseCounter", "currentBasingcount", "currentBasingCounter"], "currentEntriesCount": ["currentEntursOffset", "currentEntriesOffset", "currentAddriesOffset", "currentAddriesLimit", "currentEnturesLimit", "currentEnturesSize", "currentAdduresOffset", "currentAdduresCount", "currentEntursCount", "currentEntriesLimit", "currentAdduresLimit", "currentEntursLimit", "currentEntrasCount", "currentEntrasSize", "currentEntriesSize", "currentAdduresSize", "currentEnturesCount", "currentAddriesSize", "currentEntrasLimit", "currentEntrasOffset", "currentEnturesOffset", "currentEntursSize", "currentAddriesCount"], "targetCount": ["targetSize", "argetCount", "patternSize", "targetcount", "Targetcount", "argetSize", "TargetCount", "patterncount", "TargetSize", "TargetSum", "patternSum", "argetSum", "targetSum", "argetcount", "patternCount"], "fastaChannel": [" fastaConnection", " fastAChannel", "fastaConnection", "fastAChannel", "fastaqColumn", "fastasContext", "fastaColumn", "fastAColumn", "fastaContext", "fastaContainer", "fastAConnection", "fastasColumn", " fastaColumn", "fastAContainer", "fastaqChannel", "fastABuffer", " fastABuffer", "fastAContext", "fastaqBuffer", " fastAContext", "fastanBuffer", " fastAColumn", " fastaContext", "fastasBuffer", "fastasChannel", "fastaqConnection", "fastanChannel", " fastAConnection", "fastasContainer", " fastAContainer", "fastanContext", " fastaContainer", "fastasConnection", "fastanContainer"], "totalSeqCount": ["totalSeuxCount", "totalSeuxNum", "totalQueQCounter", "totalQueQNum", "totalSeqsCounter", "totalSeQCounter", "totalQueqCount", "totalQueqNum", "totalSeqCounter", "totalSeqsCount", "totalSeQNum", "totalSeqNum", "totalSeqsNum", "totalSeuxcount", "totalSeqcount", "totalSeQcount", "totalQueQcount", "totalSeqscount", "totalQueqCounter", "totalQueqcount", "totalQueQCount", "totalSeuxCounter", "totalSeQCount"], "totalResiduesCount": ["totalResqueuresCount", "totalResqueuresNum", "totalResidurescount", "totalResiduingNum", "totalResiduescount", "totalResiduationCount", "totalResiduingSize", "totalResqueuescount", "totalResqueuesNum", "totalResiduationSize", "totalResiduingCount", "totalResiduationcount", "totalResqueuesCount", "totalResiduesSize", "totalResqueurescount", "totalResqueuresSize", "totalResiduesNum", "totalResiduationNum", "totalResqueuesSize", "totalResiduresNum", "totalResiduresCount", "totalResiduresSize", "totalResiduingcount"], "prevTime": ["PrevSize", "prevValue", "PrevFile", " prevFile", "prevFile", "prevSize", "commitValue", "commitSize", "commitFile", "PrevValue", " prevSize", "commitTime", " prevValue", "PrevTime"], "fastaFileSize": ["fastaLineSize", "fastasFileName", "fastaFileName", "fastaFilesLength", "fastasHeaderName", "fastABufferCount", "fastaFileCount", "fastAFileLength", "fastaBufferCount", "fastaBufferSize", "fastaLineAddress", "fastABufferSize", "fastaFileLength", "fastaFilesAddress", "fastaFilesName", "fastaBlockAddress", "fastaPageLength", "fastaHeaderLength", "fastaBufferLength", "fastaLineLength", "fastaFilesSize", "fastaLineCount", "fastaHeaderSize", "fastAFileSize", "fastasFileSize", "fastaPageAddress", "fastasFileAddress", "fastaBlockSize", "fastABufferAddress", "fastaPageSize", "fastasHeaderSize", "fastaBufferAddress", "fastABufferLength", "fastaFileAddress", "fastasFileLength", "fastAFileCount", "fastaBlockLength", "fastaPageName", "fastasHeaderLength", "fastaBlockCount", "fastAFileAddress", "fastaHeaderAddress", "fastasHeaderAddress", "fastaHeaderName"], "fastaFileReadOffset": ["fastaFileWriteOffset", "fastaDirectoryReadOffset", "fastaBufferWriteLength", "fastaFilereadOff", "fastaDirectoryWriteEntry", "fastaDirectoryReadoffset", "fastaDirectoryWriteOffset", "fastaFilesReadLength", "fastaBufferReadoffset", "fastaFilereadLength", "fastaFileLoadOffset", "fastaFileStartEntry", "fastaBufferReadLength", "fastaFilereadOffset", "fastaFileRunOff", "fastaDirectoryWriteoffset", "fastaBufferWriteOffset", "fastaFileWriteOff", "fastaFileStartOff", "fastaDirectoryReadEntry", "fastaFileLoadAmount", "fastaFilesWriteLength", "fastaDirectoryReadOff", "fastaFileLengthOffset", "fastaFileRunoffset", "fastaBufferWriteoffset", "fastaFileLoadLength", "fastaFileLengthAmount", "fastaFilereadoffset", "fastaFileWriteEntry", "fastaFileWriteAmount", "fastaFilesWriteOff", "fastaFileStartOffset", "fastaFileLengthLength", "fastaBufferReadOffset", "fastaFilesReadOffset", "fastaFileReadAmount", "fastaFileRunEntry", "fastaFileReadoffset", "fastaFileRunOffset", "fastaFileWriteLength", "fastaFilesWriteoffset", "fastaFileReadOff", "fastaFileLengthoffset", "fastaDirectoryWriteOff", "fastaFileReadLength", "fastaBufferReadAmount", "fastaFilesReadOff", "fastaFilesReadoffset", "fastaFileLengthOff", "fastaFileLoadoffset", "fastaFileStartoffset", "fastaBufferWriteAmount", "fastaFileWriteoffset", "fastaFileReadEntry", "fastaFilesWriteOffset"], "partitionStartOffset": ["partitionStartOff", "partitionsStartOffset", "partitionBufferOrder", "partitionEndOff", "partitionEndOrder", "partitionsStartOff", "partitionsEndOff", "partitionStopOffset", "partitionsEndOffset", "partitionStopOrder", "partitionsEndRange", "partitionsStartRange", "partitionBufferRange", "partitionStopRange", "partitionsStartOrder", "partitionBufferOff", "partitionStartRange", "partitionBufferOffset", "partitionStopOff", "partitionStartOrder", "partitionsEndOrder", "partitionEndRange"], "bufferSize": [" bufferC", "bufferC", "bufferCount", "processC", "BufferType", "processType", "queueCount", " bufferCount", "BufferSize", "bufferSIZE", "processSize", "BufferCount", "processSIZE", "queueSize", "bufferType", "BufferC", "BufferSIZE", " bufferType", " bufferSIZE"], "fastaBuffer": ["fastaaBuff", " fastAChannel", "FastaPtr", "FastaChannel", "fastanFile", "fastAFile", "fastAChannel", "fastasQueue", "fastasBuff", "fastasFile", "fastaaPtr", "fastaaBuffer", "FastaStream", " fastaFile", "fastaStream", "fastaContainer", "fastanBuff", "fastAContainer", "fastacePtr", "fastaceChannel", " fastaQueue", "fastaceBuff", "fastABuffer", " fastABuffer", "fastasPtr", "fastaBuff", " fastAQueue", " fastasBuffer", " fastaBuff", "FastaBuffer", "fastanPtr", "FastasStream", "fastAPtr", "fastanBuffer", "fastaPtr", "FastasBuff", "fastanQueue", "fastasBuffer", "fastasChannel", "FastaBuff", "FastasPtr", "fastaFile", "fastasStream", "fastaaStream", " fastABuff", "FastasChannel", "fastanChannel", " fastasChannel", "fastasContainer", " fastasContainer", "fastABuff", " fastAFile", "fastaceBuffer", "fastaQueue", " fastaContainer", "fastAQueue", "FastasBuffer", " fastasFile", "fastanContainer", "fastanStream"], "fastaReadState": ["fastaReadingType", "fastaReadMode", "fastasReaderMode", "fastaReaderstate", "fastaFileMode", "fastaReadingState", "fastasReaderType", "fastasReaderstate", "fastaFilestate", "fastaReadstate", "fastaFileState", "fastaReaderType", "fastasReaderState", "fastaReadingstate", "fastasReadType", "fastasReadState", "fastaReadType", "fastaFileType", "fastaReadingMode", "fastasReadstate", "fastasReadMode", "fastaReaderState", "fastaReaderMode"], "nBytes": ["oBytes", "nParts", " nbytes", "numFiles", "nByte", "oParts", "numBytes", "lenFrames", "lenFiles", "pParts", "nFrames", "Nbytes", "numFrames", "numbytes", "pBytes", "lenBytes", "oFiles", "lenbytes", "NByte", "nFiles", "obytes", "pByte", "NParts", " nFrames", " nFiles", "NBytes", "NFiles", " nByte", "nbytes", "pbytes", " nParts"]}}
{"id1": "13122204", "id2": "5977352", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipProject", "unzipProject", "UnzipFile", "unpackmodel", "Unarchivemodel", "unarchiveFile", "unpatchmodel", "unarchivemodel", "unpackModel", "unpackFile", "unzipFile", "UnarchiveModel", "unpackProject", "UnzipModel", "unpatchModel", "unarchiveProject", "unzipmodel", "UnarchiveProject", "unpatchFile", "UnarchiveFile", "unarchiveModel", "Unzipmodel", "unpatchProject"], "filename": ["Filename", "txt", "bf", "files", "src", "fd", "title", "il", "directory", "File", "loc", "module", "location", "path", "fp", "fn", "FILE", "file", "f", "url", "nil", "model", "download", "fil", "database", "kl", "SourceFile", "fits", "name", "l", "string", "utf", "jet", "folder", "uri", "source", "username"], "tempdir": [" temppath", "TempDIR", "tempDir", "tempath", "tempdirectory", "tmpfolder", "Tempfolder", "tempfolder", "TempDir", " tempfolder", "tmpDir", "temDir", "tmppath", "temdirectory", "tempDIR", "temdir", "Tempdir", "tmpDIR", "Tempdirectory", "temppath", " tempdirectory", "tmpdir", "tmpdirectory", "temfolder", " tempDir", " tempDIR"], "dest": ["de", " Dest", "obj", "sync", "walk", "src", "output", "transfer", "delete", "tmp", "comb", "opt", "std", "default", "tar", "nt", "handler", "home", "Dest", "ui", "loc", "target", "result", "dc", "desc", "inner", "exit", "later", "proc", "cdn", "file", "sup", "dist", "store", "dir", "die", "st", "wb", "zip", "rest", "temp", "flat", "session", "log", "builder", "trans", "done", "test", "transform", "export", "di", "prop", "folder", "usr", "cont", "gen", "dat", "source", "walker", "txt"], "fis": ["lis", "fileiss", "fbis", "fsisa", "fid", "fi", "flbis", "fsiss", "flis", "fsis", "fliss", "li", "filebis", " fiss", "fileis", "fileid", "fsbis", "lid", "fiss", "fileisa", " fid", "liss", "filei", "fisa", "flisa", " fi"], "BUFFER": ["BUUCK", "TAFFER", "BUVER", "BOFER", "SAUCK", "UPVEN", " BUFIX", "SAFFER", "CUVEN", " BUVER", "TAVER", "UPFFER", "CUFF", " BUFER", "BUFF", " BUPER", "BOFIX", "BUVEN", "MAFFER", " BUFF", "BOFFER", "CUPER", " BUUCK", "SAVER", "SAPER", "MAFER", "BUFER", "BUFIX", "CUVER", "CUFFER", "UPFF", "BUPER", "MAFIX", "TAPER", "MAPER", " BUVEN", "UPVER", "TAUCK", "BOPER", "CUUCK"], "zis": ["xiss", "jists", "jis", "xis", " ziss", "zos", " zos", " zisa", "zipins", "Zis", "zipas", "zin", "ziss", "dii", "yIS", "xists", " zins", "zii", "Zisa", "yin", " zas", " zii", "zIS", "zins", "zi", "zas", "zisa", "xos", "zipisa", "zipis", "xbis", "dis", "Zins", " zists", " zi", "xi", "zipIS", "zists", " zIS", "yis", "zipin", "ji", "zbis", "yisa", "Zas", " zin", "xii", "diss", " zbis", "dbis", "jos"], "entry": ["next", "image", "iterator", "ace", "match", "la", "de", "element", "ie", "way", "cel", "ce", "rc", "feed", "ou", "cat", "e", "enter", "id", "nt", "ry", "archive", "lc", "valid", "server", "info", "module", "result", "or", "connection", "ident", "li", "inner", "se", "pack", "line", "row", "file", "part", "end", "ge", "porter", "zip", "pe", "her", "spec", "ent", "record", "ries", "je", "name", "Entry", "reader", "si", "source", "inc", "jo"], "count": ["ind", "next", "in", "buffer", "writer", "size", "max", "pos", "cond", "Count", "key", "current", "i", "use", "feed", "write", "e", "id", "limit", "core", "coll", "cache", "val", "last", "code", "sum", "low", "time", "index", "weight", "_", "line", "file", "part", "len", "start", "end", "iter", "f", "base", "type", "b", "log", "number", "allow", "name", "counter", "list", "add", "read", "c", "length"], "data": ["next", "image", "la", "buffer", "bytes", "size", "batch", "alpha", "pos", "block", "load", "feed", "input", "write", "id", "info", "result", "format", "media", "content", "array", "message", "zero", "index", "a", "pack", "raw", "value", "str", "len", "start", "base", "number", "record", "name", "reader", "DATA", "d", "body", "shift", "read", "dat", "length"], "fos": [" foes", "xoes", "bis", " foos", "foes", "fOS", "afOS", "xops", "bOS", "foos", "xos", " fops", "afos", "dfoes", "afis", "dfoos", "dfos", "bops", "afops", "xoos", "fops", "bos", " fOS", "dfops"]}}
{"id1": "21979714", "id2": "8385785", "code1": "    @ActionMethod\n    public void list() throws IOException {\n        final URL url = new URL(\"http://127.0.0.1:\" + testPort + \"/list?version=1000\");\n        final HttpURLConnection con = (HttpURLConnection) url.openConnection();\n        con.setRequestProperty(Http11Header.AUTHORIZATION, \"Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==\");\n        con.setRequestProperty(Http11Header.WWW_AUTHENTICATE, \"Basic realm=\\\"karatasi\\\"\");\n        final InputStream in = con.getInputStream();\n        final byte[] buf = new byte[4096];\n        textArea.setText(\"\");\n        for (int bytesRead; (bytesRead = in.read(buf)) != -1; ) {\n            textArea.append(new String(buf, 0, bytesRead));\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"list": ["request", "get", "ping", "sort", "sync", "query", "delete", "print", "load", "parse", "LIST", "ls", "check", "info", "index", "pull", "show", "find", "start", "download", "test", "split", "search", "export", "stop", "read"], "url": ["blog", "client", "sl", "ul", "entry", "rl", "host", "fl", "bug", "ls", "bb", "page", "server", "conn", "connection", "http", "URL", "resource", "path", "pull", "ob", "ssl", "file", "build", "f", "Url", "api", "base", "log", "org", "ll", "cl", " URL", "l", "string", "web", "ur", "uri", "lock", "config", "www"], "con": ["an", "client", "connect", "ca", "Conn", "ctx", "fa", "cp", "rc", "cn", "ln", "cons", "on", "CON", "ex", "lc", "cf", "com", "run", "conn", "ann", "open", "ran", "bc", "ver", "connection", "http", "cur", "cm", "uc", "xc", "conf", "fc", "Con", "fn", "part", "ctrl", "en", "f", "ch", "close", "exec", "conv", "login", "can", "cl", "pc", "co", "fac", "un", "sub", "func", "c", "ec"], "in": ["r", "client", "m", "n", "inn", "stream", "i", "is", "socket", "input", "ex", "conn", "lin", "a", "inner", "vin", "out", "ini", "rec", "rin", "file", "conf", "min", "f", "this", "login", "data", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "sub", "c", "inc"], "buf": ["fab", "db", "bp", "buffer", "cas", "bu", "bytes", "batch", "seq", "bf", "br", "la", "ff", "ab", "src", "rc", "func", "tmp", "bb", "Buffer", "sb", "grab", "bc", "rb", "fb", "cur", "orig", "buff", "uc", "exc", "Buff", "bag", "bh", "bd", "abs", "pb", "wb", "base", "vec", "conv", "data", "b", "cv", "uf", "aka", "bin", "utf", "cb"], "bytesRead": ["bytesWrite", "byteWrite", "BytesLoad", "bytesLength", "byteLength", " bytesWritten", "bytesread", "stringsRead", "BytesRead", "byteRead", "byteWritten", " bytesFind", "wordsread", " bytesLength", "wordsLength", " bytesFound", "bytesLoad", " bytesLoad", "stringsFind", "stringsLoad", "wordsFound", "BytesFind", "BytesWrite", "tesread", "tesRead", "bytesFind", "tesLength", "BytesLength", "bytesWritten", "tesFound", " bytesWrite", "bytesFound", " bytesread", "BytesWritten", "wordsRead", "stringsWritten"]}}
{"id1": "11484416", "id2": "12766377", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public Document index() throws CrawlingException {\n        log.debug(\"BEGINIG indexing page [code=\" + getCode() + \"] ...\");\n        URL url = null;\n        InputStream in = null;\n        String contentType = null;\n        try {\n            url = new URL(getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath());\n            HttpURLConnection pageContent = (HttpURLConnection) url.openConnection();\n            if (pageContent.getResponseCode() != HttpURLConnection.HTTP_OK) {\n                log.debug(\"page pk[\" + getCode() + \",\" + url.toExternalForm() + \"] is invalid\");\n                return null;\n            }\n            String redireccion = pageContent.getHeaderField(\"location\");\n            if (redireccion != null) {\n                log.debug(\"Page \" + url.toExternalForm() + \" redirected to \" + redireccion);\n                recordLink(redireccion);\n                return null;\n            }\n            contentType = pageContent.getContentType();\n            in = new BufferedInputStream(pageContent.getInputStream(), 32768);\n        } catch (MalformedURLException e) {\n            log.error(\"Invalid page address\", e);\n        } catch (ConnectException e) {\n            if (getServer() != null) {\n                log.error(\"Unable to connect to page: \" + getServer().getProtocol() + \"://\" + getServer().getHost() + \":\" + getServer().getPort() + getPath(), e);\n            }\n        } catch (UnknownHostException uhe) {\n            log.warn(\"Unknow host indexing page \" + getURL(), uhe);\n        } catch (IOException e) {\n            log.warn(\"Unable to index page \" + getURL(), e);\n        }\n        Document doc = generateDocument(contentType, in);\n        log.debug(\"END indexing page [code=\" + getCode() + \"]\");\n        return doc;\n    }\n", "label": 0, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "11562173", "id2": "16142024", "code1": "    private void checkInputStream(InputStream in, byte[] cmp, boolean all) throws IOException {\n        ByteArrayOutputStream stream = new ByteArrayOutputStream();\n        IOUtils.copy(in, stream);\n        byte[] out = stream.toByteArray();\n        if (all) assertEquals(cmp.length, out.length);\n        for (int i = 0; i < cmp.length; i++) assertEquals(cmp[i], out[i]);\n    }\n", "code2": "    private static final void copyFile(File srcFile, File destDir, byte[] buffer) {\n        try {\n            File destFile = new File(destDir, srcFile.getName());\n            InputStream in = new FileInputStream(srcFile);\n            OutputStream out = new FileOutputStream(destFile);\n            int bytesRead;\n            while ((bytesRead = in.read(buffer)) != -1) out.write(buffer, 0, bytesRead);\n            in.close();\n            out.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Couldn't copy file '\" + srcFile + \"' to directory '\" + destDir + \"'\");\n        }\n    }\n", "label": 1, "substitutes": {"checkInputStream": ["checkInputSteam", "checkIOChannel", " checkInputstream", "checkFileChannel", "checkFileStream", "checkOutputstream", "checkIOStream", "checkInputstream", "checkOutputStream", "checkFileSteam", " checkOutputStream", " checkOutputSteam", " checkOutputstream", " checkInputSteam", "checkOutputSteam", "checkInputChannel", " checkInputChannel", " checkOutputChannel", "checkIOstream", "checkFilestream", "checkOutputChannel", "checkIOSteam"], "in": ["image", "p", "ic", "inn", "isin", "src", "is", "input", "din", "plus", "connection", "inner", "index", "io", "into", "con", "ini", "x", "min", "login", "data", "ack", "comp", "ins", "bin", "In", "reader", "IN", "as", "again", "source", "up", "c", "inc"], "cmp": ["match", "amp", "p", "sort", "ctx", "asc", "cp", "up", "rc", "cs", "pre", "cc", "comment", "lc", "ci", "com", "coll", "cache", "loc", "diff", "code", "omp", "cho", "clip", "index", "cop", "fp", "op", "proc", "sup", "config", "ctrl", "roc", "ch", "prefix", "conv", "cup", "spec", "comp", "cpp", "pc", "pixel", "co", "mp", "upp", "prev", "mom", "np", "cb", "c"], "all": ["auto", "process", "match", "both", "p", "one", "alpha", "best", "full", "asc", "default", "global", "parent", "coll", "valid", "ann", "sum", "array", "a", "not", "only", "acl", "ALL", "none", "null", "al", "except", "local", "partial", "each", "any", "cl", "allow", "call", "total", "l", "list", "and", "am", "always", "All"], "stream": ["iterator", "client", "progress", "sw", "ream", "up", "host", "output", "form", "object", "socket", "feed", "context", "impl", "input", "user", "instance", "port", "coll", "stack", "per", "result", "response", "pool", "raw", "this", "channel", "null", "wrapper", "platform", "model", "temp", "ack", "v", "trans", "comp", "test", "transform", "document", "src", "Stream", "track", "round", "string", "reader", "speed", "steam", "roll", "cont", "source", "self"], "out": ["Out", "image", "p", "sync", "obj", "block", "full", "up", "output", "comment", "user", "copy", "parent", "option", "result", "sum", "array", "exp", "index", "response", "not", "io", "part", "x", "prefix", "o", "null", "this", "data", "b", "v", "other", "name", "bin", "again", "project", "list", "point", "outs", "outer", "extra", "OUT", "c", "inc"], "i": ["ind", "r", "ai", "j", "p", "h", "n", "key", "init", "multi", "fi", "slice", "ix", "e", "id", "abi", "ci", "gi", "lc", "ui", "info", "strength", "index", "li", "ii", "io", "ini", "bi", "end", "x", "pi", "f", "start", "xi", "ti", "k", "ri", "type", "u", "b", "v", "ji", "oi", "mi", "it", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"]}}
{"id1": "10759917", "id2": "17193692", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 1, "substitutes": {"delete": ["get", " deletion", "de", "del", "save", "sync", " Delete", " deleting", "load", "write", "id", "Delete", "register", "connection", "post", "link", "exec", "update", "execute", "drop", "database", "remove", " destroy", "destroy", "flush", "dump", "create"], "name": ["client", "size", "one", "n", "label", "key", "class", "old", "object", "comment", "action", "default", "version", "e", "parent", "id", "on", "address", "ame", "info", "alias", "code", "time", "path", "resource", "word", "value", "now", "part", "NAME", "link", "space", "url", "prefix", "no", "null", "none", "pass", "model", "active", "data", "type", "missing", "definition", "base", "false", "database", "Name", "names", "table", "true", "style", "string", "named", "like", "create", "filename"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkError", "CannotDeleteSystemLinkError", "CannotDeleteSystemLinkception", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkEx", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceError", "CannotDeleteSystemRelError", "CannotDeleteSystemLinksApplication", "CannotDeleteClassLinkInformation", "CannotDeleteSysLinkException", "CannotDeleteSystemLinkInformation", "CannotDeleteSystemRelEx", "CannotDeleteSystemlinkApplication", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemLinksInformation", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksException", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteSysLinkception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemLinksception", "CannotDeleteSystemlinkception", "CannotDeleteSystemReferenceException", "CannotDeleteClassLinkception", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundError", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotfoundException", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundRequest", "ClassLinkTypeNotFoundRequest"], "conn": ["orp", "db", "error", "client", "connect", "ca", "Conn", "h", "p", "query", "ctx", "n", "oss", "sync", "cond", "cp", "cn", "cc", "pg", "ou", "cat", "ns", "bb", "cli", "nt", "ci", "po", "core", "cache", "coll", "server", "cb", "loc", "ann", "open", "dn", "lc", "connection", "nc", "dc", "ver", "cur", "cm", "ob", "ssl", "con", "conf", "uc", "pub", "util", "close", "ch", "enc", "serv", "exec", "oci", "session", "ac", "rt", "org", "ct", "pc", "co", "mc", "Connection", "lock", "act", "config", "c", "pr", "ec"], "stmt": [" stm", "stdd", "strnt", "rdmt", "STsql", "istmd", "Stm", "Stdt", "stlt", "estsql", " stdb", "sthdb", " stmn", "strlt", "Stmd", "playnt", "rddd", "STdd", "stdt", "playmt", "strmb", "stmd", "stmp", "strmt", "Stmm", "strdd", " stmd", "ctm", "sthmt", "istmt", "Stmp", " stdd", "strmd", "estlt", "Stmb", "strsql", "strob", "stob", "STmt", "strmm", "strmp", "rdmd", "strm", "STlt", "sthmd", "estmt", "playmd", " stob", "ctmd", "stm", "istnt", " stmm", "istdt", " stnt", "ctmt", "stmm", "Stnt", " stmb", "estdd", " stsql", "ctmb", "stnt", "Stmt", "sthmn", "stsql", "stmn", "Stmn", "playdt", "Stdb", "stmb", " stmp", "stdb", "rdsql", "Stob"], "prepTable": ["supable", "PrepType", " preptable", "parTable", "preptable", " prepable", "parCol", "suptable", "parType", "supTable", "inittable", "prepable", "partable", "Preptable", "PrepTable", "prepType", "initType", " prepType", " prepCol", "supType", "Prepable", "initCol", "initTable", "prepCol"], "objectLinkTable": ["objLinkStore", "objlinkType", "objectlinkChain", "objectlinkType", "objlinkChain", "objectSyncStore", "objectlinkSource", "objectTypeFile", "ObjectLinkTable", "ObjectLineTable", "objectLinkChain", "ObjectLineTab", "ObjectLinkFile", "objectSyncChain", "objectLinkFile", "ObjectLinkSource", "objectLineSource", "objectRelTable", "objectLinkSource", "objLinkType", "objlinkTable", "objectTypeTab", "objectTypeTable", "objectRelChain", "objectTypeSource", "objectLineFile", "objectlinkFile", "objectlinkTab", "objLinkTable", "objectRelType", "ObjectLinkTab", "objlinkStore", "objLinkChain", "objectlinkStore", "ObjectLineSource", "objectLineTab", "objectRelStore", "objectSyncTable", "objectLinkStore", "objectLineTable", "ObjectLineFile", "objectlinkTable", "objectLinkTab", "objectSyncType", "objectLinkType"], "sql": ["db", "su", "term", "query", "sl", "summary", "s", "comment", "ls", "id", "statement", " SQL", "expression", "SQL", "sb", "sg", "sf", "result", "pr", "params", "ssl", "csv", "description", "function", "str", "url", "update", "zip", "sq", "log", "spec", "dl", "shell", "ql", "string", "general", "insert", "sv", "cmd", "join", "select"]}}
{"id1": "14473781", "id2": "23310397", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n        mButton1 = (Button) findViewById(R.id.myButton1);\n        mButton2 = (Button) findViewById(R.id.myButton2);\n        mTextView1 = (TextView) findViewById(R.id.myTextView1);\n        mButton1.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpPost httpRequest = new HttpPost(uriAPI);\n                List<NameValuePair> params = new ArrayList<NameValuePair>();\n                params.add(new BasicNameValuePair(\"str\", \"post string\"));\n                try {\n                    httpRequest.setEntity(new UrlEncodedFormEntity(params, HTTP.UTF_8));\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n        mButton2.setOnClickListener(new Button.OnClickListener() {\n\n            public void onClick(View v) {\n                String uriAPI = \"http://www.sina.com\";\n                HttpGet httpRequest = new HttpGet(uriAPI);\n                try {\n                    HttpResponse httpResponse = new DefaultHttpClient().execute(httpRequest);\n                    if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                        String strResult = EntityUtils.toString(httpResponse.getEntity());\n                        strResult = eregi_replace(\"(\\r\\n|\\r|\\n|\\n\\r)\", \"\", strResult);\n                        mTextView1.setText(strResult);\n                    } else {\n                        mTextView1.setText(\"Error Response: \" + httpResponse.getStatusLine().toString());\n                    }\n                } catch (ClientProtocolException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                } catch (Exception e) {\n                    mTextView1.setText(e.getMessage().toString());\n                    e.printStackTrace();\n                }\n            }\n        });\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingNode", " doInContext", " doOnBuffer", " doOnNode", "doInContext", "doInNode", "doOnBuffer", " doUsingContext", " doWithinBuffer", " doUsingBuffer", " doOnBackground", " doWithinBackground", "doOnNode", "doOnContext", "doOnBackground", " doWithinContext", " doInBuffer", " doWithinNode", " doUsingBackground", " doOnContext", " doInNode", "doInBuffer"], "params": ["ip", "Par", "query", "Param", "i", "par", "instance", "parse", "page", "handler", "json", "properties", "ams", "array", "param", "resources", "options", "pi", "Parameters", "url", "api", "data", "type", "list", "ps", "uri", "config"], "httpClient": ["HttpProxy", "HttpPost", "httpContext", " httpContext", "HttpCase", "httpsCase", "ttpContext", "httpsClient", "ttpProxy", "HttpClient", "httpCall", "httpProxy", "httpCase", "HttpCall", "HttpContext", "ttpClient", "ttpPost", "httpsPost", "httpsCall", " httpCase", " httpCall", " httpProxy"], "localContext": ["localcontext", " localConfig", "globalContext", "httpContext", "LocalClient", "LocalContext", "httpcontext", " localClient", " localData", "httpData", "locData", "loccontext", "globalClient", "locConfig", "Localcontext", "httpConfig", "globalPort", "locContext", "localClient", "localPort", " localPort", "localData", "LocalPort", " localcontext", "localConfig", "globalcontext"], "httpPost": [" httppost", "phpPOST", "cachePOST", "HttpPost", "phpCopy", "httpPOST", " httpPOST", "requestPOST", "httpCopy", "requestpost", "httpsRequest", "Httppost", "httpRequest", "ttpCreate", "HttpCopy", " httpPatch", "requestPost", "ttpCopy", " httpCopy", "httppost", "phppost", "requestCopy", "phpPost", "httpPatch", "HttpCreate", "cacheRequest", " httpCreate", "ttpPost", "ttppost", "httpCreate", "httpsPOST", "httpsPatch", "cachePatch", "cachePost", "httpsPost", " httpRequest"], "entity": ["image", "component", "email", "p", "service", "oe", "eme", "element", "entry", "ce", "object", "el", "instance", "e", "environment", "om", "page", "coll", "server", "address", "per", "json", "connection", "media", "http", "content", "resource", "Entity", "xml", "translation", "line", "file", "part", "post", "url", "enc", "api", "base", "channel", "model", "pe", "ent", "article", "collection", "activity", "ity", "document", "node", "body", "event", "person", "issue", "create"], "index": ["image", "size", "author", "i", "key", "old", "section", "address", "word", "value", "edit", "x", "prefix", "letter", "update", "axis", "search", "width", "name", "string", "column", "length", "request", "ind", "batch", "element", "label", "view", "route", "page", "diff", "num", "weight", "operation", "part", "active", "offset", "again", "initial", "inc", "success", "in", "level", "alpha", "argument", "pattern", "object", "action", "slice", "id", "expression", "pointer", "step", "number", "Index", "position", "left", "pos", "all", "default", "version", "coll", "connection", "date", "second", "f", "primary", "data", "type", "other", "site", "list", "loop", "condition"], "response": ["request", "image", "client", "service", "offer", "i", "output", "reply", "object", "feed", "respons", "e", "page", "handler", "json", "server", "answer", "result", "connection", "http", "array", "message", "resource", "Response", "value", "resp", "post", "api", "onse", "model", "data", "v", "collection", "status", "application", "method", "body", "respond", "related"]}}
{"id1": "9413074", "id2": "12004824", "code1": "    String getLocation(Class clazz) {\n        try {\n            java.net.URL url = clazz.getProtectionDomain().getCodeSource().getLocation();\n            String location = url.toString();\n            if (location.startsWith(\"jar\")) {\n                url = ((java.net.JarURLConnection) url.openConnection()).getJarFileURL();\n                location = url.toString();\n            }\n            if (location.startsWith(\"file\")) {\n                java.io.File file = new java.io.File(url.getFile());\n                return file.getAbsolutePath();\n            } else {\n                return url.toString();\n            }\n        } catch (Throwable t) {\n        }\n        return Messages.getMessage(\"happyClientUnknownLocation\");\n    }\n", "code2": "    public HttpResponse executeHttpRequest(HttpRequestBase httpRequest) {\n        HttpResponse response = null;\n        try {\n            HttpParams httpParams = new BasicHttpParams();\n            HttpConnectionParams.setConnectionTimeout(httpParams, maxTime);\n            HttpConnectionParams.setSoTimeout(httpParams, maxTime);\n            httpclient = new DefaultHttpClient(httpParams);\n            response = httpclient.execute(httpRequest);\n            maxTime = 15000;\n        } catch (Exception e) {\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"getLocation": ["GetURL", "newFile", "findURL", "getURL", " getAddress", "getLoc", "GetLoc", "findLocation", "newLoc", "findFile", "GetPath", "getAddress", "getFile", "setLocation", "newURL", "GetFile", " getPath", "setPath", "setAddress", "newLocation", "findLoc", "GetLocation", "getPath", "setURL", " getURL", "GetAddress"], "clazz": ["cllass", "Clclass", "clclass", " cllass", "Clazz", "CLazz", "Cluster", "cluster", "CLuster", "Cllass", " cluster", "CLlass", " clclass", "CLclass"], "url": ["lr", "image", "entry", "i", "impl", "address", "http", "ob", "link", "api", "base", "text", "name", "mount", "string", "href", "uri", "client", "sl", "html", "feed", "user", "bug", "route", "page", "loc", "URL", "path", "b", "local", "ll", "language", "l", "web", "service", "email", "host", "class", "object", "context", "bb", "ref", "pull", "ssl", "Url", "null", "channel", "gl", "log", "rel", "cl", "layer", "source", "position", "buffer", "server", "coll", "or", "connection", "code", "resource", "f", "Location", "zip", "loader", "org", "browser", "site", "jar", "config"], "location": ["position", "image", "error", "where", "layout", "layer", "instance", "route", "lc", "directory", "address", "home", "loc", "result", "property", "connection", "content", "response", "message", "resource", "path", "URL", "region", "library", "operation", "translation", "description", "function", "storage", "Location", "area", "feature", "warning", "data", "local", "language", "via", "l", "site", "style", "string", "uri", "source", "filename", "length"], "file": ["get", "image", "entry", "full", "files", "key", "class", "object", "el", "il", "page", "File", "cache", "per", "child", "fe", "path", "resource", "io", "fp", "line", "FILE", "ile", "dir", "f", "lib", "base", "pe", "log", "it", "name", "entity", "l", "remote", "folder", "uri", "source", "filename", "able"]}}
{"id1": "8093133", "id2": "364438", "code1": "    public static Object loadXmlFromUrl(URL url, int timeout, XML_TYPE xmlType) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setConnectTimeout(timeout);\n        connection.setReadTimeout(timeout);\n        BufferedInputStream buffInputStream = new BufferedInputStream(connection.getInputStream());\n        return loadXml(buffInputStream, xmlType);\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"loadXmlFromUrl": ["loadXMLfromUrl", "loadXMLFromurl", "loadXMLfromFile", "loadXmlfromFile", "loadXmlWithFile", "loadXmlAsURL", "loadXmlFromurl", "loadXMLfromURL", "loadXmlWithurl", "loadXmlAsurl", "loadXMLFromUrl", "loadXmlfromURL", "loadXmlFromFile", "loadXmlWithUrl", "loadXmlFromURL", "loadXmlfromUrl", "loadXMLFromFile", "loadXmlWithURL", "loadXmlfromurl", "loadXMLFromURL", "loadXmlAsFile", "loadXmlAsUrl", "loadXMLfromurl"], "url": ["image", "client", "buffer", "service", "sl", "obj", "host", "object", "feed", "user", "id", "page", "server", "address", "open", "loc", "conn", "location", "http", "URL", "path", "resource", "io", "ssl", "file", "str", "link", "Url", "base", "loader", "org", "l", "string", "uri", "source", "config"], "timeout": ["client", "buffer", "size", "sync", "capacity", "key", "socket", "delay", "limit", "port", "period", "server", "cache", "seconds", "time", "resource", "io", "sleep", "Timeout", "ssl", "out", "scroll", "unit", "until", "data", "type", "token", "offset", "wait", "resolution", "network", "duration", "window", "lock", "config", "length"], "xmlType": ["xmltype", "writerStyle", "mlClass", "writerType", "elementType", "writertype", "xmlFile", " xmlFile", "elementStyle", "mlFile", "phpFile", "xmlTypes", " xmlModel", "phpTypes", "mlTypes", "xmlStyle", "phpType", "elementModel", " xmlTypes", " xmltype", "xmlModel", "mlType", "xmlClass", " xmlClass", " xmlStyle", "writerModel", "phpClass", "elementtype"], "connection": ["position", "client", "connect", "union", "writer", "entry", "relation", "socket", "use", "proxy", "context", "character", "version", "section", "lc", "directory", "handler", "server", "conn", "open", "loc", "bc", "http", "container", "response", "resource", "index", "io", "con", "function", "which", "connected", "channel", "unit", "wrapper", "builder", "b", "database", "collection", "application", " Connection", "l", "reader", "ion", "communication", "network", "Connection", "uri", "event", "closed", "config", "c", "condition"], "buffInputStream": ["BuffOutputStream", "BuffOutputstream", "BuffReadSteam", "buffReadStream", "buffinputstream", "buffinputSteam", "buffOutputStream", "buffInputstream", "buffReadstream", "buffOutputstream", "BuffInputSteam", "buffInputSteam", "buffInstream", "BuffInputstream", "BuffReadStream", "buffInStream", "buffOutputSteam", "buffInSteam", "BuffInputStream", "buffReadSteam", "buffinputStream", "BuffOutputSteam", "BuffReadstream"]}}
{"id1": "11477906", "id2": "13499897", "code1": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 1, "substitutes": {"loadDefaultSettings": ["loadApplicationsettings", "getdefaultsettings", "loadDefaultsettings", "loadDefaultConfiguration", "getdefaultConfiguration", "getDefaultsettings", "loadApplicationConfiguration", "loaddefaultParameters", "getDefaultParameters", "loadDefaultParameters", "getDefaultSettings", "loadGlobalsettings", "loaddefaultSettings", "loaddefaultConfiguration", "getdefaultSettings", "getDefaultConfiguration", "loaddefaultsettings", "loadApplicationParameters", "getdefaultParameters", "loadApplicationSettings", "loadGlobalParameters", "loadGlobalSettings", "loadGlobalConfiguration"], "configFileName": ["configFilesName", "configFilenameLocation", "configFilesType", "configFileLocation", "configPlaceLocation", "configPlaceName", "ConfigModuleUrl", "ConfigFileString", "configPlaceString", "configFullUrl", "configFullString", "configModuleName", "configFileTime", "configModuleLocation", "fileFileLocation", "fileFILEName", "configFilesTime", "configFILETime", "ConfigModuleLocation", "configFILELocation", "configFILEName", "ConfigModuleName", "configModuleUrl", "configPlaceUrl", "configFilesLocation", "configFilenameType", "configFileType", "fileFILELocation", "configFileString", "ConfigModuleString", "configFilenameName", "configFilenameTime", "ConfigFileLocation", "configFullName", "ConfigFileUrl", "ConfigFileName", "configFullLocation", "fileFileTime", "fileFILEType", "fileFILETime", "configFileUrl", "fileFileType", "configModuleString", "fileFileName", "configFILEType"], "in": ["r", "m", "pin", "n", "inn", "stream", "is", "i", "socket", "init", "cin", "input", "id", "din", "conn", "plus", "diff", "a", "inner", "resource", "pull", "nin", "ssl", "con", "ini", "work", "config", "inside", "f", "url", "this", "pass", "base", "login", "data", "err", "log", "it", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "read", "source", "up", "inc"], "out": ["Out", "image", "timeout", "client", "writer", "error", "sync", "obj", "off", "one", "all", "output", "socket", "object", "view", "default", "s", "ou", "user", "instance", " back", "write", "copy", "parent", "version", "ex", "server", "t", "conn", "to", " file", "able", "connection", "exp", "ext", "io", "file", "config", " output", "f", "prefix", "o", "null", "exec", "lib", "set", "this", "data", "err", "log", "it", "net", "name", "bin", "password", "OUT", "string", "again", "and", "d", "point", "outs", "back", "up", "c", "inc"]}}
{"id1": "13421722", "id2": "8690362", "code1": "    public static long getFileSize(String address) {\n        URL url = null;\n        try {\n            url = new URL(address);\n            System.err.println(\"Indirizzo valido - \" + url.toString().substring(0, 10) + \"...\");\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Indirizzo non valido!\");\n        }\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=0-\");\n            connection.connect();\n            return connection.getContentLength();\n        } catch (IOException ioe) {\n            System.err.println(\"I/O error!\");\n            return 0;\n        }\n    }\n", "code2": "    public static void fileUpload() throws IOException {\n        HttpClient httpclient = new DefaultHttpClient();\n        httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);\n        HttpPost httppost = new HttpPost(postURL);\n        File file = new File(\"d:/hai.html\");\n        System.out.println(ukeycookie);\n        httppost.setHeader(\"Cookie\", ukeycookie + \";\" + skeycookie + \";\" + usercookie);\n        MultipartEntity mpEntity = new MultipartEntity();\n        ContentBody cbFile = new FileBody(file);\n        mpEntity.addPart(\"\", cbFile);\n        httppost.setEntity(mpEntity);\n        System.out.println(\"Now uploading your file into mediafire...........................\");\n        HttpResponse response = httpclient.execute(httppost);\n        HttpEntity resEntity = response.getEntity();\n        System.out.println(response.getStatusLine());\n        if (resEntity != null) {\n            System.out.println(\"Getting upload response key value..........\");\n            uploadresponsekey = EntityUtils.toString(resEntity);\n            getUploadResponseKey();\n            System.out.println(\"upload resoponse key \" + uploadresponsekey);\n        }\n    }\n", "label": 0, "substitutes": {"getFileSize": ["getByteSize", " getFileInfo", "getfileSize", "getByteInfo", "getByteLength", " getfileLength", " getFileLength", "getfileInfo", "getFilesBytes", " getfileSize", "getByteBytes", "getFilesInfo", " getFileBytes", "getFilesLength", "getFileLength", "getfileBytes", "getFileInfo", " getfileInfo", "getfileLength", " getfileBytes", "getFilesSize", "getFileBytes"], "address": ["request", "position", "ip", "localhost", "email", "size", "Address", "host", "output", "object", "reference", "route", "attribute", "port", "server", "target", "format", "code", "location", "content", "path", "report", "resource", "message", "array", "str", "prefix", "base", "data", "type", "offset", "number", "name", "string", "network", "point", "addr", "uri", "source", "config"], "url": ["lr", "image", "job", "client", "service", "sl", "html", "host", "socket", "object", "feed", "proxy", "impl", "user", "bug", "e", "page", "server", "conn", "loc", "result", "found", "http", "location", "URL", "resource", "path", "io", "ob", "xml", "ssl", "file", "build", "str", "f", "Url", "lib", "api", "base", "channel", "session", "log", "org", "ll", "l", "string", "web", "ur", "uri", "orb", "config", "www"], "connection": ["request", "position", "client", "connect", "service", "entry", "relation", "socket", "object", "use", "proxy", "context", "character", "version", "reference", "environment", "section", "handler", "server", "conn", "open", "info", "to", "or", "bc", "http", "response", "resource", "io", "out", "con", "function", "connected", "channel", "wrapper", "session", "control", "database", "collection", "application", "communication", "Connection", "uri", "event", "current", "config", "c", "condition"]}}
{"id1": "13024538", "id2": "9996334", "code1": "    public static String getHash(String uri) throws NoSuchAlgorithmException {\n        MessageDigest mDigest = MessageDigest.getInstance(\"MD5\");\n        mDigest.update(uri.getBytes());\n        byte d[] = mDigest.digest();\n        StringBuffer hash = new StringBuffer();\n        for (int i = 0; i < d.length; i++) {\n            hash.append(Integer.toHexString(0xFF & d[i]));\n        }\n        return hash.toString();\n    }\n", "code2": "    public String generateToken(String code) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA1\");\n            md.update(code.getBytes());\n            byte[] bytes = md.digest();\n            return toHex(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new RuntimeException(\"SHA1 missing\");\n        }\n    }\n", "label": 1, "substitutes": {"getHash": ["createHost", "getDig", "toHost", "createHeader", "toHeader", "GetDig", "GetHeader", "getHeader", "toHash", "toDig", "createHash", "createDig", "GetHost", "getHost", "GetHash"], "uri": ["image", "iri", " URI", "bytes", "p", "URI", "theme", "id", "abi", "cli", "directory", "attribute", "address", "origin", "ui", "format", "URL", "message", "path", "num", "io", "file", " ur", "str", "uni", "storage", "pi", "f", "url", "prefix", "base", "ri", "data", "token", "database", "text", "name", "string", "source", "filename"], "mDigest": ["MDigest", "mHashester", "mdigest", "mDested", "mDit", "MDigee", "mMixe", "mIntegit", "MDige", "MDger", "mdigested", "MDested", "mdigee", "mDester", "mDigester", "mHashest", "MDit", "mIntegester", "mDige", "mDee", "mDigit", "mMixested", "mDigger", "mDest", "mMixester", "MDigester", "mMixest", "MDigger", "mDigested", "mdigit", "mDger", "mIntegest", "MDigested", "MDigit", "MDester", "mIntegee", "mHashger", "MDee", "MDest", "mDe", "mdige", "mDigee", "mHashested", "mdigester", "MDe", "mMixger"], "d": ["db", "sd", "m", "h", "p", "dig", "n", "g", "dos", "fd", "s", "dd", "dict", "ad", "e", "t", "dx", "md", "did", "dn", "dc", "D", "dt", "ds", "dh", "x", "f", "data", "b", "v", "dl", "done", "di", "ded", "l", "ld", "da", "dat", "c"], "hash": ["ha", "image", "db", "buffer", "h", "html", "ash", "block", "key", "output", "square", "use", "print", "user", "copy", "cache", "address", "sh", "result", "format", "sum", "array", "response", "message", "pool", "out", "raw", "Hash", "build", "str", "ashes", "f", "url", "throw", "base", "data", "temp", "b", "her", "v", "shadow", "log", "sha", "he", "total", "memory", "style", "string", "header", "loop", "shift", "dump", "ruby", "length", "hex"], "i": ["r", "ai", "m", "j", "p", "n", "block", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "t", "ui", "info", "a", "zi", "li", "index", "ii", "io", "vi", "z", "bi", "end", "x", "pi", "f", "start", "o", "xi", "ti", "k", "ri", "u", "b", "v", "ji", "oi", "it", "di", "l", "hi", "si", "chi", "qi", "I", "c"]}}
{"id1": "13666876", "id2": "5148212", "code1": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "code2": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        logger.info(\"copyFile(File src=\" + src + \", File dest=\" + dest + \", int bufSize=\" + bufSize + \", boolean force=\" + force + \") - start\");\n        File f = new File(Configuration.getArchiveDir());\n        if (!f.exists()) {\n            f.mkdir();\n        }\n        if (dest.exists()) {\n            if (force) {\n                dest.delete();\n            } else {\n                throw new IOException(\"Cannot overwrite existing file: \" + dest);\n            }\n        }\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) {\n                    break;\n                }\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } finally {\n                    if (out != null) {\n                        out.close();\n                    }\n                }\n            }\n        }\n        logger.debug(\"copyFile(File, File, int, boolean) - end\");\n    }\n", "label": 1, "substitutes": {"transformSingleFile": [" transformOneSourceFile", " transformSingleSourceFile", "transformsingleFile", " transformOnefile", "transformSinglefile", "transform1Files", " transformSinglefile", "transformsingleFiles", "transformOneSourceFile", "transformSinglePath", "transformMultiSourceFile", "transformOnefile", " transformSingleFiles", "transform1SourceFile", "transform1File", "transformMultiFile", " transformOneFiles", "transformOneFiles", "transform1Path", "transformMultifile", " transformSinglePath", " transformOnePath", "transformOneFile", "transformsinglefile", "transformSingleFiles", " transformOneFile", "transformsingleSourceFile", "transformOnePath", "transformMultiFiles", "transformSingleSourceFile"], "xed": ["rexED", "exeded", "xedited", "xEd", "rexeds", "exEd", "xED", "xeded", "xxed", " xedited", " Xeds", "xxeded", "xted", " xEd", "exeb", " Xeded", " xended", "xtED", "xteds", "xtEd", " Xeb", "xeb", "xxedited", "xxeds", "xended", " xED", "exed", "rexeded", "rexed", "xxeb", " xeds", "xxended", "Xended", "exED", "xeds", "Xed", "exeds", " xeded", " Xed", "Xeded", "xxED", "Xedited"], "node": ["image", "error", "component", "shape", "query", "tree", "object", "load", "instance", "slave", "parent", "ode", "route", "copy", "page", "option", "loc", "child", "Node", "location", "index", "message", "path", "op", "day", "row", "file", "root", "part", "no", "none", "set", "edge", "live", "document", "name", "leaf", "menu", "event", "source", "config"], "dob": ["adub", "DOB", "adOB", "adob", " dub", "Dob", "DOb", "ddOB", "dod", " dOB", "ddOb", "dOb", "dub", "ddod", "ddub", "Dub", " dOb", "adod", "ddob", " dod", "dOB"], "mySrc": ["MySource", "MySrc", "mysrb", "myEsource", "mysrc", " myEsrc", "MyEssrc", " mySRC", "myDsource", " mySst", "mySrb", "MyEsRC", "MyAssrc", "mySsrc", "myAssrc", "mySource", "myDsRC", "myssrc", "MyAsource", "myDsrc", "myAsRC", "MySrb", "MySsrc", "myDrc", "myEsRC", "myDssrc", " mySsrc", "myAsst", "mySst", " myEssrc", "MyAsrc", "myAsrb", "myDst", "MyAsRC", "myAsource", "myEsrb", "myEsrc", "mysRC", "mySRC", "myAsrc", "MyEsrc", "myEsst", " myEsst", " myEsRC", "MySRC", "myEssrc", "MyEsrb", "myDRC"], "mySrcF": ["mySckF", "myEssrcf", "myCrcF", "myCRCE", "mySRCf", "mySRCF", "mySRCM", "mySRCE", "mySsrcf", "myCRCF", "myEsrcf", "myEssrcE", "mySrcE", "myCrcM", "mySckE", "myCRCM", "mySckM", "myEssrcF", "mySrcf", "myEssrcFile", "mySsrcM", "mySrcM", "myEsrcF", "myCrcf", "mySckf", "myEsrcE", "mySsrcF", "mySsrcFile", "myEsrcFile", "mySrcFile", "myCRCf", "mySourceFile", "mySourceF", "mySourceE", "mySRCFile", "myCrcE", "mySourcef", "mySsrcE"], "myOutF": ["myOutputFile", "myOutQ", "myOutputC", "myoutPF", "myOutPF", "myOUTFF", "myoutFile", "MyOutF", "MyOutPF", "MyOutFF", " myOutputF", "MyInPF", "myOUTPF", "MyOutD", "myOUTQ", "MyInFile", "myInC", " myOutC", "MyInE", "myoutC", "MyInD", "MyOutE", "myInQ", "myOutputE", "MyOutFile", "myoutFF", "myInD", " myOutputE", "myoutF", "myInPF", "myOutE", "myOutFF", "myInE", " myOutputC", "myOutputF", "MyInF", "myOUTE", "MyInQ", "myOUTF", "myOUTD", "MyInFF", "myInFF", " myOutE", "MyOutQ", "myInFile", "myOutD", "myOutFile", "myoutE", "myOutC", "myOUTFile", " myOutputFile", " myOutFile", "myInF"], "co": ["CO", "mo", "auto", "ico", "lo", "ca", "ck", "la", "OO", "flo", "oe", "ce", "rc", "cc", "aco", "CC", "bb", "ee", "che", "po", "bo", "ci", "cf", "fo", "coll", "lc", "cache", "oo", "fe", "loc", "isco", "cu", "bc", "code", "cos", "cho", "cur", "cca", "ob", "ko", "con", "conf", "fc", "BO", "ctrl", "no", "o", "pe", "can", "coe", " CO", "pc", "so", " Co", "colo", "company", "mc", "Co", "cmp", "gro", "cb", "c"], "x3dvFile": ["x3rdVPage", "x3dsvFiles", "x3rdVFile", "x3rdvfile", "x3ndvfile", "x3dsvFile", "x3ndvFile", "x3rdvPage", "x3dsvSource", "x3ndsvSource", "x3ndsvfile", "x3dvsPage", "x3ndsvFiles", "x3dVFiles", "x3dVPage", "x3dVFile", "x3dffile", "x3dfSource", "x3dvfile", "x3dvFiles", "x3dvSource", "x3dvsfile", "x3dfFile", "x3rdVfile", "x3dsvPage", "x3rdVFiles", "x3ndvSource", "x3dsvfile", "x3dvsFiles", "x3dvsFile", "x3dvPage", "x3dfFiles", "x3dVfile", "x3ndvFiles", "x3rdvFile", "x3dVSource", "x3rdvFiles", "x3ndsvFile"], "fis": ["refiss", "elfs", "Fbs", " fbs", "Fs", "fi", "fbs", "Fus", " fs", "elfisa", "elfis", " fiss", " fisa", " fus", "fs", "elfbs", "elfi", "elfiss", "elfus", "refi", "refisa", "fiss", "refis", "fisa", "fus", "Fis", " fi"], "gzos": ["bagis", "wxis", "wxos", "gzOS", "zxis", "zos", "zipops", "zxops", "zipos", "wxo", "gzo", "zOS", "zipis", "bago", "zops", "zo", "zis", "gzis", "bagops", "wxOS", "bagOS", "zxo", "zxos", "gzops", "bagos", "zxOS", "zipOS", "zipo"], "buf": ["fab", "db", "pad", "la", "buffer", "cas", "bytes", "seq", "batch", "bf", "br", "block", "queue", "ab", "ff", "lb", "dec", "uint", "port", "loc", "grab", "result", "bc", "rb", "fb", "cur", "buff", "av", "uc", "box", "Buff", "bag", "len", "bh", "feat", "bd", "vec", "data", "b", "cv", "cap", "ba", "uf", "done", "bin", "cb"], "ret": ["att", "fin", "success", "match", "r", "pet", "bf", "obj", "bit", "reply", "rc", "default", "RET", "id", "nt", "ft", "ry", "val", " RET", "reg", "result", "ver", "num", "ref", "out", "count", "fun", "len", "rets", "en", "rf", "f", "alt", "rep", "b", "rt", "Ret", "continue", "res", "det", "re", "repl"]}}
{"id1": "1954410", "id2": "7458833", "code1": "    protected ActionForward doExecute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        ActionMessages errors = new ActionMessages();\n        try {\n            boolean isMultipart = FileUpload.isMultipartContent(request);\n            Mail mailInstance = getMailInstance(request);\n            if (isMultipart) {\n                Map fields = new HashMap();\n                Vector attachments = new Vector();\n                List items = diskFileUpload.parseRequest(request);\n                Iterator iter = items.iterator();\n                while (iter.hasNext()) {\n                    FileItem item = (FileItem) iter.next();\n                    if (item.isFormField()) {\n                        if (item.getFieldName().equals(\"forwardAttachments\")) {\n                            String[] aux = item.getString().split(\":\");\n                            MailPartObj part = mailInstance.getAttachment(aux[0], aux[1]);\n                            attachments.addElement(part);\n                        } else {\n                            fields.put(item.getFieldName(), item.getString());\n                        }\n                    } else {\n                        if (!StringUtils.isBlank(item.getName())) {\n                            ByteArrayOutputStream baos = null;\n                            try {\n                                baos = new ByteArrayOutputStream();\n                                IOUtils.copy(item.getInputStream(), baos);\n                                MailPartObj part = new MailPartObj();\n                                part.setAttachent(baos.toByteArray());\n                                part.setContentType(item.getContentType());\n                                part.setName(item.getName());\n                                part.setSize(item.getSize());\n                                attachments.addElement(part);\n                            } catch (Exception ex) {\n                            } finally {\n                                IOUtils.closeQuietly(baos);\n                            }\n                        }\n                    }\n                }\n                String body = \"\";\n                if (fields.get(\"taBody\") != null) {\n                    body = (String) fields.get(\"taBody\");\n                } else if (fields.get(\"taReplyBody\") != null) {\n                    body = (String) fields.get(\"taReplyBody\");\n                }\n                Preferences preferencesInstance = getPreferencesInstance(request);\n                Send sendInstance = getSendInstance(request);\n                String mid = (String) fields.get(\"mid\");\n                if (StringUtils.isBlank(mid)) {\n                    request.setAttribute(\"action\", \"compose\");\n                } else {\n                    request.setAttribute(\"action\", \"reply\");\n                }\n                Boolean isHtml = null;\n                if (StringUtils.isBlank((String) fields.get(\"isHtml\"))) {\n                    isHtml = new Boolean(preferencesInstance.getPreferences().isHtmlMessage());\n                } else {\n                    isHtml = Boolean.valueOf((String) fields.get(\"isHtml\"));\n                }\n                sendInstance.send(mid, Integer.parseInt((String) fields.get(\"identity\")), (String) fields.get(\"to\"), (String) fields.get(\"cc\"), (String) fields.get(\"bcc\"), (String) fields.get(\"subject\"), body, attachments, isHtml.booleanValue(), Charset.defaultCharset().displayName(), (String) fields.get(\"priority\"));\n            } else {\n                errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"mail.send\", \"The form is null\"));\n                request.setAttribute(\"exception\", \"The form is null\");\n                request.setAttribute(\"newLocation\", null);\n                doTrace(request, DLog.ERROR, getClass(), \"The form is null\");\n            }\n        } catch (Exception ex) {\n            String errorMessage = ExceptionUtilities.parseMessage(ex);\n            if (errorMessage == null) {\n                errorMessage = \"NullPointerException\";\n            }\n            errors.add(\"general\", new ActionMessage(ExceptionCode.ERROR_MESSAGES_PREFIX + \"general\", errorMessage));\n            request.setAttribute(\"exception\", errorMessage);\n            doTrace(request, DLog.ERROR, getClass(), errorMessage);\n        } finally {\n        }\n        if (errors.isEmpty()) {\n            doTrace(request, DLog.INFO, getClass(), \"OK\");\n            return mapping.findForward(Constants.ACTION_SUCCESS_FORWARD);\n        } else {\n            saveErrors(request, errors);\n            return mapping.findForward(Constants.ACTION_FAIL_FORWARD);\n        }\n    }\n", "code2": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"doExecute": ["submitexecuteApply", "doExecApply", "doexecuteRun", "submitexecuteRun", "doSendutes", "doSendute", "doSendRun", "doexecuteutes", "submitExecutes", "doexecuteApply", "submitexecuteutes", "doexecuteute", "doSendApply", "submitExecRun", "doExecutes", "submitexecuteute", "doExecRun", "submitExecApply", "submitExecute"], "mapping": ["fapper", "matching", "amapping", " mapper", "aminding", "mapper", " matching", "amatching", "fatching", "finding", "amapper", "fapping", " minding", "minding"], "form": [" forms", "template", "component", "formation", "flow", "pattern", "object", "feed", "app", "owner", "Form", "page", "dom", "format", "submit", "xml", "FORM", "post", "url", "definition", "builder", "control", "forms", "transform", "method", "command", "field", "config"], "request": ["client", "query", "hello", "worker", "queue", "q", "object", "view", "use", "context", "input", "user", "instance", "Reply", "s", "parent", "route", "HTTP", "server", "json", "address", "complete", "result", "format", "message", "resource", "report", "path", "pull", "xml", "submit", "_", "Bytes", "Response", "url", "req", "this", "Upload", "model", "session", "re", "type", "Accept", "data", "application", "requ", "method", "call", "name", "Request", "frame", "reader", "ware", "QUEST", "uri", "add", "current", "create", "self"], "response": ["client", " Response", "output", "reply", "object", " responses", "view", "page", "handler", "server", "json", "result", "report", "message", "resource", "xml", "Response", "Resp", "resp", "req", "model", "data", "v", "status", "application", "res"], "errors": [" session", " mess", " replies", "mess", " commands", " logger", " acc", " flashes", " managers", " events", " responses", " messenger", " error", " payload", " Messages", " changes", " translations", " failures", " messages", " logs", " this", " status", " streams", " management", " messaging", " calls", " warnings", " problems", " updates"], "isMultipart": ["isMultipound", "isMultippart", "isMultiparts", "isMultompart", "isMultippedart", "isMultitarts", "isMultiIPPart", "isMultiIPost", "isMultitart", "isMultiipart", "isMultippated", "isMultipost", "isMultipPart", "isMultippedound", "isMultiart", "isMultiipound", "isMultiIPound", "isMultIPart", "isMultipage", "isMultippedPart", "isMultompPart", "isMultIPPart", "isMultiipost", "isMultiated", "isMultiarts", "isMultitated", "isMultompost", "isMultiage", "isMultiipPart", "isMultippage", "isMultitage", "isMultompound", "isMultIPost", "isMultipated", "isMultippedost", "isMultIPound", "isMultipparts", "isMultiIPart"], "mailInstance": ["mailinstance", "mailInst", " emailUsage", " emailInstance", "fileInst", " mailInst", " mailinstance", "fileinstance", "emailInstance", " emailinstance", "emailinstance", "emailInst", "mailUsage", "emailManager", "fileUsage", "fileInstance", " emailInst", "fileManager", "mailManager", " mailManager", " mailUsage"], "fields": ["locks", "details", "words", "qs", "models", "files", "types", "loads", "boxes", "s", "strings", "tags", "headers", "input", "cells", "forces", "archives", "dates", "comments", "events", "maps", "links", "properties", "features", "lines", "gets", "keys", "objects", "holders", "atts", "packs", "services", "params", "posts", "members", "states", "changes", "classes", "pages", "checks", "uploads", "facts", "data", "forms", "groups", "lists", "views", "rows", "users", "ids", "acks", "utils", "ments", "parts", "rules", "field", "flows", "plugins"], "attachments": ["Attachps", "attachlements", "Attachments", "attachps", " attachparts", "attachions", "payparts", "attions", "suppments", "payments", "exters", " attachment", "attachees", "extps", "attps", "extions", "suppees", "achresses", "attachparts", "attment", "attlements", "attachresses", "extments", "suppment", "Attachlements", "payresses", "achment", "achparts", "Attachment", "attachment", "atters", "Attachers", "payment", " attachresses", "attachers", "attees", "attments", "supplements", "Attachees", "Attachions", "achments"], "items": ["locks", "children", "qs", "models", "files", "types", "phones", "its", "ips", "events", "es", "links", "lines", "keys", "objects", "reports", "results", "Items", "apps", "pages", "alls", "data", "lists", "groups", "orders", "rows", "ins", "names", "ids", "apters", "ops", "parts", "list", "ers", "plugins"], "iter": ["former", "Iterator", "iterator", "ip", "ner", "cher", "ul", "Iter", "i", "master", "order", "el", "chain", "slice", "enter", "page", "coll", "loc", "oper", "ver", "http", "inner", "ite", "exp", "li", "gener", "ir", "altern", "file", "edit", "end", "ator", "zip", "err", "keep", "inter", "er", "it", "itter", "skip", "ter", "upper", "finder", "reader", "list", "loop", "outer", "ser", "event", "walker", "inc", "izer"], "item": ["next", "image", "entry", "i", "section", "attribute", "complete", "example", "info", "more", "container", "post", "api", "base", "update", "er", "name", "volume", "custom", "reader", "folder", "get", "ip", "atom", "element", "full", "load", "user", "page", "val", "inner", "li", "index", "anything", "file", "area", "hop", "plugin", "event", "issue", "original", "service", "art", "order", "object", "app", "slice", "result", "url", "Item", "missing", "it", "source", "layer", "up", "obj", "all", "instance", "album", "handler", "coll", "server", "or", "resource", "storage", "data", "type", "temp", "token", "other", "entity", "site", "extra", "current", "widget"], "aux": ["ups", "cas", "auc", "au", "union", "amp", "fax", "off", "asc", " Aux", "strings", "etc", "ou", "packages", "pkg", "lc", "aos", "ox", "alias", "ru", "af", "array", "ants", "ext", "ras", "aus", "aw", "uc", "sup", "offs", "abs", "axe", "buf", "prefix", "abc", "imp", "des", "data", "except", "lang", "uf", " auxiliary", "anc", "frac", "ux", "sub", "cmp", "extra", "aff"], "part": ["error", "component", "p", "obj", "one", "element", "pos", "html", "full", "block", "art", "key", "class", "object", "pre", "action", "but", "user", "instance", "parent", "on", "section", " Part", "po", "patch", "id", "per", "val", "info", "diff", "group", "fact", "format", "connection", "ref", "word", "pair", "change", "step", "file", "PART", "start", "pi", "f", "area", "ch", "no", "base", "data", "type", "player", "b", "partial", "comp", "joined", "co", "Part", "name", "l", "plugin", "parts", "list", "and", "point", "field", "act", "join", "add", "back", "layer"], "baos": ["baOS", "abaosi", "boo", " bais", "haoss", "bois", "baoss", "boOS", " baoss", "BAosh", "BAos", "abaOs", "haos", "Bao", " bao", "BAis", "paos", " baoS", "boot", "abaos", "BAOs", "Baosi", "paOS", "hao", "baosh", "baosi", "bao", "Baos", "paot", " baot", "BAoS", "pais", "baoS", "bais", "boosh", "hais", "BAoss", "baOs", "paosh", "baot", " baOS", "BAosi", "BaoS", "boos", "BAo", "abais", "pao", "BaOs", "Bais"], "body": ["template", "size", "query", "flash", "tree", "html", "full", "fee", "summary", "output", "reply", "object", "comment", "common", "headers", "port", "json", "state", "media", "connection", "content", "message", "resource", "params", "translation", "description", "value", "options", "end", "url", "binary", "null", "pass", "zip", "data", "type", "b", "shell", "text", "name", "document", "string", "parts", "header", "source", "length", "Body"], "preferencesInstance": ["preferencesClient", "prefeesClient", "preffeesClient", "preffeesinstance", "prefirmsClient", "preffeesInstance", "prefirmsInstance", "prefferencesinstance", "prefferencesInstance", "prefiesinstance", "prefeesInstance", "prefirmsinstance", "prefferencesClient", "preferencesinstance", "prefiesClient", "prefiesInstance", "prefeesinstance"]}}
{"id1": "6988216", "id2": "16623181", "code1": "    public void testSimpleQuery() throws Exception {\n        JCRNodeSource dummySource = (JCRNodeSource) resolveSource(BASE_URL + \"users/alexander.klimetschek\");\n        assertNotNull(dummySource);\n        OutputStream os = ((ModifiableSource) dummySource).getOutputStream();\n        assertNotNull(os);\n        String dummyContent = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>alexander</id><teamspace>cyclr</teamspace><teamspace>mindquarryTooLong</teamspace></user>\";\n        os.write(dummyContent.getBytes());\n        os.flush();\n        os.close();\n        JCRNodeSource source = (JCRNodeSource) resolveSource(BASE_URL + \"users/bastian\");\n        assertNotNull(source);\n        os = ((ModifiableSource) source).getOutputStream();\n        assertNotNull(os);\n        String content = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?><user><id>bastian</id><teamspace>mindquarry</teamspace></user>\";\n        os.write(content.getBytes());\n        os.flush();\n        os.close();\n        QueryResultSource qResult = (QueryResultSource) resolveSource(BASE_URL + \"users?/*[.//user/teamspace='mindquarry']\");\n        assertNotNull(qResult);\n        Collection results = qResult.getChildren();\n        assertEquals(1, results.size());\n        Iterator it = results.iterator();\n        JCRNodeSource rSrc = (JCRNodeSource) it.next();\n        InputStream rSrcIn = rSrc.getInputStream();\n        ByteArrayOutputStream actualOut = new ByteArrayOutputStream();\n        IOUtils.copy(rSrcIn, actualOut);\n        rSrcIn.close();\n        assertEquals(content, actualOut.toString());\n        actualOut.close();\n        rSrc.delete();\n    }\n", "code2": "    public static void main(String[] args) {\n        File srcDir = new File(args[0]);\n        File dstDir = new File(args[1]);\n        File[] srcFiles = srcDir.listFiles();\n        for (File f : srcFiles) {\n            if (f.isDirectory()) continue;\n            try {\n                FileChannel srcChannel = new FileInputStream(f).getChannel();\n                FileChannel dstChannel = new FileOutputStream(dstDir.getAbsolutePath() + System.getProperty(\"file.separator\") + f.getName()).getChannel();\n                ByteBuffer buffer = ByteBuffer.allocate(1024);\n                int nr = 0;\n                srcChannel.position(nr);\n                nr += srcChannel.read(buffer);\n                while (nr < f.length()) {\n                    buffer.flip();\n                    dstChannel.write(buffer);\n                    buffer.clear();\n                    nr += srcChannel.read(buffer);\n                }\n                srcChannel.close();\n                dstChannel.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testSimpleQuery": ["runRawSearch", "runSimpleQuery", " runBasicSearch", " runBasicFilter", "runSimpleFilter", " runSimpleQuery", " runRawSearch", " runBasicConnect", " runRawQuery", "runRawQuery", " runClientFilter", " runBasicQuery", " runRawFilter", "runRawConnect", " runClientConnect", " runClientQuery", "runRawFilter", " runSimpleSearch", " runSimpleConnect", " runSimpleFilter", " runClientSearch", "runSimpleConnect", " runRawConnect", "runSimpleSearch"], "dummySource": ["duddySite", "dummyType", "pummyService", " dummyOrigin", "dandyClient", "dumbConfig", " dumbSource", "dellyService", "dandySource", "puddyClient", "dellyType", "duddyOrigin", "duddyContent", "dummyClient", "pummySite", "dummySite", "daddyClient", "daddyContent", "dummyService", "dundleContent", "duddyType", "daddyType", "dandySite", "dellyContent", "duddySourceFile", "daddySourceFile", "pummyType", "dumbContent", "dummyOrigin", "puddySource", "dummySourceFile", "daddyService", " dumbContent", "duddyClient", "puddyService", "dummyConfig", "duddyService", " dumbOrigin", "pummySourceFile", " dummyConfig", "dumbOrigin", " dumbConfig", "pummyClient", "dandySourceFile", "puddySite", "dellySource", "pummyContent", "dundleConfig", "daddySource", "puddyType", "puddySourceFile", "dundleSource", "puddyContent", "dumbSource", "daddySite", "duddyConfig", "dundleOrigin", "pummySource", "duddySource"], "os": ["us", "ok", "oos", "oss", "iso", "pos", "uns", "dos", "i", "is", "ose", "bs", "object", "s", "ou", "ls", "ol", "ns", "om", "ows", "ros", "ens", "aos", "es", "css", "conn", "ox", "los", "ks", "or", "obs", "cos", "ios", "ori", "oses", "io", "oc", "op", "out", "ds", "oa", "nos", "OS", "osi", "ols", "o", "fs", "mos", "oS", "ops", "vs", "bos", "ss", "acs", "as", "ps", "ms", "sys", "Os"], "dummyContent": [" dummyOutput", " dellyContents", "dumpingOutput", "dumpercontent", "DummyContent", "DuckyBody", " dummyContents", "dummyContents", " dummycontent", "dellyOutput", "duckyReader", "dumperBody", "duddyContent", "duckyBody", "dumperContents", "dellyContent", "dellycontent", "dumperReader", "duckyContent", "dumperOutput", "duddySource", "duckySource", "DuckyReader", "DummyBody", "dummyReader", "DummyReader", "duddyBody", "dumpingcontent", " dellycontent", "DummySource", "DuckySource", " dellyOutput", "dellyContents", "duddyReader", "dumperSource", "dumperContent", " dellyContent", "dummyBody", "DuckyContent", "dumpingContent", "dummyOutput", "dumpingContents", "dummycontent"], "source": [" Source", "sc", "client", "service", "size", "sl", "sync", "element", "stream", "src", "i", "class", "host", "object", "s", "proxy", "use", "scope", "slave", "e", "parent", "sn", "sin", "core", "cache", "info", "result", "target", "connection", "cos", "resource", "resources", " sources", "Source", "secure", "storage", "url", "unit", "channel", "SOURCE", "search", "text", "node", "site", "reader", "string", "seed", "uri", "ser", "ource", "config", "ources"], "content": ["image", "clean", "match", "service", "children", "size", "html", "Content", "host", "output", "comment", "load", "feed", "input", "title", "version", "comments", "expression", "css", "sol", "server", "address", "child", "target", "result", "code", "media", "cos", "response", "resource", "report", "message", "xml", "music", "value", "description", "cover", "url", "update", "model", "data", "activity", "transform", "text", "document", "news", "body", "header", "cms", "cont", "current", "config"], "qResult": ["qresult", "qResults", "iqResult", " qResponse", "rSource", "iqresult", "kResult", "queryReturn", "QReturn", "queryResult", "qRes", "rResult", "kReturn", "rRes", "qReturn", "kresult", "kSource", "QResult", "queryRes", "QResults", "queryResponse", "iqResults", "iqResponse", "QFilter", "kFilter", "kRes", "qResponse", "rresult", "queryresult", "qFilter", "querySource", "kResults", "qSource", "queryResults", " qResults", "queryFilter", " qresult"], "results": ["items", "details", "children", "qs", "models", "files", "s", "its", "events", "features", "lines", "objects", "result", "vers", "response", "reports", "docs", "successful", "resources", "members", "ions", "pages", "data", "values", "blocks", "RESULTS", "users", "errors", "collection", "groups", "rows", "ins", "ries", "ids", "versions", "res", "shows", "runs", "Results", "tests"], "it": ["rit", "r", "itted", "in", "ip", "the", "p", "ic", "entry", "stat", "i", "you", "ort", "init", "its", "sit", "slice", "id", "ci", "ITS", "t", "info", "or", "ited", " It", "pit", "not", "ite", "mit", "op", "ati", "lit", "edit", "which", "iter", "v", "ait", "split", "ins", "IT", "l", "list", "si", "and", "iti", "It"], "rSrc": ["rSource", " rDsource", "rIsrc", "RIsRC", "RIsrc", "rPsrc", "rAssrc", "rDsRC", "rPssrc", "rAsource", "RIsrec", "rIsrec", "rSRC", "rEsource", " rDsRC", "rIsource", "rAsRC", "rSrec", " rSRC", " rSsrc", " rDsrc", " rEsrc", " rDssrc", "rEsRC", "rPsRC", " rEsource", "rDsource", "rIsRC", "rSsrc", "rEssrc", "rDssrc", "RSRC", "RIsource", "rPsource", "RSrc", "rAsrc", "rAsrec", "RSource", "RSrec", " rSource", " rEssrc", "rEsrc", "rDsrc", " rEsRC"], "rSrcIn": ["rSvcIns", "rAsrcin", "rSsrcIn", "rSvcIn", "rSrcIN", "rAsrcOut", "rSRCIns", "rCrcIns", "rSsrcin", "rSourcein", "rSourceOut", "rSourceIn", "rCsrcIN", "rCrcin", "rSvcin", "rCrcIn", "rAsRCin", "rCRCIn", "rSrcIns", "rSsrcOut", "rSRCin", "rCRCIns", "rSsrcIN", "rCRCOut", "rSRCIN", "rSRCOut", "rCrcIN", "rCsrcin", "rSvcIN", "rSrcin", "rAsRCOut", "rSrcOut", "rSourceIns", "rSRCIn", "rAsRCIn", "rCrcOut", "rCsrcOut", "rAsrcIn", "rCsrcIn", "rSvcOut"], "actualOut": ["eventIn", "nexpectedWin", " actualBridge", "nexpectedOut", "illegalOutput", "publicIn", "operatorIn", " ActualBridge", "publicOutput", " ActualOUT", "illegalOut", "assertIn", "eventOut", " actualout", "eventOUT", " actualOutput", "assertOut", "nexpectedIn", "publicOUT", "assertBridge", "realout", "actualOutput", "assertOUT", " ActualIn", "actualOUT", "illegalOUT", "actualWin", " actualIn", "actualBridge", " actualWin", "eventout", "actualout", "nexpectedout", "operatorout", "realIn", " ActualOut", "operatorOut", " actualOUT", "publicOut", "illegalIn", "realWin", "operatorOUT", "realOut", "actualIn"]}}
{"id1": "13122204", "id2": "20375440", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipProject", "unzipProject", "UnzipFile", "unpackmodel", "Unarchivemodel", "unarchiveFile", "unpatchmodel", "unarchivemodel", "unpackModel", "unpackFile", "unzipFile", "UnarchiveModel", "unpackProject", "UnzipModel", "unpatchModel", "unarchiveProject", "unzipmodel", "UnarchiveProject", "unpatchFile", "UnarchiveFile", "unarchiveModel", "Unzipmodel", "unpatchProject"], "filename": ["Filename", "txt", "bf", "files", "src", "fd", "title", "il", "directory", "File", "loc", "module", "location", "path", "fp", "fn", "FILE", "file", "f", "url", "nil", "model", "download", "fil", "database", "kl", "SourceFile", "fits", "name", "l", "string", "utf", "jet", "folder", "uri", "source", "username"], "tempdir": [" temppath", "TempDIR", "tempDir", "tempath", "tempdirectory", "tmpfolder", "Tempfolder", "tempfolder", "TempDir", " tempfolder", "tmpDir", "temDir", "tmppath", "temdirectory", "tempDIR", "temdir", "Tempdir", "tmpDIR", "Tempdirectory", "temppath", " tempdirectory", "tmpdir", "tmpdirectory", "temfolder", " tempDir", " tempDIR"], "dest": ["de", " Dest", "obj", "sync", "walk", "src", "output", "transfer", "delete", "tmp", "comb", "opt", "std", "default", "tar", "nt", "handler", "home", "Dest", "ui", "loc", "target", "result", "dc", "desc", "inner", "exit", "later", "proc", "cdn", "file", "sup", "dist", "store", "dir", "die", "st", "wb", "zip", "rest", "temp", "flat", "session", "log", "builder", "trans", "done", "test", "transform", "export", "di", "prop", "folder", "usr", "cont", "gen", "dat", "source", "walker", "txt"], "fis": ["lis", "fileiss", "fbis", "fsisa", "fid", "fi", "flbis", "fsiss", "flis", "fsis", "fliss", "li", "filebis", " fiss", "fileis", "fileid", "fsbis", "lid", "fiss", "fileisa", " fid", "liss", "filei", "fisa", "flisa", " fi"], "BUFFER": ["BUUCK", "TAFFER", "BUVER", "BOFER", "SAUCK", "UPVEN", " BUFIX", "SAFFER", "CUVEN", " BUVER", "TAVER", "UPFFER", "CUFF", " BUFER", "BUFF", " BUPER", "BOFIX", "BUVEN", "MAFFER", " BUFF", "BOFFER", "CUPER", " BUUCK", "SAVER", "SAPER", "MAFER", "BUFER", "BUFIX", "CUVER", "CUFFER", "UPFF", "BUPER", "MAFIX", "TAPER", "MAPER", " BUVEN", "UPVER", "TAUCK", "BOPER", "CUUCK"], "zis": ["xiss", "jists", "jis", "xis", " ziss", "zos", " zos", " zisa", "zipins", "Zis", "zipas", "zin", "ziss", "dii", "yIS", "xists", " zins", "zii", "Zisa", "yin", " zas", " zii", "zIS", "zins", "zi", "zas", "zisa", "xos", "zipisa", "zipis", "xbis", "dis", "Zins", " zists", " zi", "xi", "zipIS", "zists", " zIS", "yis", "zipin", "ji", "zbis", "yisa", "Zas", " zin", "xii", "diss", " zbis", "dbis", "jos"], "entry": ["next", "image", "iterator", "ace", "match", "la", "de", "element", "ie", "way", "cel", "ce", "rc", "feed", "ou", "cat", "e", "enter", "id", "nt", "ry", "archive", "lc", "valid", "server", "info", "module", "result", "or", "connection", "ident", "li", "inner", "se", "pack", "line", "row", "file", "part", "end", "ge", "porter", "zip", "pe", "her", "spec", "ent", "record", "ries", "je", "name", "Entry", "reader", "si", "source", "inc", "jo"], "count": ["ind", "next", "in", "buffer", "writer", "size", "max", "pos", "cond", "Count", "key", "current", "i", "use", "feed", "write", "e", "id", "limit", "core", "coll", "cache", "val", "last", "code", "sum", "low", "time", "index", "weight", "_", "line", "file", "part", "len", "start", "end", "iter", "f", "base", "type", "b", "log", "number", "allow", "name", "counter", "list", "add", "read", "c", "length"], "data": ["next", "image", "la", "buffer", "bytes", "size", "batch", "alpha", "pos", "block", "load", "feed", "input", "write", "id", "info", "result", "format", "media", "content", "array", "message", "zero", "index", "a", "pack", "raw", "value", "str", "len", "start", "base", "number", "record", "name", "reader", "DATA", "d", "body", "shift", "read", "dat", "length"], "fos": [" foes", "xoes", "bis", " foos", "foes", "fOS", "afOS", "xops", "bOS", "foos", "xos", " fops", "afos", "dfoes", "afis", "dfoos", "dfos", "bops", "afops", "xoos", "fops", "bos", " fOS", "dfops"]}}
{"id1": "5125848", "id2": "8132219", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static void copyFile(String inFile, String outFile) {\n        File in = new File(inFile);\n        File out = new File(outFile);\n        try {\n            FileChannel inChannel = new FileInputStream(in).getChannel();\n            FileChannel outChannel = new FileOutputStream(out).getChannel();\n            try {\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n            } finally {\n                if (inChannel != null) inChannel.close();\n                if (outChannel != null) outChannel.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"combineJs": ["Combinejs", "combineJS", "CombinateJS", "CombineJs", "combinScript", "combinedJS", "combinedJs", "CombineScript", "combinateScript", "combinedScript", "combinejs", "CombinateScript", "combinateJS", "combinJS", "combineScript", "combinateJs", "CombineJS", "combinedjs", "combinjs", "CombinateJs", "combinatejs", "Combinatejs", "combinJs"], "base": ["image", "db", "absolute", "proxy", "page", "cache", "server", "home", "address", "info", "relative", "http", "resource", "ref", "based", "out", "file", "build", "root", "bas", "part", "store", "f", "area", "prefix", "api", "builder", "data", "b", "log", "bot", "site", "string", "Base", "uri", "source", "config"], "linkJs": [" linkjs", "loadJs", "linkedjs", "likeLinks", " linkLinks", "likeJS", "loadScript", "loadjs", " linkScript", "likejs", "linkedLinks", "linkedJs", "linkjs", "linkScript", "linkJS", "loadJS", "linkLinks", " linkJS", "likeJs", "linkedJS", "linkedScript"], "newFiles": ["addFiles", "addResources", "oldFiles", " newLinks", "oldLinks", "oldResources", "addfiles", "addLinks", " newfiles", "newfiles", "newLinks", "oldfiles", "newResources", " newResources"], "dir": ["domain", "db", "in", "DIR", " db", " download", "src", " folder", "object", "id", "directory", " manager", "cache", "home", "md", " Dir", " directory", "loc", "module", "or", "relative", "http", "container", " d", "dep", "editor", "direction", "ir", "out", "manager", "work", "wd", "file", "build", "root", "dist", " dep", "lib", "zip", "session", "div", "download", "log", "b", "local", "keep", "Dir", " module", "plugin", "d", "folder", " repo", "uri", "lock", " block", "source", " director"], "name": [" resource", " build", " bundle", " info", " zip", " folder", " root", " init", " manager", " abs", " relative", " source", " prefix", " title", " id", " suffix", " dest", "Dir", " head", " cache", " parent", " module", " app", " repo"], "minDir": ["minJar", "miniDriver", "tempDir", " minDriver", "minidir", "miniDb", "blockDir", "versionDir", "blockFile", "minManager", "blockdir", "Mindir", "MinMin", "minDriver", "minDb", "versionManager", "tempdir", "blockDriver", "mindir", "minDest", "initManager", " minFile", " minDb", " minMin", "versionDirectory", "tempJar", "miniFile", "initFolder", " minManager", " minJar", "MinJar", " mindir", " minDest", "minFile", "tempMin", "MinDb", "initDir", "minDirectory", "miniDest", "initDirectory", "minMin", "minFolder", " minFolder", "MinDest", "MinDir", "miniDir", " minDirectory", "versionFolder", "MinFile"], "combineFile": ["comboseWriter", "combinateWriter", "CombineSourceFile", "combinerSourceFile", "CombinateLog", "combinedWriter", "comboseFile", "combinateReader", "combinerLog", "CombinateFile", "combinateFile", "CombinateWriter", "combinerWriter", "combineDir", "comboseDir", "joinateWriter", "joinateFile", "combinedDir", "CombineWriter", "joineReader", "joineWriter", "CombineLog", "combineSourceFile", "combicateFile", "combinedFile", "combineReader", "combinerFile", "joineFile", "joinateReader", "combineLog", "joineDir", "combinateSourceFile", "combinateDir", "CombineFile", "combinateLog", "combinedReader", "combicateSourceFile", "joinateDir", "combicateLog", "combicateWriter", "comboseReader", "CombinateSourceFile"], "concatFile": ["Concatsfile", "concatDir", "concDir", "concWriter", "concatFiles", "concfile", "ConcatsWriter", "concentFile", "ConcatsStream", "concatsFile", "concentWriter", "conatefile", "Concatfile", "concFiles", "ConcatFile", "concentDir", "ConcatFiles", "conateDir", "ConcatWriter", "concatsDir", "concentStream", "ConcatDir", "concFile", "concatsfile", "ConcatsDir", "conateFile", "concatsStream", "concatfile", "concatsFiles", "ConcatsFiles", "ConcatsFile", "concatsWriter", "conateFiles", "concStream", "ConcatStream", "concatStream"], "combineWriter": ["comboseWriter", "combinerReader", "ComboseFile", "combinateWriter", "combineWalker", "combiseWriter", "combideWalker", "combideReader", "combineRW", "comboseFile", "combinateReader", "combinateFile", "mixineWalker", "combideRW", "mixineWriter", "mixinerReader", "comboseWalker", "combideWriter", "CombineWriter", "combineWrite", "ComboseWriter", "CombineWrite", "combiseFile", "combineReader", "ComboseReader", "combiseWrite", "comboseWrite", "mixinerRW", "mixinerWriter", "CombineReader", "combiseReader", "combinerWalker", "combinerRW", "CombineFile", "ComboseWrite", "mixineRW", "mixineReader", "comboseRW", "comboseReader", "mixinerWalker", "combinerWriter", "combinateWrite"], "concatWriter": ["concilFile", "syncatWriter", "ConcatsWrite", "concWriter", "syncWriter", "syncWrite", "ConcatWrite", "convertWrite", "ConcatsWriter", "concReader", "concatsFile", "ConcatFile", "syncatReader", "concatsReader", "ConcatWriter", "syncReader", "concatDriver", "convertReader", "ConcatDriver", "convertWriter", "concilDriver", "concatReader", "concFile", "convertFile", "syncFile", "ConcatsDriver", "concilWrite", "ConcatsFile", "concatsWriter", "concilWriter", "concatWrite", "convertDriver", "syncatFile", "concWrite", "concatsWrite", "concatsDriver", "syncatWrite"], "fails": ["Frors", "frors", "Fls", "fls", "Falls", " fls", "Fails", "foralls", "ifls", "trors", "Fakes", "forils", "Failed", "infils", "Faults", "foraults", "ifils", "ifakes", "failed", "dfailing", "failing", "tils", "infaults", "tails", "dfils", " failing", "forails", "ifails", " fakes", " fils", "dfails", "falls", "Fils", "Failing", "infails", " failed", "fakes", "fils", "faults", "dfailed", "infalls", "tls", " frors"], "link": [" resource", "image", "match", " comment", "block", "ink", "Link", "comment", "load", "dd", " config", "bug", "parse", "e", " node", "links", "address", "open", " Link", "info", "loc", " tag", " inline", "connection", "li", "message", " site", " http", " target", "line", " entry", " source", " page", " html", "linked", " module", " lang", " document", "l", " item", "style", "follow", " anchor", "uri", "add", " location"], "path": ["PATH", "script", "attr", "entry", "src", "key", "class", "pattern", "input", "id", "attribute", "route", "loc", "info", "code", "Path", "location", "content", "pointer", "value", "wd", "file", "step", "data", "type", "text", "node", "ath", "string", "href", "point", "uri", "source", "filename"], "url": ["image", "r", "sl", "html", "stream", "host", "key", "route", "page", "server", "address", "open", "loc", "result", "connection", "http", "location", "URL", "resource", "pull", "xml", "ssl", "file", "build", "str", "f", "Url", "api", "channel", "data", "download", "ri", "loader", "b", "log", "l", "browser", "string", "web", "uri", "source", "www"], "inputStream": ["InputFile", " inputWriter", "inputChannel", "outputstream", "outputFile", "Inputstream", "InputChannel", "outputStreamer", "downFile", "downStreamer", " inputstream", "outputChannel", "outputReader", "outputWriter", "downStream", "InputReader", " inputFile", "InputStreamer", "InputStream", "inputReader", " inputChannel", "downReader", "inputFile", "InputWriter", "inputStreamer", "inputWriter", "inputstream"], "jsFile": ["jsonFile", "javascriptDir", "scriptSource", "scriptPath", "javascriptReader", " jsWriter", "javascriptPath", "scriptFile", "javascriptStream", "JsFile", "jsStream", "jsfile", "jsWriter", "javascriptWriter", "jsonSource", "JsStream", "javascriptFile", "JsWriter", "javascriptSource", " jsfile", "jsReader", "jsSource", "jsPath", "jsDir", "jsonDir", " jsLog", "Jsfile", "JsReader", "scriptDir", "javascriptfile", "jsLog", "JsLog", "jsonPath", "javascriptLog", " jsReader", " jsStream"], "fileName": ["fileSize", " fileSize", "resourceSize", "fileNumber", " fileNumber", "FilePath", "filePath", "resourcePath", "FileName", " filePath", "FileNumber", "resourceNumber", "FileSize", "resourceName"], "outputStream": ["responseWriter", "outputstream", "OutputStream", "outputFile", " outputReader", "resourceSteam", " outputstream", " outputSteam", "OutputWriter", "responseStream", "outputReader", "responseSteam", "outputWriter", "outputSteam", "inputSteam", " outputWriter", "resourceReader", "OutputFile", " outputFile", "responseReader", "Outputstream", "resourcestream", "resourceStream", "inputFile", "OutputSteam", "OutputReader", "inputWriter"], "first": ["next", "auto", "success", "error", "before", "p", "third", "left", "alpha", "one", "full", "all", "same", "default", "use", "user", "required", "then", "stack", "replace", "last", "th", "result", "found", "only", "top", "count", "now", "root", "must", "start", "second", "st", "primary", "each", "split", "it", "other", "First", "again", "prev", "always", "current", "self", "right", "initial"], "reader": ["r", "image", "in", "writer", "buffer", "h", "Reader", "entry", "stream", "rc", "object", "feed", "context", "input", "e", "handler", "reads", "server", "info", "inner", "report", "resource", "io", "xml", "reading", "file", "f", " Reader", "data", "builder", "loader", "er", "driver", "parser", "read", "dd", "source", "config"], "jsCompressor": ["jsRepress", "jsExpressor", "jsExpression", "jsExporter", "jsReporter", "jsCompress", "jsComporter", " jsCompression", "jsRepression", "jsRepressor", " jsCompress", "jsCompression", "jsExpress", " jsComporter"], "s": ["S", "os", "m", "words", "scripts", "g", "qs", "n", "is", "types", "strings", "xs", "ls", "ns", "comments", "ses", "ens", "es", "t", "gets", "lines", "objects", "states", "ions", "ings", "abs", "en", "fs", "sets", "v", "groups", "l", "ing", "ments", "ss", "gs", "ps", "sys", "ws", "ts"], "s1": ["atsAP", "ats2", "sAP", "ings2", "esB", "s81", "ingsB", "qsIP", "ats1", "ys2", "sPre", "esPre", "esAP", "etsPre", "es1", "etsAP", "ys01", "ings1", "ys1", "es2", "qs2", "qs81", "qs1", "s01", "ets2", "ings01", "ets1", "es81", "sB", "esIP", "sIP", "ysB", "atsPre", "es01"], "i": ["ip", "m", "j", "p", "ic", "is", "ik", "q", "e", "phi", "id", "t", "ui", "ifier", "a", "ii", "z", "bi", "x", "pi", "f", "o", "xi", "u", "b", "v", "w", "l", "ing", "d", "si", "qi", "I", "c"], "s2": ["s62", "esSecond", "etsCloud", "etsSecond", "ets82", "ings2", "sSecond", "qs12", "es82", "esCloud", "sets1", "lsSecond", "ls2", "ings12", "ls62", "setsCloud", "qsSecond", "es1", "ets62", "ings1", "ingsSecond", "es2", "es12", "qs2", "qs1", "ets2", "sCloud", "sets2", "ets1", "es62", "s82", "sets82", "s12", "ls1"], "i1": ["e2", "l1", "e1", "a9", "s9", "iFirst", "pi9", "piFirst", "i0", "a1", "i2", "pi4", "e0", "pi0", "a4", "l2", "sFirst", "s4", "iOne", "pi1", "l0", "i9", "eFirst", "s0", "eOne", "i4", "sOne", "lOne", "a2", "pi2"]}}
{"id1": "22560224", "id2": "15351863", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    public static String generate(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringUTF8", " hashFileMD8", " hashStringMK4", " hashStringM6", " hashStringUTF6", " hashStringM4", " hashFileMD6", " hashStringUTF4", " hashStringMK8", " hashStringM5", " hashStringM8", " hashStringMK5", " hashStringMD4", " hashFileMK8", " hashStringUTF5", " hashFileMK5", " hashFileMK6", " hashFileMD5", " hashStringMD6", " hashFileMD4", " hashStringMD8", " hashStringMK6", " hashFileMK4"], "string": ["STR", "buffer", "writer", "bytes", "p", "service", "script", "object", "map", "strings", "input", "sequence", "version", "slice", "section", "address", "result", "content", "array", "message", "word", "date", "file", "str", "operator", "binary", "letter", "null", "data", "database", "number", "text", "name", "ring", "password", "list", "uri", "source", "filename"], "md": ["km", "mm", "mac", "m", "dig", "bf", "ad", "pd", "metadata", "um", "od", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "sm", "mg", "dm", "data", "pm", "MD", "mp", "me", "mc", "rpm", "mag", "hd", "d", "gm", "vd", "ms", "meta", "hash", "am", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "largeData", "byteInfo", "linedata", "byteLength", "lineBytes", "byteSeries", "ByteDATA", "bytePart", "ByteSeries", "lineInfo", " bytedata", "wordInfo", "ByteData", "ByteString", "byteArray", "ByteInfo", "harddata", "BytePart", " byteArray", "letterLength", " bytePart", " byteLength", "bitdata", "largeDATA", "bitData", "Bytedata", "bytedata", "wordData", " byteBytes", " byteString", "wordArray", "largeSeries", " byteDATA", "wordPart", " byteInfo", "blockString", "hardLength", "bitBytes", "byteString", "letterDATA", "letterData", "blockdata", "hardData", " byteSeries", "largeArray", "blockData", "blockArray", "lineData", "letterdata", "hardDATA", "byteBytes", "byteDATA", "bitInfo"], "sb": ["db", "kB", "abb", "bp", "buffer", "sc", "bf", "BP", "src", "ab", "bs", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "fb", "bm", "bps", "mb", "buff", "gb", "ssl", "BG", "Bs", "pb", "Buff", "bh", "eb", "buf", " SB", "BB", "sq", "b", "xb", "obb", "nb", "SF", "ruby", "cb"], "i": ["ai", "ip", "in", "m", "j", "p", "h", "ie", "n", "g", "eni", "is", "s", "multi", "fi", "ix", "slice", "e", "phi", "abi", "id", "ci", "gi", "lc", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "yi", "qi", "uri", "field", "I", "c", "sp"], "hexString": ["nullBuffer", " hexArray", "octArray", "shortBuffer", " hexStr", "octStr", "exstring", "hexstring", "hexText", "formString", "hexArray", "formstring", "shortString", "nullstring", "formStr", "exArray", "nullString", "exText", "shortstring", "exStr", " hexBuffer", "exBuffer", "octstring", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "nullText", "formArray", "octBuffer", " hexText", "octString"], "hex": ["ip", "h", "shape", "sync", "hello", "alpha", "bit", "xxxxxxxx", "form", "ctr", "character", "cube", "nexus", "id", "ex", "sex", "cf", "xf", "wh", "sum", "exp", "http", "num", "rh", "hess", "buff", "pack", "digit", "cross", "closure", "raw", "lit", "str", "pex", "x", "iter", "oct", "brew", "temp", "alph", "rex", "quad", "char", "text", "he", "coord", "xa", "utf", "hash", " Hex", "cmp", "shift", "kh", "escape", "length"]}}
{"id1": "16063533", "id2": "742465", "code1": "    public static byte[] encrypt(String x) throws Exception {\n        java.security.MessageDigest d = null;\n        d = java.security.MessageDigest.getInstance(\"SHA-1\");\n        d.reset();\n        d.update(x.getBytes());\n        return d.digest();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"encrypt": ["deccrypt", "enipher", "Enccrypt", "Encrypt", "enccrypt", "decrypt", "encipher", "encrypted", "Encipher", "decrypted", "enrypted", "enrypt", "decipher", "Encrypted"], "x": ["xes", "xy", "m", "p", "tx", "xp", "xxxxxxxx", "crypt", "s", "xs", "e", "rx", "ex", "X", "es", "t", "code", "content", "message", "xml", "z", "f", "xi", "xxx", "data", "rex", "xxxx", "y", "b", "xx", "v", "text", "fx", "string", "xa", "hex"], "d": ["db", "sd", "m", "de", "dig", "p", "ed", "rd", "dad", "i", "fd", "mad", "dict", "ad", "e", "id", "pd", "dom", "dx", "t", "md", "cd", "od", "dc", "D", "dt", "ds", "dh", "gd", "bd", "f", "o", "data", "u", "b", "nd", "di", "ded", "ade", "vd", "and", "ld", "da", "dd", " dd", " D"]}}
{"id1": "22879400", "id2": "8588992", "code1": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "code2": "    public ActionForward perform(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        String status = null;\n        HttpSession session = request.getSession();\n        ReportingBean reportingBean = null;\n        NewConceptBean conceptBean = null;\n        String conceptName = null;\n        String primitive = null;\n        MessageResources errorMessages = MessageResources.getMessageResources(\"com.apelon.apps.dts.treebrowser.resources.error_messages\");\n        LogonUtilities logonUtilities = new LogonUtilities();\n        if (logonUtilities.checkSession(session, status, reportingBean, errorMessages)) {\n            reportingBean = (ReportingBean) session.getAttribute(\"reportingBean\");\n            if ((reportingBean.getMessageHtml().indexOf(\"Classify\")) == -1) {\n                reportingBean.setReportingHtml(\"\");\n            }\n            conceptBean = (NewConceptBean) session.getAttribute(\"newConceptEntity\");\n            conceptName = request.getParameter(\"conceptName\");\n            primitive = request.getParameter(\"primitive\");\n            if (primitive == null) {\n                primitive = \"false\";\n            }\n            conceptBean.setConceptName(conceptName);\n            conceptBean.setPrimitive(primitive);\n            String namespace = conceptBean.getConceptNamespace();\n            if (namespace == null) {\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_3\"));\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n                return (mapping.findForward(status));\n            }\n            String[] roleMods = request.getParameterValues(\"some_or_all\");\n            String[] roleGrps = request.getParameterValues(\"role_group\");\n            Vector roles = conceptBean.getRoles();\n            RoleBean[] roleCons = new RoleBean[roles.size()];\n            roles.copyInto(roleCons);\n            if (roleMods != null && roleGrps != null && roleCons != null) {\n                if (roleCons.length == roleMods.length && roleCons.length == roleGrps.length) {\n                    for (int i = 0; i < roleCons.length; i++) {\n                        roleCons[i].setSomeOrAll(roleMods[i]);\n                        roleCons[i].setRoleGroup(roleGrps[i]);\n                    }\n                }\n            }\n            session.setAttribute(\"newConceptEntity\", conceptBean);\n            NewConceptXMLDisplayBean xmlBean = new NewConceptXMLDisplayBean();\n            xmlBean.setNewConceptXml(conceptBean);\n            String data = BrowserUtilities.encodeUrl(\"conceptXml\") + \"=\" + BrowserUtilities.encodeUrl(xmlBean.getNewConceptXml()) + \"&\" + BrowserUtilities.encodeUrl(\"nameSpace\") + \"=\" + BrowserUtilities.encodeUrl(namespace);\n            XMLPropertyHandler configPh = new XMLPropertyHandler(\"dtsbrowserclassify.xml\");\n            Properties configProps = configPh.getProps();\n            String urlString = configProps.getProperty(\"url\");\n            URL url = new URL(urlString);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(data);\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String line;\n            StringBuffer buf = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                buf.append(line);\n            }\n            String resultXml = buf.toString();\n            wr.close();\n            rd.close();\n            ClassifiedConceptBean ccBean = new ClassifiedConceptBean();\n            ClassifyResultParser parser = new ClassifyResultParser(resultXml);\n            ResultBuilder rbuilder = new ResultBuilder();\n            rbuilder.setConceptBean(ccBean);\n            rbuilder.setParser(parser);\n            rbuilder.setNamespace(namespace);\n            try {\n                rbuilder.buildResult();\n                ccBean = rbuilder.getConceptBean();\n                ClassifiedConceptDisplayBean displayBean = new ClassifiedConceptDisplayBean();\n                displayBean.setNewConceptHtml(ccBean);\n                session.setAttribute(\"classifyResult\", ccBean);\n                session.setAttribute(\"classifyDisplayResult\", displayBean);\n                status = \"success\";\n            } catch (Exception e) {\n                Categories.dataServer().error(StackTracePrinter.getStackTrace(e));\n                reportingBean.setReportingHtml(errorMessages.getMessage(\"classify_1\") + e.getMessage());\n                session.setAttribute(\"reportingBean\", reportingBean);\n                status = \"classify_fail\";\n            }\n        }\n        return (mapping.findForward(status));\n    }\n", "label": 0, "substitutes": {"loadAllProperties": ["loadallProproperties", "loadAllproResources", "loadallProperties", "loadAllProtperties", "loadAllprops", "loadAllproperties", "loadAllProtproperties", "loadAllProproperties", "loadAllProResources", "loadallProtResources", "loadAllProps", "loadallProtperties", "loadallProResources", "loadallProtps", "loadAllProtResources", "loadAllAllproperties", "loadAllAllResources", "loadAllProtps", "loadallProtproperties", "loadAllAllperties", "loadAllAllps", "loadallProps", "loadAllproproperties"], "resourceName": ["stringInfo", "fileNAME", " resourceUrl", "resourceInfo", " resourceInfo", "stringFull", " resourceTitle", "stringName", "collectionInfo", "stringname", "attributeUrl", " resourceFull", "collectionname", "resourceTitle", "collectionName", "resourcename", "ResourceInfo", "fileFull", "fileUrl", " resourcename", "fileInfo", "collectionTitle", "fileName", "ResourceTitle", "resourceNAME", "attributename", "resourceFull", "ResourceName", "Resourcename", "resourceUrl", "attributeNAME", "attributeName", "filename", " resourceNAME"], "classLoader": ["resourcePath", "ClassRing", "ClassLoading", " classLoading", "projectLoading", "ClassPath", "classRing", "projectloader", " classloader", " classRing", "classPath", "resourceLoading", "classloader", "ClassLoader", "projectRing", "classLoading", " classPath", "Classloader", "projectLoader", "resourceloader", "resourceLoader"], "clToUse": ["classToUSE", "classtoUse", "clCoUSE", "clToUSE", "clFromUser", "clCoUse", "clTouse", "classTOUse", "clOfUSE", "clOfUser", "clToUser", "classToUser", "clFromUSE", "CLtoUSE", "CLtoUse", "CLtoUser", "clFromUse", "cltouse", "classtoUser", "cltoUsing", "CLTouse", "cltoUser", "clTOUSE", "classToUse", "CLToUse", "cltoUse", "clFromuse", "clCouse", "clCoUsing", "classTouse", "CLtouse", "classtoUSE", "clOfUse", "CLToUser", "clTOuse", "cltoUSE", "clToUsing", "clOfuse", "classTOuse", "CLtoUsing", "classTOUser", "clFromUsing", "classTOUSE", "classtouse", "CLToUSE", "clTOUse", "clTOUser", "CLToUsing"], "properties": ["items", "vals", "perties", "details", "bytes", "p", "obj", "styles", "files", "types", "les", "json", "features", "lines", "metadata", "keys", "info", "objects", "result", "property", "reports", "params", "posts", "resources", "results", "xml", "pb", "options", "classes", "tops", "this", "api", "articles", "data", "loader", "values", "groups", "settings", "prop", "pro", "parts", "ps", "books", "ports", " props", "rules", "tests", "fields"], "urls": [" urlins", "URLches", "urlworks", "logls", "logches", "sls", "Urlis", "Urlrows", "urlrows", "URLs", "Urls", "Urllines", "logs", "urlins", "URLworks", "urlis", "clls", "slls", "cls", "urlls", "slrows", "sllines", "Urlins", "Urlls", "URLlines", "logworks", " urlis", "clworks", "clches", "URLis", "urllines", "urlches", "URLins", "URLrows", "URLls", " urlls"], "url": ["r", "job", "client", "connect", "sl", "ul", "key", "class", "socket", "impl", "fl", "ls", "il", "id", "server", "conn", "loc", "open", "connection", "http", "URL", "resource", "path", "cur", "ssl", "uc", "file", "f", "Url", "base", "b", "ll", "cl", "name", "l", "ur", "uri", "event", "source", "c"], "is": ["lis", "os", "ip", "in", "Is", "ils", "us", "bis", "isl", "iso", "isa", "src", "i", "ab", "s", "ois", "was", "its", "ls", "il", "id", "ci", "es", "isi", "bel", "ris", "IS", "info", "ui", "or", "iss", "ios", "ori", "isc", "nis", "out", "iris", "ais", "abs", "close", "fs", "api", "est", "serv", "err", "are", "does", "isol", "it", "ins", "ar", "internet", "as", "si", "ps", "js", "ms", "and", "uri", "act"], "con": ["client", "ca", "connect", "Conn", "rc", "cn", "syn", "init", "cons", "cr", "on", "CON", "com", "cache", "const", "coll", "bel", "conn", "open", "ann", "ran", "connection", "bc", "http", "cos", "resource", "cur", "ver", "uc", "fc", "cover", "conf", "Con", "ch", "close", "conv", "can", "pc", "co", "un", "ocon", "act", "c", "inc"]}}
{"id1": "5744493", "id2": "18748516", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doFileCopy", " doFileWrite", " doFolderWrite", " dofileProxy", "newBlockCopy", " doFolderProxy", "newBlockWrite", " doBlockcopy", "newFileCopy", " doFilecopy", "newFilecopy", "newBlockProxy", "newFileWrite", " doFolderCopy", " doBlockWrite", " doFileProxy", " doBlockCopy", " dofileCopy", " dofileWrite", " doBlockProxy", "newFileProxy", " doFoldercopy", " dofilecopy", "newBlockcopy"], "in": ["image", "m", "buffer", "pin", "query", "inn", "isin", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "file", "part", "min", "url", "base", "login", "data", "err", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "buffer", "off", "output", "socket", "pre", "default", "user", "write", "copy", "ex", "page", "server", "cache", "conn", "source", "target", "connection", "ext", "resource", "io", "file", "part", "dot", "o", "prefix", "base", "exec", "temp", "b", "v", "name", "again", "string", "point", "outs", "external", "OUT"], "inChannel": [" inClient", "outStream", "inClient", "inputChannel", " inchannel", "inchannel", "INStream", "INChan", "outchannel", "outChan", "binSocket", "binChannel", " inChan", "InStream", "INSocket", "INChannel", "InChan", "outSocket", "inChan", "inputChan", "binChan", "binStream", "INClient", " inStream", "InChannel", "inSocket", " inSocket", "InSocket", "Inchannel", "INchannel", "outClient", "inputStream", "inputSocket", "inStream"], "outChannel": [" outBuffer", "outStream", " outchannel", "intChan", "inchannel", "OutChan", "outchannel", "outChan", "OutChannel", "outButton", "intChannel", "againSocket", " outButton", "againStream", " outChan", " outStream", "againChannel", "outSocket", "inChan", " outSocket", "intchannel", "inContainer", "inSocket", "outContainer", "OutBuffer", "inButton", "outBuffer", "intButton", "inBuffer", "OutStream", "OutContainer", " outContainer", "againChan", "inStream"], "maxCount": [" maxSize", " maxLength", "MaxSize", "MaxSum", "Maxcount", "maxSize", "blockcount", "maxLength", "MaxCount", "axcount", "maxSum", " maxcount", "axLength", "maxcount", "MaxLength", "axSize", "blockSum", "blockCount", "axCount", " maxSum", "blockSize"], "size": ["position", "bytes", "shape", "max", "ize", "p", "n", "capacity", "fee", "transfer", "sized", "limit", "address", "loc", "seek", "sum", "time", "send", "count", "available", "len", "start", "en", "min", "end", "unit", "mode", "scale", "data", "Size", "type", "range", "cap", "offset", "width", "volume", "name", "small", "speed", "empty", "shift", "flush", "SIZE", "length"], "pos": ["position", "os", "p", "obj", "off", "block", "i", "slice", "po", "id", "limit", "port", "address", "val", "open", "loc", "diff", "pointer", "cos", "index", "ref", "pose", "count", "POS", "part", "len", "start", "iter", "min", "o", "unit", "base", "pass", "no", "data", "rel", " position", "offset", "spec", "Pos", "point", "push", "slot", "pid", "neg", "pt", "length"]}}
{"id1": "13012591", "id2": "15202804", "code1": "    protected String getPasswordHash(String password) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            log.error(\"MD5 algorithm not found\", e);\n            throw new ServiceException(e);\n        }\n        md.update(password.getBytes());\n        byte[] hash = md.digest();\n        StringBuffer buf = new StringBuffer();\n        for (int i = 0; i < hash.length; i++) {\n            buf.append(Integer.toHexString(hash[i] & 0xff));\n        }\n        return buf.toString();\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getPasswordHash": ["getStringSecret", " getpasswordHash", " getPasswordhash", "getpasswordSum", "getPasswordSecret", " getPasswordSecret", " getpasswordhash", "getPasswordhash", "getpasswordhash", "getHashhash", "getHashHash", "getStringhash", "getpasswordSecret", "getStringHash", "getHashSum", " getpasswordSecret", " getpasswordSum", "getHashSecret", "getStringSum", "getPasswordSum", "getpasswordHash", " getPasswordSum"], "password": ["account", "buffer", "words", "p", "email", "crypt", "key", "pattern", "user", "input", "attribute", "sword", "cache", "phrase", "address", "padding", "Password", "code", "content", "array", "path", "message", "word", "wd", "config", "prefix", "pass", "security", "confirmed", "data", "token", "secret", "database", "number", "text", " passwords", "name", "auth", "string", "source", "PASS", "username"], "md": ["mm", "mac", "mo", "db", "m", "amp", "dig", "map", "ad", "pkg", "mu", "pd", "metadata", "arm", "ma", "dr", "od", "dc", "alg", "bm", "mb", "cm", "amd", "nm", "gb", "dh", "mand", "bd", "gd", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "mc", "hd", "mag", "mod", "d", "material", "mage", "gm", "vd", "ms", "meta", "ld", "cmd", "mem", "dd", " MD", "hm"], "hash": ["mac", "image", "ha", "error", "match", "h", "dig", "batch", "query", "html", "ash", "block", "key", "host", "square", "map", "mask", "cache", "check", "address", "sh", "diff", "handle", "code", "sum", "array", "index", "message", "count", "Hash", "cover", "build", "row", "ashes", "bh", "url", "dot", "data", "secret", "sha", "number", "search", "total", "body", "header", "filter", "carry", "kh", "hed", "length", "hex"], "buf": ["db", "pad", "bp", "buffer", "cas", "h", "bf", "br", "ctx", "ff", "ab", "src", "tmp", "bb", "pkg", "abi", "cf", "Buffer", "sb", "home", "aux", "bc", "rb", "fb", "array", " buffer", "af", "va", "ref", "fp", "buff", "img", "box", "pb", "Buff", "bh", "bag", "book", "abs", "f", "conv", "data", "b", "cv", "v", "uf", "cap", "bin", "nb", "cb"], "i": ["r", "ai", "ip", "uli", "m", "h", "p", "j", "eni", "s", "multi", "fi", "e", "phi", "id", "mu", "ci", "abi", "gi", "t", "ui", "length", "li", "index", "ii", "io", "vi", "bi", "end", "x", "pi", "f", "o", "xi", "ti", "k", "data", "ri", "u", "b", "v", "ji", "oi", "it", "di", "l", "hi", "d", "si", "chi", "qi", "field", "uri", "I", "c"]}}
{"id1": "12349563", "id2": "22844377", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public int scrapeForIsbns(URL url) {\n        int matches = 0;\n        Pattern p = Pattern.compile(\"ISBN-10:</strong>\\\\s*(\\\\w{10})\");\n        Matcher m;\n        for (int i = 0; i < RETRIES; i++) {\n            try {\n                InputStream in = url.openStream();\n                BufferedReader br = new BufferedReader(new InputStreamReader(in));\n                String str;\n                while ((str = br.readLine()) != null) {\n                    m = p.matcher(str);\n                    while (m.find()) {\n                        matches++;\n                        outputIsbns.put(m.group(1));\n                        logger.debug(\"Got ISBN: \" + m.group(1));\n                    }\n                }\n                break;\n            } catch (ConnectException e) {\n                logger.warn(\"Connection attempt \" + i + \" failed, trying again. Max retries: \" + RETRIES);\n                try {\n                    Thread.sleep(5000);\n                } catch (InterruptedException e1) {\n                }\n            } catch (IOException e) {\n                logger.error(\"Error reading URL stream\", e);\n            } catch (InterruptedException e) {\n                logger.error(\"Interrupted while calling put(Object E)\", e);\n            }\n        }\n        return matches;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceExits", " fileexistence", " resourceexits", " fileExits", " resourceCompists", " resourceexes", " fileExists", " fileExes", " resourceexistence", " resourceAbsits", " fileexes", " resourceExistence", " resourceAbses", " resourceAbsistence", " fileExistence", " resourceexists", " fileexists", " resourceCompits", " resourceCompistence", " resourceCompes", " fileexits", " resourceExes", " resourceAbsists"], "location": ["position", "image", "localhost", "shape", "host", "object", "layout", "layer", "reference", "route", "directory", "server", "address", "home", "loc", "info", "target", "connection", "pointer", "content", "path", "resource", "response", "region", "message", "operation", "description", "file", "Location", "area", "base", "data", "type", "LOC", "local", "collection", "provided", "language", "name", "node", "remote", "href", "string", "point", "folder", "uri", "source", "filename", "length"], "url": ["r", "blog", "image", "sl", "obj", "i", "host", "impl", "user", "fl", "www", "page", "server", "address", "open", "loc", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "build", "f", "Url", "lib", "api", "base", "zip", "b", "ll", "l", "string", "web", "uri", "source", "config", "c"], "cxn": ["cdsg", "cexns", "crexp", " cxcon", "Cxns", "Cxn", "cxne", " crexn", "crexg", "cxns", "cxp", "Cuxne", " cxp", "cexg", "Cxp", "cexn", "crexn", "cuxn", "cxxn", "Cxne", "cdsn", "cxxns", "cexcon", "cexp", "Cuxns", "cexne", "cdsp", "Cuxn", "cxcon", " crexp", " crexcon", "cxxne", "cxg", "cuxp", " crexg", " cxg", "cdscon", "cuxns", "cxxp", "cuxne", "Cuxp", "crexcon"], "is": ["lis", "next", "get", "os", "in", "ip", "ai", "Is", "us", "bis", "iso", "isl", "stream", "isa", "src", "i", "oss", "bs", "s", "app", "init", "ois", "was", "its", "id", "ens", "es", "isi", "ris", "IS", "info", "ui", "or", "iss", "http", "ios", "isc", "ori", "nis", "has", "cos", "ob", "ir", "out", "iris", "ais", "abs", "x", "close", "fs", "api", "does", "im", "it", "ar", "internet", "as", "js", "ms", "web", "cms", "uri"], "byteBuffer": ["ByteArray", "bitBuffer", "byteLength", " byteBB", "bitBuff", "bitBB", "ByteBB", "byteArray", "byteBB", " byteArray", "bitLength", " byteLength", "ByteLength", "ByteBuffer", "ByteBuff", " byteBuff", "byteBuff", "bitArray"]}}
{"id1": "19335986", "id2": "9109613", "code1": "    public void uncaughtException(final Thread t, final Throwable e) {\n        final Display display = Display.getCurrent();\n        final Shell shell = new Shell(display);\n        final MessageBox message = new MessageBox(shell, SWT.OK | SWT.CANCEL | SWT.ICON_ERROR);\n        message.setText(\"Hawkscope Error\");\n        message.setMessage(e.getMessage() + \"\\nSubmit Hawkscope Error Report to Issue Tracker?\");\n        log.error(\"Uncaught exception\", e);\n        if (message.open() == SWT.OK) {\n            IOUtils.copyToClipboard(Version.getBugReport(e));\n            try {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry?comment=\" + URLEncoder.encode(\"Please paste the Hawkscope Error \" + \"Report here. It's currently copied to your \" + \"clipboard. Thank you for your support!\", Constants.ENCODING));\n            } catch (final Exception e1) {\n                Program.launch(Constants.HAWKSCOPE_URL_ROOT + \"issues/entry\");\n            }\n        }\n        shell.dispose();\n    }\n", "code2": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"uncaughtException": ["uncachedexc", "unchandledException", "uncaughtEvent", "Caughtexc", "CatchedEvent", "unchandledEvent", "uncatchedEvent", "CaughtEvent", "uncaughtexc", "uncatchedException", "CatchedException", "Catchedexc", "uncachedException", "unchandledexc", "CaughtException", "uncatchedexc", "uncachedEvent"], "t": ["r", "T", "m", "p", "ed", "tx", "n", "tree", "g", " td", "s", "title", "ty", "let", "out", "f", "type", "w", "it", "l", " T", "ing", "d", "te", "tr", "c", "ts"], "e": ["r", "error", "ne", "ace", "eu", "m", "de", "j", "p", "ed", "oe", "ie", "element", "i", "ce", "s", "el", "ee", "enter", "environment", "es", "Exception", "example", "fe", "diff", "code", "be", "se", "esi", "E", "exc", "en", "ev", "f", "ception", "ge", "o", "eb", "data", "err", "pe", "er", "ep", "ele", "me", "d", "ae", "event", "c", "ec"], "display": ["image", "process", "position", "de", "design", "p", "console", "summary", "profile", "host", "view", "object", "app", "layout", "default", "page", "monitor", "fe", "content", "container", "report", "show", "hide", "screen", "scroll", "description", "dis", "this", "panel", "platform", "status", "me", "style", "d", "Display", "body", "window", "play", "config"], "shell": ["image", "echo", "kernel", "process", "clone", "m", "h", "buffer", "console", "tool", "host", "help", "el", "app", "copy", "environment", "cli", "bash", " Shell", "sb", "server", "sh", "child", "container", "xml", "gui", "sym", "tools", "poll", "mail", "hell", "Shell", "exec", "system", "log", "b", "live", "cl", "status", "l", "ml", "sound", "math", "body", "loop", "lock", "machine", "launch"], "message": ["request", "image", "error", "m", "buffer", "email", "mess", "flash", "console", "msg", "essage", " exception", "queue", "summary", "object", "view", "management", "output", " messenger", "copy", "page", "meter", "monitor", "server", "address", "result", "media", "content", "response", "report", "Message", "xml", "translation", "description", "value", "mail", "model", "update", "data", "log", "status", "application", "document", "member", "body", "header", "event"], "e1": ["E1", "e2", " e2", "exc8", "e3", "E8", "E2", "exc3", "exc1", " e8", " e3", "exc2", "E3", "e8"]}}
{"id1": "3958807", "id2": "20735941", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    protected File getFile() throws IOException {\n        File home = new File(System.getProperty(\"user.dir\"));\n        String fileName = String.format(\"%s.txt\", getFilePrefix());\n        File file = new File(home, fileName);\n        if (file.exists()) {\n            return file;\n        } else {\n            URL url = LocalNameGenerator.class.getResource(\"/\" + fileName);\n            if (url == null) {\n                throw new IllegalStateException(String.format(\"Cannot find resource at %s\", fileName));\n            } else {\n                InputStream in = url.openStream();\n                try {\n                    BufferedOutputStream out = new BufferedOutputStream(new FileOutputStream(file));\n                    try {\n                        IOUtils.copy(in, out);\n                    } finally {\n                        out.close();\n                    }\n                } finally {\n                    in.close();\n                }\n                return file;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBbinaryInput", "loadFinaryInput", "loadFbinaryFile", "loadBbinaryFile", "loadBinaryInput", "loadFbinaryInput", "loadBInputInput", "loadBatchInput", "loadBinaryFile", "loadBbinaryStream", "loadFinaryFile", "loadBatchStream", "loadFinaryContent", "loadBInputFile", "loadFbinaryContent", "loadBatchFile", "loadBInputStream", "loadBinaryContent", "loadBbinaryContent", "loadFbinaryStream", "loadFinaryStream", "loadBInputContent", "loadBatchContent"], "streamName": [" streamPath", "streamKey", "resourcePath", "channelKey", "channelName", "fileType", "StreamPath", "streamname", " streamType", "resourcename", "streamType", "resourceType", "fileKey", "fileName", "resourceName", "StreamName", "filePath", " streamname", "channelPath", " streamKey", "streamPath", "Streamname", "filename"], "streamToLoad": ["objectTORead", "objectToUpload", "streamTOUse", "streamWillAdd", "streamtoRead", "streamWithAdd", "streamtoAdd", " streamtoAdd", "streamWillUpload", "streamtoUse", "streamToUse", " streamtoRead", "streamWillRead", " streamToUse", "streamWithLoad", " streamtoLoad", "streamTOLoad", "objectToRead", "channelToload", "channeltoLoad", "streamToRead", "channelToAdd", "streamtoload", "channeltoload", "objectTOUpload", " streamToAdd", "channelToLoad", "streamTOAdd", "streamWillUse", "objectTOUse", "streamWillLoad", "streamtoUpload", "streamWithUse", "streamToload", "streamToUpload", " streamtoUse", "streamWithRead", "streamTOload", "streamTOUpload", "objectToUse", "objectTOLoad", "streamToAdd", "objectToLoad", " streamToRead", "channeltoAdd", "streamtoLoad", "streamTORead"], "sz": ["ssz", " szi", "szes", " szip", "sszes", "wszip", "psz", "szip", "sze", "psze", "siz", "ssiz", "wszi", "szi", " sze", "imsze", "ssze", "wsz", "imsiz", " szes", "pszip", "imsz", "wsze", "pszi", " siz", "imszes"], "req": ["request", "r", "fr", "client", "progress", "require", "ok", "obj", "ctx", "src", "q", "def", "input", "pkg", "rx", "conn", "http", "rss", "response", "report", "ref", "rh", "rr", "proc", "Resp", "rec", "qt", "rw", "f", "serv", "exec", "err", "download", "requ", "sem", "inv", "Request", "res", "respond", "wx", "cb"], "resp": ["request", "client", "obj", "ctx", "html", "output", "reply", "par", "bb", "e", "page", "circ", "server", "conn", "esp", "http", "rss", "response", "ref", "report", "rh", "rup", "fp", "ret", "df", "Response", "Resp", "rec", "proc", "rev", "serv", "exec", "rep", "zip", "wb", "api", "err", "jp", "download", "rem", "rel", "wp", "comm", "res", "remote", "respond", "prev", "wx", "body", "cook", "cmp", "re", "sp"], "out": ["Out", "auto", "os", "in", "buffer", "p", "i", "output", "object", "s", "tmp", "default", "copy", "aos", "cache", "conn", "boot", "response", "io", "op", "pool", "img", "fn", "buf", "o", "null", "serv", "base", "zip", "binary", "data", "exec", "b", "log", "co", "ops", "bin", "res", "again", "outs", "gz", "ws", "OUT"], "bos": ["os", "lo", "mis", "flo", "zos", "oos", "bis", "oops", "bs", "zb", "bott", "bb", "lol", "bo", "abi", "ros", "cro", "aos", "bare", "los", "boot", "bc", "obs", "ubis", "ios", "bps", "bes", "ob", "osa", "bro", "ko", "bas", "bi", "bh", "biz", "osi", "zo", "pins", "las", "bot", "fits", "bin", "obb", "obos", "obo", "rob"]}}
{"id1": "1097146", "id2": "8320469", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static String md5(String text) {\n        String encrypted = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(text.getBytes());\n            encrypted = hex(md.digest());\n        } catch (NoSuchAlgorithmException nsaEx) {\n        }\n        return encrypted;\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentdigests", "getMessageEncester", "getMessagedigests", "getContentDigests", "getMessagedigifier", "getMessageDigifier", "getMessageDigests", "getMessageSignifier", "getMessageEncifier", "getMessagedigester", "getMessageEncest", "getMessageSignester", "getMessageEncests", "getContentdigest", "getContentDigester", "getMessagedigest", "getMessageDigester", "getContentdigifier", "getMessageSignests", "getContentdigester", "getContentDigest", "getContentDigifier", "getMessageSignest"], "input": ["request", "image", "in", "buffer", "self", "amp", "accept", "element", "argument", "stream", "i", "output", "form", "object", "context", "instance", "parse", "parent", "address", "plus", "inf", "state", "target", "content", "inner", "submit", "audio", "message", "array", "container", "xml", "raw", "out", "now", "str", "binary", "this", "null", "definition", "model", "data", "temp", "type", "Input", "text", "document", "password", "reader", "string", "list", "empty", "source", "config"], "md": ["mac", "mm", "mo", "m", "bf", "mad", "mn", "metadata", "M", "um", "ma", "dr", "od", "dc", "bm", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "di", "me", "mc", "vd", "mag", "rpm", "d", "mod", "ms", "meta", "am", "cmd", "dd", " MD"], "bytes": ["vals", "words", "ipes", "ies", "files", "les", "s", "bs", "units", "strings", "its", "odes", "es", "address", "lines", "keys", "seconds", "tes", "bps", "Bytes", "codes", "gb", "pieces", "classes", "bits", "binary", "pages", "null", "base", "data", "blocks", "b", "values", "groups", "rows", "bles", "body", "string", "parts", "outs"]}}
{"id1": "4398382", "id2": "18202328", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 1, "substitutes": {"digest": [" digested", "mdester", "encress", "Digse", "generest", "Digress", "digress", "mdest", " digests", "generests", "digests", "digse", "mdests", "Digest", "Digester", " digester", " digse", "digester", "encse", " digress", "encest", "generester", "mdested", "encester", "digested", "generested"], "algorithm": ["malgebra", "algebra", "aroding", "algo", "Alignment", "malignment", "challgebra", "aloding", "alenge", "Algebra", " alenge", "Algorithm", " algo", "challgo", "arignment", "argorithm", "Alenge", "Aloding", " algebra", "alignment", "argebra", "maloding", "malgorithm", "challgorithm", "Algo", "challenge"], "text": ["image", "buffer", "bytes", "output", "pattern", "object", "feed", "username", "Text", "sequence", "input", "attribute", "address", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "word", "value", "str", "url", "letter", "data", "struct", "token", "test", "secret", "name", "password", "string", "source", "config", "length", "txt"], "mDigest": ["mPostested", "mCodener", "MDgest", "mdigested", "mDEST", "mDester", " mDigester", " mDigast", "mCodest", "mDenge", "mDgest", " mGest", "amDigener", "mSignge", "MDest", "mdigester", "mDiger", "mDesignest", "mdigest", "mPostest", "mSignast", "mdiggest", "mGge", "mSignester", "mDesignester", "mSignEST", "mGester", "MDiger", "mDest", "amDigested", "mDigested", "amPostener", "amDigest", "mDigener", "mEncester", "MDigEST", "mCodested", " mGge", " mDigge", "mGast", "mSignest", "mDer", "mSignenge", "mDigEST", "MDester", "amPostested", " mGast", "mDigenge", "MDiggest", "MDigest", " mGester", "MDigenge", "mDigge", "amPostest", "mdigener", "mEncest", "mDiggest", "mGest", "mDigester", "mdiger", "mDesigner", "mPostener", "MDigester", "mDigast", "mDesigngest", "mEncast", "mEncge", "MDer"], "raw": ["image", "clean", "buffer", "original", "RAW", "full", "output", "default", "feed", "input", "instance", "internal", "unsigned", "serial", "json", "result", "array", "content", "response", "Raw", "message", "orig", "container", "row", "binary", "buf", "enc", "none", "null", "data", "partial", "wrap", "source", "initial", "hex"], "encoder": ["Encoded", " encoded", "enoder", "deccode", "enode", "enoding", "Encode", "Encoder", "encoding", "ecoded", "ecode", "encoded", "ecoder", "decoder", "enccode", "decode", "ecoding", "Encoding", "encode", "decoding", " encoding", " encode", "eccode"]}}
{"id1": "6304373", "id2": "5676111", "code1": "    public static String uploadOrDeleteMediaOrTemplates(String action, String object, String numElements, HttpServletRequest req, HttpSession session) {\n        FTPClient ftp = new FTPClient();\n        CofaxToolsUser user = (CofaxToolsUser) session.getAttribute(\"user\");\n        StringBuffer links = new StringBuffer();\n        StringBuffer folders = new StringBuffer();\n        String folder = \"\";\n        String server = \"\";\n        String login = \"\";\n        String password = \"\";\n        String fileTransferFolder = CofaxToolsServlet.fileTransferFolder;\n        String liveFolder = \"\";\n        ArrayList servers = new ArrayList();\n        StringBuffer message = new StringBuffer();\n        message.append(\"Status:<BR>\");\n        if (action.equals(\"Upload\")) {\n            server = (String) user.workingPubConfigElementsHash.get(\"TESTFTPSERVER\");\n            login = (String) user.workingPubConfigElementsHash.get(\"TESTFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"TESTFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                folder = (String) user.workingPubConfigElementsHash.get(\"TESTTEMPLATEFOLDER\");\n            }\n        }\n        if (action.equals(\"Delete\")) {\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                folder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n        }\n        ArrayList al = new ArrayList();\n        int numElement = Integer.parseInt(numElements);\n        for (int i = 0; i < numElement; i++) {\n            String key = String.valueOf(i);\n            String file = req.getParameter(key);\n            if (file != null) {\n                al.add(file);\n            }\n        }\n        if (action.equals(\"Upload\")) {\n            try {\n                int reply;\n                ftp.connect(server);\n                CofaxToolsUtil.log(ftp.getReplyString());\n                reply = ftp.getReplyCode();\n                if (!FTPReply.isPositiveCompletion(reply)) {\n                    ftp.disconnect();\n                    return (\"FTP server refused connection.\");\n                } else {\n                    ftp.login(login, password);\n                }\n                for (int ii = 0; ii < al.size(); ii++) {\n                    String fileName = (String) al.get(ii);\n                    String folderName = stripName(fileName);\n                    fileName = stripPath(fileName);\n                    try {\n                        ftp.changeWorkingDirectory(folderName);\n                        OutputStream output;\n                        output = new FileOutputStream(fileTransferFolder + fileName);\n                        ftp.retrieveFile(fileName, output);\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates retrieving file: \" + ftp.getReplyString());\n                        message.append(\"Retrieving file \" + fileName + \" to local disk.<BR>\");\n                        output.close();\n                    } catch (java.io.IOException e) {\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot write file\" + e);\n                    }\n                }\n                ftp.logout();\n                ftp.disconnect();\n            } catch (IOException e) {\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                return (\"Could not connect to server: \" + e);\n            }\n            login = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPLOGIN\");\n            password = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPPASSWORD\");\n            if (object.equals(\"Media\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVEIMAGESFOLDER\");\n            }\n            if (object.equals(\"Templates\")) {\n                server = (String) user.workingPubConfigElementsHash.get(\"LIVEFTPSERVER\");\n                liveFolder = (String) user.workingPubConfigElementsHash.get(\"LIVETEMPLATEFOLDER\");\n            }\n            servers = splitServers(server);\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: server refused connection: \" + connectServer);\n                        return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        CofaxToolsUtil.log(\"Original String \" + fileName);\n                        CofaxToolsUtil.log(\"Search for \" + folder);\n                        CofaxToolsUtil.log(\"Replace \" + liveFolder);\n                        String folderName = CofaxToolsUtil.replace(fileName, folder, liveFolder);\n                        CofaxToolsUtil.log(\"Results: \" + folderName);\n                        folderName = stripName(folderName);\n                        fileName = stripPath(fileName);\n                        try {\n                            InputStream io;\n                            io = new FileInputStream(fileTransferFolder + fileName);\n                            CofaxToolsUtil.log(\"Reading file : \" + fileTransferFolder + fileName);\n                            boolean directoryExists = ftp.changeWorkingDirectory(folderName);\n                            if (directoryExists == false) {\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates directory: \" + folderName + \" does not exist. Attempting to create.\");\n                                message.append(\"Directory: \" + folderName + \" does not exist. Attempting to create.<BR>\");\n                                boolean canCreatDir = ftp.makeDirectory(folderName);\n                                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + canCreatDir);\n                                message.append(\"Results: \" + canCreatDir + \"<BR>\");\n                            }\n                            boolean isStored = ftp.storeFile(fileName, io);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates storing file: \" + fileName + \" in directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + isStored + \" : \" + ftp.getReplyString());\n                            message.append(\"Storing file \" + fileName + \"<BR> to location \" + folderName + \"<BR> on server \" + connectServer + \".<BR>\");\n                        } catch (java.io.IOException e) {\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                            return (\"Cannot upload file\" + fileName + \"<BR>To path: \" + folderName + \"<BR>On server \" + connectServer);\n                        }\n                    }\n                    ftp.logout();\n                    ftp.disconnect();\n                    message.append(\"Success<BR><BR>\");\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cSServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                System.out.println(\"getting cache servers: \" + cSServers);\n                ArrayList cServers = splitServers(cSServers);\n                for (int iiii = 0; iiii < cServers.size(); iiii++) {\n                    String thisClearCacheServer = (String) cServers.get(iiii);\n                    try {\n                        String connectServer = (String) cServers.get(iiii);\n                        for (int iiiii = 0; iiiii < al.size(); iiiii++) {\n                            String thisFilePath = (String) al.get(iiiii);\n                            String folderNameFileName = CofaxToolsUtil.replace(thisFilePath, folder, liveFolder);\n                            String URLToClear = CofaxToolsServlet.removeTemplateCache + folderNameFileName;\n                            CofaxToolsClearCache clear = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheServer + URLToClear);\n                            clear.start();\n                            message.append(\"Clearing Cache for \" + folderNameFileName + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: could not connect to server clearing cache \" + e);\n                    }\n                }\n            }\n            for (int i = 0; i < al.size(); i++) {\n                String fileName = (String) al.get(i);\n                String folderName = stripName(fileName);\n                fileName = stripPath(fileName);\n                File file = new File(fileTransferFolder + fileName);\n                boolean delete = file.delete();\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file from local drive: \" + fileTransferFolder + fileName);\n                CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + delete);\n            }\n        }\n        servers = splitServers(server);\n        if (action.equals(\"Delete\")) {\n            for (int iii = 0; iii < servers.size(); iii++) {\n                try {\n                    int reply;\n                    String connectServer = (String) servers.get(iii);\n                    ftp.connect(connectServer);\n                    CofaxToolsUtil.log(ftp.getReplyString());\n                    reply = ftp.getReplyCode();\n                    if (!FTPReply.isPositiveCompletion(reply)) {\n                        ftp.disconnect();\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: FTP server refused connection: \" + connectServer);\n                        return (\"FTP server refused connection.\");\n                    } else {\n                        ftp.login(login, password);\n                    }\n                    for (int ii = 0; ii < al.size(); ii++) {\n                        String fileName = (String) al.get(ii);\n                        String folderName = stripName(fileName);\n                        fileName = stripPath(fileName);\n                        try {\n                            ftp.changeWorkingDirectory(folderName);\n                            ftp.deleteFile(fileName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates deleting file: \" + fileName + \" from directory: \" + folderName);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates on server : \" + connectServer);\n                            CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates results: \" + ftp.getReplyString());\n                            message.append(\"Deleting file \" + fileName + \"<BR>\");\n                            message.append(\"from folder \" + folderName + \"<BR>\");\n                            message.append(\"on server \" + connectServer + \"<BR>\");\n                        } catch (java.io.IOException e) {\n                            return (\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: cannot delete file\" + fileName);\n                        }\n                    }\n                    message.append(\"Success<BR><BR>\");\n                    ftp.logout();\n                    ftp.disconnect();\n                } catch (IOException e) {\n                    CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR: Could not connect to server: \" + e);\n                    return (\"Could not connect to server: \" + e);\n                }\n            }\n            if (object.equals(\"Templates\")) {\n                String cISServers = (String) user.workingPubConfigElementsHash.get(\"CACHESERVERS\");\n                ArrayList cIServers = splitServers(cISServers);\n                for (int iiiiii = 0; iiiiii < cIServers.size(); iiiiii++) {\n                    String thisClearCacheIServer = (String) cIServers.get(iiiiii);\n                    try {\n                        String connectServer = (String) cIServers.get(iiiiii);\n                        for (int iiiiiii = 0; iiiiiii < al.size(); iiiiiii++) {\n                            String thisFilePathI = (String) al.get(iiiiiii);\n                            String URLToClearI = CofaxToolsServlet.removeTemplateCache + thisFilePathI;\n                            CofaxToolsClearCache clearI = new CofaxToolsClearCache(\"HTTP://\" + thisClearCacheIServer + URLToClearI);\n                            clearI.start();\n                            message.append(\"Clearing Cache for \" + thisFilePathI + \"<BR>\");\n                            message.append(\"on server \" + thisClearCacheIServer + \"<BR>Success<BR><BR>\");\n                        }\n                    } catch (Exception e) {\n                        CofaxToolsUtil.log(\"CofaxToolsFTP uploadOrDeleteMediaOrTemplates ERROR clearing cache \" + e);\n                    }\n                }\n            }\n        }\n        return (message.toString());\n    }\n", "code2": "    public void get() {\n        try {\n            int cnt;\n            URL url = new URL(urlStr);\n            URLConnection conn = url.openConnection();\n            conn.setDoInput(true);\n            conn.setDoOutput(false);\n            InputStream is = conn.getInputStream();\n            String filename = new File(url.getFile()).getName();\n            FileOutputStream fos = new FileOutputStream(dstDir + File.separator + filename);\n            byte[] buffer = new byte[4096];\n            while ((cnt = is.read(buffer, 0, buffer.length)) != -1) fos.write(buffer, 0, cnt);\n            fos.close();\n            is.close();\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"uploadOrDeleteMediaOrTemplates": ["uploadOrDeleteMediaOrMempl", "uploadOrDeleteMediaOrTempl", "uploadOrDeleteMediaOrTemplateFiles", "uploadOrDeleteMediaOrTemplateporary", "uploadOrDeleteMediaOrtemporary", "uploadOrDeleteMediaOrTemFiles", "uploadOrDeleteMediaOrTemplateplates", "uploadOrDeleteMediaOrTemplatepl", "uploadOrDeleteMediaOrMemFiles", "uploadOrDeleteMediaOrtemFiles", "uploadOrDeleteMediaOrtemplates", "uploadOrDeleteMediaOrTemporary", "uploadOrDeleteMediaOrMemplates", "uploadOrDeleteMediaOrMemporary", "uploadOrDeleteMediaOrtempl"], "action": ["next", "error", "what", "service", "flash", "element", "flow", "view", "version", "parent", "environment", "section", "module", "state", "format", "ACTION", "resource", "ction", "operation", "change", "function", "step", "now", "part", "active", "url", "actions", "api", "type", "test", "activity", "status", "controller", "call", "method", "activation", "name", "site", "plugin", "style", "commit", "Action", "item", "lock", "act", "event", "effect"], "object": ["request", "ject", "image", "auto", "email", "service", "obj", "element", "full", "host", "class", "oid", "instance", "version", "parent", "environment", "office", "directory", "address", "objects", "group", "module", "target", "not", "resource", "zone", "thread", "function", "now", "edit", "part", "url", "letter", "o", "none", "mode", "model", "system", "subject", "article", "number", "document", "node", "project", "string", "lock", "event", "current", "self"], "numElements": [" numelement", "numGelement", "numEllements", "numelements", "numElem", "numGeodes", "numGelem", "numGelements", " numEodes", " numeodes", " numElem", "numEodes", "numEllem", "numEllement", " numelements", "numeodes", " numelem", "numelem", "numelement", "numElodes"], "req": ["next", "gr", "r", "obj", "ctx", "g", "msg", "html", "use", "load", "ro", "parent", "module", "report", "params", "xml", "conf", "resp", "mr", "util", "base", "update", "builder", "err", "log", "res", "verb", "usr"], "session": ["request", "image", "client", "h", "service", "ctx", "flash", "use", "context", "scope", "global", "instance", "sa", "cache", "Session", "state", "result", "connection", "http", "container", "response", "resource", "manager", "thread", "security", "system", "temp", "local", "token", "test", "ESSION", "subject", "document", "browser", "site", "lock", "event", "ession", "person", "shared", "sp"], "ftp": ["ttp", "ftP", "ttP", " ftcp", "FTc", " ftc", "ftcp", "FTcp", "ftc", "FTP", "ttcp", "ttc", "FTp", " ftP"], "user": ["image", "account", "db", "error", "client", "self", "match", "creator", "User", "html", "full", "author", "class", "profile", "use", "view", "USER", "comment", "used", "bug", "e", "ee", "parent", "page", "rule", "home", "per", "info", "group", "module", "result", "state", "connection", "ver", "path", "post", "mail", "url", "this", "pass", "base", "data", "type", "system", "log", "er", "users", "other", "admin", "record", "name", "auth", "browser", "by", "member", "custom", "facebook", "string", "project", "usa", "hash", "usr", "lock", "current", "person", "shared", "config", "username"], "links": ["items", "image", "details", "email", "styles", "flash", "html", "tree", "Link", "headers", "lines", "posts", "Links", "images", "results", "members", "mail", "link", "url", "pages", "actions", "base", "log", "groups", "linked", "ids", "mails", "menu"], "folders": ["anchors", "filers", "anchages", "handries", "anchers", "handers", "filors", "handages", "foldors", "filages", "anchries", "foldries", "handors", "foldages", "filries"], "folder": ["email", "level", "upload", "element", "layout", "scope", "slice", "theme", "layer", "future", "enter", "id", "directory", "archive", "picture", "address", "home", "division", "connection", "location", "region", "path", "resource", "editor", "zone", "ignore", "fold", "dir", "area", "url", "device", "letter", "zip", "flat", "license", "append", "database", "Folder", "document", "volume", "plugin", "project", "two", "network", "sample", "menu", "command", "uri", "source", "filename"], "server": ["account", "localhost", "client", "email", "service", "host", "socket", "master", "version", "slave", "enter", "page", "erver", "directory", "port", "address", "connection", "location", "inner", "resource", "ssl", "manager", "value", "peer", "url", "engine", "device", "scale", "system", "type", "database", "token", "status", "node", "Server", "site", "reader", "string", "remote", "seed", "network", "uri", "ser", "outer", "source", "filename", "username"], "login": ["blog", "account", "blank", "email", "service", "access", "pin", "label", "profile", "socket", "layout", "consumer", "basic", "picture", "cookie", "info", "group", "connection", "path", "resource", "Login", "ssl", "mail", "config", "url", "pass", "skin", "log", "database", "users", "shell", "status", "secret", "name", "auth", "site", "plugin", "string", "network", "bridge", "sudo", "lock", "journal", "machine", "filename", "username"], "password": ["timeout", "email", "access", "worker", "profile", "pattern", "ass", "username", "basic", "slave", "photo", "directory", "sword", "picture", "mask", "phrase", "cookie", "alias", "padding", "Password", "strip", "connection", "division", "word", "PASS", "manager", "pass", "security", "token", "secret", "database", " passwords", "language", "name", "auth", "volume", "plugin", "string", "column", "sudo", "device", "filename", "account"], "fileTransferFolder": ["FileTransferTheme", "fileUploadServer", "fileAccessTheme", "fileImportDirectory", "fileTransferServer", "fileUploadTheme", "fileUploadFolder", "fileTransferDirectory", "mediaTransferfolder", "fileTransferfolder", "FileTransferfolder", "mediaUploadServer", "fileTransformFolder", "FileUploadPath", "fileAccessfolder", "FileUploadfolder", "FileTransferFolder", "fileAccessFolder", "fileTransformfolder", "fileTransferTheme", "FileUploadFolder", "fileTransformTheme", "fileImportFolder", "fileAccessPath", "fileUploadDirectory", "fileTransformPath", "mediaTransferFolder", "FileUploadTheme", "FileTransferPath", "mediaTransferServer", "fileUploadPath", "fileUploadfolder", "fileImportServer", "mediaTransferDirectory", "fileImportfolder", "mediaUploadfolder", "mediaUploadFolder", "mediaUploadDirectory", "fileTransferPath"], "liveFolder": ["Livefolder", " liveDirectory", "livefolder", "LiveLocation", "liveLocation", "Previewfolder", "PreviewFolder", "LiveDirectory", "LiveFolder", " liveLocation", " livefolder", "liveDirectory", "PreviewDirectory", "PreviewLocation"], "servers": ["servServer", " serServer", "serServer", "servations", "serations", "Serations", "Servers", "servls", "serls", " serls", " serations", "Serls", "servvers", "SerServer"], "message": ["request", "image", "error", "details", "buffer", "mess", "email", "flash", "element", "msg", "summary", "page", "address", "module", "content", "array", "response", "resource", "path", " messages", "Message", "manager", "description", "mail", "url", "update", "log", "status", "application", "document", "member", "body", "string", "header", "menu"]}}
{"id1": "1156851", "id2": "15018553", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"runWeb": ["processSite", "processWs", "runningWs", " runweb", "runningWeb", "runweb", "runningSite", "processWeb", " runWs", "runSite", "runWs", " runSite", "runningweb", "processweb"], "beginURL": ["Beginurl", "endURI", "startELF", "untilURI", "useUR", "BeginURI", "BeginURL", "endUrl", "beginELF", "BeginELF", "startUrl", " beginUrl", "beginSSL", "endUR", "untilURL", "beginUR", "beginUrl", "BeginSSL", " beginSSL", "untilurl", "BeginUR", "useUrl", "endurl", "startURL", "useURL", "beginURI", "endURL", "untilUrl", "startSSL", "BeginUrl", "beginurl", " beginELF", "useURI"], "contextRoot": ["conceptBase", "contextGround", " contextRO", "eventroot", "resourcePath", "ContextRO", "eventRoot", " contextHome", "ContextGround", "ContextHome", "ContextBase", " contextPath", " contextBase", " contextGround", "serviceRO", "resourceroot", "contextRO", "resourceRoot", "contextHome", "ContextPath", "serviceRoot", "conceptRoot", "conceptHome", "ContextRoot", "conceptroot", "serviceroot", "contextBase", "Contextroot", "contextroot", "serviceGround", "contextPath", " contextroot"], "pageURI": ["PageID", "endURI", "enduri", "PageUR", "pageuri", " pageuri", "siteURL", "pageURL", " pageURL", "endUR", "pageID", "PageURL", " pageUR", "endURL", " pageID", "pageUR", "PageURI", "Pageuri", "siteUR", "siteID", "siteURI"], "vtURLs": ["rtURLls", "vtGETls", "vtRLS", "vtURLi", "vtURLParts", "tvDownloades", "vtUrlParts", "vtURLobs", "VTURls", "vtUrllines", "vtURLS", "VTURs", "htURs", "vtURLlines", "vtGETs", "vtIPs", "tvURLS", "tvDownloadS", "VTURLs", "vtURs", "htURParts", "vtStreamobs", "vtStreams", "vtDownloades", "vtRLes", "rtURLS", "vtURLes", "vtGETS", "vtDownloadS", "vtURLls", "htURls", "htURobs", "htURLParts", "vturli", "vturlls", "rtURls", "VTURLls", "VTURlines", "VTURi", "vtUrlobs", "VTURLi", "vtURobs", "htURLobs", "vtDownloads", "vtIPS", "rtURLs", "vturls", "vtStreamls", "vtURParts", "vtRLs", "tvDownloads", "tvURLs", "htURLs", "rtURs", "vtURlines", "vtStreamParts", "vtIPes", "vtURls", "VTURLlines", "htURLls", "vtURS", "vtUrlS", "vtUrlls", "vtUrli", "vtURi", "tvURLes", "rtURS", "vturllines", "vtUrls"], "vtRobots": ["vtProops", "VTRobugs", "vtLegibraries", "vtGrorots", "VTProops", "htrobOTS", "VTGroibraries", "vtrobops", "vtBlOTS", "vtPros", "vtGroibraries", "VTRobots", "vtProots", "vtRobot", "vtBOTS", "vtBots", "VTPros", "vtBlots", "vtRobOTS", "vtLogOTS", "vtRobops", "vtPlugs", "VTRobibraries", "vtPlrots", "vtrobOTS", "vtBot", "VTRobs", "htrobops", "vtBlops", "vtLegots", "vtGrougs", "VTRobOTS", "VTGrorots", "vtRobs", "vtLogs", "vtPlibraries", "vtLogots", "VTProOTS", "vtLegugs", "VTProots", "vtLogops", "vtRobrots", "vtRobibraries", "vtProOTS", "vtBlot", "htRobots", "vtBs", "htRobot", "VTGrougs", "vtLegrots", "htrobot", "vtBops", "htrobots", "VTRobops", "vtrobots", "VTGroots", "VTRobrots", "vtrobot", "htRobOTS", "vtGroots", "htRobops", "vtRobugs", "vtPlots"], "indexer": ["indexe", "checkers", " indexers", " indexER", "checkER", "IndexER", "Indexer", " indexed", "checkeer", "findReader", " indexeer", "indexers", "checker", " indexe", "fixed", "indexed", " indexReader", "indexeer", "Indexers", "fixer", "Indexeer", "finded", "fixe", "finder", "finde", "indexReader", "fixReader", "indexER"], "indexDoc": ["documentPage", "indexDom", "officePage", "Indexdoc", "indexdoc", "documentDom", "documentdoc", "documentDoc", "officeDoc", "IndexPage", "officeDom", "officedoc", "indexPage", "IndexDoc", "IndexDom"], "sxURL": ["sxDB", "sxeURL", "sfxURI", "sxiDOM", "sxcELF", "sxeTL", "dsxeURL", " sexURL", " sxcSSL", "sxxurl", " sxcUrl", "SxUrl", "lxUR", "pxUrl", "sxiUR", "SxUR", "sxELF", "sXDB", "sxcUrl", " sexurl", "lXUR", "swwLink", " sxcURI", "sfxUR", "snexURL", "SexURL", " sxURI", "snexurl", "sexURL", "snexUR", "SxURL", "sxtURL", "sXDOM", "sxxURI", " sxcurl", " sxDB", "sxxUR", "sxcLink", " sXURL", "sxSSL", "lxURL", "sXSSL", "sexELF", " sXurl", " sxLink", "pxcUrl", "sxURI", "sxbUR", "sxeUR", "sexDOM", "sxeurl", " sxcURL", "sxeUrl", "dsxURL", "sxcUR", "sxxURL", "sxtDB", " sexUrl", "sexUrl", "lXURL", " sxUrl", "pxcURL", "pxURL", "sXUR", "dsxUR", "dsxTL", "dsxeTL", "sxaurl", "sxLink", "sXURL", "sxiSSL", "swwURL", "sexUR", "sfxURL", "SexELF", "sxUR", "dsxeUR", "lXDOM", "sexSSL", "sxeSSL", " sxurl", "dsxeurl", "sxbURL", "swwUrl", "sxburl", "lXSSL", "swwUR", "sxaTL", " sxUR", "sxxUrl", "sxcURI", "SxELF", "sxtUR", "sxcurl", "sxturl", "pxcURI", "sxurl", " sxcUR", "lxSSL", "dsxurl", "sxUrl", "sxxDB", "sxcURL", "sxTL", "snexTL", "sxbUrl", "pxURI", "sxaUR", "sxaURL", "sxcSSL", "sXELF", "sexurl", " sXUR", "sxtUrl", " sxSSL", "sxiURL", "sfxUrl", "SexUR", "SexUrl", "sxtURI", "sxDOM", "sXurl", " sXDB", " sexUR", "sXUrl", "sfxSSL", "lxDOM"], "sxRobotURL": ["sxRooyTL", "sxRoboPath", "sxRoboyUrl", "sxRubotUR", "sxRooyURL", "sxRobotTL", "sxRobobUR", "sxRobOTPath", "sxRoboURL", "sxRobogTL", "sxRuboPath", "sxRobobTL", "sxRobOTTL", "sxRobobSSL", "sxRobooturl", "sxRobotSSL", "sxRobogURL", "sxRobootURL", "sxRoboUrl", "sxLootTL", "sxRootTL", "sxRubotURL", "sxRobotationCL", "sxRobogSSL", "sxRuboUrl", "sxRobotUR", "sxRoboUR", "sxRobOTURI", "sxRoboyURL", "sxRuboUR", "sxRobotUrl", "sxRobotationURL", "sxRubotUrl", "sxRobotationURI", "sxRobOTCL", "sxRobootTL", "sxLoobTL", "sxRubotPath", "sxRoboburl", "sxRobOTUrl", "sxRobobURI", "sxLootURL", "sxRobotURI", "sxRoboturl", "sxRobortTL", "sxRoboyTL", "sxLootSSL", "sxRooyUR", "sxRobortUR", "sxRobootSSL", "sxRobotCL", "sxRobortURL", "sxRuboURL", "sxRobogurl", "sxRobOTUR", "sxRobobCL", "sxRoboyPath", "sxLoobURL", "sxRoboyUR", "sxRobOTURL", "sxRootUR", "sxLooburl", "sxRobotationUR", "sxLooturl", "sxLoobSSL", "sxRobobURL", "sxRootURL", "sxRobotPath"], "pd": ["ppa", " md", "p", "bf", "pp", " db", " td", "PF", " pp", " pm", "pg", "bb", " dc", "CB", "Parser", " cp", "py", "md", "ht", "cd", "APD", " PD", "lp", "td", "ds", "pb", "gd", "bd", "pi", "PB", "xd", "pm", "dl", "wp", " sd", " pdf", "PD", " df", " DD", "pc", "cpp", "hd", "vd", "d", " cd", "parser", "BT", "dd", " dd"], "cb": ["db", "bp", "ca", "BBC", "ctx", "bf", " db", "cp", "ff", "fd", "func", "Callback", "bb", "handler", "CB", "cf", "sb", "cd", "bc", "rb", "fb", "dc", "kb", "ob", "buff", "cm", "gb", "fn", "fc", "pb", " rc", "bd", "eb", "callback", " CB", "b", "cv", "cpp", "obb", " cd", "cod", " bc", "cmp", "cmd", "c", " dd"], "bIndexPage": ["bindexpage", "bbSearchPage", " bQueryPage", " bIndexPages", " bIndexpage", "bQueryTable", "bindexPages", " bindexpage", "bSearchLine", "bQueryLine", " bindexLine", "bindexFile", "bSearchpage", " bSearchpage", "nbIndexPage", "bindexLine", "bindexPage", "bbIndexLine", "bShortLine", "bindexTable", "nbIndexpage", " bSearchPage", "bbSearchpage", " bIndexFile", "bSearchPage", "bLinkPage", "bShortPage", " bIndexTable", "bQueryFile", "bQueryPage", "bIndexFile", "nbLinkFile", "bLinkLine", "bShortpage", " bQueryFile", "nbLinkLine", "bLinkpage", "bSearchPages", "bIndexPages", "bIndexLine", " bindexPages", " bIndexLine", "bIndexpage", " bindexPage", "bbIndexPage", "bSearchFile", "bSearchTable", "nbIndexFile", "nbLinkpage", "nbIndexLine", "bLinkFile", "bbIndexpage", "bbSearchLine", " bSearchPages", "bLinkPages", " bQueryLine", "nbLinkPage", "bIndexTable", " bQueryTable"], "urlConn": ["httpConnection", "urlCon", "fileConnection", " urlConnect", " urlConf", " urlBuff", "urlConf", "URLBuff", "httpConn", "fileconn", "URLconn", "UrlConfig", "UrlConn", "serverCon", "fileConnect", "httpconn", "urlConnect", "URLCo", " urlConfig", "serverConnect", " urlConnection", "serverConn", " urlCon", "URLConf", "UrlConf", " urlCo", "URLConnect", "URLConfig", "serverConnection", "fileConn", "urlConfig", "urlConnection", "URLConnection", "httpCon", "httpCo", "URLConn", "urlBuff", "UrlBuff", "urlconn", "urlCo", "httpConnect"], "modDate": ["modTime", "modDat", " modTime", "MODDay", "ModTime", " modDat", "ModDay", "ModDate", "modDay", "MODTime", "MODDat", "MODDate", "ModDat", " modDay"], "bfReader": ["btRead", "bfRead", "bdreader", "bfBuffer", "BFRead", "bdReader", "bdWriter", "bdBuffer", "bbWriter", "BFFile", "btWriter", "bbBuffer", "bbRead", "bbReader", "bbreader", "bfFile", "bfreader", "BFReader", "BFWriter", "btFile", "bbFile", "btreader", "btBuffer", "btReader", "bfWriter"]}}
{"id1": "8778962", "id2": "23666867", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "8932510", "id2": "18693224", "code1": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"doPost": ["doPOST", " doPut", "DoGet", "doGet", "doPut", "DoPut", "sendPost", "sendPut", "DoPost", "sendPOST", "sendGet", " doPOST", " doGet", "DoPOST"], "request": ["next", "image", "rate", "query", "save", "parent", "enter", "attribute", "complete", "info", "http", "report", "post", "this", "re", "allow", "Request", "reader", "question", "uri", "create", "get", "client", "view", "user", "input", "message", "path", "rf", "remove", "requ", "command", "QUEST", "event", "join", "right", "writer", "self", "hello", "stream", "q", "form", "object", "context", "port", "child", "result", "url", "req", "subject", "method", "have", "frame", "remote", "head", "buffer", "queue", "instance", "server", "connection", "resource", "xml", "model", "session", "data", "type", "application", "document", "call", "project", "list", "current", "config", "condition"], "response": ["next", "image", "error", "client", "writer", "service", "stream", " Response", "host", "output", "reply", "view", "object", "respons", "server", "json", "result", "connection", "resource", "message", "report", "xml", "Response", "description", "resp", "onse", "data", "status", "application", "document", "res", "site", "respond", "re"], "is": ["lis", "ai", "ip", "in", "Is", "iri", "mis", "p", "us", "bis", "ie", "iso", "isl", "isin", "isa", "eni", "i", "bs", "ois", "was", "ib", "ci", "isi", "address", "ris", "alis", "IS", "info", "ui", "iss", "rss", "http", "ios", "ori", "isc", "nis", "ir", "out", "iris", "ini", "ais", "pi", "url", "api", "sis", "ri", "are", "isp", "it", "vs", "as", "si", "web", "uri", "ist"], "page": ["next", "image", "blog", "ip", "error", "button", "account", "p", "flash", "html", "pp", "phone", "order", "view", "object", "pg", "user", "sea", "parent", "photo", "po", "office", "handler", "server", "cache", "per", "child", "result", "code", "path", "message", "pool", "ko", "change", "line", "plane", "cover", "root", "end", "f", "url", "pages", "area", "channel", "session", "pe", "can", "bad", "pm", "article", "wp", "record", "wiki", "so", "node", "browser", "site", "list", "filter", "Page", "web", "menu", "pl", "www", "sp"], "os": ["mo", "p", "obj", "oss", "pos", "socket", "object", "oid", "ls", "po", "ros", "oo", "ios", "io", "op", "oto", " bos", "oa", "OS", "ot", "o", "so", "ops", "bos", "ps", "ms"], "rootUrl": ["randomPage", "webPage", "remoteURL", "randomURL", "remoteUrl", "randomUrl", "rootPage", "rootURL", "weburl", "remoteurl", " rooturl", "rooturl", " rootPage", "webURL", " rootURL", "randomurl", "remotePage"], "isMultipart": ["isMultitepart", "isMultiisepart", "isMultiseart", "isMultiiseArt", "isMultiteart", "isMultiteoint", "isMultiipoint", "isMultiipppart", "isMultipoint", "isMultippart", "isMultiparts", "isMultiseArt", "isMultiipart", "isMultypArt", "isMultumparts", "isMultypart", "isMultiipparts", "isMultyppart", "isMultiisearts", "isMultisearts", "isMultiiparts", "isMultiipArt", "isMultumppart", "isMultumpArt", "isMultitearts", "isMultyparts", "isMultipArt", "isMultipppart", "isMultiippart", "isMultisepart", "isMultiiseart", "isMultiippoint", "isMultippoint", "isMultipparts", "isMultumpart"], "rd": ["ind", "db", "RD", "fr", "dig", "rl", "fd", "func", "std", "lt", "fl", "rs", "cr", "rx", "pd", "wid", "loc", "dra", "cd", "dr", "od", "rb", "rss", "ru", "dj", "rh", "td", "rr", "ra", "wr", "ds", "dh", "director", "bd", "rw", "rf", "rolog", "ren", "rt", "xd", "rn", "aa", "rg", "respond", "ld", "rid", "ird", "hh", "dd", "pt", "rob"], "upload": ["image", " uploading", "stream", "form", "transfer", "object", "load", "input", "user", " archive", "instance", "install", "pkg", "archive", "server", "or", "pload", "http", "container", "audio", " instance", "io", " Upload", "out", "file", "sup", "post", "util", "f", "Upload", " submission", "url", "uploads", "zip", "control", "driver", " uploaded", "project", "parser", "command", "folder", "dd", "create", "up"], "webUrl": ["wwwUr", "rootUr", "WebLine", "WebPage", "webLine", "webPage", " webPath", "wwwURL", "WebUr", "wwwLine", "rootPage", "rootURL", "webUr", "WebPath", "WebUrl", " webLine", " webPage", "webPath", "wwwUrl", "WebURL", " webURL", "webURL", " webUr", "rootPath"], "iter": ["former", "Iterator", "iterator", "in", "liter", "vis", "ner", "cher", "inse", "Iter", "eni", "collect", "apper", "order", "init", "feed", "its", "slice", "enter", "coll", "loc", "info", "or", "oper", "ver", "http", "inner", "ite", "li", "gener", "ir", "keeper", "iner", "ignore", "file", "end", "ator", "set", "exec", "err", "keep", "inter", "er", "over", "it", "itter", "ter", "reader", "list", "ser", "iv", "outer", " iterator", "walker", "inc", "izer"], "item": ["items", "get", "r", "image", "ip", "in", "atom", "m", "p", "element", "g", "entry", "stat", "queue", "q", "order", "object", "el", "app", "feed", "input", "user", "instance", "e", "coll", "info", "source", "result", "or", "inner", "li", "op", "xml", "value", "row", "rec", "file", "part", "end", "link", "area", " Item", "this", "api", "unit", "update", "zip", "Item", "data", "temp", "bar", "er", "it", "other", "record", "hop", "entity", "site", "ar", "plugin", "custom", "extra", "layer", "up"], "name": ["in", "m", "size", "term", "one", "n", "block", "label", "key", "i", "old", "common", "on", "e", "id", "parent", "ame", "nam", "info", "child", "connection", "inner", "path", "time", "not", "orig", "nm", "word", "part", "NAME", "x", "end", "f", "col", "prefix", "no", "none", "data", "type", "ni", "Name", "names", "call", "member", "string", "named", "am", "field", "layer", "na", "non"], "baos": ["baOS", "caOs", "nao", "baoes", " baios", " bais", "BAoes", "caOS", "BAos", "pao", "Bao", " bao", "BAis", "BAOS", "paos", "abaos", "sao", "cais", "cao", "bao", "Baos", "Baios", "saOS", "paOs", "abaOS", "naos", "pais", "naOs", " baoes", "baios", "nais", "bais", "paoes", "abao", "baOs", "saos", " baOS", "BAo", "abaios", "BAios", "caos", "sais", "BaOs", "Bais"], "wpIs": ["wordpressis", "WPIs", "cpIns", "wxis", "wordpressAs", "gpIs", "wpis", "phpIs", "xpIs", "cpIS", "fwIs", "wordpressOs", "xpis", "fpIs", "fpOs", "WPAs", "cpIs", "wpOs", "ipI", "WPI", "wxIS", "fwAs", "xpOs", "wpIS", "ipIs", "wxIns", "WPis", "phpis", "gpis", "WPOs", "WPIS", "gpOs", "wxIs", "fpIns", "ipIS", "fpis", "fwIS", "phpIns", "ipAs", "gpIns", "wpI", "cpis", "wpIns", "fwI", "wordpressIs", "xpAs", "phpIS", "wpAs", "WPIns"], "u": ["hu", "su", "bu", "us", "p", "ul", "tu", "i", "s", "uv", "ou", "input", "nu", "U", "mu", "ui", "Lu", "cu", "ru", "iu", "uni", "file", "util", "f", "url", "Url", "uid", "api", "uu", "uci", "o", "b", "l", "fu", "web", "lu", "ur", "uri", "una", "c"]}}
{"id1": "12782570", "id2": "8182932", "code1": "    public void logging() throws Fault {\n        final InterceptorWrapper wrap = new InterceptorWrapper(message);\n        final LoggingMessage buffer = new LoggingMessage(\"Inbound Message\\n----------------------------\");\n        String encoding = (String) wrap.getEncoding();\n        if (encoding != null) {\n            buffer.getEncoding().append(encoding);\n        }\n        Object headers = wrap.getProtocolHeaders();\n        if (headers != null) {\n            buffer.getHeader().append(headers);\n        }\n        InputStream is = (InputStream) wrap.getContent(InputStream.class);\n        if (is != null) {\n            CachedOutputStream bos = new CachedOutputStream();\n            try {\n                IOUtils.copy(is, bos);\n                bos.flush();\n                is.close();\n                this.message.setContent(InputStream.class, bos.getInputStream());\n                if (bos.getTempFile() != null) {\n                    logger.error(\"\\nMessage (saved to tmp file):\\n\");\n                    logger.error(\"Filename: \" + bos.getTempFile().getAbsolutePath() + \"\\n\");\n                }\n                if (bos.size() > limit) {\n                    logger.error(\"(message truncated to \" + limit + \" bytes)\\n\");\n                }\n                bos.writeCacheTo(buffer.getPayload(), limit);\n                bos.close();\n            } catch (IOException e) {\n                throw new Fault(e);\n            }\n        }\n        logger.debug(\"Message received :\\n\" + buffer.getPayload().toString());\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"logging": ["Logger", "Loguring", "loging", "Logging", "configing", "configuring", " loging", " logger", "logger", "loguring", "configging", " loguring", "configger", "Loging"], "wrap": ["get", "process", "image", "wire", "sw", "p", "h", "ow", "flash", "html", "stream", "use", " wrapped", "init", "ad", "parse", "handler", "core", "cache", "run", "or", "handle", "format", "war", "message", "word", "work", "we", "cover", "build", "box", "now", "bag", "util", "f", "binary", "api", "wb", "wrapper", "zip", "div", "builder", "wa", "b", " Wrap", "wp", "w", "nw", "transform", "force", "rap", "frame", "web", "wra", "lock", "ws", "widget", "create", "self", "pipe"], "buffer": ["pause", "pad", "writer", "template", "batch", "flash", "msg", "queue", "surface", "reply", "object", "transfer", "print", "feed", "view", "reference", "bb", "copy", "Buffer", "cache", "server", "source", "result", "board", "fb", "bm", "response", "ref", "report", "http", "buff", "message", "manager", "cover", "pb", "iter", "BU", "buf", "binary", "base", "wrapper", "builder", "player", "log", "b", "bar", "loader", "shell", "bin", "table", "frame", "reader", "header", "nb", "bridge", " buffers", "layer", "cb", " buf"], "encoding": ["coder", "encording", "decoded", "Encoded", "enoder", "cording", "ecryption", "challoder", "enaching", "challoded", "enoding", "coded", "decaching", "Encoder", "ecoded", "encryption", "encoded", "ecoder", "Encryption", "decoder", "coding", "ecoding", "Encoding", "decoding", "encoder", "enoded", "ecording", "encaching", "enording", "challaching", "decryption", "challoding"], "getEncoding": [" getEncoded", "getEncasing", " getEncocol", "getCoding", "getCoded", "getencoding", "getEncoded", "getEncocol", " getEncasing", "getCasing", "getEncression", "getencasing", "getCocol", " getEnoder", "getencocol", "getEnocol", " getEnression", "getCompression", "getEncoder", "getEnoder", "getCoder", "getencoder", "getEnoding", "getCression", " getEnoded", " getEncoder", "getEnression", "getCompoded", " getEnoding", " getEnocol", "getCompoder", "getCompoding", " getEnasing", " getEncression", "getEnoded", "getEnasing"], "headers": ["vals", "details", "h", "files", "types", "host", "s", "strings", "rs", "dict", "events", "workers", "links", "properties", "features", "lines", "keys", "objects", "padding", "writers", "http", "params", "frames", "breaks", "ings", "str", "options", "bits", "relations", "wrapper", "ints", "caps", "values", "blocks", "groups", "names", "ids", "settings", "heads", "body", "header", "parts", "ports", "ers", "head", "ppers", "fields", "plugins"], "is": ["lis", "os", "in", "mis", "Is", "us", "bis", "iso", "oss", "isl", "isa", "i", "bs", "s", "ois", "was", "its", "ses", "aos", "isi", "es", "ris", "IS", "ui", "or", "iss", "obs", "http", "ios", "ori", "nis", "has", "out", "iris", "bas", "ais", "abs", "fs", "api", "sis", "are", "isol", "las", "ins", "so", "ops", "as", "js", "ms", "cms", "ists", "ws", "tis"], "bos": ["os", "mis", "obi", "bots", "bis", "oos", "zos", "oops", "bs", "proxy", "ois", "bott", "was", "lins", "bo", "ubs", "ros", "ses", "aos", "abi", "home", "los", "android", "mobi", "ubis", "obs", "bc", "ios", "cos", "kb", "bes", "oses", "ob", "bps", "osa", "ko", "bas", "bi", "bh", "osi", "abs", "zo", " Bos", "bits", "fs", "oks", "mos", "pins", "shadow", "org", "bot", "so", "fits", "ops", "bones", "beans", "js", "obos", "cms", "obo", "outs", "ws", "oes", "opus", "tis", "uds"], "e": ["error", "ne", "de", "p", "one", "ie", "oe", "element", "i", "ce", "ee", "ze", "fe", "a", "ite", "be", "se", "esi", "E", "ale", "exc", "x", "ke", "f", "ception", "die", "o", "ev", "type", "pe", "err", "er", "ele", "je", "d", "ae", "re", "ea", "c", "ec"]}}
{"id1": "21308543", "id2": "11562165", "code1": "    private static void copyFile(String src, String target) throws IOException {\n        FileChannel ic = new FileInputStream(src).getChannel();\n        FileChannel oc = new FileOutputStream(target).getChannel();\n        ic.transferTo(0, ic.size(), oc);\n        ic.close();\n        oc.close();\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copiedStream", "copyStream", "copyContent", " copiedFiles", " copyContent", "transferContent", " copyStream", "copyFiles", " copiedFile", "transferStream", "transferFile", " copiedContent", "transferFiles"], "src": ["image", "sc", "upload", "attr", "stream", "rc", "sci", "slice", "input", "rs", "sit", "ls", "sin", "core", "server", "scene", "loc", "source", "inf", "media", "rb", "http", "inst", "resource", "code", "path", "img", "dest", "feat", "sel", "url", "this", "download", "remote", "string", "js", "href", "project", "uri", "ource", "ruby", "filename"], "target": ["next", "writer", "large", "compatible", "tx", "master", "output", "object", "reference", "eth", "parent", "nt", "port", "to", "loc", "result", "fat", "content", "path", "resource", "top", "out", "dest", "director", "secure", "prot", "url", "base", "goal", "temp", "type", "Target", "rel", "it", "text", "name", "external", "arget", "remote", "project", "arg", "source", "effect"], "ic": ["ico", "aic", "ai", "ip", "irc", "cci", "ici", "IC", "i", "ik", "sci", "cc", "rc", "cin", "ix", "ib", "lc", "ci", "loc", "bc", "isc", "io", "acl", "voc", "xc", "fc", "aci", "cit", "pic", "enc", "exec", "vc", "iac", "cl", "it", "ct", "pc", "ick", "nic", "mc", "ics", "icc", "mic", "c", "ac", "inc", "ec"], "oc": ["toc", "sc", "irc", "ace", "output", "rc", "cc", "cs", "aco", "bb", "ci", "OC", "alloc", "loc", "bc", "isc", "ocol", "io", "voc", "uc", "xc", "fc", "oca", "roc", "oci", "enc", "pic", "o", "abc", "exec", "vc", "arc", "org", "soc", "AC", "nic", "pc", "other", "co", "anc", "mc", "acs", "ocr", "mic", "iv", "c", "ac", "ec"]}}
{"id1": "7296597", "id2": "4921631", "code1": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"create": ["process", "error", "clone", "connect", "save", "query", "init", "construct", "write", "run", "open", " recreate", "build", "start", "store", "close", "exec", "make", "update", "clear", "log", "drop", "database", "Create", "setup", "destroy"], "conn": ["db", "ai", "error", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "obj", "cert", "cp", "socket", "cn", "rc", "pg", "cat", "cr", "nt", "ci", "core", "ex", "sb", "coll", "cache", "server", "ann", "loc", "adj", "open", "connection", "nc", "dc", "ssl", "con", "conf", "pub", "connected", "oci", "ch", "enc", "serv", "exec", "col", "session", "ac", "close", "log", "rt", "org", "ct", "contract", "co", "Connect", "mc", "commit", "Connection", "lock", "act", "c", "pr"], "stat": ["stats", "db", "error", "su", "success", "pas", "connect", "vis", "sync", "query", "ga", "init", "sit", "cat", "id", "statement", "cli", "sn", "ex", "cache", "sb", "fail", "reg", "ann", "info", "adj", "state", "pr", "debug", "con", "bas", "str", "pred", "close", "null", "serv", "exec", "session", "login", "err", "log", "b", "spec", "shell", "status", "it", "Stat", "name", "auth", "si", "commit", "da", "act", "config", "STAT", "sp"], "sql": ["stats", "where", "db", "su", "error", "query", "msg", "html", "socket", "s", "comment", "ls", "cli", "statement", " SQL", "sol", "sn", "SQL", "sb", "info", "sf", "connection", "params", "xml", "ssl", "str", "util", "url", "col", "serv", "zip", "session", "data", "sq", "log", "dl", "database", "shell", "status", "text", "auth", "ql", "ss", "string", "nl", "si", "seed", "general", "sv", "select", "sp"]}}
{"id1": "9796161", "id2": "18451704", "code1": "    public static String getMD5(String s) {\n        try {\n            MessageDigest m = MessageDigest.getInstance(\"MD5\");\n            m.update(s.getBytes(), 0, s.length());\n            return \"\" + new BigInteger(1, m.digest()).toString(16);\n        } catch (NoSuchAlgorithmException e) {\n            logger.error(\"MD5 is not supported !!!\");\n        }\n        return s;\n    }\n", "code2": "    public boolean isValidPage(BookPage page) {\n        boolean isValid = false;\n        try {\n            if (page.getType() == BookPage.TYPE_RESOURCE) {\n                BookPagePreviewPanel panel = new BookPagePreviewPanel(dControl, true);\n                panel.setCurrentBookPage(page);\n                isValid = !page.getUri().equals(\"\") && panel.isValid();\n            } else if (page.getType() == BookPage.TYPE_URL) {\n                URL url = new URL(page.getUri());\n                url.openStream().close();\n                isValid = true;\n            } else if (page.getType() == BookPage.TYPE_IMAGE) {\n                if (page.getUri().length() > 0) isValid = true;\n            }\n        } catch (Exception e) {\n            isValid = false;\n        }\n        return isValid;\n    }\n", "label": 0, "substitutes": {"getMD5": [" getSHA5", "getHTML4", " getMD512", "getmdHash", "getSHA5", "getSHA512", "getMD4", "getSHA4", "getMDHash", "getmd4", "getHTML5", "getHTML512", " getMD4", "getMD512", " getSHAHash", "getHTMLHash", "getmd5", "getSHAHash", " getMDHash", "getmd512", " getSHA4", " getSHA512"], "s": ["S", "os", "in", "bytes", "p", "tests", "scripts", "styles", "g", "n", "sync", "i", "is", "bs", "cs", "strings", "input", "its", "rs", "ls", "e", "ns", "ses", "comments", "ips", "ows", "es", "sb", "lines", "a", "services", "ssl", "sym", "ds", "str", "ings", "abs", "f", "sets", " fails", "ates", "data", "b", "ends", "v", "l", "als", "ss", "string", "js", "parts", "gs", "ms", "si", "ps", " ads", "ws", "source", "self", "c", "ts"], "m": ["mm", "mac", "h", "p", "i", "man", "e", "om", "mu", "t", "M", "md", "fm", "arm", "um", "module", "bm", "rm", "cm", "nm", "manager", "mand", "mr", "f", "ym", "sm", "dm", "im", "v", "pm", "mi", "em", "tm", "me", "mc", "l", "d", "gm", "ms", "am", "mut", "machine", "vm", "c", "hm", "wm"]}}
{"id1": "88047", "id2": "14317425", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "23398710", "id2": "13946197", "code1": "    public String getUser() {\n        try {\n            HttpGet get = new HttpGet(\"http://api.linkedin.com/v1/people/~\");\n            consumer.sign(get);\n            HttpClient client = new DefaultHttpClient();\n            HttpResponse response = client.execute(get);\n            if (response != null) {\n                int statusCode = response.getStatusLine().getStatusCode();\n                if (statusCode != 200) {\n                    this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n                }\n                StringBuffer sBuf = new StringBuffer();\n                String linea;\n                BufferedReader reader = new BufferedReader(new InputStreamReader(response.getEntity().getContent(), \"UTF-8\"));\n                while ((linea = reader.readLine()) != null) {\n                    sBuf.append(linea);\n                }\n                reader.close();\n                response.getEntity().consumeContent();\n                get.abort();\n                String salida = sBuf.toString();\n                String user_firstname = salida.split(\"</first-name>\")[0].split(\"<first-name>\")[1];\n                String user_lastname = salida.split(\"</last-name>\")[0].split(\"<last-name>\")[1];\n                return user_firstname + \" \" + user_lastname;\n            }\n        } catch (UnsupportedEncodingException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (IOException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthMessageSignerException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthExpectationFailedException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        } catch (OAuthCommunicationException e) {\n            this.enviarMensaje(\"Error: Usuario no autenticado en la red de Linkedin\");\n        }\n        return null;\n    }\n", "code2": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "label": 0, "substitutes": {"getUser": ["getAccount", "newProfile", "createPerson", "newPerson", "createProfile", " getProfile", "getPerson", "newUser", "createUser", "getProfile", " getPerson", "newAccount", " getAccount", "createAccount"], "get": ["request", "GET", "Get", "service", "p", "query", "g", "google", "i", "view", "object", "init", "consumer", "parse", "cli", "json", "cache", "check", "open", "handle", "http", "resource", "pull", "show", "single", "send", "find", "build", "post", "start", "ge", "url", "this", "api", "set", "update", "model", "got", "put", "token", "v", "status", "it", "method", "call", "entity", "invoke", "body", "like", "remote", "give", "read", "sign", "create", "c"], "client": ["request", "connect", "service", "p", "console", "i", "output", "app", "consumer", "copy", "cli", "handler", "server", "per", "conn", "open", "result", "connection", "http", "php", "resource", "io", "ssl", "manager", "send", "con", "secure", "Client", "url", "this", "api", "channel", "session", "control", "contact", "https", "method", "call", "web", "bird"], "response": ["request", "image", "success", "error", "writer", "service", "offer", "tree", "received", "full", "queue", "output", "reply", "view", "object", "feed", "relation", "version", "page", "handler", "json", "server", "result", "connection", "http", "resource", "message", "successful", "report", "index", "results", "Response", "send", "resp", "api", "serv", "data", "subject", "collection", "status", "application", "wave", "document", "site", "body", "respond", "generation", "uri"], "statusCode": ["statusC", "statusType", "StatusC", "Statuscode", "responseCode", " statusC", " statusType", "StatusType", "responseType", " statuscode", "StatusCode", "successC", "successCode", "successcode", "successType", "statuscode"], "sBuf": ["sPluf", " sFbuf", " sBbuf", "sFumb", "sBBbuf", "sQumb", " sAbuf", "sPlumb", " sBumb", "sBeruf", "sBbuff", "sAuf", "sBbuf", "sQuf", " sBbuff", " sAuf", "sBlu", "sFlu", "sBBuf", "sBerumb", " sFlu", "sBuff", " sBBuf", "sBumb", "sFbuf", "sFuf", "sPlbuf", " sBlu", "sQbuf", " sBuff", "sFuff", " sFumb", "sAbuff", " sAbuff", "sBBuff", "sFbuff", " sAuff", "sPllu", "sBBumb", " sFuf", "sBBbuff", " sBBbuf", "sAuff", " sBBumb", "sAbuf", "sBerbuf", "sBerlu"], "linea": [" lineas", " lineva", "linha", "lina", "Lineas", "lineva", "linA", "ideA", "ideas", "idea", "Lineva", "linas", " lineha", "linva", "Lineha", "lineas", " lineA", "LineA", "ideva", "Linea", "lineA", "lineha"], "reader": ["r", "writer", "buffer", "ner", "worker", "cher", "Reader", "stream", "rer", "i", "feed", "input", "e", "rx", "handler", "server", "per", "result", "ler", "pointer", "right", "inner", "editor", "io", "rr", "line", "keeper", "row", "reading", "rar", "iter", "f", "wrapper", "ri", "data", "builder", "loader", "player", "er", "oder", "driver", "l", "upper", "parser", "ser", "read", "layer", "bird"], "salida": ["Salida", "satara", "milida", " salicka", "Salara", "slida", "salicka", "satido", " salidas", "salanda", "Salido", "satida", "bilara", "bilicka", " salanda", "slanda", "milanda", "Salanda", "milido", "slara", "slidas", "bilido", " salara", "bilida", "Salidas", "milidas", " salido", "saticka", "salara", "salido", "salidas"], "user_firstname": ["user_realame", "user_lastame", "user_realName", "user_headname", "user_thirdame", "user_thirdname", "user_firstphone", "user_firstame", "user_fullName", "user_fullame", "user_realname", "user_headame", "user_fullname", "user_firstnames", "user_lastnames", "user_realnames", "user_fullnames", "user_lastName", "user_headphone", "user_firstName", "user_thirdphone", "user_lastphone"], "user_lastname": ["user_lastame", "user_longaddress", "user_firstword", "user_firstame", "user_lastaddress", "user_fullName", "user_fullame", "user_fullword", "user_longname", "user_fullname", "user_fulladdress", "user_firstnames", "user_lastnames", "user_longName", "user_lastword", "user_fullnames", "user_pastaddress", "user_pastname", "user_longame", "user_lastName", "user_pastame", "user_pastName"]}}
{"id1": "15580610", "id2": "6171406", "code1": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"trainClassifier": [" trainclassification", "trainModelification", "trainTestifier", "trainclassify", "trainClassification", "trainClassLoader", "trainModelLoader", " trainclassifier", " trainClassify", " trainclassify", "trainclassifier", " trainClassLoader", "trainclassification", " trainclassLoader", "trainTestLoader", "trainModelifier", "trainModelify", " trainClassification", "trainClassify", "trainclassLoader", "trainTestify", "trainTestification"], "dir": ["env", "domain", "db", "DIR", "files", "output", "class", "object", "fd", "directory", "home", "md", " directory", "loc", "group", "module", "target", "cd", "filename", "path", "report", "direction", "out", "wd", "file", "build", "dist", "root", "url", "lib", "base", "doc", "model", "data", "div", "database", "Dir", "name", "di", "du", "d", "project", "folder", "uri", "window", "config"], "command": ["request", "category", "error", "domain", "Command", "image", "component", "service", "query", "script", "one", "argument", "pattern", "help", "comment", "action", "delete", "input", "sequence", "slave", "cli", "attribute", "directory", "archive", "history", "child", "info", "program", "module", "media", "connection", "array", "path", "message", "reason", "word", "operation", "function", "file", "root", "power", "which", "three", "this", "exec", "model", "system", "control", "clear", "usage", "database", "shell", "force", "language", "document", "name", "volume", "password", "project", "string", "and", "menu", "sudo", "cmd", "event", "machine", "config", "move"], "length": ["dim", "position", "before", "match", "both", "level", "size", "shape", "max", "capacity", "left", "creator", "ph", "full", "square", "class", "form", "character", "slice", "sequence", "ength", "section", "id", "limit", "loc", "last", "th", "span", "or", "strength", "Length", "sum", "padding", "inner", "time", "word", "value", "count", "now", "how", "angle", "power", "len", "end", "part", "depth", "letter", "zip", "type", "range", "prime", "number", "width", "l", "style", "body", "head", "duration", "distance", "join"], "process": ["component", "service", "p", "worker", "script", "sync", "console", "cess", "display", "host", "class", "output", "use", "app", "master", "user", "parse", "parent", "run", "plus", "child", "program", "group", "result", "handle", "share", "connection", "path", "proc", "out", "thread", "function", "file", "post", "this", "exec", "session", "system", "task", "status", "application", "processing", "method", "call", "document", "processor", "python", "project", "cmd", "pid", "machine", "Process"]}}
{"id1": "22503685", "id2": "13207437", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 1, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoWalkerResults", "readGeoparserOutput", "readGeoparserReport", "readGeOParserResults", "readGeoParserResults", "readGeOParserReport", "readGeoparserResult", "readGeoparserResults", "readGeOReaderReport", "readGeoParserReport", "readGeoWalkerReport", "readGeOParserOutput", "readGeOReaderOutput", "readGeoReaderReport", "readGeOReaderResults", "readGeoParserOutput", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResult", "readGeoReaderResult", "readGeoReaderOutput", "readGeOParserResult"], "recordContent": ["resourceContents", "RecordBody", "recordFile", "reportBody", "resourceText", "RecordText", "RecordMessage", "reportMessage", "RecordFile", "recordContents", "RecordContent", " recordContents", "reportContent", "recordBody", "resourceFile", " recordFile", "resourceContent", " recordText", "recordMessage", "recordText", "RecordContents", " recordBody", "reportText", " recordMessage"], "getGazeteerIds": ["getGazeteerConfigs", "getGazeteersIdes", "getGazeteerHostes", "getGazeteersLogxs", "getGazeteersIdings", "getGazeteerNeedes", "getGazeteersIdxs", "getGazeteerLogs", "getGazeteersIders", "getGazeteerIdxs", "getGazeteerIdls", "getGazeteerTextings", "getGazeteerTexts", "getGazeteerLogxs", "getGazeteerLogers", "getGazeteersLogers", "getGazeteerConfigxs", "getGazeteerConfigings", "getGazeteerIdes", "getGazeteerHostings", "getGazeteerLogls", "getGazeteerIders", "getGazeteerTextxs", "getGazeteerHosts", "getGazeteersLogls", "getGazeteerLogings", "getGazeteerNeeds", "getGazeteersIdls", "getGazeteersIds", "getGazeteerTextls", "getGazeteerHosters", "getGazeteerNeedings", "getGazeteerIdings", "getGazeteerNeeders", "getGazeteersLogings", "getGazeteerConfigls", "getGazeteersLoges", "getGazeteersLogs", "getGazeteerLoges"], "ret": ["get", "r", "att", "match", "obj", "bf", "g", "reply", "default", "opt", "dict", "RET", "ut", "ft", "nt", "t", "reg", "replace", "info", "group", "result", "array", "ext", "ref", "vet", "Result", "results", "out", "resp", "Return", "part", "rets", "len", "iter", "feat", "fun", "f", "str", "alt", "data", "rt", "ll", "Ret", "status", "arr", "res", "rg", "list", "det", "gt", "hash", "sys", "mem", "re", "usr", "arg", "repl"], "retries": ["tried", "retried", "altrying", " retrys", "Retries", " retry", "Retry", "Retrying", "trying", "trys", "RETried", "tries", "RETrying", "RETries", "retrying", "altrys", " retrying", "Retrys", "retry", "retrys", "altries", "altried", "RETrys"], "reqPre": ["reqpre", "refPre", "refPost", "requestPre", " requestPost", "requestPlan", "respPlan", " requestpre", "resppre", "refpre", "respPost", "requestPost", "refPlan", "reqPost", " reqpre", "respPre", "requestPref", " requestPref", " reqPost", "reqPlan", "requestpre", "reqPref", " reqPref", " requestPre"], "outputFormat": ["inputSettings", "reportType", "outputSettings", "outputVersion", "inputFormat", "reportVersion", "inputVersion", "OutputVersion", "inputType", "reportSettings", "reportFormat", "OutputType", "OutputFormat", "OutputSettings", "outputType"], "doc": ["db", "m", "h", "Document", "tx", "html", "msg", "pos", "git", "DOC", "bug", "parse", "e", "po", "page", "coll", "md", "home", "info", "result", "dr", "bc", "dc", "http", "desc", "docs", "response", "resource", "xml", "df", "date", "file", "part", "Doc", "str", "f", "api", "feature", "data", "div", "b", "text", "record", "document", "di", "mc", "style", "body", "project", "event", "up"], "url": ["request", "r", "buffer", "sl", "element", "html", "entry", "e", "id", "page", "server", "address", "info", "result", "connection", "http", "location", "response", "ref", "URL", "resource", "path", "ssl", "file", "str", "f", "Url", "api", "base", "channel", "data", "b", "org", "document", "name", "l", "browser", "string", "web", "uri", "orb", "source"], "reader": ["r", "buffer", "writer", "tx", "Reader", "stream", "rc", "feed", "input", "instance", "handler", "info", "or", "http", "resource", "io", "rr", " readers", " parser", "file", "iter", "data", "oder", "er", "parser", "uri", "read"]}}
{"id1": "21491791", "id2": "822452", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"run": ["process", "job", "worker", "spawn", "all", "app", "apply", "code", "Run", "work", "build", "start", "unit", "exec", "execute", "log", "runner", "test", "running", "call", "invoke", "fork", "loop", "command", "create", "func"], "input": ["request", "image", "iterator", "in", "client", "worker", "entry", "stream", "flow", "form", "view", "feed", "context", "user", "internal", "instance", "address", "conn", "state", "connection", "inner", "index", "audio", "resource", "io", "readable", "out", "raw", "work", "reading", "file", "config", "storage", "active", "data", "control", "loader", "Input", "text", "driver", "parser", "read", "source", "up", "initial"], "output": ["image", "job", "generated", "console", "queue", "object", "user", "write", "parent", "environment", "page", "office", "cache", "Writer", "written", "target", "connection", "filename", "writers", "response", "resource", "path", "index", "exit", "later", "operation", "out", "file", "end", "Output", "letter", "unit", "data", "temp", "control", "log", "put", "application", "text", "document", "network", "web", "outer", "writing", "source", "config"], "reader": ["request", "r", "image", "in", "client", "ner", "worker", "Reader", "entry", "stream", "rer", "rator", "author", "view", "context", "owner", "slave", "handler", "server", "inner", "resource", "audio", "io", "manager", "row", "reading", "book", "riter", "peer", "wrapper", "system", "builder", "ri", "loader", "oder", "er", "driver", "parser", "read", "source"], "writer": ["request", "r", "wire", "ner", "creator", "worker", "entry", "author", "write", "ew", "office", "maker", "Writer", "written", "or", "connection", "writers", "inner", "war", "editor", "word", "work", "out", "manager", "wr", "riter", "rw", "engine", "wb", "wrapper", "builder", "data", "wer", "player", "wa", "her", "er", "w", "nw", "wan", "driver", "writ", "ter", "outer", "ws", "writing"], "pump": ["Pamp", "ppump", "ppumper", "cumping", " pam", "hump", "dumper", "pdump", " pdump", "Pumping", "pamp", "humper", "mumper", "Pumps", "pumps", "Pam", "prump", "camp", "pmp", "pam", "Pdump", "pumping", " pmp", "pram", "dmp", "ppumps", "prdump", "pumper", "humps", "Pmp", "cumper", " pamp", "Pump", "mprint", "cump", " pumper", "mump", "hprint", "Pprint", "prumper", " pumps", "pprint", "Pumper", "dump", "dumps", "ppumping", " pumping", "mumps"], "counter": ["r", "lr", "ner", "progress", "worker", "hello", "entry", "author", "master", "currency", "order", "comment", "trace", "consumer", "sequence", "instance", "version", "parent", "ger", "ener", "page", "meter", "enter", "server", "const", "cookie", "result", "pointer", "ver", "code", "inner", "index", "num", "zero", "rew", "keeper", "row", "count", "clock", "step", "starter", "now", "second", "ception", "url", "Counter", "builder", "loader", "keep", "er", "inter", "runner", "offset", "collection", "number", "continue", "processor", "ter", "race", "center", "seed", "loop", "outer", "repeat", "current", "layer", "walker", "timer"], "buffer": ["position", "batch", "entry", "queue", "reference", "page", "Buffer", "limit", "port", "server", "address", "source", "message", "resource", "buff", "uffer", "file", "iter", "url", "buf", "binary", "channel", "base", "data", "loader", "uf", "text", "document", "header", "layer", "length"], "off": ["auto", "offer", "left", "pos", "ff", "flow", "art", "ord", "opt", "on", "fail", "open", "info", "ui", "low", "inner", "ref", "unknown", "out", "offs", "own", "now", "of", "oa", "start", "down", "Off", "end", "area", "o", "set", "OFF", "offset", "Offset", "addr", "head", "eno", "less"], "len": ["fin", "in", "size", "lf", "n", "pos", "all", "fd", "el", "lt", "lim", "fl", "ln", "on", "lc", "limit", "val", "loc", "den", "lin", "ler", "li", "ref", "lan", "line", "lon", "Len", "count", "lit", "end", "en", "url", "lib", "log", "ll", "width", "name", "bin", "l", "body", "elt", "ld", "lock", "gen", "layer", "length"], "rd": [" r", "red", "r", "db", "lr", "RD", "fr", "ind", "rl", "fd", "rc", "ord", "rs", "cr", "rx", "ud", "val", "dra", "dr", "ru", "rb", "adr", "rm", "rss", "rh", " prod", "rr", "ra", "rod", "nr", "hr", "rw", "rf", "raid", "ds", "xd", "rt", "nd", "rn", "d", "ld", "rid", "rand", "RR", "dd", "rob"]}}
{"id1": "19849797", "id2": "7843322", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public void run(IAction action) {\n        int style = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell().getStyle();\n        Shell shell = new Shell((style & SWT.MIRRORED) != 0 ? SWT.RIGHT_TO_LEFT : SWT.NONE);\n        GraphicalViewer viewer = new ScrollingGraphicalViewer();\n        viewer.createControl(shell);\n        viewer.setEditDomain(new DefaultEditDomain(null));\n        viewer.setRootEditPart(new ScalableFreeformRootEditPart());\n        viewer.setEditPartFactory(new TableEditPartFactory());\n        viewer.setContents(getContents());\n        viewer.flush();\n        int printMode = new PrintModeDialog(shell).open();\n        if (printMode == -1) return;\n        PrintDialog dialog = new PrintDialog(shell, SWT.NULL);\n        PrinterData data = dialog.open();\n        if (data != null) {\n            PrintGraphicalViewerOperation op = new PrintGraphicalViewerOperation(new Printer(data), viewer);\n            op.setPrintMode(printMode);\n            op.run(selectedFile.getName());\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", "cloneFiles", "transferfile", " copySource", "transferSource", "cloneSource", "clonefile", "copyFiles", "copyfile", "transferFile", "cloneFile", "transferFiles", "copySource"], "sourceFile": ["ourceUrl", "SourceUrl", "ourceDirectory", "SourceDir", "Sourcefile", "sourcefile", "ourcefile", "ourceFile", "destDirectory", " sourcefile", "SourceFolder", "destUrl", "destfile", "srcDir", "sourceFolder", "srcfile", "srcFile", "srcFolder", " sourceDir", "sourceDirectory", "sourceDir", "SourceDirectory", "SourceFile", "sourceUrl", " sourceFolder"], "destFile": ["srcFiles", "targetDir", "foreignfile", "sourcePoint", "foreignFiles", "srcLine", "srcDirectory", " destDir", "DestFile", " destPoint", "resultfile", "targetPath", "destDir", "Destfile", "destDirectory", "destfile", "srcDir", "targetfile", "DestDirectory", "destFiles", "resultLine", "srcfile", "resultDir", "targetLine", "srcFile", "DestPath", " destfile", "targetFiles", "destPath", "destLine", "foreignFile", "DestDir", "foreignPath", "sourceDir", "resultFile", "DestFiles", " destDirectory", "targetFile", "DestPoint", " destFiles", "destPoint", "sourceFiles"], "source": ["get", "image", "client", "component", "service", "size", "ie", "stream", "src", "ce", "output", "object", "use", "proxy", "context", "scope", "slice", "input", "view", "reference", "slave", "parent", "id", "route", "sin", "core", "cache", "server", "scene", "from", "target", "result", "connection", "inner", "index", "resource", "manager", "dest", "file", "Source", "root", "secure", "storage", "start", "iter", "url", "this", "null", "api", "unit", "channel", "session", "wrapper", "SOURCE", "status", "table", "site", "reader", "remote", "si", "seed", "uri", "current", "ource", "config"], "destination": [" destion", "Destinated", "distinator", "identination", "constination", "identinated", "destation", "distination", "constribution", " destruction", "destruction", "Destruction", "Destribution", "generinated", "domation", "identinate", "identinator", "distruction", "participination", "Destinator", "generination", "participinated", "participinator", " destation", "construction", " destinated", "distion", "destinator", "generruction", "Destion", "destinated", "generinator", "destribution", "Destation", "destion", "destinate", "domination", "participinate", " destribution", " destinator", "Destinate", "Destination", "dominated", "distinated", "constinator", "dominator"]}}
{"id1": "18891988", "id2": "6756635", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"getFile": ["getfile", "loadFile", "loadString", "Getfile", "GetFilename", "GetString", "downloadFilename", "loadFilename", "downloadString", "getString", "getFilename", "loadfile", "downloadFile", "GetFile", "downloadfile"], "serviceName": ["servicePath", "projectName", "packagename", "serviceType", "projectPath", "packageName", "ServiceName", " servicePath", " servicename", "packagePath", " serviceType", "packageUrl", "serviceUrl", "Servicename", "ServicePath", "servicename", "ServiceUrl", " serviceUrl", "projectUrl", "ServiceType", "projectType"], "wsdlLocation": ["wsDLFile", "wllAddress", "wslpFolder", "wsllUrl", "wslLocation", "wsllLocation", "wsslLocation", "wsdlFolder", "wllFolder", "wslFile", "awslFile", "wsllFolder", "wdlDirectory", "wsDLUrl", "wddlFolder", "wsdlDirectory", "wslpFile", "wslpDirectory", "awslLocation", "wsslFolder", "wssdAddress", "wdlAddress", "awslDirectory", "wsdlUrl", "wsllFile", "wddlFile", "wslUrl", "wsDLLocation", "wssdFolder", "wdlFile", "awsdlLocation", "awslUrl", "wddlDirectory", "wllLocation", "wslFolder", "wsdlFile", "wsslFile", "wsDLDirectory", "wsllDirectory", "awsdlDirectory", "wsllAddress", "wsdlAddress", "wddlLocation", "wssdFile", "wslpLocation", "wdlFolder", "wdlLocation", "wssdLocation", "wllFile", "awsdlUrl", "wsslAddress", "awsdlFile", "wslDirectory"], "endpoint": ["endsocol", " endpointer", "ENDpoint", "endocol", "endination", "EndPoint", "enPoint", "endsword", "startaddress", " endPoint", "startpoint", "Endpoint", "endpointer", "endpo", " endpo", " endaddress", "enaddress", "enpointer", "Endocol", " endocol", "Endpo", "Endpoints", " endword", "enpoints", "enination", "ENDpoints", "Endination", "Endword", "ENDination", "endspo", "ENDPoint", "endPoint", "endaddress", "endword", "endpoints", "startPoint", "enpoint", "startpointer", "endspoint"], "fileLocation": ["fileUrl", "FILEDirectory", " fileDirectory", "fileDirectory", "fileURI", "FILEUrl", "FileLocation", "FileUrl", " fileURI", "FileDirectory", "FILEURI", " fileUrl", "FileURI", "FILELocation"], "tempDir": [" temporaryDir", "tmpVer", " tempVer", "TempDir", " temporaryPath", "tempdir", "tmpDir", "tempVer", "Tempdir", "tmpDirectory", "tmpPath", " temporaryDirectory", "tempPath", " tempdir", " tempPath", " tempDirectory", "tmpdir", "TempDirectory", "TempPath", "tempDirectory", " temporaryVer"], "url": ["image", "client", "service", "sl", "ul", "stream", "host", "socket", "el", "fl", "ls", "server", "coll", "address", "conn", "open", "connection", "http", "URL", "path", "pull", "io", "ssl", "file", "f", "Url", "channel", "base", "download", "contact", "log", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "WSDLFile": ["WINDELFolder", "WSDDLPath", "WSDDLSourceFile", "WDDLSourceFile", "WDDlFile", "WINDLPath", "WDDLBase", "WSDLFolder", "WSDDLFolder", "WSDLLFolder", "WDDlSourceFile", "WSDELFolder", "WSDLSourceFile", "WINDLFile", "WSDDLFiles", "WDDLPath", "WSDLLPath", "WDDlfile", "WSDlSourceFile", "WSDLfile", "WSDlFile", "WINDLFiles", "WSDDLfile", "WSDlBase", "WINDLFolder", "WSDLPath", "WINDELFiles", "WSDLLFiles", "WDDlFolder", "WDDlBase", "WSDELFiles", "WSDLFiles", "WSDELFile", "WDDLFile", "WDDLFolder", "WSDLLSourceFile", "WSDlfile", "WDDLfile", "WSDDLBase", "WDDlPath", "WSDLLBase", "WSDLLfile", "WSDLBase", "WSDLLFile", "WINDELFile", "WSDlFolder", "WSDELPath", "WSDDLFile", "WSDlPath", "WINDELPath"], "tmpWSDLFile": ["tmpWDDLFolder", "tmpWDDlFile", "tmpWSDLFiles", "tmpWDDLFiles", "tmpWSDlUrl", "tmpWSDlFile", "tmpWSDELUrl", "tmpWSDELFile", "tmpWDDlFiles", "tmpWDDlUrl", "tmpWSDlFolder", "tmpWDDELFiles", "tmpWSDLLUrl", "tmpWDDELLocation", "tmpWDDLLocation", "tmpWSDlLocation", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDDLFile", "tmpWSDDLLocation", "tmpWSDLLFiles", "tmpWSDlFiles", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDLLFolder", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWDDlFolder", "tmpWSDELFolder", "tmpWSDDLUrl", "tmpWDDELFile", "tmpWSDDLFiles", "tmpWDDLUrl", "tmpWDDELUrl", "tmpWSDLUrl"], "inputFile": ["InputFile", " inputPage", "tempFile", "tempBase", " inputBase", " inputFactory", "InputBuffer", " inputPlace", "tempPage", "outputFile", "InputFiles", "outputDir", " inputfile", "inputUrl", "InputUrl", "tempBuffer", " inputStream", "inputBase", "Inputfile", "InputDir", "inputPlace", "requestStream", "requestFile", " inputFiles", "inputFactory", "tempfile", "outputFiles", "tempUrl", "InputStream", "InputFactory", "InputPage", "inputBuffer", "InputBase", "InputPlace", "inPage", " inputBuffer", " inputUrl", "inputfile", "inDir", "inputFiles", "infile", " inputDir", "inputDir", "inFile", "inputPage", "tempFactory", "tempPlace", "requestFiles", "outputfile", "inputStream", "requestfile"], "tmpFile": ["tempFile", "uploadStream", "TempFiles", "uploadFiles", "tempPage", " tmpPage", "tmpPage", "uploadFile", " tmpDirectory", " tmpFiles", "tmpFiles", "TempPage", "TempFile", "tmpDirectory", "tempFiles", "inputDocument", "uploadDocument", "tempStream", "tempDirectory", "inputFiles", "tempDocument", "inputStream", "tmpStream", "TempDirectory"], "in": ["r", "image", "client", "m", "p", "pin", "inn", "gin", "is", "socket", "init", "impl", "input", "on", "id", "din", "conn", "lin", "connection", "inner", "ssl", "file", "f", "login", "data", "ins", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "timeout", "client", "writer", "sync", "output", "socket", "input", "copy", "on", "parent", "server", "cache", "conn", "to", "group", "connection", "inner", "io", "line", "file", "conf", "part", "ch", "o", "channel", "conv", "err", "can", "log", "net", "co", "name", "bin", "In", "again", "OUT", "IN", "outs", "outer", "source", "up", "c", "inc"], "con": ["plain", "client", "connect", "Conn", "sync", "gin", "socket", "cn", "rc", "thin", "CON", "com", "conn", "open", "ran", "connection", "nc", "bc", "inner", "cm", "ssl", "uc", "fc", "rec", "conf", "Con", "kin", "ctrl", "en", "ch", "close", "channel", "conv", "can", "ins", "co", "un", "IN", "win", "c", "inc"], "fileLength": ["fileSize", "contentSize", "FileLength", " fileWidth", "channelWidth", "contentLen", "FileSize", "channelLen", "filelength", "fileLen", "FileLen", "FileWidth", " filelength", "channelLength", "channelSize", "contentlength", " fileSize", "fileWidth", " fileLen", "Filelength", "contentLength"], "channelIn": ["channelin", " channelConn", "ChannelIn", " channelin", "Channelin", "connectionIn", "channelConn", "connectionOut", "connectionin", "characterIN", "resourceIN", "connectionConn", "characterIn", "resourcein", "channelIN", "resourceOut", "ChannelIN", "ChannelConn", " channelIN", "resourceIn", "characterin", "characterOut", "ChannelOut"], "channelOut": ["connectionOutside", "ChannelOutput", "ChannelIn", "channelOutside", " channelOutput", "channelOUT", "connectionIn", "chanIn", "connectionOut", "canIn", "connectionOutput", "chanout", "chanOutside", "ChannelOutside", " channelout", "canOutside", "canOUT", "chanOUT", "Channelout", "channelout", "connectionout", "chanOut", "channelOutput", "canOut", "ChannelOUT", "ChannelOut"], "tmpDocument": ["tempContent", "tempFile", "tmNode", "newFile", "tmFile", "tempdocument", "tmdocument", " tmpNode", "tempNode", " tmpContent", "tmpDoc", "tmpdocument", "tmpContent", "tempDoc", "newDocument", "tmpNode", "mpFile", " tmpdocument", "newContent", " tmpDoc", "mpNode", "tempDocument", "newdocument", "tmDocument", "mpDoc", "mpDocument"], "nl1": ["arl1", "jlone", "nn2", "nn0", "arl5", "nl5", "jl5", "klFirst", "ln11", "kl1", "nn6", "nn1", "arlFirst", "NL0", "NL6", "NL11", "klone", "NL1", "jlFirst", "ln6", "nl2", "nn11", "ln1", "jl1", "dl0", "dl1", "nlFirst", "nl11", "nl0", "NL2", "kl5", "ln2", "arlone", "nlone", "dl2", "nl6"], "i": ["ai", "ip", "uli", "m", "j", "p", "ie", "n", "eni", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "index", "li", "ii", "io", "iu", "z", "ini", "bi", "part", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "chi", "qi", "uri", "I"], "node1": ["layerOne", "node91", "layer2", "node0", " node0", "nodeone", "Node1", "packageOne", "Node0", "layer91", "n0", " nodeone", "Node91", "shape91", "shapeOne", "layer1", "n1", "nOne", "packageone", "NodeOne", " nodeOne", "shapeone", " node91", "Node2", "nodeOne", "package91", "shape1", "node2", "package1", "n2", " node2"], "tmpOut": ["tempFile", "ptyOutput", "vmout", "cacheOUT", "txtOut", "vmOUT", "txtWriter", "tempout", "txtOutput", " tmpOutput", "cacheOut", "tmpIn", " tmpIn", "tempWriter", "tmpWriter", "tempOutput", "tmpOutput", "txtout", "cacheFile", "tmpout", "tmpOUT", "ptyIn", "tempIn", "ptyOut", " tmpWriter", "vmOut", "tempOut", "cacheIn", "tempOUT", " tmpout", "ptyout", " tmpOUT", "vmIn"], "retVal": [" retObj", "valRet", "RETval", "RETVal", "retval", "retObj", "RETObj", " retval", "valval", "retRet", "valObj", " retRet", "valVal", "RETRet"]}}
{"id1": "17786231", "id2": "11556231", "code1": "        private void downloadFile(final String downloadUrl, final String destinationFile) throws IOException {\n            HttpClient client = new DefaultHttpClient();\n            HttpGet httpGet = new HttpGet(downloadUrl);\n            final File outputFile = new File(destinationFile);\n            createParentDirectories(outputFile);\n            FileOutputStream outputStream;\n            outputStream = new FileOutputStream(outputFile);\n            final HttpResponse response = client.execute(httpGet);\n            if (isInterrupted()) {\n                outputStream.close();\n                return;\n            }\n            final HttpEntity entity = response.getEntity();\n            InputStream inputStream = null;\n            try {\n                if (entity != null) {\n                    inputStream = entity.getContent();\n                    CopyStreamStatusCallback callback = new CopyStreamStatusCallback() {\n\n                        @Override\n                        public long getSkipBetweenUpdates() {\n                            return entity.getContentLength() * 2 / PERCENTAGE_BASE;\n                        }\n\n                        @Override\n                        public void onUpdate(final long copiedLength) {\n                            int percentage = (int) (copiedLength * PERCENTAGE_BASE / entity.getContentLength());\n                            handleUpdate(STATUS_DOWNLOADING, percentage);\n                        }\n                    };\n                    copyStreams(inputStream, outputStream, callback);\n                }\n            } finally {\n                try {\n                    outputStream.close();\n                    if (inputStream != null) {\n                        inputStream.close();\n                    }\n                } catch (IOException e) {\n                    Log.v(DictionaryForMIDs.LOG_TAG, \"Exception while closing stream: \" + e);\n                }\n            }\n        }\n", "code2": "    public static Document ByURL(String urlstr) throws IOException {\n        String uri = urlstr;\n        URL url = new URL(uri);\n        URLConnection connection = url.openConnection();\n        InputStream in = connection.getInputStream();\n        Reader reader = new InputStreamReader(in);\n        InputSource is = new InputSourceImpl(reader, uri);\n        System.out.println(is.toString());\n        Document document = new Document() {\n\n            @Override\n            public Node adoptNode(Node source) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttribute(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Attr createAttributeNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public CDATASection createCDATASection(String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Comment createComment(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentFragment createDocumentFragment() {\n                return null;\n            }\n\n            @Override\n            public Element createElement(String tagName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Element createElementNS(String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public EntityReference createEntityReference(String name) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public ProcessingInstruction createProcessingInstruction(String target, String data) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public Text createTextNode(String data) {\n                return null;\n            }\n\n            @Override\n            public DocumentType getDoctype() {\n                return null;\n            }\n\n            @Override\n            public Element getDocumentElement() {\n                return null;\n            }\n\n            @Override\n            public String getDocumentURI() {\n                return null;\n            }\n\n            @Override\n            public DOMConfiguration getDomConfig() {\n                return null;\n            }\n\n            @Override\n            public Element getElementById(String elementId) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagName(String tagname) {\n                return null;\n            }\n\n            @Override\n            public NodeList getElementsByTagNameNS(String namespaceURI, String localName) {\n                return null;\n            }\n\n            @Override\n            public DOMImplementation getImplementation() {\n                return null;\n            }\n\n            @Override\n            public String getInputEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getStrictErrorChecking() {\n                return false;\n            }\n\n            @Override\n            public String getXmlEncoding() {\n                return null;\n            }\n\n            @Override\n            public boolean getXmlStandalone() {\n                return false;\n            }\n\n            @Override\n            public String getXmlVersion() {\n                return null;\n            }\n\n            @Override\n            public Node importNode(Node importedNode, boolean deep) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void normalizeDocument() {\n            }\n\n            @Override\n            public Node renameNode(Node n, String namespaceURI, String qualifiedName) throws DOMException {\n                return null;\n            }\n\n            @Override\n            public void setDocumentURI(String documentURI) {\n            }\n\n            @Override\n            public void setStrictErrorChecking(boolean strictErrorChecking) {\n            }\n\n            @Override\n            public void setXmlStandalone(boolean xmlStandalone) throws DOMException {\n            }\n\n            @Override\n            public void setXmlVersion(String xmlVersion) throws DOMException {\n            }\n\n            public Node appendChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node cloneNode(boolean arg0) {\n                return null;\n            }\n\n            public short compareDocumentPosition(Node arg0) throws DOMException {\n                return 0;\n            }\n\n            public NamedNodeMap getAttributes() {\n                return null;\n            }\n\n            public String getBaseURI() {\n                return null;\n            }\n\n            public NodeList getChildNodes() {\n                return null;\n            }\n\n            public Object getFeature(String arg0, String arg1) {\n                return null;\n            }\n\n            public Node getFirstChild() {\n                return null;\n            }\n\n            public Node getLastChild() {\n                return null;\n            }\n\n            public String getLocalName() {\n                return null;\n            }\n\n            public String getNamespaceURI() {\n                return null;\n            }\n\n            public Node getNextSibling() {\n                return null;\n            }\n\n            public String getNodeName() {\n                return null;\n            }\n\n            public short getNodeType() {\n                return 0;\n            }\n\n            public String getNodeValue() throws DOMException {\n                return null;\n            }\n\n            public Document getOwnerDocument() {\n                return null;\n            }\n\n            public Node getParentNode() {\n                return null;\n            }\n\n            public String getPrefix() {\n                return null;\n            }\n\n            public Node getPreviousSibling() {\n                return null;\n            }\n\n            public String getTextContent() throws DOMException {\n                return null;\n            }\n\n            public Object getUserData(String arg0) {\n                return null;\n            }\n\n            public boolean hasAttributes() {\n                return false;\n            }\n\n            public boolean hasChildNodes() {\n                return false;\n            }\n\n            public Node insertBefore(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public boolean isDefaultNamespace(String arg0) {\n                return false;\n            }\n\n            public boolean isEqualNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSameNode(Node arg0) {\n                return false;\n            }\n\n            public boolean isSupported(String arg0, String arg1) {\n                return false;\n            }\n\n            public String lookupNamespaceURI(String arg0) {\n                return null;\n            }\n\n            public String lookupPrefix(String arg0) {\n                return null;\n            }\n\n            public void normalize() {\n            }\n\n            public Node removeChild(Node arg0) throws DOMException {\n                return null;\n            }\n\n            public Node replaceChild(Node arg0, Node arg1) throws DOMException {\n                return null;\n            }\n\n            public void setNodeValue(String arg0) throws DOMException {\n            }\n\n            public void setPrefix(String arg0) throws DOMException {\n            }\n\n            public void setTextContent(String arg0) throws DOMException {\n            }\n\n            public Object setUserData(String arg0, Object arg1, UserDataHandler arg2) {\n                return null;\n            }\n        };\n        return document;\n    }\n", "label": 0, "substitutes": {"downloadFile": ["copyFile", "transferfile", " downloadFiles", "copyStream", "transferStream", "copyFiles", "copyfile", " downloadfile", " downloadStream", "transferFile", "downloadStream", "transferFiles", "downloadFiles", "downloadfile"], "downloadUrl": ["updateUrl", "updateFile", " downloadLine", "outputURL", "updateLine", "outputurl", " downloadurl", "outputLine", "downloadURL", " downloadURL", "updateurl", "transferFile", "transferurl", "downloadurl", "downloadLine", "outputUrl", "updateURL", "transferURL", "transferUrl"], "destinationFile": ["destporaryFiles", "destinatedFile", "DestinationFilename", "destoutputString", "destinatedFiles", "DestinationString", "destporaryFile", "destporaryImage", "DestinatingFilename", "destinatingImage", "destigrationFILE", "destinatingFILE", "DestinatingFile", "destinatedFilename", "destoutputFile", "destinatingFiles", "DestinatingFiles", "destinationFILE", "DestinationFILE", "destinationImage", "destinatingFile", "destoutputFiles", "destinatingString", "DestinationImage", "destinationString", "destinationFiles", "destigrationFiles", "destigrationFile", "destoutputImage", "DestinatingFILE", "DestinationFiles", "destinatingFilename", "destigrationFilename", "DestinatingString", "DestinatingImage", "DestinationFile", "destinatedFILE", "destporaryString", "destinationFilename"], "client": ["request", "get", "self", "connect", "service", "query", "cher", "queue", "ce", "proxy", "app", "parent", "cli", "handler", "server", "cache", "per", "conn", "connection", "http", "resource", "con", "Client", "url", "api", "channel", "session", "contact", "https", "cl", "application", "force", "method", "call", "bird", "plugin", "remote", "project", "uri", "config", "c"], "httpGet": ["ttpCall", "httpget", "Httpget", " httpSend", "HttpPut", "resourcePut", "resourceGet", "ttpCreate", "httpCall", "httpPut", " httpget", "resourceCall", "HttpCall", "resourceget", "httpSend", "HttpGet", "HttpCreate", " httpCreate", "httpCreate", "HttpSend", " httpPut", "ttpGet", " httpCall", "ttpSend"], "outputFile": ["outputDirectory", "targetDir", "writePath", "outStream", "referencePath", "targetDirectory", "writefile", "outPath", "writeFile", "outputPath", "referencefile", "outputDir", "referenceStream", " outputDirectory", "outfile", " outputfile", "outputFiles", "targetFiles", "inputDirectory", "writeStream", "referenceFile", " outputDir", "inputFile", "inputFiles", "outFile", "inputDir", " outputPath", " outputFiles", "targetFile", "outputfile"], "outputStream": ["responseWriter", "OutputStream", "logStream", " outputSteam", "outputStreamer", "OutputForm", "OutputWriter", "inputForm", "responseStream", "responseSteam", "outputWriter", "outputSteam", "logWriter", "outputForm", "inputSteam", " outputWriter", "OutputFile", " outputStreamer", "logSteam", "inputFile", "OutputSteam", " outputForm", "inputStreamer", "inputWriter", "logStreamer", "responseFile"], "response": ["request", "image", "error", "success", "query", "received", "queue", "output", "reply", "object", "relation", "feed", "version", "handler", "json", "server", "result", "connection", "http", "resource", "message", "report", "Response", "resp", "ception", "api", "session", "data", "collection", "status", "application", "document", "body", "respond", "generation", "event"], "entity": ["image", "component", "service", "email", "element", "ie", "entry", "machine", "ce", "output", "object", "el", "comment", "instance", "e", "environment", "id", "attribute", "metadata", "json", "cache", "server", "coll", "agent", " identity", "result", "state", "media", "connection", "content", "resource", "Entity", "message", "xml", "translation", "file", "url", "api", "channel", "unit", "model", "data", "pe", "ent", "collection", "status", "application", "ity", "document", "node", "volume", "body", "item", "event", "issue", "source"], "inputStream": ["InputFile", "audioStreamer", "InputBuffer", "inputChannel", "outputstream", "Inputstream", " inputSteam", "selectSteam", "InputChannel", "selectStream", "outputStreamer", "childStreamer", " inputStreamer", "selectStreamer", "downloadStream", " inputstream", "InputSteam", "outputChannel", "childSteam", "outputSteam", "InputLength", " inputFile", "InputStreamer", "inputSteam", "InputStream", "inputBuffer", "audiostream", "childStream", " inputBuffer", "childChannel", " inputChannel", "outputBuffer", "downloadLength", "inputFile", "selectFile", "audioStream", " inputLength", "downloadstream", "downloadSteam", "audioSteam", "inputStreamer", "inputLength", "inputstream"], "callback": ["clone", "buffer", "batch", "sync", "ff", "cell", "cc", "proxy", "consumer", "Callback", "future", "handler", "CB", "cache", "cb", "result", "state", "code", "connection", "band", "fb", "message", "resource", "closure", "function", "config", "url", "wrapper", "data", "loader", "collection", "behavior", "call", "backs", "processor", "plugin", "event", "back", "func"], "copiedLength": ["copippedWidth", "copedCount", "copyingCount", "copixedSize", "copyiedWidth", "copyippedSize", "copiedWidth", "copiedlength", "copodedlength", "copyiedSize", "copyippedlength", "copyedLength", "copyinglength", "copippedLength", "copippedlength", "copyedBytes", "copyiedBytes", "copedLength", "copyedCount", "copyiedLength", "copippedSize", "copixedCount", "copiedBytes", "copyingLength", "copodedLength", "copodedWidth", "copedSize", "copixedLength", "copyippedLength", "copodedSize", "copyiedCount", "copyedSize", "copedBytes", "copyingWidth", "copyippedWidth", "copiedSize", "copyingBytes", "copyingSize", "copyiedlength", "copiedCount", "copixedBytes"], "percentage": ["percentance", " Percentages", "milage", " Percentile", "milaged", " percentile", "Percentance", " Percentance", "Percentage", "Percentaged", "milance", "percentaged", " Percentage", "Percentile", " percentade", " percentages", "milade", "percentages", " percentance", " percentaged", "Percentade", "percentile", "Percentages", "percentade"]}}
{"id1": "771802", "id2": "530882", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createIOSteam", "createInputSteam", "createInputFile", " createByteSteam", " createInputReader", " createByteStream", "createOutputSteam", " createInputSteam", " createOutputFile", "createInputStream", " createIOFile", " createOutputReader", "createInputReader", "createOutputReader", " createInputFile", " createIOStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputStream", " createIOReader", " createByteReader"], "inFile": ["outStream", "insStream", "sourcefile", "sourceFiles", "insFiles", "incFile", "outFiles", "insfile", "sourceStream", "sourceFile", "outfile", "incStream", "incfile", "inputfile", "incFiles", "infile", "inputFiles", "inputFile", "inputStream", "inFiles", "insFile", "inStream"], "outFile": ["workFile", "outStream", "targetDirectory", "targetStream", "workfile", "workingFile", " outfile", "workingfile", "targetfile", "inputTime", " outStream", "outfile", "outTime", "inTime", "workTime", "outDir", "inputfile", "inDir", "infile", "inputFile", "workDir", "inputDir", " outDirectory", "workingDirectory", "workingStream", "targetFile", "outDirectory"], "k_blockSize": ["k_lockSize", "k_bitSize", "k_blocksLen", "k_byteSize", "k_blocksLength", "k_lineCount", "k_BlockSize", "k_lockLength", "k_blocksSize", "k_byteInfo", "k_blockLength", "k_blockCount", "k_BlockCount", "k_lineSize", "k_byteLen", "k_BlockLength", "k_lockCount", "k_blockCode", "k_blocksCount", "k_BlockCode", "k_lockCode", "k_byteCount", "k_blockLen", "k_blockInfo", "k_byteLength", "k_lockLen", "k_bitCount", "k_bitInfo", "k_lineInfo", "k_byteCode"], "byteCount": [" bytecount", "ByteSize", "flushLength", "flushCount", "characterLen", "flushcount", "byteLength", "bytecount", "byteSize", "characterSize", " byteSum", " byteLen", "ByteSum", "flushSize", "blockLength", "Bytecount", " byteLength", "byteSum", "ByteLength", "characterLength", "ByteCount", "characterCount", "blockSum", "ByteLen", "blockCount", "byteLen", " byteSize", "blockSize"], "buf": ["font", "la", "buffer", "cas", "bytes", "seq", "batch", "bf", "ctx", "queue", "src", "fd", "rc", "brace", "tmp", "feed", "Buffer", "alloc", "loc", "result", "rb", "fb", "buff", "img", "exc", "Buff", "bag", "len", "feat", "bh", "config", "base", "vec", "data", "append", "b", "cv", "cap", "uf", "border", "ucc", "background", "cmd", "flush", "cb"], "ofp": ["OFnp", "oft", "Ofc", "Oft", "ofl", "OFt", "Ofp", "OFc", "oftp", "fort", "OFtp", "ofnp", "ofc", "Ofl", "Oftp", "afl", "afc", "Ofnp", "afp", "afnp", "OFp", "forc", "fortp", "forp", "OFl"], "zos": ["os", "nox", "rons", "zb", "bs", "lins", "zn", "iffs", "zi", "oses", "zer", "forge", "bos", "robe", "outs", "webkit", "za", "iframe", "dylib", "inos", "uz", "ses", "ros", "css", "bitcoin", "ZI", "jas", "nz", "soon", "osi", "zen", "oS", "zers", "ozo", "ops", "utils", "js", "ws", "oda", "ls", "abi", "core", "zy", "zona", "zx", "obs", "cos", "tz", "z", "zyk", "rez", "zar", "ogl", "enos", "zes", "cfg", "kos", "zl", "zag", "zin", "lol", "zon", "owicz", "los", "liquid", "packs", "bes", "modules", "budget", "ZA", "zo", "zig", "zip", "zik", "fits", "obb", "hz", "ossus", "gz", "zh"], "osw": ["issw", "bwo", "eswd", "esow", "esw", "osssw", "ossow", "lswo", "ossw", "esfw", "isw", "isd", "esd", "oswd", "lsw", "oshell", "osfw", "esy", "isnow", "lsws", "bsx", "osy", " osww", "ishell", "bsws", "esww", "osswd", "isy", "bsw", "esnow", "oswo", "essw", "lsx", "bx", "ossd", "osx", " osfw", "ossy", "eshell", "ossnow", "iswd", "osow", "osshell", "osd", "bws", "bswo", "osws", " osow", "osww", "ossfw", "osnow", "ossww"], "bw": [" baw", "fw", "fr", "lbwh", " bz", "abwe", "ow", "bbew", "Bwa", "fwa", "lx", "Bw", "bwd", "abW", "lbwa", "lsw", " bew", "ebw", "abw", "ebW", "bew", "ebwe", "lbz", "ebwd", "fbW", "bsw", "bwu", "bbwh", "fbwe", "lbr", "bbwa", "bbws", "lbsw", "bx", "Bew", "fsw", "lw", "bz", "bwh", "bbaw", " bwu", "bwa", "Bws", "bbwu", "lwa", "bbw", "baw", "bws", "fx", "lbws", " bwa", "fwh", "owu", "owa", " bwh", "bW", "abwd", "lbw", "oaw", " bws", "bbz", "fbwd", "bwe", "fbw", "lbx"], "zot": ["zerot", "Zit", "Zita", " zor", "zita", "Zott", "azita", " zori", "jit", "azit", "azot", "jori", "Zot", "zott", "jot", "Zor", "azott", "zerit", "zerita", "ziot", "azor", "zori", "zeros", "zerori", "zerott", "Ziot", "zor", " ziot", "jos", "aziot"], "ifp": ["Ifi", "ipc", "ipl", " ifb", " ifc", " ifi", "IFc", "ipb", "ipp", " ifl", "ifl", "IFf", "IFl", "iff", "ifc", "IFp", "IFi", " iff", "Iff", "Ifc", "ifb", "Ifp", "IFb", "ifi"], "zis": ["jis", "xis", "zenIS", "xits", "Zis", "ziss", "xais", "zenib", "jits", "zenis", "zeip", " zais", "jit", "zipiss", " zits", "Zip", "zIS", "zais", "jisi", " zisi", "xit", "zipis", " zib", "Ziss", "zip", " zIS", "xisi", "xIS", "zeits", "zits", "zipits", "xib", "zenais", "zeiss", "zisi", "zipip", "Zits", "zeis", "zib"], "isr": ["ISrc", "ISpr", "risr", "ISr", "risrc", "irrc", "ISrs", "ISsr", "isrc", "risrb", "isrb", "isssr", "iscr", "irpr", "rispr", "irr", " isrs", "ispr", "irrb", "ISrb", "isrs", " iscr", "isscr", "IScr", "issrs", "issr", " issr"], "br": ["lr", "r", "gr", "rib", "fr", "bp", "obi", "HR", "ctr", "rs", " dr", "cro", " BR", "bc", "rb", "bl", "ber", "ob", "Br", "bro", "img", "ibl", "shr", "str", "bh", "hr", "sr", " Br", "mr", "ch", "div", "err", "b", "bar", "BR", "obl", "kr", "ibr", "bsp", "arr", "yr", "browser", "body", "ocr", " fr", "tr", "sp"], "zit": ["zeitter", "zeit", "zitter", "zipitter", " zip", "zita", "jic", " zite", "jits", "zeith", "jip", "jit", "zipIT", "zipith", " zits", "jite", "zi", "xit", "jita", "zenits", "zenit", " zi", "zenith", "xi", "zipite", "zip", "xic", "zipita", "zeita", "zite", "ji", "zeits", "zits", "zipits", "zIT", "xith", " zith", "jIT", "zeIT", "zipit", "zipip", "zith", " zic", "zenitter", "zic", "jith"]}}
{"id1": "20414923", "id2": "23531898", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    public void doUpdateByLoginID() throws Exception {\n        if (!isValidate()) {\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): Illegal data values for update\");\n        }\n        Connection con = null;\n        PreparedStatement ps = null;\n        String strQuery = \"UPDATE \" + Common.USER_SESSION_TABLE + \" SET \" + \"session_id = ?, user_id = ?, begin_date = ? , \" + \"ip_address = ?, mac_no = ? \" + \"WHERE  login_id= ?\";\n        DBOperation dbo = factory.createDBOperation(POOL_NAME);\n        try {\n            con = dbo.getConnection();\n            con.setAutoCommit(false);\n            ps = con.prepareStatement(strQuery);\n            ps.setString(1, this.sessionID);\n            ps.setInt(2, this.user.getUserID());\n            ps.setTimestamp(3, this.beginDate);\n            ps.setString(4, this.ipAddress);\n            ps.setString(5, this.macNO);\n            ps.setString(6, this.loginID);\n            int resultCount = ps.executeUpdate();\n            if (resultCount != 1) {\n                con.rollback();\n                throw new CesSystemException(\"User_session.doUpdateByLoginID(): ERROR updating data in T_SYS_USER_SESSION!! \" + \"resultCount = \" + resultCount);\n            }\n            con.commit();\n        } catch (SQLException se) {\n            if (con != null) {\n                con.rollback();\n            }\n            throw new CesSystemException(\"User_session.doUpdateByLoginID(): SQLException while updating user_session; \" + \"session_id = \" + this.sessionID + \" :\\n\\t\" + se);\n        } finally {\n            con.setAutoCommit(true);\n            closePreparedStatement(ps);\n            closeConnection(dbo);\n        }\n    }\n", "label": 1, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamDetails", "deletebitstreamInfo", "deleteBitStreamInfo", "deleteBitsystemDetails", "deletebitstreamINFO", "deleteBitstoreInfo", "deleteBitStreaminfo", "deleteBitStreamINFO", "deletebitStreamInfo", "deletebitStreamINFO", "deleteBitsystemInfo", "deleteBitstoreINFO", "deletebitStreaminfo", "deletebitstreamDetails", "deleteBitstreamDetails", "deleteBitsysteminfo", "deleteBitstoreDetails", "deleteBitstoreinfo", "deleteBitstreamINFO", "deleteBitsystemINFO", "deleteBitStreamDetails", "deleteBitstreaminfo", "deletebitstreaminfo"], "id": ["error", "ip", "in", "db", "seq", "p", "one", "entry", "key", "i", "object", "vid", "oid", "ad", "parent", "Id", "mid", "ID", "address", "info", "did", "source", "code", "ident", "index", "num", "path", "ref", "ide", "count", "root", "part", "which", "start", "x", "uid", "url", "no", "sid", "data", "type", "offset", "status", "number", "ids", "name", "d", "like", "aid", "rid", "pid", "kid", "create"], "conn": ["db", "client", "connect", "ca", "Conn", "obj", "ctx", "sync", "stat", "cp", "rc", "cn", "cc", "pg", "cr", "mn", "nt", "ci", "cf", "coll", "server", "ann", "dn", "connection", "nc", "dc", "cm", "con", "col", "ch", "enc", "serv", "exec", "sql", "session", "jp", "rt", "ct", "co", "mc", "Connection", "act", "config", "c", "pr"], "stmt": [" stm", "shmd", "Stlt", "stmr", "Stmr", "Stm", "StMT", "stlt", " stdb", " stmn", "strst", " stpr", "strlt", "sttr", "Stmd", "shMT", "strpr", "stmd", "stst", " sttr", " stst", "stMT", "strmt", "strMT", " stmd", "Start", "strmd", "strdb", "strmn", "start", "shart", "Stst", "strm", "strmr", "shmt", "stpr", "stm", " start", "strtr", "Sttr", "Stmt", "stmn", "Stmn", "Stdb", " stlt", "stdb", " stmr", " stMT", "Stpr"], "numDeleted": ["numDelased", "NumDeigrated", "numDelleted", "numExashed", "Numdeigrated", "numdeased", "Numdeleted", "numExletes", "numdelected", " numDeashed", "numDelete", "numExoded", "numDeoded", "numDefoded", "numModashed", " numDelected", "numDuleted", "numUndued", "numNeletes", " numdeashed", "numdeashed", "numModleted", " numDeased", "numDeloded", "numNelete", "numdeleted", " numDelete", "numDefleted", " numdeased", "numDefased", "numDeigrated", "Numdeued", "numMododed", "numDeflected", "NumDeDelete", " numdeleted", "numDeased", "numDuDelete", "numdelete", "numNeleted", "numExleted", "numdeigrated", "numdeued", " numdeoded", "numDeletes", "numUndDelete", "numModletes", "numDeued", "NumdeDelete", "numDelected", "numDellected", "NumDeued", "numdeletes", "numUndleted", " numdelected", " numDeoded", " numDeletes", "numdeDelete", "NumDeleted", "numDeDelete", "numdeoded", " numdeletes", "numDeashed", "numDuigrated"]}}
{"id1": "10385815", "id2": "22264586", "code1": "    public static void copy(String fileFrom, String fileTo) throws IOException {\n        FileInputStream inputStream = null;\n        FileOutputStream outputStream = null;\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        try {\n            inputStream = new FileInputStream(fileFrom);\n            outputStream = new FileOutputStream(fileTo);\n            inputChannel = inputStream.getChannel();\n            outputChannel = outputStream.getChannel();\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } finally {\n            try {\n                inputChannel.close();\n            } finally {\n                try {\n                    outputChannel.close();\n                } finally {\n                    try {\n                        inputStream.close();\n                    } finally {\n                        outputStream.close();\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "process", "clone", "sync", "upload", "Transfer", "transfer", "delete", "Copy", "write", "open", "replace", "Cop", "change", "send", "file", "exec", "update", "zip", "download", "put", "paste", "split", " Copy", "cmp", "create", "move"], "fileFrom": ["FileTo", "mailTo", "FileStart", "mailFrom", "FileFrom", "fileIn", " fileSource", "mailAs", "fileAs", "fileStart", " fileIn", "ioStart", "FileSource", " fileAs", " fileStart", "FileAs", "ioTo", "ioFrom", "fileSource", "ioSource", "mailIn", "FileIn"], "fileTo": [" fileto", "FileTo", "Fileto", "fileto", "resourceTo", " fileTarget", "fileFile", "resourceFrom", "FileFrom", "fpTo", "FileTarget", "resourceFile", " fileTO", "fileTarget", "FileFile", "fpFrom", "fileTO", "FileTO", "fpto", "fpTO", "resourceTarget", " fileFile"], "inputStream": ["InputFile", "outputContext", "outputstream", "inputContext", "outputFile", "Inputstream", " inputSteam", "InputChannel", "outputSync", "InputSteam", " inputstream", " inputSync", "outputSteam", " inputFile", "inputSteam", "InputStream", " inputContext", "InputSync", "InputContext", "inputSync", "inputFile", "inputstream"], "outputStream": ["writeSocket", "OutputStream", "outputPath", "OutputStreamer", "referenceStream", " outputSteam", "outputStreamer", "fourSteam", "outputChan", "fourStream", "outputSocket", "referenceSocket", "referenceSteam", " outputChan", "outputSteam", "inputChan", "inputSteam", "writeSteam", "OutputPath", "writeChannel", "fourStreamer", "fourChannel", "OutputChan", "writeStream", "referenceChannel", " outputStreamer", "OutputChannel", "OutputSteam", " outputPath", "inputPath", "inputSocket"], "inputChannel": ["outputContext", "butCommand", "outputCommand", " inputSocket", "inputClient", "inputCam", " inputClient", "inputContext", "audioCam", "parentChannel", "InputSocket", "parentPassword", "InputChannel", " inputCam", "outputCam", "outputChan", "parentChan", "outputSocket", "inputPassword", "inputCommand", "inputChan", "butChannel", "InputStream", " inputContext", "butContext", "audioChannel", "outputPassword", "parentStream", "InputContext", "butChan", " inputCommand", "audioClient", "audioStream", " inputPassword", "outputClient", " inputChan", "inputSocket", "InputChan"], "outputChannel": ["outputContext", "outStream", "Outputchannel", " outputchannel", "inputContext", "OutputStream", "outChan", " outputQueue", "outputChan", "OutputQueue", "outputchannel", "inputchannel", " outputChan", "inputQueue", "inputChan", "outChannel", "outputQueue", "OutputChan", "OutputChannel", "OutputContext", " outputContext", "outContext"]}}
{"id1": "6008635", "id2": "21013026", "code1": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"referredFilesChanged": ["referredFileChanged", "referredfilesChanged", "revertedFilesChanged", "referredfileschanged", "revertedFileschanged", "referredFileschanged", "referredFilechanged", "revertedFilesChange", "referredfilesChange", "referredFileChange", "referredFilesChange"], "IOException": ["Downloadception", "IOError", " IOError", "IOception", "DownloadException", "IPception", " IOception", "IPException", "IPError", "DownloadError"], "file": ["image", "db", "entry", "full", "files", "class", "object", "use", "feed", "e", "id", "page", "directory", "handler", "File", "server", "fe", "sf", "info", "http", "path", "message", "fp", "resource", "single", "work", "line", "FILE", "ile", "part", "mail", "dir", "link", "base", "model", "data", "type", "pe", "b", "log", "live", "it", "document", "name", "l", "style", "string", "le", "folder", "uri", "source", "filename"], "url": ["image", "h", "service", "sl", "n", "g", "cert", "rl", "html", "object", "feed", "impl", "fl", "bb", "e", "id", "page", "server", "coll", "open", "loc", "connection", "http", "URL", "resource", "path", "ssl", "z", "build", "Url", "ch", "channel", "api", "log", "b", "v", "ll", "l", "web", "uri", "www"], "f": ["r", "fr", "m", "p", "lf", "n", "fa", "files", "i", "fd", "form", "func", "s", "feed", "fl", "e", "cf", "fo", "t", "coll", "sf", "fe", "info", "inf", "af", "fb", "path", "fp", "conf", "fc", "rf", "fs", "lib", "b", "v", "name", "fx", "l", "folder", "F", "filename", "c"]}}
{"id1": "7276377", "id2": "14617444", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public void readUNI(Vector<String> descriptions, String source) {\n        InputStream is = null;\n        try {\n            URL url = new URL(source);\n            is = url.openStream();\n            Scanner scanner = new Scanner(is);\n            scanner.nextLine();\n            String line = \"\";\n            String id = \"\";\n            String desc = \"\";\n            while (scanner.hasNextLine()) {\n                line = scanner.nextLine();\n                Scanner linescanner = new Scanner(line);\n                linescanner.useDelimiter(\"\\t\");\n                id = linescanner.next();\n                linescanner.next();\n                desc = linescanner.next();\n                linescanner.useDelimiter(\"\\n\");\n                linescanner.next();\n                descriptions.add(id + \" \" + desc);\n            }\n        } catch (MalformedURLException e) {\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (is != null) try {\n                is.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"checksum": ["decumb", "cksums", "checksums", "ckssum", "decums", "cksumb", "cksum", " checkssum", " checksumb", "checkssum", "decum", " checksums", "checksumb", "decsum"], "url": ["image", "fr", "email", "service", "sl", "cert", "stream", "host", "src", "feed", "proxy", "user", "id", "server", "rule", "address", "loc", "or", "connection", "filename", "http", "location", "URL", "path", "resource", "ssl", "manager", "file", "str", "f", "Url", "base", "download", "gl", "loader", "ll", "text", "name", "l", "string", "href", "ur", "uri", "source", "config", "username"], "algorithm": ["malgebra", "algebra", "algo", "ALgebra", "Alignment", "exgo", "malignment", "Algebra", "Algorithm", " algorith", " alignment", " algo", "allgorithm", "allgo", "allgorith", "Algorith", "ALgo", "malgorith", " algebra", "ALgorith", "malgo", "alignment", "exgorithm", "allgebra", "malgorithm", "exgebra", "Algo", "exgorith", "algorith", "ALgorithm"], "messageDigest": ["messageRegator", "messageDester", "messageDigade", "messagediger", "messageMixpe", "messageDiger", "messageDigge", "messageDest", "MessageDest", "messageDigess", "messagedigester", "messageSignester", "messageDesignator", "messageDigester", "messageMixest", "messageDse", "messageSignge", "messageDge", "messageRegess", "MessageMixpe", "messageDesignester", "MessageDesignest", "MessageDester", "messageDade", "MessageDigest", "MessageSignester", "messagedigpe", "messageDesigness", "MessageDigess", "MessageDesignester", "MessageDigade", "messageDigpe", "MessageMixer", "messageDpe", "messagedigade", "messageMixer", "messagedigse", "messageSignest", "MessageMixest", "MessageDigse", "messagedigess", "MessageDigator", "messageDigator", "MessageDesignator", "messagedigge", "MessageSignest", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDigse", "MessageDigge", "MessageDade", "MessageSignge", "MessageSignse", "MessageDse", "MessageDesigness", "messageDesignest", "messageSignse", "messagedigator", "messagedigest", "messageRegest", "messageRegester", "MessageDigpe", "MessageDigester"], "bytes": ["items", "vals", "os", "buffer", "words", "size", "ipes", "steps", "files", "loads", "limits", "bs", "units", "cells", "resses", "ls", "ips", "reads", "es", "lines", "gets", "objects", "boot", "seconds", "tes", "bps", "Bytes", "resources", "frames", "pieces", "classes", "bits", "pages", "ones", "zip", "blocks", "values", "errors", "eps", "rows", "bles", "vs", "parts", "outs"], "in": ["r", "fr", "m", "client", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "impl", "input", "version", "id", "ex", "din", "conn", "fe", "a", "inner", "nin", "ssl", "out", "ini", "con", "rin", "file", "kin", "min", "f", "serv", "login", "data", "ac", "err", "b", "token", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "gen", "win", "source", "c", "inc"], "nBytesRead": ["nPagesLength", " nBytesCount", "nFramesFound", "nFramesLength", "nByteFound", "nBytesLength", "nCharactersLength", "nBytesCount", "nBytesFound", "nWordsWritten", "nWordsRead", " nByteCount", " nByteLength", "nBytesLoad", "nPartsRead", " nBytesLoad", "nCharactersRead", " nBytesFound", " nByteFound", " nByteWritten", " nByteRead", "nByteLoad", "nPagesRead", "nCharactersCount", "nPagesFound", "nPartsWritten", "nByteRead", " nBytesLength", "nPartsLoad", "nFramesWritten", "nBytesWritten", "nByteCount", "nWordsLength", "nByteWritten", "nFramesRead", "nPagesWritten", " nByteLoad", "nCharactersWritten", " nBytesWritten", "nByteLength", "nWordsCount"], "checksumValue": ["checksupString", "checksramArray", " checkssumString", "checkssumText", "checksummVal", "checksummArray", " checkssumVal", "checksupValue", " checkssumText", " checksumString", "checksumberValue", "checkssumValue", " checkssumData", " checksumText", "checksramPath", "checksummValue", "checksumData", "checksumArray", "checksumberText", " checkssumPath", "checkssumVal", "checksummPath", " checksumVal", "checksupData", " checkssumArray", " checkssumValue", "checksupText", "checksumString", "checksramValue", "checksumText", "checkssumArray", "checksumberData", " checksumArray", "checksumPath", " checksumData", "checksumberString", "checkssumPath", "checkssumData", " checksumPath", "checksramVal", "checkssumString", "checksumVal"]}}
{"id1": "4602568", "id2": "4164833", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"storeImage": ["storeVideo", "processVideo", " transferMedia", "storeIcon", " storeIcon", "storeMedia", "processIcon", " storeVideo", " transferImage", " transferIcon", "processImage", " transferVideo", "processMedia", " storeMedia"], "inStream": [" inVideo", " inSteam", " instream", "INStream", "inputVideo", "inCh", "INPath", "inVideo", "inputstream", "inReader", "INCh", "winSteam", "instream", "winReader", "winVideo", " inPath", "inputSteam", "inPath", "winStream", "inputReader", "inputCh", " inReader", " inCh", "inSteam", "INstream", "inputStream", "inputPath"], "fileName": [" fileNames", "imagePath", "httpPath", "httpName", "Filename", "resourceInfo", "imageName", "FilePart", "FileNames", "FILEname", " fileInfo", "fileNode", "FileName", "resourcename", " fileNode", "imagename", "FILENode", "fileInfo", "FilePath", "filePart", "httpPart", "FileInstance", " filePath", "FileInfo", "fileNames", "resourceName", "FILEPath", "fileInstance", "imageNames", " fileInstance", " filePart", "filePath", "FILEInfo", "FILEInstance", "httpname", "resourceNode", " filename", "FILEName", "filename"], "resize": [" resizes", "Resize", "resizer", " resized", "Resizes", " Resizes", "resized", " Resized", "resizes", "Resizer", " resizer", " Resize", "Resized", " Resizer"], "rightNow": ["RightToday", " rightAccount", "rightToday", " rightToday", "dayCurrent", "thirdCurrent", "rightNOW", "thirdNOW", "straightnow", " rightnow", "dayToday", "straightAccount", " rightThen", " rightCurrent", "RightNow", "rightThen", "rightAccount", "straightNow", "thirdThen", "RightCurrent", "thirdToday", " rightNOW", "RightNOW", "thirdNow", "RightAccount", "dayNow", "rightnow", "dayNOW", "rightCurrent", "straightToday", "thirdnow", "Rightnow"], "dayNamedFolderName": ["dayNamedfolderName", "dayNamedDirectorySize", "dayNamedAreaSize", "dayNamedFileName", "dayNamedFileInfo", "dayNamingFolderInfo", "dayNamedDirectoryPath", "dayNestedFolderName", "dayNamedFolderKey", "dayNamedDirName", "dayNestedDirectorySize", "dayNamedfoldername", "dayNamedDirKey", "dayNamedFolderPath", "dayNamedFilePath", "dayNamedFolderInfo", "dayNamedfolderPath", "dayNamedFolderSize", "dayNamingFolderName", "dayNamedfolderSize", "dayNnamedFolderName", "dayNestedFolderSize", "dayNamedAreaName", "dayNestedFoldername", "dayNnamedFolderPath", "dayNamedFileKey", "dayNamedFileSize", "dayNestedDirectoryname", "dayNamedDirSize", "dayNamedAreaname", "dayNamedDirectoryName", "dayNestedDirectoryPath", "dayNamingFolderSize", "dayNamingFolderKey", "dayNamedDirectoryname", "dayNamedFoldername", "dayNestedDirectoryName", "dayNestedFolderPath", "dayNamedfolderInfo", "dayNnamedFolderSize", "dayNamedDirInfo", "dayNamedAreaPath", "dayNnamedFolderInfo"], "uploadDirRoot": [" uploadDirroot", "uploadDirBase", "uploadFolderPath", "inputDirName", "inputDirRoot", "UploadDirroot", "UploadFolderRoot", "inputDirectoryName", "uploadBaseRoot", "uploaddirHome", "inputDirectoryRoot", "uploadBasePath", "uploadFileName", " uploadFileRoot", "uploadDirPath", "uploadDirHome", "uploadFolderroot", "uploadDbRoot", " uploadDirHome", "UploadDirBase", " uploadFileroot", "uploadFileroot", "uploadDirectoryPath", "uploadDbHome", "uploadBaseBase", "inputDirectoryHome", "uploadDirectoryRoot", "uploadFileRoot", "uploaddirRoot", "uploadFilePath", "inputDirHome", "UploadDirPath", "inputDirectoryPath", "uploaddirroot", "uploadDbPath", "uploadDirName", "uploadDirroot", "UploadFolderPath", "uploadFolderBase", "inputDirPath", "uploadFolderRoot", "uploadDirectoryName", "UploadFolderBase", "UploadFolderroot", "uploadDbName", "uploadDirectoryroot", "uploadDirectoryBase", "uploadBaseroot", " uploadFileHome", "uploadDirectoryHome", "UploadDirRoot", "uploadFileHome"], "file": ["image", "auto", "service", "p", "entry", "full", "files", "flow", "class", "object", "comment", "view", "user", "parent", "e", "page", "directory", "handler", "File", "rule", "home", "per", "child", "fe", "connection", "http", "path", "fp", "line", "out", "function", "work", "ile", "book", "part", "FILE", "dir", "f", "url", "lib", "unit", "base", "model", "zip", "pe", "log", "b", "local", "force", "document", "name", "folder", "up"], "extension": ["Extion", "EXTversion", "EXTdivision", "intion", "Extend", "ExtION", "EXTion", "intend", "EXTension", "xtension", "Extension", "extdivision", "xtion", "interion", "interversion", "xtION", "interension", "extion", "extION", "xtend", "extversion", "exversion", "intension", "intION", "exion", "interdivision", "exdivision", "exension", "extend"], "outFileName": ["inLineName", "inFilePath", "outLineLocation", " outFileAddress", "outfileName", "outFilePart", "outFullKey", "inLineInfo", "outPlaceAddress", "outDirPath", "outFieldAddress", "outfileLength", "outDirInfo", "outFileLocation", "outPlacePath", "outfileSize", "outPlaceName", "outfileLocation", "outFolderName", " outFileLine", "inFileLine", " outPlacePath", "outFolderAddress", "OutFileLength", "outLineSize", "outFileLength", "outPathPath", "outfileInfo", "OutDirLength", "outFileSize", " outFilename", "outFilename", "outFullPart", "OutFileInfo", "outFileLine", "inLinePath", "outLineKey", "outFileType", " outPlaceSize", "outLineInfo", "outFullName", "inFileName", "outLineName", "outPlaceSystem", "inFileInfo", "outPlaceType", " outPlaceAddress", " outPlaceName", "inFilePart", "outPathName", "outPathType", "outFieldName", "OutFilePath", "outFolderInfo", "inLinePart", "OutDirPath", " outFileSystem", "inFileKey", "outPlaceLocation", "outFullPath", "outDirKey", "outLineLine", " outPlaceSystem", " outPlaceLine", "outFileSystem", " outFileType", "outDirPart", "outPlaceLine", "outPlaceSize", "OutDirInfo", " outFilePath", "inLineLine", "outLineType", "outFileKey", "outFieldLine", "outLinePath", " outPlaceType", " outFileLocation", "outLinePart", "outDirLine", "outLinename", "outPathname", "outLineLength", " outPlacename", "outDirLength", "outPlacename", "outFileAddress", "outFileInfo", "outFolderPath", "inLineKey", " outFileSize", "OutFileName", "outfilePath", "outDirName", " outPlaceLocation", "outFolderLine", "outFolderSystem", "OutDirName", "outFieldSystem", "outFilePath"], "outPathAndName": ["outpathAndTime", "outPathAndPath", "outPathandNames", "outPathANDNames", "outPathOrname", "outpathAndPath", "outNameAndAddress", "outPathANDPath", "outPathOrNames", "outPathAndAddress", "outpathAndName", "outPathOrPath", "outpathAndNames", "outpathOrPath", "outPathandName", "outPathAndNames", "outPathANDTime", "outNameOrName", "outPathANDName", "outPathANDname", "outNameOrAddress", "outPathandPath", "outNameOrRam", "outPathAndRam", "outPathOrTime", "outPathANDAddress", "outPathANDRam", "outpathOrNames", "outPathAndname", "outNameAndRam", "outPathOrAddress", "outPathOrName", "outNameAndName", "outPathOrRam", "outNameAndPath", "outpathAndname", "outpathOrName", "outPathAndTime", "outNameOrPath"], "uploadedFile": ["uploadratedF", "uploadpedFiles", "UploadpedFile", "UploadedFolder", "uploadedFolder", "uploadpedFile", "uploadpedFolder", "uploadchedFile", "uploadedImage", "processedPath", "processedF", "UploadedImage", "uploadatedfile", "uploadenedFiles", "uploadatedFile", "uploadenedFile", "processchedfile", "UploadpedImage", "uploadpedfile", "UploadedFile", "uploadedFiles", "UploadedFiles", "uploadendedFile", "uploadratedfile", "uploadedPath", "uploadenedFolder", "uploadenedfile", "uploadedF", "uploadratedFile", "uploadededFiles", "uploadededImage", "processedFile", "uploadizedFull", "uploadizedImage", "uploadpedFull", "uploadedFull", "Uploadedfile", "UploadpedFolder", "uploadpedImage", "uploadendedPath", "uploadratedPath", "UploadedFull", "processedfile", "processchedF", "uploadchedF", "uploadizedFile", "UploadpedFull", "UploadpedFiles", "uploadedfile", "processchedFile", "uploadizedFiles", "uploadchedfile", "Uploadpedfile", "uploadatedFolder", "uploadededFile", "uploadededFull", "uploadendedfile", "uploadatedFiles", "uploadchedPath", "processchedPath", "uploadendedF"], "outStream": [" outBuffer", "tempFile", "Directory", "New", "s", "Copy", "tempBuffer", "format", "URL", "tempSteam", "Bytes", "_", " outFile", "Url", "url", "tempStream", "inSteam", "outSteam", "outFile", "outBuffer", "inFile", "inBuffer", " outSteam", "Type"]}}
{"id1": "2676365", "id2": "11562165", "code1": "    public void reset(int currentPilot) {\n        try {\n            PreparedStatement psta = jdbc.prepareStatement(\"DELETE FROM component_prop \" + \"WHERE pilot_id = ? \");\n            psta.setInt(1, currentPilot);\n            psta.executeUpdate();\n            jdbc.commit();\n        } catch (SQLException e) {\n            jdbc.rollback();\n            log.debug(e);\n        }\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"reset": ["back", "sync", "release", "save", "delete", " reconnect", "init", " migrate", "register", " shutdown", " Reset", " restore", " checkpoint", "start", "close", "activate", "set", "update", "clear", "stop", " rebuild", "et", "commit", "setup", "destroy", " disconnect", "flush", "disable"], "currentPilot": ["currentPointiece", "currentPooter", "currentPortector", "currentPortacket", "activePacket", " currentCPilot", "currentCPector", "currentPayiece", " currentPector", "activePistor", "currentPistor", "currentPortooter", " currentCPacket", " currentCPooter", "activePiece", "currentpacket", "currentPointilot", " currentPooter", "currentpilot", "currentPector", "currentPayilot", "activepistor", "currentpooter", "currentPortilot", "currentpiece", "currentPayacket", "currentCPooter", "currentpistor", "currentPointacket", "activepacket", " currentCPector", "currentPiece", "currentPointistor", "activepilot", "currentpector", "currentPayistor", "currentCPilot", "activePilot", "currentCPacket", "currentPacket", "activepiece", " currentPacket"], "psta": [" pppa", "psa", "Psa", " pda", "jsa", "Pesta", " pla", "Pppa", " pste", "pste", "Pasi", " psa", "Pda", "Psta", "pasi", "Pste", "peppa", " pasi", "jda", "pla", "pela", "jsta", "parsa", "pesta", "pesa", "paresta", "parsta", "parasi", " pesta", "Pla", "pda", "pppa", "jste"]}}
{"id1": "14473711", "id2": "11005804", "code1": "    public static String str2md5(String str) {\n        try {\n            MessageDigest alga = MessageDigest.getInstance(MESSAGE_DIGEST_TYPE);\n            alga.update(str.getBytes());\n            byte[] digesta = alga.digest();\n            return byte2hex(digesta);\n        } catch (NoSuchAlgorithmException ex) {\n            return str;\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"str2md5": ["str2dig5", "str2MD3", "str2digse", "str_MD5", "str2md512", "str2h3", "str_MD512", "str2hse", "str2dig3", "str_md5", "str2h512", "str_md3", "str2MD512", "str2MDse", "str_MD3", "str2md3", "str_MDse", "str2dig512", "str2mdse", "str2MD5", "str_md512", "str_mdse", "str2h5"], "str": ["STR", "r", "in", "fr", "buffer", "bytes", "p", "obj", "br", "msg", "sp", "i", "s", "strings", "input", "dict", "cr", "Str", "t", "result", "dr", "code", "format", "exp", "inner", "sr", "f", "url", "st", "enc", "pass", "data", "err", "char", "spec", "test", "kr", "er", "text", "arr", "name", "string", "tr", "empty", "source", "hex", "txt"], "alga": [" algas", "elga", " alca", "ala", "elda", "alda", "Alga", " ala", "alsca", "alqa", "ALa", "algas", " alsa", "ALsa", "alca", "ALja", "ALgas", "ALda", "alsa", "Algas", "elgas", "ALqa", "alsga", " alqa", "alsda", "alsqa", " alda", "ela", "ALca", "Alja", "ALga", "alja", " alja", "Alsa"], "digesta": ["igosta", "igera", "diffesta", "diffeste", "digosta", "digza", "igesta", "badera", "diffosta", "finesta", "finsta", "badza", "diffsta", "codsta", "codeste", "digera", "codza", "codesta", "codosta", "badosta", "codera", "finosta", "badesta", "digsta", "igza", "fineste", "digeste"]}}
{"id1": "20751378", "id2": "7372311", "code1": "    private String hashPassword(String password) throws NoSuchAlgorithmException {\n        String hash = null;\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\n        log.debug(\"secure hash on password \" + password);\n        md.update(password.getBytes());\n        hash = new String(Base64.encodeBase64(md.digest()));\n        log.debug(\"returning hash \" + hash);\n        return hash;\n    }\n", "code2": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "label": 1, "substitutes": {"hashPassword": ["cryptPassword", "signPassword", " hashPass", " hashWord", "cryptpassword", "signpassword", "hashpassword", "signPass", "hashPass", "cryptPass", "signWord", "hashWord", " hashpassword", "cryptWord"], "password": ["plain", "mac", "pad", "words", "p", "crypt", "key", "pattern", "user", "input", "sword", "cache", "phrase", "address", "padding", "Password", "code", "content", "path", "message", "word", "description", "wd", "prefix", "pass", "security", "data", "token", "secret", "w", "sha", "number", " passwords", "text", "database", "name", "auth", "python", "string", "seed", " Password", "command", "encrypted", "PASS", "username"], "hash": ["error", "key", "address", "history", "sh", "replace", "bolt", "handle", "format", "value", "Hash", "build", "root", "base", "security", "update", "tag", "search", "text", "string", "kh", "dump", "length", "ha", "html", "user", "cache", "json", "check", "array", "index", "message", "rh", "pool", "ashes", "alt", "gh", "math", "ruby", "hed", "mac", "ssh", "msg", "ash", "host", "copy", "pkg", "id", "oh", "phrase", "result", "proof", "sum", "work", "url", "uild", "log", "put", "number", "auth", "memory", "addr", "match", "h", "dig", "square", "version", "height", "code", "her", "secret", "sha", "call", "mod", "style", "hex"], "md": ["km", "mm", "mac", "der", "sd", "m", "Cmd", "dig", "kg", "grad", "mad", "pd", "metadata", "ME", "ma", "od", "mb", "amd", "nm", "gb", "df", "wd", "dh", "mand", "gd", "bd", "f", "sm", "mg", "dm", "xd", "pm", "sha", "nd", "mt", "MD", "mc", "hd", "mag", "mod", "d", "vd", "ms", "meta", "am", "cmd", "dd", " MD", "hm"]}}
{"id1": "22560224", "id2": "23517481", "code1": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hashStringMD5": [" hashStringUTF8", " hashFileMD8", " hashStringMK4", " hashStringM6", " hashStringUTF6", " hashStringM4", " hashFileMD6", " hashStringUTF4", " hashStringMK8", " hashStringM5", " hashStringM8", " hashStringMK5", " hashStringMD4", " hashFileMK8", " hashStringUTF5", " hashFileMK5", " hashFileMK6", " hashFileMD5", " hashStringMD6", " hashFileMD4", " hashStringMD8", " hashStringMK6", " hashFileMK4"], "string": ["STR", "buffer", "writer", "bytes", "p", "service", "script", "object", "map", "strings", "input", "sequence", "version", "slice", "section", "address", "result", "content", "array", "message", "word", "date", "file", "str", "operator", "binary", "letter", "null", "data", "database", "number", "text", "name", "ring", "password", "list", "uri", "source", "filename"], "md": ["km", "mm", "mac", "m", "dig", "bf", "ad", "pd", "metadata", "um", "od", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "sm", "mg", "dm", "data", "pm", "MD", "mp", "me", "mc", "rpm", "mag", "hd", "d", "gm", "vd", "ms", "meta", "hash", "am", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "largeData", "byteInfo", "linedata", "byteLength", "lineBytes", "byteSeries", "ByteDATA", "bytePart", "ByteSeries", "lineInfo", " bytedata", "wordInfo", "ByteData", "ByteString", "byteArray", "ByteInfo", "harddata", "BytePart", " byteArray", "letterLength", " bytePart", " byteLength", "bitdata", "largeDATA", "bitData", "Bytedata", "bytedata", "wordData", " byteBytes", " byteString", "wordArray", "largeSeries", " byteDATA", "wordPart", " byteInfo", "blockString", "hardLength", "bitBytes", "byteString", "letterDATA", "letterData", "blockdata", "hardData", " byteSeries", "largeArray", "blockData", "blockArray", "lineData", "letterdata", "hardDATA", "byteBytes", "byteDATA", "bitInfo"], "sb": ["db", "kB", "abb", "bp", "buffer", "sc", "bf", "BP", "src", "ab", "bs", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "fb", "bm", "bps", "mb", "buff", "gb", "ssl", "BG", "Bs", "pb", "Buff", "bh", "eb", "buf", " SB", "BB", "sq", "b", "xb", "obb", "nb", "SF", "ruby", "cb"], "i": ["ai", "ip", "in", "m", "j", "p", "h", "ie", "n", "g", "eni", "is", "s", "multi", "fi", "ix", "slice", "e", "phi", "abi", "id", "ci", "gi", "lc", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "yi", "qi", "uri", "field", "I", "c", "sp"], "hexString": ["nullBuffer", " hexArray", "octArray", "shortBuffer", " hexStr", "octStr", "exstring", "hexstring", "hexText", "formString", "hexArray", "formstring", "shortString", "nullstring", "formStr", "exArray", "nullString", "exText", "shortstring", "exStr", " hexBuffer", "exBuffer", "octstring", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "nullText", "formArray", "octBuffer", " hexText", "octString"], "hex": ["ip", "h", "shape", "sync", "hello", "alpha", "bit", "xxxxxxxx", "form", "ctr", "character", "cube", "nexus", "id", "ex", "sex", "cf", "xf", "wh", "sum", "exp", "http", "num", "rh", "hess", "buff", "pack", "digit", "cross", "closure", "raw", "lit", "str", "pex", "x", "iter", "oct", "brew", "temp", "alph", "rex", "quad", "char", "text", "he", "coord", "xa", "utf", "hash", " Hex", "cmp", "shift", "kh", "escape", "length"]}}
{"id1": "15241397", "id2": "14598566", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", " doGET", " doPut", "doget", " doget", "doPut", "handlePut", "didGET", "didPut", "handleGet", "handleGET", "didget", "didGet", "handleget"], "request": ["image", "client", "buffer", "query", "received", "queue", "object", "context", "input", "user", "instance", "server", "complete", "info", "result", "connection", "http", "message", "resource", "report", "xml", "url", "req", "data", "type", "er", "subject", "application", "method", "document", "Request", "reader", "web", "QUEST", "uri", "event", "initial"], "response": ["next", "image", "error", "client", "writer", "full", "queue", "host", "output", "reply", "view", "object", "version", "parent", "page", "server", "json", "result", "connection", "resource", "report", "message", "pool", "results", "esi", "Response", "out", "function", "resp", "onse", "model", "session", "data", "collection", "status", "application", "wave", "other", "document", "site", "body", "respond", "generation"], "rewrittenQueryString": ["rewwrittenRequestText", "rewrittenqueryService", "rewrittenQueryArray", "rewrittenqueryLine", "rewrittenQuestionArray", "rewrittenQuestionLine", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenQuestionString", "rewwrittenQueryService", "rewwrittenRequestList", "rewwrittenQueryArray", "rewrittenRequestStr", "rewrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewwrittenQueryList", "rewwrittenRequestStr", "rewrittenRequestArray", "rewrittenQueryService", "rewwrittenRequestString", "rewrittenUrlLine", "rewrittenUrlText", "rewrittenUrlService", "rewrittenRequestLine", "rewrittenQueryList", "rewrittenPageList", "rewwrittenQueryString", "rewrittenQuestionList", "rewrittenqueryText", "rewrittenRequestService", "rewwrittenQueryStr", "rewwrittenRequestLine", "rewwrittenQueryText", "rewrittenQueryLine", "rewrittenQuestionText", "rewwrittenRequestService", "rewrittenPageArray", "rewrittenPageLine", "rewwrittenQueryLine", "rewrittenRequestList", "rewrittenQueryText", "rewrittenRequestText", "rewrittenqueryString", "rewrittenQuestionStr", "rewrittenqueryStr"], "rewrittenUrl": ["rewcraftedURL", "rewwrittenUr", "rewrapedFile", "RewrittenLocation", "rewriteURL", "rewwrittenText", "rewatchedUrl", "RewrittenServer", "rewardedLanguage", "RewrittenText", "RewrittenURL", "rewmatchedUrl", "rewwrittenJar", "rewardedUrl", "rewrapedURL", "rewilledInt", "rewwrittenFile", "RewrittenJar", "rewrittenurl", "rewedUr", "rewrittenLanguage", "rewwrittenLanguage", "RewwrittenFile", "rewmatchedurl", "rewmatchedFile", "rewrittenInt", "RewwrittenText", "rewedFile", "rewriteServer", "rewrittenJar", "RewwrittenInt", "Rewwrittenurl", "rewardedLocation", "rewardedURL", "rewrittenServer", "rewrittenFile", "RewwrittenServer", "rewatchedServer", "rewriteUrl", "rewwrittenLocation", "rewardedFile", "rerittenUrl", "rewardedInt", "rewilledURL", "RewwrittenLocation", "rewrittenUr", "rewodedUrl", "rewatchedText", "rerittenFile", "rewcraftedUr", "rewodedURL", "rewwrittenURL", "RewwrittenUrl", "RewrittenUrl", "rewedURL", "RewrittenInt", "RewwrittenUr", "rewrapedUr", "rewardedJar", "Rewrittenurl", "rewriteText", "rerittenLanguage", "rewwrittenInt", "rewrittenText", "rewwrittenUrl", "rewatchedURL", "rewcraftedLocation", "rewedUrl", "rewmatchedURL", "rewwrittenServer", "rewilledUrl", "rewilledJar", "rewodedLanguage", "RewrittenFile", "rewcraftedUrl", "rerittenUr", "rewrittenURL", "rewedurl", "rewardedUr", "rewodedFile", "rewrapedUrl", "rewwrittenurl", "rewrittenLocation", "RewwrittenJar", "RewwrittenURL", "RewrittenUr", "rerittenURL"], "httpURLConnection": ["httpChannelService", "webSSLClient", "httpPathconnection", "httpCLCode", "httpURLFlow", "httpURIConn", " httpURLconnection", " httpURLCode", " httpURConn", "httpUrlConnect", "httpurlConn", "httpURLClient", "HttpURLService", "httpURIConnection", "apacheURLConnect", "webURLContext", "httpSSLClient", "httpSSLContext", "httpELConnect", "httpSSLConnection", "httpChannelconnection", "httpURLConnect", "httpCLConnection", "httpWebConn", " httpStreamconnection", "httpELConn", " httpUrlConn", "httpUrlConnection", "webSSLContext", "apacheGEConnect", "httpGEConnect", "apacheGEConnection", "httpWebConnection", "httpUrlClient", " httpStreamCurrent", "httpurlCurrent", "httpURConnect", "httpURLCurrent", "httpurlCode", "httpELConnection", "httpStreamCurrent", "httpSSLConn", "httpChannelConnect", "httpGEFlow", "httpURService", "httpWebConnect", "httpURLConn", "httpURIFlow", "httpURIconnection", "httpGEConnection", "apacheGEFlow", " httpStreamSession", "httpPathCurrent", "webURLClient", "httpURLconnection", "HttpChannelConnection", "httpPathConnection", "webURLConnection", " httpUrlCode", "apacheURLConnection", "HttpURLConnection", " httpURLConnect", "httpURLContext", "httpChannelConnection", "httpStreamConnection", "httpURConn", "HttpChannelService", "httpURConnection", " httpUrlConnection", "HttpURLconnection", " httpURConnect", "httpURIConnect", "httpurlConnect", "httpUrlCode", "httpURLCode", "httpGEconnection", "apacheURLconnection", "httpURLSession", "httpUrlContext", "httpURconnection", "httpURIContext", "httpURLService", "apacheURLFlow", " httpStreamConnection", "webURLConn", "httpUrlconnection", "httpCLConn", "webSSLConn", "HttpURLConnect", "httpUrlConn", "httpURIClient", "HttpChannelconnection", "httpurlSession", " httpURLSession", "httpPathSession", "httpurlconnection", "HttpChannelConnect", "webSSLConnection", "httpUrlService", "httpStreamSession", "httpStreamconnection", " httpURLCurrent", "httpurlConnection", "httpurlFlow", " httpURLConn", " httpURConnection", "apacheGEconnection"], "header": ["next", "error", "match", "writer", "buffer", "component", "entry", "block", "author", "queue", "key", "master", "default", "comment", "character", "consumer", "headers", "version", "reference", "after", "section", "attribute", "handler", "server", "rule", "metadata", "info", "group", "result", "dr", "index", "message", "pair", "line", "date", "function", "cover", "director", "part", "iter", "second", "channel", "feature", "definition", "data", "player", "her", "er", "token", "document", "driver", "ter", "member", "string", "list", "filter", "bridge", "head", "Header", "outer", "event", "hash", "field", "back", "layer", "column", "item"], "value": ["get", "hello", "element", "entry", "label", "key", "current", "object", "comment", "default", "version", "parent", "expression", "office", "gi", "server", "valid", "option", "val", "json", "child", "info", "property", "format", "media", "content", "message", "description", "now", "function", "attribute", "end", "letter", "set", "model", "data", "type", "VALUE", "values", "v", "text", "language", "document", "name", "password", "string", "variable", "item", "field", "sv", "V", "Value"], "inputStream": ["pullstream", "inputChannel", "outputstream", "resourceChannel", "Inputstream", "InputChannel", "resourceSteam", "outputStreamer", "pullStreamer", "InputSteam", "outputChannel", "outputSteam", "InputStreamer", "inputSteam", "InputStream", "pullStream", "resourcestream", "resourceStream", "pullSteam", "inputStreamer", "inputstream"], "outputStream": ["outputstream", "OutputStream", "outputFile", " outputChannel", "externalSteam", "externalStreamer", "OutputStreamer", " outputSteam", "outputStreamer", "responseStream", "outputChannel", "responseSteam", "outputSteam", "responseChannel", "inputSteam", "externalStream", "OutputFile", " outputFile", "Outputstream", "OutputChannel", "OutputSteam", "externalstream", "inputStreamer", "responseFile", "inputstream"]}}
{"id1": "14609912", "id2": "3945236", "code1": "    private static String lastModified(URL url) {\n        try {\n            URLConnection conn = url.openConnection();\n            return long2date(conn.getLastModified());\n        } catch (Exception e) {\n            SWGAide.printDebug(\"cach\", 1, \"SWGCraftCache:lastModified: \" + e.getMessage());\n        }\n        return \"0\";\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"lastModified": ["lastmodification", "lastMerIFIED", "nextMODified", "lastModached", "lastMODified", "nextMODification", "lastMerached", "nextMODIFIED", "lastmodified", "nextModification", "lastModification", "nextModified", "lastMODification", "lastmodIFIED", "lastMerification", "nextModached", "lastmodached", "lastModIFIED", "nextMODached", "nextModIFIED", "lastMODIFIED", "lastMODached", "lastMerified"], "url": ["image", "client", "sl", "obj", "host", "object", "ls", "id", "page", "server", "address", "open", "loc", "connection", "location", "http", "URL", "resource", "path", "ssl", "file", "str", "secure", "link", "Url", "base", "data", "org", "https", "ll", "name", "l", "browser", "string", "href", "uri", "source", "config", "www"], "conn": ["client", "connect", "Conn", "obj", "ctx", "n", "sync", "cp", "rc", "cn", "nt", "ci", "cache", "coll", "cb", "open", "loc", "ann", "connection", "nc", "http", "cm", "ssl", "con", "conf", "ch", "enc", "col", "exec", "serv", "conv", "ac", "rt", "ct", "l", "Connection", "act", "config", "c"]}}
{"id1": "21491791", "id2": "4716110", "code1": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "code2": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"run": ["process", "job", "worker", "spawn", "all", "app", "apply", "code", "Run", "work", "build", "start", "unit", "exec", "execute", "log", "runner", "test", "running", "call", "invoke", "fork", "loop", "command", "create", "func"], "input": ["request", "image", "iterator", "in", "client", "worker", "entry", "stream", "flow", "form", "view", "feed", "context", "user", "internal", "instance", "address", "conn", "state", "connection", "inner", "index", "audio", "resource", "io", "readable", "out", "raw", "work", "reading", "file", "config", "storage", "active", "data", "control", "loader", "Input", "text", "driver", "parser", "read", "source", "up", "initial"], "output": ["image", "job", "generated", "console", "queue", "object", "user", "write", "parent", "environment", "page", "office", "cache", "Writer", "written", "target", "connection", "filename", "writers", "response", "resource", "path", "index", "exit", "later", "operation", "out", "file", "end", "Output", "letter", "unit", "data", "temp", "control", "log", "put", "application", "text", "document", "network", "web", "outer", "writing", "source", "config"], "reader": ["request", "r", "image", "in", "client", "ner", "worker", "Reader", "entry", "stream", "rer", "rator", "author", "view", "context", "owner", "slave", "handler", "server", "inner", "resource", "audio", "io", "manager", "row", "reading", "book", "riter", "peer", "wrapper", "system", "builder", "ri", "loader", "oder", "er", "driver", "parser", "read", "source"], "writer": ["request", "r", "wire", "ner", "creator", "worker", "entry", "author", "write", "ew", "office", "maker", "Writer", "written", "or", "connection", "writers", "inner", "war", "editor", "word", "work", "out", "manager", "wr", "riter", "rw", "engine", "wb", "wrapper", "builder", "data", "wer", "player", "wa", "her", "er", "w", "nw", "wan", "driver", "writ", "ter", "outer", "ws", "writing"], "pump": ["Pamp", "ppump", "ppumper", "cumping", " pam", "hump", "dumper", "pdump", " pdump", "Pumping", "pamp", "humper", "mumper", "Pumps", "pumps", "Pam", "prump", "camp", "pmp", "pam", "Pdump", "pumping", " pmp", "pram", "dmp", "ppumps", "prdump", "pumper", "humps", "Pmp", "cumper", " pamp", "Pump", "mprint", "cump", " pumper", "mump", "hprint", "Pprint", "prumper", " pumps", "pprint", "Pumper", "dump", "dumps", "ppumping", " pumping", "mumps"], "counter": ["r", "lr", "ner", "progress", "worker", "hello", "entry", "author", "master", "currency", "order", "comment", "trace", "consumer", "sequence", "instance", "version", "parent", "ger", "ener", "page", "meter", "enter", "server", "const", "cookie", "result", "pointer", "ver", "code", "inner", "index", "num", "zero", "rew", "keeper", "row", "count", "clock", "step", "starter", "now", "second", "ception", "url", "Counter", "builder", "loader", "keep", "er", "inter", "runner", "offset", "collection", "number", "continue", "processor", "ter", "race", "center", "seed", "loop", "outer", "repeat", "current", "layer", "walker", "timer"], "buffer": ["position", "batch", "entry", "queue", "reference", "page", "Buffer", "limit", "port", "server", "address", "source", "message", "resource", "buff", "uffer", "file", "iter", "url", "buf", "binary", "channel", "base", "data", "loader", "uf", "text", "document", "header", "layer", "length"], "off": ["auto", "offer", "left", "pos", "ff", "flow", "art", "ord", "opt", "on", "fail", "open", "info", "ui", "low", "inner", "ref", "unknown", "out", "offs", "own", "now", "of", "oa", "start", "down", "Off", "end", "area", "o", "set", "OFF", "offset", "Offset", "addr", "head", "eno", "less"], "len": ["fin", "in", "size", "lf", "n", "pos", "all", "fd", "el", "lt", "lim", "fl", "ln", "on", "lc", "limit", "val", "loc", "den", "lin", "ler", "li", "ref", "lan", "line", "lon", "Len", "count", "lit", "end", "en", "url", "lib", "log", "ll", "width", "name", "bin", "l", "body", "elt", "ld", "lock", "gen", "layer", "length"], "rd": [" r", "red", "r", "db", "lr", "RD", "fr", "ind", "rl", "fd", "rc", "ord", "rs", "cr", "rx", "ud", "val", "dra", "dr", "ru", "rb", "adr", "rm", "rss", "rh", " prod", "rr", "ra", "rod", "nr", "hr", "rw", "rf", "raid", "ds", "xd", "rt", "nd", "rn", "d", "ld", "rid", "rand", "RR", "dd", "rob"]}}
{"id1": "3024970", "id2": "13063241", "code1": "    @Test\n    public void testCopy_inputStreamToOutputStream() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        int count = IOUtils.copy(in, out);\n        assertTrue(\"Not all bytes were read\", in.available() == 0);\n        assertEquals(\"Sizes differ\", inData.length, baout.size());\n        assertTrue(\"Content differs\", Arrays.equals(inData, baout.toByteArray()));\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"testCopy_inputStreamToOutputStream": ["testCopy_inputStreamToInputStream", "testCopy_inputStreamAndInputFile", "testCopy_inputStreamToOutputstream", "testCopy_inputStreamAndOutputFile", "testCopy_inputStreamToInputstream", "testCopy_inputStreamToOutstream", "testCopy_inputStreamToOutputFile", "testCopy_inputStreamAndInputstream", "testCopy_inputStreamToOutFile", "testCopy_inputStreamAndOutputStream", "testCopy_inputStreamToInputFile", "testCopy_inputStreamToOutArray", "testCopy_inputStreamAndInputStream", "testCopy_inputStreamToInputArray", "testCopy_inputStreamAndInputArray", "testCopy_inputStreamToOutStream", "testCopy_inputStreamAndOutputstream", "testCopy_inputStreamAndOutputArray", "testCopy_inputStreamToOutputArray"], "in": ["image", "r", "pin", "query", "n", "inn", "gin", "isin", "i", "is", "s", "init", "cin", "proxy", "input", "id", "include", "arin", "din", "ex", "conn", "connection", "a", "inner", "index", "nin", "ssl", "ini", "rin", "con", "file", "inside", "min", "url", "this", "pass", "login", "update", "data", "err", "token", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "read", "win", "source", "up", "c", "inc"], "baout": ["caoff", "BAin", "BaOut", "BAout", "aain", "paart", "baart", "bain", " bain", "caOUT", "BAoff", " baOUT", "BAart", "cain", "caOut", "paagain", "baoff", "baOUT", "Bain", "paOUT", "baagain", "BaOUT", "BAOut", "Baout", " baart", "aaout", "caout", "caagain", "BAagain", "paout", "pain", "aaoff", "baOut", "BAOUT", "paOut", "aaOut"], "out": ["Out", "image", "client", "buffer", "obj", "n", "up", "output", "object", "default", "ou", "copy", "parent", "ex", "cache", "to", "inas", "conn", "array", "exp", "ext", "io", "pool", "line", "at", "file", "part", "o", "exec", "base", "data", "with", "b", "log", "In", "again", "IN", "outs", "lock", "OUT", "inc"], "count": ["process", "error", "max", "cond", "Count", "load", "parent", "limit", "cache", "check", "from", "info", "code", "found", "ref", "weight", "pool", "work", "file", "start", "base", "type", "call", "name", "counter", "head"]}}
{"id1": "13783898", "id2": "539195", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "20208819", "id2": "16969205", "code1": "    private static final String hash(String input, String algorithm) {\n        try {\n            MessageDigest dig = MessageDigest.getInstance(algorithm);\n            dig.update(input.getBytes());\n            StringBuffer result = new StringBuffer();\n            byte[] digest = dig.digest();\n            String[] hex = { \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"a\", \"b\", \"c\", \"d\", \"e\", \"f\" };\n            for (int i = 0; i < digest.length; i++) {\n                int u = digest[i];\n                u &= 0x000000FF;\n                int highCount = u / 16;\n                int lowCount = u - (highCount * 16);\n                result.append(hex[highCount]);\n                result.append(hex[lowCount]);\n            }\n            return result.toString();\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    private List<JarFile> webArchives(ServletContext servletContext) throws IOException {\n        List<JarFile> list = new ArrayList<JarFile>();\n        Set<Object> paths = servletContext.getResourcePaths(WEB_LIB_PREFIX);\n        for (Object pathObject : paths) {\n            String path = (String) pathObject;\n            if (!path.endsWith(\".jar\")) {\n                continue;\n            }\n            URL url = servletContext.getResource(path);\n            String jarURLString = \"jar:\" + url.toString() + \"!/\";\n            url = new URL(jarURLString);\n            JarFile jarFile = ((JarURLConnection) url.openConnection()).getJarFile();\n            JarEntry signal = jarFile.getJarEntry(FACES_CONFIG_IMPLICIT);\n            if (signal == null) {\n                if (log().isTraceEnabled()) {\n                    log().trace(\"Skip JAR file \" + path + \" because it has no META-INF/faces-config.xml resource\");\n                }\n                continue;\n            }\n            list.add(jarFile);\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"hash": ["get", " hashing", "output", "print", "parse", "copy", "mix", "check", "code", "sum", "format", "num", " Hash", "pack", "raw", "Hash", "build", "str", "SHA", " hashes", "update", "string", "dump"], "input": ["request", "image", "in", "buffer", "accept", "upload", "output", "form", "feed", "context", "instance", "parent", "address", "plus", "inf", "array", "inner", "audio", "raw", "str", "addin", "url", "binary", "null", "data", "temp", "Input", "text", "reader", "string", "seed", "current", "source", "config", "length"], "algorithm": ["calgorith", "algebra", "algo", "Algebra", "Algorithm", " algorith", "aligebra", " algo", " alphabet", "aligo", "Algorith", "calgo", "alphabet", "aliphabet", " algebra", "calgorithm", "calgebra", "Alphabet", "Algo", "aligorithm", "algorith"], "dig": ["dim", "get", "db", "de", "pin", "del", "ag", "g", "grad", "tool", "rd", "comb", "init", "dec", "mix", "ex", "ng", "fe", "um", "grab", "cd", "alg", "exp", "num", "imag", "build", "enc", "div", "log", "im", "pm", "test", "rob", "Dig", "sem", "ig", "me", "rg", "wrap", "mod", "d", "and", "cod", "ld", "lab", "push", "cmp", "rand", "add", "gen", "sign", "dat", "prep"], "result": ["db", "su", "match", "success", "buffer", "card", "current", "master", "output", "default", "consumer", "user", "global", "future", "ger", "page", "valid", "json", "group", "diff", "format", "sum", "array", "response", "message", "report", "our", "Result", "ret", "results", "work", "df", "dest", "function", "value", "root", "manager", "cover", "iter", "url", "this", "null", "api", "data", "builder", "runner", "test", "record", "res", "member", "string", "counter", "uri", "re", "source", "up", "length"], "digest": [" digested", " dige", "signest", " DigEST", "Digse", "generest", " Digest", "bigested", "DigEST", "signester", " digests", "signEST", "generests", "digests", "digse", "signse", " digEST", "bigester", "Digest", "bigests", "Digester", " digester", "Digests", " digse", "generEST", "digester", "digEST", "generester", "dige", "digested", "bigest", "Digested", " Dige", "Dige", " Digester"], "hex": ["h", "ph", "bit", "form", "pattern", "ctr", "cube", "mix", "uint", "ex", "sex", "xf", "address", "check", "format", "array", "sum", "index", "num", "zero", "rh", "wh", "buff", "hess", "digit", "row", "pex", "iter", "oct", "throw", "null", "zip", "data", "temp", "ticket", "rex", "char", "transform", "text", "pixel", "bin", "string", "header", "utf", "head", "shift", "length"], "i": ["ai", "uli", "h", "j", "p", "n", "multi", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "ui", "info", "a", "index", "li", "ii", "io", "iu", "z", "bi", "x", "pi", "f", "o", "xi", "ti", "ri", "b", "y", "v", "oi", "it", "di", "hi", "l", "d", "si", "qi", "uri", "I", "c"], "u": ["hu", "su", "h", "p", "us", "bu", "ul", "tu", "yu", "q", "ue", "uv", "ou", "e", "nu", "U", "mu", "ui", "cu", "ru", "num", "cur", "iu", "uc", "uni", "sup", "x", "f", "uu", "uid", "o", "pu", "b", "v", "uf", "char", "l", "un", "du", "d", "string", "fu", "chu", "lu", "ur", "uri", "back", "up", "c"], "highCount": ["largeCount", "lowcount", "hiLength", "largeSize", "lowCode", "highCode", "higherCode", "highC", "HighCode", "higherCount", "lowSize", "highLength", "lowCast", "fullCast", "HighSize", "fullCount", "highcount", "largeCode", "fullcount", "highCast", "higherC", "HighCount", "HighLength", "hiCount", "HighC", "higherCast", "highSize", "higherSize", "largeC", "hiSize", "lowLength", "hiCode", "highercount"], "lowCount": ["lowerLength", "lowerSum", "LowSize", "lowerCount", "highC", "lowerC", "LowCast", "lowSize", "highLength", "lowCast", "slowCast", "slowSum", "LowCount", "lowerSize", "highCast", "lowC", "lowSum", "slowCount", "highSize", "slowLength", "lowerCast", "LowC", "lowLength", "highSum"]}}
{"id1": "17337238", "id2": "12724876", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    private void loadURL(URL url, String username, String password, JLabel statusDialogMBLabel) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (username != null && !username.equals(\"\")) {\n            if (password == null) {\n                password = \"\";\n            }\n            String encoding = new sun.misc.BASE64Encoder().encode(new String(username + \":\" + password).getBytes());\n            connection.setRequestProperty(\"Authorization\", \"Basic \" + encoding);\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n        String inputLine;\n        this.tmpVRMLFile = File.createTempFile(\"xnavi-\", null, null);\n        System.out.println(\"Created tmp file: \" + this.tmpVRMLFile.getAbsolutePath());\n        FileWriter fw = new FileWriter(this.tmpVRMLFile);\n        long bytesInFile = this.tmpVRMLFile.length();\n        double sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n        String response = \"\";\n        while ((inputLine = in.readLine()) != null) {\n            response = inputLine + \"\\n\";\n            fw.write(response);\n            fw.flush();\n            if (statusDialogMBLabel != null) {\n                bytesInFile = this.tmpVRMLFile.length();\n                sizeInMB = ((double) bytesInFile) / (1024.0 * 1024.0);\n                sizeInMB *= 100.0;\n                sizeInMB = (double) ((int) sizeInMB);\n                sizeInMB /= 100.0;\n                statusDialogMBLabel.setText(sizeInMB + \" MB\");\n                statusDialogMBLabel.repaint();\n            }\n        }\n        fw.close();\n        System.out.println(\"Wrote file \" + this.tmpVRMLFile.getAbsolutePath());\n    }\n", "label": 0, "substitutes": {"create": ["request", "creator", "save", "one", "init", "created", "construct", "instance", "write", "copy", "open", "replace", " recreate", "config", "start", "store", "make", "update", "type", "creation", "record", "Create", "setup", "insert", "destroy", "add", " Create"], "IOException": ["TimeoutError", "IOError", "TimeoutException", "Timeoutception", "Databaseception", "DatabaseError", "IOception", "DatabaseException", " IOError", " IOception"], "conn": ["error", "Coll", "db", "os", "r", "client", "connect", "ca", "Conn", "h", "p", "sync", "ctx", "n", "apt", "oss", "cp", "rc", "cn", "cc", "pg", "ad", "cr", "po", "nt", "ci", "ht", "ens", "coll", "reg", "ann", "loc", "dn", "connection", "nc", "ob", "con", "conf", "wd", "ds", "dh", "pub", "en", "col", "ch", "enc", "sql", "session", "err", "log", "rt", "ct", "Connect", "res", "Connection", "lock", "act", "c", "pr"], "st": ["ST", "r", "sts", "db", "sc", "fr", "sw", "sl", "ast", "sync", "St", "rd", "src", "ste", "s", "std", "sa", "cr", "nt", "ft", "sn", "ist", "t", "sb", "ut", "sh", "inst", "se", "td", "con", "sta", "step", "ds", "str", "ts", "est", "rest", "rt", "put", "nd", "cl", "mt", "ct", "stop", "ost", "ss", "ld", "sth", "ust", "ess", "dd", "pt", "pr", "sp"], "query": ["request", "eries", "where", "error", "clean", "timeout", "iq", "term", "script", "q", "form", "comment", "scope", "qq", "parse", "cr", "select", "Query", "statement", "rule", "json", "qu", "result", "code", "sum", "index", "report", "resource", "rr", "description", " Query", "how", "build", "str", "value", "sql", "update", "sq", "database", "test", "search", "table", "ql", "string", "seed", "command", "question", "filter", "push", "uri", "join", "dq", "pr"], "rs": ["r", "rys", "RS", "arms", "rd", "rl", "rc", "cs", "s", "Rs", "xs", "ls", "cr", "rx", "ns", "ows", "ros", "asts", "ges", "ris", "reg", "ks", "result", "dr", "vers", "rss", "rm", "issues", "ras", "results", "rr", "row", "ds", "hr", "sr", "mr", "ts", "req", "ars", "ans", "ack", "rt", "hs", "rows", "ins", "ys", "acks", "vs", "ues", "res", "rg", "ps", "runs", "ers", "ms", "ws", "pr", "repl"], "genId": ["GenID", "ginID", "gID", "genType", "ginId", "generId", "ginid", " genType", " genInt", " genid", "generType", "ginById", "genById", "libId", "genID", " genID", "winID", "gid", "GenId", "libInt", "winById", "winid", "genInt", " genById", "gId", "winId", "genid", "libType", "Genid", "generInt"], "ret": ["att", "detail", "entry", "rc", "reply", "RET", "reg", "desc", "Pub", "vet", "proc", "pb", "fun", "pub", "grid", "base", "v", "search", "res", "usr", "back", "r", "db", "fit", "def", "gen", "proxy", "ft", "val", "let", "response", "num", "resp", "part", "active", "alt", "rt", "bot", "utils", "gt", "job", "success", "class", "cat", "id", "result", " result", "ext", "ref", "REG", "rev", "auth", "pro", "place", "match", "seq", "obj", "bf", "default", " Ret", "server", "Reg", "rets", "f", "login", "data", "Ret", "vr", "true", "general", "det", "tr", "re", "arg", "repl"]}}
{"id1": "335223", "id2": "13595251", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public void descargarArchivo() {\n        try {\n            FileInputStream fis = new FileInputStream(resultados.elementAt(materialSelccionado).getRuta());\n            FileOutputStream fos = new FileOutputStream(rutaDestinoDescarga);\n            FileChannel inChannel = fis.getChannel();\n            FileChannel outChannel = fos.getChannel();\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n            fis.close();\n            fos.close();\n        } catch (IOException ioe) {\n            System.err.println(\"Error al Generar Copia del Material\\n\" + ioe);\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "19147279", "id2": "4921631", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public int create(BusinessObject o) throws DAOException {\n        int insert = 0;\n        int id = 0;\n        Item item = (Item) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"INSERT_ITEM\"));\n            pst.setString(1, item.getDescription());\n            pst.setDouble(2, item.getUnit_price());\n            pst.setInt(3, item.getQuantity());\n            pst.setDouble(4, item.getVat());\n            pst.setInt(5, item.getIdProject());\n            pst.setInt(6, item.getIdCurrency());\n            insert = pst.executeUpdate();\n            if (insert <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (insert > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            Statement st = connection.createStatement();\n            ResultSet rs = st.executeQuery(\"select max(id_item) from item\");\n            rs.next();\n            id = rs.getInt(1);\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return id;\n    }\n", "label": 1, "substitutes": {"actualizarDatosFinal": [" actualizarDatOSFinal", " actualizarDatosResult", " actualizarDatocFinal", " actualizarDatocTotal", " actualizarBatosTotal", " actualizarDataoComplete", " actualizarDataoTotal", " actualizarDatOSComplete", " actualizarBatocResult", " actualizarDataoFinal", " actualizarBatosResult", " actualizarDatOSTotal", " actualizarBatocFinal", " actualizarDataoResult", " actualizarDatOSResult", " actualizarBatocComplete", " actualizarBatosFinal", " actualizarDatosTotal", " actualizarDatocComplete", " actualizarDatocResult", " actualizarBatocTotal", " actualizarBatosComplete", " actualizarDatosComplete"], "idJugadorDiv": ["idJudadeDec", "idJugordDec", "idJugaderDec", "idJugordOrd", "idJugrarDoc", "idJugaderDoc", "idJugaderDIV", "idJubordDiv", "idJugordDiv", "idJugadorDIV", "idJubadorDec", "idJugordDIV", "idJudadorDiv", "idJubadorDoc", "idJugadorDec", "idJudadorDIV", "idJudadorDec", "idJugrarDiv", "idJugaderDiv", "idJubordDoc", "idJugordDoc", "idJugadeDec", "idJugadorOrd", "idJubordOrd", "idJugaderOrd", "idJugadorDoc", "idJubordDec", "idJudadeDIV", "idJubadorOrd", "idJubadorDiv", "idJugadeDiv", "idJugadeDIV", "idJugrarOrd", "idJugrarDec", "idJudadeDiv"], "idRonda": ["idrora", "idRona", "idRado", "idRhonda", "idGrora", "idRhanna", " idRora", "pidRhado", "idRhado", "idRora", "idRhona", " idRanna", "pidRhora", "pidRado", " idrora", "idGrado", "idRhora", "idrado", "idrona", "pidRonda", "idGronda", "pidRhona", " idronda", "idGrona", " idRona", "pidRhonda", "idronda", "idranna", " idrona", " idranna", "pidRona", "pidRora", "idRanna"], "unjxdxr": ["unjxfexr", "unjddxxR", "unjxdxxl", "unjxdxl", "unjxdddR", "unjxfexR", "unjxdxtr", "unjddxl", "unjxdddrs", "unjxdexer", "unjddxxl", "unjxdxrs", "unjxdxtrs", "unjxdxter", "unjxfxR", "unjxdxxr", "unjxfxr", "unjxdddr", "unjxdxxR", "unjxfexrs", "unjddxxer", "unjddxr", "unjxdexl", "unjxdexR", "unjxdxtl", "unjddxer", "unjxdxR", "unjxdexr", "unjxdxer", "unjxdxxer", "unjxdxtR", "unjddxR", "unjxdexrs", "unjddxxr", "unjxfxrs"], "intResult": ["IntReturn", "longResult", "intRes", " intOrder", " intRest", "INTReturn", "intCode", "ntCode", "IntCode", "intReturn", "mintRate", "longRes", "longResponse", "INTRest", "IntRate", "intRate", "ntResult", "IntResponse", "INTResult", "intRest", " intReturn", "mintResult", "ntRes", " intRes", "longCode", "intOrder", "mintOrder", "intResponse", " intRate", "IntRes", "ntResponse", "IntResult", "IntOrder", "INTRes", "mintReturn", "IntRest"], "sql": ["job", "db", "query", "sl", "sync", "msg", "QL", "socket", "comment", "pg", "select", "section", "statement", " SQL", "limit", "SQL", "sb", "conn", "params", "ssl", "fn", "str", "plan", "url", "sq", "log", "printf", "dl", "database", "eps", "joined", "mt", "search", "l", "ql", "string", "nl", "cmd", "join", "dd", "pr"], "connection": ["position", "db", "client", "connect", "BC", "writer", "query", "ctx", "cp", "relation", "socket", "cc", "proxy", "character", "context", "pg", "environment", "section", "statement", "handler", "server", "conn", "loc", "bc", "container", "index", "manager", "con", "function", "connected", "engine", "session", "log", "database", "collection", "application", "document", "driver", "table", "reader", "ion", "communication", "Connection", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "details", "ping", "p", "PS", "qs", "pp", "pa", "cp", "bs", "cs", "proxy", "pg", "syn", "rs", "ls", "ns", "ips", "po", "conn", "ks", "pers", "posts", "params", "ds", "changes", "ts", "relations", "pe", "eps", "hs", "ins", "pc", "ops", "mp", "Ps", "pse", "gs", "pps", "ms", "ports", "pr", "sp"]}}
{"id1": "21224967", "id2": "8330057", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"crear": ["generar", "Creas", "generare", "Crear", "generas", " Creare", " creare", " Crear", "Crea", "Creare", " crea", " creas", "genera", " Crea", " Creas"], "result": ["success", "error", "match", "db", "rate", "entry", "order", "currency", "comment", "default", "user", "page", "limit", "valid", "diff", "ver", "found", "grade", "response", "message", "Result", "ret", "df", "results", "out", "count", "function", "date", "value", "cash", "die", "feature", "err", "type", "mark", "status", "number", "force", "record", "res", "counter", "score", "ure", "event", "sign", "up", "length"], "sql": ["job", "db", "where", "query", "script", "sync", "sl", "q", "comment", "pg", "action", "install", "statement", " SQL", "SQL", "conn", "params", "fp", "ssl", "fn", "plan", "url", "serv", "exec", "base", "session", "update", "zip", "sq", "log", "printf", "dl", "database", "ql", "string", "seed", "setup", "cmd", "join", "up", "select", "repl"], "connection": ["position", "db", "error", "client", "connect", "BC", "union", "writer", "p", "query", "ctx", "cond", "relation", "socket", "proxy", "context", "pg", "environment", "section", "statement", "server", "cache", "Exception", "conn", "loc", "bc", "container", "graph", "index", "manager", "con", "function", "tc", "which", "connected", "engine", "session", "system", "log", "database", "collection", "application", "document", "driver", "table", "ion", "communication", "Connection", "lock", "event", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "p", "PS", "query", "pp", "qs", "pos", "pa", "cp", "cs", "bs", "proxy", "pg", "pre", "ns", "po", "ips", "pd", "properties", "conn", "ks", "pers", "cop", "params", "posts", "proc", "ds", "changes", "gres", "pe", "jp", "eps", "hs", "ins", "pc", "ops", "settings", "Ps", "vs", "ss", "pse", "gs", "pps", "ports", "pt", "pr", "sp"]}}
{"id1": "22264586", "id2": "21656668", "code1": "    private static void copyFiles(String strPath, String dstPath) throws Exception {\n        File src = new File(strPath);\n        File dest = new File(dstPath);\n        if (src.isDirectory()) {\n            dest.mkdirs();\n            String list[] = src.list();\n            for (int i = 0; i < list.length; i++) {\n                String dest1 = dest.getAbsolutePath() + \"\\\\\" + list[i];\n                String src1 = src.getAbsolutePath() + \"\\\\\" + list[i];\n                copyFiles(src1, dest1);\n            }\n        } else {\n            FileChannel sourceChannel = new FileInputStream(src).getChannel();\n            FileChannel targetChannel = new FileOutputStream(dest).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), targetChannel);\n            sourceChannel.close();\n            targetChannel.close();\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFiles": ["copyPages", "Copyfiles", " copyfiles", "copyChildren", "copyFile", "transferPages", " copyPages", "copyfiles", "transferfiles", "CopyFile", " copyFile", "transferFile", "cloneFile", " copyChildren", "CopyFiles", "cloneFiles", "clonefiles", "transferChildren", "CopyChildren", "clonePages", "transferFiles"], "strPath": [" strFile", "strpath", "strLog", "STRLog", "strFile", "striLog", "StrLog", " strpath", "strName", " strName", "STRpath", "stName", "Strpath", "StrPath", "STRPath", "stPath", "STRFile", "stpath", "striFile", "stripath", "striPath", "StrName", "StrFile", "stFile"], "dstPath": ["fstFile", "fstpath", "drcPath", "dndDir", "drcDir", "dstDir", "dndName", "dndPath", "fstsFile", "sdstpath", "dblFile", "sdndName", "sdndPath", "ddestPath", "drcName", "fstsPath", "fstPath", "dblpath", "dstsDir", "ddestName", "dstFile", "dblDir", "ddestDir", "drcpath", "dstsFile", "dndpath", "fstspath", "dstsPath", "sdndpath", "sdstPath", "dstspath", "fstDir", "dstName", "fstsDir", "dblPath", "sdndDir", "sdstDir", "dstpath", "sdstName", "ddestpath", "ddestFile"], "src": ["back", "in", "sc", "client", "self", "sort", "sl", "ctx", "upload", "scripts", "sync", "stream", "host", "rc", "s", "tmp", "sit", "slice", "rs", "input", "ls", "sin", "reverse", "RC", "sb", "loc", "source", "rb", "path", "cur", "inst", "ssl", "img", "sup", "Source", "dist", "config", "secure", "sel", "url", "st", "this", "download", "sq", "SOURCE", "obl", "split", "sub", "project", "front", "sys", "cmp", "iv", "ource", "ruby", "cb", "rob", "ources", "txt"], "dest": ["db", "de", " Dest", "delete", "default", "tmp", "dd", "comb", "cat", "thin", "slave", "home", "Dest", "target", "result", "dc", "wh", "desc", "dep", "later", "img", "out", "cdn", "sup", "ds", "dist", "wd", "secure", "gd", "wb", "rest", "des", "zip", "flat", "div", "temp", "trans", "done", "test", "di", "du", "style", "d", "front", "project", "prop", "folder", "destroy", "dat", "source", "txt"], "list": ["size", "sort", "entry", "key", "s", "chain", "map", "parent", "info", "str", "base", "dl", "test", "name", "string", "p", "batch", "full", "is", "load", "strings", "json", "stack", "val", "lines", "keys", "diff", "array", "bl", "path", "part", "set", "lists", "ll", "remove", "status", "arr", "l", "like", "filter", "www", "stat", "stream", "files", "delete", "ls", "LIST", "id", "lc", "run", "pair", "dir", "url", "null", "split", "cl", "names", "cont", "source", "la", "all", "queue", "version", "write", "coll", "group", "listed", "code", "members", "none", "data", "type", "parents", "read", "config"], "i": ["r", "ai", "ip", "m", "j", "p", "n", "ie", "key", "multi", "ix", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "info", "a", "li", "index", "ii", "io", "bi", "part", "start", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "data", "b", "y", "v", "ji", "oi", "di", "hi", "me", "si", "qi", "uri", "c", "I", "length"], "dest1": ["sourceOne", "srcOne", "source1", " destone", "Dest0", "homeone", "sourceone", "source2", "source0", "destone", "destOne", "home1", "dest0", "dest2", "Dest1", "src0", "src2", "DestOne", "Dest2"], "src1": [" src2", "sourceOne", "srcOne", "source1", "sourceone", "source2", " srcOne", "rc2", "rcOne", "rc1", "src2", "rcone", "srcone", " srcone"], "sourceChannel": ["srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "ourceContext", "ourceStream", "sourceContext", "targetStream", "ourceChannel", "targetchannel", "targetChan", "sourceStream", "srcStream", "targetContext", " sourceChan", " sourceContext", "SourceContext", " sourcechannel", "srcContext", "SourceChannel", "Sourcechannel", "sourcechannel", "SourceChan"], "targetChannel": ["argetChan", "sourceChan", "TargetChan", "TargetContext", "sourceContext", "destChan", "targetManager", "TargetConnection", "targetchannel", "targetChan", "TargetChannel", "argetchannel", "targetContext", "destContext", " targetchannel", "destChannel", "argetChannel", " targetContext", "argetManager", "Targetchannel", " targetConnection", "destConnection", "TargetManager", "sourcechannel", "targetConnection", " targetChan", " targetManager"]}}
{"id1": "442381", "id2": "8468859", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public boolean connect() {\n        boolean isConnected = false;\n        try {\n            try {\n                this.ftpClient.connect(this.server, this.port);\n            } catch (SocketException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            } catch (IOException e) {\n                status = ErrorResult.CONNECTNOTPOSSIBLE.code;\n                return false;\n            }\n            int reply = this.ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                this.disconnect();\n                status = ErrorResult.CONNECTNOTCORRECT.code;\n                return false;\n            }\n            try {\n                if (this.account == null) {\n                    if (!this.ftpClient.login(this.username, this.passwd)) {\n                        status = ErrorResult.LOGINNOTCORRECT.code;\n                        this.ftpClient.logout();\n                        return false;\n                    }\n                } else if (!this.ftpClient.login(this.username, this.passwd, this.account)) {\n                    status = ErrorResult.LOGINACCTNOTCORRECT.code;\n                    this.ftpClient.logout();\n                    return false;\n                }\n            } catch (IOException e) {\n                status = ErrorResult.ERRORWHILECONNECT.code;\n                try {\n                    this.ftpClient.logout();\n                } catch (IOException e1) {\n                }\n                return false;\n            }\n            isConnected = true;\n            return true;\n        } finally {\n            if ((!isConnected) && this.ftpClient.isConnected()) {\n                this.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionWork", "doReleaseWork", "doBuildCheck", " doReleasecheck", "doVERSIONWork", " doBuildWork", "doversioncheck", "doversionTest", "doBuildWork", " doVersionTest", "doVERSIONcheck", "doBuildcheck", " doVersioncheck", "doBuildTest", "doReleaseTest", "doReleaseCheck", " doBuildCheck", " doReleaseCheck", "doReleasecheck", " doVersionWork", " doBuildcheck", "doVERSIONTest", "doVersionTest", " doBuildTest", "doversionCheck", "doVERSIONCheck", " doReleaseTest", "doVersioncheck"], "view": ["request", "image", "client", "buffer", "accept", "self", "vis", "html", "block", "full", "display", "q", "form", "cell", "object", "layout", "comment", "use", "input", "app", "el", "e", "page", "port", "server", "cache", "ui", "http", "see", "show", "screen", "gui", "out", "change", "row", "gu", "box", "edit", "sel", "this", "model", "update", "div", "session", "can", "v", "VIEW", "views", "l", "style", "reader", "body", "View", "window", "event", "lock", "widget", "config"], "url": ["blog", "image", "client", "buffer", "service", "sl", "stream", "host", "socket", "input", "user", "bb", "server", "bel", "address", "open", "connection", "http", "hub", "URL", "resource", "path", "ob", "ssl", "file", "build", "f", "Url", "lib", "channel", "base", "zip", "loader", "log", "ll", "browser", "l", "string", "web", "uri", "source"], "in": ["buffer", "bis", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "sin", "din", "lin", "inner", "resource", "nin", "out", "ini", "con", "rin", "file", "binary", "login", "data", "b", "ins", "In", "reader", "IN", "as", "win", "source", "ac", "inc"], "bin": ["fin", "buffer", "pin", "inn", "gin", "socket", "bn", "init", "cin", "input", "ln", "bb", "abi", "sin", "din", "spin", "run", "lin", "inner", "out", "con", "kin", "file", "bi", "part", "binary", "lib", "inline", "data", "loader", "b", "log", "border", "oin", "bot", "record", "browser", "reader", "IN", "body", "nb", "lock", "win", "ruby"], "line": ["job", "ip", "lo", "lf", "block", "entry", "i", "key", "cell", "object", "el", "comment", "load", "layer", "parse", "e", "id", "page", "lc", "valid", "rule", "home", "lines", "Line", "lin", "code", "band", "message", "day", "word", "row", "file", "str", "end", "link", "ge", "part", "letter", "no", "unit", "base", "pass", "inline", "definition", "data", "pe", "model", "b", "log", "ine", "split", "LINE", "cl", "text", "name", "l", "site", "style", "string", "nl", "le", "look", "source", "up", "non"], "develBuild": ["deviousbuild", "dewardBuild", "deelBuilder", "deelRun", "deployRun", "desvenRun", "desvelRun", "deployBuilt", "desvelBuilder", "desvenbuild", "DEvelBuilder", "dewardBuilder", "deVELBuilt", "devenBuild", "deelRelease", "desvelRelease", "devenBuilt", "DEVELBuilder", "dellBuilder", "devenBuilder", "deploybuild", "dewardbuild", "DEvelBuilt", "devenRelease", "develBuilt", "devenbuild", "deVELRun", "develRun", "develbuild", "desvenBuilt", "dellRun", "deVELbuild", "deVELBuild", "deelBuild", "develBuilder", "desvenRelease", "desvelbuild", "DEvelBuild", "DEVELbuild", "deviousBuild", "deployBuild", "desvenBuild", "dellRelease", "desvenBuilder", "deVELBuilder", "DEVELBuilt", "DEVELBuild", "dewardBuilt", "devenRun", "deviousBuilt", "desvelBuilt", "dellBuild", "develRelease", "deployBuilder", "DEvelbuild", "desvelBuild"], "stableBuild": ["staticBuild", "stableBuilder", "prettyVersion", "staticBuilder", "prettybuild", "compatiblebuild", "secureBuild", "validbuild", "validBuild", "latestBuild", " stablebuild", "validBuilder", "compatibleBuilder", "latestBuilder", " stableVersion", "securebuild", "baseBuild", "prettyBuild", "stableVersion", "baseVersion", "secureBuilder", "latestbuild", "baseBuilder", "basebuild", "stablebuild", "prettyBuilder", "staticbuild", " stableBuilder", "compatibleBuild"]}}
{"id1": "6341264", "id2": "18097962", "code1": "    public static byte[] getJarEntry(String jarName, String entry, int port) {\n        byte[] b = null;\n        try {\n            String codebase = System.getProperty(\"java.rmi.server.codebase\", InetAddress.getLocalHost().getHostName());\n            String protocol = \"http://\";\n            int x = codebase.indexOf(protocol) + protocol.length();\n            String s2 = codebase.substring(x);\n            int x2 = s2.indexOf('/');\n            String downloadHost = s2.substring(0, x2);\n            if (downloadHost.indexOf(':') == -1) {\n                downloadHost += \":\" + port;\n            }\n            URL url = new URL(\"jar:http://\" + downloadHost + \"/\" + jarName + \"!/\" + entry);\n            JarURLConnection jurl = (JarURLConnection) url.openConnection();\n            JarEntry je = jurl.getJarEntry();\n            InputStream is = jurl.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            int size = (int) je.getSize();\n            b = new byte[size];\n            int rb = 0;\n            int chunk = 0;\n            while ((size - rb) > 0) {\n                chunk = bis.read(b, rb, size - rb);\n                if (chunk == -1) {\n                    break;\n                }\n                rb += chunk;\n            }\n            bis.close();\n            is.close();\n            bis = null;\n            is = null;\n            url = null;\n            jurl = null;\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return b;\n    }\n", "code2": "    private static String getVersion() {\n        debug.print(\"\");\n        String version = null;\n        String version_url = \"http://kmttg.googlecode.com/svn/trunk/version\";\n        try {\n            URL url = new URL(version_url);\n            URLConnection con = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) version = inputLine;\n            in.close();\n        } catch (Exception ex) {\n            version = null;\n        }\n        return version;\n    }\n", "label": 0, "substitutes": {"getJarEntry": ["getJarFile", "getFolderInfo", "GetJarSource", "loadJarentry", "loadJarEntry", "getZipentry", "loadZipentry", "getjarEntry", "getJarentry", "getZipInfo", "getEntryEntry", "loadZipEnt", "getEntryentry", "getZipSource", "getEntryFile", "getZipEntry", "getJarSource", "getFolderSource", "getJarEnt", "loadJarFile", "GetZipEntry", "loadJarEnt", "GetJarEntry", "getEntryEnt", "loadZipFile", "getjarEnt", "getjarentry", "getJarInfo", "getZipEnt", "loadZipEntry", "GetJarFile", "GetZipFile", "GetZipInfo", "getFolderEntry", "getFolderFile", "GetZipSource", "GetJarInfo", "getjarFile", "getZipFile"], "jarName": ["jarPath", "JarName", "browserId", "jarUrl", " jarID", "JarID", "javaUrl", "browserUrl", "jarAlias", "browserName", "browserAlias", " jarPath", "javaPath", "JarPath", "javaID", "javaName", "javaAlias", "jarId", " jarId", "JarAlias", "javaId", " jarUrl", "jarID", " jarAlias"], "entry": ["image", "service", "query", "ie", "element", "key", "host", "feed", "enter", "id", "ry", "route", "archive", "server", "address", "connection", "ident", "path", "resource", "description", "file", "str", "start", "zip", "data", "type", "ticket", "offset", "secret", "name", "Entry", "plugin", "string", "uri", "jar", "source", "filename"], "port": ["position", "ip", "timeout", "service", "pos", "host", "Port", "key", "ort", "version", "delay", "patch", "limit", "server", "address", "target", "time", "path", "direction", "count", "file", "type", "offset", "name", "password", "project", "string", "ports", "point", "uri", "PORT", "pid", "length"], "b": ["r", "db", "abb", "bp", "buffer", "bytes", "p", "bf", "br", "i", "ab", "lb", "bs", "s", "zb", "emb", "ib", "bb", "e", "sb", "boot", "a", "fb", "beta", "mb", "ob", "library", "buff", "pb", "B", "bd", "reb", "f", "eb", "binary", "wb", "base", "buf", "bar", "v", "l", "xb", "obb", "d", "nb", "orb", "cb", "c", "erb"], "codebase": ["broadbase", "queBase", "quebas", "corebar", "codeBase", "corebase", "workb", "CodeBase", "broadb", "workBase", " codefull", " codeBase", " codeb", "codebar", "Codebar", "queb", "broadBase", " codebar", " codebas", "workbase", "Codebas", "quebase", "coreBase", "workfull", "codefull", "codebas", "codeb", "corebas", "broadfull", "Codeb", "Codebase"], "protocol": ["Protocol", "ocolocol", "predocol", "protost", "Protport", "verbost", "propport", " protost", " protology", "predology", "predurl", " proturl", "propurl", "protore", "predore", "propocol", "verburl", "Protost", "verbocol", "verbology", "proport", "proology", "ocolore", "protport", "proturl", "Proturl", "Protology", "Protore", "ocolurl", "propology", "prourl", "protology", "proocol", "ocolology"], "x": ["xes", "m", "h", "max", "p", "xt", "tx", "ctx", "pos", "xp", "xxxxxxxx", "ix", "xs", "rx", "id", "ex", "X", "xf", "es", "dx", "check", "val", "ax", "exp", "index", "z", "work", "ww", "xc", "lex", "en", "f", "xi", "xxx", "pe", "xxxx", "y", "v", "xx", "xd", "w", "fx", "d", "wx", "xa", "cross"], "s2": ["e2", "string2", "s62", "e1", "stringtwo", "ptwo", "stwo", "p1", "sls", "satter", "xls", "e62", "o62", "qsii", "v1", "o1", "ssecond", "v2", "patter", " sls", "qsls", "osecond", "esecond", " s1", "s1", "qs2", "vtwo", " ssecond", "qs1", "x1", "stringatter", "vatter", "sii", "string1", "xii", "p2", " s62", " sii", "o2"], "x2": ["x0", " x6", "ix1", "tx2", "index0", "tx52", "ix6", "ix2", " x52", "X2", "xSecond", "txSecond", "X1", " x0", "X52", "index1", "XSecond", "ix0", " xSecond", "index6", "x1", "x6", " x1", "index2", "x52", "tx1"], "downloadHost": ["transferHost", "transferPath", " downloadAddress", "transferRoot", "DownloadPath", "updateRoot", "urlDomain", "writePort", "transferhost", "downloadDomain", " downloadRoot", "updateAddress", " downloadPath", "transferPort", "transferAddress", "downloadRoot", "downloadPort", "writeDomain", "updatehost", "urlHost", "urlhost", " downloadhost", "downloadhost", "downloadAddress", "Downloadhost", " downloadPort", " downloadDomain", "writehost", "urlPort", "downloadPath", "DownloadHost", "updateHost", "writeHost", "DownloadAddress"], "url": ["ball", "image", "j", "service", "sl", "ul", "obj", "rl", "el", "fl", "user", "ls", "bb", "il", "server", "coll", "loc", "connection", "http", "URL", "li", "resource", "ob", "ssl", "file", "build", "link", "util", "f", "Url", "base", "zip", "control", "gl", "contact", "log", "rel", "org", "ll", "l", "web", "ur", "uri", "lock", "jar", "orb", "source", "www"], "jurl": ["juri", "gurl", "Jurl", "jeturi", " jcoll", "ajURL", "jjURL", " jfile", "jjurl", "jURL", "JUrl", "jjob", "jpurl", "jetfile", "Jcoll", "Juri", "jhttp", "jcoll", "nconnection", "Jjob", " jjob", " jURL", "gURL", "ajurl", "nurl", " jhttp", "jeturl", "jphttp", "jfile", "jUrl", "jconnection", "JURL", "jpjob", "jpURL", "nURL", "gconnection", "Jhttp", "jjcoll", "Jfile", "gUrl", "nUrl", "jjfile", "jetURL", "Jconnection", "ajfile", "ajuri"], "je": ["ne", "su", "fr", "la", "j", "obj", "oe", "ie", "java", "jen", "e", "ee", "ze", "py", "jj", "Obj", "ja", "li", "se", "jl", "esi", " ze", "zip", "jp", "ni", "ju", "ji", "Je", "kee", "oi", "pse", "elt", "js", "si", "jar", "opy", "jo"], "is": ["lis", "os", "ai", "in", "mis", "Is", "obj", "ie", "iso", "isl", "isin", "isa", "oss", "i", "src", "bs", "s", "ois", "its", "ib", "bb", "il", "ses", "sin", "isi", "es", "address", "ris", "IS", "info", "ui", "state", "iss", "http", "ios", "ori", "li", "nis", "ii", "ob", "cos", "ir", "iris", "ais", "api", "zip", "ri", "are", "so", "vs", "as", "js", "si", "uri", "jar", "self"], "bis": ["lis", "os", "mis", "Is", "obj", "connection", "oss", "isin", "oris", "i", "bus", "bs", "s", "proxy", "ois", "slice", "bb", "ls", "usb", "abi", "ses", "sin", "sb", "ris", "IS", "boot", "iss", "obs", "cos", "ios", "bps", "ubis", "nis", "fb", "bes", "ori", "http", "ob", "ignore", "iris", "inner", "bi", "abs", "pi", "bits", "binary", "serv", "base", "zip", "ri", "download", "di", "bin", "bos", "obb", "uri", "afi", "lock", "cb", "uds"], "size": ["large", "rate", "shape", "sync", "ize", "capacity", "sec", "cel", "term", "form", "rc", "use", "init", "eng", "sized", "cr", "sn", "ci", "core", "address", "loc", "sum", "content", "grade", "time", "cm", "se", "send", "now", "esc", "len", "en", "area", "close", "enc", "unit", "iz", "scale", "mode", "Size", "err", "range", "cl", "width", "co", "name", "small", "body", "si", "speed", "act", "hh", "SIZE", "length"], "rb": ["lr", "r", "abb", "bf", "rd", "rl", "src", "rc", "lb", "zb", "bb", "cr", "rx", "sb", "loc", "ru", "fb", "adr", "rab", "io", "ob", "rh", "gb", "rr", "ra", "pb", "nr", "rar", " rc", "sr", "reb", "rf", "buf", "eb", "wb", "area", "ri", "range", "rt", "RB", "rub", "vr", "xb", "rg", "obb", "nb", "orb", "ruby", "cb", "rob", "erb"], "chunk": ["chunky", " Chunk", "clunks", "boy", " chack", "bink", "pask", "clone", "shink", "cheunk", "shunk", "Chunk", "quunk", "bone", "punky", "chrow", " chunks", "cheink", "CHunc", "schunk", "chone", "Chunks", "shoy", "chunks", "CHunk", "clunc", "chink", "qurow", "quunky", "shone", "schrow", "schask", "clunk", "cheunks", " Chack", " Chunks", "chunc", "choy", "schunky", "cheunc", "CHunks", "chack", "Chack", "punk", "chask", "CHink", "cloy", "bunk", "prow", "clink", "quask"]}}
{"id1": "21979462", "id2": "11704429", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "    public void run() {\n        RandomAccessFile file = null;\n        InputStream stream = null;\n        try {\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestProperty(\"Range\", \"bytes=\" + downloaded + \"-\");\n            connection.connect();\n            if (connection.getResponseCode() / 100 != 2) {\n                error();\n            }\n            int contentLength = connection.getContentLength();\n            if (contentLength < 1) {\n                error();\n            }\n            if (size == -1) {\n                size = contentLength;\n                stateChanged();\n            }\n            file = new RandomAccessFile(destination, \"rw\");\n            file.seek(downloaded);\n            stream = connection.getInputStream();\n            while (status == DOWNLOADING) {\n                byte buffer[];\n                if (size - downloaded > MAX_BUFFER_SIZE) {\n                    buffer = new byte[MAX_BUFFER_SIZE];\n                } else {\n                    buffer = new byte[size - downloaded];\n                }\n                int read = stream.read(buffer);\n                if (read == -1) break;\n                file.write(buffer, 0, read);\n                downloaded += read;\n                stateChanged();\n            }\n            if (status == DOWNLOADING) {\n                status = COMPLETE;\n                stateChanged();\n            }\n        } catch (Exception e) {\n            error();\n        } finally {\n            if (file != null) {\n                try {\n                    file.close();\n                } catch (Exception e) {\n                }\n            }\n            if (stream != null) {\n                try {\n                    stream.close();\n                } catch (Exception e) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"downloadURLtoString": [" downloadURLtoLong", " downloadUrltoLong", " downloadURLasStr", " downloadURLtostring", " downloadUrlasString", " downloadUrltostring", " downloadUrlasLong", " downloadURLasString", " downloadUrlasstring", " downloadURL2string", " downloadURLasstring", " downloadUrltoStr", " downloadURL2Long", " downloadURLasLong", " downloadURLintoLong", " downloadURLtoStr", " downloadUrltoString", " downloadURL2String", " downloadUrlasStr", " downloadURL2Str", " downloadURLintoString", " downloadURLintostring", " downloadURLintoStr"], "url": ["lr", "image", "job", "buffer", "service", "sl", "el", "user", "page", "server", "rule", "address", "bel", "loc", "connection", "http", "URL", "resource", "path", "ref", "ssl", "file", "link", "f", "Url", "base", "data", "gl", "loader", "b", "name", "l", "remote", "uri", "source", "config"], "in": ["r", "db", "fr", "buffer", "h", "ic", "n", "inn", "gin", "isin", "read", "i", "is", "s", "init", "impl", "input", "ln", "rx", "din", "lin", "af", "fb", "inner", "nin", "ssl", "out", "ini", "into", "at", "min", "f", "ilo", "login", "data", "err", "b", "it", "ins", "bin", "In", "reader", "IN", "again", "as", "cms", "re", "source", "ac", "inc"], "sb": ["lr", "db", "abb", "bp", "buffer", "bf", "src", "lb", "bs", "s", "zb", "SB", "bt", "amb", "ib", "bb", "ls", "usb", "sa", "sf", "sg", "bc", "rb", "bm", "fb", "kb", "mb", "buff", "gb", "Bs", "pb", "ub", "bh", "B", "bd", "eb", "buf", "wb", " SB", "BB", "b", "bsp", "xb", "obb", " eb", "si", "nb", "lab", "sth", "sv", "cb", "erb"], "str": ["STR", "r", "fr", "txt", "sl", "obj", "br", "n", "i", "key", "s", "cr", "lc", "Str", "stri", "coll", "result", "dr", "bl", "exp", "cur", "line", "wr", "sr", "iter", "f", "st", "pass", "enc", "doc", "data", "err", "div", "b", "char", "spec", "cl", "text", "ct", "arr", "name", "l", "string", "list", "tr", "read", "pr", "sp"]}}
{"id1": "3266833", "id2": "11305840", "code1": "    public MotixFileItem(final InputStream is, final String name, final String contentType, final int index) throws IOException {\n        this.name = name;\n        this.contentType = contentType;\n        this.index = index;\n        this.extension = FilenameUtils.getExtension(this.name);\n        this.isImage = ImageUtils.isImage(name);\n        ArrayInputStream isAux = null;\n        final ByteArrayOutputStream out = new ByteArrayOutputStream();\n        try {\n            IOUtils.copy(is, out);\n            isAux = new ArrayInputStream(out.toByteArray());\n            if (this.isImage) {\n                this.bufferedImage = imaging.read(isAux);\n            }\n        } finally {\n            IOUtils.closeQuietly(out);\n            IOUtils.closeQuietly(isAux);\n        }\n        this.inputStream = new ArrayInputStream(out.toByteArray());\n    }\n", "code2": "    public boolean setUpdateCliente(int IDcliente, String nombre, String paterno, String materno, String ocupacion, String rfc) {\n        boolean update = false;\n        try {\n            stm = conexion.prepareStatement(\"update clientes set nombre='\" + nombre.toUpperCase().trim() + \"' , paterno='\" + paterno.toUpperCase().trim() + \"' ,\" + \"materno='\" + materno.toUpperCase().trim() + \"',ocupacion='\" + ocupacion.toUpperCase().trim() + \"',rfc='\" + rfc.trim() + \"' where IDcliente ='\" + IDcliente + \"' \");\n            stm.executeUpdate();\n            conexion.commit();\n            update = true;\n        } catch (SQLException e) {\n            System.out.println(\"error al actualizar registro en la tabla clientes  \" + e.getMessage());\n            try {\n                conexion.rollback();\n            } catch (SQLException ee) {\n                System.out.println(ee.getMessage());\n            }\n            return update = false;\n        }\n        return update;\n    }\n", "label": 0, "substitutes": {"is": ["lis", "get", "image", "os", "ip", "in", "mis", "Is", "us", "bis", "iso", "isa", "i", "bs", "init", "was", "its", "ib", "id", "es", "ris", "isu", "IS", "info", "or", "iss", "ios", "isc", "has", "ir", "iris", "ais", "abs", "close", "im", "ins", "fits", "as", "cms", "iv", "ws"], "name": ["image", "domain", "large", "size", "term", "one", "n", "label", "key", "default", "title", "version", "parent", "id", "office", "directory", "address", "ame", "nice", "alias", "module", "connection", "format", "code", "path", "word", "description", "value", "file", "part", "NAME", "space", "min", "prefix", "no", "pass", "base", "this", "null", "url", "data", "type", "database", "Name", "search", "names", "memory", "string", "named", "vision", "source", "filename"], "contentType": ["contentPath", "ContentTypes", " contenttype", "messageName", " contentPoint", "sourcePoint", "contentInfo", "messageInfo", "outputPath", "sourceInfo", "ContentPath", "documenttype", " contentInfo", "mediaTypes", "documentType", "ContentType", "messagetype", "Contenttype", "mediaType", "outputName", "ContentInfo", "mediaName", "ContentName", "contenttype", "documentPoint", "contentTypes", "outputType", "contentPoint", "documentInfo", "sourceType", "mediaPath", "outputTypes", "sourcetype", "messageType", " contentName", "contentName"], "index": ["position", "image", "in", "error", "timeout", "level", "shape", "size", "alpha", "i", "key", "default", "multi", "slice", "input", "write", "height", "id", "page", "expression", "include", "address", "open", "pointer", "content", "weight", "pull", "value", "end", "x", "depth", "prefix", "none", "update", "axis", "data", "type", "append", "offset", "number", "Index", "search", "width", "body", "string", "list", "fix", "length", "inc"], "extension": ["variuration", "variance", "Exturation", "variension", "Extensions", "Extance", "configensions", "configension", "exturation", "configance", "variensions", "configuration", "Extension", "extance", "extensions"], "isImage": ["IsFile", "ISVideo", "areInstance", "IsVideo", " isimage", "IsImage", " isMedia", " isVideo", "asimage", "ISFile", " isInstance", " isImages", "areImages", "areMedia", " isFile", "isImages", "areFile", " isPicture", "ISPicture", "isaFile", "isaMedia", "isVideo", "asImage", "ISImage", "IsPicture", "isPicture", "isFile", "isimage", "asInstance", "isMedia", "areImage", "isaImages", "asFile", "isaImage", "isInstance", "areimage"], "isAux": ["isAlux", " isHalux", "isAcux", "isOAlux", "asAex", "isAnux", "isAex", "isAcru", "isAslux", "isAExcept", "asAslux", "isAsExcept", "isHax", "isWaux", " isAlux", " isArrayxt", "isArrayxt", "asAux", "isArrayru", "isUex", "isAx", "asAExcept", "isUlux", "isAxt", "isAAux", "asAsUX", "asAUX", "isWaUX", "isArrayUX", "isAUX", "isAnUX", "isHalux", " isArrayUX", " isAUX", "asAsExcept", "isOAux", "isWax", "isAcxt", "isAsex", "isAsUX", "asAlux", "isAnlux", "isUUX", "isAru", " isAx", "asAsux", " isAxt", "isAAru", " isHaux", " isAru", "isAsx", " isArrayux", "isAnex", "isHaUX", "isAAxt", "isAAUX", "isOAExcept", " isArrayru", "isUux", " isHax", "isOAUX", "isWalux", "isAsux", "isUExcept", "isAcUX", "asAsex", "isArrayux", " isHaUX", "isHaux"], "out": ["Out", "image", "auto", "in", "next", "client", "plain", "error", "size", "buffer", "sync", "obj", "off", "output", "socket", "object", "user", "input", "version", "copy", "parent", "ex", "page", "cache", "conn", "result", "array", "exp", "ext", "a", "io", "inner", "word", "pool", "at", "file", "work", "part", "post", "prefix", "this", "o", "exec", "null", "base", "data", "temp", "over", "table", "OUT", "again", "project", " in", "outs", "outer", "extra", "source", "up"], "bufferedImage": ["BufferingImage", "bufferingImage", "buffendedimage", "buffledimage", "bufferingimage", "Bufferingimage", "Bufferedimage", "BufferedImage", "buffledImage", "bufferedimage", "buffendedImage"], "inputStream": ["outputBuffer", "outputStream", "inputSteam", "InputBuffer", "outputstream", "InputStream", "inputBuffer", " inputSteam", "InputSteam", "Inputstream", " inputstream", " inputBuffer", "outputSteam", "inputstream"]}}
{"id1": "3252116", "id2": "16719805", "code1": "    public static String getMD5(String source) {\n        String s = null;\n        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            byte tmp[] = md.digest();\n            char str[] = new char[16 * 2];\n            int k = 0;\n            for (int i = 0; i < 16; i++) {\n                byte byte0 = tmp[i];\n                str[k++] = hexDigits[byte0 >>> 4 & 0xf];\n                str[k++] = hexDigits[byte0 & 0xf];\n            }\n            s = new String(str);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n", "code2": "    public static void copyFile(File from, File to) throws IOException {\n        if (from.isDirectory()) {\n            if (!to.exists()) {\n                to.mkdir();\n            }\n            File[] children = from.listFiles();\n            for (int i = 0; i < children.length; i++) {\n                if (children[i].getName().equals(\".\") || children[i].getName().equals(\"..\")) {\n                    continue;\n                }\n                if (children[i].isDirectory()) {\n                    File f = new File(to, children[i].getName());\n                    copyFile(children[i], f);\n                } else {\n                    copyFile(children[i], to);\n                }\n            }\n        } else if (from.isFile() && (to.isDirectory() || to.isFile())) {\n            if (to.isDirectory()) {\n                to = new File(to, from.getName());\n            }\n            FileInputStream in = new FileInputStream(from);\n            FileOutputStream out = new FileOutputStream(to);\n            byte[] buf = new byte[32678];\n            int read;\n            while ((read = in.read(buf)) > -1) {\n                out.write(buf, 0, read);\n            }\n            closeStream(in);\n            closeStream(out);\n        }\n    }\n", "label": 0, "substitutes": {"getMD5": [" getSHA5", " getMD3", " getMD512", "getSHA5", "getSHA512", "getMD4", "getMAC5", "getMD3", "getSHA4", " getSHA3", "getMP4", " getMD4", "getSHA3", "getMP3", "getMD512", "getMAC512", "getMAC4", "getMAC3", "getMP512", " getSHA4", " getSHA512", "getMP5"], "source": ["buffer", "service", "sl", "stream", "src", "output", "object", "input", "slice", "e", "parent", "from", "target", "result", "code", "connection", "content", "resource", "fp", "dest", "file", "Source", "f", "url", "this", "base", "security", "data", "SOURCE", "secret", "text", "document", "password", "body", "string", "uri", "ource", "config", "sp"], "s": ["r", "S", "os", "m", "h", "p", "bytes", "sl", "bis", "n", "g", "is", "strings", "its", "rs", "ls", "e", "ns", "ses", "t", "sb", "es", "sg", "services", "results", "ssl", "sym", "ds", "ings", "f", "fs", "sets", "series", "b", "ends", "rows", "ins", "ops", "als", "ss", "d", "string", "si", "js", "ps", "gs", "ws", "ts"], "hexDigits": [" hexDigit", "hexFormitives", "hexDigings", "hexDigats", "hexSignings", "tempDigites", "hexSignists", "hexDigists", "hexDigitives", "hexdigases", " hexDigings", "hexFormists", "hexdigit", "hexFormits", "hexdigals", "hexDigites", "tempSignites", "hexEdists", "hexdigats", "hashFormits", "hexdigists", "hashDigitives", "hexSignitives", "hashDigists", "hashFormitives", "hexFormats", "hexEdals", "hashDigats", "tempSignals", "hexdigings", "hexDigit", "hexSignats", "hexdigits", "hashDigits", "hexEdits", "tempSignits", "hexDigals", " hexDigases", "hexEdites", "hexdigitives", "hexSignals", "tempDigals", "hexDigases", "hashFormists", "hexdigites", "hexSignases", "tempSignists", "hexSignit", "tempDigists", "hexSignites", "tempDigits", "hexSignits", "hashFormats"], "md": ["mm", "mac", "m", "dig", "bf", "mad", "mu", "pd", "metadata", "um", "ma", "cd", "dc", "rm", "mb", "cm", "amd", "nm", "df", "wd", "mand", "mail", "bd", "f", "sm", "mg", "dm", "pm", "mi", "em", "sha", "mt", "MD", "mp", "di", "mc", "hd", "mag", "rpm", "vd", "am", "meta", "cmd", "dd", " MD"], "tmp": ["pad", "bp", "buffer", "p", "txt", "obj", "pp", "bt", "pre", "app", "stuff", "cb", " temp", "pointer", "rb", "array", "fb", "params", "buff", "img", "proc", "dest", "now", "sup", "storage", "ppo", "area", "buf", "api", "base", "data", "temp", "append", "v", "test", "wp", "cpp", "mp", "seed", "meta", "cmp", "extra", "np", "config", "sp"], "str": ["STR", "r", "fr", "j", "txt", "obj", "sl", "br", "pos", "sec", "cs", "ctr", "dict", "dec", "cr", "Str", "stri", "dr", "code", "exp", "inner", "cur", "hr", "part", "iter", "sr", "enc", "st", " sp", "unit", "doc", "exec", "data", "div", "err", "temp", "char", "v", "spec", "text", "arr", "style", "ss", "string", "tr", " substr", "pr", "hex", "sp"], "k": ["kick", "K", "ck", "ki", "j", "p", "ok", "n", "g", "q", "key", "mk", "ek", "sk", "e", "id", "ak", "ku", "ks", "ko", "unk", "work", "x", "f", "ch", "o", "kw", "u", "dk", "b", "y", "v", "w", "kk", "kat", "d", "kid", "c"], "i": ["ai", "ip", "in", "m", "j", "p", "n", "multi", "e", "phi", "abi", "gi", "ci", "mu", "t", "ui", "info", "a", "li", "index", "ii", "io", "iu", "z", "ini", "bi", "x", "pi", "f", "xi", "ti", "ri", "u", "b", "y", "v", "ji", "oi", "it", "di", "hi", "l", "d", "si", "chi", "qi", "uri", "shift", "I", "c"], "byte0": ["bytek", " byte2", "pixelk", "number5", "word0", " byte6", "word2", "number6", "byte1", "number00", "pixel2", "byte00", " byte5", "numberk", "byte6", "pixel00", " byte00", "letter00", "byte2", "pixel6", "byte5", "letter0", "number1", "word5", "word1", "letter2", "letterk", "number0", " byte1", "pixel5", "pixel0", "number2"]}}
{"id1": "2022160", "id2": "21491791", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "label": 1, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "19738435", "id2": "481364", "code1": "    public Resource parse(URL url, IRDFContainer target) throws RDFException, IOException {\n        parseURL = url;\n        URLConnection connection = url.openConnection();\n        if (charset == null) {\n            charset = Charset.forName(\"UTF-8\");\n        }\n        Reader reader = new InputStreamReader(connection.getInputStream(), charset);\n        return internalParse(reader, target);\n    }\n", "code2": "    private void downloadFiles() {\n        SwingWorker<Double, RaphPhotoGalleryPhoto> downloadFilesWorker = new SwingWorker<Double, RaphPhotoGalleryPhoto>() {\n\n            Date startDownloadDate;\n\n            @Override\n            public Double doInBackground() {\n                startDownloadDate = new Date();\n                refreshSpeed = 0;\n                lastDate = null;\n                try {\n                    int totalSizeRead = 0;\n                    int totalNumberRead = 0;\n                    for (RaphPhotoGalleryPhoto photo : photoList) {\n                        URL url = new URL(getCodeBase().toString() + photo.getUrl());\n                        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n                        DataInputStream dis = new DataInputStream(connection.getInputStream());\n                        FileOutputStream fos = new FileOutputStream(destinationDirectory.toString() + \"/\" + photo.getFileName());\n                        byte[] b = new byte[65536];\n                        int sizeRead;\n                        photo.setProcessedSize(0);\n                        totalNumberRead++;\n                        while ((sizeRead = dis.read(b)) > -1) {\n                            fos.write(b, 0, sizeRead);\n                            totalSizeRead += sizeRead;\n                            photo.addToProcessedSize(sizeRead);\n                            photo.setTotalProcessedSize(totalSizeRead);\n                            photo.setTotalProcessedNumber(totalNumberRead);\n                            publish(photo);\n                            try {\n                            } catch (Exception ignore) {\n                            }\n                        }\n                        fos.close();\n                    }\n                } catch (MalformedURLException e1) {\n                    System.err.println(\"MalformedURLException: \" + e1);\n                } catch (IOException e2) {\n                    System.err.println(\"IOException: \" + e2);\n                }\n                long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                double totalSpeed = photoListTotalSize / (totalDiffTime / 1000);\n                return new Double(totalSpeed);\n            }\n\n            @Override\n            protected void process(List<RaphPhotoGalleryPhoto> list) {\n                RaphPhotoGalleryPhoto photo = list.get(list.size() - 1);\n                progressBarTotal.setMaximum(photoListTotalSize);\n                progressBarTotal.setValue(photo.getTotalProcessedSize());\n                setProgressBarTotalLabels(photo.getTotalProcessedNumber(), photoList.size(), photoListTotalSize - photo.getTotalProcessedSize());\n                progressBarCurrent.setMaximum(photo.getFileSize());\n                progressBarCurrent.setValue(photo.getProcessedSize());\n                progressBarCurrentLabel.setText(photo.getFileName());\n                long diffTime = 0;\n                if (lastDate == null) lastDate = new Date();\n                diffTime = (new Date()).getTime() - lastDate.getTime();\n                if (diffTime > 1000) {\n                    double currentSpeed = (photo.getTotalProcessedSize() - lastTotalSize) / (diffTime / 1000.0);\n                    if (currentSpeed > 0) lastSpeed.add(new Double(currentSpeed));\n                    if (lastSpeed.size() == 10) lastSpeed.removeFirst();\n                    double speed = 0;\n                    for (Double d : lastSpeed) {\n                        speed += d.doubleValue();\n                    }\n                    speed = Math.round(speed / lastSpeed.size());\n                    if (refreshSpeed == 0) {\n                        long totalDiffTime = (new Date()).getTime() - startDownloadDate.getTime();\n                        double totalSpeed = (photo.getTotalProcessedSize()) / (totalDiffTime / 1000.0);\n                        remainingTime = (photoListTotalSize - photo.getTotalProcessedSize()) / totalSpeed;\n                        if (remainingTime < 8) refreshSpeed = 0; else refreshSpeed = 3;\n                    } else {\n                        refreshSpeed--;\n                        remainingTime -= diffTime / 1000.0;\n                    }\n                    speedLabel.setText(String.format(\"%.0f\", speed / 1024) + \" \" + getParameter(\"i18n_speedUnit\") + \" :  \" + String.format(\"%.0f\", remainingTime) + \" s\");\n                    lastDate = new Date();\n                    lastTotalSize = photo.getTotalProcessedSize();\n                }\n            }\n\n            @Override\n            protected void done() {\n                try {\n                    speedLabel.setText(String.format(\"%.0f\", get().doubleValue() / 1024) + \" \" + getParameter(\"i18n_speedUnit\"));\n                    downloadButton.setText(getParameter(\"i18n_finished\"));\n                    downloadState = 2;\n                } catch (Exception ignore) {\n                }\n            }\n        };\n        downloadFilesWorker.execute();\n    }\n", "label": 0, "substitutes": {"parse": ["request", "get", "process", "match", "load", "arse", "instance", "Parser", "run", "open", "apply", "replace", "from", "source", "format", "resource", "se", "pack", " parser", "find", "start", "link", "set", "parser", "add", "read", "create"], "url": ["request", "image", "error", "r", "absolute", "client", "buffer", "element", "entry", "stream", "src", "host", "object", "feed", "proxy", "input", "e", "page", "server", "address", "conn", "http", "location", "URL", "resource", "path", "io", "ssl", "file", "str", "link", "Url", "api", "base", "channel", "loader", " URL", "text", "document", "l", "string", "ur", "uri", "source", "config"], "target": ["timeout", "component", "ctx", "host", "output", "class", "object", "context", "reference", "parent", "t", "address", "to", " Target", "result", "format", "pointer", "content", "container", "response", "resource", "path", "resources", "root", "this", "data", "Target", "collection", "document", "node", "arget", "project", "event", "current", "source", "config"], "parseURL": ["parserURL", " parseUrl", "readURL", "parserUrl", "parseResource", "parseUrl", "readUrl", "parserResource", " parseResource", "readType", "parserType", " parseType", "parseType", "readResource"], "connection": ["db", "timeout", "client", "connect", "writer", "service", "creator", "ctx", "relation", "context", "character", "section", "directory", "handler", "conn", "open", "or", "bc", "container", "response", "resource", "io", "pool", "out", "con", "function", "director", "which", "connected", "normal", "channel", "database", "application", "text", "ion", "body", "Connection", "uri", "source", "config", "c"], "charset": ["Charsec", "chARSetter", "chipsect", "chasec", "chipseting", "ChasET", "charsets", "chaseting", "choipseting", "chansec", "chansect", "chapterset", "Chasetter", "chaset", "Charset", "Chaset", "charseting", "charsect", "chipsET", "chanset", "ChARSet", "chipsec", "chaptersetter", "ChARSET", "chaptersET", "ChARSec", "chipsets", "chARSET", "choarsET", "chARSet", "Charsetter", "chaptersec", "choarseting", "choipsets", "choarsets", "chARSect", "charsetter", "ChARSect", "chansET", "CharsET", "Charsect", "charsec", "chipset", "choipset", "charsET", "choarset", "Chasec", "chARSec", "chasET", "choipsET", "chasetter", "chasets"], "reader": ["r", "in", "writer", "worker", "Reader", "entry", "stream", "i", "object", "feed", "context", "input", "handler", "server", "per", "or", "ler", "pointer", "container", "resource", "io", "rr", "keeper", "row", "reading", "director", "rar", "iter", "x", "channel", "data", "loader", "er", "oder", "driver", "parser", "read", "source"]}}
{"id1": "2022160", "id2": "7891509", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "7087108", "id2": "1598693", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static String retrieveData(URL url) throws IOException {\n        URLConnection connection = url.openConnection();\n        connection.setRequestProperty(\"User-agent\", \"MZmine 2\");\n        InputStream is = connection.getInputStream();\n        if (is == null) {\n            throw new IOException(\"Could not establish a connection to \" + url);\n        }\n        StringBuffer buffer = new StringBuffer();\n        try {\n            InputStreamReader reader = new InputStreamReader(is, \"UTF-8\");\n            char[] cb = new char[1024];\n            int amtRead = reader.read(cb);\n            while (amtRead > 0) {\n                buffer.append(cb, 0, amtRead);\n                amtRead = reader.read(cb);\n            }\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        is.close();\n        return buffer.toString();\n    }\n", "label": 0, "substitutes": {"doGet": ["processDownload", "processGET", "doGET", " doGET", " doPut", "doPut", "doDownload", "didGET", "didPut", "processGet", "processPut", "didGet", " doDownload", "didDownload"], "request": ["error", "client", "buffer", "self", "query", "host", "view", "object", "use", "context", "user", "input", "instance", "version", "parent", "route", "server", "json", "complete", "child", "info", "result", "target", "connection", "http", "resource", "report", "message", "xml", "url", "req", "forward", "this", "model", "data", "type", "builder", "subject", "application", "method", "name", "Request", "external", "reader", "project", "string", "web", "QUEST", "uri", "event", "current", "create", "config", "condition"], "response": ["image", "client", "writer", "service", "output", "reply", "view", "object", "version", "reference", "page", "server", "json", "cache", "example", "result", "connection", "content", "http", "resource", "message", "report", "results", "Response", "out", "resp", "model", "collection", "status", "application", "wave", "method", "document", "site", "remote", "respond", "body"], "path": ["image", "PATH", "p", "key", "output", "pattern", "object", "route", "id", "directory", "cache", "info", "format", "Path", "location", "content", "http", "message", "resource", "index", "out", "value", "config", "dir", "url", "base", "data", "text", "method", "name", "ath", "string", "filter", "point", "folder", "uri", "filename"], "file": ["image", "h", "full", "files", "up", "class", "socket", "object", "use", "feed", "route", "directory", "handler", "File", "rule", "fe", "info", "to", "child", "connection", "http", "resource", "fp", "out", "function", "FILE", "work", "part", "dir", "f", "url", "lib", "base", "zip", "data", "pe", "b", "log", "local", "it", "name", "l", "le", "folder", "uri", "lock", "source", "filename"], "in": ["r", "pin", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "copy", "thin", "id", "din", "ax", "lin", "inner", "resource", "nin", "out", "ini", "con", "kin", "rin", "f", "binary", "serv", "login", "data", "ac", "b", "it", "ins", "bin", "In", "reader", "IN", "as", "win", "source", "c", "inc"]}}
{"id1": "14688886", "id2": "20602651", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 1, "substitutes": {"populateResources": ["compureResource", "poputeRelations", "compureRelations", "popractResources", "poputeResource", "populateRelations", "popureFiles", "poputeFiles", "poputeResources", "compulateFiles", "compureResources", "popureResources", "compulateRelations", "compureFiles", "popractFiles", "compulateResources", "popureResource", "populateResource", "popureRelations", "compulateResource", "popractRelations", "populateFiles", "popractResource"], "templates": ["Template", "template", "filens", "Temeters", "temures", "filures", "templateps", "templateples", "stemples", "tomplates", "prompl", "Temens", "templateplates", "Templ", " temures", "promplate", "promplates", "temps", " templ", "stemplates", "tempplates", "Temples", "Temps", "stempl", "temeters", "tompl", "typlates", "tometers", "stemps", "temples", "tempplate", "filpl", "typs", "templ", "prometers", "temppl", " temens", "templatepl", "tempps", "typlate", "Templates", "typl", "tomplate", "temens", "Temures", "filplates"], "url": ["image", "r", "job", "template", "buffer", "service", "email", "sl", "html", "entry", "host", "pattern", "object", "el", "feed", "fl", "il", "e", "route", "page", "server", "address", "connection", "http", "location", "URL", "resource", "path", "ob", "xml", "ssl", "file", "config", "link", "f", "Url", "channel", "base", "data", "download", " URL", "name", "l", "string", "href", "uri", "pl", "source", "filename"], "fileName": ["FileKey", "resourcePath", "stringType", "FileType", "stringName", " fileTime", "fDir", " fileInfo", "sourceName", "FileName", "filenameName", "filePart", "fileDir", "FileFull", "fileSync", " fileDir", "filePath", "fileTime", " filePart", "folderPath", "foldername", "sourceInfo", " fileKey", "folderPart", "fileString", "objectTime", "fname", "FileDir", "modelname", "fileSystem", " fileSystem", "FILELocation", " fileDirectory", "fileDirectory", "resourcePart", "FILESync", "filenamename", "stringDirectory", "modelLocation", "sourcename", "Filename", " fileLength", "sourceString", "FILESystem", "fileType", " fileType", "folderName", " fileSync", "resourcename", "fName", " filePath", "filenameString", " fileLocation", "fKey", "resourceName", "filenameType", "objectname", " filename", "filename", "objectName", "sourceLength", "fileLength", " fileFull", "filenameFull", "fileLocation", "FILEname", "modelName", "FileDirectory", "modelSystem", "filenameLength", "fileFull", "fileInfo", "fileKey", "FileInfo", "FileString", " fileString", "objectSync", "FILETime", "FILEName"], "templateResource": ["tempFile", "eventReader", " templateFile", "plateResource", "translationContent", "plateContainer", "copyUrl", "templateUrl", "translationRing", "templateReader", "privateResource", "privateUrl", "xmlFile", "templateresource", "xmlRole", "layoutResource", "templateType", "privateresource", "translationContainer", "eventresource", "tempResource", "translationResource", "layoutRing", "templateRing", "templateFile", " templateType", "plateRing", "templateContent", "templateContainer", "privateReader", "copyresource", "eventUrl", "xmlType", "tempRole", "copyReader", "plateContent", "xmlResource", "copyResource", "tempType", "eventResource", " templateRole", "templateRole", "layoutContent", "layoutContainer"], "is": ["lis", "r", "os", "in", "ip", "irc", "Is", "bis", "iso", "isl", "isa", "src", "s", "app", "its", "was", "ib", "isi", "ris", "IS", "iss", "rss", "ios", "isc", "ori", "nis", "io", "has", "ir", "out", "iris", "abs", "ais", "api", "serv", "ri", "im", "it", "ar", "as", "cms", "uri"], "strBuff": ["brBuff", "arrBuffer", "strGrab", "rBuffer", "StrText", "brBuffer", "StrTab", " strBuffer", " strTab", " strbuff", "StrBuffer", "strbuff", "stringFlow", "strText", " strGrab", "strTab", " strPref", "stringGrab", "rBuff", "StrBuff", "Strbuff", "stringBuffer", "brFlow", "strBuffer", " strFlow", "StrPref", "arrTab", "stringBuff", "brGrab", "strFlow", " strText", "arrPref", "arrBuff", "rText", "strPref", "rbuff"], "br": ["r", "gr", "fr", "Reader", "stream", "ctr", "cr", "result", "dr", "bc", "rb", "bl", "ber", "ori", "io", "Br", "bro", "hr", "nr", "sr", "mr", "buf", " reader", "data", "div", "err", "b", "bar", "er", "BR", "brush", "text", "arr", "yr", "browser", "res", "reader", "tr", "orb", "cb", "sp"], "str": ["STR", "r", "sc", "fr", "strike", "p", "sl", "sec", "key", "cr", "lc", "Str", "stri", "t", "coll", "or", "dr", "cur", "line", "wr", "hr", "sr", "iter", "f", "oct", "st", "enc", "data", "type", "err", "div", "char", "er", "spec", "kr", "cl", "text", "star", "arr", "name", "style", "string", "tr", "pr", "sp"], "images": ["image", "letters", "ups", "words", "scripts", "styles", "models", "people", "assets", "files", "types", "boxes", "holes", "tags", "xs", "dates", "sites", "games", "gallery", "ages", "events", "ips", "picture", "features", "objects", "rooms", "quarters", "media", "bands", "services", "jobs", "resources", "frames", "apps", "ions", "pieces", "icons", "png", "classes", "pages", "opens", "inches", "agents", "gif", "ims", "users", "groups", "views", "ins", "versions", "shows", "videos", "stars", "lights", "thumbnails", "Images", "photos", "tests", "flows", "plugins"], "i": ["image", "j", "key", "s", "ci", "gi", "info", "format", "http", "x", "this", "u", "v", "yi", "uri", "I", "ind", "ip", "p", "html", "eni", "multi", "fi", "phi", "diff", "index", "li", "io", "iu", "gu", "bi", "ti", "b", "mi", "d", "si", "ai", "in", "app", "slice", "e", "id", "cli", "lc", "z", "ini", "Url", "xi", "y", "ji", "it", "hi", "chi", "add", "ie", "n", "mu", "ui", "ii", "xml", "_", "ij", "uni", "pi", "f", "ni", "di", "qi", "config"], "img": ["att", "image", "fw", "iframe", "m", "icon", "p", "sl", "jpg", "ie", "src", "ff", "tmp", "app", "map", "input", "fig", "gallery", "ng", "cb", "info", "bg", "fb", "inst", "ext", "li", "bl", "exp", "file", "gd", "hr", "png", "f", "ch", "lib", "imp", "abc", "data", "ani", "gif", "im", "v", "norm", "arr", "small", "aut", "tif", "aff", "config"], "imgProperty": ["cachePro", " imgProp", "imgPro", "cacheImage", "bgPro", "cacheProperty", " imgPro", " imgImage", "imgProp", "bgImage", "imgImage", "bgProp", "cacheProp", "bgProperty"]}}
{"id1": "20426057", "id2": "11952735", "code1": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "code2": "    public static boolean copyFile(String sourceName, String destName) {\n        FileChannel sourceChannel = null;\n        FileChannel destChannel = null;\n        boolean wasOk = false;\n        try {\n            sourceChannel = new FileInputStream(sourceName).getChannel();\n            destChannel = new FileOutputStream(destName).getChannel();\n            destChannel.transferFrom(sourceChannel, 0, sourceChannel.size());\n            wasOk = true;\n        } catch (Throwable exception) {\n            logger.log(Level.SEVERE, \"Exception in copyFile\", exception);\n        } finally {\n            try {\n                if (sourceChannel != null) sourceChannel.close();\n            } catch (Throwable tt) {\n            }\n            try {\n                if (destChannel != null) destChannel.close();\n            } catch (Throwable tt) {\n            }\n        }\n        return wasOk;\n    }\n", "label": 0, "substitutes": {"createKeyStore": ["createKeyChain", "createSecretStore", "createSecretstore", "createTrustChain", "getKeyChain", "getKeyFactory", "createSecretFactory", "createTrustFactory", "createKeystore", "createkeyStore", "createTrustStore", "createTruststore", "getkeyStore", "createkeyFactory", "getkeyFactory", "createkeyChain", "createKeyFactory", "createSecretChain", "getkeystore", "createkeystore", "getkeyChain", "getKeystore", "getKeyStore"], "url": ["image", "db", "client", "buffer", "service", "email", "sl", "html", "entry", "stream", "src", "host", "key", "class", "el", "proxy", "feed", "id", "page", "server", "coll", "address", "plus", "loc", "connection", "filename", "http", "location", "URL", "resource", "path", "ref", "ob", "xml", "ssl", "manager", "file", "str", "store", "f", "Url", "lib", "api", "base", "zip", "data", "gl", "loader", "log", "org", "ll", " URL", "text", "l", "string", "uri", "source", "config", "www"], "password": ["pad", "words", "p", "fax", "crypt", "key", "pattern", "help", "attribute", "patch", "sword", "address", "phrase", "alias", "padding", "Password", "array", "path", "params", "word", "PASS", "work", "wd", "prefix", "pass", "channel", "api", "wallet", "data", "press", "secret", "token", "language", " passwords", "name", "auth", "string", "seed", "hash", "column", "username"], "keystore": ["webStore", "trustspace", "lockbase", "kstore", " keyspace", " keycache", "kbase", "kserver", "KeyStore", "lockstore", "webserver", "truststore", "keybase", "keytool", "keyspace", "webstorage", " keytool", "truststorage", "Keystore", "Keybase", " keystorage", "keyserver", "lockstorage", "Keystorage", "keystorage", "webstore", "signstorage", "Keytool", "signtool", "keyStore", "kcache", " keyStore", "Keycache", "lockspace", "Keyserver", " keybase", "signstore", "keycache", "signbase", "trustbase", " keyserver", "kStore"]}}
{"id1": "947406", "id2": "8788371", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private void tail(String[] cmd, int pos) throws IOException {\n        CommandFormat c = new CommandFormat(\"tail\", 1, 1, \"f\");\n        String src = null;\n        Path path = null;\n        try {\n            List<String> parameters = c.parse(cmd, pos);\n            src = parameters.get(0);\n        } catch (IllegalArgumentException iae) {\n            System.err.println(\"Usage: java FsShell \" + TAIL_USAGE);\n            throw iae;\n        }\n        boolean foption = c.getOpt(\"f\") ? true : false;\n        path = new Path(src);\n        FileSystem srcFs = path.getFileSystem(getConf());\n        if (srcFs.isDirectory(path)) {\n            throw new IOException(\"Source must be a file.\");\n        }\n        long fileSize = srcFs.getFileStatus(path).getLen();\n        long offset = (fileSize > 1024) ? fileSize - 1024 : 0;\n        while (true) {\n            FSDataInputStream in = srcFs.open(path);\n            in.seek(offset);\n            IOUtils.copyBytes(in, System.out, 1024, false);\n            offset = in.getPos();\n            in.close();\n            if (!foption) {\n                break;\n            }\n            fileSize = srcFs.getFileStatus(path).getLen();\n            offset = (fileSize > offset) ? offset : fileSize;\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                break;\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "clone", "p", "sync", "cp", "transfer", "Copy", "write", "cat", " cp", "replace", "Cop", "clip", "cop", "csv", "file", "zip", "download", "log", "paste", "put", "split", "it", " Copy", "cmp", "dump", " transfer"], "src": ["sc", "sl", "stream", "files", "rc", "use", "s", "input", "sit", "rs", "id", "sin", "sb", "loc", "source", "rb", "inst", "resource", "cur", "stab", "gb", "img", "fn", "dist", "config", "bh", "sel", "url", "data", "sq", "ins", "name", "string", "js", "href", "uri", "ource", "sub", "filename", "rob", "txt"], "dest": ["de", "obj", " Dest", "output", "delete", "class", "tmp", "comb", "opt", "thin", "const", "home", "Dest", "replace", "target", "result", "desc", "orig", "later", "img", "wd", "sup", "dist", "dir", "die", "st", "wb", "rest", "des", "temp", "flat", "done", "test", "name", "bin", "d", "prop", "folder", "destroy", "dat", "source", "txt"], "in": ["r", "m", "pin", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "cf", "din", "conn", "info", "diff", "lin", "a", "inner", "vin", "pull", "nin", "con", "ini", "rin", "kin", "work", "url", "lib", "pass", "base", "this", "login", "data", "err", "download", "b", "trans", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "issue", "source", "up", "inc"], "out": ["Out", "image", "os", "timeout", "client", "writer", "plain", "sync", "one", "off", "obj", "up", "output", "socket", "app", "init", "ou", "user", "write", "id", "ex", "aos", "cache", "conn", "or", "exp", "ext", "index", "our", "io", "inner", "exit", "nin", "pool", "img", "file", "at", "part", "x", "o", "no", "exec", "this", "lib", "data", "err", "vert", "log", "w", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "inc"], "buf": ["fab", "pad", "bp", "buffer", "bytes", "seq", "batch", "p", "bf", "ctx", "pos", "block", "br", "off", "ff", "ab", "fd", "rc", "queue", "bn", "fl", "loc", "result", "bc", "rb", "fb", "num", "orig", "ref", "cur", "buff", "raw", "count", "uc", "box", "len", "bh", "bag", "bd", "f", "feat", "data", "b", "cv", "v", "cap", "uf", "bin", "nb", "cb", "c"], "n": ["ind", "ne", "m", "j", "p", "size", "max", "i", "na", "nn", "write", "ns", "nt", "sn", "ng", "t", "N", "length", "dn", "nc", "index", "num", "nin", "z", "count", "nr", "len", "x", "en", "f", "no", "o", "k", "u", "b", "v", "w", "nd", "number", "rn", "l", "un", "d", "nb", "c"]}}
{"id1": "804637", "id2": "22552318", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private synchronized void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM non_generic_favs\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().matches(ERR_MISSING_TABLE)) {\n                e.printStackTrace(System.out);\n                throw new IOException(\"Error on initial data store read\");\n            }\n            String[] qry = { \"CREATE TABLE non_generic_favs (id INT NOT NULL PRIMARY KEY)\", \"CREATE TABLE ignore_chan_favs (id INT NOT NULL PRIMARY KEY, chanlist LONG VARCHAR)\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                }\n                e2.printStackTrace(new PrintWriter(System.out));\n                throw new IOException(\"Error initializing data store\");\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        e4.printStackTrace(System.out);\n                        throw new IOException(\"Unable to cleanup data store resources\");\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    e3.printStackTrace(System.out);\n                    throw new IOException(\"Unable to reset data store auto commit\");\n                }\n            }\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "7945594", "id2": "21013026", "code1": "    public static void fileDownload(String fAddress, String destinationDir) {\n        int slashIndex = fAddress.lastIndexOf('/');\n        int periodIndex = fAddress.lastIndexOf('.');\n        String fileName = fAddress.substring(slashIndex + 1);\n        URL url;\n        try {\n            url = new URL(fAddress);\n            URLConnection uc = url.openConnection();\n            BufferedReader in = new BufferedReader(new InputStreamReader(uc.getInputStream()));\n            File file = new File(destinationDir + \"/download.pdf\");\n            FileOutputStream fos = new FileOutputStream(file);\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos));\n            int inputLine;\n            while ((inputLine = in.read()) != -1) out.write(inputLine);\n            in.close();\n        } catch (Exception ex) {\n            Logger.getLogger(UrlDownload.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n", "code2": "    private InputStream getPageStream(String query) throws MalformedURLException, IOException {\n        URL url = new URL(baseUrl + query + \"&rhtml=no\");\n        URLConnection connection = url.openConnection();\n        connection.connect();\n        InputStream in = connection.getInputStream();\n        BufferedInputStream bis = new BufferedInputStream(in);\n        return bis;\n    }\n", "label": 0, "substitutes": {"fileDownload": [" filedownload", "filePull", "urlDownload", "folderDownload", "filedownload", " fileURL", "urlURL", "folderdownload", "folderPull", " filePull", "urldownload", "folderURL", "urlPull", "fileURL"], "fAddress": ["sfLocation", "bLocation", "urlOrder", "faddress", "FAddress", " faddress", "fileAdd", "faddr", "fEmail", "fingAdd", "fileLocation", "fOrder", "fileAddress", "bPath", "sfAddress", "bAddress", "sfPath", "rfMessage", "bEmail", "sfMessage", "sfOrder", "fLocation", "urladdress", "fPath", "fingaddr", "fAdd", " fPath", "FLocation", "fMessage", " fEmail", " faddr", "sfaddress", "rfaddress", " fMessage", "fingEmail", "urlAdd", "fingAddress", "baddress", "urlAddress", "rfLocation", "baddr", " fOrder", "sfAdd", "bAdd", "rfAddress", "FAdd", " fAdd", " fLocation"], "destinationDir": ["destinationPath", "DestinationDir", "destinationDirectory", "DestributionDir", "declinationDar", "destributionDir", "destippingArea", "destinationArea", "destativeDirectory", "DestinationArea", "declinationDur", "destativeArea", "destinePath", "destinatedPath", "DestributionArea", "destributionDirectory", "declinatedPath", "DestributionDirectory", "destativeDIR", "destinatedDir", "destributionDar", "declinationPath", "destippingDir", "destinationDar", "destineDir", "destativeDir", "destributionDIR", "declinatedDir", "destributionPath", "DestinationDirectory", "destippingDirectory", "destineDur", "destributionDur", "declinatedDar", "DestributionDIR", "declinationDir", "destinationDur", "destinatedDar", "destinatedDur", "destinationDIR", "declinatedDur", "destippingDIR", "DestinationDIR", "destineDar", "destributionArea"], "slashIndex": ["sllashCount", "slushindex", "SlashLength", "slushIndex", "Slashindex", "slargeCount", "slashindex", "slashedindex", "SlashedLength", "sllashindex", "sllashIndex", "SlashIndex", "slargeindex", "slargeLength", "slashedIndex", "slashedCount", "slashedLength", "slashLength", "SlashedCount", "slargeIndex", "SlashedIndex", "slashCount", "sllashLength", "Slashedindex", "slushLength", "SlashCount"], "periodIndex": ["dollarOffset", "dollarStart", " periodOffset", " periodindex", "moneyindex", "moneyOffset", "dollarIndex", "dollarindex", "moneyStart", "moneyIndex", " periodStart", "periodOffset", "periodStart", "periodindex"], "fileName": ["fname", "fPath", "FilePath", "fileAddress", "filePath", "Filename", "fName", " fileAddress", "FileName", " filePath", " filename", "filename", "FileAddress"], "url": ["image", "blog", "service", "sl", "ul", "rl", "up", "socket", "proxy", "feed", "ou", "user", "bug", "fl", "www", "page", "server", "bel", "open", "loc", "conn", "connection", "http", "li", "URL", "resource", "path", "oc", "ob", "ssl", "str", "link", "f", "Url", "uu", "api", "base", "ch", "channel", "plug", "download", "u", "log", "rel", "org", "ll", "l", "string", "web", "ur", "uri", "re", "config", "c"], "uc": ["sc", "union", "auc", "cus", "ul", "cci", "stream", "rc", "cc", "ou", "lc", "ci", "com", "conn", "um", "cu", "bc", "connection", "http", "nc", "hub", "cur", "oc", "con", "fc", "exc", "tc", "UC", "uci", "uu", "unc", "u", "ucc", "soc", "pc", "anc", "mc", "usc", "c", "ac", "ec"], "in": ["r", "image", "n", "inn", "stream", "gin", "i", "is", "rc", "socket", "s", "init", "cin", "input", "cli", "din", "conn", "lin", "inner", "io", "nin", "con", "ini", "into", "inside", "f", "this", "login", "ac", "data", "err", "b", "it", "ins", "bin", "In", "reader", "IN", "again", "source", "up", "c", "inc"], "file": ["full", "files", "up", "output", "socket", "class", "e", "parent", "page", "File", "rule", "per", "to", "fe", "connection", "path", "resource", "fp", "io", "line", "FILE", "book", "ile", "dir", "f", "letter", "o", "this", "base", "zip", "data", "b", "log", "name", "l", "place", "folder", "source", "filename"], "fos": ["sfOS", "FOs", "fileops", "fOS", "fileos", "fileOs", "sfo", "sfis", "fo", "Fos", "fileob", " fops", "Fops", " fob", "fOs", "sfos", "fob", " fo", "Fo", " fis", "fops", "FOS", "Fob", " fOS", " fOs", "Fis", "fis"], "out": ["Out", "plain", "writer", "sync", "block", "output", "s", "init", "ou", "write", "copy", "to", "inner", "io", "line", "work", "down", "f", "o", "exec", "update", "data", "err", "log", "b", "w", "net", "bin", "OUT", "again", "string", "outs", "outer", "flush", "up", "inc"], "inputLine": [" inputline", "outputBlock", "inputChar", "outputEl", "outputL", "InputL", "inputLINE", "errorLINE", "inputL", "inputRow", "InputChar", " inputL", "outputLINE", "outputLine", "inputEl", "outputline", " inputLINE", " inputBlock", " inputRow", "InputLine", " inputEl", " inputChar", "inputline", "errorRow", "inputBlock", "errorLine", "errorL", "outputRow", "outputChar", "Inputline", "InputEl", "InputBlock"]}}
{"id1": "6470716", "id2": "3958807", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "label": 1, "substitutes": {"st": ["ST", "r", "sts", "stage", "sc", "fr", "ast", "St", "src", "class", "ste", "s", "std", "id", "Str", "ft", "t", "sb", "stress", "const", "sf", "fe", "tt", "code", "inst", "sta", "str", "start", "f", "est", "rest", "struct", "put", "cl", "ct", "ost", "d", "string", "ld", "sth", "ust", "pt", "www", "ist"], "url": ["blog", "image", "fr", "sl", "ul", "html", "stream", "tool", "host", "feed", "impl", "fl", "user", "bug", "ls", "bb", "id", "page", "server", "coll", "bel", "address", "open", "loc", "or", "connection", "http", "hub", "URL", "path", "ob", "ssl", "file", "build", "link", "f", "Url", "base", "zip", "err", "gl", "download", "log", "b", "org", "ll", "cl", "l", "string", "web", "ur", "uri", "pl", "source", "www"], "fis": ["lis", "fips", "fIS", "FIS", "bis", "flris", "zris", "flos", "zips", "lris", "fi", " fips", " fris", "FIs", "fIs", "Fos", "Fips", "flis", "zIS", "fliss", "afiss", " fiss", "biss", "afos", "bi", "afis", "flIs", "fli", "fris", " fils", "lils", "fiss", "bos", " fIS", "liss", "fils", "afIs", "Fris", "Fis", "Fiss", "flils", " fi"], "zis": ["zenois", "zeIS", " ziss", "qiss", "Zais", "ezIS", " zisa", "Zis", "zips", "qbis", "zipisi", "qis", "ziss", "ezisa", "zenis", "ezis", "zois", "zeisa", " zais", "zipiss", " zits", "zipbis", "zIS", "zais", " zisi", "zi", "zipi", "zisa", "ezips", "zipis", "zeips", "Ziss", " zois", " zips", " zi", "zenisi", " zIS", "zbis", "zits", "zipits", "zipais", "zisi", "zenais", "qi", "Zits", "zeis", " zbis", "zipois"], "entry": ["next", "r", "image", "in", "ace", "match", "la", "de", "country", "auto", "fr", "obj", "ie", "element", "sec", "cel", "key", "cell", "object", "comment", "feed", "rc", "sea", "parse", "e", "enter", "cat", "nt", "ry", "lc", "archive", "address", "info", "result", "or", "dc", "ident", "li", "index", "exp", "inner", "se", "line", "row", "file", "part", "ge", "zip", "session", "pe", "spec", "ent", "record", "ries", "je", "Entry", "reader", "si", "extra", "inc"], "count": ["ind", "buffer", "size", "max", "Count", "i", "current", "use", "load", "feed", "default", "write", "parent", "id", "limit", "cache", "check", "val", "child", "more", "code", "sum", "index", "_", "line", "file", "part", "len", "start", "en", "end", "depth", "base", "type", "log", "offset", "number", "allow", "skip", "name", "counter", "list", "add", "read", "c", "length"], "data": ["image", "error", "buffer", "bytes", "p", "size", "batch", "alpha", "block", "i", "load", "feed", "input", "cache", "info", "result", "code", "content", "a", "message", "zero", "results", "raw", "value", "str", "len", "start", "area", "buf", "number", "text", "body", "string", "d", "DATA", "reader", "empty", "read", "shift", "dat", "length"], "fos": ["efosi", "flnos", "efoses", "zos", "fOS", "fros", "flos", "fosh", "Fos", "zol", "foses", "flol", "fnos", "efosh", "froses", "zOS", "znos", "dfoses", "dfosi", "frosh", "Fol", "dfos", "dfosh", "Fnos", "flOS", "efos", "FOS", "fosi", "frosi", "fol"], "dest": ["writer", "de", "sync", "flash", "stream", "src", "output", "default", "tmp", "comb", "std", "slice", "const", "home", "Dest", "loc", "result", "target", "dc", "wh", "sum", "desc", "inner", "exit", "later", "img", "out", "cdn", "sup", "dist", "end", "die", "wb", "zip", "des", "rest", "temp", "trans", "done", "transform", "test", "south", "di", "coord", "style", "prop", "outer", "cont", "dev", "dat", "source", "txt"]}}
{"id1": "18202328", "id2": "3745402", "code1": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "code2": "    static Cipher createCipher(String passwd, int mode) throws Exception {\n        PBEKeySpec keySpec = new PBEKeySpec(passwd.toCharArray());\n        SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(\"PBEWithMD5AndDES\");\n        SecretKey key = keyFactory.generateSecret(keySpec);\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(\"input\".getBytes());\n        byte[] digest = md.digest();\n        byte[] salt = new byte[8];\n        for (int i = 0; i < 8; ++i) salt[i] = digest[i];\n        PBEParameterSpec paramSpec = new PBEParameterSpec(salt, 20);\n        Cipher cipher = Cipher.getInstance(\"PBEWithMD5AndDES\");\n        cipher.init(mode, key, paramSpec);\n        return cipher;\n    }\n", "label": 1, "substitutes": {"register": ["connect", "save", "master", "app", "load", "chain", "Register", "user", "init", "check", "reg", " regenerate", " registration", "Login", " unlock", "start", "activate", "login", "update", "bind", "auth", " reg", "password", "setup", "play", "create", "config", " Register"], "session": ["request", "image", "position", "video", "client", "connect", "h", "service", "sync", "script", "caster", "host", "master", "socket", "view", "use", "proxy", "user", "global", "version", "input", "slave", "sa", "parent", "section", "port", "sb", "cache", "Session", "cookie", "conn", "child", "server", "group", "game", "state", "connection", "message", "resource", "gui", "ssl", "manager", "thread", "room", "device", "channel", "security", "login", "person", "temp", "database", "shell", " Session", "driver", "mc", "site", "python", "password", "remote", "browser", "facebook", "play", "lock", "ess", "ession", "window", "event", "machine", "config"], "username": ["account", "ername", "localhost", "email", "term", "mother", "hello", "crypt", "profile", "host", "phone", "character", "user", "title", "attribute", "monitor", "sword", "address", "phrase", " nickname", "ame", "property", "Password", "path", "message", "word", "NAME", "uid", "url", "prefix", "login", "person", "nick", "amer", "token", "subject", "secret", "users", "Name", "database", "text", "name", "auth", "driver", "password", "voice", " password", "string", "verb", "seed", "steam", "minecraft", "uri", "duration", "mobile", "source", "filename", "length"], "verificationKey": ["verifyingKEY", "significationkey", "significationKEY", "verationKey", "verificationPoint", "verifyPoint", "verificationSecret", "significationKey", "vermentKey", "validifyingSecret", "verifyKey", "validifyingPoint", "significationSecret", "verificationkey", "verifySecret", "verationPoint", "vermentKEY", "signationkey", "verifyingPoint", "validificationSecret", "verifyingKey", "vermentkey", "signationKEY", "verationkey", "verifyingkey", "validifyingkey", "verificationKEY", "signationKey", "validifyingKey", "verationSecret", "signationSecret", "validificationKey", "verifyingSecret", "verifykey", "validificationkey", "validificationPoint", "verationKEY", "vermentSecret"], "salt": ["sALT", "sort", "Shash", "setsodium", "sealt", "suffSalt", "suffalt", "sodium", "seALT", " sodium", "sehash", "sSalt", "seSalt", "setsort", " sALT", "SALT", " sort", "suffhash", "shash", "setsALT", "setsalt", "SSalt", "Salt", "suffALT"], "hash": ["mac", "match", "buffer", "h", "query", "html", "ash", "crypt", "key", "output", "square", "host", "user", "input", "version", "cache", "address", "result", "sum", "array", "message", "pool", "Hash", "build", "url", "log", "her", "secret", "sha", "number", "text", "total", "name", "auth", "memory", "password", "string", "header", "kh", "hed", "hex"], "digest": [" digested", " dige", "hedester", "signest", " digger", "signests", "logger", "Digit", "bigested", "DigEST", "defe", "digger", " digests", "signEST", "diggest", "digests", " digEST", "bigester", "Digest", "biggest", "logest", " digit", "Digger", "defEST", "logester", "digit", "Digester", " digester", "Digests", "hedest", "digester", "digEST", "hedEST", "defester", " diggest", "dige", "digested", "defest", "Diggest", "bigest", "logit", "hedested", "Digested", "signested", "Dige"], "nameChars": ["nameCharARS", "nameCharts", "nameGrars", "nameChARS", " nameCharacters", "namechars", "namechats", " nameChats", " nameChARS", "nameGrARS", "nameChases", "namechARS", "nameChats", "nameCheases", "nameChacters", " nameChases", "nameChears", "nameCheats", "namechacters", " nameCharts", "nameGracters", "nameChararts", "nameCheARS", " nameCharars", "namechases", " nameChararts", "nameGrarts", "nameCharacters", " nameChacters", "nameCharars", " nameCharARS", "namecharts"], "nameChar": ["NameCharacter", "nameCh", "namechar", " namechar", " nameCharacter", "nameDir", "idCharacter", " NameCharacter", "NameDir", "nameText", " nameText", "idCh", "NameCtrl", " nameDir", "addressChar", "resourcechar", "nameCtrl", "addressCh", "idText", "idChar", "NameCh", "resourceDir", " nameCtrl", " nameCh", " NameText", "NameChar", "addressCharacter", "resourceCharacter", "nameCharacter", "addressCtrl", "resourceChar", " NameCh", " NameChar", "Namechar"], "p": ["r", "client", "m", "h", "j", "P", "n", "pp", "g", "br", "pa", "i", "q", "cp", "pre", "s", "e", "po", " P", "t", "py", "per", "ap", "a", "lp", "fp", "cop", "pair", "op", "at", "part", "f", "o", "api", "pe", "jp", "u", "b", "er", "v", "pc", "l", "d", "ps", "point", "np", "up", "sp"], "player": ["video", "position", "match", "client", "m", "ace", "worker", "script", "g", "n", "aster", "caster", "machine", " Player", "players", "class", "master", "user", "conference", "owner", "slave", "e", "parent", "server", "per", "ler", "game", "connection", "media", "playing", "board", "Player", "pool", "manager", "gamer", "league", "part", "winner", "data", "pe", "person", "can", "leader", "er", "live", "pm", "controller", "name", "driver", "l", "played", "member", "team", "pro", "steam", "play", "party", "layer"], "c": ["r", "C", "sc", "ca", "m", "h", "ctx", "n", "cp", "ce", "rc", "cs", "cc", "chain", "cr", "lc", "ci", "cf", "cache", "t", "cb", "cu", "bc", "dc", "nc", "cm", "con", "conf", "fc", "tc", "f", "enc", "o", "abc", "k", "ac", "arc", "v", "cl", "ct", "pc", "l", "mc", "d", "config", "ec"]}}
{"id1": "14598566", "id2": "7149578", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    @Override\n    protected void parseContent(StreamLimiter streamLimiter, LanguageEnum forcedLang) throws IOException {\n        String charset = null;\n        IndexDocument sourceDocument = getSourceDocument();\n        if (sourceDocument != null && urlItemFieldEnum != null) {\n            FieldValueItem fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentTypeCharset.getName(), 0);\n            if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            if (charset == null) {\n                fieldValueItem = sourceDocument.getFieldValue(urlItemFieldEnum.contentEncoding.getName(), 0);\n                if (fieldValueItem != null) charset = fieldValueItem.getValue();\n            }\n        }\n        boolean charsetWasNull = charset == null;\n        if (charsetWasNull) charset = getProperty(ClassPropertyEnum.DEFAULT_CHARSET).getValue();\n        StringWriter writer = new StringWriter();\n        IOUtils.copy(streamLimiter.getNewInputStream(), writer, charset);\n        addField(ParserFieldEnum.htmlSource, writer.toString());\n        writer.close();\n        HtmlDocumentProvider htmlProvider = findBestProvider(charset, streamLimiter);\n        if (htmlProvider == null) return;\n        addField(ParserFieldEnum.htmlProvider, htmlProvider.getName());\n        String contentType = htmlProvider.getMetaHttpEquiv(\"content-type\");\n        String contentTypeCharset = null;\n        if (contentType != null) {\n            contentTypeCharset = MimeUtils.extractContentTypeCharset(contentType);\n            if (contentTypeCharset != null && !contentTypeCharset.equals(charset)) charsetWasNull = true;\n        }\n        if (charsetWasNull) {\n            if (contentTypeCharset != null) charset = contentTypeCharset; else charset = htmlProvider.getMetaCharset();\n            if (charset != null) htmlProvider = findBestProvider(charset, streamLimiter);\n        }\n        HtmlNodeAbstract<?> rootNode = htmlProvider.getRootNode();\n        if (rootNode == null) return;\n        for (HtmlNodeAbstract<?> metaNode : htmlProvider.getMetas()) {\n            String metaName = metaNode.getAttributeText(\"name\");\n            if (metaName != null && metaName.startsWith(OPENSEARCHSERVER_FIELD)) {\n                String field = metaName.substring(OPENSEARCHSERVER_FIELD_LENGTH);\n                String[] fields = field.split(\"\\\\.\");\n                if (fields != null) {\n                    String content = metaNode.getAttributeText(\"content\");\n                    addDirectFields(fields, content);\n                }\n            }\n        }\n        addField(ParserFieldEnum.charset, charset);\n        addFieldTitle(htmlProvider.getTitle());\n        String metaRobots = null;\n        String metaDcLanguage = null;\n        String metaContentLanguage = null;\n        for (HtmlNodeAbstract<?> node : htmlProvider.getMetas()) {\n            String attr_name = node.getAttributeText(\"name\");\n            String attr_http_equiv = node.getAttributeText(\"http-equiv\");\n            if (\"keywords\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_keywords, HtmlDocumentProvider.getMetaContent(node)); else if (\"description\".equalsIgnoreCase(attr_name)) addField(ParserFieldEnum.meta_description, HtmlDocumentProvider.getMetaContent(node)); else if (\"robots\".equalsIgnoreCase(attr_name)) metaRobots = HtmlDocumentProvider.getMetaContent(node); else if (\"dc.language\".equalsIgnoreCase(attr_name)) metaDcLanguage = HtmlDocumentProvider.getMetaContent(node); else if (\"content-language\".equalsIgnoreCase(attr_http_equiv)) metaContentLanguage = HtmlDocumentProvider.getMetaContent(node);\n        }\n        boolean metaRobotsFollow = true;\n        boolean metaRobotsNoIndex = false;\n        if (metaRobots != null) {\n            metaRobots = metaRobots.toLowerCase();\n            if (metaRobots.contains(\"noindex\")) {\n                metaRobotsNoIndex = true;\n                addField(ParserFieldEnum.meta_robots, \"noindex\");\n            }\n            if (metaRobots.contains(\"nofollow\")) {\n                metaRobotsFollow = false;\n                addField(ParserFieldEnum.meta_robots, \"nofollow\");\n            }\n        }\n        UrlFilterItem[] urlFilterList = getUrlFilterList();\n        List<HtmlNodeAbstract<?>> nodes = rootNode.getAllNodes(\"a\", \"frame\");\n        IndexDocument srcDoc = getSourceDocument();\n        if (srcDoc != null && nodes != null && metaRobotsFollow) {\n            URL currentURL = htmlProvider.getBaseHref();\n            if (currentURL == null && urlItemFieldEnum != null) {\n                FieldValueItem fvi = srcDoc.getFieldValue(urlItemFieldEnum.url.getName(), 0);\n                if (fvi != null) currentURL = new URL(fvi.getValue());\n            }\n            for (HtmlNodeAbstract<?> node : nodes) {\n                String href = null;\n                String rel = null;\n                String nodeName = node.getNodeName();\n                if (\"a\".equals(nodeName)) {\n                    href = node.getAttributeText(\"href\");\n                    rel = node.getAttributeText(\"rel\");\n                } else if (\"frame\".equals(nodeName)) {\n                    href = node.getAttributeText(\"src\");\n                }\n                boolean follow = true;\n                if (rel != null) if (rel.contains(\"nofollow\")) follow = false;\n                URL newUrl = null;\n                if (href != null) if (!href.startsWith(\"javascript:\")) if (currentURL != null) newUrl = LinkUtils.getLink(currentURL, href, urlFilterList);\n                if (newUrl != null) {\n                    ParserFieldEnum field = null;\n                    if (newUrl.getHost().equalsIgnoreCase(currentURL.getHost())) {\n                        if (follow) field = ParserFieldEnum.internal_link; else field = ParserFieldEnum.internal_link_nofollow;\n                    } else {\n                        if (follow) field = ParserFieldEnum.external_link; else field = ParserFieldEnum.external_link_nofollow;\n                    }\n                    addField(field, newUrl.toExternalForm());\n                }\n            }\n        }\n        if (!metaRobotsNoIndex) {\n            nodes = rootNode.getNodes(\"html\", \"body\");\n            if (nodes == null || nodes.size() == 0) nodes = rootNode.getNodes(\"html\");\n            if (nodes != null && nodes.size() > 0) {\n                StringBuffer sb = new StringBuffer();\n                getBodyTextContent(sb, nodes.get(0), true, null);\n                addField(ParserFieldEnum.body, sb);\n            }\n        }\n        Locale lang = null;\n        String langMethod = null;\n        String[] pathHtml = { \"html\" };\n        nodes = rootNode.getNodes(pathHtml);\n        if (nodes != null && nodes.size() > 0) {\n            langMethod = \"html lang attribute\";\n            String l = nodes.get(0).getAttributeText(\"lang\");\n            if (l != null) lang = Lang.findLocaleISO639(l);\n        }\n        if (lang == null && metaContentLanguage != null) {\n            langMethod = \"meta http-equiv content-language\";\n            lang = Lang.findLocaleISO639(metaContentLanguage);\n        }\n        if (lang == null && metaDcLanguage != null) {\n            langMethod = \"meta dc.language\";\n            lang = Lang.findLocaleISO639(metaDcLanguage);\n        }\n        if (lang != null) {\n            addField(ParserFieldEnum.lang, lang.getLanguage());\n            addField(ParserFieldEnum.lang_method, langMethod);\n        } else if (!metaRobotsNoIndex) lang = langDetection(10000, ParserFieldEnum.body);\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileBynIO", "copyFileByMIP", "copyFilebynio", "copyFileByFileIF", "copyFilebynIO", "copyFileByNIP", "copyFilebynIP", "copyFileByMIF", "copyFileBynio", "copyFileByFileio", "copyFilebyNIP", "copyFileByNio", "copyFilebynIF", "copyFileByMIO", "copyFileByNIF", "copyFileBynIF", "copyFilebyNIO", "copyFileByFileIO", "copyFileBynIP", "copyFileByFileIP", "copyFilebyNIF", "copyFileByMio", "copyFilebyNio"], "in": ["image", "m", "buffer", "h", "inn", "i", "input", "copy", "id", "ex", "din", "diff", "or", "connection", "inner", "index", "resource", "io", "ini", "at", "file", "part", "x", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "source", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "n", "output", "object", "copy", "ex", "cache", "to", "conn", "target", "connection", "path", "ext", "resource", "io", "dest", "file", "at", "part", "prefix", "o", "exec", "data", "b", "v", "w", "name", "external", "again", "string", "project", "outs", "source", "OUT", "c", "inc"], "sourceChannel": ["ourceQueue", "srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "ourcechannel", "sourceServer", "sinChan", "sinStream", "ourceStream", "innerChan", " sourceQueue", "srcQueue", "srcConnection", "ourceChannel", "targetChannel", "sourceQueue", "targetchannel", "SourceConnection", "targetChan", " sourceServer", "innerStream", "sourceStream", "sourceConnection", " sourceChan", "sinServer", " sourcechannel", "SourceChannel", " sourceConnection", "innerServer", "targetConnection", "Sourcechannel", "innerChannel", "ourceConnection", "sinChannel", "sourcechannel", "SourceChan"], "destinationChannel": ["destributionChan", "DestinationStream", "DestinationChannel", "destinatedChannel", "destributionContext", "DestinatorClient", "destinateConnection", "destionChan", "destinationContext", "destinatedStream", "destroyingConnection", "destinationClient", "DestinationConnection", "destinatorConnection", "destroyingStream", "destionClient", "DestinationContext", "destributionConnection", "destinateStream", "destributionStream", "destinationConnection", "destributionChannel", "destinatorChannel", "destinateChannel", "DestinatorContext", "DestinationClient", "destionConnection", "DestinationChan", "DestinatorConnection", "destionChannel", "destinationStream", "destinatorClient", "destributionClient", "destinatorContext", "destinatorChan", "destroyingChannel", "DestinatorChan", "destinatedContext", "DestinatorChannel", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "9033639", "id2": "20128728", "code1": "    public void testHttpsConnection() throws Throwable {\n        setUpStoreProperties();\n        try {\n            SSLContext ctx = getContext();\n            ServerSocket ss = ctx.getServerSocketFactory().createServerSocket(0);\n            TestHostnameVerifier hnv = new TestHostnameVerifier();\n            HttpsURLConnection.setDefaultHostnameVerifier(hnv);\n            URL url = new URL(\"https://localhost:\" + ss.getLocalPort());\n            HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();\n            SSLSocket peerSocket = (SSLSocket) doInteraction(connection, ss);\n            checkConnectionStateParameters(connection, peerSocket);\n            connection.connect();\n        } finally {\n            tearDownStoreProperties();\n        }\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"testHttpsConnection": ["testHtlsconnection", "testHtlsConnector", "testHtlsContext", "testHttsconnection", "testHttsConnector", "testHtpsConnection", "testHttlsconnection", "testHttpsContext", "testHtpsContext", "testHttpContext", "testHttpsConnector", "testHttsContext", "testHttpsconnection", "testHttpConnector", "testHttpconnection", "testHttpConnection", "testHttlsConnector", "testHtpsConnector", "testHttlsContext", "testHtpsconnection", "testHttsConnection", "testHttlsConnection", "testHtlsConnection"], "ctx": ["sc", "client", "ca", "cas", "tx", "cci", "cp", "rc", "cs", "cc", "cn", "context", "lc", "cf", "ci", "cb", "conn", "bc", "cca", "cm", "ssl", "conf", "fc", "tc", "ctrl", "x", "exec", "base", "conv", "jp", "cv", "cpp", "pc", "utils", "mc", "cms", "Context", "config", "c"], "ss": ["os", "sc", "cas", "sw", "ssh", "sl", "tx", "oss", "src", "socket", "cs", "bs", "rs", "ls", "ns", "ses", "sn", "css", "server", "sf", "conn", "state", "iss", "rss", "se", "hess", "ssl", "ds", "fs", "sq", "https", "WS", "vs", "si", "ps", "SS", "ess", "ws", "sp"], "hnv": ["dnf", "nh", "dnV", "knh", "dnx", "hnh", "cnf", " hpv", "nx", "nv", "cnv", "nva", " hpx", " hph", "knf", "dnv", "knV", "hnf", "knva", "knx", "cnV", "hnx", " hpva", "knv", "hnva", "hnV", "cnx"], "url": ["image", "blog", "job", "client", "sl", "host", "socket", "feed", "context", "user", "page", "server", "address", "conn", "loc", "http", "location", "URL", "path", "ssl", "file", "director", "link", "f", "Url", "channel", "base", "control", "log", "org", "ll", "name", "l", "string", "follow", "web", "uri", "layer", "www"], "connection": ["position", "timeout", "client", "connect", "relation", "socket", "default", "proxy", "context", "character", "nn", "version", "section", "lc", "cf", "handler", "established", "server", "cli", "conn", "loc", "bc", "http", "nc", "URL", "response", "ssl", "function", "con", "connected", "channel", "wrapper", "session", "b", "database", "collection", "application", " Connection", "driver", "l", "password", "reader", "communication", "command", "Connection", "uri", "closed", "config", "c", "condition"], "peerSocket": [" peerPort", "peerPort", "serverSocket", "sslSocket", "sslConnection", "peerConnection", "sslPort", "peConn", " peerSession", " PeerConn", "peerSession", "sslSession", "peerServer", " peerConn", "peConnection", " PeerConnection", "peServer", " PeerServer", "serverConnection", "serverSession", "peSocket", "peerConn", "serverPort", " peerServer", " PeerSocket", " peerConnection"]}}
{"id1": "17901739", "id2": "7468819", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 1, "substitutes": {"setMembers": ["setJoin", "SetJoin", "SetMembers", "setMember", "SetMethods", " setJoin", "parseMembers", " setMethods", "parseMember", "parseJoin", "setMethods", "parseMethods", "SetMember", " setMember"], "url": ["image", "blog", "client", "service", "email", "sl", "entry", "queue", "socket", "feed", "user", "server", "address", "connection", "http", "location", "URL", "resource", "path", "io", "hub", "ssl", "file", "Url", "channel", "base", "data", "loader", "org", "article", "l", "string", "uri", "source", "www"], "reader": ["r", "iterator", "writer", "ner", "worker", "Reader", "entry", "stream", "rer", "i", "rc", "feed", "input", "e", "handler", "server", "per", "ler", "http", "inner", "editor", "report", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "f", "builder", "err", "loader", "er", "driver", "l", "table", "parser", "read", "bird"], "buffer": ["video", "image", "stage", "sync", "flash", "FFER", "comment", "Buffer", "address", "info", "fb", "http", "str", "iter", "buf", "base", "text", "string", "uri", "window", "flush", "length", "request", "bytes", "batch", "feed", "input", "parse", "page", "cache", "rb", "response", "message", "buff", "file", "uffer", "b", "bar", "border", "pause", "button", "writer", "fr", "received", "output", "bb", "expression", "phrase", "result", "padding", "line", "row", "null", "player", "paste", "wave", "background", "password", "counter", "seed", "layer", "source", "filename", "template", "queue", "read", "transfer", "sequence", "server", "game", "code", "resource", "binary", "data", "loader", "document", "bin", "header", "texture"], "pattern": ["image", "position", " Pattern", "match", "template", "cher", "script", "object", "print", "feed", "app", "slice", "serial", "expression", "patch", "handler", "Pattern", "rule", "cache", "child", "group", "format", "array", "graph", "path", "regular", "df", "function", "file", "part", "str", "letter", "model", "system", "builder", "type", "log", "number", "atter", "document", "password", "counter", "string", "parser", "command", "filter", "event", "re", "layer", "config", "condition"], "matcher": ["reches", "ratger", "patatcher", "manacher", "statcher", "compner", "patner", "mitchers", "ratacher", "Matpattern", "matchpattern", "Matger", "statpattern", "captatter", "attacher", "compatcher", " matter", "captpattern", "patcher", "matacher", "mirher", "matches", " matpattern", "mither", "Matner", "harpattern", "matchher", "matchers", "motpattern", "reched", "harcher", "reach", "compach", "patch", "mather", "Matching", "matatcher", "matchched", "mancher", "compched", " matacher", "harner", " mather", "captter", "motner", "matchches", " matatter", "matger", " matler", "attcher", "matchler", "matchter", "manher", "matching", "patpattern", "compter", "matatter", "patter", "matpattern", "matler", "mirter", "Matacher", "linter", "matach", "matchach", "pather", "ratcher", " matchers", "Matter", "compcher", " match", "ratching", "captcher", "linatter", "statler", "linpattern", "statner", "motter", "lincher", "attching", "match", "matchcher", "mircher", "attger", "patchers", "manner", "mirpattern", "harler", "Matcher", "mitcher", "compches", "matchatcher", "matchacher", "matched", "recher", "motcher", "matter", "matner", " matner", "mitch", "matchner", "Mather"], "erg": ["der", "gr", "ander", "gae", "irc", "orter", "eur", "gru", "eri", "progress", "ag", "worker", "justice", "rator", "rog", "git", "ga", "ord", "eng", "igor", "gra", "east", "ger", "gg", "urg", "ero", "sg", "eric", "yang", "game", "dr", "aug", "alg", "berg", "region", "gy", "magic", "oga", "gd", "feat", "orters", "era", "ager", "porter", "uster", "jing", "org", "arc", "ERG", "er", "agog", "ig", "forge", "rg", "ider", "og", "usa", "clus", "ers", "ocr", "aga", "ard", "anger", "gas", "ung", "agg"], "start": ["pad", "size", "sort", "grad", "old", "mid", "address", "open", "info", "last", "something", "end", "space", "st", "base", "name", "ind", "get", "End", "fit", "off", "load", "begin", "check", "boot", "diff", "state", "inner", "index", "find", "part", "started", "close", "unit", "set", "scale", "pend", "offset", "stop", "like", "middle", "in", "stat", "art", "init", "ad", "starting", "id", "run", "plus", "sum", "grade", "pick", "Start", "show", "work", "count", "step", "min", "it", "seed", "speed", "head", "first", "add", "shift", "source", "position", "match", "cost", "max", "ie", "pos", "read", "sol", "se", "send", "fill", "need", "ish", "none", "rest", "type", "bin", "style", "current"], "von": ["fin", "su", "flo", "jan", "tu", "eni", "melon", "vid", "bn", "endon", "nn", "vu", "ou", "tin", "fen", "oni", "ln", "won", "zon", "han", "jen", "aven", "dn", "lin", "ver", "fat", "bon", "anon", "vin", "andon", "lon", "olson", "fn", "uber", "fun", "feat", "len", "kn", "hon", "wen", "don", "byn", "tun", "mun", "di", "hn", "vor", "onna", "bin", "ten", "mon", "lu", "evin", "endor", "una", "john", "non"], "bis": ["os", "bs", "vid", "ois", "phis", "lins", "bid", "zi", "fb", "bas", "len", "bits", "prefix", "base", "bat", "vs", "bos", "outs", "isin", "eni", "is", "bus", "uno", "nas", "isi", "ris", "val", "boot", "ios", "li", "vin", "buff", "offs", "bi", "uss", "su", "BUS", "us", "cus", "oss", "ls", "bb", "nexus", "abi", "lin", "obs", "cos", "bps", "sis", "bian", "ri", "bles", "cedes", "vals", "pos", "oris", "cin", "oni", "ui", "los", "fat", "ori", "bes", "ours", "pi", "onis", "des", "ni", "pins", "di", "bin", "lus", "bett", "udi", "idis"], "m_strComponents": ["m_strExpales", "m_strComponent", "m_strExpenses", "m_intRepales", "m_intComports", "m_arrCommales", "m_intReports", "m_strRepales", "m_intRepenses", "m_strCompenses", "m_strReports", "m_strExponents", "m_strRepenses", "m_arrCommonent", "m_arrCompenses", "m_arrComponents", "m_strReponents", "m_strCommonent", "m_strExports", "m_arrCommenses", "m_strCommales", "m_intReponents", "m_intCompales", "m_strCommenses", "m_strComponentonents", "m_arrComponent", "m_intCompenses", "m_strCommorts", "m_intComponents", "m_arrCommonents", "m_strExponent", "m_strCommonents", "m_strCompales", "m_strComponentales", "m_strComponentonent", "m_arrCompales", "m_strComponentenses", "m_strComports"], "m_strPriorities": ["m_intPrefries", "m_strActivities", "m_strActivries", "m_StrPriority", "m_strComparifiers", "m_strPrioritives", "m_strMonities", "m_intPrioritions", "m_strMonitives", "m_StrPosity", "m_strComparities", "m_intPriorries", "m_intPriorities", "m_StrPriorities", "m_strPrefitions", "m_StrPrioritions", "m_intPrioritives", "m_strPositions", "m_strComparitions", "m_StrPositions", "m_strPriorries", "m_strActivitions", "m_intPrefitives", "m_strPrefries", "m_strPrefitives", "m_StrPosifiers", "m_strQualitions", "m_strActivitives", "m_strMonitions", "m_strComparity", "m_strPosity", "m_strMonries", "m_intPrefities", "m_strPosities", "m_strPriority", "m_strPriorifiers", "m_intPrefitions", "m_StrPosities", "m_strQuality", "m_strQualifiers", "m_strPosifiers", "m_strQualities", "m_StrPriorifiers", "m_strPrioritions", "m_strPrefities"]}}
{"id1": "13644374", "id2": "647224", "code1": "    public byte[] getBytesFromUrl(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toByteArray(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public void uploadFile(File inputFile, String targetFile) throws IOException {\n        System.out.println(\"Uploading \" + inputFile.getName() + \" to \" + targetFile);\n        File outputFile = new File(targetFile);\n        if (targetFile.endsWith(\"/\")) {\n            outputFile = new File(outputFile, inputFile.getName());\n        } else if (outputFile.getParentFile().exists() == false) {\n            outputFile.getParentFile().mkdirs();\n        }\n        if (inputFile.renameTo(outputFile) == false) {\n            InputStream in = new FileInputStream(inputFile);\n            OutputStream out = new FileOutputStream(outputFile);\n            byte[] line = new byte[16384];\n            int bytes = -1;\n            while ((bytes = in.read(line)) != -1) out.write(line, 0, bytes);\n            in.close();\n            out.close();\n        }\n    }\n", "label": 0, "substitutes": {"getBytesFromUrl": ["getBytesfromUrl", "getBytesfromString", "getbytesFromString", "getBytesViaRoute", "getbytesFormRoute", "getBytesfromURL", "getbytesFromUrl", "getBytesViaString", "getbytesFormURL", "getbytesFromURL", "getbytesFormUrl", "getBytesFormString", "getBytesfromRoute", "getBytesViaURL", "getbytesFormString", "getBytesFromRoute", "getBytesFormURL", "getBytesFormUrl", "getBytesFromURL", "getBytesFromString", "getBytesViaUrl", "getBytesFormRoute", "getbytesFromRoute"], "url": ["request", "buffer", "service", "email", "sl", "host", "i", "key", "route", "page", "server", "json", "address", "loc", "result", "connection", "http", "location", "URL", "resource", "path", "ref", "xml", "str", "Url", "api", "base", "data", "download", "method", "name", "l", "href", "string", "ur", "uri", "source"], "get": ["request", "GET", "client", "Get", "service", "query", "i", "use", "load", "parse", "e", "cli", "json", "gets", "open", "handle", "http", "resource", "pull", "send", "find", "build", "start", "api", "exec", "set", "update", "execute", "put", "method", "call", "body", "like", "read", "create"], "response": ["request", "success", "error", "tree", "received", "full", "output", "reply", "object", "feed", "e", "page", "json", "server", "result", "connection", "http", "content", "resource", "message", "report", "Response", "out", "resp", "f", "api", "onse", "data", "status", "application", "wave", "method", "document", "body", "respond"], "entity": ["image", "element", "entry", "output", "object", "el", "action", "instance", "e", "environment", "page", "json", "metadata", "server", "info", "result", "connection", "content", "http", "resource", "Entity", "message", "xml", "translation", "ale", "resp", "file", "this", "null", "api", "security", "model", "data", "pe", "ent", "collection", "document", "node", "body", "event", "person"]}}
{"id1": "12380475", "id2": "21656668", "code1": "    public void transport(File file) throws TransportException {\n        if (file.exists()) {\n            if (file.isDirectory()) {\n                File[] files = file.listFiles();\n                for (int i = 0; i < files.length; i++) {\n                    transport(file);\n                }\n            } else if (file.isFile()) {\n                try {\n                    FileChannel inChannel = new FileInputStream(file).getChannel();\n                    FileChannel outChannel = new FileOutputStream(destinationDir).getChannel();\n                    inChannel.transferTo(0, inChannel.size(), outChannel);\n                } catch (IOException e) {\n                    log.error(\"File transfer failed\", e);\n                }\n            }\n        }\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"transport": [" transprocess", " transpoint", "ransmission", " transmission", "ransporter", "protprocess", "protmission", "ransport", " transports", "transmission", "ransprocess", "ransports", "transports", "protport", "transprocess", "protpoint", "ranspoint", "transpoint", "protporter", "protports", " transporter", "transporter"], "file": ["image", "db", "auto", "service", "entry", "stream", "full", "queue", "class", "socket", "object", "use", "comment", "user", "e", "parent", "route", "page", "directory", "handler", "File", "server", "cache", "info", "handle", "connection", "content", "http", "path", "resource", "fp", "io", "single", "out", "FILE", "line", "change", "ile", "dir", "f", "url", "channel", "base", "model", "data", "type", "log", "local", "document", "name", "reader", "string", "project", "folder", "source", "filename"], "files": ["items", "balls", "ups", "models", "phones", "bs", "s", "boxes", "cells", "headers", "ls", "pes", "sites", "events", "features", "lines", "keys", "objects", "issues", "images", "results", "iles", "ions", "dir", "classes", "f", "Files", "pages", "fs", "facts", "blocks", "users", "views", "ins", "names", "ums", "books", "thumbnails", "flows"], "i": ["ai", "ip", "m", "h", "p", "j", "n", "key", "multi", "slice", "e", "id", "abi", "ci", "info", "ui", "li", "index", "ii", "io", "vi", "ini", "end", "x", "pi", "f", "col", "o", "xi", "ti", "k", "ri", "u", "ni", "b", "v", "mi", "oi", "it", "di", "hi", "d", "si", "chi", "uri", "I", "c"], "inChannel": ["outStream", "inputChannel", " inchannel", "inchannel", "InMessage", "outchannel", "inCh", " inChan", "inMessage", "InStream", "InChan", "inputChan", "inChan", " inMessage", " inStream", "InChannel", "inputCh", "Inchannel", "InCh", " inCh", " inFile", "outFile", "inFile", "inputStream", "InFile", "outMessage", "inStream"], "outChannel": ["outStream", " outchannel", "inchannel", "ioHandler", "OutChan", "outchannel", "outChan", "OutChannel", " outHandler", "ioChan", " outChan", " outConnection", " outStream", "Outchannel", "inChan", "outConnection", "ioConnection", "inConnection", "ioChannel", "outHandler", "inHandler", "OutStream", "inStream"]}}
{"id1": "16466743", "id2": "10391753", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmn512", "getmetadata12", " getMD512", "getmd12", "getMD5", "getmd6", "getmetadata6", "getmn12", " getmd6", "getmetadata5", "getmn5", "getmn6", " getMD5", "getMD512", " getmd512", "getmetadata512", " getMD12", "getMD6", "getmd512", " getMD6", "getMD12", " getmd12"], "password": ["account", "pad", "buffer", "words", "p", "email", "crypt", "key", "pattern", "input", "attribute", "sword", "phrase", "address", "padding", "Password", "array", "path", "message", "word", "wd", "config", "f", "prefix", "pass", "login", "data", "token", "secret", "number", " passwords", "text", "name", "auth", "string", " Password", "encrypted", "hash", "PASS", "username"], "pwHash": ["pwhMac", "pwdSum", "pwahash", "PwBlock", "PwHash", "pwaMac", "pwdMac", "pWSum", "pWMac", "pwaHash", "pweDig", " pwSum", "pWBlock", "pwDig", "pxDig", "pwhSum", " pwaSum", "qwDig", "pwtHash", "pxSum", "pwaDig", "qxHash", "pwdhash", "pweSum", "qxDig", "PWBlock", "qxSum", " pwhash", "pweHash", " pwahash", "pwaSum", "pwdHash", " pwDig", "pwhash", "qxMac", "pwdDig", "PWMac", "pWHash", "PWHash", "PWSum", "qwMac", " pwaHash", "pwtSum", "pwSum", "pwBlock", "pxMac", "pwhBlock", "qwHash", "pwhHash", "pwehash", "qwSum", " pwaDig", "PwSum", "PwMac", "pwtBlock", "pwtMac", "pwMac", "pxHash"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "kg", "dig", "ad", "mu", "pd", "metadata", "M", "um", "ma", "cd", "od", "dc", "bm", "rm", "mb", "cm", "amd", "nm", "mand", "bd", "sm", "mg", "dm", "pm", "mi", "sha", "mt", "MD", "mp", "me", "mc", "mod", "mag", "d", "mage", "ld", "ms", "meta", "hash", "am", "cmd", "dd", " MD", "hm"], "b": ["r", "db", "buffer", "bytes", "p", "batch", "bis", "br", "bf", "ab", "lb", "bs", "emb", "ib", "bb", "e", "sb", "rb", "fb", "a", "be", "mb", "ob", "buff", "gb", "bi", "B", "bd", "reb", "f", "eb", "buf", "binary", "wb", "base", "u", "ba", "l", "bin", "d", "nb", "orb", "cb"], "i": ["r", "ai", "ip", "h", "p", "j", "n", "block", "s", "multi", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "info", "a", "zi", "li", "index", "ii", "io", "vi", "z", "bi", "start", "x", "pi", "f", "o", "xi", "base", "ti", "ri", "data", "u", "ni", "v", "ji", "oi", "it", "di", "l", "d", "si", "chi", "qi", "uri", "I", "c"]}}
{"id1": "6008635", "id2": "22411381", "code1": "    public boolean referredFilesChanged() throws MalformedURLException, IOException {\n        for (String file : referredFiles) {\n            if (FileUtils.isURI(file)) {\n                URLConnection url = new URL(file).openConnection();\n                if (url.getLastModified() > created) return true;\n            } else if (FileUtils.isFile(file)) {\n                File f = new File(file);\n                if (f.lastModified() > created) return true;\n            }\n        }\n        return false;\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"referredFilesChanged": ["referredFileChanged", "referredfilesChanged", "revertedFilesChanged", "referredfileschanged", "revertedFileschanged", "referredFileschanged", "referredFilechanged", "revertedFilesChange", "referredfilesChange", "referredFileChange", "referredFilesChange"], "IOException": ["Downloadception", "IOError", " IOError", "IOception", "DownloadException", "IPception", " IOception", "IPException", "IPError", "DownloadError"], "file": ["image", "db", "entry", "full", "files", "class", "object", "use", "feed", "e", "id", "page", "directory", "handler", "File", "server", "fe", "sf", "info", "http", "path", "message", "fp", "resource", "single", "work", "line", "FILE", "ile", "part", "mail", "dir", "link", "base", "model", "data", "type", "pe", "b", "log", "live", "it", "document", "name", "l", "style", "string", "le", "folder", "uri", "source", "filename"], "url": ["image", "h", "service", "sl", "n", "g", "cert", "rl", "html", "object", "feed", "impl", "fl", "bb", "e", "id", "page", "server", "coll", "open", "loc", "connection", "http", "URL", "resource", "path", "ssl", "z", "build", "Url", "ch", "channel", "api", "log", "b", "v", "ll", "l", "web", "uri", "www"], "f": ["r", "fr", "m", "p", "lf", "n", "fa", "files", "i", "fd", "form", "func", "s", "feed", "fl", "e", "cf", "fo", "t", "coll", "sf", "fe", "info", "inf", "af", "fb", "path", "fp", "conf", "fc", "rf", "fs", "lib", "b", "v", "name", "fx", "l", "folder", "F", "filename", "c"]}}
{"id1": "8747840", "id2": "1169642", "code1": "    public static void copy(File src, File dest) throws FileNotFoundException, IOException {\n        FileInputStream in = new FileInputStream(src);\n        FileOutputStream out = new FileOutputStream(dest);\n        try {\n            byte[] buf = new byte[1024];\n            int c = -1;\n            while ((c = in.read(buf)) > 0) out.write(buf, 0, c);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        String key = getKey();\n        synchronized (this.lauchedHTTPRequests) {\n            if (this.lauchedHTTPRequests.contains(key)) return;\n            this.lauchedHTTPRequests.add(key);\n        }\n        String st = this.dataSource.getTileURL(this.x, this.y, this.z);\n        URL url;\n        try {\n            url = new URL(st);\n        } catch (MalformedURLException e1) {\n            logger.warning(\"Error in URL: \" + st);\n            return;\n        }\n        String geoJSON = \"\";\n        try {\n            InputStream is;\n            if (\"file\".equals(url.getProtocol())) is = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) is = url.openStream(); else {\n                logger.warning(\"Impossible to load settings from \" + url + \". Unsupported protocol \" + url.getProtocol());\n                return;\n            }\n            BufferedReader in = new BufferedReader(new InputStreamReader(is));\n            String line;\n            while ((line = in.readLine()) != null) geoJSON += line;\n            in.close();\n        } catch (FileNotFoundException e) {\n            return;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return;\n        }\n        VectorTile tile = new VectorTile(geoJSON, x, y, z);\n        Geometry[] geoms = new Geometry[tile.getPieces().size()];\n        int i = 0;\n        for (MfGeo geo : tile.getPieces()) {\n            if (geo.getGeoType() == GeoType.GEOMETRY) {\n                geoms[i++] = ((MfGeometry) geo).getInternalGeometry();\n            } else if (geo.getGeoType() == GeoType.FEATURE) {\n                MfFeature mf = (MfFeature) geo;\n                geoms[i++] = mf.getMfGeometry().getInternalGeometry();\n            }\n        }\n        GeometryCollection gc = new GeometryFactory().createGeometryCollection(geoms);\n        this.dataSource.getDataLoader().add(new OpenCartoFeature(this.dataSource.getLayer(), new Rep(gc), this.z));\n        this.dataSource.getLayer().getDisplayCacheLoader().coin();\n        synchronized (this.lauchedHTTPRequests) {\n            this.lauchedHTTPRequests.remove(key);\n        }\n    }\n", "label": 0, "substitutes": {"copy": ["get", "clone", "p", "sync", "all", "cp", "transfer", "Copy", "load", "write", " cp", "diff", "Cop", "clip", "rm", "cop", "file", "zip", "download", "paste", "put", "split", "mop", " Copy", "cmp", "dump", " transfer"], "src": ["back", "obj", "sl", "stream", "files", "rc", "s", "input", "sit", "sin", "archive", "sb", "cb", "loc", "inf", "rb", "inst", "resource", "path", "ref", "gb", "img", "rin", "file", "dist", "config", "sel", "url", "b", "ins", "reader", "uri", "ource", "source", "filename"], "dest": ["de", " Dest", "obj", "save", "output", "delete", "class", "comb", "tmp", "opt", "thin", "home", "Dest", "target", "result", "desc", "orig", "exit", "later", "file", "sup", "dist", "down", "die", "wb", "temp", "flat", "b", "done", "test", "name", "folder", "destroy", "usr", "tif", "source", "txt"], "in": ["r", "image", "m", "h", "n", "inn", "gin", "stream", "i", "is", "socket", "isin", "impl", "input", "ln", "thin", "id", "din", "conn", "lin", "a", "inner", "pull", "nin", "con", "ini", "rec", "rin", "file", "inside", "f", "url", "login", "ins", "bin", "In", "l", "sub", "reader", "IN", "as", "again", "win", "source", "inc"], "out": ["Out", "client", "self", "writer", "obj", "one", "off", "n", "i", "output", "socket", "app", "ou", "ex", "cache", "home", "conn", "exp", "ext", "io", "exit", "pool", "img", "file", "line", "part", "post", "o", "this", "exec", "err", "temp", "log", "b", "over", "v", "w", "OUT", "again", "outs", "outer", "source", "up", "inc"], "buf": ["bp", "buffer", "bytes", "p", "batch", "seq", "bf", "ctx", "br", "cp", "ab", "fd", "rc", "ff", "tmp", "queue", "bb", "cr", "cf", "length", "bc", "rb", "fb", "bl", "cur", "orig", "fp", "buff", "raw", "count", "uc", "len", "bh", "bd", "bag", "f", "wb", "base", "data", "b", "cv", "cap", "v", "uf", "cmd", "cb"], "c": ["r", "C", "m", " i", "p", "n", "cp", "i", "ce", "rc", "cc", "cr", "e", "lc", "ci", "cy", "cf", "loc", "cd", "cu", "code", "nc", "dc", "a", "pointer", "cur", " n", "cm", "z", "count", "fc", "xc", "uc", " rc", "f", "col", "unc", "enc", "o", "ch", "k", "ac", "u", "b", "v", "cl", "ct", "pc", "l", " b", "d", "cb", "ec"]}}
{"id1": "6009527", "id2": "1421557", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstment", "doFinishloadAttments", "doFinishLoadInstortion", "doFinishloadAttachortion", "doFinishLoadInstachment", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAssment", "doFinishLoadAssachment", "doFinishLoadInstments", "doFinishloadAttachment", "doFinishLoadAssments", "doFinishLoadAttachachment", "doFinishLoadAttment", "doFinishLoadAttments", "doFinishloadAttment", "doFinishloadAttachments", "doFinishLoadAttachments", "doFinishloadAttortion", "doFinishLoadAttortion", "doFinishLoadAssortion"], "attachmentId": ["attentionPath", "attimageInfo", "adachmentPath", "adociationPath", "AttachmentID", "attlementId", "attimagePath", "ttociationID", "attociationID", "attlementType", "attentionType", "attimageID", "attociationPath", "adachmentInfo", "attociationInfo", "attociationId", "attentionID", "adachmentID", "adociationInfo", "ttociationId", "attachmentType", "adociationID", "ttachmentId", "attlementid", "attachmentPath", "AttachmentType", "attplementationid", "ttachmentID", "attachmentID", "attentionInfo", "attentionId", "attentionid", "attachmentid", "ttachmentid", "attociationid", "attplementationID", "attachmentInfo", "AttachmentId", "attplementationId", "Attachmentid", "adociationId", "attimageId", "attlementID", "ttociationid", "adachmentId"], "attachment": ["appachment", "attachached", "instention", "assached", "attruction", "attociation", "attention", "instachment", "attached", " adaptment", " adaptachment", " attention", "assment", "instruction", "attment", "adention", " attociation", "attachruction", " adaptociation", " attment", "adached", "appention", "appment", "association", "assention", "attachachment", "adment", "attachention", "appruction", "adachment", " adaptention", "instment", "assachment"], "attachmentUri": ["attachmentIURI", "attachmentARI", "attachmentCuURI", "attachmentAuri", "attachmentSuuri", "attachedUti", "attachmentAti", "attachmentUURI", "attachmentEti", "attmentUri", "attachmentUti", "attachmentIuri", "attachmentSuURI", "attmentIri", "attachmentURI", "attmentIris", "attachedAti", "attachedAuri", "attachmentSuri", "attachmentCuris", "attachmentCuri", "attmentUURI", "attachmentIris", "attachmentUuri", "attachedUri", "attmentUris", "attachmentCuuri", "attachedARI", "attachmentEuri", "attmentUuri", "attachmentUris", "attachmentEri", "attachmentERI", "attachmentAri", "attachedUuri", "attachmentSuti", "attmentIURI", "attachmentSuRI", "attachedAri", "attachmentIri", "attmentIuri", "attachedURI", "attachmentSuris"], "contentUri": ["contentIi", "resourceUi", " contentUdi", " contentUris", "contentCdi", "resourceIRI", "contentSuris", "contentCRI", "contentUsri", "contentIri", "contentURris", "resourceUri", "contentCri", "resourceIris", "contentCuri", "contentSudi", "contentUuri", "contentFileris", "contentFileuri", "contentUsris", "contentUdi", " contentSuri", "resourceIi", "contentUsdi", "contentURri", "resourceIri", "contentUi", "contentUsRI", " contentSuRI", "resourceUuri", "contentCris", "resourceURI", "contentFileRI", " contentURI", "contentSuRI", "contentURuri", "resourceUris", "contentUsuri", " contentSudi", "contentIris", "contentUris", " contentSuris", "contentSuri", "contentIuri", "contentCi", "contentURi", "contentIRI", "contentFileri", "resourceIuri", "contentURI"], "file": ["get", "image", "auto", "buffer", "upload", "stream", "files", "up", "output", "socket", "object", "use", "view", "load", "input", "copy", "ger", "handler", "picture", "File", "cache", "child", "to", "connection", "content", "path", "resource", "fp", "io", "single", "line", "work", "FILE", "book", "f", "url", "letter", "this", "unit", "base", "binary", "zip", "model", "data", "pe", "create", "b", "local", "log", "via", "name", "entity", "reader", "le", "folder", "uri", "source", "filename", "able"], "in": ["r", "image", "m", "pin", "sync", "inn", "gin", "i", "socket", "s", "init", "input", "e", "copy", "id", "cli", "din", "conn", "or", "connection", "a", "inner", "io", "pull", "nin", "ini", "con", "f", "url", "binary", "this", "o", "login", "data", "err", "ac", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "client", "writer", "sync", "one", "i", "output", "socket", "view", "s", "init", "copy", "on", "cli", "page", "ex", "cache", "to", "conn", "connection", "inner", "ext", "resource", "io", "nin", "line", "o", "this", "null", "base", "exec", "data", "err", "b", "log", "net", "bin", "In", "by", "again", "OUT", "IN", "outs", "outer", "lock", "source", "up", "inc"], "intent": ["request", "category", "animate", "anim", "intention", "term", "ctx", "element", "entry", "concept", "impact", "ink", "focus", "object", "action", "context", "Activity", "init", "eng", "vent", "agent", "android", "content", "inst", "response", "xml", "ant", "feat", "acc", "enc", "this", "feature", "activate", "ents", "spirit", "ani", "contact", " Intent", "ent", "activity", "it", "text", "language", "advert", "document", "activation", "anc", "entity", "event", "act", "effect"]}}
{"id1": "16820041", "id2": "2525897", "code1": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 1, "substitutes": {"encodePassword": ["enodeString", "enodedpassword", "enodeSecret", "enccodePassword", "enoderPassword", "encodepassword", "enodePassword", "enodedPassword", "encodeSecret", "enccodeString", "enodedString", "enoderSecret", "enccodeSecret", "enoderString", "enodedSecret", "enodepassword", "enccodepassword", "enoderpassword", "encodeString"], "_originalPassword": ["_actualPass", "_encryptedPassword", "theoriginalPass", "_OriginalSecret", "_actualSecret", "_origpassword", "_originalpassword", "_originalPass", "_origPassword", "theorigPassword", " _originalSecret", "_editedPass", "_origPass", "_encryptedSalt", " _actualPassword", "theoriginalpassword", "_OriginalPass", "theorigPass", "_actualPassword", " _actualPass", " _originalPass", "_originalSecret", "_editedPassword", "theorigSalt", " _actualSecret", "_originalSalt", "_origSalt", "_encryptedpassword", "_encryptedPass", "theorigpassword", "_Originalpassword", "_editedSecret", "_OriginalSalt", "theoriginalPassword", "theoriginalSalt", "_OriginalPassword"], "md": ["mac", "mm", "pad", "mo", "sd", "m", "Cmd", "dig", "kg", "ph", "db", "mad", "ad", "mn", "id", "pd", "metadata", "ma", "od", "code", "dc", "dr", "alg", "cd", "mb", "cm", "amd", "gb", "df", "dh", "mand", "bd", "gd", "sm", "mg", "dm", "data", "pm", "sha", "mt", "MD", "mp", "mc", "mod", "mag", "hd", "d", "vd", "ld", "ms", "meta", "hash", "cmd", "dd", " MD", "hm"], "encodedPassword": ["encidedSecret", "encachedSecret", "encoderPass", "encapedPassword", "enryptedString", "enodedpassword", "encidedPassword", "enccodedPass", "encoredPassword", "enoderPassword", "encryptedSecret", "enccodedPassword", "encidedPass", "ecryptedString", "enodedPassword", "enryptedpassword", "encoderpassword", "encoredString", "ecodedSecret", "encryptedPassword", "encoredSecret", "enryptedPass", "encryptedpassword", "encodedSecret", "encryptedPass", "enccodedSecret", "enoderPass", "encoderPassword", "enodedString", "encidedpassword", "encodedPass", "enoderSecret", "encodedString", "ecryptedPassword", "enccodedpassword", "encapedString", "encodedpassword", "ecodedPassword", "ecodedString", "encachedString", "encapedpassword", "encachedPassword", "enryptedPassword", "enodedSecret", "encoderString", "ecryptedSecret", "enoderpassword", "encryptedString", "encapedPass", "encoderSecret", "enodedPass"]}}
{"id1": "19944975", "id2": "160739", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeSection", "WriteSection", " writeReport", " writeConfig", "writeConfig", "WriteConfig", "WriteReport", "writeReport", "WriteConfiguration", "saveSection", "saveConfiguration", "saveConfig", " writeSection", "saveReport"], "out": ["Out", "plain", "client", "writer", "m", "obj", "sync", "key", "output", "object", "init", "scope", "user", "write", "parent", "ex", "server", "conn", "inas", "connection", "exp", "path", "resource", "report", "io", "ext", "inner", "xml", "pool", "line", "at", "file", "config", "prefix", "lib", "o", "base", "this", "exec", "temp", "err", "w", "name", "res", "password", "reader", "OUT", "string", "again", "list", "IN", "project", "outs", "window", "flush", "dump", "external", "filename", "c"], "url": ["r", "image", "service", "sl", "stream", "object", "feed", "page", "server", "address", "open", "conn", "connection", "http", "location", "URL", "resource", "path", "io", "ob", "xml", "ssl", "file", "f", "Url", "channel", "base", "api", "data", "b", "rel", "org", "ll", "l", "string", "web", "uri", "source", "config"], "in": ["r", "pin", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "cin", "input", "copy", "id", "din", "conn", "inas", "lin", "a", "inner", "resource", "nin", "xml", "ssl", "rin", "ini", "kin", "file", "inside", "min", "f", "serv", "login", "data", "err", "ac", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "cms", "win", "source", "c", "inc"]}}
{"id1": "14819747", "id2": "421042", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"debug": ["db", "enabled", "error", " DEBUG", "progress", "details", "console", "display", "help", "develop", "trace", "print", "comment", "bug", "ger", "cache", "reg", "module", " debugger", "show", "development", "real", "date", "file", "root", "build", "store", "active", "depth", "production", "die", "doc", "err", "log", " Debug", "test", "tag", "status", "admin", "quiet", "export", "github", " debugging", "plugin", "remote", "enable", "DEBUG", "play", "dev", "dump", "Debug", "config"], "prologFile": ["PrologFile", "prologfile", " prologfile", "proLogfile", "propathDir", " proLogFile", "ProLogString", "propathSourceFile", "probaseFiles", "proversionPath", "proversionSourceFile", "roLogSource", "ProLogfile", " problogfile", "prologFull", " prologFiles", "rologfile", "defblogDir", "proconfigfile", "proconfigFile", "proversionFILE", " prologHeader", "procatfile", "defblogSourceFile", "prologString", "prollFile", "deflogPath", "proLogStream", "prologHeader", " problogSourceFile", "proLogString", "propathFile", "defLogSourceFile", "rologSource", "proflowFile", "rologFile", "proflowSourceFile", "problogSourceFile", " prologFull", "problogDir", "proconfigSourceFile", "prollPath", "proversionFile", "prolexFile", "prologDir", "deflogFile", "rologPath", "proLogFull", "prolexfile", "prologFiles", "ProLogFile", "proconfigPath", "probaseFile", "proLogFile", "deflogfile", "Prologfile", "PrologString", "prolangFile", "proflowDir", " prologStream", " prologSourceFile", "proLogPath", "proflowfile", "proLogFILE", "proLogFiles", "prolangFull", "prologSourceFile", " proLogFiles", "defLogFILE", "roLogPath", "prologSource", "prolangSourceFile", "defblogfile", "deflogDir", "propathfile", "probaseHeader", "ProLogModule", "proconfigFILE", "deflogFILE", "roLogFile", "prolexString", "defblogFile", "prolangfile", " problogFile", "probaseStream", "proLogSourceFile", "prologFILE", "prologStream", "proconfigModule", "PrologModule", "prologModule", "prollSource", "defLogPath", "deflogSourceFile", "roLogfile", "problogHeader", "problogFiles", "proLogModule", "problogFile", "prologPath", "procatFile", "prolexModule", "problogStream", " proLogHeader", "proLogHeader", "defLogFile", "proLogSource", "problogfile", "procatSource", "proconfigString", " proLogStream", "procatPath", "prollfile", " problogFull", "problogFull"], "targetFile": ["targetDir", "targetDirectory", "outputPath", "outputFile", "sourcefile", "outputDir", "targetPath", "targetfile", " targetfile", "sourceFile", "sourcePath", " targetDirectory", "sourceDirectory", "targetFiles", "TargetDirectory", "sourceDir", "Targetfile", "TargetDir", " targetFiles", "TargetPath", "outputfile", "TargetFiles", "TargetFile", "sourceFiles"], "source": ["position", "template", "buffer", "service", "term", "sl", "src", "i", "class", "view", "comment", "use", "scope", "input", "slice", "proxy", "parse", "id", "json", "stack", "target", "result", "format", "content", "message", "resource", "description", "file", "Source", "str", "options", "unit", "model", "session", "data", "type", "zip", "SOURCE", "text", "language", "name", "style", "body", "string", "uri", "ource", "config"], "myParser": [" myReader", "yourParser", "MyJar", " myJar", "MyParser", "yourJar", "yourProgram", "myJar", "MyProgram", "myReader", "yourReader", "MyReader"], "myProgram": ["yourMath", "yourPlan", "MYprogram", "MyParser", "MYParser", "yourProgram", "myMath", " myprogram", "yourprogram", "MyProgram", "theParser", " myPlan", "theMath", "MyPlan", "theProgram", "myPlan", "Myprogram", " myMath", "yourParser", "theprogram", "MYProgram", "myprogram"], "myVisitor": [" myvisIT", "myVisitors", "MyVisulator", "mySignitors", "myVisIT", " myvisitors", "myDesignIT", "myDesignit", "myvisit", "myExitors", "myVISitable", "myVisulator", "myExiter", " myVisitable", " myvisit", "myAuditable", "myVisitit", "myvisiter", "Myvisitors", "myAudit", "MyVisiter", "myvisitor", "myVisititor", "myvisitable", "mySignitor", "myVisiter", "MyVisitor", "myvisulator", "myVISitor", "myDesignitable", "myvisIT", "myVisititable", "mySignulator", "myAuditor", "MyVisitors", " myvisitable", "myDesignitor", " myVisitors", "Myvisiter", " myVisIT", "myAuditors", "myExitor", "Myvisitor", "mySigniter", "myExulator", "Myvisulator", "myVisititors", "myVISit", " myvisitor", "myVisitable", "myVisit", "myvisitors", " myVisit", "myVISIT"], "adapterLayer": ["adviceFactory", "acaptersFactory", "acapterFactory", "acapterContainer", "adapterFactory", "acapterLayer", "acapterBuffer", "acaptersBuffer", "adptionInfo", "adaptersContainer", "adviceLanguage", "adviceInfo", "admissionContainer", "admissionLanguage", "adptionBuffer", "adviceLayer", "acapterInfo", "adviceBuffer", "adapterInfo", "admissionLayer", "adaptersLanguage", "adviceContainer", "adapterBuffer", "acaptersInfo", "acaptersLanguage", "adapterLanguage", "adaptersFactory", "acaptersLayer", "adaptersLayer", "adapterContainer", "acapterLanguage", "adaptersInfo", "adaptersBuffer", "acaptersContainer", "adptionFactory", "adptionLayer"], "classLoader": ["classPath", "ClassPath", "staticDir", "ClassDir", "classDir", "staticLoader", "classloader", " classDir", "ClassLoader", "staticPath", "staticloader", " classPath", " classloader", "Classloader"], "adapterWriter": ["adAdapterReader", "adapterReader", "attapterWriter", "adAdapterwriter", "adaptersReader", "adapterWrite", "attapterwriter", "adapterwriter", "adapterswriter", "adaptersWriter", "adaptersWrite", "admissionWrite", "attaptersReader", "attaptersWriter", "attapterswriter", "adAdapterWriter", "admissionReader", "attapterReader", "attaptersWrite", "adAdapterWrite", "admissionWriter", "admissionwriter", "attapterWrite"], "annotationGenerator": ["annotationgenators", "annnotationGenoder", "annotationGeneroder", "annotationGcer", "annotationGenerators", "annotationgenator", "annotationGator", "annotationgenoder", "annotationGenoder", "annnotationGenerators", "annotationGenator", "annnotationGenerator", "annnotationGenator", "annnotationGeneroder", "annotationGoder", "annnotationGenercer", "annotationGenercer", "annotationGencer", "annnotationGencer", "annotationgencer", "annnotationGenators", "annotationGenators", "annotationGators"], "out": ["Out", "error", "in", "sync", "obj", "query", "n", "flow", "output", "pre", "print", "chain", "user", "parent", "copy", "cli", "page", "server", "cache", "conn", "group", "diff", "state", "code", "array", "io", "line", "raw", "post", "down", "store", "prefix", "temp", "err", "log", "bar", "v", "net", "OUT", "again", "list", "point", "sys", "outer", "outs", "lock", "gen", "cmd", "dump", "up"]}}
{"id1": "2022160", "id2": "9449064", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void main(String[] args) {\n        try {\n            boolean readExp = Utils.getFlag('l', args);\n            final boolean writeExp = Utils.getFlag('s', args);\n            final String expFile = Utils.getOption('f', args);\n            if ((readExp || writeExp) && (expFile.length() == 0)) {\n                throw new Exception(\"A filename must be given with the -f option\");\n            }\n            Experiment exp = null;\n            if (readExp) {\n                FileInputStream fi = new FileInputStream(expFile);\n                ObjectInputStream oi = new ObjectInputStream(new BufferedInputStream(fi));\n                exp = (Experiment) oi.readObject();\n                oi.close();\n            } else {\n                exp = new Experiment();\n            }\n            System.err.println(\"Initial Experiment:\\n\" + exp.toString());\n            final JFrame jf = new JFrame(\"Weka Experiment Setup\");\n            jf.getContentPane().setLayout(new BorderLayout());\n            final SetupPanel sp = new SetupPanel();\n            jf.getContentPane().add(sp, BorderLayout.CENTER);\n            jf.addWindowListener(new WindowAdapter() {\n\n                public void windowClosing(WindowEvent e) {\n                    System.err.println(\"\\nFinal Experiment:\\n\" + sp.m_Exp.toString());\n                    if (writeExp) {\n                        try {\n                            FileOutputStream fo = new FileOutputStream(expFile);\n                            ObjectOutputStream oo = new ObjectOutputStream(new BufferedOutputStream(fo));\n                            oo.writeObject(sp.m_Exp);\n                            oo.close();\n                        } catch (Exception ex) {\n                            ex.printStackTrace();\n                            System.err.println(\"Couldn't write experiment to: \" + expFile + '\\n' + ex.getMessage());\n                        }\n                    }\n                    jf.dispose();\n                    System.exit(0);\n                }\n            });\n            jf.pack();\n            jf.setVisible(true);\n            System.err.println(\"Short nap\");\n            Thread.currentThread().sleep(3000);\n            System.err.println(\"Done\");\n            sp.setExperiment(exp);\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            System.err.println(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "13852596", "id2": "17999474", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"execute": ["process", "all", "transfer", "load", "install", "parse", "copy", "server", "run", " invoke", "apply", "register", "Exec", "evaluate", "handle", "code", "submit", "report", "start", " perform", "exec", "test", "call", "invoke", "ute", "create"], "resources": ["items", "locks", "flows", "scripts", "models", "files", "types", "strings", "Resources", "cells", "archives", "events", "maps", "workers", "projects", "chains", "features", "objects", "stores", "writers", "issues", "resource", "reports", "services", "images", "params", "results", "apps", "roots", "ions", "classes", "relations", "pages", "series", "works", "rates", "users", "groups", "rings", "ids", "stars", "thumbnails", "rules", "plugins"], "i": ["ai", "ip", "wei", "iri", "j", "h", "ic", "p", "ie", "eni", "is", "s", "multi", "e", "phi", "abi", "mu", "ci", "gi", "id", "isi", "cli", "ui", "info", "ori", "li", "ii", "io", "vi", "iu", "ir", "esi", "ini", "we", "bi", "pi", "f", "o", "xi", "ami", "ti", "k", "ri", "u", "ani", "v", "oi", "di", "l", "hi", "si", "qi", "uri", "I"], "classFile": ["serviceFile", "objectfile", "staticFile", "ruleFiles", "sessionFiles", "CLASSFiles", "basefile", "fileFile", "CLASSImage", "sessionFile", "customFile", "ClassPath", "connectionFile", "ClassEntry", "classClass", "classPage", "connectionStream", "finalFile", " classFiles", "customFiles", "baseFile", "lassClass", "sessionEntry", "ClassDirectory", "sessionFactory", "ClassDir", "ruleLine", "connectionFiles", "finalfile", " classFILE", "ClassFilename", "ClassLine", "classFiles", " classStream", "CLASSDirectory", "classesFiles", "classesfile", "CLASSPage", "ClassFactory", " classEntry", "Classfile", "packEntry", "serviceLine", "classFactory", "ClassGlobal", "ClassImage", "serviceFILE", "finalFILE", "lassFile", "classGlobal", "classLine", "classEntry", " classPage", " classPath", "ClassFile", "CLASSfile", "objectDir", "fileDirectory", "packFILE", "classDir", "staticfile", "ClassPage", " classGlobal", " classDir", "lassGlobal", "classesFile", "ruleFile", "classFilename", "objectFiles", "sessionfile", "classLoader", "classesPath", "ClassFiles", " classFilename", "classDirectory", "packfile", "CLASSEntry", "objectFile", " classfile", "classPath", "CLASSLoader", "fileLoader", "ClassStream", "classStream", " classFactory", "baseUrl", "fileFiles", "sessionFILE", "staticFILE", "classUrl", "CLASSFILE", "baseFILE", "servicefile", "CLASSUrl", "fileLine", "finalUrl", "CLASSLine", "staticLine", " classLine", "filefile", " classClass", "classImage", "CLASSFile", "classfile", "ClassFILE", "customFILE", "classFILE", " classLoader", "customEntry", "packFile", "lassFiles", "fileImage", "connectionfile", "ClassClass", "ruleFilename"], "inputStream": ["outputContext", "InputFile", "rawSteam", "uploadStream", "initStreamer", "initSteam", "importSteam", "inputSw", "activeStream", "outputstream", "activeStreamer", "inputContext", "childContext", "outputFile", "Inputstream", "initstream", " inputSteam", "uploadSw", "rawStream", "uploadFile", "outputStreamer", "initStream", "activeSteam", " inputStreamer", "importstream", "importStreamer", " inputstream", "InputSteam", "importStream", "outputReader", "outputSteam", "InputSw", "rawStreamer", "rawFile", "InputStreamer", " inputFile", "inputSteam", "childstream", "InputStream", " inputContext", "childStream", "inputReader", "binarySteam", " inputReader", "binaryFile", "inputFile", "binaryStreamer", "binaryStream", "outputSw", "uploadstream", "childReader", "activestream", "inputStreamer", "inputstream"], "reader": ["request", "client", "buffer", "ner", "worker", "sync", "Reader", "entry", "stream", "rer", "author", "key", "rc", "context", "input", "owner", "layer", "reflect", "ee", "ger", "rx", "copy", "handler", "server", "Writer", "per", "ler", "or", "dr", "writers", "http", "inner", "editor", "resource", "report", "io", "war", "rr", "manager", "keeper", "row", "reading", "book", "director", "rar", "riter", "iter", "wrapper", "builder", "ri", "re", "loader", "system", "er", "oder", "arser", "driver", "parser", "seed", "draft", "read", "shared", "source", "right"], "oldSize": ["OldSize", "prevSc", "prevLength", " oldSc", "prevSize", "OldSc", " oldName", " oldLength", "OldLength", "oldName", "OldName", "oldLength", "oldSc", "prevName"], "writer": ["r", "wire", "buffer", "service", "ner", "creator", "worker", "Reader", "element", "author", "object", "write", "ee", "e", "maker", "handler", "Writer", "written", "child", "ler", "format", "writers", "dc", "inner", "editor", "war", "resource", "io", "word", "index", "report", "manager", "row", "wr", "director", "riter", "rw", "iter", "winner", "engine", "wrapper", "builder", "data", "wer", "loader", "her", "player", "er", "token", "oder", "w", "document", "driver", "writ", "string", "parser", "draft", "read", "writing", "widget", "walker"], "b": ["r", "db", "buffer", "m", "h", "p", "g", "br", "ab", "lb", "object", "emb", "bb", "e", "boot", "rb", "fb", "a", "be", "ob", "pb", "B", "bd", "f", "eb", "binary", "null", "base", "abc", "k", "u", "bar", "ba", "w", "l", "bin", "d", "orb", "c"], "outputStream": ["inputView", "outStream", "outputstream", "outStreamer", "protectedStream", "OutputStream", "dataStreamer", "OutputStreamer", " outputstream", " outputSteam", "outputStreamer", "outstream", "inputStreamer", "outputSteam", "dataSteam", "inputContainer", "protectedstream", "OutputView", "inputSteam", "dataStream", " outputView", " outputStreamer", "Outputstream", "protectedStreamer", "OutputSteam", "outSteam", "dataContainer", "protectedSteam", " outputContainer", "outputView", "outputContainer", "inputstream"], "injectedClasses": ["injectedclassies", "injectedWrities", "injectedClassies", "injectionclassites", "injectedProjectites", "injectionclassies", "injectionClassies", "injectedProjecties", "injectionclasses", "injectedclasses", "injectionClassites", "injectionClasses", "injectionclasss", "injectedclasss", "injectedProjects", "injectionClasss", "injectedWrites", "injectedClasss", "injectedWritites", "injectedProjectes", "injectedClassites", "injectedclassites", "injectedWrits"], "newSize": ["newFontSize", " newStorage", "finalSize", "NewLength", "NewStorage", "NewSize", "NewFontSize", " newFontSize", "newLength", "finalStorage", "finalLength", "newStorage", "finalFontSize", " newLength"]}}
{"id1": "17538992", "id2": "1586662", "code1": "    public static boolean check(String urlStr) {\n        try {\n            URL url = new URL(urlStr);\n            HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n            urlConnection.setConnectTimeout(2000);\n            urlConnection.getContent();\n        } catch (Exception e) {\n            logger.error(\"There is no internet connection\", e);\n            return false;\n        }\n        return true;\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"check": ["get", "process", "match", "ok", "CHECK", "load", "complete", "run", "info", "Check", "resource", "checked", "work", "find", " Check", "start", "link", "checking", "close", "checks", " checking", "exec", "update", "login", " checks", "test", "call"], "urlStr": ["urlName", "httpName", "resourceString", "httpText", "urlstr", "resourceText", "URLName", "resourcestr", " urlstr", " urlText", "httpstr", "urlText", "httpStr", " urlName", "URLString", "urlSTR", "httpSTR", "URLStr", " urlSTR", "resourceStr", "httpString", "urlString", " urlString", "URLSTR"], "url": ["r", "image", "blog", "client", "sl", "obj", "host", "object", "feed", "impl", "user", "ls", "page", "www", "server", "address", "open", "conn", "connection", "http", "URL", "resource", "ssl", "build", "str", "f", "Url", "channel", "base", "data", "b", "log", "ll", " URL", "l", "browser", "string", "web", "uri", "layer", "config", "c"], "urlConnection": ["UrlConnection", "httpConnection", "URLconnection", "urlC", " urlconn", "urlconnection", "sslConnection", "urlUrl", "httpSocket", "urlSocket", "newConnection", "URLContainer", "httpconnection", "sslconn", "UrlSocket", "UrlConfig", "httpUrl", "URLUrl", "httpconn", "newContainer", " urlConfig", "httpConfig", " urlSocket", " urlC", "sslconnection", "httpContainer", "Urlconnection", " urlconnection", "urlConfig", "httpC", "URLConnection", "newconnection", "urlContainer", "newUrl", "urlconn", "sslC"]}}
{"id1": "693636", "id2": "932225", "code1": "    public static int createEmptyCart() {\n        int SHOPPING_ID = 0;\n        Connection con = null;\n        try {\n            con = getConnection();\n        } catch (java.lang.Exception ex) {\n            ex.printStackTrace();\n        }\n        try {\n            PreparedStatement insert_cart = null;\n            SHOPPING_ID = Integer.parseInt(Sequence.getSequenceNumber(\"shopping_cart\"));\n            insert_cart = con.prepareStatement(\"INSERT INTO shopping_cart (sc_id, sc_time) VALUES ( ? , NOW() )\");\n            insert_cart.setInt(1, SHOPPING_ID);\n            insert_cart.executeUpdate();\n            con.commit();\n            insert_cart.close();\n            returnConnection(con);\n        } catch (java.lang.Exception ex) {\n            try {\n                con.rollback();\n                ex.printStackTrace();\n            } catch (Exception se) {\n                System.err.println(\"Transaction rollback failed.\");\n            }\n        }\n        return SHOPPING_ID;\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 0, "substitutes": {"createEmptyCart": ["createNewSpot", "createNewcart", " createEmptySpot", "createCreatecart", "createCreateSpot", "createNewShipping", "createCreateCart", " createEmptyShipping", "createTempCart", "createTempShipping", "createEmptycart", "createEmptyShipping", " createNewSpot", " createNewCart", "createNewCart", "createCreateShipping", " createEmptycart", "createTempcart", "createEmptySpot", " createNewcart", " createNewShipping", "createTempSpot"], "SHOPPING_ID": ["SHOPPINGIDIDs", "SHOPPING_IDs", "SHOPPINGIDid", "SHOPPIPIDIDS", "SHOPPTING_id", "SHOPPYING_IDs", "SHOPPIPIDID", "SHOPPING_Id", "SHOPPING_id", "SHOPPINGINGID", "SHOPPIP_Id", "SHOPPINGINGid", "SHOPPIPIDId", "SHOPPIP_IDS", "SHOPPIPIDid", "SHOPPINGIDID", "SHOPPINGIDId", "SHOPPYING_Id", "SHOPPYING_ID", "SHOPPIP_ID", "SHOPPINGINGId", "SHOPPTING_Id", "SHOPPINGPOID", "SHOPPINGIDIDS", "SHOPPINGPOIDs", "SHOPPING_IDS", "SHOPPINGPOId", "SHOPPIP_id", "SHOPPYING_IDS", "SHOPPTING_ID", "SHOPPINGPOIDS", "SHOPPIP_IDs", "SHOPPIPIDIDs"], "con": ["db", "client", "connect", "ca", "Conn", "cas", "ctx", "fa", "cond", "rc", "cc", "cn", "cons", "cr", "CON", "ex", "ci", "cf", "com", "coll", "cache", "reg", "conn", "loc", "ann", "ran", "connection", "bc", "cur", "cm", "pool", "conf", "fc", "uc", "row", "Con", "en", "ctrl", "close", "col", "exec", "conv", "session", "ac", "can", "log", "wan", "pc", "co", "fac", "mc", "un", "commit", "act", "win", "pen", "c", "inc", "ec"], "insert_cart": ["insert_ox", "insert_cat", " insert_pod", "insertencart", "insert_payment", " insert_cat", "insertencycle", "insert_center", "insert_container", "exec_payment", "insert_conn", "insert_cycle", "install_cart", "insertencenter", "insertencat", " insert_conn", "insert_part", "install_part", "exec_Cart", "install_container", " insert_ox", " insert_center", "insert_pod", " insert_cycle", "insert_Cart", "exec_cart"]}}
{"id1": "17901739", "id2": "21827619", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 0, "substitutes": {"setMembers": ["setJoin", "SetJoin", "SetMembers", "setMember", "SetMethods", " setJoin", "parseMembers", " setMethods", "parseMember", "parseJoin", "setMethods", "parseMethods", "SetMember", " setMember"], "url": ["image", "blog", "client", "service", "email", "sl", "entry", "queue", "socket", "feed", "user", "server", "address", "connection", "http", "location", "URL", "resource", "path", "io", "hub", "ssl", "file", "Url", "channel", "base", "data", "loader", "org", "article", "l", "string", "uri", "source", "www"], "reader": ["r", "iterator", "writer", "ner", "worker", "Reader", "entry", "stream", "rer", "i", "rc", "feed", "input", "e", "handler", "server", "per", "ler", "http", "inner", "editor", "report", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "f", "builder", "err", "loader", "er", "driver", "l", "table", "parser", "read", "bird"], "buffer": ["video", "image", "stage", "sync", "flash", "FFER", "comment", "Buffer", "address", "info", "fb", "http", "str", "iter", "buf", "base", "text", "string", "uri", "window", "flush", "length", "request", "bytes", "batch", "feed", "input", "parse", "page", "cache", "rb", "response", "message", "buff", "file", "uffer", "b", "bar", "border", "pause", "button", "writer", "fr", "received", "output", "bb", "expression", "phrase", "result", "padding", "line", "row", "null", "player", "paste", "wave", "background", "password", "counter", "seed", "layer", "source", "filename", "template", "queue", "read", "transfer", "sequence", "server", "game", "code", "resource", "binary", "data", "loader", "document", "bin", "header", "texture"], "pattern": ["image", "position", " Pattern", "match", "template", "cher", "script", "object", "print", "feed", "app", "slice", "serial", "expression", "patch", "handler", "Pattern", "rule", "cache", "child", "group", "format", "array", "graph", "path", "regular", "df", "function", "file", "part", "str", "letter", "model", "system", "builder", "type", "log", "number", "atter", "document", "password", "counter", "string", "parser", "command", "filter", "event", "re", "layer", "config", "condition"], "matcher": ["reches", "ratger", "patatcher", "manacher", "statcher", "compner", "patner", "mitchers", "ratacher", "Matpattern", "matchpattern", "Matger", "statpattern", "captatter", "attacher", "compatcher", " matter", "captpattern", "patcher", "matacher", "mirher", "matches", " matpattern", "mither", "Matner", "harpattern", "matchher", "matchers", "motpattern", "reched", "harcher", "reach", "compach", "patch", "mather", "Matching", "matatcher", "matchched", "mancher", "compched", " matacher", "harner", " mather", "captter", "motner", "matchches", " matatter", "matger", " matler", "attcher", "matchler", "matchter", "manher", "matching", "patpattern", "compter", "matatter", "patter", "matpattern", "matler", "mirter", "Matacher", "linter", "matach", "matchach", "pather", "ratcher", " matchers", "Matter", "compcher", " match", "ratching", "captcher", "linatter", "statler", "linpattern", "statner", "motter", "lincher", "attching", "match", "matchcher", "mircher", "attger", "patchers", "manner", "mirpattern", "harler", "Matcher", "mitcher", "compches", "matchatcher", "matchacher", "matched", "recher", "motcher", "matter", "matner", " matner", "mitch", "matchner", "Mather"], "erg": ["der", "gr", "ander", "gae", "irc", "orter", "eur", "gru", "eri", "progress", "ag", "worker", "justice", "rator", "rog", "git", "ga", "ord", "eng", "igor", "gra", "east", "ger", "gg", "urg", "ero", "sg", "eric", "yang", "game", "dr", "aug", "alg", "berg", "region", "gy", "magic", "oga", "gd", "feat", "orters", "era", "ager", "porter", "uster", "jing", "org", "arc", "ERG", "er", "agog", "ig", "forge", "rg", "ider", "og", "usa", "clus", "ers", "ocr", "aga", "ard", "anger", "gas", "ung", "agg"], "start": ["pad", "size", "sort", "grad", "old", "mid", "address", "open", "info", "last", "something", "end", "space", "st", "base", "name", "ind", "get", "End", "fit", "off", "load", "begin", "check", "boot", "diff", "state", "inner", "index", "find", "part", "started", "close", "unit", "set", "scale", "pend", "offset", "stop", "like", "middle", "in", "stat", "art", "init", "ad", "starting", "id", "run", "plus", "sum", "grade", "pick", "Start", "show", "work", "count", "step", "min", "it", "seed", "speed", "head", "first", "add", "shift", "source", "position", "match", "cost", "max", "ie", "pos", "read", "sol", "se", "send", "fill", "need", "ish", "none", "rest", "type", "bin", "style", "current"], "von": ["fin", "su", "flo", "jan", "tu", "eni", "melon", "vid", "bn", "endon", "nn", "vu", "ou", "tin", "fen", "oni", "ln", "won", "zon", "han", "jen", "aven", "dn", "lin", "ver", "fat", "bon", "anon", "vin", "andon", "lon", "olson", "fn", "uber", "fun", "feat", "len", "kn", "hon", "wen", "don", "byn", "tun", "mun", "di", "hn", "vor", "onna", "bin", "ten", "mon", "lu", "evin", "endor", "una", "john", "non"], "bis": ["os", "bs", "vid", "ois", "phis", "lins", "bid", "zi", "fb", "bas", "len", "bits", "prefix", "base", "bat", "vs", "bos", "outs", "isin", "eni", "is", "bus", "uno", "nas", "isi", "ris", "val", "boot", "ios", "li", "vin", "buff", "offs", "bi", "uss", "su", "BUS", "us", "cus", "oss", "ls", "bb", "nexus", "abi", "lin", "obs", "cos", "bps", "sis", "bian", "ri", "bles", "cedes", "vals", "pos", "oris", "cin", "oni", "ui", "los", "fat", "ori", "bes", "ours", "pi", "onis", "des", "ni", "pins", "di", "bin", "lus", "bett", "udi", "idis"], "m_strComponents": ["m_strExpales", "m_strComponent", "m_strExpenses", "m_intRepales", "m_intComports", "m_arrCommales", "m_intReports", "m_strRepales", "m_intRepenses", "m_strCompenses", "m_strReports", "m_strExponents", "m_strRepenses", "m_arrCommonent", "m_arrCompenses", "m_arrComponents", "m_strReponents", "m_strCommonent", "m_strExports", "m_arrCommenses", "m_strCommales", "m_intReponents", "m_intCompales", "m_strCommenses", "m_strComponentonents", "m_arrComponent", "m_intCompenses", "m_strCommorts", "m_intComponents", "m_arrCommonents", "m_strExponent", "m_strCommonents", "m_strCompales", "m_strComponentales", "m_strComponentonent", "m_arrCompales", "m_strComponentenses", "m_strComports"], "m_strPriorities": ["m_intPrefries", "m_strActivities", "m_strActivries", "m_StrPriority", "m_strComparifiers", "m_strPrioritives", "m_strMonities", "m_intPrioritions", "m_strMonitives", "m_StrPosity", "m_strComparities", "m_intPriorries", "m_intPriorities", "m_StrPriorities", "m_strPrefitions", "m_StrPrioritions", "m_intPrioritives", "m_strPositions", "m_strComparitions", "m_StrPositions", "m_strPriorries", "m_strActivitions", "m_intPrefitives", "m_strPrefries", "m_strPrefitives", "m_StrPosifiers", "m_strQualitions", "m_strActivitives", "m_strMonitions", "m_strComparity", "m_strPosity", "m_strMonries", "m_intPrefities", "m_strPosities", "m_strPriority", "m_strPriorifiers", "m_intPrefitions", "m_StrPosities", "m_strQuality", "m_strQualifiers", "m_strPosifiers", "m_strQualities", "m_StrPriorifiers", "m_strPrioritions", "m_strPrefities"]}}
{"id1": "17475530", "id2": "6966398", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"testAddLinkToImage": ["testAddLinkOfPicture", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinktoFile", "testAddLinksToLink", "testAddLinkOfLink", "testAddLinksToPicture", "testAddLinkstoPicture", "testAddLinkFromLink", "testAddLinkOfFile", "testAddLinktoLink", "testAddLinkstoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToImage", "testAddLinkFromImage", "testAddLinkstoFile", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromFile", "testAddLinkstoImage", "testAddLinksToFile", "testAddLinktoPicture"], "in": ["r", "image", "get", "m", "pin", "n", "inn", "gin", "isin", "stream", "is", "i", "socket", "el", "cin", "input", "version", "copy", "id", "ex", "din", "val", "conn", "diff", "ax", "or", "connection", "exp", "index", "resource", "path", "nin", "xml", "ssl", "out", "ini", "con", "work", "file", "rin", "at", "min", "f", "url", "pass", "exec", "serv", "login", "doc", "data", "err", "with", "token", "ins", "name", "bin", "In", "reader", "IN", "as", "again", "uri", "win", "source", "ac", "inc"]}}
{"id1": "15768167", "id2": "17116123", "code1": "    public static void copyFile(File in, File out) throws Exception {\n        FileChannel sourceChannel = null;\n        FileChannel destinationChannel = null;\n        try {\n            sourceChannel = new FileInputStream(in).getChannel();\n            destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        } finally {\n            if (sourceChannel != null) sourceChannel.close();\n            if (destinationChannel != null) destinationChannel.close();\n        }\n    }\n", "code2": "    public void deleteAuthors() throws Exception {\n        if (proposalIds.equals(\"\") || usrIds.equals(\"\")) throw new Exception(\"No proposal or author selected.\");\n        String[] pids = proposalIds.split(\",\");\n        String[] uids = usrIds.split(\",\");\n        int pnum = pids.length;\n        int unum = uids.length;\n        if (pnum == 0 || unum == 0) throw new Exception(\"No proposal or author selected.\");\n        int i, j;\n        PreparedStatement prepStmt = null;\n        try {\n            con = database.getConnection();\n            con.setAutoCommit(false);\n            String pStr = \"delete from event where ACTION_ID='member added' AND PROPOSAL_ID=? AND SUBJECTUSR_ID=?\";\n            prepStmt = con.prepareStatement(pStr);\n            for (i = 0; i < pnum; i++) {\n                for (j = 0; j < unum; j++) {\n                    if (!uids[j].equals(userId)) {\n                        prepStmt.setString(1, pids[i]);\n                        prepStmt.setString(2, uids[j]);\n                        prepStmt.executeUpdate();\n                    }\n                }\n            }\n            con.commit();\n        } catch (Exception e) {\n            if (!con.isClosed()) {\n                con.rollback();\n                prepStmt.close();\n                con.close();\n            }\n            throw e;\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "p", "inn", "isin", "i", "is", "input", "id", "ex", "diff", "inner", "index", "resource", "io", "work", "at", "file", "min", "f", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "d", "again", "lock", "source", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "obj", "off", "output", "object", "parent", "ex", "server", "cache", "conn", "to", "target", "result", "resource", "io", "line", "file", "dest", "part", "at", "dot", "o", "prefix", "base", "exec", "data", "err", "temp", "b", "v", "w", "name", "project", "string", "again", "outs", "source", "OUT", "c"], "sourceChannel": ["srcLog", "srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "resourceContext", "serviceConnection", "inputChannel", " sourceSocket", "resourceChannel", "ourcechannel", "inputContext", " sourceLog", "sourceContext", "targetStream", "sourceBuffer", "srcchannel", "ourceChannel", "targetChannel", "resourceFeed", "sourceLog", "targetchannel", " sourceService", "resourceConnection", "targetChan", " sourceBuffer", "ourceService", "sourceStream", "resourceService", "resourcechannel", "serviceChannel", "sourceConnection", "SourceLog", "inputChan", " sourceChan", "targetBuffer", " sourceContext", "SourceBuffer", " sourcechannel", "SourceChannel", "ourceSocket", " sourceConnection", "servicechannel", "serviceSocket", "sourceService", " sourceFeed", "resourceChan", "targetConnection", "Sourcechannel", "ourceConnection", "inputFeed", "sourceFeed", "sourcechannel", "SourceChan", "sourceSocket"], "destinationChannel": ["DestinationStream", "destinatingConnection", "DestinationChannel", "destinatorUrl", "destionchannel", "destinatedChannel", "destationChan", "desturationchannel", "destinationManager", "DestinatorUrl", "destinatedManager", "destinatingchannel", "DestinationCh", "Destinatorchannel", "destionChan", "destinatedConnection", "DestinationConnection", "destinatorConnection", "destionStream", "destinatedCh", "desturationUrl", "destinationCh", "destinatedchannel", "destationchannel", "DestinationManager", "destinatorchannel", "destinatedUrl", "destationChannel", "destationConnection", "destinationConnection", "DestinatorChannel", "destinatingChannel", "destinatorChannel", "destinationchannel", "Destinationchannel", "destationStream", "DestinatorManager", "DestinationChan", "desturationChan", "DestinatorConnection", "destionChannel", "destinationStream", "destinatorCh", "DestinationUrl", "desturationChannel", "destinatorChan", "destinatingManager", "DestinatorChan", "DestinatorCh", "destinatorManager", "destinationUrl", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "20568568", "id2": "8770016", "code1": "    private String createHTML(PAGE_TYPE requestPage) {\n        String result = \"<html><head>\";\n        URL url = getClass().getClassLoader().getResource(\"org/compiere/images/PAPanel.css\");\n        InputStreamReader ins;\n        try {\n            ins = new InputStreamReader(url.openStream());\n            BufferedReader bufferedReader = new BufferedReader(ins);\n            String cssLine;\n            while ((cssLine = bufferedReader.readLine()) != null) result += cssLine + \"\\n\";\n        } catch (IOException e1) {\n            log.log(Level.SEVERE, e1.getLocalizedMessage(), e1);\n        }\n        switch(requestPage) {\n            case PAGE_LOGO:\n                result += \"</head><body class=\\\"header\\\">\" + \"<table width=\\\"100%\\\"><tr><td>\" + \"<img src=\\\"res:org/compiere/images/logo_ad.png\\\">\" + \"</td><td></td><td width=\\\"290\\\">\" + \"</td></tr></table>\" + \"</body></html>\";\n                break;\n            case PAGE_HOME:\n                result += \"</head><body><div class=\\\"content\\\">\\n\";\n                queryZoom = null;\n                queryZoom = new ArrayList<MQuery>();\n                String appendToHome = null;\n                String sql = \" SELECT x.AD_CLIENT_ID, x.NAME, x.DESCRIPTION, x.AD_WINDOW_ID, x.PA_GOAL_ID, x.LINE, x.HTML, m.AD_MENU_ID\" + \" FROM PA_DASHBOARDCONTENT x\" + \" LEFT OUTER JOIN AD_MENU m ON x.ad_window_id=m.ad_window_id\" + \" WHERE (x.AD_Client_ID=0 OR x.AD_Client_ID=?) AND x.IsActive='Y'\" + \" ORDER BY LINE\";\n                PreparedStatement pstmt = null;\n                ResultSet rs = null;\n                try {\n                    pstmt = DB.prepareStatement(sql, null);\n                    pstmt.setInt(1, Env.getAD_Client_ID(Env.getCtx()));\n                    rs = pstmt.executeQuery();\n                    while (rs.next()) {\n                        appendToHome = rs.getString(\"HTML\");\n                        if (appendToHome != null) {\n                            if (rs.getString(\"DESCRIPTION\") != null) result += \"<H2>\" + rs.getString(\"DESCRIPTION\") + \"</H2>\\n\";\n                            result += stripHtml(appendToHome, false) + \"<br>\\n\";\n                        }\n                        if (rs.getInt(\"AD_MENU_ID\") > 0) {\n                            result += \"<a class=\\\"hrefNode\\\" href=\\\"http:///window/node#\" + String.valueOf(rs.getInt(\"AD_WINDOW_ID\") + \"\\\">\" + rs.getString(\"DESCRIPTION\") + \"</a><br>\\n\");\n                        }\n                        result += \"<br>\\n\";\n                        if (rs.getInt(\"PA_GOAL_ID\") > 0) result += goalsDetail(rs.getInt(\"PA_GOAL_ID\"));\n                    }\n                } catch (SQLException e) {\n                    log.log(Level.SEVERE, sql, e);\n                } finally {\n                    DB.close(rs, pstmt);\n                    rs = null;\n                    pstmt = null;\n                }\n                result += \"<br><br><br>\\n\" + \"</div>\\n</body>\\n</html>\\n\";\n                break;\n            default:\n                log.warning(\"Unknown option - \" + requestPage);\n        }\n        return result;\n    }\n", "code2": "    public InputStream loadResource(String location) throws GenericConfigException {\n        URL url = getURL(location);\n        try {\n            return url.openStream();\n        } catch (java.io.IOException e) {\n            throw new GenericConfigException(\"Error opening URL resource at location [\" + url.toExternalForm() + \"]\", e);\n        }\n    }\n", "label": 0, "substitutes": {"createHTML": ["createCSS", " createCSS", "CreateH", "createH", " createPDF", "createPDF", "newH", "newHTML", "CreateHTML", "CreateCSS", "newPDF", " createH", "CreatePDF", "newCSS"], "requestPage": [" requestPages", "requestpage", "thisPages", "RequestPage", "thisPage", "pagepage", "RequestPC", "requestPC", " requestpage", "RequestResult", "thispage", "Requestpage", "requestResult", "thisRequest", "returnPage", "pageResult", "pagePC", " requestResult", " requestRequest", "returnPages", "returnpage", "requestRequest", " requestPC", "returnRequest", "requestPages", "pagePage"], "result": ["success", "compl", "match", "detail", "error", "html", "msg", "summary", "output", "order", "comment", "future", "section", "page", "valid", "cache", "json", "complete", "replace", "answer", "info", "diff", "sum", "content", "response", "resource", "message", "report", "Result", "our", "ret", "results", "description", "value", "date", "root", "part", "feature", "data", "err", "cup", "mark", "test", "status", "color", "document", "figure", "res", "string", "header", "menu", "event", "up"], "url": ["image", "r", "in", "buffer", "service", "sl", "src", "host", "class", "feed", "fl", "ls", "page", "server", "bel", "connection", "http", "hub", "URL", "resource", "path", "io", "pull", "resources", "ssl", "file", "link", "f", "Url", "channel", "base", "plug", "data", "download", "gl", "loader", "b", "org", "ll", "name", "l", "string", "web", "uri", "source", "up"], "ins": ["vals", "r", "in", "ils", "Ins", "bis", "qs", "inn", "gin", "src", "is", "bs", "s", "limits", "its", "ls", "cons", "ips", "INS", "ens", "din", "lines", "ris", "fe", "ks", "inas", "lin", "rss", "inner", "ios", "kin", "ds", "abs", "fs", "ints", "alls", "ans", "pins", "rows", "vs", "ains", "als", "reader", "as", "ps", "outs", "ats", "ws", "ts", "inc", "plugins"], "bufferedReader": ["BuffererWriter", "BuffererRead", "buffledStream", "buffledRead", "bufferedRead", "buffenedReader", "bufferedStream", "buffenedWriter", "BufferedWriter", "bufferingReader", "BufferedReader", "bufferingStream", "bufferingWriter", "bufferedIn", " buffenedReader", " buffenedWriter", " bufferedIn", "buffererStream", "bufferingRead", "buffererReader", "BufferedRead", " bufferedWriter", "buffererWriter", "buffledWriter", "buffererRead", "BuffererStream", "buffledReader", "buffaredIn", "bufferedWriter", " buffenedStream", "buffaredStream", "buffledIn", " buffenedIn", "BufferedStream", " bufferedStream", "buffaredWriter", "BuffererReader", "buffenedStream", "buffaredReader", "buffenedIn"], "cssLine": ["ssLine", "styleBlock", "styleFile", "urlL", "ssBlock", "ssRow", "cssL", "cssline", "CSSL", "csvLine", "CSSLine", "rssFile", "cssBlock", "styleline", "urlRow", "ssline", "cssRow", "rssline", "csvline", "urlline", "CSSline", "styleStr", "ssFile", "csvStr", "csvBlock", "cssStr", "styleLine", "rssLine", "CSSRow", "urlLine", "cssFile", "ssL", "rssBlock", "ssStr"], "e1": ["e2", "me8", "e3", "E2", " e8", "er3", "er1", "e8", "E1", " e9", "me1", "e9", "Eone", "aeOne", " e2", "erone", "er2", "me2", "eaone", "meOne", "ea9", "eone", " eOne", "eOne", "ae2", "E9", "ae1", "ae8", " eone", " e3", "ea1", "E3", "ea2"], "queryZoom": [" queryZooming", "queryzom", "queryXoom", "querySlom", " queryzooming", " queryzom", "queryExom", "queryExoom", " queryzoo", "queryZom", "queryzoo", "queryScom", "queryExooming", "queryScoom", "queryScooming", "querySloom", " queryZom", " queryZoo", "queryZoo", "querySlooming", "queryExoo", "queryXom", "queryXooming", "queryzoom", "queryXoo", "queryzooming", "queryZooming", " queryzoom"], "appendToHome": [" appendToBack", "appendFromBack", " append2Page", "appendFromHome", " appendFromBack", " appendFromPage", "appendToBack", " appendOnRoot", " appendOnBack", "appendFromRoot", " append2Back", "appendFromPage", "appendToRoot", " append2Home", " appendOnPage", " appendOnHome", " appendToRoot", " appendFromHome", " appendToPage", " append2Root", " appendFromRoot", "appendToPage"], "sql": ["vals", "job", "db", "expr", "details", "query", "msg", "QL", "comment", "id", "statement", " SQL", "SQL", "conn", "pr", "params", "ssl", "csv", "str", "col", "serv", "base", "sq", "log", "printf", "database", "dl", "shell", "eps", "table", "ql", "res", "body", "string", "general", "seed", "setup", "sys", "sv", "lock", "select"], "pstmt": [" pscm", "pctm", " pscmt", "pspmd", "pcttr", "psthpt", "pscmd", "pstrmt", "psthm", "pft", "pctct", "Pstnt", " pstmp", "pscm", "pstpt", "postmp", "pstrt", "pspm", "ppttr", "pscpr", "pfnt", "pctt", "pptmt", "pctmp", "pstmd", "pscpt", "pctmt", "pptmp", "pstmp", " postmt", " psttr", "psthpr", "pfct", " pstpt", "pstct", "psthmd", "pstnt", "psppt", " pstm", "pspmt", "psthmt", "postct", " pscct", "Pctt", "pptct", "pstpr", "pscmt", "pstt", "Pstmt", " pscpr", "Pctmt", "Pctct", "Pstt", "pscct", "psttr", " postct", " pstpr", " postmp", " pscmd", "pstrnt", "Pstct", " pstmd", "posttr", "pstrct", " posttr", "pctnt", "pctpr", "pstm", "psthct", "postmt", "pfmt", " pstct", " pscpt", "Pctnt"], "rs": ["r", "details", "RS", "qs", "rd", "rl", " res", "rc", "cs", "Rs", "bs", "ls", "LS", "ows", "RC", "ris", "ks", " Rs", "dr", "rss", "rb", "rm", "ras", "results", "rr", "ds", "sr", "mr", "relations", "ars", "rt", "errors", "eps", "rows", "ops", "res", "ps", "runs", "pps", "RR", " RS", "pr"]}}
{"id1": "7458833", "id2": "732800", "code1": "    private void copyParseFileToCodeFile() throws IOException {\n        InputStream in = new FileInputStream(new File(filenameParse));\n        OutputStream out = new FileOutputStream(new File(filenameMisc));\n        byte[] buffer = new byte[1024];\n        int length;\n        while ((length = in.read(buffer)) > 0) out.write(buffer, 0, length);\n        in.close();\n        out.close();\n    }\n", "code2": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "label": 1, "substitutes": {"copyParseFileToCodeFile": [" copyParseFileToOutputFiles", " copyParseFileToCodeClass", " copyParseFileTocodeFile", " copyParseFiletoCodeFiles", " copyParseFiletoCodeFile", " copyParseFiletoOutputFile", " copyParseFileToOutputFile", " copyParseFileTocodeClass", " copyParseFiletoCodefile", " copyParseFileToCodefile", " copyParseFileToOutputfile", " copyParseFileTocodeFiles", " copyParseFiletoOutputFiles", " copyParseFiletoCodeClass", " copyParseFileToMapFiles", " copyParseFiletoOutputClass", " copyParseFileToCodeFiles", " copyParseFileToMapClass", " copyParseFileToMapFile", " copyParseFileToMapfile", " copyParseFiletoOutputfile", " copyParseFileTocodefile", " copyParseFileToOutputClass"], "in": ["get", "r", "image", "m", "pin", "ic", "n", "inn", "gin", "stream", "i", "is", "socket", "init", "cin", "impl", "input", "ls", "id", "din", "lin", "inner", "io", "pull", "nin", "con", "ini", "rin", "kin", "inside", "min", "f", "login", "err", "oin", "ins", "bin", "In", "reader", "IN", "as", "again", "read", "win", "up", "inc"], "out": ["Out", "image", "plain", "client", "writer", "sync", "one", "n", "up", "i", "output", "socket", "user", "parent", "ex", "server", "cache", "conn", "exp", "ext", "inner", "io", "work", "file", "post", "o", "this", "exec", "err", "log", "w", "other", "net", "bin", "again", "as", "outs", "outer", "source", "OUT", "inc"], "buffer": ["request", "pause", "position", "pad", "shape", "batch", "capacity", "queue", "feed", "input", "slice", "sequence", "reference", "layer", "Buffer", "limit", "cache", "server", "address", "result", "padding", "array", "fb", "buff", "raw", "count", "uffer", "available", "iter", "buf", "binary", "channel", "null", "base", "data", "uf", "number", "wave", "document", "total", "string", "duration", "read", "event", "source"], "length": ["position", "before", "match", "level", "size", "shape", "block", "full", "view", "load", "character", "feed", "slice", "sequence", "ength", "bb", "id", "limit", "address", "Length", "code", "time", "index", "weight", "pull", "ob", "path", "line", "value", "count", "row", "len", "end", "part", "start", "url", "type", "range", "partial", "offset", "number", "width", "total", "volume", "l", "style", "string", "point", "duration", "distance", "repeat", "lock"]}}
{"id1": "12744653", "id2": "15166511", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) {\n                    sb.append('0');\n                }\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"getRandomGUID": ["getRandomIGid", "getRandomGCuid", "getRandomGCID", "getRandomGuid", "getRandGid", "getRandGuid", "getRandomIGUID", "getRandGID", "getRandomGCid", "getRandomUID", "getRandomUuid", "getRandomGID", "getRandUID", "getRandUuid", "getRandomGid", "getRandomIGID", "getRandomIGuid", "getRandGUID", "getRandomUid", "getRandUid", "getRandUUID", "getRandomGCUID", "getRandomUUID"], "secure": ["Secure", "timeout", "client", "service", "require", "sec", "host", "ce", "rc", "use", "proxy", "unsigned", "server", "deep", "secondary", "safe", "sensitive", "ssl", "debug", "sr", "stable", "depth", "active", "security", "confirmed", "zip", "session", "pure", "exclusive", "secret", "https", "allow", "force", "quiet", "remote", "random", "seed", "encrypted", "weak", " insecure", "smart", "external", "config"], "md5": ["mand3", "mg5", "mg3", " MD5", "MD2", " MD3", " MD11", "mdql", "mand5", "MD3", "MD5", "mand2", "md15", "MD11", "md3", "md2", "mg15", "MDody", "MDql", " md3", "mandody", " MDql", "md11", "mgql", " MD2", "MD15", "mdody", " md11", " mdody", " md15", " md2", " mdql"], "sbValueBeforeMD5": ["sbValueBeforeMN6", "sbValueBeforeMF3", "sbValueBeforeMN5", "sbValueBeforeMB5", "sbValueWithoutMD5", "sbValueBeforeAMD512", "sbValueBeforeMS005", "sbValueBeforeAST3", "sbValueBeforeAST25", "sbValueBeforeMS3", "sbValueBeforeAMD3", "sbValueAfterMS15", "sbValueBeforeMS15", "sbValueAfterMS50", "sbValueBeforeMD25", "sbValueBeforeMF5", "sbValueBeforeMS25", "sbValueBeforeAST5", "sbValueBesidesMF5", "sbValueBeforeVM5", "sbValueAfterMS5", "sbValueBeforeSHA5", "sbValueForSHA5", "sbValueBeforeMR25", "sbValueBeforeVM7", "sbValueBeforeMD20", "sbValueDuringMF3", "sbValueForMD512", "sbValueBeforeAMD15", "sbValueBeforeMP3", "sbValueAfterMD3", "sbValueBeforeMFDie", "sbValueBeforeMF005", "sbValueBeforeM5", "sbValueBeforeMNDie", "sbValueBeforeMP7", "sbValueWithoutMR3", "sbValueAfterMS25", "sbValueWithoutMD25", "sbValueBeforeDER005", "sbValueBeforeAST50", "sbValueBeforeMP95", "sbValueBeforeMD50", "sbValueBeforeMDDie", "sbValueBeforePMDie", "sbValueBeforePM5", "sbValueAfterMP7", "sbValueBeforeM512", "sbValueBeforeM20", "sbValueBeforeSD5", "sbValueBesidesMD005", "sbValueAfterMS3", "sbValueBeforeMD95", "sbValueBeforeMD8", "sbValueBeforeSD20", "sbValueBeforePM6", "sbValueForSHA20", "sbValueBeforeSD512", "sbValueBeforeDS5", "sbValueDuringMF005", "sbValueBeforeM3", "sbValueBeforePM005", "sbValueBeforeM25", "sbValueAfterMP3", "sbValueBeforeMS50", "sbValueAfterMD50", "sbValueBeforeMS512", "sbValueWithoutMR25", "sbValueWithoutMR8", "sbValueBeforeMAC3", "sbValueBeforeMB15", "sbValueBeforeMN005", "sbValueDuringMD3", "sbValueAfterMD15", "sbValueBeforeMF6", "sbValueBesidesMDDie", "sbValueBeforeMAC25", "sbValueWithoutMD8", "sbValueBeforeDS7", "sbValueAfterMP95", "sbValueDuringMD512", "sbValueForMD3", "sbValueBesidesMD5", "sbValueBeforeMB3", "sbValueAfterMD5", "sbValueDuringMD005", "sbValueBeforeDS95", "sbValueBeforeSD3", "sbValueForMD20", "sbValueDuringMF5", "sbValueBesidesMFDie", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueBeforeMB512", "sbValueDuringMD5", "sbValueAfterMS512", "sbValueBesidesMF005", "sbValueBeforeDS3", "sbValueAfterMD512", "sbValueBeforeMD005", "sbValueAfterMP5", "sbValueAfterMD95", "sbValueBeforeMAC8", "sbValueBeforeMAC5", "sbValueBeforeDER3", "sbValueBeforeDER5", "sbValueBeforeAMD5", "sbValueAfterMD25", "sbValueBeforeSHA20", "sbValueBeforeVM3", "sbValueForMD5", "sbValueBeforeMR3", "sbValueBeforeVM95", "sbValueForSHA512", "sbValueBeforeM50", "sbValueBeforeMR8", "sbValueBeforeMF512", "sbValueBeforeMD6", "sbValueBeforeMD3", "sbValueAfterMD7", "sbValueBeforeMR5", "sbValueWithoutMD3", "sbValueBeforeDER512", "sbValueBeforeMD7", "sbValueBesidesMD6", "sbValueForSHA3", "sbValueWithoutMR5", "sbValueBeforeMS8", "sbValueBeforeMD15", "sbValueBeforeSHA512", "sbValueBesidesMF6", "sbValueBeforeSHA3", "sbValueBeforeMD512", "sbValueDuringMF512"], "time": ["error", "timeout", "cost", "rate", "size", "host", "user", "year", "version", "slice", "TIME", "delay", "id", "loc", "tz", "work", "value", "date", "count", "clock", "start", "etime", "depth", "money", "hour", "mode", "Time", "tim", "type", "offset", "times", "name", "race", "counter", "speed", "random", "seed", "duration", "event", "ime", "length", "timer"], "rand": ["r", "clean", "error", "rate", "max", "risk", "alpha", "bit", "q", "rc", "order", "ro", "chance", "year", "bug", "rank", "version", "cr", "delay", "id", "serial", "rol", "ng", "rule", "mid", "Rand", "reg", "rage", "pick", "index", "rh", "rr", "count", "root", "dist", "raid", "winner", "min", "depth", "type", "range", "bot", "res", "round", "random", "seed", "gen", "win", "right"], "valueBeforeMD5": ["valueAfterMD3", "valueBeforeEM5", "valueInsideMD1", "valueAfterAMD5", "valueBeforeAMD5", "valueBeforeMD1", "valueInsideMD5", "valueBeforeMS1", "valueBeforeMS3", "valueBeforeMD3", "valueBeforeMC1", "valueBeforeAMDFive", "valueInsideMD2", "valueBeforeMC2", "valueAfterMDFive", "valueAfterAMD53", "valueBeforeMD2", "valueInsideMD3", "valueAfterAMD3", "valueBeforeAMD53", "valueAfterAMDFive", "valueBeforeMS5", "valueBeforeMS2", "valueBeforeMC3", "valueBeforeMD53", "valueBeforeEM3", "valueBeforeAMD3", "valueBeforeEMFive", "valueBeforeMDFive", "valueBeforeEM53", "valueAfterMD53", "valueBeforeMC5"], "array": ["image", "error", "shape", "batch", "element", "order", "view", "object", "app", "section", "expression", "archive", "Array", "address", "integer", "arrow", "result", "a", "our", "audio", "message", "air", "pair", "ray", "value", "function", "row", "angle", "area", "binary", "api", "feature", "data", "range", "database", "collection", "any", "allow", "number", "record", "arr", "string", "list", "sample", "vector"], "sb": ["sc", "bp", "buffer", "abb", "dB", "bf", "bis", "src", "ab", "lb", "zb", "s", "bt", "SB", "bs", "nn", "amb", "ib", "bb", "ls", "usb", "sa", "sf", "sg", "bc", "rb", "fb", "bg", "bm", "kb", "lp", "stab", "mb", "bl", "gb", "bj", "sup", "pb", "ub", "bh", "eb", "buf", "wb", " SB", "BB", "sq", "bsp", "xb", "obb", "nb", "lab", "sth", "sv", "orb", "cb", "rob"], "j": ["job", "ind", "p", "obj", "br", "g", "n", "ie", "i", "key", "q", "uj", "J", "e", "adj", "aj", "length", "jj", "code", "ja", "li", "num", "ii", "index", "jl", "z", "bj", "out", "ij", "bi", "part", "end", "x", "f", "ch", "o", "k", "jp", "y", "v", "ji", "l", "d", "js", "dy", "c", "pr", "jo"], "b": ["job", "db", "p", "bf", "n", "br", "bit", "i", "ab", "lb", "bs", "ib", "bb", "e", "length", "code", "rb", "a", "beta", "fb", "be", "mb", "ob", "bi", "pb", "B", "x", "bd", "f", "eb", "base", "BB", "y", "bar", "bin", "l", "d", "nb", "orb", "cb", "c"], "valueAfterMD5": ["valueAfterMD3", "valueAfterAMD5", "valueBeforeMD7", "valueBeforeMP7", "valueBeforeMD3", "valueBeforeMP3", "valueAfterMC5", "valueBeforeMP5", "valueAfterMD7", "valueAfterMP3", "valueBeforeMD2", "valueAfterMC7", "valueAfterAMD7", "valueAfterAMD3", "valueAfterMC3", "valueAfterMD2", "valueAfterMP2", "valueAfterAMD2", "valueBeforeMP2", "valueAfterMP7", "valueAfterMP5", "valueAfterMC2"]}}
{"id1": "23517481", "id2": "11005804", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"md5": [" md8", "sha5", "md8", "sha2", "sha512", "sha8", " md512", "MD2", "md2", " md2", "MD8", "MD5", "MD512", "md512"], "uri": ["request", "absolute", "iri", " URI", "query", "i", "object", "URI", "reference", "id", "attribute", "directory", "abi", "address", "origin", "ui", "format", "connection", "location", "URL", "message", "path", "io", "resource", "file", " ur", "pi", "url", "Url", "prefix", "api", "base", "ri", "data", "token", "database", "text", "name", "string", "source", "filename"], "messageDigest": ["messageDester", "messagediger", "messageDiger", "MessageMixusher", "messageDest", "MessageDest", "messageDEST", "messagedigester", "messageUploadester", "messagedigger", "messageMixEST", "MessageDigested", "messageDigester", "messageMixest", "messageDigum", "messagedigEST", "MessageDer", "messageUploadum", "MessageDigEST", "messageDigusher", "messageDesignester", "MessageDesignest", "MessageDigum", "MessageDester", "MessageMixEST", "messagedigusher", "messagedigested", "MessageDigusher", "messageUploadest", "MessageDigest", "messageDigger", "messageDigEST", "MessageDesignester", "messageDesignum", "messageMixer", "messageDigested", "MessageDesignum", "MessageMixest", "MessageDigger", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDger", "messageDesignest", "messagedigum", "messagedigest", "messageDesignested", "messageMixger", "messageDusher", "MessageDesignested", "messageUploadested", "messageMixusher", "MessageDger", "MessageDigester"], "bytes": ["acters", "letters", "buffer", "seq", "words", "steps", "files", "bs", "s", "units", "strings", "slice", "sequence", "ips", "events", "es", "address", "lines", "keys", "objects", "seconds", "tes", "services", "params", "resources", "Bytes", "ions", "pieces", "classes", "bits", "binary", "data", "blocks", "values", "errors", "bles", "parts", "outs"], "stringBuffer": ["doubleBuilder", "stringBar", "StringHelper", "objectFrame", "StringBuff", "StringFrame", "intBuilder", "objectString", " stringHelper", "stringFrame", "externalBar", "StringBB", "StringText", "doubleBuffer", "externalLength", "doubleBuff", "objectHelper", "stringHelper", " stringString", "intBuffer", "intText", "stringBuilder", "stringString", "objectBuff", " stringLength", "doubleText", "stringBuff", "StringString", "StringLength", " stringBB", " stringBuff", "externalBuff", "externalBuffer", "StringBar", "stringBB", "objectBB", " stringBar", " stringFrame", "stringText", "stringLength", "intBuff", "objectBuffer"], "b": ["r", "buffer", "p", "bf", "block", "bit", "i", "object", "s", "bb", "e", "id", "abi", "sb", "length", "code", "rb", "a", "fb", "be", "ob", "value", "bi", "B", "x", "f", "letter", "base", "k", " B", "v", "number", "l", "d", "string", "body", " a", "c"], "hex": ["ip", "buffer", "h", "alpha", "bit", "i", "pattern", "character", "bb", "serial", "ex", "cache", "check", "loc", "length", "code", "a", "rh", "buff", "digit", "raw", "lit", "str", "x", "iter", "f", "oct", "letter", "binary", "null", "url", "bits", "alph", "char", "comp", "number", "text", "he", "bin", "string", "header", "utf", "hash", "c"]}}
{"id1": "21224967", "id2": "2198730", "code1": "    public boolean crear() {\n        int result = 0;\n        String sql = \"insert into jugador\" + \"(apellidoPaterno, apellidoMaterno, nombres, fechaNacimiento, pais, rating, sexo)\" + \"values (?, ?, ?, ?, ?, ?, ?)\";\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatement(elJugador);\n            result = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (result > 0);\n    }\n", "code2": "    public void importCSV(InputStream csvfile) throws Exception {\n        try {\n            String[] qmarks = new String[columns.length];\n            for (int i = 0; i < qmarks.length; i++) {\n                qmarks[i] = \"?\";\n            }\n            if (cleartable) {\n                String delsql = \"delete from \" + table;\n                Statement delstm = conn.createStatement();\n                delstm.executeUpdate(delsql);\n            }\n            String sql = \"insert into \" + table + \" (\" + StringUtils.join(columns, \", \") + \") values (\" + StringUtils.join(qmarks, \", \") + \")\";\n            log.debug(\"SQL: \" + sql);\n            PreparedStatement stm = conn.prepareStatement(sql);\n            int datatypes[] = new int[columns.length];\n            for (int i = 0; i < columns.length; i++) {\n                Table tbl = project.getTableByName(table);\n                if (tbl == null) throw new OntopiaRuntimeException(\"Unknown table: \" + table);\n                Column col = tbl.getColumnByName(columns[i]);\n                if (col == null) throw new OntopiaRuntimeException(\"Unknown table column: \" + columns[i]);\n                if (col.getType() == null) throw new OntopiaRuntimeException(\"Column type is null: \" + col.getType());\n                DataType datatype = project.getDataTypeByName(col.getType(), \"generic\");\n                if (datatype == null) throw new OntopiaRuntimeException(\"Unknown column type: \" + col.getType());\n                String dtype = datatype.getType();\n                if (\"varchar\".equals(dtype)) datatypes[i] = Types.VARCHAR; else if (\"integer\".equals(dtype)) datatypes[i] = Types.INTEGER; else throw new OntopiaRuntimeException(\"Unknown datatype: \" + dtype);\n            }\n            LineNumberReader reader = new LineNumberReader(new InputStreamReader(csvfile));\n            for (int i = 0; i < ignorelines; i++) {\n                String line = reader.readLine();\n                if (line == null) break;\n            }\n            log.debug(\"[\" + StringUtils.join(columns, \", \") + \"]\");\n            int lineno = 0;\n            while (true) {\n                lineno++;\n                String line = reader.readLine();\n                if (line == null) break;\n                try {\n                    String[] cols = StringUtils.split(line, separator);\n                    if (cols.length > columns.length && !ignorecolumns) log.debug(\"Ignoring columns: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    log.debug(\"CVALUES: \" + (columns.length + 1) + \"-\" + cols.length + \" '\" + line + \"'\");\n                    String dmesg = \"(\";\n                    for (int i = 0; i < columns.length; i++) {\n                        String col = cols[i];\n                        if (stripquotes) {\n                            int len = col.length();\n                            if (len > 1 && ((col.charAt(0) == '\"' && col.charAt(len - 1) == '\"') || (col.charAt(0) == '\\'' && col.charAt(len - 1) == '\\''))) col = col.substring(1, len - 1);\n                        }\n                        if (col != null && col.equals(\"\")) col = null;\n                        dmesg = dmesg + col;\n                        if (i < columns.length - 1) dmesg = dmesg + \", \";\n                        stm.setObject(i + 1, col, datatypes[i]);\n                    }\n                    dmesg = dmesg + \")\";\n                    log.debug(dmesg);\n                    stm.execute();\n                } catch (Exception e) {\n                    conn.rollback();\n                    throw new OntopiaRuntimeException(\"Cannot read line \" + lineno + \": '\" + line + \"'\", e);\n                }\n            }\n            conn.commit();\n        } finally {\n            if (conn != null) conn.close();\n        }\n    }\n", "label": 1, "substitutes": {"crear": ["generar", "Creas", "generare", "Crear", "generas", " Creare", " creare", " Crear", "Crea", "Creare", " crea", " creas", "genera", " Crea", " Creas"], "result": ["success", "error", "match", "db", "rate", "entry", "order", "currency", "comment", "default", "user", "page", "limit", "valid", "diff", "ver", "found", "grade", "response", "message", "Result", "ret", "df", "results", "out", "count", "function", "date", "value", "cash", "die", "feature", "err", "type", "mark", "status", "number", "force", "record", "res", "counter", "score", "ure", "event", "sign", "up", "length"], "sql": ["job", "db", "where", "query", "script", "sync", "sl", "q", "comment", "pg", "action", "install", "statement", " SQL", "SQL", "conn", "params", "fp", "ssl", "fn", "plan", "url", "serv", "exec", "base", "session", "update", "zip", "sq", "log", "printf", "dl", "database", "ql", "string", "seed", "setup", "cmd", "join", "up", "select", "repl"], "connection": ["position", "db", "error", "client", "connect", "BC", "union", "writer", "p", "query", "ctx", "cond", "relation", "socket", "proxy", "context", "pg", "environment", "section", "statement", "server", "cache", "Exception", "conn", "loc", "bc", "container", "graph", "index", "manager", "con", "function", "tc", "which", "connected", "engine", "session", "system", "log", "database", "collection", "application", "document", "driver", "table", "ion", "communication", "Connection", "lock", "event", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "p", "PS", "query", "pp", "qs", "pos", "pa", "cp", "cs", "bs", "proxy", "pg", "pre", "ns", "po", "ips", "pd", "properties", "conn", "ks", "pers", "cop", "params", "posts", "proc", "ds", "changes", "gres", "pe", "jp", "eps", "hs", "ins", "pc", "ops", "settings", "Ps", "vs", "ss", "pse", "gs", "pps", "ports", "pt", "pr", "sp"]}}
{"id1": "2668634", "id2": "14691829", "code1": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"inputName": ["InputFile", "Inputname", "imageName", "outputPath", "outputFile", "inputAddress", " inputAddress", "inputUrl", "InputUrl", "imageFile", "imagename", "InputName", " inputPath", " inputFile", "InputAddress", " inputUrl", "outputUrl", "inputFile", " inputname", "InputPath", "imageAddress", "inputname", "inputPath"], "outputName": ["applicationPath", "outputPath", "outputFile", "outputDir", "outputname", "applicationname", "Outputname", " outputname", "applicationName", "OutputDir", "OutputFile", "OutputPath", "applicationDir", " outputFile", "applicationFile", "OutputName", " outputDir", "inputFile", "inputDir", "inputPath"], "stripLoggers": ["stripColters", "stripDebuggers", "stripLogger", "striplogging", "stripDebugging", " stripLogger", "stripColger", "striploggers", "stripDebugger", " stripLogters", " striplogger", "stripColgers", " striplogging", "stripColging", "striplogger", "striplogters", "stripLogters", " striplogters", "stripDebugters", " striploggers", " stripLogging", "stripLogging"], "tempFile": [" temporaryStream", " temporaryfile", "tempDir", "poraryMessage", "TempFiles", "tempPage", " tempMessage", "tmpPage", "TempStream", "TempDir", " tempStream", " tempFiles", " tempfile", "tmpFiles", "tmpfile", "tmpDir", " temporaryFile", "poraryFiles", "tempfile", "tempMessage", "TempFile", " tempPage", "tempFiles", "inputfile", "poraryFile", "poraryfile", "TempMessage", "tmpFile", "tempStream", "inputFile", " temporaryFiles", "inputDir", "inputPage", "Tempfile", " tempDir"], "jin": ["Js", " Jin", "in", "su", "pin", "Mu", "NI", "jan", "gin", "icer", "zin", "hin", "cin", "sit", "jen", "tin", "ln", "nu", "thin", "cli", "pillar", "zon", "din", "arin", "zn", "spin", "sin", "Skin", "lin", "rio", "cos", "ja", "Mos", "Ru", "vin", "raf", "nin", "jl", "Intern", "NJ", "ini", "rin", "nir", "inx", "kin", "unin", "util", "lib", "skin", "zip", "jp", "ni", "jing", "fil", "fen", "jack", "zik", "hn", "bin", "plugin", "Kit", "irin", "lu", "jun", "john"], "jout": [" jOut", "JOut", "jetOUT", " jouter", "nOut", "ujOut", "nOUT", "narray", "jOut", " jOUT", "jouter", "Jout", "nout", "jarray", "ujouter", " jarray", "jOUT", "Jouter", "jetout", "jetarray", "jetOut", "ujout"], "srcChannel": [" srcCh", "srcCh", "rcCh", "srcChan", "sourceChan", "rcChan", " srcchannel", " srcChan", "rcChannel", "sourceCh", "rcchannel", "sourcechannel", "sourceChannel", "srcchannel"], "dstChannel": ["dstCh", "dspCh", "dspchannel", " ddestCh", " ddestChannel", "ddestChannel", " ddestChan", "dndChannel", " dstChan", "dndChan", " ddestchannel", " dstchannel", " dstCh", "dndCh", "dstChan", "ddestCh", "dndchannel", "ddestchannel", "dspChan", "ddestChan", "dspChannel", "dstchannel"], "portletApplicationName": ["portletApplicationUrl", "portletApplicationsInfo", "portalApplicationPath", "portletAppCode", "portletApplicationsPath", "portletPlatformPath", "portalPlatformUrl", "portletapplicationType", "portletApplicationPath", "portletsAppInfo", "portletApplicationInfo", "portletApplicationType", "portletPlatformName", "portletapplicationUrl", "portletapplicationName", "portalPlatformName", "portletAppName", "portletsAppPath", "portletsAppCode", "portletAppUrl", "portalApplicationType", "portletapplicationPath", "portletApplicationCode", "portletsApplicationName", "portalApplicationUrl", "portletsApplicationCode", "portletAppInfo", "portletAppPath", "portalPlatformPath", "portletPlatformCode", "portletPlatformInfo", "portletApplicationsCode", "portletsApplicationInfo", "portletsAppName", "portalApplicationName", "portletPlatformType", "portletApplicationsName", "portalPlatformType", "portletsApplicationPath", "portletPlatformUrl", "portletAppType"], "webXml": ["webWorkli", " webXaml", "webHiel", "webCml", "webXMxml", "webEcML", "contextXlass", "webXul", "webxml", "webXMiel", "WebXpl", "webHml", "contextXul", " webXMML", "WebXMML", "webXMml", "webCrossli", "WebXiel", "webXli", "webXMaml", "WebXML", "contextXxml", "webXaml", "webxlass", "webHML", "webxaml", "webXiel", "WebXMpl", "webEcml", "webEcpl", "webXMML", "contextClass", "webCrossml", "webCrossul", "webHpl", " webXMml", "webXxml", "webClass", "contextCrossli", "webXML", "webCxml", "contextXML", "contextXli", "webxxml", "contextCxml", "webXlass", " webXMxml", "WebXml", "contextCrossul", "webWorkul", "WebXMiel", "webWorkML", "webCrossML", "webCML", "contextCrossml", "contextCml", " webXxml", "webxML", "WebXMml", "contextCML", "webWorkaml", " webXMaml", "contextCrossML", " webXML", "webWorkml", "webEciel", "webWorkxml", "webXpl", "webXMpl"], "portletXml": ["portletHxml", "portletXmos", "portletCML", "portletXaml", "portletSyncxml", "portletSynctml", "portletSyxml", "portletSyml", "portletxxml", "portletEml", "portletxml", "portletXMmal", "portletSytml", "portletSyncaml", "portletXtml", "portleSyaml", "portletXmal", "portletXMng", "portletXMxml", "portletYml", "portletsXml", "portletYng", "portletYML", "portletEng", "portletsYml", "portfileXmos", "portletsYng", "portletXxml", "portletEML", "portletCmos", "portleXml", "portleSyxml", "portletsXML", "portletHML", "portfileXML", "portfileHmos", "portletYmal", "portleXxml", "portletXng", "portfileHml", "portletXMaml", "portleXtml", "portleXaml", "portletCxml", "portletsYmal", "portletXMtml", "portleSytml", "portletxmos", "portletHmos", "portletEmal", "portletsXmal", "portletCml", "portfileXxml", "portfileXml", "portletXMML", "portleSyml", "portletXMml", "portfileHxml", "portletSyncml", "portletsYML", "portletHml", "portfileHML", "portletSyaml", "portletxML", "portletsXng", "portletXML"], "contextXml": ["contextUml", " contextAxml", " contextAxla", "contextExML", "contextHwl", "contextxwl", "contextXMml", "conceptXaml", "contextXwl", " contextXML", "contextXl", " contextAxML", "conceptHwl", "conceptHml", "contextXla", "contextXxml", "conceptXwl", "contextAxml", "contextAxl", "contextXaml", "contextxxml", " contextXla", " contextAxl", "contextxaml", "conceptXml", "contextXMaml", "contextXMwl", "conceptXxml", "contextAxla", "contextExla", "contextAxML", "contextExl", "conceptHaml", "contextUl", "contextUla", "contextHaml", "contextXML", "contextHml", "contextHxml", "contextExml", "contextXMxml", "conceptHxml", "contextxml", " contextXl", "contextUML"], "src": ["r", "in", "sc", "ruby", "sl", "obj", "ie", "ctx", "entry", "rl", "sync", "i", "host", "rc", "socket", "s", "sit", "slice", "rs", "ses", "sn", "sin", "sb", "loc", "result", "rb", "http", "inst", "resource", "cur", "rss", "ssl", "img", "gb", "rin", "dest", "rec", "sup", "Source", "lit", "dist", "secure", "sr", "sel", "prot", "url", "req", "st", "bh", "zip", "rest", "ri", "sq", "rel", "spec", "SOURCE", "comp", "lower", "uc", "href", "ur", "gz", "uri", "jar", "ser", "cont", "ource", "sub", "config", "username"], "source": ["get", "in", "client", "component", "service", "size", "sl", "ie", "stream", "i", "ce", "form", "view", "use", "proxy", "scope", "input", "sit", "slice", "context", "e", "thin", "parent", "sin", "handler", "core", "stack", "from", "result", "connection", "inner", "reason", "resource", "fp", "xml", "resources", "out", "function", "kin", "file", "Source", "secure", "storage", "sr", "iter", "start", "url", "this", "null", "unit", "wrapper", "zip", "session", "rc", "channel", "loader", "spec", "SOURCE", "comp", "token", "status", "text", "driver", "reader", "string", "uri", "gen", "ource", "ources", "sp"], "zipEntries": [" zipEntrys", "sliceEntresses", "zipentlements", "zipEnlines", "zipEries", "ZipEntlements", "sliceEry", "sliceElines", "zipentions", "zipEndries", "sliceEresses", "sliceEntry", "sliceEntries", "zipIntegrys", "zipEntrations", "zipentrys", "zipEndresses", "zipIntegrations", "ZipEntries", "sliceEries", "ZipEntions", "zipEntresses", "zipEresses", "zipCurries", "zipEndry", "zipEnry", "zipEnresses", "zipEnrations", "zipIntegries", "zipEntry", "zipEnrys", "zipCurlements", "zipCurrys", "zipEnries", "zipEntrys", "zipCurions", " zipEntrations", "zipEntlines", "zipIntegry", "zipEry", "zipEntlements", "zipentries", "sliceEntlines", "zipElines", "ZipEntrys", "zipEntions", "zipEndlines", " zipEntry"], "target": ["next", "match", "template", "component", "compatible", "host", "output", "class", "object", "context", "wrong", "theme", "scope", "route", "nt", "address", "loc", "tail", "format", "content", "location", "path", "resource", "top", "value", "dest", "file", "config", "bh", "feat", "prefix", "unit", "platform", "goal", "data", "type", "flat", "Target", "rel", "tag", "it", "method", "hop", "name", "site", "style", "arget", "project", "string", "href", "remote", "external", "current", "filename"], "webRewriter": ["webrewitcher", " webrewitcher", "New", "webrewriter", " webReworter", "webReprite", " webRewitcher", "app", "s", "webRepriter", "webReworter", "webResriter", "http", "webResrite", " webrewriter", "_", " webrewrite", "webRewitcher", "webRewrite", "webResitcher", "this", "webResorter", "webreworter", "application", "Entry", "webReporter", "webrewrite", " webreworter", " webRewrite", "webRepitcher"]}}
{"id1": "6190356", "id2": "20310134", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldmd512", " hashPasswordForOldmd4", " hashPasswordForNewM4", " hashPasswordForOldmd3", " hashPasswordForOldMC512", " hashPasswordForOldMC5", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForOldMD4", " hashPasswordForOldMD3", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForNewMD3", " hashPasswordForOldmd5", " hashPasswordForNewM512", " hashPasswordForNewM5", " hashPasswordForOldMC3", " hashPasswordForOldMC4", " hashPasswordForNewM3", " hashPasswordForOldM3"], "password": ["account", "pad", "buffer", "words", "p", "crypt", "key", "pattern", "input", "sword", "phrase", "address", "result", "padding", "Password", "code", "content", "array", "path", "message", "word", "value", "wd", "pass", "wallet", "data", "token", "secret", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "md": ["km", "mm", "mac", "mo", "clean", "ind", "m", "Cmd", "dig", "grad", "pg", "managed", "pd", "metadata", "um", "cd", "ma", "od", "dc", "rm", "amd", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "dm", "pm", "mt", "MD", "di", "mp", "mc", "hd", "mag", "mod", "d", "rpm", "vd", "am", "meta", "cmd", "dd", " MD", "vm", "hm"], "messageDigest": ["messageDester", " messageDigEST", "messageAddse", "messageDEST", "messageDest", "messagedigester", " messageModester", "messageDigester", "messageDse", "messagedigEST", " messageDigester", "MessageDigEST", "MessageModse", "MessageModEST", "messageAddester", "MessageDigest", "messageDigEST", " messageModEST", "MessageAddester", "messageModests", "MessageModester", "messageAddEST", "MessageAddse", "messagedigse", "MessageDigse", "messageAddest", "MessageModest", "messageDigests", " messageModests", "messageAddests", "messageDigse", "messagedigests", " messageDigests", " messageModest", "messageModse", "messageModEST", "messagedigest", "MessageAddEST", "MessageAddest", "messageModest", "MessageDigester", "messageModester"], "hexString": ["tempFile", " hexArray", "stringService", "octArray", "transformStr", "hashSection", " hexStr", "sumStr", "octStr", "tempFunction", "hexstring", "crossstring", "tempStr", "hexArray", " hexSection", " hexService", " hexFile", "hexFunction", "stringArray", "transformString", "hexSection", "crossStr", "hexFile", " hexFunction", "stringString", "sumString", "hashService", "transformArray", "hashString", "transformBuffer", " hexBuffer", "sumstring", "crossString", "hashArray", "hexBuffer", "stringSection", "hexStr", " hexstring", "sumFile", "hexService", "octBuffer", "tempString", "crossFunction", "tempstring", "octString"], "i": ["r", "ai", "ip", "m", "h", "p", "j", "n", "s", "multi", "fi", "ix", "slice", "e", "phi", "id", "ci", "t", "ui", "info", "length", "a", "index", "li", "ii", "io", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "v", "ji", "oi", "di", "l", "d", "si", "qi", "uri", "I", "c"], "hex": ["ip", "h", "batch", "hello", "alpha", "bit", "full", "host", "form", "pattern", "default", "character", "serial", "nexus", "ex", "sex", "cache", "json", "cookie", "hack", "result", "format", "http", "exp", "path", "zero", "orig", "rh", "buff", "pack", "digit", "raw", "lit", "str", "pex", "oct", "letter", "binary", "none", "null", "data", "temp", "rex", "char", "comp", "transform", "text", "he", "pixel", "string", "utf", "hash", " Hex", "cmp", "shift", "length"]}}
{"id1": "23517481", "id2": "9319440", "code1": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "code2": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "label": 0, "substitutes": {"md5": [" md8", "sha5", "md8", "sha2", "sha512", "sha8", " md512", "MD2", "md2", " md2", "MD8", "MD5", "MD512", "md512"], "uri": ["request", "absolute", "iri", " URI", "query", "i", "object", "URI", "reference", "id", "attribute", "directory", "abi", "address", "origin", "ui", "format", "connection", "location", "URL", "message", "path", "io", "resource", "file", " ur", "pi", "url", "Url", "prefix", "api", "base", "ri", "data", "token", "database", "text", "name", "string", "source", "filename"], "messageDigest": ["messageDester", "messagediger", "messageDiger", "MessageMixusher", "messageDest", "MessageDest", "messageDEST", "messagedigester", "messageUploadester", "messagedigger", "messageMixEST", "MessageDigested", "messageDigester", "messageMixest", "messageDigum", "messagedigEST", "MessageDer", "messageUploadum", "MessageDigEST", "messageDigusher", "messageDesignester", "MessageDesignest", "MessageDigum", "MessageDester", "MessageMixEST", "messagedigusher", "messagedigested", "MessageDigusher", "messageUploadest", "MessageDigest", "messageDigger", "messageDigEST", "MessageDesignester", "messageDesignum", "messageMixer", "messageDigested", "MessageDesignum", "MessageMixest", "MessageDigger", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDger", "messageDesignest", "messagedigum", "messagedigest", "messageDesignested", "messageMixger", "messageDusher", "MessageDesignested", "messageUploadested", "messageMixusher", "MessageDger", "MessageDigester"], "bytes": ["acters", "letters", "buffer", "seq", "words", "steps", "files", "bs", "s", "units", "strings", "slice", "sequence", "ips", "events", "es", "address", "lines", "keys", "objects", "seconds", "tes", "services", "params", "resources", "Bytes", "ions", "pieces", "classes", "bits", "binary", "data", "blocks", "values", "errors", "bles", "parts", "outs"], "stringBuffer": ["doubleBuilder", "stringBar", "StringHelper", "objectFrame", "StringBuff", "StringFrame", "intBuilder", "objectString", " stringHelper", "stringFrame", "externalBar", "StringBB", "StringText", "doubleBuffer", "externalLength", "doubleBuff", "objectHelper", "stringHelper", " stringString", "intBuffer", "intText", "stringBuilder", "stringString", "objectBuff", " stringLength", "doubleText", "stringBuff", "StringString", "StringLength", " stringBB", " stringBuff", "externalBuff", "externalBuffer", "StringBar", "stringBB", "objectBB", " stringBar", " stringFrame", "stringText", "stringLength", "intBuff", "objectBuffer"], "b": ["r", "buffer", "p", "bf", "block", "bit", "i", "object", "s", "bb", "e", "id", "abi", "sb", "length", "code", "rb", "a", "fb", "be", "ob", "value", "bi", "B", "x", "f", "letter", "base", "k", " B", "v", "number", "l", "d", "string", "body", " a", "c"], "hex": ["ip", "buffer", "h", "alpha", "bit", "i", "pattern", "character", "bb", "serial", "ex", "cache", "check", "loc", "length", "code", "a", "rh", "buff", "digit", "raw", "lit", "str", "x", "iter", "f", "oct", "letter", "binary", "null", "url", "bits", "alph", "char", "comp", "number", "text", "he", "bin", "string", "header", "utf", "hash", "c"]}}
{"id1": "16557837", "id2": "7468827", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                BufferedInputStream in = new BufferedInputStream(con.getInputStream());\n                FileOutputStream fos = new FileOutputStream(toFile);\n                BufferedOutputStream bout = new BufferedOutputStream(fos, 1024);\n                byte[] data = new byte[1024];\n                int x = 0;\n                while ((x = in.read(data, 0, 1024)) >= 0) {\n                    bout.write(data, 0, x);\n                    lastIteraction = System.currentTimeMillis();\n                }\n                bout.flush();\n                bout.close();\n                fos.flush();\n                fos.close();\n                in.close();\n                con.disconnect();\n                finish = true;\n            } catch (Exception e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"copyFromTo": ["copyFileFrom", "transferFromFile", "transferfromFrom", "transferFromWith", "copyFromWith", "transferFromFrom", "copyfromFile", "copyFileFile", "copyDirTo", "transferfromWith", "copyDirFrom", "copyfromFrom", "transferfromFile", "copyDirWith", "copyFileTo", "transferfromTo", "copyfromTo", "copyfromWith", "copyFromFile", "copyFileWith", "transferFromTo", "copyDirFile", "copyFromFrom"], "srcFile": ["srcFiles", "rcDir", " srcClass", "srcClass", " srcDir", "sourcefile", "sourceFiles", "destDir", "srcPage", "sourceSourceFile", "destfile", "srcDir", "destFiles", "srcfile", " srcPath", "sourceFile", " srcFiles", "sourcePath", "sourceClass", "rcSourceFile", "sourceDir", "srcSourceFile", "srcPath", "destPage", " srcPage", " srcfile", "destClass", "rcFile", " srcSourceFile", "destSourceFile", "rcPage", "rcFiles", "rcPath", "rcfile"], "destFile": [" destinationFilename", "targetDir", "DestSourceFile", "destPlace", " destPath", " destFilename", "srcPlace", "wbFilename", "DestFile", " destDir", "destroyFine", " destSourceFile", " destinationfile", "targetPath", "destDir", " destinationFine", "Destfile", "destFilename", "defaultDir", "srcDir", "destfile", "destFiles", "southPlace", "srcFilename", "DestPath", " destfile", "southFile", " destinationFile", "destroyPage", "targetFiles", "destPath", " destinationPage", "DestDir", " destPage", "defaultfile", " destPlace", "wbFile", "DestFiles", "destPage", " destinationDir", "DestFilename", "defaultFiles", "southDir", "destroyFilename", " destFine", "destroyFile", " destinationFiles", "defaultFile", "destSourceFile", "southFilename", "wbSourceFile", "targetFile", " destFiles", "wbFiles", "destFine"], "in": ["Out", "r", "image", "h", "p", "pin", "n", "inn", "isin", "i", "is", "socket", "init", "cin", "input", "id", "ci", "din", "lin", "connection", "inner", "index", "io", "pull", "nin", "con", "rin", "ini", "file", "part", "x", "inside", "f", "min", "url", "o", "channel", "login", "ac", "err", "b", "ins", "co", "bin", "In", "reader", "IN", "again", "as", "like", "win", "source", "c", "inc"], "out": ["Out", "image", "error", "sync", "query", "key", "comment", "parent", "ger", "ex", "to", "conn", "raw", "post", "store", "prefix", "no", "this", "base", "name", "In", "string", "outs", "window", "cmd", "win", "dump", "OUT", "ico", "client", "off", "user", "input", "page", "cache", "json", "diff", "state", "inner", "io", "file", "part", "down", "err", "net", "again", "lock", "inc", "job", "auto", "writer", "output", "pre", "copy", "cli", "ext", "line", "url", "o", "lib", "channel", "doc", "log", "IN", "point", "outer", "source", "up", "c", "term", "obj", "note", "socket", "ou", "write", "server", "group", "connection", "code", "resource", "exec", "session", "call", "co", "bin", "list", "sys", "extra", "gen"], "fis": ["lis", " foss", "pos", "cfris", "flios", "gis", "fros", "fios", "flos", "cfos", "pis", "fi", "hios", " fris", "pris", "hos", "gi", "FIs", "fIs", "foss", "Fos", "his", "cfios", "flis", "los", "gais", "li", " fIs", "cfis", "cfi", "fli", "fris", " fais", "pIs", "gos", "hi", "cfoss", "frris", "fross", "Fris", "fais", "Fis", "lais", " fi"], "fos": ["lis", "boes", "Faos", " fics", " foes", "eoss", "infose", "flo", "bis", "go", "pos", "foes", "eose", "flos", "eis", "flose", "pis", "faos", "infis", " fout", "po", "foss", "fo", "Fos", "paos", "infoss", "gout", "infos", "los", "tics", "lose", "loss", "toes", "tos", " faos", "fics", "flout", " fo", "gose", "Fo", "bics", "poes", "gos", "bos", " fose", "eos", "Foes", "Fis", "fose", "tis", "fout"], "srcModified": ["srcVerification", "srcmodified", "srcXification", "srcVerified", " srcModed", "srcMetification", "srcMetressed", "srcXed", "sourceModIFIED", "srcMinify", "srcModressed", " srcModined", "srcMinification", "srcMinIFIED", "srcMetified", "srcXined", "srcModification", " srcModIFIED", "srcVerined", "srcMinified", "srcModed", " srcModressed", "sourceModify", "srcmodify", "srcXified", "sourceMinIFIED", " srcModification", "srcMetIFIED", "sourceMinify", "sourceModification", "srcmodressed", "srcVered", "srcmodIFIED", "srcModIFIED", "sourceMinification", "sourceModified", "srcModined", "sourceMinified", "srcModify", "srcmodification"]}}
{"id1": "21754659", "id2": "22536033", "code1": "    private JButton getButtonSonido() {\n        if (buttonSonido == null) {\n            buttonSonido = new JButton();\n            buttonSonido.setText(Messages.getString(\"gui.AdministracionResorces.15\"));\n            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetree.png\")));\n            buttonSonido.addActionListener(new java.awt.event.ActionListener() {\n\n                public void actionPerformed(java.awt.event.ActionEvent e) {\n                    JFileChooser fc = new JFileChooser();\n                    fc.addChoosableFileFilter(new SoundFilter());\n                    int returnVal = fc.showDialog(AdministracionResorces.this, Messages.getString(\"gui.AdministracionResorces.17\"));\n                    if (returnVal == JFileChooser.APPROVE_OPTION) {\n                        File file = fc.getSelectedFile();\n                        String rutaGlobal = System.getProperty(\"user.dir\") + \"/\" + rutaDatos + \"sonidos/\" + file.getName();\n                        String rutaRelativa = rutaDatos + \"sonidos/\" + file.getName();\n                        try {\n                            FileInputStream fis = new FileInputStream(file);\n                            FileOutputStream fos = new FileOutputStream(rutaGlobal, true);\n                            FileChannel canalFuente = fis.getChannel();\n                            FileChannel canalDestino = fos.getChannel();\n                            canalFuente.transferTo(0, canalFuente.size(), canalDestino);\n                            fis.close();\n                            fos.close();\n                            imagen.setSonidoURL(rutaRelativa);\n                            System.out.println(rutaGlobal + \" \" + rutaRelativa);\n                            buttonSonido.setIcon(new ImageIcon(getClass().getResource(\"/es/unizar/cps/tecnoDiscap/data/icons/view_sidetreeOK.png\")));\n                            gui.getAudio().reproduceAudio(imagen);\n                        } catch (IOException ex) {\n                            ex.printStackTrace();\n                        }\n                    } else {\n                    }\n                }\n            });\n        }\n        return buttonSonido;\n    }\n", "code2": "    private boolean setPayload() throws IOException {\n        if (Index < Headers.length) {\n            FileOutputStream fos = new FileOutputStream(Headers[Index], true);\n            FileInputStream fis = new FileInputStream(HeadlessData);\n            FileChannel fic = fis.getChannel();\n            FileChannel foc = fos.getChannel();\n            fic.transferTo(0, fic.size(), foc);\n            fic.close();\n            foc.close();\n            setDestination(Destinations[Index]);\n            setPayload(Headers[Index]);\n            Index++;\n            return true;\n        }\n        return false;\n    }\n", "label": 1, "substitutes": {"getButtonSonido": ["getbuttonSenico", "getbuttonSonico", "getButtonJonico", "getButtonSenido", "getButtonSonico", "getButtonJonido", "getButtonJonendo", "getButtonJonira", "getbuttonSonido", "getButtonSenira", "getbuttonSonira", "getButtonSenendo", "getbuttonSenira", "getbuttonSenido", "getbuttonSonendo", "getButtonSonendo", "getButtonSenico", "getbuttonSenendo", "getButtonSonira"], "buttonSonido": ["buttonHomida", "btnDonido", "buttonDonado", "buttonDonini", "buttonDonida", "ButtonSonido", "buttonHonido", "buttonHomido", " buttonSenardo", "btnSonado", "ButtonSonida", " buttonSenino", "buttonsonado", "buttonDonardo", "ButtonSonardo", "buttonSonado", "buttonDonino", "buttonHomado", "buttonDonigo", "buttonTanardo", "buttonDonido", "btnSonido", "buttonSenido", "buttonSenida", " buttonSonardo", " buttonSenido", " buttonSenado", "ButtonDonida", "ButtonSonini", "ButtonDonardo", "buttonsonardo", "btnDonardo", "btnDonado", "buttonSonino", "buttonsonini", "btnSonini", "buttonSonigo", "buttonSenardo", "buttonSenigo", "ButtonDonini", "btnDonigo", " buttonSonado", "buttonSenado", " buttonSonino", " buttonSenida", "buttonSenini", "ButtonDonado", " buttonSonida", "buttonHonado", "btnSonigo", "buttonTanado", "ButtonSonado", "buttonHonardo", "buttonHonino", "buttonTanida", "buttonsonigo", "buttonSonardo", "buttonSonida", "ButtonDonido", "buttonHomardo", "buttonSenino", "buttonSonini", "buttonTanido", "btnSonardo", "buttonsonido"], "e": [" je", " fe", "ed", " ace", " exception", " events", "ee", " invoked", "t", " caught", " exc", " ev", " pe", "E", " Event", " E", " ignored", " en", " ate", " exp", " other", "Event", " ie", " cause", " inst", "event", " te"], "fc": ["fw", "irc", "fr", "flo", "lf", "bf", "fa", "PF", "fd", "fi", "fl", "il", "LC", "lc", "cf", "FC", "xf", "WF", "fm", "FE", "fe", "bc", "dc", "fb", "nc", "isc", "af", "DC", "fp", "wic", "WC", "con", "xc", "fn", "fed", "tc", "f", "roc", "fs", "CF", "enc", "FS", "Factory", "GF", "ct", "pc", "fx", "mc", " FC", "wk", "wt", "F", "c", "ec"], "returnVal": [" returnval", "backValue", "returnval", "returnVAL", " returnNum", "continueValue", " returnValue", "continueval", "ReturnValue", "returnValue", "Returnval", "returnNum", "ReturnVAL", "backVAL", "ReturnNum", "continueNum", "backval", " returnVAL", "continueVal", "ReturnVal", "backVal"], "file": ["get", "image", "db", "full", "files", "up", "class", "socket", "object", "use", "feed", "user", "global", "input", "page", "cf", "directory", "handler", "File", "per", "fe", "info", "to", "sf", "connection", "http", "php", "path", "resource", "fp", "single", "io", "message", "out", "function", "FILE", "ile", "part", "dir", "f", "url", "binary", "lib", "base", "zip", "data", "type", "b", "local", "log", "document", "name", "l", "folder", "uri", "lock", "source", "filename"], "rutaGlobal": ["rutoGeneral", "rucaGeneral", "rottaLocal", "srettaGlobal", "rettaInternational", "rugaInternational", "srettaInternational", "rundaGeneral", " rutaInternational", "srottaGeneral", "rugaReal", "rutaReal", "rutiCore", "rundaGlobal", " rutoGlobal", "rutiLocal", " rutaGeneral", "rettaLocal", "srutaGlobal", "rottaGlobal", "rutiGlobal", "rutoGlobal", "rutiReal", "rutaLocal", "rugaGlobal", "srettaLocal", "srutaCore", "rutaInternational", "rutoLocal", " rutoGeneral", "srutaGeneral", "rettaReal", "srottaCore", "srottaGlobal", "rucaInternational", "rettaGlobal", "rottaGeneral", "rutiInternational", "rutaCore", "rutoInternational", "rucaGlobal", "rundaInternational", " rutoInternational", "rugaLocal", "srutaLocal", "rutoCore", "rutaGeneral", "srutaReal", "rottaCore", "srottaLocal", "rutiGeneral", "srettaReal", "srutaInternational"], "rutaRelativa": ["rutaRelarativas", "rutaMalarivo", "rutaMalativa", "rutaRelarativ", "rutaMalativas", "rutaRelativ", "rutaMalariva", "rutaRelateivo", "rutaMalarivism", "rutaRelateivism", "rutaRelattivism", "rutaRelariv", "rutaRelateiv", "rutaRelattiv", "rutaRelariva", "rutaRelarivas", "rutaRelativo", "rutaRelarativa", "rutaRelativas", "rutaRelattivo", "rutaRelarativo", "rutaRelarivism", "rutaRelattiva", "rutaRelATivas", "rutaRelarivo", "rutaMalativo", "rutaRelateiva", "rutaRelATiv", "rutaRelattivas", "rutaRelATiva", "rutaRelarativism", "rutaMalarivas", "rutaRelativism", "rutaMalativism", "rutaRelATivo"], "fis": ["Fir", "xiss", "vis", " fys", "xis", "fys", "fros", "xris", "Fys", " fris", "FIs", "fIs", "vIs", "Fos", "viss", "vos", " fiss", " fIs", " fir", "fir", "friss", "xys", "fris", "fiss", "Fris", "frir", "Fis", "Fiss"], "fos": ["tfops", "tfOS", "fileops", "fOS", "fios", "fileos", "infis", "fo", "fileocks", "Fos", "infos", "infOS", "Focks", "tfo", " fops", " focks", "Fops", "tfos", "fileo", " fo", "Fo", " fios", "Fios", "infios", "fops", "FOS", " fOS", "Fis", "focks"], "canalFuente": ["canalMuence", "canalBuente", "canalBuento", "canalFUent", "canalMuent", "canalJuencer", "canalFuencer", "canallBuence", "canalFugent", "canulFuencer", "canalJuent", "canulFience", "canalsBuento", "canulFient", "canallBuenza", "canalMuencer", "canalFuento", "canalBuent", "canallFugent", "canallBuente", "canalKuente", "canulFiente", "canulFuente", "canalBuenza", "canulFuent", "canallBugent", "canalsFuent", "canalJuento", "canalfuence", "canalFuent", "canalKugent", "canalFuenza", "canalFiencer", "canalFUante", "canalFuante", "canalFient", "canalKuenza", "canalsFuante", "canulFiencer", "canalsFuento", "canalFuence", "canallFuenza", "canalFUente", "canalJuante", "canalJuente", "canalKuence", "canalJuence", "canallFuence", "canalsBuente", "canulFuence", "canalfuente", "canalfugent", "canalsBuante", "canalBuence", "canalMuente", "canalFUento", "canalfuenza", "canalsBuent", "canalBuante", "canalsFuente", "canallFuente", "canalFiente", "canalFience", "canalBugent"], "canalDestino": ["canaldestina", "canelCampina", "canaldestino", "canaldestination", "canelDestination", "canallDestania", "canalDestination", "canelDestina", "canelCampination", "canaldestinos", "canalCampinos", "canallDestinos", "canalldestina", "canalDestina", "canalldestania", "canalNegination", "canalCampination", "canalNegino", "canalDestinos", "canalldestinos", "canallDestina", "canalNegina", "canalldestino", "canelCampino", "canalCampino", "canelCampania", "canalDestania", "canalNegania", "canaldestania", "canalCampina", "canelDestino", "canelDestania", "canallDestino", "canalCampania"]}}
{"id1": "21995302", "id2": "12034046", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "label": 0, "substitutes": {"open": ["opening", "process", "get", " OPEN", "ize", "stream", " opening", "use", "load", "init", "parse", "write", "to", " transfer", "handle", "resource", " reopen", "oc", "xml", "change", "Open", "build", "start", "end", "en", "close", "o", " opened", "set", "update", " start", " close", " Open", "it", "un", " opener", "res", "fix", "add", "re", "create", "initial"], "input": ["request", "image", "error", "in", "client", "buffer", "accept", "upload", "element", "argument", "stream", "ink", "i", "output", "socket", "class", "object", "form", "context", "feed", "instance", "inf", "state", "connection", "http", "inner", "container", "resource", "audio", "io", "pull", "ssl", "out", "file", "this", "base", "exec", "data", "type", "temp", "keep", "Input", "text", "document", "reader", "command", "event", "current", "source", "config", "inc", "PUT"], "uri": ["next", "image", "absolute", "iri", "service", " URI", "ki", "element", "eni", "i", "object", "URI", "instance", "id", "abi", "cli", "directory", "gi", "ci", "route", "address", "origin", "picture", "ui", "info", "result", "state", "adi", "connection", "http", "li", "resource", "response", "path", "io", "direction", "manager", "uni", "file", "str", "pi", "uid", "prefix", "api", "base", "definition", "ri", "data", "database", "mi", "via", "document", "di", "string", "si", "verb", "bridge", "qi", "doi", "source", "username"], "url": ["ball", "buffer", "sl", "stream", "i", "socket", "feed", "impl", "ls", "id", "server", "coll", "address", "bel", "source", "state", "connection", "http", "li", "URL", "resource", "io", "ref", "path", "ob", "ssl", "file", "link", "f", "Url", "api", "base", "channel", "plug", "data", "b", "char", "text", "l", "browser", "string", "layer", "config"]}}
{"id1": "1508930", "id2": "19276022", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    public DataSet parse() throws SnifflibDatatypeException {\n        NumberFormat numformat = NumberFormat.getInstance();\n        if (this.headers.size() != this.types.size()) {\n            throw new SnifflibDatatypeException(\"Different number of headers (\" + this.headers.size() + \") and types(\" + this.types.size() + \").\");\n        }\n        DataSet out = null;\n        if (!this.dryrun) {\n            out = new DataSet();\n        }\n        BufferedReader r = null;\n        StreamTokenizer tokenizer = null;\n        try {\n            if (this.isURL) {\n                if (this.url2goto == null) {\n                    return (null);\n                }\n                DataInputStream in = null;\n                try {\n                    in = new DataInputStream(this.url2goto.openStream());\n                    System.out.println(\"READY TO READ FROM URL:\" + url2goto);\n                    r = new BufferedReader(new InputStreamReader(in));\n                } catch (Exception err) {\n                    throw new RuntimeException(\"Problem reading from URL \" + this.url2goto + \".\", err);\n                }\n            } else {\n                if (this.file == null) {\n                    throw new RuntimeException(\"Data file to be parsed can not be null.\");\n                }\n                if (!this.file.exists()) {\n                    throw new RuntimeException(\"The file \" + this.file + \" does not exist.\");\n                }\n                r = new BufferedReader(new FileReader(this.file));\n            }\n            if (this.ignorePreHeaderLines > 0) {\n                String strLine;\n                int k = 0;\n                while ((k < this.ignorePreHeaderLines) && ((strLine = r.readLine()) != null)) {\n                    k++;\n                }\n            }\n            tokenizer = new StreamTokenizer(r);\n            tokenizer.resetSyntax();\n            tokenizer.eolIsSignificant(true);\n            tokenizer.parseNumbers();\n            if (this.delimiter.equals(\"\\\\t\")) {\n                tokenizer.whitespaceChars('\\t', '\\t');\n            }\n            if (this.delimiter.equals(\",\")) {\n                tokenizer.whitespaceChars(',', ',');\n            }\n            tokenizer.quoteChar('\"');\n            tokenizer.whitespaceChars(' ', ' ');\n            boolean readingHeaders = true;\n            boolean readingInitialValues = false;\n            boolean readingData = false;\n            boolean readingScientificNotation = false;\n            if (this.headers.size() > 0) {\n                readingHeaders = false;\n                readingInitialValues = true;\n            }\n            if (this.types.size() > 0) {\n                readingInitialValues = false;\n                Class targetclass;\n                for (int j = 0; j < this.types.size(); j++) {\n                    targetclass = (Class) this.types.get(j);\n                    try {\n                        this.constructors.add(targetclass.getConstructor(String.class));\n                    } catch (java.lang.NoSuchMethodException err) {\n                        throw new SnifflibDatatypeException(\"Could not find appropriate constructor for \" + targetclass + \". \" + err.getMessage());\n                    }\n                }\n                readingData = true;\n            }\n            int currentColumn = 0;\n            int currentRow = 0;\n            this.rowcount = 0;\n            boolean advanceField = true;\n            while (true) {\n                tokenizer.nextToken();\n                switch(tokenizer.ttype) {\n                    case StreamTokenizer.TT_WORD:\n                        {\n                            if (readingScientificNotation) {\n                                throw new RuntimeException(\"Problem reading scientific notation at row \" + currentRow + \" column \" + currentColumn + \".\");\n                            }\n                            advanceField = true;\n                            if (readingHeaders) {\n                                this.headers.add(tokenizer.sval);\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(String.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(String.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    try {\n                                        try {\n                                            try {\n                                                if (!this.dryrun) {\n                                                    out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                } else if (this.findingTargetValue) {\n                                                    if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                        this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                        r.close();\n                                                        return (null);\n                                                    }\n                                                }\n                                            } catch (java.lang.reflect.InvocationTargetException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 1\" + err.getMessage());\n                                            }\n                                        } catch (java.lang.IllegalAccessException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 2\" + err.getMessage());\n                                        }\n                                    } catch (java.lang.InstantiationException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 3\" + err.getMessage());\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_NUMBER:\n                        {\n                            advanceField = true;\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"Expecting string header at row=\" + currentRow + \", column=\" + currentColumn + \".\");\n                            } else {\n                                if (readingInitialValues) {\n                                    this.types.add(Double.class);\n                                }\n                                if (!this.dryrun) {\n                                    if (out.getColumnCount() <= currentColumn) {\n                                        out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                    }\n                                }\n                                try {\n                                    Constructor construct;\n                                    if (currentColumn < this.constructors.size()) {\n                                        construct = (Constructor) this.constructors.get(currentColumn);\n                                    } else {\n                                        Class targetclass = (Class) this.types.get(currentColumn);\n                                        construct = targetclass.getConstructor(double.class);\n                                        this.constructors.add(construct);\n                                    }\n                                    if (readingScientificNotation) {\n                                        Double val = this.scientificNumber;\n                                        if (!this.dryrun) {\n                                            try {\n                                                out.setValueAt(new Double(val.doubleValue() * tokenizer.nval), currentRow, currentColumn);\n                                            } catch (Exception err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                            }\n                                        } else if (this.findingTargetValue) {\n                                            if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                Double NVAL = new Double(tokenizer.nval);\n                                                try {\n                                                    this.targetValue = numformat.parse(val + \"E\" + NVAL);\n                                                } catch (Exception err) {\n                                                    throw new RuntimeException(\"Problem parsing scientific notation at row=\" + currentRow + \" col=\" + currentColumn + \".\");\n                                                }\n                                                tokenizer.nextToken();\n                                                if (tokenizer.ttype != 'e') {\n                                                    r.close();\n                                                    return (null);\n                                                } else {\n                                                    tokenizer.pushBack();\n                                                }\n                                            }\n                                        }\n                                        readingScientificNotation = false;\n                                    } else {\n                                        try {\n                                            this.scientificNumber = new Double(tokenizer.nval);\n                                            if (!this.dryrun) {\n                                                out.setValueAt(this.scientificNumber, currentRow, currentColumn);\n                                            } else if (this.findingTargetValue) {\n                                                if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                    this.targetValue = this.scientificNumber;\n                                                    r.close();\n                                                    return (null);\n                                                }\n                                            }\n                                        } catch (Exception err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing \" + construct.getDeclaringClass() + \"at row \" + currentRow + \" column \" + currentColumn + \".\", err);\n                                        }\n                                    }\n                                } catch (java.lang.NoSuchMethodException err) {\n                                    throw new SnifflibDatatypeException(\"Problem constructing\" + err.getMessage());\n                                }\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOL:\n                        {\n                            if (readingHeaders) {\n                                readingHeaders = false;\n                                readingInitialValues = true;\n                            } else {\n                                if (readingInitialValues) {\n                                    readingInitialValues = false;\n                                    readingData = true;\n                                }\n                            }\n                            if (readingData) {\n                                currentRow++;\n                            }\n                            break;\n                        }\n                    case StreamTokenizer.TT_EOF:\n                        {\n                            if (readingHeaders) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading headers.\");\n                            }\n                            if (readingInitialValues) {\n                                throw new SnifflibDatatypeException(\"End of file reached while reading initial values.\");\n                            }\n                            if (readingData) {\n                                readingData = false;\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            if (tokenizer.ttype == '\"') {\n                                advanceField = true;\n                                if (readingHeaders) {\n                                    this.headers.add(tokenizer.sval);\n                                } else {\n                                    if (readingInitialValues) {\n                                        this.types.add(String.class);\n                                    }\n                                    if (!this.dryrun) {\n                                        if (out.getColumnCount() <= currentColumn) {\n                                            out.addColumn((String) this.headers.get(currentColumn), (Class) this.types.get(currentColumn));\n                                        }\n                                    }\n                                    try {\n                                        Constructor construct;\n                                        if (currentColumn < this.constructors.size()) {\n                                            construct = (Constructor) this.constructors.get(currentColumn);\n                                        } else {\n                                            Class targetclass = (Class) this.types.get(currentColumn);\n                                            construct = targetclass.getConstructor(String.class);\n                                            this.constructors.add(construct);\n                                        }\n                                        try {\n                                            try {\n                                                try {\n                                                    if (!this.dryrun) {\n                                                        out.setValueAt(construct.newInstance((String) tokenizer.sval), currentRow, currentColumn);\n                                                    } else if (this.findingTargetValue) {\n                                                        if ((this.targetRow == currentRow) && (this.targetColumn == currentColumn)) {\n                                                            this.targetValue = construct.newInstance((String) tokenizer.sval);\n                                                            r.close();\n                                                            return (null);\n                                                        }\n                                                    }\n                                                } catch (java.lang.reflect.InvocationTargetException err) {\n                                                    throw new SnifflibDatatypeException(\"Problem constructing 1 \" + err.getMessage());\n                                                }\n                                            } catch (java.lang.IllegalAccessException err) {\n                                                throw new SnifflibDatatypeException(\"Problem constructing 2 \" + err.getMessage());\n                                            }\n                                        } catch (java.lang.InstantiationException err) {\n                                            throw new SnifflibDatatypeException(\"Problem constructing 3 \" + err.getMessage());\n                                        }\n                                    } catch (java.lang.NoSuchMethodException err) {\n                                        throw new SnifflibDatatypeException(\"Problem constructing 4\" + err.getMessage());\n                                    }\n                                }\n                            } else if (tokenizer.ttype == 'e') {\n                                Class targetclass = (Class) this.types.get(currentColumn);\n                                if (Number.class.isAssignableFrom(targetclass)) {\n                                    currentColumn--;\n                                    readingScientificNotation = true;\n                                    advanceField = false;\n                                }\n                            } else {\n                                advanceField = false;\n                            }\n                            break;\n                        }\n                }\n                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {\n                    break;\n                }\n                if (advanceField) {\n                    currentColumn++;\n                    if (!readingHeaders) {\n                        if (currentColumn >= this.headers.size()) {\n                            currentColumn = 0;\n                        }\n                    }\n                }\n            }\n            if (!readingHeaders) {\n                this.rowcount = currentRow;\n            } else {\n                this.rowcount = 0;\n                readingHeaders = false;\n                if (this.ignorePostHeaderLines > 0) {\n                    String strLine;\n                    int k = 0;\n                    while ((k < this.ignorePostHeaderLines) && ((strLine = r.readLine()) != null)) {\n                        k++;\n                    }\n                }\n            }\n            r.close();\n        } catch (java.io.IOException err) {\n            throw new SnifflibDatatypeException(err.getMessage());\n        }\n        if (!this.dryrun) {\n            for (int j = 0; j < this.headers.size(); j++) {\n                out.setColumnName(j, (String) this.headers.get(j));\n            }\n        }\n        return (out);\n    }\n", "label": 1, "substitutes": {"httpRequestByPOST": ["httpRequestNoPut", "httpRequestWithPOST", "httpRequestAsGET", "httpRequestWithGET", "httpPostWithpost", "httpRequestNoGET", "httpRequestWithpost", "httpPostWithPut", "httpRequestNoPOST", "httpRequestByPut", "httpRequestAsPut", "httpRequestAsPOST", "httpPostBypost", "httpPostByPut", "httpRequestWithPut", "httpPostWithPOST", "httpRequestAspost", "httpPostByGET", "httpRequestNopost", "httpRequestBypost", "httpRequestByGET", "httpPostByPOST", "httpPostWithGET"], "url": ["request", "domain", "email", "html", "queue", "host", "route", "page", "id", "server", "json", "address", "connection", "http", "location", "URL", "resource", "path", "ssl", "date", "file", "str", "Url", "api", "base", "download", "name", "l", "string", "uri", "www", "username"], "timeout": ["blocking", "size", "max", "socket", "delay", "page", "limit", "cache", "cookie", "connection", "time", "URL", "resource", "sleep", "Timeout", "ssl", "out", "until", "token", "wait", "method", "password", "random", "duration", "length"], "params": ["request", "ip", "Par", "details", "words", "query", "attr", "Param", "server", "json", "properties", "ams", "http", "param", "services", "posts", "terms", "resources", "results", "ras", "apps", "options", "Parameters", "relations", "api", "data", "pins", "names", "settings", "password", "prop", "parts", "ps", "list", "source"], "response": ["request", "next", "image", "service", "tree", "full", "output", "reply", "object", "feed", "page", "server", "json", "example", "answer", "more", "result", "connection", "content", "array", "resource", "report", "message", "location", "reason", "Response", "value", "resp", "str", "api", "model", "data", "collection", "status", "application", "res", "site", "respond", "string", "uri"], "httpClient": ["HttpPost", " httpStore", "serverStore", "httpStore", "httpsClient", "httpServer", "HttpClient", "httpContract", "serverContract", "serverPost", "HttpContract", "HttpServer", "serverServer", "httpsContract", "httpsPost", "serverClient", "HttpStore", "httpsServer", " httpServer"], "httpPost": [" httppost", "HttpPost", "httpsPut", "HttpPut", "httpPOST", " httpPOST", "httpAdd", "HttpThread", "HttpDo", "Httppost", " httpThread", "httpRequest", " httpRequest", "htmlPost", "ttpThread", "httpPut", "HttpPOST", "httppost", "htmlDo", "HttpRequest", "httpThread", "httpDo", "httpsAdd", "ttpRequest", "ttpPost", "ttpDo", "httpsPOST", "httpsDo", "htmlPut", " httpAdd", "HttpAdd", "httpsPost", "httpspost", "htmlPOST", " httpDo"], "serverResponse": ["httpResp", "statusResponse", "httpStatus", " serverSession", "statusSession", "statusResp", "erverResp", "httpServer", "erverServer", "ServerClient", " serverResp", "serverResp", "httpSession", "erverClient", "ServerResponse", "statusStatus", "ServerServer", "serverServer", "serverStatus", "serverSession", "ServerResp", " serverStatus", "statusClient", "serverClient", " serverClient", "erverResponse", "httpResponse"], "statusLine": ["resourceLine", "syncLine", "responseEntity", "StatusPass", "httpLine", "progressLine", "statusNode", "syncEntity", "statusPage", "responseLin", "statusL", "statusFile", "StatusLink", "StatusNode", "StatusFile", "httpCode", "responseCode", "statusCode", "resourceL", "syncLin", "errorError", "errorCode", "StatusLine", "contentNode", "responseError", "errorLink", "progressLin", "StatusPage", "serverFile", "StatusCode", "StatusL", "syncCode", "errorLine", "contentFile", "contentLine", "contentPage", "statusError", "serverLine", "responseLine", "responseLink", "resourcePass", "resourceCode", "progressCode", "progressEntity", "serverPage", "statusLink", "statusEntity", "statusPass", "httpL", "httpPass", "StatusError", "serverNode", "statusLin"], "inputStream": ["tempContent", "InputBuffer", "Inputstream", "loadStream", " inputSteam", "tempStreamer", "pullBuffer", "inContent", "loadSteam", " inputStreamer", " inputstream", "InputSteam", " inputContent", "tempSteam", "pullReader", "inReader", "instream", "InputReader", "inputSteam", "InputStream", "inputBuffer", "inputContent", "inStream", "pullStream", "InputContent", "tempStream", "inSteam", "loadContent", "pullSteam", "inBuffer", "loadStreamer", "inputStreamer", "inputstream"], "inputReader": ["outputBuilder", "outputER", "outputStream", "outputStreamer", "readerReader", "requestBuffer", "regularReader", "readerStream", "regularStream", "outputReader", "requestStream", "readerStreamer", " inputBuilder", "inputER", "requestBuilder", "regularStreamer", "inputBuffer", "requestReader", "inputBuilder", " inputBuffer", "outputBuffer", "readerER", "inputStreamer", "regularER"], "bufferedReader": ["buffedStream", " buffaredRead", "buffererContainer", "buffaredRead", "bufferedRead", "bufferedStream", "BufferedWriter", "bufferingReader", "bufferingWriter", "BufferedReader", "bufferingStream", "buffaredContainer", "buffedWriter", "BufferedContainer", "buffedReader", " bufferedRead", "buffererStream", "buffererReader", "bufferingRead", " buffaredReader", "buffererWriter", "bufferedWriter", "buffaredStream", "BufferingStream", " buffaredStream", "bufferingContainer", "BufferedStream", "buffedRead", "bufferedContainer", "BufferingReader", " bufferedStream", "buffaredWriter", "BufferingContainer", " buffaredWriter", "BufferingWriter", " bufferedWriter", "buffaredReader"], "buffer": ["request", "pause", "image", "writer", "queue", "output", "surface", "feed", "bb", "copy", "slave", "page", "Buffer", "limit", "cache", "server", "sb", "source", "result", "array", "fb", "message", "resource", "audio", "buff", "ignore", "report", "ob", "out", "row", "translation", "uffer", "iter", "buf", "binary", "null", "base", "data", "builder", "type", "loader", "b", "bar", "wave", "document", "background", "reader", "string", "header", "loop", "layer"], "line": ["ip", "sl", "lf", "sync", "entry", "block", "i", "key", "cell", "object", "el", "comment", "character", "feed", "parse", "e", "page", "lc", "lines", "Line", "lin", "code", "content", "message", "row", "file", "str", "liner", "iter", "link", "end", "letter", "pass", "base", "unit", "inline", "data", "char", "LINE", "number", "text", "cl", "name", "l", "body", "string", "header", "le", "source", "column"], "lastErrorCode": [" lastErrorName", "lastHeaderMessage", "currentStatusCause", "currentStatusCode", "lastHttpCode", "lastStatusText", "lastErrorInfo", " lastHeaderName", "lastSuccessText", "currentStatusText", "currentStatusMessage", "lastErrorName", " lastHeaderInfo", " lastErrorInfo", "lastSuccessCause", "lastWarningCode", "lastStatusCause", "currentErrorMessage", "lastHeaderCode", "lastHeaderName", "lastStatusMessage", " lastHeaderMessage", "lastSuccessCode", "lastWarningName", "currentErrorCode", "lastHttpCause", "currentErrorCause", "lastWarningMessage", "lastStatusCode", "lastHttpMessage", "lastHeaderInfo", "currentErrorText", "lastErrorText", " lastHeaderCode", "lastStatusName", "lastWarningInfo", "lastStatusInfo", "lastHttpText", "lastErrorCause", "lastSuccessMessage"], "lastErrorMessage": ["lastHeaderMessage", "lastCodeException", "lastErrorSummary", " lastHeaderSummary", "lastHeaderSummary", " lastErrorDetails", "lastWarningSummary", "lastStatusStatus", " lastWarningStatus", "lastCodeSummary", "lastStatusDetails", "lastWarningDetails", "lastWarningCode", "lastHeaderCode", "lastCodeCode", " lastWarningDescription", "lastStatusMessage", "lastStatusDescription", " lastWarningMessage", "lastWarningException", " lastHeaderMessage", " lastHeaderException", "lastWarningStatus", " lastErrorDescription", "lastErrorException", "lastWarningMessage", "lastErrorDescription", "lastWarningDescription", "lastErrorStatus", " lastErrorException", " lastErrorStatus", " lastErrorSummary", " lastHeaderCode", "lastErrorDetails", "lastHeaderException", "lastCodeMessage", " lastWarningDetails"]}}
{"id1": "10391753", "id2": "932225", "code1": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "code2": "    public void createVendorSignature() {\n        byte b;\n        try {\n            _vendorMessageDigest = MessageDigest.getInstance(\"MD5\");\n            _vendorSig = Signature.getInstance(\"MD5/RSA/PKCS#1\");\n            _vendorSig.initSign((PrivateKey) _vendorPrivateKey);\n            _vendorMessageDigest.update(getBankString().getBytes());\n            _vendorMessageDigestBytes = _vendorMessageDigest.digest();\n            _vendorSig.update(_vendorMessageDigestBytes);\n            _vendorSignatureBytes = _vendorSig.sign();\n        } catch (Exception e) {\n        }\n        ;\n    }\n", "label": 1, "substitutes": {"encrypt": ["deccrypt", "encress", "Encrypt", "decress", "enccrypt", " encipher", "decrypt", "encipher", " encress", " enccrypt", "Encipher", "Encress", "decipher", "Enccrypt"], "text": ["plain", "image", "buffer", "bytes", "crypt", "key", "output", "class", "object", "pattern", "input", "Text", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "word", "out", "str", "prefix", "letter", "data", "token", "test", "contract", "name", "password", "string", "encrypted", "source", "config", "length", "hex", "txt"], "toEncrypt": ["toEnccrypt", "toCrypted", " toEncipher", "toCcrypt", "toCryption", "toDiscipher", "toAcract", "toCCrypt", " toEncryption", "toDecract", "toExecrypt", "toDiscract", "toEncript", " toDecrypt", "toRecrypt", " toExeccrypt", "toCrypt", "toDecryption", " toDecert", " toEnccrypt", "toExeccrypt", "toRecryption", "toAcrypt", " toExecrypt", "toRecript", " toCryption", "toCript", "toReccrypt", " toEncrypted", " toEncract", "toDiscrypt", "toAcert", " toEncript", " toDecipher", " toDecract", "toExecript", " toCrypt", " toCrypted", " toExecript", "toExecrypted", " toEncCrypt", "toEncrypted", "toDecCrypt", "toAcipher", "toEncipher", "toDiscert", " toExecryption", "toDecipher", "toExecryption", "toDecrypted", "toEncryption", "toDecert", "toDecrypt", "toExecCrypt", "toEncCrypt", " toCCrypt", "toEncert", "toEncract", " toEncert"], "hexString": [" hexUnit", "hashstring", "hexUnit", " hexArray", "shortBuffer", "stringstring", "hexstring", "hexText", "indexstring", "hashBuffer", "hashList", "hexArray", "indexArray", "shortString", "stringArray", "indexText", "indexString", "stringUnit", "shortList", "stringString", "textstring", "hashString", " hexBuffer", "hashArray", "textArray", " hexList", "hashText", "textUnit", "hexBuffer", "hexList", "shortArray", " hexstring", " hexText", "textString"], "dig": ["dim", "get", "db", "fin", "de", "del", "grad", "prep", " mod", "comb", "dd", "define", "dec", "cr", " Dig", "mix", "ng", "fe", "um", "diff", "or", "cd", "alg", "dc", "exp", "grab", "destruct", "ssl", "build", "find", " dec", " comb", "enc", "est", "rep", "div", "log", "her", "im", "pm", "test", "Dig", "draw", "ig", "driver", "mod", "du", "wrap", "d", "pro", "and", "cod", "lab", "loop", "hash", "push", "sign", "add", "gen", "neg", "rand", "rob", "hex"], "pw": [" pws", "PW", " pwa", " paw", "cw", "pwd", "lpow", "cws", "Pow", " pye", "Pwd", "pws", "prw", "Pwh", "praw", "ppw", "ppaw", "Pws", " pow", "pye", " pwh", "pwa", "prwa", "prye", " pwd", "lpW", "ppye", "pow", "lpw", "lpwd", "cW", "pW", " pW", "paw", "Pw", "pwh", "cwh", "ppwa"], "i": ["r", "ai", "ip", "in", "m", "h", "p", "j", "n", "key", "ix", "slice", "e", "phi", "id", "mu", "ci", "gi", "lc", "t", "ui", "length", "a", "index", "li", "ii", "io", "ei", "z", "ini", "bi", "start", "x", "pi", "f", "end", "o", "xi", "ti", "k", "data", "ri", "u", "b", "y", "v", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "chi", "qi", "uri", "I", "c"], "digest": ["hashester", "debugested", " digested", "signest", " digesting", "labester", "hashEST", "delEST", "DigEST", "delester", " digests", "signEST", "debuggest", "diggest", "Digestamp", "digests", "delest", "digestamp", " digEST", "Digest", "delestamp", "hashested", "codests", "Digester", " digester", "hashest", "digester", "digEST", "labesting", "labests", "labest", "digesting", " diggest", "codester", " digestamp", "debugester", "digested", "Diggest", "codesting", "Digested", "signested", "codest", "debugest", "signester"], "digestLength": ["digstLength", "digesterType", "digESTStr", "digesterLength", "digesterLen", "diffesterLoop", "digesterLine", "digusterLine", "digESTLength", "DigestLine", "digestlength", "digstLoop", "DigesterLength", "digESTLine", "DigestStr", "digestLen", "digestLoop", "DigestLength", "DigesterLine", "digstType", "DigestLen", "digestLine", "digusterStr", "digesterlength", "digesterStr", "digestType", "digusterLength", "digesterLoop", "DigesterStr", "diffestLength", "digestationType", "digstlength", "diffestlength", "diffesterType", "digusterLen", "digestationLength", "diffestLoop", "digestStr", "DigesterLen", "diffesterLength", "diffestType", "diffesterlength", "digESTLen", "digestationLoop", "digestationlength"]}}
{"id1": "1097146", "id2": "21827619", "code1": "    public static String getMessageDigest(String input) {\n        if (input == null) {\n            log.warn(\"Returning SHA-1 null value for null input\");\n            return null;\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(input.getBytes(\"UTF-8\"));\n            byte[] bytes = md.digest();\n            return new BASE64Encoder().encode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        } catch (UnsupportedEncodingException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "code2": "    public static String SHA1(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "label": 1, "substitutes": {"getMessageDigest": ["getContentdigests", "getMessageEncester", "getMessagedigests", "getContentDigests", "getMessagedigifier", "getMessageDigifier", "getMessageDigests", "getMessageSignifier", "getMessageEncifier", "getMessagedigester", "getMessageEncest", "getMessageSignester", "getMessageEncests", "getContentdigest", "getContentDigester", "getMessagedigest", "getMessageDigester", "getContentdigifier", "getMessageSignests", "getContentdigester", "getContentDigest", "getContentDigifier", "getMessageSignest"], "input": ["request", "image", "in", "buffer", "self", "amp", "accept", "element", "argument", "stream", "i", "output", "form", "object", "context", "instance", "parse", "parent", "address", "plus", "inf", "state", "target", "content", "inner", "submit", "audio", "message", "array", "container", "xml", "raw", "out", "now", "str", "binary", "this", "null", "definition", "model", "data", "temp", "type", "Input", "text", "document", "password", "reader", "string", "list", "empty", "source", "config"], "md": ["mac", "mm", "mo", "m", "bf", "mad", "mn", "metadata", "M", "um", "ma", "dr", "od", "dc", "bm", "rm", "amd", "cm", "mb", "nm", "df", "wd", "gd", "mand", "bd", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "di", "me", "mc", "vd", "mag", "rpm", "d", "mod", "ms", "meta", "am", "cmd", "dd", " MD"], "bytes": ["vals", "words", "ipes", "ies", "files", "les", "s", "bs", "units", "strings", "its", "odes", "es", "address", "lines", "keys", "seconds", "tes", "bps", "Bytes", "codes", "gb", "pieces", "classes", "bits", "binary", "pages", "null", "base", "data", "blocks", "b", "values", "groups", "rows", "bles", "body", "string", "parts", "outs"]}}
{"id1": "18504192", "id2": "7044685", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    static String encrypt(String plaintext) {\n        MessageDigest d = null;\n        try {\n            d = MessageDigest.getInstance(\"SHA-1\");\n            d.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return new String(Base64.encodeBase64(d.digest()));\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "inn", "src", "i", "old", "input", "copy", "parent", "id", "info", "diff", "or", "inner", "index", "io", "ini", "at", "file", "part", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "d", "again", "c", "inc"], "out": ["Out", "client", "writer", "p", "obj", "n", "output", "object", "copy", "ex", "cache", "conn", "target", "connection", "io", "dest", "file", "line", "part", "prefix", "o", "base", "exec", "data", "temp", "err", "b", "w", "call", "name", "password", "again", "string", "point", "outs", "external", "OUT", "c", "inc"], "source": ["get", "client", "clone", "component", "service", "size", "writer", "sl", "sync", "ie", "stream", "src", "i", "view", "use", "proxy", "scope", "input", "slice", "slave", "parent", "copy", "sin", "core", "server", "origin", "from", "target", "connection", "se", "ssl", "dest", "Source", "secure", "storage", "iter", "start", "channel", "unit", "null", "SOURCE", "settings", "reader", "project", "ource", "self", "ources"], "destination": ["Destinated", "declinated", "continated", "destinations", "dependinated", "declination", "Destinations", "declification", "contination", "Destinator", "dependination", "testinator", "Destification", " destinated", "dependification", "destinator", "destinated", " destinations", "contining", "destification", "destining", "testinations", " destinator", "testination", "Destination", "testinated", "continator", "Destining", " destining", "dependinator", "declinator"]}}
{"id1": "16851955", "id2": "18217985", "code1": "    @Test\n    public void testTrainingBackprop() throws IOException {\n        File temp = File.createTempFile(\"fannj_\", \".tmp\");\n        temp.deleteOnExit();\n        IOUtils.copy(this.getClass().getResourceAsStream(\"xor.data\"), new FileOutputStream(temp));\n        List<Layer> layers = new ArrayList<Layer>();\n        layers.add(Layer.create(2));\n        layers.add(Layer.create(3, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(2, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        layers.add(Layer.create(1, ActivationFunction.FANN_SIGMOID_SYMMETRIC));\n        Fann fann = new Fann(layers);\n        Trainer trainer = new Trainer(fann);\n        trainer.setTrainingAlgorithm(TrainingAlgorithm.FANN_TRAIN_INCREMENTAL);\n        float desiredError = .001f;\n        float mse = trainer.train(temp.getPath(), 500000, 1000, desiredError);\n        assertTrue(\"\" + mse, mse <= desiredError);\n    }\n", "code2": "    public static String fromHtml(URL url, String defaultEncoding, boolean overrideEncoding) throws IOException, BadDocumentException {\n        URLConnection conn = url.openConnection();\n        String contentType = conn.getContentType();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) {\n            int i = contentType.indexOf(\"charset\");\n            if (i >= 0) {\n                String s = contentType.substring(i);\n                i = s.indexOf('=');\n                if (i >= 0) {\n                    s = contentType.substring(i + 1).trim();\n                    encoding = s.replace(\"\\'\", \"\").replace(\"\\\"\", \"\").trim();\n                    if (encoding.equals(\"\")) {\n                        encoding = defaultEncoding;\n                    }\n                }\n            } else {\n                encoding = defaultEncoding;\n            }\n        }\n        String expected = \"text/html\";\n        if (contentType == null) {\n            DefaultXMLNoteErrorHandler.warning(null, 90190, \"Returned content type for url.openConnection() is null\");\n            contentType = expected;\n        }\n        int index = contentType.indexOf(';');\n        if (index >= 0) {\n            contentType = contentType.substring(0, index).trim();\n        }\n        if (!contentType.equals(expected)) {\n            String msg = translator.translate(\"The content type of url '%s' is not '%s', it is '%s'\");\n            throw new BadDocumentException(String.format(msg, url.toString(), expected, contentType));\n        }\n        BufferedReader in = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        return fromHtml(in, encoding);\n    }\n", "label": 0, "substitutes": {"testTrainingBackprop": ["testTrainingBACKpointer", "testTrainingBACKdrop", "testTrainBACKprop", "testTrainBACKpressure", "testTrainingFrontdrop", "testTrainingBackpressure", "testTrainingBackdrop", "testTrainBackpointer", "testTrainingBACKprop", "testTrainingFrontprop", "testTrainBACKdrop", "testTrainingFrontpointer", "testTrainingFrontpressure", "testTrainBackprop", "testTrainingBackpointer", "testTrainBackdrop", "testTrainBackpressure", "testTrainingBACKpressure", "testTrainBACKpointer"], "temp": ["font", "fake", "clean", "pdf", "template", "writer", "buffer", "save", "cel", "full", "output", "form", "tmp", "input", "copy", "parent", "ex", "Temp", "archive", "directory", "cache", "http", "container", "path", "io", "out", "dest", "file", "storage", "tem", "f", "this", "stable", "base", "zip", "porary", "data", "emp", "flat", "model", "local", "v", "session", "test", "mount", "wrap", "folder", "empty", "lock", "current", "dat", "config", "pipe", "txt"], "layers": ["bllements", "dlores", "blayers", "lients", "nlikes", "dlasks", "fllements", " lowers", "liores", "players", "placks", "gobs", "licayers", "nlagers", "dlibraries", " libraries", "nlayers", "bowers", "languages", "planguages", "lasses", "lacks", "llements", "Lients", "bays", " lients", "dlanguages", "blasses", " lacks", "flanguages", "bayers", " lasses", "gayers", "lagers", "licagers", " lays", "nlibraries", "lores", " lores", "lasks", "dlacks", "slacks", "lobs", "Layers", "flasses", " likes", "gients", "slays", "libraries", "liacks", " lasks", "liayers", " llements", "licikes", " languages", "flayers", " lobs", "lays", "backs", "lowers", "licibraries", "Lobs", "liibraries", "slowers", "likes", "blanguages", "slayers", " lagers", "plasks", "dlayers"], "fann": ["Fanny", "elfana", "sfanny", "Fannon", "xfanny", "elfnn", "sfannon", "fannon", "fanny", "larn", "fain", "lana", "gnn", "gann", "elfann", "xfannon", "xfann", "sfain", "elfarn", "fnn", "Fann", "lann", "fana", "xfain", "gana", "lnn", "sfann", "garn", "farn", "Fain"], "trainer": [" tracker", "Trainer", "Trayer", "Tracer", "retacer", "tracker", "strayer", "traacer", "traainer", "Tracker", "train", "traacker", "retainer", "tracer", "rainer", "striner", "retayer", "stracer", "strainer", "tacker", "trarain", "tacer", "stracker", "trayer", " tracer", "trrain", "strain", " train", "tainer", "rain", "racker", "racer", "Triner", "Trrain", "triner", "retiner"], "desiredError": ["reservedError", "deservedOrder", "desivedSize", "descidederror", "DesireException", "desciredError", "DesireError", "DesiredSize", "deservedSize", "desirederror", "desivedException", "desiredException", "desirableEvent", "DesireSize", "desizedSize", "resiredSize", "desciredFailure", "designedError", "desidedProblem", "DesiredError", "deservedError", "deservedEvent", "desiringFailure", "descidedFailure", "despectederror", "designedSize", "desidedFailure", "descidedError", "desirableOrder", "descirederror", "desiringerror", "resiredError", "desirableError", "desirableSize", "desiredFailure", "DesiredException", "desiredOrder", "desciredProblem", "desireException", "desidedError", "desizedError", "designedOrder", "desiredProblem", "designedEvent", "reservedOrder", "desiringProblem", "resiredEvent", "desiringError", "desidederror", "despectedError", "reservedSize", "desiredEvent", "reservedEvent", "desireSize", "desireError", "despectedProblem", "descidedProblem", "resiredOrder", "despectedFailure", "desiredSize", "desizedException", "desivedError"], "mse": ["fce", "fmte", "Mte", " mge", " mce", "gmge", "gmSE", "fmse", "mze", "fmce", "mge", "fmze", "fge", "Mze", "gmse", "Mse", "mce", "mSE", "Mce", "MSE", "Mge", "mte", "fSE", "fse", " mze", " mSE", "gmce", " mte"]}}
{"id1": "22708533", "id2": "10218878", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    public static void DecodeMapFile(String mapFile, String outputFile) throws Exception {\n        byte magicKey = 0;\n        byte[] buffer = new byte[2048];\n        int nread;\n        InputStream map;\n        OutputStream output;\n        try {\n            map = new FileInputStream(mapFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        try {\n            output = new FileOutputStream(outputFile);\n        } catch (Exception e) {\n            throw new Exception(\"Map file error\", e);\n        }\n        while ((nread = map.read(buffer, 0, 2048)) != 0) {\n            for (int i = 0; i < nread; ++i) {\n                buffer[i] ^= magicKey;\n                magicKey += 43;\n            }\n            output.write(buffer, 0, nread);\n        }\n        map.close();\n        output.close();\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": ["insertDocumentUsingFile", "insertDocumentToFile", "insertDocumentAsFile", "insertDocumentTourl", "insertDocumentToUrl", "insertDocumentUsingurl", "insertFileToURL", "insertDocumentAsurl", "insertDocumentFromFile", "insertFileFromUrl", "insertFileToUrl", "insertDocumentAsUrl", "insertDocumentFromURL", "insertDocumentUsingUrl", "insertFileToFile", "insertDocumentAsURL", "insertFileFromurl", "insertDocumentFromUrl", "insertDocumentFromurl", "insertFileFromURL", "insertDocumentUsingURL", "insertFileFromFile", "insertFileTourl"], "file": ["image", "db", "self", "stream", "files", "src", "class", "object", "use", "input", "id", "File", "address", "from", "path", "resource", "fp", "xml", "FILE", "dir", "f", "base", "data", "local", "document", "name", "framework", "frame", "string", "place", "uri", "source", "filename"], "target": ["next", "template", "large", "host", "output", "pattern", "object", "proxy", "reference", "parent", "office", "port", "server", "address", "to", "result", "pointer", "location", "path", "resource", "dest", "root", "base", "platform", "Target", "rel", "database", "tag", "document", "name", "site", "external", "remote", "project", "string", "source", "filename"], "is": ["lis", "get", "ai", "in", "ip", "Is", "mis", "service", "us", "bis", "ie", "iso", "isl", "oss", "isa", "src", "i", "cs", "s", "bs", "ois", "was", "its", "ls", "id", "ci", "css", "es", "isi", "address", "ris", "conn", "loc", "IS", "info", "or", "state", "iss", "http", "ios", "ori", "nis", "ir", "out", "iris", "ais", "abs", "x", "fs", "api", "serv", "zip", "series", "are", "it", "ops", "vs", "ss", "as", "js", "si", "ps", "ms", "web"], "os": ["auto", "us", "oos", "iso", "pos", "oss", "ose", "i", "bs", "s", "oid", "otes", "ol", "ors", "ens", "ros", "aos", "es", "conn", "ks", "los", "boot", "or", "obs", "cos", "ios", "ori", "http", "oses", "io", "ob", "ds", "oa", "nos", "OS", "ais", "osi", "ot", "o", "opens", "des", "ans", "oS", "oi", "so", "ops", "vs", "bos", "ss", "as", "ps", "Os", "outs", "oes"], "url": ["image", "ball", "blog", "client", "connect", "sl", "i", "socket", "use", "proxy", "user", "ls", "lc", "server", "conn", "open", "or", "http", "li", "URL", "path", "io", "resource", "ssl", "link", "f", "Url", "o", "lib", "base", "channel", "zip", "control", "b", "log", "ll", "l", "string", "web", "uri", "source", "config", "c"], "connection": ["job", "db", "client", "connect", "union", "creator", "cond", "i", "socket", "relation", "use", "proxy", "context", "lc", "ci", "directory", "handler", "server", "conn", "loc", "open", "or", "bc", "http", "response", "URL", "io", "out", "con", "connected", "channel", "control", "b", "database", "controller", " Connection", "document", "l", "ion", "Connection", "uri", "config", "c"]}}
{"id1": "12034046", "id2": "17974661", "code1": "    private InputStream openRemoteStream(String remoteURL, String pathSuffix) {\n        URL url;\n        InputStream in = null;\n        try {\n            url = new URL(remoteURL + pathSuffix);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            in = connection.getInputStream();\n        } catch (Exception e) {\n        }\n        return in;\n    }\n", "code2": "    public boolean requestServerModifications(UUID sessionId, OutputStream out) throws SynchronizationException {\n        HttpClient client = new SSLHttpClient();\n        StringBuilder builder = new StringBuilder(url).append(\"?\" + SESSION_PARAM + \"=\" + sessionId).append(\"&\" + CMD_PARAM + \"=\" + CMD_SERVERMODIF);\n        HttpGet method = httpGetMethod(builder.toString());\n        try {\n            HttpResponse response = client.execute(method);\n            Header header = response.getFirstHeader(HEADER_NAME);\n            if (header != null && HEADER_VALUE.equals(header.getValue())) {\n                int code = response.getStatusLine().getStatusCode();\n                if (code == HttpStatus.SC_OK) {\n                    long expectedLength = response.getEntity().getContentLength();\n                    InputStream is = response.getEntity().getContent();\n                    FileUtils.writeInFile(is, out, expectedLength);\n                    return true;\n                } else {\n                    throw new SynchronizationException(\"Command 'receive' : HTTP error code returned.\" + code, SynchronizationException.ERROR_RECEIVE);\n                }\n            } else {\n                throw new SynchronizationException(\"HTTP header is invalid\", SynchronizationException.ERROR_RECEIVE);\n            }\n        } catch (Exception e) {\n            throw new SynchronizationException(\"Command 'receive' -> \", e, SynchronizationException.ERROR_RECEIVE);\n        }\n    }\n", "label": 0, "substitutes": {"openRemoteStream": ["createRemoteURL", "openExternalURL", "openLocalFile", "createremoteChannel", "openLocalStream", "openremoteChannel", "createremoteURL", "openExternalFile", "createRemoteFile", "createremoteStream", "createremoteFile", "openExternalChannel", "openRemoteChannel", "createRemoteStream", "openremoteStream", "createRemoteChannel", "openremoteFile", "openLocalChannel", "openLocalURL", "openRemoteFile", "openRemoteURL", "openExternalStream", "openremoteURL"], "remoteURL": ["RemoteAddress", "httpPath", " remotePath", "httpAddress", "RemoteURL", "RemoteUrl", "remoteUrl", "httpURL", "httpUrl", "localURL", " remoteURI", " remoteUrl", "localUrl", "RemoteURI", " remoteAddress", "RemotePath", "localURI", "remotePath", "remoteURI", "remoteAddress", "localPath"], "pathSuffix": ["pathSsuffix", "pathPufffix", "pathSuffixed", "pathPsuffIX", "pathPsuffixed", "pathPuffix", "pathSixIX", "pathSufffix", "pathSufIX", "pathSufix", "pathSufixed", "pathPsuffix", "pathSsuffIX", "pathPuffIX", "pathPuffixed", "pathSixix", "pathSixixed", "pathSsuffixed", "pathSuffIX", "pathSsufffix", "pathSixfix", "pathPsufffix"], "url": ["image", "ball", "blog", "client", "sl", "socket", "feed", "user", "bb", "e", "page", "server", "address", "open", "loc", "conn", "bc", "http", "location", "URL", "resource", "path", "li", "ob", "ssl", "out", "manager", "file", "build", "link", "f", "Url", "this", "api", "base", "zip", "log", "b", "org", "rel", "ll", "l", "remote", "string", "web", "ur", "uri", "source", "config", "www"], "in": ["r", "m", "pin", "ic", "inn", "stream", "gin", "isin", "i", "is", "socket", "zin", "cin", "input", "tin", "arin", "din", "conn", "inner", "path", "index", "resource", "nin", "out", "ini", "con", "rin", "into", "fc", "part", "min", "f", "serv", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "again", "win", "source", "c", "inc"], "connection": ["client", "connect", "n", "i", "socket", "object", "relation", "proxy", "character", "instance", "e", "environment", "section", "handler", "server", "conn", "open", "info", "bc", "response", "resource", "io", "out", "con", "director", "connected", "channel", "wrapper", "control", "b", "database", "number", " Connection", "application", "l", "reader", "communication", "Connection", "uri", "source", "config", "c"]}}
{"id1": "14819747", "id2": "3514286", "code1": "    public static void main(final String args[]) {\n        if (args.length < 2 || (args.length == 3 && !\"-d\".equals(args[0]))) {\n            System.out.println(\"Usage: AdapterGenerator [Options] <PrologFile> <ClassPath>\");\n            System.out.println(\"       where the framework is the first element in the class path\");\n            System.out.println(\"Options: -d Enables the generation of debug output\");\n            return;\n        }\n        boolean debug = args.length == 3;\n        File prologFile = new File(debug ? args[1] : args[0]);\n        if (!prologFile.isFile()) {\n            System.out.println(\"The given file does not exist.\");\n            return;\n        }\n        File targetFile = new File(prologFile.getParentFile(), prologFile.getName().substring(0, prologFile.getName().lastIndexOf(\".\")) + \".jar\");\n        String source;\n        try {\n            source = FileUtils.readFileToString(prologFile);\n        } catch (IOException ex) {\n            System.out.println(\"Error reading file: \" + ex.getMessage());\n            return;\n        }\n        Parser myParser = new PrologParserImpl();\n        PrologProgram myProgram;\n        try {\n            myProgram = (PrologProgram) myParser.parse(source);\n        } catch (Exception ex) {\n            System.out.println(\"Could not parse file: \" + ex.getMessage());\n            return;\n        }\n        try {\n            FactVisitor myVisitor = new FactVisitor();\n            myVisitor.visit(myProgram);\n            Map<String, TypeGenerationInfo> adapterLayer = myVisitor.getAdapterLayer();\n            if (adapterLayer.size() == 0) {\n                System.out.println(\"No adapters to generate, \" + \"did you forget to run the comeback rules?\");\n                return;\n            }\n            URLClassLoader classLoader = createClassLoaderFromClassPath(debug ? args[2] : args[1]);\n            ClassWriter adapterWriter = new ClassWriter(new JarEntryWriter(targetFile));\n            AdapterAnnotationGenerator annotationGenerator = new AdapterAnnotationGenerator();\n            Type annotationType = Type.getObjectType(\"net/sourceforge/comeback/Adapter\");\n            adapterWriter.writeClass(annotationType.getClassName(), annotationGenerator.createAnnotation(annotationType));\n            AdapterLookupGenerator lookupWriter = new AdapterLookupGenerator(Type.getObjectType(\"net/sourceforge/comeback/Adapters\"), annotationType);\n            GenerationContext context = new GenerationContext(adapterLayer, classLoader, annotationType, lookupWriter, adapterWriter);\n            context.setGenerateDebugOutput(debug);\n            Iterator<TypeGenerationInfo> iterator = adapterLayer.values().iterator();\n            while (iterator.hasNext()) {\n                TypeGenerationInfo info = iterator.next();\n                context.generateAdapter(info);\n            }\n            ByteArrayOutputStream serialized = new ByteArrayOutputStream();\n            ObjectOutputStream out = new ObjectOutputStream(serialized);\n            out.writeObject(adapterLayer);\n            out.close();\n            adapterWriter.writeResource(\"net/sourceforge/comeback/adapterlayer.ser\", serialized.toByteArray());\n            String[] sharedClassesPrefixes = new String[2];\n            Assembler assembler = new Assembler(adapterWriter);\n            PatternClassFilter filter = new PatternClassFilter();\n            URL url = Main.class.getResource(\"/\" + Main.class.getName().replace('.', '/') + \".class\");\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[0] = assembler.assemble(connection.getJarFile(), filter);\n            filter = new PatternClassFilter();\n            url = Type.class.getResource(\"/\" + Type.class.getName().replace('.', '/') + \".class\");\n            connection = (JarURLConnection) url.openConnection();\n            sharedClassesPrefixes[1] = assembler.assemble(connection.getJarFile(), filter);\n            String tmp = debug ? args[2] : args[1];\n            adapterWriter.writeClass(lookupWriter.getType().getClassName(), lookupWriter.createAdapterLookup(adapterLayer.values(), tmp.substring(tmp.lastIndexOf(File.pathSeparator) + 1), sharedClassesPrefixes));\n            adapterWriter.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            return;\n        }\n    }\n", "code2": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"debug": ["db", "enabled", "error", " DEBUG", "progress", "details", "console", "display", "help", "develop", "trace", "print", "comment", "bug", "ger", "cache", "reg", "module", " debugger", "show", "development", "real", "date", "file", "root", "build", "store", "active", "depth", "production", "die", "doc", "err", "log", " Debug", "test", "tag", "status", "admin", "quiet", "export", "github", " debugging", "plugin", "remote", "enable", "DEBUG", "play", "dev", "dump", "Debug", "config"], "prologFile": ["PrologFile", "prologfile", " prologfile", "proLogfile", "propathDir", " proLogFile", "ProLogString", "propathSourceFile", "probaseFiles", "proversionPath", "proversionSourceFile", "roLogSource", "ProLogfile", " problogfile", "prologFull", " prologFiles", "rologfile", "defblogDir", "proconfigfile", "proconfigFile", "proversionFILE", " prologHeader", "procatfile", "defblogSourceFile", "prologString", "prollFile", "deflogPath", "proLogStream", "prologHeader", " problogSourceFile", "proLogString", "propathFile", "defLogSourceFile", "rologSource", "proflowFile", "rologFile", "proflowSourceFile", "problogSourceFile", " prologFull", "problogDir", "proconfigSourceFile", "prollPath", "proversionFile", "prolexFile", "prologDir", "deflogFile", "rologPath", "proLogFull", "prolexfile", "prologFiles", "ProLogFile", "proconfigPath", "probaseFile", "proLogFile", "deflogfile", "Prologfile", "PrologString", "prolangFile", "proflowDir", " prologStream", " prologSourceFile", "proLogPath", "proflowfile", "proLogFILE", "proLogFiles", "prolangFull", "prologSourceFile", " proLogFiles", "defLogFILE", "roLogPath", "prologSource", "prolangSourceFile", "defblogfile", "deflogDir", "propathfile", "probaseHeader", "ProLogModule", "proconfigFILE", "deflogFILE", "roLogFile", "prolexString", "defblogFile", "prolangfile", " problogFile", "probaseStream", "proLogSourceFile", "prologFILE", "prologStream", "proconfigModule", "PrologModule", "prologModule", "prollSource", "defLogPath", "deflogSourceFile", "roLogfile", "problogHeader", "problogFiles", "proLogModule", "problogFile", "prologPath", "procatFile", "prolexModule", "problogStream", " proLogHeader", "proLogHeader", "defLogFile", "proLogSource", "problogfile", "procatSource", "proconfigString", " proLogStream", "procatPath", "prollfile", " problogFull", "problogFull"], "targetFile": ["targetDir", "targetDirectory", "outputPath", "outputFile", "sourcefile", "outputDir", "targetPath", "targetfile", " targetfile", "sourceFile", "sourcePath", " targetDirectory", "sourceDirectory", "targetFiles", "TargetDirectory", "sourceDir", "Targetfile", "TargetDir", " targetFiles", "TargetPath", "outputfile", "TargetFiles", "TargetFile", "sourceFiles"], "source": ["position", "template", "buffer", "service", "term", "sl", "src", "i", "class", "view", "comment", "use", "scope", "input", "slice", "proxy", "parse", "id", "json", "stack", "target", "result", "format", "content", "message", "resource", "description", "file", "Source", "str", "options", "unit", "model", "session", "data", "type", "zip", "SOURCE", "text", "language", "name", "style", "body", "string", "uri", "ource", "config"], "myParser": [" myReader", "yourParser", "MyJar", " myJar", "MyParser", "yourJar", "yourProgram", "myJar", "MyProgram", "myReader", "yourReader", "MyReader"], "myProgram": ["yourMath", "yourPlan", "MYprogram", "MyParser", "MYParser", "yourProgram", "myMath", " myprogram", "yourprogram", "MyProgram", "theParser", " myPlan", "theMath", "MyPlan", "theProgram", "myPlan", "Myprogram", " myMath", "yourParser", "theprogram", "MYProgram", "myprogram"], "myVisitor": [" myvisIT", "myVisitors", "MyVisulator", "mySignitors", "myVisIT", " myvisitors", "myDesignIT", "myDesignit", "myvisit", "myExitors", "myVISitable", "myVisulator", "myExiter", " myVisitable", " myvisit", "myAuditable", "myVisitit", "myvisiter", "Myvisitors", "myAudit", "MyVisiter", "myvisitor", "myVisititor", "myvisitable", "mySignitor", "myVisiter", "MyVisitor", "myvisulator", "myVISitor", "myDesignitable", "myvisIT", "myVisititable", "mySignulator", "myAuditor", "MyVisitors", " myvisitable", "myDesignitor", " myVisitors", "Myvisiter", " myVisIT", "myAuditors", "myExitor", "Myvisitor", "mySigniter", "myExulator", "Myvisulator", "myVisititors", "myVISit", " myvisitor", "myVisitable", "myVisit", "myvisitors", " myVisit", "myVISIT"], "adapterLayer": ["adviceFactory", "acaptersFactory", "acapterFactory", "acapterContainer", "adapterFactory", "acapterLayer", "acapterBuffer", "acaptersBuffer", "adptionInfo", "adaptersContainer", "adviceLanguage", "adviceInfo", "admissionContainer", "admissionLanguage", "adptionBuffer", "adviceLayer", "acapterInfo", "adviceBuffer", "adapterInfo", "admissionLayer", "adaptersLanguage", "adviceContainer", "adapterBuffer", "acaptersInfo", "acaptersLanguage", "adapterLanguage", "adaptersFactory", "acaptersLayer", "adaptersLayer", "adapterContainer", "acapterLanguage", "adaptersInfo", "adaptersBuffer", "acaptersContainer", "adptionFactory", "adptionLayer"], "classLoader": ["classPath", "ClassPath", "staticDir", "ClassDir", "classDir", "staticLoader", "classloader", " classDir", "ClassLoader", "staticPath", "staticloader", " classPath", " classloader", "Classloader"], "adapterWriter": ["adAdapterReader", "adapterReader", "attapterWriter", "adAdapterwriter", "adaptersReader", "adapterWrite", "attapterwriter", "adapterwriter", "adapterswriter", "adaptersWriter", "adaptersWrite", "admissionWrite", "attaptersReader", "attaptersWriter", "attapterswriter", "adAdapterWriter", "admissionReader", "attapterReader", "attaptersWrite", "adAdapterWrite", "admissionWriter", "admissionwriter", "attapterWrite"], "annotationGenerator": ["annotationgenators", "annnotationGenoder", "annotationGeneroder", "annotationGcer", "annotationGenerators", "annotationgenator", "annotationGator", "annotationgenoder", "annotationGenoder", "annnotationGenerators", "annotationGenator", "annnotationGenerator", "annnotationGenator", "annnotationGeneroder", "annotationGoder", "annnotationGenercer", "annotationGenercer", "annotationGencer", "annnotationGencer", "annotationgencer", "annnotationGenators", "annotationGenators", "annotationGators"], "out": ["Out", "error", "in", "sync", "obj", "query", "n", "flow", "output", "pre", "print", "chain", "user", "parent", "copy", "cli", "page", "server", "cache", "conn", "group", "diff", "state", "code", "array", "io", "line", "raw", "post", "down", "store", "prefix", "temp", "err", "log", "bar", "v", "net", "OUT", "again", "list", "point", "sys", "outer", "outs", "lock", "gen", "cmd", "dump", "up"]}}
{"id1": "9096314", "id2": "20210699", "code1": "    private void handleNodeLostService(long eventID, long nodeID, String ipAddr, long serviceID, String eventTime) {\n        Category log = ThreadCategory.getInstance(OutageWriter.class);\n        if (eventID == -1 || nodeID == -1 || ipAddr == null || serviceID == -1) {\n            log.warn(EventConstants.NODE_REGAINED_SERVICE_EVENT_UEI + \" ignored - info incomplete - eventid/nodeid/ip/svc: \" + eventID + \"/\" + nodeID + \"/\" + ipAddr + \"/\" + serviceID);\n            return;\n        }\n        Connection dbConn = null;\n        try {\n            dbConn = DatabaseConnectionFactory.getInstance().getConnection();\n            if (openOutageExists(dbConn, nodeID, ipAddr, serviceID)) {\n                log.warn(\"\\'\" + EventConstants.NODE_LOST_SERVICE_EVENT_UEI + \"\\' for \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" ignored - table already  has an open record \");\n            } else {\n                PreparedStatement getNextOutageIdStmt = dbConn.prepareStatement(OutageManagerConfigFactory.getInstance().getGetNextOutageID());\n                long outageID = -1;\n                ResultSet seqRS = getNextOutageIdStmt.executeQuery();\n                if (seqRS.next()) {\n                    outageID = seqRS.getLong(1);\n                }\n                seqRS.close();\n                try {\n                    dbConn.setAutoCommit(false);\n                } catch (SQLException sqle) {\n                    log.error(\"Unable to change database AutoCommit to FALSE\", sqle);\n                    return;\n                }\n                PreparedStatement newOutageWriter = null;\n                if (log.isDebugEnabled()) log.debug(\"handleNodeLostService: creating new outage entry...\");\n                newOutageWriter = dbConn.prepareStatement(OutageConstants.DB_INS_NEW_OUTAGE);\n                newOutageWriter.setLong(1, outageID);\n                newOutageWriter.setLong(2, eventID);\n                newOutageWriter.setLong(3, nodeID);\n                newOutageWriter.setString(4, ipAddr);\n                newOutageWriter.setLong(5, serviceID);\n                newOutageWriter.setTimestamp(6, convertEventTimeIntoTimestamp(eventTime));\n                newOutageWriter.executeUpdate();\n                newOutageWriter.close();\n                try {\n                    dbConn.commit();\n                    if (log.isDebugEnabled()) log.debug(\"nodeLostService : \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID + \" recorded in DB\");\n                } catch (SQLException se) {\n                    log.warn(\"Rolling back transaction, nodeLostService could not be recorded  for nodeid/ipAddr/service: \" + nodeID + \"/\" + ipAddr + \"/\" + serviceID, se);\n                    try {\n                        dbConn.rollback();\n                    } catch (SQLException sqle) {\n                        log.warn(\"SQL exception during rollback, reason\", sqle);\n                    }\n                }\n            }\n        } catch (SQLException sqle) {\n            log.warn(\"SQL exception while handling \\'nodeLostService\\'\", sqle);\n        } finally {\n            try {\n                if (dbConn != null) dbConn.close();\n            } catch (SQLException e) {\n                log.warn(\"Exception closing JDBC connection\", e);\n            }\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"handleNodeLostService": ["handlenodeLostServer", "handleNodeUnknownFunction", "handlenodelostServer", "handleNodeErrorServices", "handlenodelostService", "handleNodeLostServices", "handleNodelostFunction", "handleNodelostServer", "handleNodelostService", "handleNodeUnknownServer", "handleNodeLostServer", "handlenodelostServices", "handleNodelostServices", "handlenodelostFunction", "handleNodeErrorFunction", "handleNodeUnknownServices", "handleNodeUnknownService", "handleNodeErrorServer", "handleNodeErrorService", "handlenodeLostServices", "handlenodeLostFunction", "handleNodeLostFunction", "handlenodeLostService"], "eventID": ["EventID", "sessionId", " eventType", " eventId", "EventId", "nodeType", "resourceID", "serviceId", "EventType", "eventName", "resourceId", "EventName", "eventType", "nodeName", "serviceName", "sessionName", "documentID", "nodeid", "nodeId", " eventName", "eventId", "resourceid", "resourceName", "documentName", "sessionID", " eventid", "documentId", "eventid"], "nodeID": [" nodeInfo", "eventInfo", "objectId", "eventURL", "serviceId", "nodeInfo", "networkID", "resourceID", "resourceId", "eventName", "networkInfo", "NodeID", "nodeName", "serviceName", "networkId", " nodeURL", "nodeURL", "serviceid", " nodeid", "NodeURL", "nodeid", "nodeId", "eventId", "objectid", "resourceid", "resourceName", " nodeId", " nodeName", "NodeId", "Nodeid", "eventid", "objectName", "objectID"], "ipAddr": ["ipAddresser", "ipAttress", "ipaddl", " ipAddrer", "apiAddp", " ipAtto", "ipAddl", "ipAddressr", "apiAttri", " ipAddress", " ipChrs", "ipAddrer", "ipAddressri", "ipAtter", "epaddr", " ipChrer", "ipAddo", "ipChl", " ipAddrs", " ipChri", "ipadder", "ipaddress", "ipaddo", " ipAddri", "apiAddri", "ipChr", "epaddl", "ipAttr", "ipaddr", "ipChri", "epAddl", "ipaddri", "epaddrer", " ipAddo", "apiAttp", "epAddrer", "ipChp", "apiAttr", "ipAddp", "ipAddressrs", "ipaddrer", "ipChrer", " ipAtter", " ipAttrs", "ipAttrs", "ipAttrer", "ipAtto", "ipAttp", "epAddr", "ipAttri", "ipaddrs", "epAddrs", "ipAdder", "apiAddr", "apiAttrs", "ipAddresso", "epaddrs", "ipAddressl", " ipAttr", "ipAddressrer", "ipAddress", "apiAddrs", "ipChrs", " ipChr", "ipAddressp", " ipAdder", "ipAddri", "ipAddrs"], "serviceID": [" serviceUID", "siteID", "imageID", "serviceIDs", "roleid", " serviceIP", "siteId", "serviceType", "imageUID", " serviceName", "networkName", "serviceId", "networkID", "ServiceName", "siteid", " serviceid", "eventName", "featureId", "featureID", "serviceIP", "roleIP", "eventType", "imageId", "ServiceIDs", " serviceIDs", "networkId", "serviceName", "networkid", "serviceUID", "ServiceID", "serviceid", "ServiceId", "eventIDs", "eventId", "siteIP", "roleId", "eventIP", "roleID", "featureUID", "ServiceType", "ServiceIP", "eventid", " serviceId", " serviceType"], "eventTime": ["serverTime", "EventInfo", "eventtime", "eventName", "EventName", " eventInfo", "eventInfo", "serverName", " eventtime", "EventTime", " eventName", "servertime", "Eventtime", "serverInfo"], "log": ["error", "entry", "key", "cell", "ger", "reg", "info", "http", "Log", "en", "base", "w", "tag", "get", "blog", "db", "sec", "full", "feed", "proxy", "user", "bug", "cache", "path", "pool", "thread", "lex", "plug", "net", "stop", "l", "lock", "event", "job", "where", "writer", "level", "stat", "host", "class", "output", "use", "guard", "pg", "cat", "port", "low", "url", "pe", "put", "cl", "it", "contract", "LOG", "og", "sign", "pl", "c", "lo", "tool", "write", "or", "exp", "debug", "crit", "ge", "f", "model", "type", "call", "loop", "gen", "config"], "dbConn": ["dbColl", "DbConn", "databaseDr", "logColl", " dbColl", "sqlSession", "dbCtrl", "databaseConn", "Dbconn", "sqlConn", "dbConnect", "dbCt", "libCon", " dbCt", "dbCon", "DbSession", "DbDr", "sqlNC", "dbSession", "DbCon", "DbCtrl", "dbCo", "webCt", "dbconn", " dbSession", " dbNC", "sqlCo", "dbCs", "databaseconn", "sqlCt", " dbConnect", "logConnect", " dbDr", "DBConnect", "libCt", "libconn", "DbColl", "DbConnection", "DbCt", "DbCs", "dbConnection", "DbConnect", "dbDr", "databaseConnection", " dbCs", " dbCtrl", "DBConn", "logCtrl", " dbConnection", "webNC", "DbCo", "sqlCtrl", " dbCon", "DBCt", " dbCo", " dbconn", "sqlconn", "DBCs", "logConn", "dbNC", "webConn", "webCtrl", "libConn"], "getNextOutageIdStmt": ["getNextOutageIdSMT", "getNextOutageIdCnt", "getNextOutageIdRb", "getNextOutageIdCb", "getNextOutageIdCmt", "getNextOutageIdSr", "getNextOutageIdRMT", "getNextOutageIDSmt", "getNextOutageIdStMT", "getNextOutageIdStr", "getNextOutageIDStb", "getNextOutageIDStr", "getNextOutageIdstr", "getNextOutageIDSb", "getNextOutageIDStnt", "getNextOutageIdSnt", "getNextOutageIdCr", "getNextOutageIDStMT", "getNextOutageIdSb", "getNextOutageIDSr", "getNextOutageIdstnt", "getNextOutageIdRr", "getNextOutageIDSMT", "getNextOutageIdStb", "getNextOutageIdSmt", "getNextOutageIDSnt", "getNextOutageIdstmt", "getNextOutageIdCMT", "getNextOutageIdRmt", "getNextOutageIdstMT", "getNextOutageIdStnt", "getNextOutageIDStmt"], "outageID": ["inrageURL", "inageURL", "outrageURL", "outageId", "outagingSecret", "outflowId", "outAGEUID", "outAGEURL", "inrageID", "OutrageSecret", "OutageId", "outageUID", "outagingID", "inageId", "inrageId", "outrageSecret", "outAGEID", "outagementID", "outrageUID", "outagementId", "outAGESecret", "outageHandle", "outageSecret", "outagingId", "outagementHandle", "outAGEName", "outrageName", "OutrageHandle", "OutrageID", "inrageUID", "outissueURL", "outagementName", "outissueUID", "OutageName", "OutageSecret", "outissueID", "outrageID", "inageID", "outissueId", "OutageID", "outageURL", "OutrageId", "outAGEId", "OutrageName", "outrageId", "inageUID", "outrageHandle", "outflowHandle", "outageName", "outagingName", "outflowName", "OutageHandle", "outflowID"], "seqRS": ["eqRS", "seqSR", "eqRT", " seqMR", "reqTS", "eqRs", "seqRL", " sequenceRS", "reqRT", " seqRT", "sequTS", "invSR", "seqRT", " sequenceRT", "reqRR", "sequenceRs", " seqTS", " seqRL", "reqRs", "sequRC", "colRT", "invrs", "reqRC", "reqRL", "sequRS", "reqRS", " sequenceRC", "structrs", "sqRS", "eqRR", "structRs", "sequenceRS", "sequenceSR", "invRs", "invRS", "seqrs", "structSR", " sequenceMR", "colRs", "sqRC", "sequRL", "sequencers", "seqMR", "colRR", "colRS", "structRS", "sqMR", "seqRC", "sqRT", "seqRR", "seqTS", "seqRs", " seqRC"], "newOutageWriter": ["newOutageWrit", "newOutagementRW", "newInflowWrit", "newOutflowRW", "newExageWrite", "newOutflowWriter", "newOutlineWrite", "newoutageWrite", "newOutpointReader", "newOutpaceReader", "newoutagewriter", "newoutureWrite", "newOutrageWrit", "newoutureReader", "newOutflowInfo", "newOutartRW", "newOutpacewriter", "newOutpaceWriter", "newOutflowWrite", "newOutagementWrit", "newOutflowReader", "newExagewriter", "newOutissueWriter", "newInflowWrite", "newOutureWriter", "newOutureInfo", "newOutagewriter", "newOutagementWrite", "newoutageInfo", "newOutrageWrite", "newOutissuewriter", "newOutrageRW", "newOutflowwriter", "newouturewriter", "newoutureWriter", "newInageWrit", "newInageWrite", "newOutflowWrit", "newOuturewriter", "newOutlineWriter", "newoutageReader", "newInflowRW", "newOutageReader", "newoutureInfo", "newOutagementWriter", "newoutureRW", "newInageRW", "newOutureWrite", "newExlinewriter", "newOutartWriter", "newOutureReader", "newExageWriter", "newInageWriter", "newOutageRW", "newExageReader", "newOutissueReader", "newExlineReader", "newOutartInfo", "newOutageWrite", "newInflowWriter", "newExlineWriter", "newOutlineReader", "newOutpointRW", "newOutpointWrite", "newOutartWrite", "newoutageRW", "newOutrageWriter", "newoutageWriter", "newOutpointWriter", "newOutissueWrite", "newExlineWrite", "newOutureRW", "newOutageInfo", "newOutlinewriter", "newOutpaceRW"]}}
{"id1": "9872346", "id2": "20310134", "code1": "    public static synchronized Document readRemoteDocument(URL url, boolean validate) throws IOException, SAXParseException {\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \")\");\n        Document document = null;\n        try {\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setNamespaceAware(true);\n            factory.setCoalescing(true);\n            HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n            connection.setDefaultUseCaches(false);\n            connection.setUseCaches(false);\n            connection.setRequestProperty(\"User-Agent\", \"eXchaNGeR/\" + System.getProperty(\"xngr.version\") + \" (http://xngr.org/)\");\n            connection.connect();\n            InputStream stream = connection.getInputStream();\n            document = factory.newDocumentBuilder().parse(stream);\n            stream.close();\n            connection.disconnect();\n        } catch (SAXException e) {\n            if (e instanceof SAXParseException) {\n                throw (SAXParseException) e;\n            }\n        } catch (ParserConfigurationException e) {\n            e.printStackTrace();\n        }\n        if (DEBUG) System.out.println(\"DocumentUtilities.readDocument( \" + url + \") [\" + document + \"]\");\n        return document;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"readRemoteDocument": ["readRemoteDocuments", "loadRemoteDocument", "readRemotedocument", "loadRemoteDocuments", "loadLocalDocuments", "readLocalDocuments", "readLocalDocument", "readExternalDocuments", "loadRemotedocument", "readServerDocuments", "readExternaldocument", "readServerDocument", "loadLocaldocument", "loadLocalDocument", "readExternalDocument", "readLocaldocument", "readServerdocument"], "url": ["image", "position", "client", "service", "email", "sl", "entry", "rl", "host", "socket", "load", "feed", "user", "layer", "version", "page", "lc", "server", "address", "loc", "filename", "location", "http", "URL", "path", "resource", "xml", "ssl", "file", "link", "store", "f", "Url", "channel", "base", "download", "org", "ll", " URL", "name", "l", "remote", "string", "ur", "uri", "source", "config", "www", "username"], "validate": ["validation", "verating", " validating", "Valating", " validation", "verate", "Valation", "Valate", " validated", "verated", "validated", "veration", "validating", "Valated"], "document": ["request", "image", "video", "design", "service", "Document", "output", "object", "view", "dict", " documentation", "parent", "office", "page", "expression", "port", "metadata", "valid", "ocument", "result", "media", "content", "container", "response", "message", "resource", "index", "word", "graph", "xml", "location", "df", "value", "function", "f", "null", "doc", "model", "session", "data", "system", "database", "collection", "application", "language", "record", "text", "node", "project", "material", "source", "degree"], "factory": ["sfactory", "sfluent", "infiller", "affault", "huture", "affixture", "fsolver", "Folver", "dactory", "affactory", "efiller", "pluent", "future", "hade", "piller", "infuture", "dade", "fsiller", "infade", "duture", "sfixture", "FFactory", "fsactory", "efactory", "infactory", "hiller", " filler", "efluent", "diller", "fade", "fFactory", "fsFactory", "bluent", "fixture", "Factory", "biller", " folver", "pault", "pixture", "hactory", "Filler", "bactory", " fFactory", "folver", "filler", "sfault", "bixture", "affluent", "pactory", "fluent", "fault", "efixture"], "connection": ["position", "image", "error", "client", "connect", "union", "service", "writer", "creator", "relation", "socket", "default", "use", "proxy", "context", "common", "user", "character", "version", "section", "handler", "port", "cache", "server", "conn", "open", "info", "http", "container", "response", "resource", "index", "io", "translation", "out", "con", "function", "link", "connected", "channel", "wrapper", "session", "builder", "system", "database", "collection", "application", "driver", "password", "reader", "communication", "Connection", "uri", "current", "config", "c", "condition"], "stream": ["video", "image", "sc", "client", "writer", "sw", "sl", "upload", "entry", "output", "form", "object", "view", "feed", "context", "load", "input", "version", "handler", "server", "coll", "stack", "per", "result", "or", "media", "container", "response", "resource", "path", "io", "translation", "out", "raw", "row", "file", "f", "channel", "model", "data", "system", "loader", "v", "trans", "transform", "Stream", "reader", "string", "body", "cont", "source"]}}
{"id1": "2834524", "id2": "8430178", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    public static void copyFile(String source_name, String dest_name) throws IOException {\n        source_name = Shell.getUtils().constructPath(source_name);\n        File source_file = new File(source_name);\n        dest_name = Shell.getUtils().constructPath(dest_name);\n        File destination_file = new File(dest_name);\n        FileInputStream source = null;\n        FileOutputStream destination = null;\n        byte[] buffer;\n        int bytes_read;\n        try {\n            if (!source_file.exists() || !source_file.isFile()) throw new FileCopyException(\"cp: no such source file: \" + source_name);\n            if (!source_file.canRead()) throw new FileCopyException(\"cp: source file \" + \"is unreadable: \" + source_name);\n            if (destination_file.exists()) {\n                if (destination_file.isFile()) {\n                    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n                    String response;\n                    if (!destination_file.canWrite()) throw new FileCopyException(\"cp: destination \" + \"file is unwriteable: \" + dest_name);\n                    System.out.print(\"cp: file \" + dest_name + \" already exists. Overwrite it ? (Y/N): \");\n                    System.out.flush();\n                    response = in.readLine();\n                    if (!response.equals(\"Y\") && !response.equals(\"y\")) throw new FileCopyException(\"cp: copy cancelled.\");\n                } else throw new FileCopyException(\"cp: destination \" + \"is not a file: \" + dest_name);\n            } else {\n                File parentdir = parent(destination_file);\n                if (!parentdir.exists()) throw new FileCopyException(\"cp: destination \" + \"directory doesn't exist: \" + dest_name);\n                if (!parentdir.canWrite()) throw new FileCopyException(\"cp: destination \" + \"directory is unwriteable: \" + dest_name);\n            }\n            source = new FileInputStream(source_file);\n            destination = new FileOutputStream(destination_file);\n            buffer = new byte[1024];\n            int size = (new Long((source_file.length() / 1024) / 50)).intValue();\n            int c = 1;\n            int written = 0;\n            System.out.print(\"cp: \");\n            while (true) {\n                if (written < 50) {\n                    if ((c - 1) == size && size != 0) {\n                        System.out.print(\"#\");\n                        c = 1;\n                        written++;\n                    } else if (size == 0) {\n                        int j = 1;\n                        if (c > 1) j = (50 / c) - 50; else j = 50 / c;\n                        for (int i = 0; i < j; i++) System.out.print(\"#\");\n                        written += j;\n                    }\n                }\n                bytes_read = source.read(buffer);\n                if (bytes_read == -1) break;\n                destination.write(buffer, 0, bytes_read);\n                c++;\n            }\n            System.out.println();\n        } finally {\n            if (source != null) try {\n                source.close();\n            } catch (IOException e) {\n            }\n            if (destination != null) try {\n                destination.close();\n            } catch (IOException e) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"write": ["process", "writer", "save", " rewrite", "sync", "all", "output", "delete", "rite", "load", "parse", "after", "println", "check", "run", "open", "handle", "out", "file", "post", "end", "Write", "update", "zip", "download", "append", "flush", "create"], "jarOut": ["garout", "jarIn", "garIn", "sheetOutput", " jarout", "jarCatalog", "javaOut", " jarCatalog", "tarOutput", "javaIn", "serOUT", "jarOUT", "JarOut", "serout", "jarout", " jarOutput", "JarCatalog", "javaOutput", "garOut", "tarOUT", " jarIn", "jarOutput", "sheetIn", "tarOut", "javaOUT", "sheetOUT", "serIn", "javaout", " jarOUT", "tarout", "sheetOut", "JarOutput", "javaCatalog", "garOUT", "Jarout", "JarIn", "serOut", "JarOUT"], "allEntries": [" allEntories", "allAddrys", "Allentrys", "AllEntry", "allentrs", "allEntrys", "allChries", "allentries", "AllEntrys", "allTries", "AllEntrs", "allTrys", "AllEntries", "allChrys", "allentry", "Allentrs", "allTry", "allenties", "allEntry", "allAddry", " allEnties", "allentrys", "allEnties", "allEntrs", " allEntrys", "allentories", "allTrs", "allAddries", "Allentries", "allChies", "Allentry", "allChories", "allEntories"], "iterator": ["former", "next", "Iterator", "consider", "size", "creator", "query", "ie", "entry", "stream", "Iter", "eni", "i", "order", "river", "init", "slice", "basic", "instance", "section", "handler", "or", "division", "oper", "inst", "inner", "gener", "later", "keeper", "starter", "step", "now", "started", "start", "iter", "end", "engine", "ator", "set", "ators", "loader", "pie", "er", "inter", "runner", "collection", "heid", "done", "running", "skip", "processor", "ter", "finder", "reader", "list", "parser", "loop", "filter", "outer", "cmp", "uri", "ski", "walker"], "jar": ["job", "image", "in", "entry", "tar", "java", "sheet", "parse", "pkg", "archive", "json", "cookie", "jam", "module", "ler", "container", "tab", "audio", "war", "zone", "pack", "Jar", "keeper", "ssl", "magic", "file", "bag", "start", "dir", "space", "url", "binary", "base", "zip", "bar", "er", "drop", "tag", "star", "record", "browser", "ar", "mag", "plugin", "style", "folder", "pod", "ser", "docker", "ski", "config", "jo"], "jarEntries": ["parseEntrs", "jarAires", "jarEnies", " jarEntories", "jarEries", "jarEntorts", "jarEntryrys", " jarEnires", "jarIntories", "jarErs", "parseEntries", "jarEntories", " jarEntires", "jarEntrys", " jarEnies", "parseErs", "jarAories", "jarEntryorts", "parseEntories", "jarTires", "jarEntryies", "jarEnries", "jarErries", "jarEntrs", "jarIntries", "JarEntorts", "JarEntrys", "parseEntriers", "jarTies", "jarTories", "jarEnties", " jarEnries", "jarEriers", "jarEories", "jarIntrs", "JarEnties", "jarAies", " jarEnories", "parseEries", "jarEntriers", "JarEntries", "jarIntriers", " jarEnties", "jarEnories", "parseEriers", "jarEntryries", "jarErorts", "jarEnires", "jarAries", "jarEntires", "parseEories", "jarTries", "jarErrys"], "o1": ["oeinf", " oOne", "oinf", "oaOne", "oe1", "O0", "op3", "oaone", "so1", "soOne", "po1", "oainf", "o11", "oOne", "Opart", " opart", " oinf", "oa91", "oa0", " o91", " o0", "so3", "op1", "o0", "oe11", " oone", "O1", "oeone", "o4", "o91", "oe91", "oa1", "O3", " o3", "oa11", "oepart", "oe3", "OOne", "o3", "oone", "opOne", "oa4", " o4", "po11", "O11", "opart", "po4", " o11"], "entryStream": ["EntrySteam", "entrystream", "entrySteam", "entryReader", "Entrystream", "connectionReader", "zipStream", " entrySteam", "zipString", " entrystream", " entryString", "connectionStream", "EntryString", "EntryStream", "inputSteam", " entryReader", "connectionSteam", "entryString", "inputReader", "zipstream", "zipSteam", "inputStream"]}}
{"id1": "7276377", "id2": "6756635", "code1": "    public static String checksum(URL url, String algorithm) {\n        MessageDigest messageDigest;\n        try {\n            messageDigest = MessageDigest.getInstance(algorithm);\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Could not create an instance of MessageDigest\", ex);\n        }\n        byte[] bytes = new byte[4 * 1024];\n        try {\n            InputStream in = null;\n            try {\n                in = url.openStream();\n                int nBytesRead = 0;\n                while ((nBytesRead = in.read(bytes)) > 0) {\n                    messageDigest.update(bytes, 0, nBytesRead);\n                }\n            } finally {\n                if (in != null) {\n                    in.close();\n                }\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not read message digest for: \" + url.toExternalForm() + \" using algorithm: \" + algorithm);\n        }\n        byte[] checksumValue = messageDigest.digest();\n        return digestAsString(checksumValue);\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"checksum": ["decumb", "cksums", "checksums", "ckssum", "decums", "cksumb", "cksum", " checkssum", " checksumb", "checkssum", "decum", " checksums", "checksumb", "decsum"], "url": ["image", "fr", "email", "service", "sl", "cert", "stream", "host", "src", "feed", "proxy", "user", "id", "server", "rule", "address", "loc", "or", "connection", "filename", "http", "location", "URL", "path", "resource", "ssl", "manager", "file", "str", "f", "Url", "base", "download", "gl", "loader", "ll", "text", "name", "l", "string", "href", "ur", "uri", "source", "config", "username"], "algorithm": ["malgebra", "algebra", "algo", "ALgebra", "Alignment", "exgo", "malignment", "Algebra", "Algorithm", " algorith", " alignment", " algo", "allgorithm", "allgo", "allgorith", "Algorith", "ALgo", "malgorith", " algebra", "ALgorith", "malgo", "alignment", "exgorithm", "allgebra", "malgorithm", "exgebra", "Algo", "exgorith", "algorith", "ALgorithm"], "messageDigest": ["messageRegator", "messageDester", "messageDigade", "messagediger", "messageMixpe", "messageDiger", "messageDigge", "messageDest", "MessageDest", "messageDigess", "messagedigester", "messageSignester", "messageDesignator", "messageDigester", "messageMixest", "messageDse", "messageSignge", "messageDge", "messageRegess", "MessageMixpe", "messageDesignester", "MessageDesignest", "MessageDester", "messageDade", "MessageDigest", "MessageSignester", "messagedigpe", "messageDesigness", "MessageDigess", "MessageDesignester", "MessageDigade", "messageDigpe", "MessageMixer", "messageDpe", "messagedigade", "messageMixer", "messagedigse", "messageSignest", "MessageMixest", "MessageDigse", "messagedigess", "MessageDigator", "messageDigator", "MessageDesignator", "messagedigge", "MessageSignest", "MessageDiger", "MessageMixester", "messageDer", "messageMixester", "messageDigse", "MessageDigge", "MessageDade", "MessageSignge", "MessageSignse", "MessageDse", "MessageDesigness", "messageDesignest", "messageSignse", "messagedigator", "messagedigest", "messageRegest", "messageRegester", "MessageDigpe", "MessageDigester"], "bytes": ["items", "vals", "os", "buffer", "words", "size", "ipes", "steps", "files", "loads", "limits", "bs", "units", "cells", "resses", "ls", "ips", "reads", "es", "lines", "gets", "objects", "boot", "seconds", "tes", "bps", "Bytes", "resources", "frames", "pieces", "classes", "bits", "pages", "ones", "zip", "blocks", "values", "errors", "eps", "rows", "bles", "vs", "parts", "outs"], "in": ["r", "fr", "m", "client", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "impl", "input", "version", "id", "ex", "din", "conn", "fe", "a", "inner", "nin", "ssl", "out", "ini", "con", "rin", "file", "kin", "min", "f", "serv", "login", "data", "ac", "err", "b", "token", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "gen", "win", "source", "c", "inc"], "nBytesRead": ["nPagesLength", " nBytesCount", "nFramesFound", "nFramesLength", "nByteFound", "nBytesLength", "nCharactersLength", "nBytesCount", "nBytesFound", "nWordsWritten", "nWordsRead", " nByteCount", " nByteLength", "nBytesLoad", "nPartsRead", " nBytesLoad", "nCharactersRead", " nBytesFound", " nByteFound", " nByteWritten", " nByteRead", "nByteLoad", "nPagesRead", "nCharactersCount", "nPagesFound", "nPartsWritten", "nByteRead", " nBytesLength", "nPartsLoad", "nFramesWritten", "nBytesWritten", "nByteCount", "nWordsLength", "nByteWritten", "nFramesRead", "nPagesWritten", " nByteLoad", "nCharactersWritten", " nBytesWritten", "nByteLength", "nWordsCount"], "checksumValue": ["checksupString", "checksramArray", " checkssumString", "checkssumText", "checksummVal", "checksummArray", " checkssumVal", "checksupValue", " checkssumText", " checksumString", "checksumberValue", "checkssumValue", " checkssumData", " checksumText", "checksramPath", "checksummValue", "checksumData", "checksumArray", "checksumberText", " checkssumPath", "checkssumVal", "checksummPath", " checksumVal", "checksupData", " checkssumArray", " checkssumValue", "checksupText", "checksumString", "checksramValue", "checksumText", "checkssumArray", "checksumberData", " checksumArray", "checksumPath", " checksumData", "checksumberString", "checkssumPath", "checkssumData", " checksumPath", "checksramVal", "checkssumString", "checksumVal"]}}
{"id1": "16590954", "id2": "13644375", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public String get(String url) {\n        try {\n            HttpGet get = new HttpGet(url);\n            HttpResponse response = this.getHttpClient().execute(get);\n            HttpEntity entity = response.getEntity();\n            if (entity == null) {\n                throw new RuntimeException(\"response body was empty\");\n            }\n            return EntityUtils.toString(entity);\n        } catch (RuntimeException ex) {\n            throw ex;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "label": 0, "substitutes": {"createJAR": ["createJARS", "createAMJar", "createJPAP", "createPHAR", " createPHARS", "createJJar", "createJAP", " createJARS", " createPHAP", "createAMAR", "createAMAP", "createJPARS", " createPHJar", "createAMARS", "createPHJar", " createJAP", "createPHARS", " createJJar", "createJPAR", "createPHAP", " createPHAR", "createJPJar"], "fileString": ["loadText", "FileStr", "loadstring", " fileText", "resourceString", "FileArray", "resourceText", "modelStr", "fileFile", "baseStr", "fileStr", "fileArray", "FileStream", "fileText", "FileName", "FileText", "modelStream", " fileArray", "lineString", "FileFile", "basestring", "fileStream", "loadString", "lineArray", "linestring", " fileName", "loadName", "FileString", "modelText", "fileName", "baseFile", "resourceStream", "Filestring", "modelString", " fileStr", "baseString", "filestring", "resourceStr", "lineName", " filestring", " fileFile"], "ext": ["xt", "class", "app", "exe", "version", "ex", "Ext", "info", "ax", "format", "filename", "content", "desc", "path", "dep", "exp", "code", "EXT", "str", "dist", "end", " Ext", "url", "x", "enc", "prot", "req", "zip", "data", "type", "append", "v", "text", "name", "extra", "external", "config", "txt"], "file": ["get", "db", "buffer", "h", "full", "files", "up", "class", "socket", "queue", "use", "output", "parent", "ger", "page", "File", "cache", "per", "fe", "module", "let", "http", "resource", "path", "fp", "single", "work", "FILE", "line", "ile", "part", "build", "change", "f", "url", "binary", "unit", "base", "doc", "model", "zip", "pe", "flat", "log", "b", "local", "bar", "test", "force", "wave", "it", "name", "l", "place", "folder", "le", "jar", "source", "filename"], "i": ["ind", "ai", "ip", "j", "p", "eni", "key", "multi", "slice", "phi", "abi", "ci", "limit", "ui", "mini", "ori", "index", "li", "ii", "iu", "ini", "uni", "x", "pi", "f", "xi", "ni", "v", "mi", "it", "di", "hi", "l", "si", "yi", "qi", "uri", "I", "c"], "dir": ["domain", "db", "DIR", "src", "output", "class", "tmp", "pkg", "id", "directory", "coll", " directory", "info", "loc", "module", "filename", "format", "path", "cur", "direction", "ir", "manager", "str", "dist", "url", "prefix", "lib", "area", "base", "doc", "zip", "data", "div", "type", "rel", "Dir", "name", "string", "folder", "uri", "jar", "config"], "jarFile": ["sessionLine", "javaSourceFile", "tarLine", "sessionfile", "archiveFiles", "jarLine", "javaDir", " jarDir", "javaF", "sessionFile", "tarF", "javaFiles", "tarSourceFile", "tarfile", "reportFile", "reportF", "jarFiles", "javaFolder", "archiveFolder", "jarDir", " jarfile", "archiveFile", " jarFolder", "reportfile", "tarFile", "sessionSourceFile", " jarSourceFile", "javaFile", " jarFiles", "jarF", "jarfile", "jarSourceFile", "jarFolder", "javafile", " jarLine", "reportSourceFile", "archiveDir"], "fstrm": ["fgrm", "fstcm", "fsrum", " fsrm", "fgrcm", "fsrcm", "fsrmd", " fsrum", "fstrcm", "fgrmd", "fbrm", "FstrM", "fstum", "Fstrmd", "Fstrcm", "fstmd", "fbrM", "fstrum", "fbrcm", "Fstrm", "fgrM", " fstrcm", "Fsrmd", "Fsrcm", "fstrmd", "fsrM", "fstm", " fstrum", "Fsrm", "fbrum", "FsrM", " fsrM", " fstrM", "fstM", "fstrM", " fsrcm", "fsrm"], "in": ["r", "image", "m", "p", "pin", "sync", "n", "inn", "stream", "gin", "is", "socket", "s", "init", "input", "id", "din", "to", "conn", "or", "inner", "io", "pull", "nin", "rin", "into", "part", "inside", "min", "f", "binary", "login", "ac", "ins", "bin", "In", "l", "reader", "IN", "again", "read", "up", "c", "inc"], "out": ["Out", "image", "plain", "client", "m", "self", "writer", "sync", "off", "all", "up", "output", "flow", "init", "user", "server", "outside", "to", "conn", "plus", "group", "connection", "inner", "exp", "resource", "io", "pool", "line", "part", "this", "channel", "null", "doc", "err", "b", "v", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "c", "inc"], "temp": ["get", "fake", "db", "clean", "buffer", "template", "writer", "p", " temporary", "full", "key", " Temp", "output", "form", "tmp", "input", " tmp", "Temp", "directory", "archive", "cache", "server", "home", "or", "path", "single", "dest", "build", "storage", "store", "f", "tem", "Output", "iter", "api", "base", "doc", "unit", "porary", "zip", "emp", "local", "v", "test", "w", "controller", "it", "export", "wrap", "folder", "dump", "source", "config", "c", "pipe"], "fstrm2": ["fhrms002", "fhrms02", "fstrmr02", "fstrms0", "fstrm1", "fstrms002", "fhrms2", "fhrm002", "fstrp2", "fstrp0", "fstrmr002", "fhrm02", "fstM2", "fstm2", "fstrm02", "fstrM1", "fhrm2", "fstrM2", "fstrm0", "fstm0", "fstrM02", "fstm1", "fstrM0", "fstM1", "fstM0", "fstrms1", "fstrm002", "fhrm1", "fstrmr1", "fstrp1", "fstrM002", "fstrms02", "fstrmr2", "fhrms1", "fstrms2"], "ostrm": ["oopmr", "odrt", "istmr", "odmr", "ooprm", "istrom", "ostrem", "obsrem", "oodrt", "otherrm", "obrt", "ophmr", "ostrom", "oodrob", "obmr", "oodrm", "oscm", "obsrob", "othermr", "istrm", "odm", "ostrt", "otherrom", "oodrem", "oscrt", "oscmr", "ooprom", "istrt", "ophrm", "odrm", "obrm", "otherrt", "ostrob", "ooprt", "ophrt", "obrom", "obsrm", "obsrt", "ophm", "ostmr", "oscrm", "ostm"], "docFile": ["DocDir", "docDir", " docF", "docFiles", "documentFiles", "documentDir", "DocFiles", " docDir", "DocF", "docF", "DocFile", "documentFile", "documentF", " docFiles"]}}
{"id1": "23161545", "id2": "20663364", "code1": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 0, "substitutes": {"getRandomGUID": ["getRandomIGid", "getRandomGCuid", "getRandomGCID", "getRandomGuid", "getRandGid", "getRandGuid", "getRandomIGUID", "getRandGID", "getRandomGCid", "getRandomUID", "getRandomUuid", "getRandomGID", "getRandUID", "getRandUuid", "getRandomGid", "getRandomIGID", "getRandomIGuid", "getRandGUID", "getRandomUid", "getRandUid", "getRandUUID", "getRandomGCUID", "getRandomUUID"], "secure": ["Secure", "timeout", "service", "require", "sec", "host", "ce", "use", "proxy", "unsigned", "server", "deep", "secondary", "safe", "sensitive", "ssl", "debug", "sr", "stable", "depth", "active", "security", "confirmed", "zip", "session", "pure", "protect", "exclusive", "secret", "https", "force", "allow", "remote", "random", "seed", "encrypted", "weak", " insecure", "smart", "external", "config"], "md5": ["cmd5", " md512", " MD5", "MD2", " MD3", " MD11", " md2", "mdql", "MD3", "MD5", " MD500", " md500", "MD11", "md3", "md2", "MDql", " md3", "cmd512", "md11", "md500", " MD2", "MD512", "md512", "MD500", " md11", "cmd3", "cmdql", " mdql"], "sbValueBeforeMD5": ["sbValueBeforeMS1", "sbValueBeforeMI5", "sbValueAfterMD75", "sbValueBeforeAMD1", "sbValueAfterMS1", "sbValueAfterMS65", "sbValueAfterMD20", "sbValueBeforeMS3", "sbValueBeforeAMD3", "sbValueBeforeMD25", "sbValueBeforeMD7", "sbValueBeforeMS25", "sbValueGivenMD512", "sbValueAfterMS5", "sbValuebeforeSD005", "sbValueBeforeSHA5", "sbValueBeforeMI1", "sbValuebeforeMD005", "sbValueBeforemd512", "sbValueBeforeMC375", "sbValueBeforemd95", "sbValueBeforeMR25", "sbValueBeforeMD20", "sbValueGivenMD5", "sbValueBeforeMI20", "sbValueBeforeDER0", "sbValueBeforeMP3", "sbValueAfterMD3", "sbValueBeforeMP7", "sbValueBeforeMC512", "sbValueBeforeD3", "sbValueBeforemd5", "sbValueAfterMS25", "sbValueBeforeDER005", "sbValueAfterMP7", "sbValueAfterMD55", "sbValuebeforeSD20", "sbValueBeforeSD5", "sbValueBeforeDER1", "sbValueBeforemd65", "sbValueBeforeMS0", "sbValueBeforeMS95", "sbValueBeforeMD1", "sbValueAfterMS75", "sbValueAfterMS3", "sbValueBeforeMD95", "sbValueBeforeSD20", "sbValueBeforeMS375", "sbValueAfterMD1", "sbValuebeforeSD1", "sbValueBeforeMAC55", "sbValueBeforeMS20", "sbValueBeforeAMD20", "sbValueAfterMP3", "sbValuebeforeMD5", "sbValueBeforeMC5", "sbValueBeforeMC3", "sbValueBeforeMS512", "sbValueBeforeD65", "sbValueBeforeMAC3", "sbValueGivenMD375", "sbValueBeforemd25", "sbValueAfterMS55", "sbValueBeforeSD1", "sbValueBeforeDER55", "sbValueBeforeMS75", "sbValueBeforemd3", "sbValueGivenmd5", "sbValueAfterMD5", "sbValueBeforeSHA1", "sbValueBeforeMS7", "sbValueBeforeMD0", "sbValueBeforeMS65", "sbValueBeforeMI7", "sbValueAfterMD0", "sbValueBeforeMS5", "sbValueBeforeMP5", "sbValueBeforeD5", "sbValueGivenmd375", "sbValueBeforeMP1", "sbValueBeforeD75", "sbValuebeforeMD1", "sbValueBeforeMI3", "sbValueBeforeMD005", "sbValueBeforemd375", "sbValueAfterMP5", "sbValueAfterMD95", "sbValueBeforemd75", "sbValueBeforeMD75", "sbValueBeforeMAC5", "sbValueBeforeDER3", "sbValueBeforeDER5", "sbValueBeforeSHA005", "sbValueBeforeAMD5", "sbValueAfterMD25", "sbValueAfterMP1", "sbValueBeforeSHA20", "sbValuebeforeSD5", "sbValueAfterMS95", "sbValueBeforeMR3", "sbValueAfterMS0", "sbValueBeforeMD65", "sbValuebeforeMD20", "sbValueBeforeMR95", "sbValueBeforeDER20", "sbValueBeforeMAC0", "sbValueBeforeMD3", "sbValueAfterMD7", "sbValueBeforeMR5", "sbValueGivenMD3", "sbValueGivenmd512", "sbValueAfterMS20", "sbValueGivenmd3", "sbValueAfterMD65", "sbValueBeforeMS55", "sbValueBeforeMD375", "sbValueBeforeMD512", "sbValueBeforeSD005", "sbValueBeforeMD55"], "time": ["error", "timeout", "cost", "rate", "size", "host", "user", "year", "version", "slice", "TIME", "delay", "id", "loc", "tz", "work", "value", "date", "count", "clock", "start", "etime", "depth", "money", "hour", "mode", "Time", "tim", "type", "offset", "times", "name", "race", "counter", "speed", "random", "seed", "duration", "event", "ime", "length", "timer"], "rand": ["r", "clean", "error", "rate", "risk", "max", "alpha", "bit", "q", "rc", "order", "ro", "chance", "year", "version", "rank", "rol", "cr", "delay", "id", "serial", "ng", "rule", "mid", "Rand", "reg", "rage", "pick", "index", "rh", "rr", "count", "root", "raid", "winner", "min", "depth", "type", "lang", "range", "bot", "res", "round", "random", "seed", "gen", "win", "right"], "valueBeforeMD5": ["valueAfterMD3", "valueBeforeMD85", "valueAfterAMD5", "valueBeforeAMD5", "valueBeforemd3", "valueInsideMD5", "valueInsideMD85", "valueBeforeMD3", "valueBeforeMP53", "valueInsideMD2", "valueBeforeMC2", "valueBeforeMP3", "valueAfterAMD53", "valueBeforeMP5", "valueBeforeMD2", "valueBeforemd2", "valueInsideMD3", "valueAfterAMD3", "valueBeforeAMD53", "valueAfterMD2", "valueBeforemd5", "valueAfterAMD2", "valueBeforeAMD2", "valueBeforeMC3", "valueBeforeMD53", "valueBeforeMP2", "valueBeforeAMD3", "valueBeforeMC85", "valueBeforemd85", "valueAfterMD53", "valueBeforeMC5"], "array": ["image", "error", "shape", "batch", "element", "view", "object", "app", "instance", "section", "expression", "archive", "cache", "Array", "address", "integer", "arrow", "result", "our", "audio", "message", "air", "pair", "ray", "value", "function", "row", "angle", "storage", "area", "binary", "api", "feature", "data", "range", "database", "collection", "any", "allow", "number", "record", "arr", "string", "list", "sample", "vector"], "sb": ["lr", "abb", "bp", "buffer", "sl", "bf", "src", "ab", "lb", "bs", "s", "zb", "SB", "bt", "nn", "ib", "bb", "sa", "usb", "sbm", "sf", "sg", "bc", "rb", "fb", "bm", "kb", "bl", "lp", "stab", "mb", "ob", "gb", "bj", "pb", "bh", "eb", "buf", "binary", "wb", " SB", "BB", "sq", "bsp", "xb", "obb", "si", "nb", "lab", "sth", "sv", "orb", "ruby", "cb", "rob"], "j": ["job", "p", "obj", "br", "g", "n", "ie", "i", "key", "q", "uj", "J", "e", "adj", "aj", "length", "jj", "code", "ja", "li", "num", "ii", "index", "jl", "z", "bj", "out", "ij", "part", "end", "x", "f", "ch", "o", "k", "jp", "y", "v", "ji", "l", "d", "js", "dy", "c", "pr", "jo"], "b": ["job", "db", "p", "bf", "n", "br", "bit", "i", "ab", "lb", "bs", "bug", "ib", "bb", "e", "bc", "rb", "a", "fb", "be", "mb", "ob", "bi", "pb", "B", "x", "f", "eb", "binary", "k", "BB", "y", "bar", "l", "bin", "d", "nb", "orb", "cb", "c"], "valueAfterMD5": ["valueAfterMD3", "valueAfterAMD5", "valueBeforeMD7", "valueBeforeMP7", "valueBeforeMD3", "valueAfterVM5", "valueBeforeMP3", "valueBeforeMP5", "valueAfterMD7", "valueAfterMP3", "valueBeforeMD2", "valueAfterAMD7", "valueAfterAMD3", "valueAfterMD2", "valueAfterVM2", "valueAfterVM3", "valueAfterMP2", "valueAfterAMD2", "valueBeforeMP2", "valueAfterMP7", "valueAfterMP5", "valueAfterVM7"]}}
{"id1": "4118412", "id2": "19109981", "code1": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "code2": "    private void startScript(wabclient.Attributes prop) throws SAXException {\n        dialog.beginScript();\n        String url = prop.getValue(\"src\");\n        if (url.length() > 0) {\n            try {\n                BufferedReader r = new BufferedReader(new InputStreamReader(new URL(url).openStream()));\n                String buffer;\n                while (true) {\n                    buffer = r.readLine();\n                    if (buffer == null) break;\n                    dialog.script += buffer + \"\\n\";\n                }\n                r.close();\n                dialog.endScript();\n            } catch (IOException ioe) {\n                System.err.println(\"[IOError] \" + ioe.getMessage());\n                System.exit(0);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"compress": ["ompressed", "comression", "compose", "comressed", "compressor", "Compression", "comress", "suppression", "Compress", "omppose", "compression", "compressing", " comprypt", "Compressor", "comppose", "Compressing", "Comppose", "Compressed", "ompression", " compressed", " compressing", "Comprypt", "comressing", "suppressor", "suppress", "suppressed", "comressor", "comrypt", "ompress", "compressed", "comprypt"], "outputFile": ["outputDirectory", "targetDir", " outputFolder", " outputLine", "OutputDirectory", "OutputF", "targetFolder", "outputPath", "externalPath", "outputDir", "externalDirectory", "inputF", "targetPath", " outputF", "inputFolder", "outputLine", "OutputLine", "OutputFiles", "inputLine", " outputDirectory", "Outputfile", "outputFolder", "outputF", " outputfile", "outputFiles", "externalFile", "OutputDir", "OutputFile", "OutputPath", "inputDirectory", "OutputFolder", " outputDir", "inputFile", "inputDir", " outputPath", " outputFiles", "outputfile", "targetFile", "externalfile", "inputPath"], "inputFiles": ["InputFile", "inputFile", " inputfiles", "outputFiles", " inputFile", "inputfiles", "Inputfiles", "InputFiles", "outputfiles"], "log": ["job", "db", "blog", "console", "stat", "entry", "up", "key", "output", "print", "trace", "feed", "user", "bug", "write", "cli", "ex", "cache", "per", "info", "or", "http", "exp", "path", "report", "low", "io", "xml", "pool", "debug", "row", "crit", "lex", "Log", "url", "exec", "base", "model", "zip", "temp", "pe", "put", "spec", "w", "tag", "cl", "net", "l", "LOG", "og", "pro", "pot", "lock", "pl", "config"], "absPath": ["resStream", "atsAuth", "apspath", "absParent", "atsPath", "absolutepath", "httpPath", "absolutePath", "httpDir", "atspath", "respath", "resDir", "bspath", "resPath", "abAuth", "abPath", "AbsPath", "abpath", "AbsStream", "absPo", "absStream", "apiPath", "apiDir", "bsPath", "bsParent", "labpath", "absolutePo", "bsHome", "abDirectory", "absoluteParent", "labParent", "Abspath", "abTime", "absDirectory", "absoluteDirectory", "atsPo", "httppath", "atsDir", "abspath", "absDir", "labPath", "AbsDir", "abDir", "apipath", "absAuth", "absoluteDir", "apsTime", "apsAuth", "AbsDirectory", " absStream", "absHome", "atsTime", "apsPath", "labHome", "absoluteHome", "abPo", " abspath", "absTime", " absDir"], "out": ["Out", "plain", "client", "writer", "sync", "obj", "off", "output", "socket", "app", "parent", "cli", "ex", "cache", "conn", "plus", "sum", "a", "inner", "ext", "io", "conf", "at", "work", "part", "prefix", "o", "serv", "this", "exec", "base", "err", "loader", "b", "w", "net", "bin", "In", "OUT", "again", "reader", "outs", "outer", "up", "inc"], "buffer": ["pad", "timeout", "writer", "bytes", "size", "shape", "batch", "block", "queue", "transfer", "feed", "slice", "input", "reference", "page", "limit", "Buffer", "cache", "phrase", "stack", "source", "padding", "buff", "uffer", "iter", "url", "buf", "binary", "channel", "base", "data", "border", "offset", "split", "wave", "memory", "reader", "header", "seed", "read", "layer", "length"], "readBytes": ["readByte", " readPages", "ReadBlocks", "inCount", " readByte", "writeCount", "readBlocks", " readParts", "writebytes", " readbytes", "writeByte", "readbytes", "ReadCount", "writeBlocks", "readCount", "ReadPages", "inBytes", "readParts", "ReadParts", "ReadByte", " readBlocks", "inPages", " readCount", "ReadBytes", "writeParts", "inbytes", "Readbytes", "writeBytes", "readPages"], "file": ["lf", " feed", "entry", "files", "key", "queue", "object", "el", "feed", "comment", "input", "slice", " message", "route", " path", "directory", "File", "rule", " directory", "fe", "source", "child", " input", "http", "path", "fp", "word", " File", " entry", " source", "FILE", "ile", "part", "work", "line", "dir", "f", "url", "letter", "unit", "base", "model", "type", "fil", "cl", " module", "name", "l", " url", "style", " files", "string", " f", "folder", "uri", " filename", "layer", "filename"], "in": ["r", "image", "pin", "n", "inn", "gin", "isin", "stream", "i", "is", "socket", "s", "init", "cin", "input", "id", "ex", "sin", "din", "lin", "a", "inner", "nin", "con", "ini", "kin", "part", "f", "pass", "login", "data", "err", "b", "ins", "bin", "In", "l", "reader", "IN", "again", "win", "up", "ac", "inc"], "normalSize": [" normalHeight", "smallSize", "normalInfo", "normalLength", "NormalHeight", "NormalPosition", "normLen", "NormalInfo", " normalWidth", "normalsize", "NormalSize", "normalTime", "normSize", "smallPosition", "normalNumber", "originalLen", " normalsize", " normalInfo", "NormalTime", "smallInfo", "normLength", "NormalWidth", " normalLen", "normalHeight", "NormalNumber", "originalsize", "normalLen", "normTime", "normWidth", "originalSize", " normalNumber", "normalPosition", "normNumber", " normalLength", " normalPosition", "normsize", "originalLength", "smallHeight", " normalTime", "normalWidth"], "builder": ["job", "r", "writer", "creator", "worker", "block", "entry", "bug", "slave", "e", "office", "sb", "info", "result", "builders", "hub", "inner", "editor", "later", "xml", "keeper", "angler", "manager", "building", "row", "build", "iter", "f", "this", "wrapper", "loader", "b", "er", "runner", "built", "driver", "l", "processor", "bean", "utils", "reader", "parser", "bridge", "outer", "Builder", "layer"], "process": ["job", "image", "large", "p", "worker", "script", "cess", "console", "cp", "output", "object", "use", "app", "e", "cache", "run", "program", "result", "handle", "share", "path", "resource", "proc", "thread", "build", "exec", "session", "task", "pm", "status", "processing", "method", "call", "node", "processor", "project", "commit", "command", "cmp", "Process", "sp"], "minSize": ["initOffset", "MinCount", "minOffset", "MinOffset", "normalLength", "minLength", "MinSize", "minWidth", " minOffset", "MinLength", "minCount", "initWidth", "normalCount", "initSize", " minWidth", "MinWidth", " minCount", " minLength", "initCount"], "diff": ["error", "equal", "progress", " difference", "size", "pos", "def", "flow", "same", "default", "multi", "version", "bug", "between", "mix", "fail", "iff", "low", "ref", "message", "change", "dist", "part", "f", "update", "scale", "div", "missing", "err", "range", "rel", "comp", "split", "changed", "frac", "remote", "Diff", "different", "distance", "extra", "cmp", "add", "neg", "shift"], "percentage": ["advantgrade", "spage", " percentency", "spce", "advantant", " percentile", " percentgrade", " percentant", "Percentant", "spile", "Percentce", " percentce", "Percentage", "percentgrade", "percentency", "Percentile", "spacity", "Percentacity", "Percentency", "percentant", "advantage", "percentile", "percentacity", " percentacity", "Percentgrade", "advantency", "percentce"], "diffSize": ["errorCount", "errorLen", "differentSize", "differentLen", "DiffCount", "differentCount", "diffLen", " diffsize", "Diffsize", "errorSize", "diffCount", "diffsize", "DiffSize", "differentsize", "DiffLen"]}}
{"id1": "23585985", "id2": "23467091", "code1": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getStreamSource": ["getstreamService", "getstreamSource", "getFileStream", "newContentStream", "getContentSources", "getFileSource", "getstreamStream", "getStreamSources", "newContentService", "getFileSources", "newContentSources", "newStreamSource", "getContentService", "getStreamService", "getFileService", "getContentStream", "newContentSource", "newStreamStream", "getStreamStream", "newStreamService", "getstreamSources", "newStreamSources", "getContentSource"], "item": ["image", "entry", "parent", "section", "attribute", "stuff", "example", "info", "http", "container", "value", "iter", "this", "api", "base", "update", "article", "name", "custom", "iv", "items", "request", "get", "ip", "atom", "client", "component", "p", "element", "view", "load", "input", "user", "om", "page", "json", "stack", "val", "inner", "index", "anything", "hop", "event", "issue", "original", "service", "q", "order", "object", "el", "app", "slice", "e", "online", "option", "result", "op", "Item", "it", "layer", "source", "all", "queue", "instance", "handler", "server", "adj", "resource", "xml", "storage", "type", "temp", "collection", "other", "entity", "site", "extra", "arg", "self"], "context": ["request", "template", "component", "service", "support", "ctx", "tx", "queue", "view", "input", "environment", "com", "core", "stack", "info", "source", "result", "connection", "bc", "container", "path", "resource", "graph", "xml", "manager", "con", "options", "this", "session", "temp", "database", "text", "document", "driver", "project", "reader", "parser", "cms", "event", "Context", "config", "c"], "streamSource": ["returnSource", "returnSources", " streamService", "cloudSource", "streamService", "threadClient", "cloudService", "putSource", "StreamSource", " streamOrigin", " streamStore", "StreamSources", "putForce", "transformOrigin", "streamFlow", "streamForce", "threadSource", "cloudTarget", "transformSources", "StreamClient", " streamTarget", "threadStore", "returnService", "StreamTarget", "streamOrigin", "StreamProxy", "putTarget", "StreamForce", "StreamStore", "cloudClient", "controlFlow", "streamStore", "transformFlow", "streamClient", " streamForce", "threadService", "streamSources", " streamProxy", " streamSources", "cloudOrigin", "putService", "StreamService", "controlOrigin", "StreamOrigin", "controlSource", "returnProxy", "transformSource", "controlSources", "streamTarget", "streamProxy", " streamClient", " streamFlow"], "obj": ["os", "pt", "amp", "j", "p", "txt", "ctx", "n", "Ob", "src", "art", "ff", "object", "tmp", "s", "ass", "bs", "instance", "po", "ex", "nt", "ut", "bo", "aos", "coll", "val", "conn", "aj", "objects", "ox", "Obj", "foo", "op", "ob", "az", "fn", "cdn", "oa", "x", "active", "o", "api", "jp", "b", "org", "oi", "bot", "arr", "so", "js", "iv", "act", "pl", "cb", "sp"], "inputFile": ["InputFile", "inputObj", "tempFile", " inputPage", "outputFile", "importUrl", "InputFiles", "outputDir", " inputfile", " inputObject", "inputUrl", "Inputfile", "InputDir", " inputObj", "imageFile", " inputFiles", "tempfile", "imageFiles", "outputFiles", "tempUrl", "importfile", "outputObject", "inputObject", " inputUrl", "inputfile", "imagePage", "importObj", "tempObj", "inputFiles", " inputDir", "inputDir", "inputPage", "imageObject", "outputfile", "importFile", "outputPage"], "is": ["lis", "get", "os", "ip", "mis", "Is", "ils", "irc", "us", "bis", "iso", "isl", "isa", "i", "bs", "init", "its", "was", "ls", "il", "id", "css", "es", "kit", "ris", "alis", "loc", "IS", "info", "ui", "or", "address", "iss", "ios", "index", "ori", "ii", "nis", "has", "isc", "inner", "iris", "ais", "abs", "iter", "fs", "api", "serv", "sis", "does", "im", "isol", "it", "ins", "vs", "res", "ics", "as", "js", "ps", "ms", "sys", "cms", "uri", "ists", "iv", "ws", "act"], "url": ["lr", "image", "attr", "key", "impl", "address", "bc", "http", "str", "sel", "api", "base", "dl", "shell", "text", "name", "string", "href", "ur", "uri", "sl", "html", "rl", "view", "feed", "user", "route", "page", "loc", "URL", "path", "file", "err", "ll", "l", "web", "www", "job", "fr", "email", "ul", "host", "pattern", "object", "el", "ls", "bb", "id", "lc", "ref", "pull", "ssl", "Url", "channel", "ri", "download", "gl", "rel", "remote", "nl", "pl", "layer", "source", "term", "bf", "fl", "hl", "coll", "server", "connection", "location", "resource", "xml", "f", "type", "char", "field", "config", "username"], "np": ["ne", "su", "bp", "p", "sync", "n", "cp", " npm", "nn", "nv", "nu", "ns", "nt", "pd", "ng", "zn", "py", "adj", " NP", "dn", "nc", "lp", "fp", "nm", "vp", "img", "nz", "NP", "cdn", "ulp", "uni", "nr", "pn", "jp", "pm", "wp", "nw", "appy", "hp", "nb", "network", "cmp", "px"], "serializer": [" serialiser", "serialization", "serialiser", "materializable", "Serialization", "materializer", "initializer", "materialize", "serialize", "erializer", " serializable", "serializable", "erialize", "initialize", "initialization", "Serialiser", "initialiser", "Serializable", "erialization", "Serialize", "erialiser", "materialiser", " serialize", "Serializer"], "node": ["image", "template", "component", "sync", "n", "msg", "tree", "object", "nn", "global", "slave", "ns", "ode", "id", "route", "child", "loc", "Node", "target", "content", "location", "path", "message", "xml", "ko", "value", "cdn", "root", "storage", "enc", "api", "nil", "edge", "live", "nw", "document", "entity", "nit", "network", "uri", "cmp", "source", "config"], "binary": ["New", "element", "s", "format", "Element", "Impl", "path", "resource", "xml", "_", "Url"]}}
{"id1": "15822137", "id2": "411595", "code1": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"raf": [" rot", "r", "fin", "fal", "arch", " arc", "upload", "bf", "Rot", "rot", "raft", "fa", "fam", "fd", "rc", "hel", "ab", " ra", "feed", "ro", " fin", " fa", " priv", "AF", "ut", "cro", "rah", "sam", "root", "dra", "rb", "af", "fb", "rss", "ref", "io", "fp", "buff", "awa", "ra", " af", "rr", "ica", "fc", "file", "rar", "RF", "fed", "bas", "rw", "rf", "f", "util", "roc", "fs", "aft", "buf", "mr", "arf", "asu", "arc", "rt", "uf", "RB", "transform", " ar", "reed", "reader", "fif", "RR", "rou"], "version": ["ip", "release", "init", "Version", "parent", "serial", "id", "section", "patch", "server", "option", "ver", "vers", "format", "index", "row", "VERSION", "step", "root", "depth", "prefix", "feature", "scale", "versions", "counter", "seed", "vision"], "numTables": ["numDabs", " numTests", "numNabs", " numTenures", " numTodes", "numTenaces", "numTenries", "numNures", "numNrees", "numTenasks", " numTaces", "numLries", "NumNaces", "NumTabs", "numTasks", "Numtaces", "numLables", "numTaces", " numTenests", "numtries", " numtaces", " numtrees", " numTries", "numDables", "NumTaces", "NumNures", "numLests", "numtrees", "NumNables", "numtures", "numNaces", "numTenests", "numTabs", " numtables", "numLures", "numNasks", "numTests", "numTures", "numTries", "numtodes", "Numtests", "NumTasks", " numTenables", "NumTables", "NumNabs", "Numtables", "numPartaces", "NumTests", "numTodes", " numTures", "numNodes", "Numtasks", " numTenries", "numTenables", "numNables", "numNests", "numDaces", " numTrees", "numPartodes", " numtodes", "numDures", "numtaces", "numtables", "NumTures", "numtasks", "numTrees", "numtabs", "numPartables", "numPartrees", "numtests", "numTenures"], "searchRange": ["indexRange", "filterPart", "filterLimit", "indexPart", " searchLimit", "filterRange", "searchrange", "indexLimit", " searchrange", " searchPart", "searchPart", "indexrange", "searchLimit", "filterrange"], "entrySelector": ["entrySelection", "entryProcessive", "sectionAcception", "entryAcceptored", "sectionAcceptive", "sectionSelector", "entryselector", "entrySelective", "sectionAcceptored", "entryAcceptive", "sectionSelective", "sectionSelectored", "entryProcessor", "sectionAcceptor", "entryselective", "entryAcceptor", "sectionSelection", "entryselectored", "entryselection", "entryProcessored", "entryAcception", "entrySelectored", "entryProcession"], "rangeShift": ["tableshift", "queryShift", "tableCut", "rangeCut", "rangeshift", "rangeScale", "queryCut", "tableShift", "tableScale", " rangeScale", " rangeshift", " rangeCut", "queryshift", "queryScale"], "entries": ["entry", "objectrics", "instries", "entrance", "encies", "entories", "entrations", "objectrations", "intrations", "errorrics", " entrys", "attances", "errorries", "countries", "ntry", "entables", "emptries", "antants", "instances", "antrys", "antories", "equry", "enties", "errorrying", "antrance", "Entries", "extrations", "endies", "Entables", "endables", "entrys", "attrys", "entances", "entsants", "anties", "insties", "entsrations", "emptants", "Entrations", "ntants", "ntables", "antries", "intrying", "countrys", "attries", "ntrance", "errorrations", "entrying", "ntrys", " entrations", "intries", "equies", "extries", "country", "instry", "encries", "Entrys", "instables", "Entants", "instrance", "equances", "ntries", "entsrys", "extances", " entants", "entrics", "encances", "ntories", "emptories", "endries", "objectrying", "ntances", "emptrys", "instrys", "intrics", "equries", "Entances", "encables", "entsries", "objectries", "countables", "nties", "Entry", "attrations", "endances", "entants", "extrys"], "i": ["ai", "ip", "in", "uli", "m", "j", "p", "h", "ie", "g", "my", "eni", "ik", "init", "multi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "lc", "cli", "ui", "info", "a", "li", "index", "ii", "ori", "io", "iu", "z", "ini", "anti", "bi", "x", "pi", "f", "o", "xi", "api", "ti", "ri", "u", "b", "y", "v", "oi", "mi", "it", "di", "l", "hi", "d", "si", "qi", "uri", "iv", "source", "I", "c"], "modified": ["success", "original", "loaded", " altered", " modifications", "left", "disabled", "received", "created", " updated", "used", " modifying", "required", "id", " modification", "valid", "locked", "complete", "restricted", " unchanged", "updated", "dirty", " delayed", "content", "found", "edited", "successful", "initial", "failed", "unknown", " modify", "hidden", "ended", " completed", "stable", "active", "ordered", "adjusted", "null", " original", "broken", "update", "offset", "rolled", "affected", "status", "changed", "mod", "interrupted", "draft", "empty", "current", "formed", "closed", " Modified", "ified", "placed", " modifier", "hold", "condition"], "temp": ["fake", "template", "j", " template", " wrapper", " candidate", "entry", "cel", " zip", "tmp", "parent", "lc", "Temp", "ex", " aux", "valid", " adapter", "result", "mini", " swap", " extra", "z", " generator", " source", "ant", " vendor", "dest", "tc", "iter", "stable", " intermediate", " cleaner", "base", "porary", " fake", "emp", "flat", "local", "v", " cache", " dummy", " holder", " winner", " orig", " destination", "extra", "empty", " esc", "holder", "txt"]}}
{"id1": "14688886", "id2": "6299111", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public static String retrieveQ(String urlToRetrieve) throws MalformedURLException, IOException {\n        URL url = new URL(urlToRetrieve);\n        URLConnection uc = url.openConnection();\n        InputStream is = uc.getInputStream();\n        BufferedReader in = new BufferedReader(new InputStreamReader(is));\n        StringBuilder output = new StringBuilder(16384);\n        String str;\n        boolean first = true;\n        while ((str = in.readLine()) != null) {\n            if (!first) output.append(\"\\n\");\n            first = false;\n            output.append(str);\n        }\n        in.close();\n        System.err.println(((HttpURLConnection) uc).getResponseMessage());\n        return output.toString();\n    }\n", "label": 1, "substitutes": {"populateResources": ["compureResource", "poputeRelations", "compureRelations", "popractResources", "poputeResource", "populateRelations", "popureFiles", "poputeFiles", "poputeResources", "compulateFiles", "compureResources", "popureResources", "compulateRelations", "compureFiles", "popractFiles", "compulateResources", "popureResource", "populateResource", "popureRelations", "compulateResource", "popractRelations", "populateFiles", "popractResource"], "templates": ["Template", "template", "filens", "Temeters", "temures", "filures", "templateps", "templateples", "stemples", "tomplates", "prompl", "Temens", "templateplates", "Templ", " temures", "promplate", "promplates", "temps", " templ", "stemplates", "tempplates", "Temples", "Temps", "stempl", "temeters", "tompl", "typlates", "tometers", "stemps", "temples", "tempplate", "filpl", "typs", "templ", "prometers", "temppl", " temens", "templatepl", "tempps", "typlate", "Templates", "typl", "tomplate", "temens", "Temures", "filplates"], "url": ["image", "r", "job", "template", "buffer", "service", "email", "sl", "html", "entry", "host", "pattern", "object", "el", "feed", "fl", "il", "e", "route", "page", "server", "address", "connection", "http", "location", "URL", "resource", "path", "ob", "xml", "ssl", "file", "config", "link", "f", "Url", "channel", "base", "data", "download", " URL", "name", "l", "string", "href", "uri", "pl", "source", "filename"], "fileName": ["FileKey", "resourcePath", "stringType", "FileType", "stringName", " fileTime", "fDir", " fileInfo", "sourceName", "FileName", "filenameName", "filePart", "fileDir", "FileFull", "fileSync", " fileDir", "filePath", "fileTime", " filePart", "folderPath", "foldername", "sourceInfo", " fileKey", "folderPart", "fileString", "objectTime", "fname", "FileDir", "modelname", "fileSystem", " fileSystem", "FILELocation", " fileDirectory", "fileDirectory", "resourcePart", "FILESync", "filenamename", "stringDirectory", "modelLocation", "sourcename", "Filename", " fileLength", "sourceString", "FILESystem", "fileType", " fileType", "folderName", " fileSync", "resourcename", "fName", " filePath", "filenameString", " fileLocation", "fKey", "resourceName", "filenameType", "objectname", " filename", "filename", "objectName", "sourceLength", "fileLength", " fileFull", "filenameFull", "fileLocation", "FILEname", "modelName", "FileDirectory", "modelSystem", "filenameLength", "fileFull", "fileInfo", "fileKey", "FileInfo", "FileString", " fileString", "objectSync", "FILETime", "FILEName"], "templateResource": ["tempFile", "eventReader", " templateFile", "plateResource", "translationContent", "plateContainer", "copyUrl", "templateUrl", "translationRing", "templateReader", "privateResource", "privateUrl", "xmlFile", "templateresource", "xmlRole", "layoutResource", "templateType", "privateresource", "translationContainer", "eventresource", "tempResource", "translationResource", "layoutRing", "templateRing", "templateFile", " templateType", "plateRing", "templateContent", "templateContainer", "privateReader", "copyresource", "eventUrl", "xmlType", "tempRole", "copyReader", "plateContent", "xmlResource", "copyResource", "tempType", "eventResource", " templateRole", "templateRole", "layoutContent", "layoutContainer"], "is": ["lis", "r", "os", "in", "ip", "irc", "Is", "bis", "iso", "isl", "isa", "src", "s", "app", "its", "was", "ib", "isi", "ris", "IS", "iss", "rss", "ios", "isc", "ori", "nis", "io", "has", "ir", "out", "iris", "abs", "ais", "api", "serv", "ri", "im", "it", "ar", "as", "cms", "uri"], "strBuff": ["brBuff", "arrBuffer", "strGrab", "rBuffer", "StrText", "brBuffer", "StrTab", " strBuffer", " strTab", " strbuff", "StrBuffer", "strbuff", "stringFlow", "strText", " strGrab", "strTab", " strPref", "stringGrab", "rBuff", "StrBuff", "Strbuff", "stringBuffer", "brFlow", "strBuffer", " strFlow", "StrPref", "arrTab", "stringBuff", "brGrab", "strFlow", " strText", "arrPref", "arrBuff", "rText", "strPref", "rbuff"], "br": ["r", "gr", "fr", "Reader", "stream", "ctr", "cr", "result", "dr", "bc", "rb", "bl", "ber", "ori", "io", "Br", "bro", "hr", "nr", "sr", "mr", "buf", " reader", "data", "div", "err", "b", "bar", "er", "BR", "brush", "text", "arr", "yr", "browser", "res", "reader", "tr", "orb", "cb", "sp"], "str": ["STR", "r", "sc", "fr", "strike", "p", "sl", "sec", "key", "cr", "lc", "Str", "stri", "t", "coll", "or", "dr", "cur", "line", "wr", "hr", "sr", "iter", "f", "oct", "st", "enc", "data", "type", "err", "div", "char", "er", "spec", "kr", "cl", "text", "star", "arr", "name", "style", "string", "tr", "pr", "sp"], "images": ["image", "letters", "ups", "words", "scripts", "styles", "models", "people", "assets", "files", "types", "boxes", "holes", "tags", "xs", "dates", "sites", "games", "gallery", "ages", "events", "ips", "picture", "features", "objects", "rooms", "quarters", "media", "bands", "services", "jobs", "resources", "frames", "apps", "ions", "pieces", "icons", "png", "classes", "pages", "opens", "inches", "agents", "gif", "ims", "users", "groups", "views", "ins", "versions", "shows", "videos", "stars", "lights", "thumbnails", "Images", "photos", "tests", "flows", "plugins"], "i": ["image", "j", "key", "s", "ci", "gi", "info", "format", "http", "x", "this", "u", "v", "yi", "uri", "I", "ind", "ip", "p", "html", "eni", "multi", "fi", "phi", "diff", "index", "li", "io", "iu", "gu", "bi", "ti", "b", "mi", "d", "si", "ai", "in", "app", "slice", "e", "id", "cli", "lc", "z", "ini", "Url", "xi", "y", "ji", "it", "hi", "chi", "add", "ie", "n", "mu", "ui", "ii", "xml", "_", "ij", "uni", "pi", "f", "ni", "di", "qi", "config"], "img": ["att", "image", "fw", "iframe", "m", "icon", "p", "sl", "jpg", "ie", "src", "ff", "tmp", "app", "map", "input", "fig", "gallery", "ng", "cb", "info", "bg", "fb", "inst", "ext", "li", "bl", "exp", "file", "gd", "hr", "png", "f", "ch", "lib", "imp", "abc", "data", "ani", "gif", "im", "v", "norm", "arr", "small", "aut", "tif", "aff", "config"], "imgProperty": ["cachePro", " imgProp", "imgPro", "cacheImage", "bgPro", "cacheProperty", " imgPro", " imgImage", "imgProp", "bgImage", "imgImage", "bgProp", "cacheProp", "bgProperty"]}}
{"id1": "5237257", "id2": "14191679", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"download": ["process", "upload", "release", "output", "transfer", "delete", "load", "archive", "complete", "run", "open", "register", "submit", "report", "pack", "file", "start", "url", "exec", "update", "zip", " downloading", "log", "paste", "Download", "dump", "select"], "fileName": ["resourcePath", "FileType", " fileFolder", "fileType", " fileType", "resourceFolder", " fileCode", "FileName", "FileDirectory", "fileUrl", "resourceType", "FilePath", " fileUrl", "resourceName", "FileCode", "resourceCode", " fileDirectory", "fileDirectory", "fileCode", "FileUrl", "fileFolder", "resourceUrl", "FileFolder", "resourceDirectory"], "filePath": ["resourcePath", "FileLocation", "filepath", "fileFile", "FilePart", "fileLocation", "FileName", "resourceFile", "FileFile", "filePart", "FilePath", "resourcepath", " fileLocation", "resourceName", "resourceLocation", " filepath", "Filepath", "resourcePart", " filePart", " fileFile"], "in": ["r", "image", "m", "pin", "sync", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "copy", "on", "id", "spin", "din", "ax", "lin", "cgi", "a", "inner", "resource", "io", "nin", "con", "ini", "rin", "file", "work", "x", "inside", "f", "url", "this", "login", "data", "err", "b", "ins", "name", "bin", "In", "l", "reader", "IN", "as", "again", "re", "win", "issue", "source", "up", "ac", "inc"], "out": ["Out", "image", "error", "client", "writer", "sync", "obj", "n", "off", "one", "up", "output", "socket", "view", "user", "write", "copy", "on", "id", "ex", "office", "cache", "server", "option", "to", "conn", "or", "inner", "ext", "path", "exp", "io", "nin", "line", "at", "file", "x", "url", "prefix", "o", "null", "exec", "this", "base", "lib", "err", "with", "log", "net", "call", "name", "bin", "In", "password", "by", "again", "IN", "string", "point", "outs", "extra", "cmd", "outer", "source", "OUT"]}}
{"id1": "5125848", "id2": "16092702", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"combineJs": ["Combinejs", "combineJS", "CombinateJS", "CombineJs", "combinScript", "combinedJS", "combinedJs", "CombineScript", "combinateScript", "combinedScript", "combinejs", "CombinateScript", "combinateJS", "combinJS", "combineScript", "combinateJs", "CombineJS", "combinedjs", "combinjs", "CombinateJs", "combinatejs", "Combinatejs", "combinJs"], "base": ["image", "db", "absolute", "proxy", "page", "cache", "server", "home", "address", "info", "relative", "http", "resource", "ref", "based", "out", "file", "build", "root", "bas", "part", "store", "f", "area", "prefix", "api", "builder", "data", "b", "log", "bot", "site", "string", "Base", "uri", "source", "config"], "linkJs": [" linkjs", "loadJs", "linkedjs", "likeLinks", " linkLinks", "likeJS", "loadScript", "loadjs", " linkScript", "likejs", "linkedLinks", "linkedJs", "linkjs", "linkScript", "linkJS", "loadJS", "linkLinks", " linkJS", "likeJs", "linkedJS", "linkedScript"], "newFiles": ["addFiles", "addResources", "oldFiles", " newLinks", "oldLinks", "oldResources", "addfiles", "addLinks", " newfiles", "newfiles", "newLinks", "oldfiles", "newResources", " newResources"], "dir": ["domain", "db", "in", "DIR", " db", " download", "src", " folder", "object", "id", "directory", " manager", "cache", "home", "md", " Dir", " directory", "loc", "module", "or", "relative", "http", "container", " d", "dep", "editor", "direction", "ir", "out", "manager", "work", "wd", "file", "build", "root", "dist", " dep", "lib", "zip", "session", "div", "download", "log", "b", "local", "keep", "Dir", " module", "plugin", "d", "folder", " repo", "uri", "lock", " block", "source", " director"], "name": [" resource", " build", " bundle", " info", " zip", " folder", " root", " init", " manager", " abs", " relative", " source", " prefix", " title", " id", " suffix", " dest", "Dir", " head", " cache", " parent", " module", " app", " repo"], "minDir": ["minJar", "miniDriver", "tempDir", " minDriver", "minidir", "miniDb", "blockDir", "versionDir", "blockFile", "minManager", "blockdir", "Mindir", "MinMin", "minDriver", "minDb", "versionManager", "tempdir", "blockDriver", "mindir", "minDest", "initManager", " minFile", " minDb", " minMin", "versionDirectory", "tempJar", "miniFile", "initFolder", " minManager", " minJar", "MinJar", " mindir", " minDest", "minFile", "tempMin", "MinDb", "initDir", "minDirectory", "miniDest", "initDirectory", "minMin", "minFolder", " minFolder", "MinDest", "MinDir", "miniDir", " minDirectory", "versionFolder", "MinFile"], "combineFile": ["comboseWriter", "combinateWriter", "CombineSourceFile", "combinerSourceFile", "CombinateLog", "combinedWriter", "comboseFile", "combinateReader", "combinerLog", "CombinateFile", "combinateFile", "CombinateWriter", "combinerWriter", "combineDir", "comboseDir", "joinateWriter", "joinateFile", "combinedDir", "CombineWriter", "joineReader", "joineWriter", "CombineLog", "combineSourceFile", "combicateFile", "combinedFile", "combineReader", "combinerFile", "joineFile", "joinateReader", "combineLog", "joineDir", "combinateSourceFile", "combinateDir", "CombineFile", "combinateLog", "combinedReader", "combicateSourceFile", "joinateDir", "combicateLog", "combicateWriter", "comboseReader", "CombinateSourceFile"], "concatFile": ["Concatsfile", "concatDir", "concDir", "concWriter", "concatFiles", "concfile", "ConcatsWriter", "concentFile", "ConcatsStream", "concatsFile", "concentWriter", "conatefile", "Concatfile", "concFiles", "ConcatFile", "concentDir", "ConcatFiles", "conateDir", "ConcatWriter", "concatsDir", "concentStream", "ConcatDir", "concFile", "concatsfile", "ConcatsDir", "conateFile", "concatsStream", "concatfile", "concatsFiles", "ConcatsFiles", "ConcatsFile", "concatsWriter", "conateFiles", "concStream", "ConcatStream", "concatStream"], "combineWriter": ["comboseWriter", "combinerReader", "ComboseFile", "combinateWriter", "combineWalker", "combiseWriter", "combideWalker", "combideReader", "combineRW", "comboseFile", "combinateReader", "combinateFile", "mixineWalker", "combideRW", "mixineWriter", "mixinerReader", "comboseWalker", "combideWriter", "CombineWriter", "combineWrite", "ComboseWriter", "CombineWrite", "combiseFile", "combineReader", "ComboseReader", "combiseWrite", "comboseWrite", "mixinerRW", "mixinerWriter", "CombineReader", "combiseReader", "combinerWalker", "combinerRW", "CombineFile", "ComboseWrite", "mixineRW", "mixineReader", "comboseRW", "comboseReader", "mixinerWalker", "combinerWriter", "combinateWrite"], "concatWriter": ["concilFile", "syncatWriter", "ConcatsWrite", "concWriter", "syncWriter", "syncWrite", "ConcatWrite", "convertWrite", "ConcatsWriter", "concReader", "concatsFile", "ConcatFile", "syncatReader", "concatsReader", "ConcatWriter", "syncReader", "concatDriver", "convertReader", "ConcatDriver", "convertWriter", "concilDriver", "concatReader", "concFile", "convertFile", "syncFile", "ConcatsDriver", "concilWrite", "ConcatsFile", "concatsWriter", "concilWriter", "concatWrite", "convertDriver", "syncatFile", "concWrite", "concatsWrite", "concatsDriver", "syncatWrite"], "fails": ["Frors", "frors", "Fls", "fls", "Falls", " fls", "Fails", "foralls", "ifls", "trors", "Fakes", "forils", "Failed", "infils", "Faults", "foraults", "ifils", "ifakes", "failed", "dfailing", "failing", "tils", "infaults", "tails", "dfils", " failing", "forails", "ifails", " fakes", " fils", "dfails", "falls", "Fils", "Failing", "infails", " failed", "fakes", "fils", "faults", "dfailed", "infalls", "tls", " frors"], "link": [" resource", "image", "match", " comment", "block", "ink", "Link", "comment", "load", "dd", " config", "bug", "parse", "e", " node", "links", "address", "open", " Link", "info", "loc", " tag", " inline", "connection", "li", "message", " site", " http", " target", "line", " entry", " source", " page", " html", "linked", " module", " lang", " document", "l", " item", "style", "follow", " anchor", "uri", "add", " location"], "path": ["PATH", "script", "attr", "entry", "src", "key", "class", "pattern", "input", "id", "attribute", "route", "loc", "info", "code", "Path", "location", "content", "pointer", "value", "wd", "file", "step", "data", "type", "text", "node", "ath", "string", "href", "point", "uri", "source", "filename"], "url": ["image", "r", "sl", "html", "stream", "host", "key", "route", "page", "server", "address", "open", "loc", "result", "connection", "http", "location", "URL", "resource", "pull", "xml", "ssl", "file", "build", "str", "f", "Url", "api", "channel", "data", "download", "ri", "loader", "b", "log", "l", "browser", "string", "web", "uri", "source", "www"], "inputStream": ["InputFile", " inputWriter", "inputChannel", "outputstream", "outputFile", "Inputstream", "InputChannel", "outputStreamer", "downFile", "downStreamer", " inputstream", "outputChannel", "outputReader", "outputWriter", "downStream", "InputReader", " inputFile", "InputStreamer", "InputStream", "inputReader", " inputChannel", "downReader", "inputFile", "InputWriter", "inputStreamer", "inputWriter", "inputstream"], "jsFile": ["jsonFile", "javascriptDir", "scriptSource", "scriptPath", "javascriptReader", " jsWriter", "javascriptPath", "scriptFile", "javascriptStream", "JsFile", "jsStream", "jsfile", "jsWriter", "javascriptWriter", "jsonSource", "JsStream", "javascriptFile", "JsWriter", "javascriptSource", " jsfile", "jsReader", "jsSource", "jsPath", "jsDir", "jsonDir", " jsLog", "Jsfile", "JsReader", "scriptDir", "javascriptfile", "jsLog", "JsLog", "jsonPath", "javascriptLog", " jsReader", " jsStream"], "fileName": ["fileSize", " fileSize", "resourceSize", "fileNumber", " fileNumber", "FilePath", "filePath", "resourcePath", "FileName", " filePath", "FileNumber", "resourceNumber", "FileSize", "resourceName"], "outputStream": ["responseWriter", "outputstream", "OutputStream", "outputFile", " outputReader", "resourceSteam", " outputstream", " outputSteam", "OutputWriter", "responseStream", "outputReader", "responseSteam", "outputWriter", "outputSteam", "inputSteam", " outputWriter", "resourceReader", "OutputFile", " outputFile", "responseReader", "Outputstream", "resourcestream", "resourceStream", "inputFile", "OutputSteam", "OutputReader", "inputWriter"], "first": ["next", "auto", "success", "error", "before", "p", "third", "left", "alpha", "one", "full", "all", "same", "default", "use", "user", "required", "then", "stack", "replace", "last", "th", "result", "found", "only", "top", "count", "now", "root", "must", "start", "second", "st", "primary", "each", "split", "it", "other", "First", "again", "prev", "always", "current", "self", "right", "initial"], "reader": ["r", "image", "in", "writer", "buffer", "h", "Reader", "entry", "stream", "rc", "object", "feed", "context", "input", "e", "handler", "reads", "server", "info", "inner", "report", "resource", "io", "xml", "reading", "file", "f", " Reader", "data", "builder", "loader", "er", "driver", "parser", "read", "dd", "source", "config"], "jsCompressor": ["jsRepress", "jsExpressor", "jsExpression", "jsExporter", "jsReporter", "jsCompress", "jsComporter", " jsCompression", "jsRepression", "jsRepressor", " jsCompress", "jsCompression", "jsExpress", " jsComporter"], "s": ["S", "os", "m", "words", "scripts", "g", "qs", "n", "is", "types", "strings", "xs", "ls", "ns", "comments", "ses", "ens", "es", "t", "gets", "lines", "objects", "states", "ions", "ings", "abs", "en", "fs", "sets", "v", "groups", "l", "ing", "ments", "ss", "gs", "ps", "sys", "ws", "ts"], "s1": ["atsAP", "ats2", "sAP", "ings2", "esB", "s81", "ingsB", "qsIP", "ats1", "ys2", "sPre", "esPre", "esAP", "etsPre", "es1", "etsAP", "ys01", "ings1", "ys1", "es2", "qs2", "qs81", "qs1", "s01", "ets2", "ings01", "ets1", "es81", "sB", "esIP", "sIP", "ysB", "atsPre", "es01"], "i": ["ip", "m", "j", "p", "ic", "is", "ik", "q", "e", "phi", "id", "t", "ui", "ifier", "a", "ii", "z", "bi", "x", "pi", "f", "o", "xi", "u", "b", "v", "w", "l", "ing", "d", "si", "qi", "I", "c"], "s2": ["s62", "esSecond", "etsCloud", "etsSecond", "ets82", "ings2", "sSecond", "qs12", "es82", "esCloud", "sets1", "lsSecond", "ls2", "ings12", "ls62", "setsCloud", "qsSecond", "es1", "ets62", "ings1", "ingsSecond", "es2", "es12", "qs2", "qs1", "ets2", "sCloud", "sets2", "ets1", "es62", "s82", "sets82", "s12", "ls1"], "i1": ["e2", "l1", "e1", "a9", "s9", "iFirst", "pi9", "piFirst", "i0", "a1", "i2", "pi4", "e0", "pi0", "a4", "l2", "sFirst", "s4", "iOne", "pi1", "l0", "i9", "eFirst", "s0", "eOne", "i4", "sOne", "lOne", "a2", "pi2"]}}
{"id1": "19810820", "id2": "18433984", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileStream", "copyfileChan", "transferfileChannel", "copyStreamStream", "copyfileStream", "copyDirectorychannel", "transferFileChan", "copyfilechannel", "copyStreamchannel", "copyStreamChan", "copyFilechannel", "copyDirectoryChannel", "transferfileChan", "copyFileChan", "copyStreamChannel", "transferfileStream", "copyDirectoryChan", "transferFileChannel", "transferfilechannel", "transferFileStream", "copyDirectoryStream", "transferFilechannel", "copyfileChannel"], "src": ["sc", "client", "sl", "sync", "upload", "ctx", "stream", "rc", "func", "s", "tmp", "sit", "slice", "rs", "input", "ls", "ses", "sin", "RC", "server", "sb", "conn", "loc", "source", "scene", "rb", "path", "cur", "inst", "ssl", "img", "dest", "sup", "Source", "dist", "config", "start", "sel", "url", "st", "rest", "download", "sq", "b", "SOURCE", "lower", "sub", "sth", "sys", "ruby", "filename"], "dst": ["bart", "Dost", "bput", "fdST", "stlt", "adrc", " dost", "lddest", "tart", "stst", "dost", "ddest", "dart", " dST", "bst", "fdput", "ldost", " ddest", "dST", "Ddest", "start", "brc", "tST", "Dst", "drc", "ldST", "tst", "dput", "adst", "blt", "tlt", "ldst", "stST", "dlt", "adST", "fdst", "fdrc", "bST", "adput", "DST"], "preserveModificationTime": ["preserveModifiedTime", "preserveModationtime", "preserveMinifiedTime", "preserveMinifiedtime", "preserveModificationFile", "preserveModifyingTime", "preserveMinificationFile", "preserveModifyTime", "preserveModationFile", "preserveModifyingtime", "preserveModifiedFile", "preserveModificationtime", "preserveModifyingFile", "preserveModifytime", "preserveModationTime", "preserveMinifiedFile", "preserveModifiedtime", "preserveMinificationTime", "preserveMinificationtime"], "inputChannel": ["imageGate", "Inputchannel", "imagechannel", " inputSocket", "errorChan", "InputBuffer", "InputSocket", "outputConsole", "InputChannel", "outputCode", "outputChan", "outputStream", "fileChannel", "outputSocket", "outputchannel", "binaryChannel", " inputConnection", "errorStream", " inputStream", "requestChannel", "binaryChan", "inputchannel", "outputCache", "errorCache", "inputConnection", "binaryGate", "requestStream", "requestChan", " inputQueue", "inputQueue", " inputCode", "inputChan", "imageChan", " inputConsole", "inputCode", "inputGate", "fileChan", "outputQueue", "inputBuffer", "requestCode", "fileConsole", "binarychannel", "imageChannel", "inputConsole", " inputBuffer", " inputchannel", " inputCache", "errorChannel", "InputQueue", "outputBuffer", "outputConnection", "inputCache", "inputStream", " inputChan", "outputGate", "fileConnection", "inputSocket", "InputChan"], "outputChannel": ["outStream", "Outputchannel", " outputchannel", "inputButton", "OutputStream", "outchannel", "outChan", " outputQueue", "writeManager", "outButton", "outputChan", "outputStream", "outputManager", "OutputQueue", "outputchannel", "writeChan", " outputStream", " outputChan", "inputChan", "inputManager", "writeQueue", "outChannel", "outputQueue", "writeChannel", "outputButton", "OutputChan", "writeStream", "OutputChannel", " outputButton", " outputManager", "inputStream"], "length": ["next", "position", "buffer", "max", "size", "block", "full", "current", "form", "load", "sequence", "slave", "delay", "section", "id", "limit", "complete", "child", "last", "result", "Length", "sum", "php", "pull", "value", "count", "available", "build", "len", "part", "end", "start", "base", "session", "type", "with", "partial", "offset", "number", "text", "width", "volume", "l", "style", "duration", "head", "lock", "join"], "total": ["toc", "error", "max", "size", "full", "all", "i", "key", "multi", "used", "id", "limit", "valid", "complete", "last", "info", "result", "sum", "found", "failed", "cur", "translation", "Total", "count", "available", "len", "start", "part", "no", "base", "set", "scale", "type", "partial", "offset", "done", "always", "otal", "duration", "current", "less"]}}
{"id1": "11484416", "id2": "10936821", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "label": 0, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "11840277", "id2": "3801655", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "label": 0, "substitutes": {"clearTables": ["clearContaches", "cacheTableables", "cacheTations", "createTows", "clearTemows", "clearTaces", "createTaches", "cacheTings", "clearBings", "clearTableables", "clearTings", "createTables", "createStaches", "cacheTows", "clearBaces", "clearTows", "clearContables", "createTaces", "clearTableings", "clearTaches", "clearBations", "clearBaches", "clearStaces", "clearStows", "cacheTableations", "clearTations", "clearTemations", "clearBows", "cacheTableows", "createStaces", "createStables", "cacheTables", "clearTableows", "clearBables", "clearTemables", "clearTemings", "clearContaces", "cacheTableings", "createStows", "clearStables", "clearStaches", "clearTableations", "clearContows"], "conn": ["db", "ai", "error", "client", "connect", "ca", "Conn", "h", "p", "obj", "ctx", "n", "oss", "cond", "cp", "rc", "cn", "cc", "pg", "ou", "cat", "ns", "bb", "nt", "ci", "lc", "cf", "cache", "coll", "server", "ann", "loc", "open", "dn", "state", "connection", "nc", "dc", "path", "cm", "ob", "ssl", "con", "conf", "wd", "pub", "config", "oci", "ch", "enc", "sql", "exec", "col", "close", "session", "ac", "log", "org", "jc", "ct", "mt", "co", "di", "Connect", "mc", "sth", "Connection", "cmp", "act", "lock", "cb", "c"], "stmt": ["Stml", " stbm", "ldager", "playtor", "STmn", "Stap", "putml", "Stmc", "ssbm", "stmd", "ftbm", "STwd", " stgr", "sttor", "str", "actmt", " stmi", "est", "estmt", "dm", "ctmd", "stm", "Stnt", "ctmt", "stmm", " stml", "tm", "ftmn", "stswd", "dmt", "stmn", " stma", "putmm", "stql", "stwd", " stm", "stbm", " stmn", "stmi", "tmt", "STbm", "stma", "Stmd", "playmt", "stmc", "stMT", "strmt", "ldmt", "ctgr", "strMT", " stap", " str", "Stgr", "actnt", "STmt", "STlt", "STgr", "istmn", " stager", "putwt", "Stmt", "puttx", "Stmn", "ftmt", "stsprint", " stlt", "putma", "putap", "putmt", "strml", "actmi", "sswt", "dql", " stct", "Stm", "putbm", "stlt", " stwt", "ewd", "strlt", "stager", "Sttor", "ldma", "dr", "Stmm", "istmt", "ctm", "Stwt", " stmc", "stap", "playwt", "estwt", "STmd", "STst", "putm", "eprint", "ssmn", "stwt", "stnt", "Stct", "STprint", "stsst", "STmc", "tct", "istMT", "emt", "estmm", "putmn", "sttx", "tnt", "STMT", "stst", "playtx", "stml", "stprint", "Stlt", "actmn", "Sttx", "ldmn", "StMT", "ctr", "stgr", "Stmi", " stmd", " stql", "ssmt", "puttor", "estm", "putlt", "stct", "ftlt", "putager", " stnt", "putMT", "ctql", "istgr", "stsmt"]}}
{"id1": "1421557", "id2": "8330057", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void getHttpURL() throws Exception {\n        boolean display = true;\n        boolean allHeaders = false;\n        String url = null;\n        url = \"http://localhost/cubigraf2\";\n        url = \"http://www.accenture.com/NR/rdonlyres/971C4EEE-24E2-4BAA-8C7B-D5A5133D5968/0/en_sprout.jpg\";\n        url = \"http://www.uni.pt/img/home-direito.gif\";\n        url = \"http://www.google.com\";\n        URLConnection uc = new URL(url).openConnection();\n        println(\"HEADERS:\");\n        if (allHeaders) {\n            Iterator<Map.Entry<String, List<String>>> itHeaders = uc.getHeaderFields().entrySet().iterator();\n            while (itHeaders.hasNext()) {\n                Map.Entry<String, List<String>> e = itHeaders.next();\n                Iterator<?> itValues = e.getValue().iterator();\n                while (itValues.hasNext()) {\n                    println(e.getKey() + \": \" + itValues.next());\n                }\n            }\n        } else {\n            showObjectProperty(uc, \"getContentEncoding\");\n            showObjectProperty(uc, \"getContentLength\");\n            showObjectProperty(uc, \"getContentType\");\n            showObjectProperty(uc, \"getDate\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getExpiration\", FORMAT.TIMESTAMP);\n            showObjectProperty(uc, \"getLastModified\", FORMAT.TIMESTAMP);\n        }\n        ExtendedInputStream in = new ExtendedInputStream(uc.getInputStream(), url.toString());\n        if (display) {\n            println(\"BODY:\");\n            ExtendedReader reader = new ExtendedReader(in);\n            for (String s = reader.readLine(); s != null; s = reader.readLine()) {\n                println(s);\n            }\n        } else {\n            println(\"(BODY saved to a file)\");\n            String contentType = uc.getContentType();\n            StringBuilder filename = new StringBuilder(\"C:\\\\Documents and Settings\\\\Carlos_da_S_Pereira\\\\Desktop\\\\JAVA_NET_TESTS\");\n            filename.append(\".\");\n            filename.append(contentType.substring(contentType.indexOf(\"/\") + 1));\n            File file = new File(filename.toString());\n            ExtendedOutputStream out = new ExtendedOutputStream(new FileOutputStream(file), file.getAbsolutePath());\n            Streams.copy(in, out);\n            out.close();\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "20232250", "id2": "471804", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processResponse", "getrequest", "sendrequest", "writeResponse", "processCommand", "sendResponse", "sendCommand", "processRequest", "writeCommand", "writeRequest", "writerequest", "getRequest", "getResponse", "getCommand", "processrequest"], "seq": ["job", "iq", "p", "contin", "query", "ctx", "batch", "fast", "pos", "eq", "queue", "sequ", "Sequ", "sci", "lic", "flow", "q", "slice", "sequence", "pkg", "cli", "id", "val", "que", "ext", "ref", "file", "rez", "feat", "iter", "sel", "ctrl", "req", "prefix", "vec", " sequence", "sq", "blast", "struct", "spec", "comp", "test", "cl", "sem", "frame", "pse", "config", "ence"], "IOException": ["TimeoutError", "IOError", " IOError", "TimeoutException", "Timeoutception", "IOception", "IPception", "IPException", "IPError", " IOception"], "putBuf": ["putFuf", "putPluff", "printBbuf", " putBob", "logBBault", "putSBuch", " putBuff", "putBsuf", "putBBob", "putBsault", " putWBurb", "fileBump", "putWBuf", "putBaseuf", "printBuf", "putFump", "putTuf", "printFob", " putPluc", "putWBbuf", "putbuff", "cutBuff", "putBouf", "putBsuff", "putWurb", " putPluf", "printFbuf", "printBuff", "putBBault", "putBaseump", "putBbuf", "putFurb", "fileSBuch", "putPluf", "fileBuf", "putBBbuf", "cutbump", "putFbuf", "putBump", "putBuch", "fileSBlf", " putBbuf", "putWuf", "putFuc", "putGBump", "putBundle", "putBsundle", "fileSBump", "cutbuff", "logBBuff", "putSBlf", "putBurb", "putGBundle", " putPluff", "putFob", "putBolf", "putBBundle", "putFuff", "putGBuc", " putPlump", " putBump", "putbuf", "fileBuch", "cutbault", "putTlf", "putSBuf", " putBurb", "putFault", "logBuf", "putBault", "logBuff", "logBBuf", "putWuff", "putBlf", "putWob", "putWBob", "cutbuf", "printFuff", "putPlump", "fileSBuf", "printFuf", "putBBuff", "putBouch", "putbault", "logBundle", "putBaseault", "putGBuff", " putWBob", "printBob", "putWBurb", "putBob", "putSBump", "putGBault", "fileBlf", "cutBuf", " putWBbuf", "putGBuf", "putTuch", "logBBundle", "logBault", " putWBuf", "putBuc", "putBuff", " putBuc", "putbump", "putTump", "cutBault", "putBaseuff", "putBBuf", "putBoump", "putPluc", "putWbuf", "cutBump"], "url": ["lr", "r", "db", "blog", "client", "fr", "sl", "rl", "host", "socket", "impl", "fl", "ls", "il", "www", "coll", "server", "open", "connection", "http", "URL", "resource", "ssl", "file", "ctrl", "f", "Url", "channel", "base", "download", "log", "org", "ll", "l", "string", "web", "ur", "uri", "jar", "source", "c"], "conn": ["r", "db", "client", "connect", "Conn", "p", "sync", "ctx", "n", "cp", "socket", "cn", "rc", "cr", "nt", "ci", "lc", "coll", "loc", "ann", "open", "connection", "nc", "dc", "cur", "io", "fp", "cm", "ssl", "out", "con", "fn", "ctrl", "util", "ch", "enc", "wb", "exec", "close", "conv", "channel", "err", "org", "rt", "ait", "nw", "ct", "pc", "co", "l", "mc", "addr", "Connection", "act", "cb", "c"], "wr": ["r", "fw", "wire", "fr", "writer", "sw", "wal", "WR", "Wr", " Wr", "raft", "rx", "Writer", "dr", "wh", "rss", "war", "rh", "rr", "raw", "shr", "nr", "hr", "rw", "sr", "mr", "wb", "wer", "wl", "wa", "kr", "w", "nw", " writer", "wrap", "wx", "wt", "wk", "spr", "ws", "RW", "wm"]}}
{"id1": "14598566", "id2": "12306305", "code1": "    public static void copyFileByNIO(File in, File out) throws IOException {\n        FileChannel sourceChannel = new FileInputStream(in).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "code2": "    private static void doCopyFile(File srcFile, File destFile, boolean preserveFileDate) throws IOException {\n        if (destFile.exists() && destFile.isDirectory()) {\n            throw new IOException(\"Destination '\" + destFile + \"' exists but is a directory\");\n        }\n        FileChannel input = new FileInputStream(srcFile).getChannel();\n        try {\n            FileChannel output = new FileOutputStream(destFile).getChannel();\n            try {\n                output.transferFrom(input, 0, input.size());\n            } finally {\n                IOUtil.closeQuietly(output);\n            }\n        } finally {\n            IOUtil.closeQuietly(input);\n        }\n        if (srcFile.length() != destFile.length()) {\n            throw new IOException(\"Failed to copy full contents from '\" + srcFile + \"' to '\" + destFile + \"'\");\n        }\n        if (preserveFileDate) {\n            destFile.setLastModified(srcFile.lastModified());\n        }\n    }\n", "label": 1, "substitutes": {"copyFileByNIO": ["copyFileBynIO", "copyFileByMIP", "copyFilebynio", "copyFileByFileIF", "copyFilebynIO", "copyFileByNIP", "copyFilebynIP", "copyFileByMIF", "copyFileBynio", "copyFileByFileio", "copyFilebyNIP", "copyFileByNio", "copyFilebynIF", "copyFileByMIO", "copyFileByNIF", "copyFileBynIF", "copyFilebyNIO", "copyFileByFileIO", "copyFileBynIP", "copyFileByFileIP", "copyFilebyNIF", "copyFileByMio", "copyFilebyNio"], "in": ["image", "m", "buffer", "h", "inn", "i", "input", "copy", "id", "ex", "din", "diff", "or", "connection", "inner", "index", "resource", "io", "ini", "at", "file", "part", "x", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "source", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "p", "n", "output", "object", "copy", "ex", "cache", "to", "conn", "target", "connection", "path", "ext", "resource", "io", "dest", "file", "at", "part", "prefix", "o", "exec", "data", "b", "v", "w", "name", "external", "again", "string", "project", "outs", "source", "OUT", "c", "inc"], "sourceChannel": ["ourceQueue", "srcChannel", "SourceStream", "srcChan", "ourceChan", "sourceChan", " sourceStream", "ourcechannel", "sourceServer", "sinChan", "sinStream", "ourceStream", "innerChan", " sourceQueue", "srcQueue", "srcConnection", "ourceChannel", "targetChannel", "sourceQueue", "targetchannel", "SourceConnection", "targetChan", " sourceServer", "innerStream", "sourceStream", "sourceConnection", " sourceChan", "sinServer", " sourcechannel", "SourceChannel", " sourceConnection", "innerServer", "targetConnection", "Sourcechannel", "innerChannel", "ourceConnection", "sinChannel", "sourcechannel", "SourceChan"], "destinationChannel": ["destributionChan", "DestinationStream", "DestinationChannel", "destinatedChannel", "destributionContext", "DestinatorClient", "destinateConnection", "destionChan", "destinationContext", "destinatedStream", "destroyingConnection", "destinationClient", "DestinationConnection", "destinatorConnection", "destroyingStream", "destionClient", "DestinationContext", "destributionConnection", "destinateStream", "destributionStream", "destinationConnection", "destributionChannel", "destinatorChannel", "destinateChannel", "DestinatorContext", "DestinationClient", "destionConnection", "DestinationChan", "DestinatorConnection", "destionChannel", "destinationStream", "destinatorClient", "destributionClient", "destinatorContext", "destinatorChan", "destroyingChannel", "DestinatorChan", "destinatedContext", "DestinatorChannel", "destinatedChan", "DestinatorStream", "destinatorStream", "destinationChan"]}}
{"id1": "21125261", "id2": "15580610", "code1": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void trainClassifier(File dir, String... args) throws Exception {\n        String[] command = new String[args.length + 3];\n        command[0] = this.getCommand();\n        System.arraycopy(args, 0, command, 1, args.length);\n        command[command.length - 2] = new File(dir, \"training-data.libsvm\").getPath();\n        command[command.length - 1] = new File(dir, this.getModelName()).getPath();\n        Process process = Runtime.getRuntime().exec(command);\n        IOUtils.copy(process.getInputStream(), System.out);\n        IOUtils.copy(process.getErrorStream(), System.err);\n        process.waitFor();\n    }\n", "label": 1, "substitutes": {"test": [" eval", "tests", " process", "run", "Train", "train", "evaluate", " sample", " simulate", " solve", " tests", " testing", " deploy", " run", "Main", "execute", " evaluate", " validate", " verify", " check", " train", " analyse", " example", "Test"], "is": ["lis", "os", "in", "ai", "mis", "Is", "bis", "iso", "stream", "isa", "src", "i", "s", "its", "ls", "ses", "id", "isi", "es", "ris", "gets", "IS", "info", "iss", "ios", "has", "ir", "out", "iris", "ais", "fs", "serv", "opens", "does", "ins", "res", "ics", "as", "si", "ps", "ists", "ws"], "byteArrayOutputStream": ["byteArrayFileFile", "byteArrayInputFile", "byteStringOutputPath", "byteArrayIOStream", "byteArrayIOFile", "byteArrayOutputPath", "byteArrayByteFile", "byteArrayFileString", "byteStringOutputStream", "byteStringOutputSteam", "byteArrayFileStream", "byteStringOutputFile", "byteArrayoutputSteam", "byteArrayByteSteam", "byteStringInputStream", "byteArrayInputString", "byteArrayByteStream", "byteArrayOutputString", "byteArrayoutputContext", "byteStringInputPath", "byteArrayoutputStream", "byteArrayOutputFile", "byteStringInputSteam", "byteArrayOutputSteam", "byteArrayOutputContext", "byteArrayInputStream", "byteArrayIOString", "byteArrayoutputPath", "byteStringInputString", "byteStringOutputString", "byteArrayFileSteam", "byteArrayFilePath", "byteStringInputFile", "byteArrayByteString", "byteArrayIOSteam", "byteArrayInputSteam", "byteArrayFileContext", "byteStringOutputContext", "byteStringInputContext", "byteArrayInputContext", "byteArrayInputPath"], "def": ["der", "de", "obj", "DE", "entry", "dem", "class", "decl", "bus", "defined", "init", "default", "define", "parse", "e", "id", "md", "info", "Def", "desc", "report", "ref", "df", "conf", "file", "dist", "dir", "f", "this", "base", "definition", "des", "data", "spec", "di", "frame", "d", "pro", "da", "dev", "re", "config", "DEF"], "se": ["ne", "su", "sc", "de", "service", "sl", "inse", "ie", "sec", "entry", "sche", "ce", "ste", "ane", "s", "sk", "sea", "sed", "parse", "e", "ses", "ze", "cle", "es", "per", "sh", "fe", "ase", "be", "ve", "sle", "see", "lex", "SE", "ge", "sel", "ke", "est", "zip", "pe", "ine", "sem", "so", "me", "ade", "site", "ss", "pse", "spe", "si", "le", "te", "ser", "sp"], "linkId": ["feedLength", "LinkInfo", "feedInfo", "lineId", "linkLength", "linkid", "lockId", "lockById", "lineById", "feedId", "LinkLength", "linkInfo", " linkById", " linkInfo", " linkLength", " linkid", "LinkId", "feedid", "lockInfo", "Linkid", "lineInfo", "linkById"], "segmentId": ["segmentsId", "selementID", " segmentType", "negementCount", "segmentID", "selementCount", " segmentsID", " segmentCount", "segmentNumber", "sementInfo", "segmentCount", "negmentCount", "selementId", "segmentsCount", "sementNumber", " segmentsId", "sementCount", "negementNumber", "segementNumber", " segmentID", "negementInfo", "segmentsType", " segmentsType", "segmentsID", "negmentInfo", "negementId", "segmentType", "segementCount", "segementId", "sementType", "negmentNumber", "sementID", "segmentsNumber", "selementType", " segmentsCount", "segementInfo", "segmentsInfo", "sementId", "negmentId", "segmentInfo"], "linkSegments": ["linkConnectgments", "lineSegles", "linkIncreines", "linkSegines", "linkEngines", " linkSegment", "linkFraggments", "linkEngments", "lineSegment", "linkIncregments", " linkEnggments", " linkSegures", "linkEngment", "linkIncrement", "linkFragments", "lineSegments", "linkConnectments", "lineSeggments", "linkFragles", "linkIncrements", " linkEngures", "linkSegment", "linkSegles", "linkSeggments", "lineFragment", "linkIncreles", "linkEnggments", "linkFragures", " linkEngments", "linkConnectures", "lineFragments", " linkSeggments", "lineSegines", "lineFragles", "linkEngures", "linkConnectment", "lineFragines", "linkFragment", "lineFraggments", " linkEngment", "linkFragines", "linkSegures", "linkEngles"], "segments": ["Seggments", "schegment", "gegs", "bements", "segements", "peplings", "begments", "sements", "schegments", "Segments", "geplings", "schements", "gements", "seplings", "begment", "Seggements", "segment", "pegment", "gegment", "pements", "begs", "gegments", "pegs", "Seggment", "pegments", "scheplings", "segs", "pegements", "gegements"], "frameProperties": ["framePropperties", " frameProblems", "frameproblems", "frameproeters", " frameProeters", "frameProproperties", "frameprops", "framePromperties", "framePromps", "framePropeters", " frameProps", " frameproblems", " frameProproperties", "frameProeters", "framePropproperties", "framePrometers", "framePropblems", "frameproproperties", " frameprops", " frameproproperties", "framePropps", "frameProps", " frameproeters", "frameProblems", "framePromproperties", " frameproperties", "frameproperties"], "time": ["image", "video", "timeout", "cost", "rate", "size", "h", "ice", "vel", "TIME", "e", "id", "delay", "port", "t", "weight", "sleep", "change", "work", "count", "step", "file", "clock", "value", "start", "etime", "x", "f", "once", "depth", "money", "end", "Time", "data", "type", "tim", "date", "v", "live", "now", "activity", "times", "name", "age", "speed", "loop", "c", "duration", "event", "play", "ime", "length", "timer"], "vehicle": ["vehish", "venical", "verticles", " vehicles", "vehline", "verticular", "vehometry", "bridical", "bridicle", "vehocity", " vehicular", "Vehicle", " mobish", " vehline", "driocity", "bridocity", "Vehicles", "venicle", "verticle", "Vehicular", " mobicles", " vehology", "bridometry", "driical", "Vehline", "vehicles", "vehicular", " mobline", "driicle", " mobicle", " vehish", "venocity", "vehical", "vehology", "venometry", "Vehish", "Vehology", "driometry", "vertology"]}}
{"id1": "12066447", "id2": "16798376", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    @Override\n    public void run() {\n        try {\n            FTPClient ftp = new FTPClient();\n            try {\n                ftp.connect(\"localhost\", 21);\n                ftp.login(\"ftpuser\", \"ftpuser123\");\n                System.out.println(\"Current: \" + ftp.printWorkingDirectory());\n                System.out.println(\"Dir status: \" + ftp.makeDirectory(DIR));\n                ftp.changeWorkingDirectory(DIR);\n                System.out.println(\"File status: \" + ftp.storeFile(FILE_PREFIX + this.getName(), getByteInputStream()));\n            } finally {\n                ftp.disconnect();\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"truncate": ["tratenator", "trunational", "trrenate", "trunator", "trunate", "truncation", "autuncational", "autuncation", "tratenational", "autatenation", "autuncator", "truncator", "tratenation", "autatenator", "tratenate", "autuncate", "autatenational", "autatenate", "trrenator", "truncational", "trrenation", "trrenational", "trunation"], "file": ["get", "image", "db", "one", "stream", "full", "files", "queue", "class", "object", "future", "e", "parent", "page", "directory", "handler", "archive", "File", "cache", "address", "per", "plus", "info", "or", "format", "connection", "http", "path", "resource", "fp", "single", "io", "time", " File", "out", "function", "FILE", "ile", "line", "f", "url", "binary", "this", "base", "model", "zip", "data", "type", "log", "local", "it", "document", "name", "l", "body", "string", "folder", "uri", "current", "source", "filename"], "backupRoot": ["backupsPath", "backUproot", "backupsRoot", "backdownRoot", "backuproot", "backdownroot", "Backbackroot", "backupDirectory", "backUpDir", "backflowroot", "backureDirectory", "frontdownroot", "backflowDir", "frontdownFolder", "frontupDir", "BackureRoot", "backbackroot", "backbaseDirectory", "backupDir", "BackdownRoot", "BackureDirectory", "frontuproot", "backupHome", "backbackDir", "backupFile", "Backuproot", "BackupHome", "backUpFolder", "backflowRoot", "backbaseRoot", "backbackFile", "backUpRoot", "BackupRoot", "backureDir", "BackupDirectory", "backdownDir", "backdownHome", "backbaseroot", "backureRoot", "backbackHome", "backdownFolder", "backupsDir", "backdownDirectory", "backbasePath", "BackupPath", "backureHome", "backflowFile", "frontupFolder", "backdownFile", "frontdownRoot", "BackbackRoot", "frontupRoot", "frontdownDir", "backupsFolder", "BackdownDirectory", "backbackDirectory", "BackdownPath", "backupsroot", "backupPath", "BackbackFile", "backupFolder", "BackureDir", "BackbackDir", "backdownPath", "Backdownroot", "BackupFile", "backupsDirectory", "backbackRoot", "BackupDir", "BackureHome"], "df": ["db", "pdf", "fr", "de", "bf", "def", "flow", "fd", "dict", "cf", "pd", "xf", "md", "sf", "fe", "dn", "format", "dc", "fb", "af", "deb", "fp", "dt", "io", "raf", " def", "fn", "fc", "ds", "f", "fs", "CF", "dm", "data", "dl", "DF", "di", "d", "tf", "da", "dq", "dd", "func", "dp"], "date": ["db", "stage", "atom", "m", "j", "sync", "fee", "form", "output", "pre", "use", "created", "input", "year", "version", "bug", "valid", "rule", "complete", "open", "diff", "updated", "module", "format", "code", "time", "day", "D", " Date", "dt", "message", "modified", "work", "dat", "out", "value", "str", "ale", "days", "x", "min", "ge", "url", "update", "data", "type", "pe", "log", "tag", "ate", "dose", "name", "custom", "d", "string", "age", "style", "Date", "re", "back", "create", "dates"], "zipFile": ["zfile", "zFiles", "ressModel", "ZipFiles", "ZipEntry", " zipFiles", "sqlfile", "zipfile", "ZipFile", "zFile", "sqlModel", "Zipfile", "zEntry", "ressfile", "zipEntry", " zipfile", "ressFile", "zipFiles", "zModel", "zipModel", "zSection", "ressSection", "zipSection", "sqlSection", "sqlFile", " zipEntry"], "zos": ["os", "ils", "dylib", "inos", "nox", "dos", "zag", "zb", "proxy", "uz", "ls", "lins", "ses", "han", "ros", "zon", "css", "iffs", "zan", "address", "zn", "bitcoin", "zy", "los", "zona", "zx", "tz", "liquid", "zi", "cos", "zero", "bes", "jas", "hess", "exit", "ssl", "z", "nz", "closure", "budget", "rez", "osi", "ZA", "zo", "cash", "zar", "zen", "zip", "eros", "chini", "zes", "her", "las", "zik", "ozo", "zer", " sands", "fits", "ops", "settings", "forge", "bos", "zzy", "obb", "robe", "js", "gz", "outs", "zh", "kos", "webkit", "asio", "zl"], "fis": ["lis", "flisp", "rafis", " fiz", "viz", " fias", " fos", "vis", "bis", "infias", "flris", "bisl", "Fisl", " fisl", "fiz", "fias", "infis", " fris", "flias", "rafris", "Fos", "rafiss", "infils", "flis", "fliss", "rafias", "infiss", " fiss", "fisp", "infits", "biss", "flids", "lids", "fids", "vits", "fris", " fils", "fisl", "infids", "fiss", "Fias", "lias", "fits", " fits", "fils", "liss", "bos", " fisp", "fos", "Fris", "infiz", "Fis", "vils", "Fisp", "Fiss"], "entry": ["next", "r", "image", "auto", "the", "ace", "de", "card", "obj", "term", "ie", "element", "cel", "key", "cell", "comment", "feed", "e", "lc", "ry", "archive", "server", "address", "per", "info", "ui", "or", "array", "exp", "index", "se", "z", "row", "ge", "zo", "letter", "zip", "data", "her", "offset", "it", "record", "ries", "so", "Entry", "style", "reader", "ion", " Entry", "si", "and", "uri", "extra", "add", "event"], "buffer": ["position", "pad", "writer", "bytes", "shape", "batch", "FFER", "queue", "transfer", "comment", "feed", "slice", "sequence", "reference", "bb", "page", "Buffer", "cache", "server", "address", "result", "padding", "beta", "buff", "row", "uffer", "available", "iter", "buf", "binary", "channel", "device", "null", "data", "b", "border", "number", "wave", "memory", "reader", "header", "seed", "vector", "flush", "layer", "length"], "readed": ["readered", "readED", "intended", "bootable", " ReadED", "inputned", " readended", " readered", "readized", "inted", "bootED", " readED", " readable", "readable", "inputled", " Readered", "readned", " Readed", " readized", "inputED", "bootered", " readned", "textended", " Readable", " Readled", " Readned", "texted", "readended", "intED", "textized", " readled", "booted", "textED", "intized", "inputed", "readled"]}}
{"id1": "3024992", "id2": "8921716", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_nulls"], "baout": ["Baash", "aeOUT", "BAin", "bonin", "baouts", "BaOut", "BAout", "BAouter", " bain", "bain", "aeouter", " baOut", "Bain", "baOUT", "baash", "bonash", "Baio", "baio", "BAio", "BaOUT", "BAOut", "Baout", "BAouts", "baouter", "Baouter", "bonout", "bonio", "aeout", " baouts", "baOut", "Baouts", "BAOUT", "aeOut", "BAash"], "out": ["Out", "r", "in", "buffer", "flow", "output", "class", "s", "write", "copy", "Writer", "array", "io", "line", "file", "Output", "null", "err", "er", "test", "reader", "outs", "outer", "OUT", "able"], "writer": ["r", "in", "buffer", "worker", "entry", "output", "class", "write", "copy", "ee", "Writer", "pointer", "writers", "io", "work", "file", "riter", "x", "rw", "letter", "null", "unit", "data", "temp", "wer", "builder", "her", "player", "er", "wa", "w", "driver", "writ", "reader", "outer", "writing", "source", "RW"]}}
{"id1": "22993368", "id2": "15409512", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void main(String args[]) throws IOException {\n        String inFileName = args[0];\n        String outFileName = args[1];\n        long position = 0L;\n        try {\n            position = Long.parseLong(args[2]);\n        } catch (NumberFormatException nfex1) {\n            try {\n                position = Long.parseLong(args[2], 16);\n            } catch (NumberFormatException nfex2) {\n                System.err.println(\"Wrong offset\");\n                System.exit(0);\n            }\n        }\n        if (position < 1L) {\n            System.err.println(\"Wrong offset. Must be more than 0\");\n            System.exit(0);\n        }\n        System.out.println(\"Copying  input: \" + inFileName);\n        System.out.println(\"        output: \" + outFileName);\n        System.out.println(\"          from: \" + position);\n        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(inFileName));\n        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(outFileName));\n        bis.skip(position);\n        for (byte[] b = new byte[1]; bis.read(b) > 0; bos.write(b)) ;\n        bis.close();\n        bos.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "7891509", "id2": "9846843", "code1": "    public PageLoader(String pageAddress) throws Exception {\n        URL url = new URL(pageAddress);\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        inputLine = \"\";\n        while (in.ready()) {\n            inputLine = inputLine + in.readLine();\n        }\n        in.close();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 0, "substitutes": {"pageAddress": ["Pageaddress", "pageName", "siteName", "urlUrl", "resourceaddress", "siteAddress", "urladdress", " pageLocation", " pageName", "PageUrl", "siteLocation", "urlLocation", "resourceLocation", "PageName", "pageaddress", "resourceAddress", "urlAddress", "PageAddress", " pageUrl", "pageLocation", "resourceUrl", "PageLocation", "siteUrl", "pageUrl"], "url": ["r", "image", "client", "service", "sl", "element", "stream", "i", "host", "socket", "object", "feed", "user", "ls", "bb", "page", "server", "address", "open", "connection", "http", "URL", "resource", "ssl", "out", "file", "f", "Url", "this", "channel", "base", "data", "loader", "b", "l", "browser", "plugin", "reader", "string", "web", "uri", "source"], "in": ["r", "client", "buffer", "inn", "stream", "gin", "isin", "i", "socket", "s", "init", "impl", "input", "id", "din", "conn", "inner", "resource", "nin", "ssl", "out", "line", "ini", "rec", "file", "kin", "into", "inside", "min", "f", "login", "data", "err", "b", "token", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "read", "win", "source", "c", "inc"], "inputLine": ["InputFile", " inputPage", " inputline", "rawLine", "imageL", "inputString", "InputL", " inputCell", "rawline", "InputCell", "inputL", " inputL", "selectLine", "inputUrl", "rawPage", "rawContent", " inputContent", "InputLine", "pageLine", "selectPage", "imageFile", " inputString", "rawFile", " inputFile", "pageline", "inputline", "rawString", " inputUrl", "inputContent", "imageLine", "imageCell", "inputFile", "selectFile", "rawUrl", "selectContent", "inputPage", "inputCell", "pageString", "pageUrl"]}}
{"id1": "8266672", "id2": "4461350", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 1, "substitutes": {"updatePicInfo": ["updatepicInfo", "updatePicInf", "savePicinfo", "saveImageinfo", "updatepicinfo", "updatePictureInfo", "updatePicinfo", "savePicInfo", "updatePictureinfo", "updateImageInfo", "updateImageInf", "updateImageinfo", "saveImageInf", "updatePictureInf", "savePicInf", "saveImageInfo", "updatepicInf"], "conn": ["orp", "db", "client", "connect", "ca", "Conn", "sync", "ctx", "oss", "stat", "cp", "rc", "cn", "cc", "pg", "cat", "cr", "cli", "nt", "ci", "mn", "core", "server", "coll", "cf", "reg", "loc", "ann", "gn", "dn", "connection", "nc", "dc", "pool", "manager", "con", "conf", "config", "pub", "en", "util", "col", "ch", "enc", "serv", "exec", "conv", "session", "rt", "jc", "ct", "pc", "co", "mc", "sys", "cms", "cmp", "act", "cmd", "cb", "c", "vol"], "nr": ["lr", "r", "gr", "fr", "ner", "nor", "n", "rl", "eni", "ctr", "chain", "nn", "orr", "rx", "mn", "sn", "dr", "ru", "adr", "rb", "radius", "our", "num", "nc", "nis", "rr", "nir", "rin", "wr", "rar", "sr", "NR", "mr", "dir", "rf", "rw", "nil", "major", "err", "ni", "range", "nick", "nw", "number", "nie", "inv", "rn", "yr", "vr", "arr", "counter", "nl", "nb", "random", "nar", "usr", "np", "lvl"], "lock": ["lr", "locks", "gr", "max", "pin", "sync", "sl", "ok", "block", "locking", "rc", "delay", "sol", "lc", "limit", "sn", "locked", "loc", "lin", "bl", "pull", "ssl", "Lock", "row", "len", "dir", "min", "zip", "lang", "rel", "live", "ock", "ll", "cl", "number", "arr", "l", "ml", "list", "pl", "LOCK", "lvl", "length"], "picInfo": ["pinInit", "pixelINFO", "moduleLi", "pinInfo", "collInf", "PicConf", "picINFO", "picSetup", "PicInf", "syncInf", "niceInf", "niceSetup", "pictureInf", "picEx", "collEx", "moduleInf", "pixelArea", "pinArea", " picInf", "pictureINFO", "kinSync", "picObj", "collINFO", "pictureArea", "pictureStyle", "picUpdate", "moduleInfo", "moduleINFO", "PicINFO", "iconInf", "pixelInfo", "studyInfo", "picInf", " picEx", "syncLi", "PicEx", "kinInfo", "iconStyle", "pictureObj", "pictInfo", "pictureInfo", "kinStyle", "iconInfo", "picInit", "styleSetup", " picINFO", "studyObj", "pictureId", "PicSetup", "pictType", "styleInfo", "studyUpdate", " picType", "syncInfo", "pictureUpdate", "pictureLi", "styleInf", "PicType", "picSync", "kinInf", "pinId", "PicInfo", "syncINFO", "pictInf", "picStyle", "niceConf", "pinInf", "pinUpdate", "picType", "pictureSync", "collInfo", "PicObj", "pinObj", "pictureInit", "niceInfo", "pictId", "pictObj", "picConf", "styleConf", " picInit", "picArea", "picLi", "picId", "studyInf", "iconSync", "pixelInf", " picObj", " picArea"], "sql": ["generic", "sync", "s", "comment", "sk", "ln", "serial", "http", "params", "fn", "str", "sq", "lang", "dl", "shell", "string", "tf", "uri", "cmp", "db", "details", "sl", "lambda", "html", "rl", "QL", "summary", "json", "loc", "lv", "pool", "err", "ll", "status", "utils", "sal", "job", "su", "email", "msg", "ls", "pkg", "cli", "lc", "limit", "sf", "result", "reason", "ssl", "function", "util", "url", "serv", "log", "printf", "kl", "auth", "ql", "nl", "seed", "sv", "filename", "tool", "socket", "install", "il", "sn", " SQL", "sol", "SQL", "sg", "rup", "xml", "csv", "zip", "session", "eps", "general", "sys", "select"], "pstmt": ["prestcl", "pstdtp", "pflmt", "pustsp", "pusttool", "ipstnl", "pstert", "psthrm", "pctmb", "Postmt", "ppstsp", "pstrtr", "pestmb", "pconstm", "ipstrnl", "pstatmc", "ppstql", " pftmn", " pftrt", "Pstret", "Pstpt", "pfmb", "lpstmt", "prestmn", "ipstrpm", "pclmn", "prestmd", "prsthmt", "psthtool", " pftmm", "pestsp", "pctpt", "pestau", "prestmb", "ppesttool", "pfmt", "putmt", "pstmc", "psthmc", "ppestql", "pstdemb", "ppstmb", "postmd", "pstatt", " pstemb", "ppmb", "pfrm", "pdm", "ppestmt", " pstert", "pdmn", "preostmn", "pstdm", "ppatt", "perstsmt", "pconstpm", "postret", " postmd", " pstm", "ppstdr", "pprmb", "lpsttr", "pstsmt", "Pctm", "pctcl", "perstmc", "pstdtool", " pstmb", "pctpm", "pctdr", "pstret", "pstau", "pctm", "pfcl", "pstpm", "pctmt", "ppmt", "pestatt", "pctgr", "putdr", "prestnl", "pflert", "pflm", "prstbh", "prestpm", "pfm", " pfmn", "ipstmt", "pstpl", "pstsgr", "ppsthmt", "postm", "presttool", "prsthmb", "Postmon", "pstrm", "pfpt", "postmon", "hstmn", "pctpl", "Pstmt", "lpstrtr", " pstrel", "lpstgr", "ppsthgr", "pconstql", "pftemb", "pctmd", "pustql", "pprmt", "hsttor", "prstmt", "pestmt", "pstsrm", "psthcl", "pstrret", "lpstm", "pconstcl", "ppstmd", "perstsmc", "postmb", "ppstgr", "postmn", "Pctmt", " pfm", "ppbh", "pprrm", "pfttp", "pfbh", "prsthql", "pstdrel", "pftmt", "psthrel", " postrel", "pcttr", "psthm", "pctrel", "pstsp", "pstrpm", "pdmt", "postau", "psthmt", "psthdr", "prstatt", "pdpl", "postmt", "perstsrm", "psthgr", "pclbh", "pconstmb", " pfmt", "lpstrmt", "pconstmn", "pstmb", "pustmt", "pftmn", "Pstmb", "Pctpl", "perstsgr", "Pstmon", " postm", "pconstpt", "ipstpm", "prestql", "pclmt", "pstdmn", "pstatmt", "ppestsp", "postrel", "preostau", "ipstrmt", " pstrm", "Pstm", "psthmn", "pstdr", " pfrel", "lpstrgr", "psctor", "psthrt", "lpstrm", " postert", "ppsthmd", "psttr", "pftmm", "postcl", "pscbh", "pptp", "putmd", "Pstpl", "pstdert", "Postret", "pctmn", "pstrgr", "pstpt", "pfatt", "prpmb", "psthql", "pfret", "perstrm", "pstgr", "pstemb", "pestcl", "pstddr", "Pstmn", "psttool", " pfrm", "pstrrt", "pstnl", " pfttp", "pestql", " pstcl", "perstmt", "ppstmt", "pstmon", "pfrel", "prestrel", "hstbh", "pscmt", " pfmb", " postmb", "pestbh", "pscpm", "pestdr", "postert", " pfcl", "Pctmb", "pstrnl", "pstmm", "prpbh", " psttp", "pstrmon", "pestgr", "prpmt", "pstsmc", " pstrt", "prpatt", "pstmd", "psttor", "pstmn", "prstql", "prestsp", "prstmb", "pprmn", "pstql", "pstatrm", "pstm", "ppsthdr", "preostcl", "ppmn", "Postmn", "perstgr", "pstrmt", "ppsttool", "psthmb", "ipstrtr", "pscnl", "prestau", " pstmn", "psthpm", "psctr", "puttool", "prsthpm", " pftmt", "ipsttr", "ppsthtool", "pstrmn", "prstpm", "pstatgr", "pfmon", "pstrmm", "pesttool", " pftemb", "pstrt", "pftrt", " pstmm", "pctql", "pcltor", "prestmt", "pstrpl", "pctrm", " pstmd", "pflrel", "pconstmt", "ppemb", "pscmn", "psthmm", "pstdmd", "psttp", "psthmd", " postmt", "ppsthmb", "hstmt", "preostmt", "presttr", "pstdmt", "pstrel", "pstcl", "pfmn", "pestmn", "pconstau", "Pctmn", "pstbh", "psthtr", "Pctpt"]}}
{"id1": "9257487", "id2": "21488518", "code1": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "code2": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"downloadFile": ["copyFile", "copyResource", " downloadFiles", "DownloadFile", "Downloadfile", "copyFiles", "copyfile", " downloadfile", " downloadResource", "DownloadFiles", "DownloadResource", "downloadResource", "downloadFiles", "downloadfile"], "from": ["From", "html", "src", "form", "host", "user", "route", "address", "module", "or", "connection", "code", "a", "path", "resource", "at", "file", "part", "link", "f", "prefix", "base", "data", "with", "range", "name", "by", "remote", "project", "as", "folder", "uri", "about", "source"], "to": ["os", "too", "flo", "output", "socket", "route", "office", "po", "To", "address", "target", "or", "location", "TO", "path", "resource", "io", "file", "storage", "prot", "prefix", "o", "eto", "until", "base", "temp", "with", "download", "range", "token", "so", "name", "remote", "as", "addr", "uri", "about", "source", "repl"], "pm": ["mm", "m", "prem", "p", "pp", "prom", "dem", "pa", "cp", "wm", "gp", "po", "PM", "monitor", "meter", "fm", "vm", "um", "bm", "rm", "lp", "cm", "pool", "pb", "pi", "mr", "sm", "dm", "jp", "im", "wp", "mi", "em", "pc", "sem", "tm", "mp", "rpm", "pro", "gm", "px", "pl", "pt", "pr", "sp"], "out": ["Out", "timeout", "client", "writer", "self", "obj", "sync", "i", "output", "socket", "input", "write", "copy", "parent", "cli", "connection", "inner", "ext", "io", "line", "file", "o", "exec", "login", "err", "temp", "log", "w", "net", "bin", "In", "OUT", "as", "string", "again", "reader", "outs", "outer", "cmd", "source", "up", "inc"], "url": ["image", "client", "fr", "sl", "i", "socket", "el", "impl", "fl", "www", "server", "bel", "open", "loc", "connection", "http", "fb", "URL", "resource", "ssl", "con", "file", "f", "Url", "lib", "channel", "base", "zip", "download", "log", "b", "er", "org", "ll", "l", "web", "ur", "uri", "source", "c"], "conn": ["client", "connect", "Conn", "p", "sync", "ctx", "n", "g", "apt", "cp", "socket", "cn", "lc", "ci", "coll", "open", "ann", "connection", "nc", "dc", "http", "cur", "cm", "ssl", "con", "pub", "en", "f", "ch", "enc", "close", "exec", "conv", "b", "l", "mc", "cms", "Connection", "lock", "act", "cb", "c"], "in": ["r", "client", "n", "inn", "stream", "isin", "i", "is", "socket", "s", "init", "cin", "impl", "input", "din", "lin", "connection", "inner", "io", "nin", "ssl", "ini", "con", "file", "inside", "f", "exec", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "c", "inc"], "buffer": ["position", "bytes", "size", "batch", "shape", "queue", "feed", "slice", "input", "reference", "write", "bb", "Buffer", "limit", "cache", "address", "source", "result", "padding", "message", "buff", "raw", "row", "uffer", "iter", "buf", "binary", "null", "base", "data", "b", "offset", "wave", "memory", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["get", "ind", "ask", "connect", "rate", "size", "ok", "sync", "Read", "block", "current", "old", "transfer", "use", "feed", "load", "input", "slice", "write", "parse", "reads", "check", "run", "open", "seek", "index", "READ", "io", "se", "sleep", "readable", "work", "send", "count", "reading", "fill", "find", "lex", "raw", "start", "iter", "x", "f", "close", "end", "pass", "exec", "k", "download", "b", "wait", "allow", "ride", "text", "number", "skip", "reader", "play", "loop", "add", " write", "create", "length", "select"]}}
{"id1": "17190057", "id2": "16092702", "code1": "    private static String encode(final String input) throws UnsupportedEncodingException, NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.reset();\n        md.update(input.getBytes(\"UTF-8\"));\n        return toHexString(md.digest());\n    }\n", "code2": "    public static boolean doTest(Getter<?> context, Document node) {\n        try {\n            URL url = new URL(StringUtil.evaluateEL(Documents.getDocumentValue(node, \"url\"), context));\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            Assert.isTrue(conn.getResponseCode() < 400);\n            conn.disconnect();\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n", "label": 0, "substitutes": {"encode": ["unode", "uncode", "encescape", "enccode", "Enescape", "enode", "Enode", "unescape", "Encode", "enescape"], "input": ["request", "image", "in", "buffer", "amp", "alpha", "stream", "def", "i", "output", "form", "pattern", "crypt", "context", "instance", "address", "plus", "inf", "result", "format", "array", "audio", "ssl", "img", "raw", "str", "secure", "addin", "binary", "this", "null", "prefix", "xxx", "data", "temp", "Input", "text", "password", "reader", "string", "empty", "source", "config", "hex"], "NoSuchAlgorithmException": ["NoSuchAlryptionement", "NoSuchAlodingement", "NoSuchEdgorithmement", "NoSuchEdgorithmWarning", "NoSuchAlgoException", "NoSuchAlgoement", "NoSuchEdryptionWarning", "NoSuchAlgoWarning", "NoSuchAlodingError", "NoSuchEdgorithmException", "NoSuchAlryptionException", "NoSuchAlodingException", "NoSuchAlgorithmError", "NoSuchEdryptionException", "NoSuchAlryptionError", "NoSuchAlryptionWarning", "NoSuchEdryptionError", "NoSuchAlgoError", "NoSuchAlgorithmement", "NoSuchEdgorithmError", "NoSuchAlodingWarning", "NoSuchAlgorithmWarning", "NoSuchEdryptionement"], "md": ["mm", "mac", "mo", "db", "m", "dig", "mad", "key", "ad", "pd", "metadata", "um", "ma", "od", "code", "dc", "cd", "sum", "message", "amd", "mb", "nm", "df", "wd", "mand", "bd", "doc", "dm", "zip", "pm", "sha", "mi", "mt", "MD", "mp", "me", "mc", "mod", "mag", "hd", "d", "ms", "meta", "hash", "cmd", "dd", " MD"]}}
{"id1": "6866575", "id2": "15166511", "code1": "    @Primitive\n    public static Value caml_md5_string(final CodeRunner ctxt, final Value str, final Value ofs, final Value len) throws Fail.Exception {\n        try {\n            final MessageDigest md5 = MessageDigest.getInstance(Md5.ALGO);\n            md5.update(str.asBlock().getBytes(), ofs.asLong(), len.asLong());\n            return Value.createFromBlock(Block.createString(md5.digest()));\n        } catch (final NoSuchAlgorithmException nsae) {\n            Fail.invalidArgument(\"Digest.substring\");\n            return Value.UNIT;\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"caml_md5_string": [" icl_md512_String", " icl_md512_double", " icl_md5_string", " icl_md5_double", " icl_md512_string", " icl_md5_ring", " icl_md5_String", " icl_md512_ring"], "ctxt": ["ceext", "ntxt", "cext", "ctext", "CTxt", "CTXT", "ceXT", "cetx", "ctXT", "CTtx", "ntXT", "cttx", "ntext", "CText", "nttx"], "str": ["STR", "r", "in", "fr", "seq", "sl", "obj", "br", "ctr", "strings", "cr", "Str", "val", "dr", "format", "code", "exp", "inner", "cur", "hr", "f", "enc", "st", "pass", "exec", "data", "err", "div", "spec", "char", "er", "text", "arr", "name", "style", "string", "prev", "hash", "tr", "self", "hex", "sp"], "ofs": [" ofn", "Ofn", "Ofills", "Ofsets", "dird", "OFd", "dirs", " OFd", "ofills", "dirstates", "Ofd", "ofn", "OFs", "Ofs", "ofd", "OFstates", " ofills", "ofstates", " OFn", " OFills", "dirsets", " OFs", " ofd", "ofsets", "OFsets", "Ofstates"], "len": ["fin", "in", "seq", "size", "lf", "sl", "n", "pos", "block", "fd", "el", "lt", "ln", "ls", "val", "span", "lin", "bl", "li", "line", "Len", "lit", "fn", "count", "en", "rev", "buf", "enc", "lib", "vec", "offset", "ll", "split", "l", "ld", "le", "mem", "length", "sp"], "md5": ["mddown", "dd4", "sha15", "MD2", "md4", "mand5", "dig3", "MD5", "dd5", "sha5", "sha3", "md8", "sha20", "md15", "sha8", " mddown", "md3", "md2", "mand15", "dig15", " md75", " md3", "mand20", "dd2", "md55", " md4", "md20", "dd75", "dig8", "sha55", "digdown", "shadown", "dig5", " md8", "dig20", "MD4", "md75", "mand55", " md2", "MD75", "dig55"]}}
{"id1": "3801655", "id2": "21656668", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    private void copyResourceToFile(final String resourceFilename, final String destinationFilename) throws IOException {\n        InputStream inStream = null;\n        OutputStream outStream = null;\n        try {\n            inStream = MatsimResource.getAsInputStream(resourceFilename);\n            outStream = new FileOutputStream(destinationFilename);\n            IOUtils.copyStream(inStream, outStream);\n        } finally {\n            if (inStream != null) {\n                try {\n                    inStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (outStream != null) {\n                try {\n                    outStream.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"helper": ["worker", "helpler", "scheHelper", "help", "helpHelper", "helppherd", "Helmer", "helpper", "workmer", "Help", "helpherd", "harler", "workper", "shp", "scheper", "shper", "heller", "scheler", "heler", "helmer", "Helper", "schepherd", "workp", "helHelper", "harper", "sher", "shmer", "harpherd", "harHelper", "Heler"], "dataset": ["datAset", "DatasET", "datapsert", "datASeter", "metaset", "datasets", "datasteter", "Dataseter", " DatASets", "datASheet", " Datasets", "datastET", "datacET", "datasET", "metasET", "datASets", "datapsheet", "DatASeter", "datassheet", "dataseter", "Dataset", "datasheet", " DatASet", " DatasET", "DatASets", "datAsheet", "datassets", " DatASheet", "datapsET", "datAsets", "datacet", "Datasets", "datASET", "datapset", "datacheet", " Dataset", "metassheet", "datastet", "datassert", "datasset", "metassert", " Datasheet", "datacert", "DatASET", "datAsET", "DatASet", "datrasets", "datASet", "metasert", " DatASET", "metasset", "datrasET", "datastets", "metasheet", "datasert", "datassET", "datraseter", "metassET", "datraset"], "zip": ["ip", "pdf", "service", "p", "sl", "git", "tar", "java", "slice", "sea", "bug", "parse", "copy", "pkg", "directory", "archive", "handler", "py", "Zip", "code", "zone", "se", "io", "pack", "ssl", "z", "out", "xml", "file", "secure", "bag", "dir", "f", "binary", "data", "flat", "system", "split", "wrap", "plugin", "folder", "loop", "gz", "lock", "jar", "window", "source", "pipe"], "entries": ["entrys", "contries", "contents", "entlines", "entrants", "entities", "intries", "infrees", "entsrants", " entlements", "infrants", "entlements", "intlements", "ENTrees", "ntents", "entryents", "iterries", "contrys", "entrees", " entities", "entryries", "entrylements", "contry", "infries", "ENTrants", "delements", "ntry", "intities", "ENTries", "ntries", " entlines", "intlines", "iterlements", "entsries", "entsrees", "itrys", "inflements", "itries", "deents", "entlections", "iterents", "itents", "deries", "ENTlections", "entslections", "itry", "infities", "entents", "ntrys", "inflines", "inflections"], "performance": ["stats", "union", " units", "ul", " u", "Unit", "units", "its", " Unit", "rank", "slave", " split", "U", "ui", " result", " writers", " suite", "work", "book", " output", "util", " group", "unit", "exec", " unit", " ratio", "runner", "each", "it", " Units"], "index": ["position", "level", "pos", "i", "key", "order", "write", "id", "page", "limit", "num", "path", "value", "count", "iter", "x", "depth", "unit", "type", "offset", "number", "Index", "name", "head", "length"], "entry": ["r", "in", "service", "obj", "element", "ie", "stream", "cel", "key", "cell", "pattern", "feed", "input", "install", "write", "e", "parse", "section", "ry", "nt", "archive", "office", "server", "lc", "route", "child", "info", "or", "result", "connection", "inner", "se", "xml", "row", "file", "part", "post", "data", "pe", "her", "it", "record", "export", "Entry", "style", "si", "folder", "uri", "add"], "temp": ["fake", "clean", "template", "p", "original", "ctx", "cel", " temporary", "full", "output", "layout", "tmp", "context", "input", "copy", "parent", "office", "Temp", "archive", "directory", "cache", "valid", "http", "path", "io", "single", "out", "thread", "dest", "file", "part", "tc", "storage", "store", "iter", "tem", "f", "binary", "stable", "base", "porary", "data", "emp", "flat", "session", "local", "partial", "test", "w", "table", "wrap", "folder", "lock", "empty", "config", "pipe", "txt"], "writer": ["r", "wire", "sw", "worker", "element", "stream", "author", "key", "output", "feed", "write", "handler", "server", "Writer", "written", "per", "ler", "or", "writers", "inner", "war", "editor", "io", "out", "manager", "wr", "file", "riter", "rw", "iter", "engine", "wrapper", "builder", "wer", "player", "log", "loader", "er", "w", "wave", "driver", "outer", "ws", "writing", "holder", "layer"], "reader": ["r", "iterator", "ner", "worker", "Reader", "element", "stream", "rer", "i", "feed", "input", "write", "ry", "handler", "server", "per", "ler", "or", "http", "inner", "editor", "io", "rr", "reading", "file", "rar", "iter", "f", "wrapper", "ri", "builder", "loader", "oder", "er", "driver", "ter", "upper", "ser"], "buffer": ["position", "bytes", "size", "batch", "capacity", "queue", "transfer", "feed", "character", "input", "sequence", "slice", "reference", "write", "layer", "limit", "Buffer", "server", "address", "result", "message", "resource", "buff", "row", "uffer", "iter", "buf", "binary", "channel", "device", "null", "data", "offset", "wave", "document", "memory", "table", "header", "seed", "flush", "source", "length", "initial"], "read": ["get", "process", "ind", "next", "connect", "size", "max", "save", "sync", "g", "Read", "current", "old", "view", "use", "print", "load", "feed", "input", "default", "ad", "write", "parse", "copy", "id", "reads", "run", "check", "open", "child", "seek", "eval", "report", "READ", "se", "sleep", "readable", "work", "send", "count", "reading", "build", "book", "find", "fill", "start", "end", "x", "iter", "close", "available", "pass", "exec", "k", "data", "download", "type", "wait", "allow", "text", "ride", "skip", "raw", "play", "add", "create", "config", "length", "select"], "outfile": ["infilename", "logfile", " outfilename", "outdir", "outf", " outstream", "Outfile", "indir", "Outline", "logFile", " outline", "outstream", "inf", "Outdir", "outdata", "indata", "Outf", " outdata", "againstream", "instream", "Outstream", "outfilename", " outFile", "inline", "outline", "logfilename", "logdata", "againdir", "infile", "outFile", "inFile", "againline", " outf", "againfile"], "line": ["job", "error", "ip", "side", "lf", "sync", "block", "cell", "object", "comment", "el", "parse", "on", "section", "page", "cle", "lines", "val", "Line", "lin", "code", "strip", "band", "word", "row", "file", "str", "end", "link", "sel", "url", "letter", "pass", "inline", "data", "type", "log", "range", "ine", "split", "status", "LINE", "text", "name", "l", "frame", "style", "string", "header", "le", "filter", "item", "look", "column"], "parser": ["r", "p", "worker", "cher", "class", "pattern", "par", "parse", "Parser", "handler", "server", "per", "ler", "lp", "params", "pool", "xml", "angler", "manager", "function", "book", "plan", "wrapper", "data", "system", "type", "loader", "builder", "er", "oder", "test", "arser", "driver", "processor", "plugin", "string", "umper"], "list": ["get", "r", "match", "p", "left", "best", "all", "chain", "map", "LIST", "parent", "val", "info", "group", "result", "listed", "array", "li", "lp", "pool", "out", "part", "plan", "base", "set", "data", "type", "can", "er", "lists", "v", "collection", "test", "other", "l", "table", "member", "and", "filter", "join", "right"], "rule": ["lr", "r", "match", "rate", "service", "ul", "tree", "ule", "rl", "class", "dict", "rol", "parse", "ee", "val", "per", "group", "li", "function", "row", "str", "Rule", "base", "model", "data", "pe", "ri", "range", "er", "record", "table", "plugin", "style", "header", "rules", "field", "item", "event", "layer"], "measure": ["measuring", "speasuring", "feasure", "feasuring", "Measures", "speasure", "feasures", "Measuring", "Measure", "measured", "Measured", "measures", "feasured", "speasured", "speasures"]}}
{"id1": "22431487", "id2": "9257487", "code1": "    public static String doPost(String URL, List<NameValuePair> params) {\n        try {\n            OauthUtil util = new OauthUtil();\n            URI uri = new URI(URL);\n            HttpClient httpclient = util.getNewHttpClient();\n            HttpPost postMethod = new HttpPost(uri);\n            StringBuffer paramString = new StringBuffer();\n            paramString.append(\"OAuth\");\n            for (int i = 0; i < params.size(); i++) {\n                paramString.append(\" \" + params.get(i).getName());\n                paramString.append(\"=\\\"\" + encodeUrl(params.get(i).getValue()) + \"\\\",\");\n            }\n            String xx = paramString.substring(0, paramString.length() - 1);\n            postMethod.addHeader(\"Authorization\", xx);\n            HttpResponse httpResponse = httpclient.execute(postMethod);\n            if (httpResponse.getStatusLine().getStatusCode() == 200) {\n                String strResult = EntityUtils.toString(httpResponse.getEntity());\n                Log.i(\"DEBUG\", \"result: \" + strResult);\n                return strResult;\n            }\n        } catch (Exception e) {\n            Log.i(\"DEBUG\", e.toString());\n        }\n        return null;\n    }\n", "code2": "    public static boolean downloadFile(String from, String to, ProgressMonitor pm) {\n        try {\n            FileOutputStream out = new FileOutputStream(to);\n            URL url = new URL(from);\n            URLConnection conn = url.openConnection();\n            InputStream in = conn.getInputStream();\n            byte[] buffer = new byte[1024];\n            int read = 0;\n            while ((read = in.read(buffer)) != -1) {\n                out.write(buffer, 0, read);\n                if (pm != null) pm.addToProgress(read);\n            }\n            out.close();\n            in.close();\n        } catch (Exception e) {\n            Installer.getInstance().getLogger().log(StringUtils.getStackTrace(e));\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"doPost": [" doLoop", "doPosts", "apiPost", "apiPosts", "formRequest", "formLoop", "doLoop", "apiLoop", " doRequest", "doRequest", " doPosts", "formPost", "apiRequest", "formPosts"], "URL": ["API", "CL", "PATH", "Address", "DIR", "URI", "JSON", "METHOD", "HTTP", "File", "ID", "HTML", "IP", "Path", "http", "resource", "FILE", "GI", "NAME", "url", "Url", "Location", "SSL", "IR", "IO", "UR", "Name", "WS", "string", "SR", "Page", "Base", "R", "PORT", "DB"], "params": ["request", "ip", "Par", "details", "words", "p", "arms", "pos", "Param", "is", "types", "par", "s", "strings", "rs", "parse", "ls", "json", "properties", "server", "es", "features", "ams", "array", "http", "param", "services", "terms", "ras", "resources", "results", "members", "apps", "options", "changes", "pi", "Parameters", "url", "relations", "api", "data", "pins", "values", "users", "names", "name", "settings", "vs", "parts", "ps", "list", "afi", "photos"], "util": ["auto", "su", "client", " u", "init", "impl", "global", "install", "il", "cli", "mu", " utility", "ut", "U", "valid", "kit", "universal", "utt", "ui", "http", "io", "iu", "Ut", "gui", "manager", "anti", "url", "lib", "api", "unit", "u", "spec", "utils", " url", "internet", "string", "general", "mut", "lu"], "uri": ["request", "API", "absolute", "client", "iri", " URI", "service", "URI", "Manager", "cli", "U", "route", "id", "handler", "server", "address", "ui", "connection", "http", "resource", "path", "io", "response", "uni", "pi", "Url", "url", "PI", "api", "base", "ri", "database", "plugin", "config"], "httpclient": ["Httpapi", " httpserver", " httpconfig", "htmlmethod", " httpconnection", "htmlserver", "httpsconnection", "Httpconnection", "Httpmethod", "httpconfig", "httpconnection", " httpClient", "HttpClient", " httpapi", "httpapi", "htmlclient", " httpmethod", "httpserver", "Httpserver", "Httpconfig", "httpClient", "httpmethod", "httpsclient", "htmlClient", "httpsconfig", "Httpclient", "httpsapi"], "postMethod": ["PostPath", "typeFunction", " postPath", "PostMethod", "typeRequest", "PostRequest", "POSTMethod", "PostFunction", "postPath", " postMessage", "typemethod", "POSTmethod", "typeMethod", "postFunction", "postMessage", "postRequest", "PostMessage", "patchPath", " postmethod", "patchMethod", " postRequest", "postmethod", "patchFunction", "Postmethod", " postFunction", "patchMessage", "POSTRequest", "POSTFunction"], "paramString": ["paramStr", " paramFile", "memberArray", " paramBuffer", "cmService", "ParamBuffer", "cmArray", "paramArray", "paramsArray", "errorFile", "parStream", "paramsStr", "errorString", "ParamStream", " paramStream", " paramstring", " paramArray", "memberString", "ParamList", "ParamFile", "memberstring", "paramBuffer", " paramStr", "paramsList", "paramList", "parFile", " paramList", "cmString", "cmstring", "paramsString", "ParamService", "ParamString", "paramstring", "paramService", "paramStream", "paramFile", "ParamArray", "Paramstring", "errorBuffer", "ParamStr", "memberFile", "parArray", "priArray", "priBuffer", "priStr", "priString", " paramService", "parString", "errorArray"], "i": ["ai", "ip", "in", "m", "j", "p", "ic", "ie", "n", "g", "eni", "is", "key", "q", "s", "multi", "slice", "ix", "e", "id", "cli", "ci", "gi", "t", "ui", "info", "index", "li", "ii", "io", "ori", "ei", "iu", "z", "ini", "count", "bi", "part", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "data", "u", "b", "y", "v", "ji", "oi", "it", "name", "di", "hi", "l", "d", "si", "qi", "iv", "c", "I", "length"], "xx": ["xy", "ck", "XX", "pp", "xxxxxxxx", "host", "key", "zz", "cn", "cc", "X", "json", "ax", "XXXX", "code", "foo", "response", "vv", "ww", "ant", "x", "uid", "prefix", "enc", "xi", "pass", "xxx", "yy", "xxxx", "ux", "ss", "XXX", "header", "xa", "Code", "act", " XX"], "httpResponse": ["phpresponse", "httpConnection", "postConnection", "Httpresponse", "httpResp", "HttpReply", " httpResp", " httpConnection", "hrresponse", "httpRequest", " httpClient", "HttpClient", "hrReply", "HttpResponse", "phpResponse", " httpReply", "postResp", "postResponse", "HttpRequest", "httpClient", "phpResp", "postRequest", "HttpConnection", "hrResp", "hrResponse", " httpresponse", "httpReply", "HttpResp", "phpClient", "httpresponse", " httpRequest"], "strResult": ["drResult", "StrReturn", " strReturn", "objResult", " strStatus", " strresult", "strStatus", "StrResponse", "stringRes", "drStatus", "strRes", " strResponse", "StrRes", "stringReturn", "StrResult", "stringResult", "objResponse", "Strresult", "stringResponse", "drResponse", "strReturn", " strRes", "objReturn", "StrStatus", "strResponse", "drresult", "objresult", "strresult"]}}
{"id1": "5551393", "id2": "15202804", "code1": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "code2": "    public static String getDigest(String user, String realm, String password, String method, String uri, String nonce) {\n        String digest1 = user + \":\" + realm + \":\" + password;\n        String digest2 = method + \":\" + uri;\n        try {\n            MessageDigest digestOne = MessageDigest.getInstance(\"md5\");\n            digestOne.update(digest1.getBytes());\n            String hexDigestOne = getHexString(digestOne.digest());\n            MessageDigest digestTwo = MessageDigest.getInstance(\"md5\");\n            digestTwo.update(digest2.getBytes());\n            String hexDigestTwo = getHexString(digestTwo.digest());\n            String digest3 = hexDigestOne + \":\" + nonce + \":\" + hexDigestTwo;\n            MessageDigest digestThree = MessageDigest.getInstance(\"md5\");\n            digestThree.update(digest3.getBytes());\n            String hexDigestThree = getHexString(digestThree.digest());\n            return hexDigestThree;\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"getMD5": [" getMD512", "getSHA5", "getSHA512", "getM4", "getMD4", "getSHA256", " getM512", "getSHA4", "getmd4", "getM512", "getM256", "getmd256", " getMD4", " getM4", "getMD512", "getmd5", " getM256", "getmd512", "getMD256", " getM5", " getMD256", "getM5"], "source": ["expected", "buffer", "template", "bytes", "size", "service", "src", "output", "object", "proxy", "input", "slice", "address", "info", "result", "target", "code", "content", "resource", "message", "dest", "file", "Source", "secure", "start", "url", "unit", "security", "base", "sm", "data", "temp", "SOURCE", "text", "name", "style", "string", "seed", "ource", "config", "length"], "tmp": ["var", "buffer", "obj", "bf", "html", "vt", "src", "output", "default", "copy", "Temp", "cache", "py", "metadata", "stuff", "sb", "tt", "cb", "result", "code", "foo", "array", "rb", "params", "nm", "fp", "ignore", "dest", "part", "storage", "buf", "binary", "zip", "data", "temp", "emp", "b", "test", "cpp", "mp", "body", "meta", "cmp", "current", "vm", "txt"], "md": ["mm", "mo", "mac", "ind", "sd", "m", "bf", "mad", "oda", "ad", "mn", "mu", "pd", "ma", "od", "cd", "rm", "editor", "mb", "cm", "nm", "amd", "wd", "gd", "mand", "bd", "mg", "dm", "zip", "pm", "mi", "nd", "mt", "MD", "mp", "di", "mc", "rpm", "mag", "hd", "d", "vd", "mod", "mmm", "ld", "ms", "meta", "cmd", "dd", " MD"]}}
{"id1": "7396682", "id2": "12236729", "code1": "    public static boolean copy(FileSystem srcFS, Path src, File dst, boolean deleteSource, Configuration conf) throws IOException {\n        if (srcFS.getFileStatus(src).isDir()) {\n            if (!dst.mkdirs()) {\n                return false;\n            }\n            FileStatus contents[] = srcFS.listStatus(src);\n            for (int i = 0; i < contents.length; i++) {\n                copy(srcFS, contents[i].getPath(), new File(dst, contents[i].getPath().getName()), deleteSource, conf);\n            }\n        } else if (srcFS.isFile(src)) {\n            InputStream in = srcFS.open(src);\n            IOUtils.copyBytes(in, new FileOutputStream(dst), conf);\n        } else {\n            throw new IOException(src.toString() + \": No such file or directory\");\n        }\n        if (deleteSource) {\n            return srcFS.delete(src, true);\n        } else {\n            return true;\n        }\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 1, "substitutes": {"copy": ["get", "clone", "sync", "save", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "archive", " cp", "replace", "source", "share", "clip", "path", "rm", "cop", "change", "file", "link", "url", "update", "download", "create", "paste", "drop", "split", "remote", "dump", "opy", "move"], "srcFS": ["sbFP", "sourceFS", "sourcefs", " srcTS", "rubyFs", "srcfs", "sourceFB", "rcFC", " srcFP", " srcFB", "srcFB", "srcFP", "sourceFs", "srcFC", "sbfs", "rubyfs", "sourceFC", "rubyFS", "rcfs", "rubyFB", "sbFS", "rcTS", "srcFs", "srcTS", " srcFs", " srcFC", "rcFS", " srcfs", "sbFs", "rcFs", "rcFP", "sourceTS"], "src": ["sc", "sl", "obj", "upload", "attr", "sec", "stream", "ctx", "host", "sync", "rc", "view", "sit", "slice", "sn", "sin", "core", "RC", "sb", "cb", "loc", "source", "inf", "target", "share", "rss", "rb", "inst", "path", "code", "fp", "resource", "http", "ssl", "img", "supp", "gb", "dest", "sup", "Source", "dist", "secure", "feat", "sr", "sel", "file", "url", "req", "st", "bh", "config", "rest", "spec", "SourceFile", "name", "project", "href", "sth", "sys", "uri", "cmp", "ource", "sub", "filename", "username"], "dst": ["cdst", " drc", " dsts", "lST", "lst", "dsts", "ddst", "pdST", "pdsc", "cdrc", "ddsc", "pdrc", "drest", "Drest", "ddest", " dST", "Dsts", "lsts", " drest", "Drc", " ddest", "idsts", "idrest", "dST", "Ddest", "ddrc", "cddest", "Dst", "drc", "idst", "dsc", " dsc", "iddest", "ldest", "cdST", "pdst", "ddST", "DST"], "deleteSource": ["DeleteSources", "delTarget", " deleteOrigin", "delMode", "DeleteMode", "delOrigin", "destroyTarget", "DeleteTarget", "DeleteOrigin", "destroyOrigin", "deleteType", "deleteSources", "DeleteType", " deleteSources", "deleteOrigin", "delSource", "destroySource", "deleteMode", "copyOrigin", "deleteTarget", "delType", "copySource", "destroyMode", "DeleteSource", " deleteMode", "delSources", " deleteType", "copyMode", "copyTarget", " deleteTarget"], "conf": ["sc", "client", "ca", "ctx", "def", "cs", "cn", "cc", "context", "fi", "comment", "bug", "cr", "cli", "lc", "cf", "ci", "cache", "const", "cb", "conn", "info", "cd", "bc", "ref", "raf", "cor", "cm", "param", " Conf", "con", "Conf", "uc", "f", "ch", "confirmed", "conv", "cl", "cfg", "prop", "cmp", "config", "c"], "contents": ["contContents", "contentents", "containers", " contients", "Content", "latents", "CONTENTS", "ContContents", "stents", "CONTents", "stacts", "contacts", "CONTacts", " contENTS", "CONTils", "Contains", "content", "stences", "contences", "stENTS", "CONTients", "Contents", "CONTains", "ContENTS", "locains", "locents", "contENTS", "Contences", "Contacts", "contentients", "contentent", "CONTContents", "latacts", "contains", "Containers", "Contils", "contils", "CONTainers", "contients", "latent", "contentENTS", "locContents", "CONTent", "latils", "CONTences", " content", "locainers"], "i": ["ai", "ip", "m", "j", "p", "h", "n", "ie", "key", "init", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "diff", "inner", "li", "index", "ii", "io", "ori", "iu", "ini", "count", "uni", "start", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "type", "u", "data", "b", "y", "v", "ji", "oi", "name", "di", "hi", "d", "si", "qi", "uri", "iv", "I", "c"], "in": ["r", "inn", "gin", "is", "socket", "input", "thin", "id", "sin", "din", "inas", "conn", "ax", "connection", "a", "nin", "out", "ini", "con", "rin", "file", "kin", "part", "min", "f", "pass", "serv", "doc", "login", "data", "ac", "b", "ins", "bin", "In", "l", "IN", "as", "win", "source", "c", "inc"]}}
{"id1": "13596891", "id2": "20851065", "code1": "    protected void doTransfer(HttpServletRequest request, HttpServletResponse response, String method) throws ServletException, IOException {\n        ServletContext servletContext = this.getServletConfig().getServletContext();\n        WebApplicationContext wac = WebApplicationContextUtils.getRequiredWebApplicationContext(servletContext);\n        String szUrl = request.getParameter(\"url\");\n        System.out.println(szUrl);\n        URL url;\n        InputStream is = null;\n        ServletOutputStream sout = null;\n        try {\n            url = new URL(szUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            Enumeration hNames = request.getHeaderNames();\n            while (hNames.hasMoreElements()) {\n                String txt = hNames.nextElement().toString();\n                con.setRequestProperty(txt, request.getHeader(txt));\n            }\n            con.setRequestProperty(\"host\", url.getHost());\n            con.setRequestProperty(\"refer\", szUrl);\n            con.setRequestMethod(method);\n            con.setDoOutput(true);\n            con.setDoInput(true);\n            InputStreamReader inBody = new InputStreamReader(request.getInputStream());\n            char bufCh[] = new char[1024];\n            int r;\n            OutputStreamWriter outReq = new OutputStreamWriter(con.getOutputStream());\n            while ((r = inBody.read(bufCh)) != -1) {\n                System.out.println(bufCh);\n                outReq.write(bufCh, 0, r);\n            }\n            outReq.flush();\n            outReq.close();\n            inBody.close();\n            System.out.println(con.getResponseCode());\n            System.out.println(con.getResponseMessage());\n            if (con.getResponseCode() == con.HTTP_OK) {\n                response.setContentType(con.getContentType());\n                response.addHeader(\"Content-Encoding\", con.getContentEncoding());\n                sout = response.getOutputStream();\n                is = con.getInputStream();\n                byte buff[] = new byte[1024];\n                while ((r = is.read(buff)) != -1) {\n                    sout.write(buff, 0, r);\n                    System.out.print(buff);\n                }\n                sout.flush();\n                is.close();\n                sout.close();\n            } else {\n                response.sendError(con.getResponseCode(), con.getResponseMessage());\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doTransfer": ["makeRequest", "doSend", "makeSend", " doSend", " doImport", "makeTransfer", "doImport", "makeImport", "handleImport", " doRequest", "handleSend", "handleRequest", "handleTransfer", "doRequest"], "request": ["position", "in", "client", "query", "stream", "received", "queue", "q", "form", "current", "object", "context", "input", "user", "version", "instance", "enter", "com", "server", "complete", "result", "connection", "http", "message", "resource", "report", "time", "xml", "post", "rf", "req", "this", "model", "session", "data", "type", "subject", "application", "requ", "record", "Request", "reader", "remote", "command", "QUEST", "event", "re", "create", "config", "condition"], "response": ["next", "image", "error", "success", "client", "writer", "service", "full", " Response", "output", "reply", "view", "object", "default", "version", "page", "server", "json", "cache", "result", "connection", "http", "content", "resource", "message", "report", "index", "results", "Response", "out", "resp", "cover", "en", "warning", "serv", "onse", "model", "session", "status", "application", "document", "call", "res", "site", "body", "respond", "header", "remote", "event", "re"], "method": ["process", "position", "sort", "term", "class", "use", "version", "METHOD", "route", "json", "property", "format", "content", "reason", "path", "resource", "message", "pull", "direction", "time", "description", "send", "date", "hod", "prefix", "callback", "mode", "session", "type", "subject", "status", "text", "call", "Method", "string", "verb", "command", "head", "cmd", "sign"], "servletContext": ["servleCurrent", "servlexContext", "servleProvider", "servletProvider", "ServletConfig", "servletConfig", "servletCurrent", "servantProvider", "ServletsConfig", "servApplicationController", "servlexConfig", "servApplicationConfig", "ServletController", "servletController", " servantProvider", "servantCurrent", "servletsController", "servletcontext", " servantCurrent", "servantConfig", " servantContext", "servLETProvider", "servlexController", " servantConfig", "servletsContext", "servlexcontext", "servApplicationContext", "servLETCurrent", "servletscontext", "servLETContext", "servLETConfig", "ServletsController", " servletConfig", " servletCurrent", "servantContext", "ServletsContext", "servleContext", "Servletscontext", " servletProvider", "servApplicationcontext", "servleConfig", "servletsConfig", "ServletContext", "Servletcontext"], "wac": [" wae", "wacs", " Wac", " Wae", " WAC", "wae", "wsac", "wsacs", " Wacs", " wAC", " wacs", "wsae", "wsAC", "wAC"], "szUrl": ["aszFrame", "asizURL", "szPath", " szURL", "sznUr", "szaUrl", "szaURL", " sizUrl", " szFolder", "sziUr", "szeUr", "szFrame", "szeFolder", "szenFolder", "asizurl", "asizFrame", "szenURL", "sznPath", "szeUrl", "szerFrame", "sznURL", "szenurl", "szeURL", "szUr", "sziUrl", "sziURL", "szerUr", "sizFrame", "aszUr", " szurl", "szeFrame", "szenUrl", "asizPath", "asizUr", "sizURL", "sznurl", "aszURL", "sizPath", " sizurl", "sizUr", "sizurl", "sznUrl", "szaPath", "szerUrl", "szaUr", "szFolder", "aszurl", " sizURL", "aszPath", "aszUrl", "sizFolder", " sizFolder", "szeurl", "szerURL", "sizUrl", "szURL", "asizUrl", "sziurl", "szurl"], "url": ["get", "client", "buffer", "service", "sl", "obj", "ul", "rl", "stream", "host", "key", "lb", "socket", "el", "context", "impl", "user", "fl", "il", "page", "server", "conn", "loc", "connection", "http", "location", "li", "resource", "URL", "xml", "ssl", "file", "cloud", "f", "Url", "base", "gl", "log", "rel", "org", "ll", " URL", "name", "l", "string", "web", "ur", "uri", "event", "re", "source", "config", "www"], "is": ["lis", "os", "ip", "ai", "Is", "ils", "us", "bis", "iso", "isl", "oss", "isa", "src", "i", "rc", "bs", "was", "ib", "il", "rx", "ci", "isi", "ris", "isu", "IS", "info", "iss", "ios", "isc", "ii", "io", "has", "ir", " are", "ais", "x", "serv", " bis", "ri", "im", "isf", "it", " isn", "as", "web", "cms", "uri"], "sout": ["SOut", "sOut", "sdata", "sOUT", " sOut", "Sdata", "sin", "Souts", " sin", " sdata", "Sin", " sOUT", "Sout", "souts", "SOUT", " souts"], "con": ["query", "ctx", "author", "rc", "conn", "open", "fe", "bc", "ver", "http", "fun", "en", "conv", "re", "wa", "ocon", "win", "non", "get", "C", "client", "connect", "ca", "pin", "cp", "cc", "cn", "java", "common", "view", "user", "internal", "cons", "san", "cache", "ran", "single", "xc", "fc", "conf", "Con", "close", "can", "status", "pc", "net", "l", "Internal", "web", "event", "pen", "inc", "ec", "m", "fa", "pre", "on", "CON", "lc", "cf", "core", "const", "run", "Common", "nc", "cos", "cur", "ssl", "min", "util", "ren", "subject", "cl", "un", "remote", "c", "syn", "version", "com", "coll", "server", "connection", "uc", "crit", "ctrl", "don", "exec", "login", "type", "wan", "ct", "co", "general", "Connection", "gen", "func"], "hNames": ["hBlocks", "HTypes", " hKeys", "hVs", "HFiles", "HNames", "ihName", " hVs", "hrFiles", "ihBlocks", "ihNames", "hrTypes", "hostKeys", " hTypes", "ihVs", "hFiles", " hNs", "hostNs", "hrKeys", " hName", "HBlocks", " hBlocks", "hostTypes", "hName", "HName", "hNs", "hrNames", "hKeys", "hTypes", "hrNs", "hostNames", "hrName", "HVs", " hFiles"], "txt": ["in", "XT", "xt", "tx", "obj", "ctx", "vt", "key", "q", "bt", "git", "lt", "Text", "tin", "rx", "section", "nt", "gi", "ht", "t", "py", "phrase", "inet", " text", "lv", "utt", "TEXT", "fp", "nm", "dt", "rr", "csv", "value", "qt", "str", "htm", "prot", "binary", "xxx", "zip", "jp", "struct", "v", "kt", "text", "ct", "name", "fx", "et", "elt", "header", "wt", "wx", "gt", "gz", "sv", "cb"], "inBody": ["INReader", "outStream", "insStream", "INStream", "InReader", "INBody", "InBody", "INFile", "insBody", "inbody", "InStream", "insReader", "inReader", "INbody", " inbody", " inStream", "outBody", " inReader", " inFile", "outFile", "inFile", "outbody", "Inbody", "InFile", "insFile", "inStream"], "bufCh": ["buffCH", "ufC", "queueCH", "bufCol", "buffch", "ufCH", "bufch", "ufCol", "bufCH", "queueCol", "bufferCh", " bufCH", "bufferCH", "bufC", "ufChar", "bufChar", "ufch", " bufC", "queueCh", " bufch", "queuech", "buffC", "bufferChar", "ufCh", " bufCol", "bufferch", "buffCh", " bufChar"], "r": ["lr", "fr", "m", "ner", "p", "br", "g", "rd", "rl", "n", "i", "q", "rc", "rs", "cr", "e", "reg", "result", "ru", "rb", "rh", " rg", "rr", "nr", "str", "hr", "x", "sr", "rw", "rf", "f", "k", "ri", "err", "u", "b", "rt", "er", "range", "v", "w", "rg", "res", "ar", "d", "reader", "R", "re", "c", "pr", "ror"], "outReq": ["outREque", "outRecque", " outRq", "outRsce", "outDeq", "outEck", "outRquest", " outRequest", "outREce", " outRsq", "outRce", "outRck", "outDece", "outRecck", "outSeque", "outRsh", "outRsque", "outREck", " outEreq", " outRquest", " outRque", "outEreq", " outRce", "outREh", "outSeck", "outConq", " outRsque", "outRq", "outEque", " outRsh", " outSeck", "outRecce", " outEck", "outSequest", " outReque", "outSeq", "outSece", " outSeque", "outReck", " outRsce", "outRequest", "outREq", "outRece", "outReh", " outSece", "outConque", "outDeque", " outSeq", " outReck", "outEq", "outConce", " outEq", " outRereq", "outRreq", "outRque", "outDequest", "outRecq", "outRsq", " outReh", " outEque", "outConh", "outRecreq", "outReque", "outRereq", " outRece"], "buff": ["buffer", "p", "map", "bb", "Buffer", " Buffer", "lines", "Pad", "info", " chunk", "array", "num", "Info", " Buff", "file", "Buff", "f", "ch", "buf", "Ptr", "data", "b", "uf", "Msg", " buffers"]}}
{"id1": "14688886", "id2": "17874479", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    public static final void main(String[] args) throws Exception {\n        HttpClient httpclient = new DefaultHttpClient();\n        HttpGet httpget = new HttpGet(\"http://www.apache.org/\");\n        System.out.println(\"executing request \" + httpget.getURI());\n        HttpResponse response = httpclient.execute(httpget);\n        HttpEntity entity = response.getEntity();\n        System.out.println(\"----------------------------------------\");\n        System.out.println(response.getStatusLine());\n        if (entity != null) {\n            System.out.println(\"Response content length: \" + entity.getContentLength());\n        }\n        System.out.println(\"----------------------------------------\");\n        httpget.abort();\n    }\n", "label": 0, "substitutes": {"populateResources": ["compureResource", "poputeRelations", "compureRelations", "popractResources", "poputeResource", "populateRelations", "popureFiles", "poputeFiles", "poputeResources", "compulateFiles", "compureResources", "popureResources", "compulateRelations", "compureFiles", "popractFiles", "compulateResources", "popureResource", "populateResource", "popureRelations", "compulateResource", "popractRelations", "populateFiles", "popractResource"], "templates": ["Template", "template", "filens", "Temeters", "temures", "filures", "templateps", "templateples", "stemples", "tomplates", "prompl", "Temens", "templateplates", "Templ", " temures", "promplate", "promplates", "temps", " templ", "stemplates", "tempplates", "Temples", "Temps", "stempl", "temeters", "tompl", "typlates", "tometers", "stemps", "temples", "tempplate", "filpl", "typs", "templ", "prometers", "temppl", " temens", "templatepl", "tempps", "typlate", "Templates", "typl", "tomplate", "temens", "Temures", "filplates"], "url": ["image", "r", "job", "template", "buffer", "service", "email", "sl", "html", "entry", "host", "pattern", "object", "el", "feed", "fl", "il", "e", "route", "page", "server", "address", "connection", "http", "location", "URL", "resource", "path", "ob", "xml", "ssl", "file", "config", "link", "f", "Url", "channel", "base", "data", "download", " URL", "name", "l", "string", "href", "uri", "pl", "source", "filename"], "fileName": ["FileKey", "resourcePath", "stringType", "FileType", "stringName", " fileTime", "fDir", " fileInfo", "sourceName", "FileName", "filenameName", "filePart", "fileDir", "FileFull", "fileSync", " fileDir", "filePath", "fileTime", " filePart", "folderPath", "foldername", "sourceInfo", " fileKey", "folderPart", "fileString", "objectTime", "fname", "FileDir", "modelname", "fileSystem", " fileSystem", "FILELocation", " fileDirectory", "fileDirectory", "resourcePart", "FILESync", "filenamename", "stringDirectory", "modelLocation", "sourcename", "Filename", " fileLength", "sourceString", "FILESystem", "fileType", " fileType", "folderName", " fileSync", "resourcename", "fName", " filePath", "filenameString", " fileLocation", "fKey", "resourceName", "filenameType", "objectname", " filename", "filename", "objectName", "sourceLength", "fileLength", " fileFull", "filenameFull", "fileLocation", "FILEname", "modelName", "FileDirectory", "modelSystem", "filenameLength", "fileFull", "fileInfo", "fileKey", "FileInfo", "FileString", " fileString", "objectSync", "FILETime", "FILEName"], "templateResource": ["tempFile", "eventReader", " templateFile", "plateResource", "translationContent", "plateContainer", "copyUrl", "templateUrl", "translationRing", "templateReader", "privateResource", "privateUrl", "xmlFile", "templateresource", "xmlRole", "layoutResource", "templateType", "privateresource", "translationContainer", "eventresource", "tempResource", "translationResource", "layoutRing", "templateRing", "templateFile", " templateType", "plateRing", "templateContent", "templateContainer", "privateReader", "copyresource", "eventUrl", "xmlType", "tempRole", "copyReader", "plateContent", "xmlResource", "copyResource", "tempType", "eventResource", " templateRole", "templateRole", "layoutContent", "layoutContainer"], "is": ["lis", "r", "os", "in", "ip", "irc", "Is", "bis", "iso", "isl", "isa", "src", "s", "app", "its", "was", "ib", "isi", "ris", "IS", "iss", "rss", "ios", "isc", "ori", "nis", "io", "has", "ir", "out", "iris", "abs", "ais", "api", "serv", "ri", "im", "it", "ar", "as", "cms", "uri"], "strBuff": ["brBuff", "arrBuffer", "strGrab", "rBuffer", "StrText", "brBuffer", "StrTab", " strBuffer", " strTab", " strbuff", "StrBuffer", "strbuff", "stringFlow", "strText", " strGrab", "strTab", " strPref", "stringGrab", "rBuff", "StrBuff", "Strbuff", "stringBuffer", "brFlow", "strBuffer", " strFlow", "StrPref", "arrTab", "stringBuff", "brGrab", "strFlow", " strText", "arrPref", "arrBuff", "rText", "strPref", "rbuff"], "br": ["r", "gr", "fr", "Reader", "stream", "ctr", "cr", "result", "dr", "bc", "rb", "bl", "ber", "ori", "io", "Br", "bro", "hr", "nr", "sr", "mr", "buf", " reader", "data", "div", "err", "b", "bar", "er", "BR", "brush", "text", "arr", "yr", "browser", "res", "reader", "tr", "orb", "cb", "sp"], "str": ["STR", "r", "sc", "fr", "strike", "p", "sl", "sec", "key", "cr", "lc", "Str", "stri", "t", "coll", "or", "dr", "cur", "line", "wr", "hr", "sr", "iter", "f", "oct", "st", "enc", "data", "type", "err", "div", "char", "er", "spec", "kr", "cl", "text", "star", "arr", "name", "style", "string", "tr", "pr", "sp"], "images": ["image", "letters", "ups", "words", "scripts", "styles", "models", "people", "assets", "files", "types", "boxes", "holes", "tags", "xs", "dates", "sites", "games", "gallery", "ages", "events", "ips", "picture", "features", "objects", "rooms", "quarters", "media", "bands", "services", "jobs", "resources", "frames", "apps", "ions", "pieces", "icons", "png", "classes", "pages", "opens", "inches", "agents", "gif", "ims", "users", "groups", "views", "ins", "versions", "shows", "videos", "stars", "lights", "thumbnails", "Images", "photos", "tests", "flows", "plugins"], "i": ["image", "j", "key", "s", "ci", "gi", "info", "format", "http", "x", "this", "u", "v", "yi", "uri", "I", "ind", "ip", "p", "html", "eni", "multi", "fi", "phi", "diff", "index", "li", "io", "iu", "gu", "bi", "ti", "b", "mi", "d", "si", "ai", "in", "app", "slice", "e", "id", "cli", "lc", "z", "ini", "Url", "xi", "y", "ji", "it", "hi", "chi", "add", "ie", "n", "mu", "ui", "ii", "xml", "_", "ij", "uni", "pi", "f", "ni", "di", "qi", "config"], "img": ["att", "image", "fw", "iframe", "m", "icon", "p", "sl", "jpg", "ie", "src", "ff", "tmp", "app", "map", "input", "fig", "gallery", "ng", "cb", "info", "bg", "fb", "inst", "ext", "li", "bl", "exp", "file", "gd", "hr", "png", "f", "ch", "lib", "imp", "abc", "data", "ani", "gif", "im", "v", "norm", "arr", "small", "aut", "tif", "aff", "config"], "imgProperty": ["cachePro", " imgProp", "imgPro", "cacheImage", "bgPro", "cacheProperty", " imgPro", " imgImage", "imgProp", "bgImage", "imgImage", "bgProp", "cacheProp", "bgProperty"]}}
{"id1": "22410173", "id2": "19006212", "code1": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public void Load(String fname) throws Exception {\n        File f = null;\n        try {\n            if (\"\".equals(fname) || fname == null) throw new Exception();\n            System.out.println(\"Loading mapfile \" + fname);\n        } catch (Exception e) {\n            throw new Exception(\"File not found\");\n        }\n        aType = null;\n        fieldtype.clear();\n        creatures.clear();\n        aElement = new String(\"\");\n        content = null;\n        Ax = -1;\n        Ay = -1;\n        aTemplate = -1;\n        SAXParserFactory factory = SAXParserFactory.newInstance();\n        data_read = 0;\n        URL url = this.game.mainClass.getClassLoader().getResource(fname);\n        if (url == null) {\n            throw new Exception(\"Can't load map from : \" + fname);\n        }\n        try {\n            SAXParser parser = factory.newSAXParser();\n            parser.parse(url.openStream(), this);\n        } catch (Exception e) {\n            System.out.println(\"Can't open XML : \" + e);\n        }\n        for (int i = 0; i < fieldtype.size(); i++) {\n            System.out.println((MapField) fieldtype.get(i));\n        }\n        game.player.setpos(start_x, start_y);\n        System.out.println(\"Player starting position set\");\n        start_x = -1;\n        start_y = -1;\n        System.out.println(\"Map \\\"\" + fname + \"\\\" loaded\");\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "source": ["image", "size", "ie", "stream", "src", "use", "input", "slice", "internal", "copy", "parent", "route", "id", "sin", "from", "target", "connection", "inner", "path", "resource", "file", "Source", "start", "down", "iter", "url", "unit", "base", "SOURCE", "ins", "name", "site", "reader", "ource", "up", "ources"], "dest": ["de", "src", "output", "delete", "transfer", "comb", "tmp", "thin", "home", "Dest", "target", "connection", "desc", "path", "orig", "exit", "later", "img", "file", "dist", "down", "die", "this", "wb", "temp", "flat", "done", "test", "name", "bin", " destination", "true", "project", "folder", "destroy"], "in": ["r", "image", "client", "m", "pin", "n", "inn", "ie", "gin", "src", "i", "socket", "s", "init", "cin", "input", "id", "din", "conn", "info", "a", "inner", "resource", "pull", "nin", "con", "ini", "work", "file", "start", "inside", "min", "f", "url", "this", "login", "data", "err", "b", "ins", "name", "bin", "In", "by", "plugin", "reader", "IN", "again", "as", "lock", "re", "win", "up", "c", "inc"], "out": ["Out", "plain", "timeout", "client", "writer", "self", "obj", "sync", "off", "n", "up", "i", "output", "socket", "init", "ou", "write", "parent", "cat", "id", "ex", "option", "conn", "to", "connection", "exp", "not", "index", "ext", "io", "our", "inner", "pool", "img", "at", "file", "url", "o", "channel", "exec", "no", "this", "lib", "data", "with", "err", "temp", "log", "vert", "w", "net", "call", "name", "bin", "password", "again", "outs", "extra", "outer", "OUT", "c", "inc"]}}
{"id1": "12586404", "id2": "19147281", "code1": "    @Override\n    public List<ProvaSolution[]> run(ProvaService prova, String agent, String key, String src) throws IOException {\n        File file = new File(src);\n        BufferedReader in;\n        InputStream is = null;\n        try {\n            if (!file.exists() || !file.canRead()) {\n                try {\n                    is = Thread.currentThread().getContextClassLoader().getResourceAsStream(src);\n                    in = new BufferedReader(new InputStreamReader(is));\n                } catch (Exception ex1) {\n                    try {\n                        is = RuleReaderImpl.class.getResourceAsStream(src);\n                        in = new BufferedReader(new InputStreamReader(is));\n                    } catch (Exception ex2) {\n                        try {\n                            URL url = new URL(src);\n                            in = new BufferedReader(new InputStreamReader(url.openStream()));\n                        } catch (Exception ex3) {\n                            throw new IOException(\"Cannot read from \" + src);\n                        }\n                    }\n                }\n            } else {\n                FileReader fr = new FileReader(file);\n                in = new BufferedReader(fr);\n            }\n            List<ProvaSolution[]> results = prova.consult(agent, in, key);\n            return results;\n        } finally {\n            if (is != null) is.close();\n        }\n    }\n", "code2": "    public boolean actualizarDatosPrevia(int idJugadorDiv, int idRonda, int idPareoRival, int color, int flotante) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET idPareoRival = \" + idPareoRival + \" , color = \" + color + \" , flotante = \" + flotante + \" \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"run": ["process", "connect", "master", "use", "apply", "submit", "report", "Run", "work", "build", "start", "close", "unit", "exec", "execute", "trial", "test", "runner", "running", "call", "un", "runs", "setup", "add", "create", "config"], "prova": ["peva", "proba", "Proda", "pega", "Prova", " proba", "Proba", "perva", "Proga", "PROVA", "peVA", "proda", "ProVA", "perba", "proga", "perfa", " profa", "pefa", "perda", " proda", "profa", "PROfa", "PROva", "Profa", "proVA", "PROga"], "agent": ["domain", "r", "ace", "client", "writer", "service", "attr", "fax", "entry", "man", "input", "monitor", "server", "address", "reg", "conn", "Agent", "state", "graph", "report", "resource", "manager", "ant", "director", "agency", "acc", "gent", "ator", "agents", "model", "session", "contract", "actor", "act", "config", "account"], "key": ["KEY", "ip", "client", "service", "cert", "entry", "host", "user", "id", "ak", "server", "rule", "address", "json", "keys", "state", "or", "path", "param", "resource", "air", "work", "row", "step", "str", "link", "base", "k", "type", "secret", "contract", "role", "name", "ring", "string", "Key", "sign", "source", "config"], "src": ["sc", "ruby", "sl", "sync", "sec", "stream", "rl", "host", "rc", "s", "proxy", "input", "sit", "route", "sin", "RC", "sb", "server", "address", "loc", "code", "rb", "rss", "path", "resource", "inst", "resources", "ssl", "img", "rin", "dest", "Source", "secure", "config", "dist", "sr", "sel", "prot", "st", "null", "rest", "loader", "rou", "SourceFile", "text", "method", "sch", "string", "href", "seed", "uri", "ser", "ource", "source", "filename", "ources", "username"], "file": ["image", "service", "full", "stream", "files", "class", "socket", "object", "el", "feed", "proxy", "use", "input", "il", "id", "File", "rule", "cache", "per", "fe", "loc", "info", "connection", "http", "resource", "path", "fp", "io", "work", "FILE", "ile", "link", "f", "binary", "this", "base", "zip", "model", "pe", "loader", "b", "log", "local", "it", "l", "reader", "folder", "uri", "lock", "play", "source", "filename"], "in": ["r", "ai", "image", "get", "p", "pin", "ic", "ie", "inn", "isin", "gin", "i", "rc", "s", "init", "cin", "el", "input", "on", "id", "include", "ci", "din", "conn", "info", "or", "lin", "dr", "inner", "index", "io", "nin", "out", "ini", "rin", "rec", "kin", "part", "str", "x", "min", "f", "req", "exec", "login", "ri", "err", "with", "it", "ins", "l", "In", "ar", "bin", "reader", "IN", "and", "again", "read", "config", "ac", "inc"], "is": ["lis", "image", "os", "iso", "isl", "isa", "i", "s", "impl", "sit", "ci", "info", "iss", "http", "isc", "nis", "x", "sel", "iter", "api", "er", "ins", "uri", "sp", "get", "r", "ip", "ire", "isin", "eni", "sin", "es", "isi", "ris", "IS", "inner", "ios", "be", "ais", "err", "does", "internet", "as", "si", "ai", "Is", "us", "ic", "was", "id", "ini", "min", "ri", "it", "ar", "ise", "cms", "bis", "ie", "its", "il", "ui", "or", "ori", "has", "ir", "iris", "abs", "are", "im"], "url": ["r", "image", "sl", "stream", "rl", "feed", "impl", "layer", "id", "server", "address", "bel", "loc", "info", "connection", "http", "URL", "resource", "ref", "path", "ob", "pull", "ssl", "str", "link", "f", "Url", "base", "b", "ll", "l", "string", "web", "ur", "uri", "source", "www"], "fr": ["lr", "fin", "compl", "br", "rl", "form", "el", "fi", "fl", "il", "Fr", "fm", "fe", "sf", "ris", "dr", "adr", "fb", "raf", "fp", "ir", "rr", "rin", "fc", "sr", "rf", "f", "err", "range", "rel", "rt", "kr", "arr", "fer", "yr", "frac", "ur", "tr", "pr"], "results": ["items", "vals", "details", "models", "files", "grades", "ips", "maps", "features", "properties", "objects", "result", "response", "reports", "terms", "params", "resources", "roots", "changes", "relations", "values", "forms", "groups", "errors", "RESULTS", "lists", "rows", "ids", "versions", "res", "runs", "rules", "Results", "devices", "tests", "plugins"]}}
{"id1": "23510383", "id2": "19868933", "code1": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"saveProject": ["deleteproject", "deleteModel", "insertModel", "saveModel", "deleteProject", "deleteApplication", " saveproject", "saveproject", " saveApplication", "saveApplication", "insertApplication", "insertproject", " saveModel", "insertProject"], "file": ["image", "db", "full", "files", "object", "use", "parent", "directory", "handler", "picture", "File", "complete", "plus", "connection", "found", "path", "resource", "fp", "single", "line", "out", "FILE", "work", "ile", "part", "dir", "base", "model", "zip", "data", "log", "local", "document", "table", "project", "folder", "lock", "filename"], "types": ["locks", "cats", "words", "styles", "models", "files", "boxes", "tags", "strings", "products", "its", "packages", "archives", "pes", "projects", "links", "features", "properties", "keys", "objects", "stores", "services", "reports", "packs", "params", "resources", "jobs", "Types", "tools", "ions", "options", "classes", "ts", "relations", "pages", "opens", "uploads", "ames", "blocks", "forms", "users", "groups", "lists", "times", "eps", "names", "ids", "settings", "versions", "shows", "parts", "ports", "thumbnails", "Images", "photos", "tests", "ypes", "fields", "plugins"], "images": ["image", "scripts", "styles", "assets", "files", "boxes", "tags", "ips", "events", "features", "rooms", "media", "services", "reports", "modules", "png", "uploads", "actions", "blocks", "users", "views", "versions", "videos", "thumbnails", "Images", "photos", "plugins"], "trajectories": ["traveyories", "traveyions", "transjectories", "trajectors", "traventors", "traveyory", "tracessory", "traventory", "traventions", "traventories", "transjectors", "trajectory", "trajections", "traveyors", "transjectory", "tracessories", "tracessors", "transcessors", "transcessories", "transcessions", "tracessions", "transjections", "transcessory"], "databasesIncluded": ["databytesInshibited", "databasesINcluded", "databasesInscluded", "daturesInclusive", "databasesINclusion", "daturesInclusion", "databasesInshibited", "databasesinclusion", "databasesInclusion", "daturesInshibited", "databytesInscluding", "databasesInsclusive", "databasesOuthibited", "databasesInclusive", "databasesOutclusion", "databasesOutclusive", "daturesIncluded", "databytesIncluding", "databasesinhibited", "databasesOutcluded", "databasesinclusive", "databasesInscluding", "databytesIncluded", "daturesInsclusive", "databasesincluded", "databytesInhibited", "databasesIncluding", "databasesINcluding", "databasesInhibited", "databasesOutcluding", "databytesInsclusion", "databasesINhibited", "daturesInsclusion", "daturesInscluded", "daturesInhibited", "databasesInsclusion", "databytesInscluded", "databytesInclusion"], "onlyLinks": ["onlyFiles", "onlyLink", "allLink", "withlinks", " onlyLink", "alllinks", "OnlyLink", "OnlyFiles", "withLinks", "justFiles", "justLinks", "withLink", " onlyFiles", "onlylinks", "justLink", "allLinks", " onlylinks", "OnlyLinks"], "index": ["ind", "position", "match", "level", "size", "i", "key", "pattern", "default", "old", "slice", "input", "id", "page", "address", "tail", "found", "num", "weight", "ini", "value", "part", "end", "x", "xxx", "offset", "Index", "search", "number", "width", "string", "point", "head", "length", "initial", "inc"], "name": ["image", "stage", "domain", "large", "size", "full", "up", "key", "default", "title", "id", "home", "connection", "ext", "path", "message", "resource", "unique", "part", "NAME", "url", "none", "base", "data", "temp", "Name", "number", "names", "memory", "string", "named", "vision", "filename"], "format": ["position", "template", "term", "form", "pattern", "layout", "init", "feed", "handler", "pretty", "Format", "function", "value", "date", "at", "config", "letter", "prefix", "unit", "base", "scale", "data", "temp", "struct", "offset", "transform", "status", "text", "language", "export", "style", "string", "header", "parser", "current", "external", "filename"], "count": ["process", "error", "match", "level", "Count", "parent", "page", "limit", "cache", "child", "code", "found", "content", "sum", "path", "num", "weight", "build", "depth", "base", "force", "call", "age", "counter", "list", "length"], "version": ["video", "image", "release", "master", "output", "default", "Version", "environment", "section", "directory", "server", "target", "ver", "content", "xml", "manager", "description", "VERSION", "cover", "dir", "channel", "feature", "platform", "update", "data", "download", "vert", "v", "database", "application", "versions", "python", "project", "string", "header", "vision", "draft", "journal", "config", "latest"], "writer": ["former", "wire", "buffer", "creator", "worker", "author", "output", "write", "page", "handler", "Writer", "written", "writers", "editor", "war", "word", "xml", "later", "out", "manager", "wr", "book", "director", "riter", "letter", "engine", "wrapper", "data", "builder", "temp", "player", "er", "w", "wave", "document", "export", "driver", "writ", "reader", "parser", "journal", "writing", "widget", "W", "walker"], "xmlDir": ["databaseArea", "externalFolder", "imageDir", "externalDir", "imageDirectory", "xmlFile", "xmlFolder", "databasePath", "externalDirectory", "xmlPath", " xmlFile", "jsonArea", "imageFile", "xmlArea", "databaseDir", "externalFile", "jsonDirectory", "jsonDir", "databaseDirectory", " xmlArea", " xmlFolder", " xmlDirectory", "imageFolder", "xmlDirectory", "jsonPath", " xmlPath"], "databases": ["variabytes", "structables", "drogs", "datables", "Datables", "datations", "Datrooms", "databytes", "notabases", " datrooms", "drabases", "Databases", "Databytes", "diogs", "notrooms", "datases", " datations", " datases", "arrabytes", "arrases", "Datases", "drations", "structabytes", "notations", "arrabases", "structases", "datogs", "arrables", "variogs", "datrooms", "diabytes", "diabases", "structabases", "notases", "variabases", "drabytes", "variations", "diations", "Datations"], "t": ["att", "T", "template", "h", "p", "j", "m", "n", "q", "class", "i", "title", "e", "ty", "target", "ant", "o", "none", "y", "v", "token", "test", "w", "task", "tm", " T", "d", "string", "te", "Type", "c", "ts"], "type": ["error", "match", "template", "p", "block", "class", "key", "comment", "action", "slice", "parent", "e", "id", "attribute", "rule", "option", "ty", "to", "info", "group", "target", "result", "state", "op", "single", "value", "function", "part", "link", "o", "ype", "null", "set", "base", "definition", "data", "pe", "model", "y", "token", "test", "TYPE", "database", "collection", "language", "other", "role", "style", "string", "like", "field", "Type", "right"], "currentName": [" currentMember", "reportedAddress", " currentTime", "CurrentPath", "thisAddress", "recentTime", " currentKey", "thisPath", "recentMember", "futurePath", " currentFile", " currentPath", "currentPath", "currentMember", "thisTime", " currentNames", "CurrentNames", "futureNames", "thisType", "thisName", "CurrentName", "currentType", "reportedPath", "recentStyle", "currentNames", "currentKey", "futureFile", "CurrentAddress", "thisStyle", "reportedName", " currentType", "reportedNames", "currentStyle", "reportedType", " currentStyle", "CurrentType", "currentAddress", "reportedKey", "currentTime", "futureName", "recentName", "CurrentKey", "thisMember", "currentFile", "CurrentFile"], "baseCopy": ["basicSource", "baseName", "asecopy", "baseSource", "aseCopy", "BaseSource", "binaryCopy", "basicCreate", "baseCreate", "BaseShare", "BaseCopy", "aseName", " baseCreate", "baseCop", "basecopy", " baseCop", "BaseCop", " baseSource", "basiccopy", "basicCopy", " baseName", "binaryCop", "baseShare", " basecopy", "aseShare", "Basecopy", "binarycopy", " baseShare", "BaseName", "BaseCreate"], "source": ["image", "client", "clone", "component", "service", "size", "rate", "ie", "stream", "src", "object", "use", "proxy", "view", "scope", "input", "slice", "reference", "slave", "parent", "section", "core", "cache", "server", "option", "scene", "from", "target", "result", "connection", "inner", "resource", "manager", "dest", "Source", "storage", "channel", "base", "unit", "SOURCE", "text", "site", "reader", "remote", "current", "ource", "config", "ources"], "destination": ["Destment", "Destignment", "Destinated", "distinator", "constation", " destment", "constination", "destation", "distination", "transination", "destinations", "externalment", "Destribution", "constinations", "Destinations", "combination", "transignment", "externalinator", "Destinator", "combinator", "combation", "destment", " destinated", "destinator", "externalination", "destinated", "transinator", "transribution", "destribution", "Destation", "distribution", "combinations", " destinator", "Destination", "externalinated", "destignment", "distignment", "constinator"], "clefs": ["Cleflows", "clef", "clebs", " clef", "CLEFS", "Clebs", "Clefs", " cleFS", "CLEf", "CleFS", "Clef", " cleflows", " clebs", "CLEbs", "CLEflows", "cleFS", "cleflows", "CLEfs"], "st": ["ST", "sts", "sc", "fr", "sl", "ast", "St", "rd", "src", "ste", "bt", "std", "sa", "cr", "sn", "statement", "ist", "sb", "tt", "inst", "bl", "sta", "str", "start", "sm", "est", "set", "rest", "struct", "nd", "mt", "ct", "ost", "ss", "stru", "ld", "sth", "ust", "ts", "sp"], "rs": ["RS", "rd", " params", "rc", "Rs", " ra", " sq", "RC", " success", " Rs", " changes", " src", " ans", " sr", " rc", " rm", " obj", "res", " repl", " hits", "Res", " Result", " re", " matches", "R", " RS"]}}
{"id1": "22022715", "id2": "10158738", "code1": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "code2": "    public void add(String language, String tag, String root, String surface) throws FidoDatabaseException, MorphologyTagNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (containsTag(stmt, tag) == false) throw new MorphologyTagNotFoundException(tag);\n                if (isRuleUnique(stmt, language, tag, root, surface) == false) return;\n                int row;\n                if (root.equals(\"*\") == true) row = getAppendRowForTag(stmt, language, tag); else if (root.indexOf('*') == -1) row = getFirstRowForTag(stmt, language, tag); else row = getFirstRegularFormForTag(stmt, language, tag);\n                boolean use = determineRecognitionUse(root, surface);\n                bumpAllRowsDown(stmt, language, tag, row);\n                String sql = \"insert into LanguageMorphologies (LanguageName, Rank, Root, Surface, MorphologyTag, Used) \" + \"values ('\" + language + \"', \" + row + \", '\" + root + \"', '\" + surface + \"', '\" + tag + \"', \";\n                if (use == true) sql = sql + \"TRUE)\"; else sql = sql + \"FALSE)\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "label": 0, "substitutes": {"digest": [" digested", "mdester", "generest", "Digure", "Digit", "digger", "mdest", " digests", "mdit", "digests", "mdger", "dger", "Digest", "digure", "digit", "Digester", " digester", "dest", "doest", "Digests", "genest", "digester", "genester", "genests", "mdure", "generester", "mdested", "genested", "generit", "doested", "digested", "dester", "dit", "Digested", "generger", "doure", "doit"], "s": ["S", "os", "m", "bytes", "p", "words", "n", "g", "is", "i", "strings", "rs", "ls", "e", "ns", "ses", "es", "sb", "lines", "a", "message", "services", "params", "ssl", "sym", "ds", "f", "data", "b", "password", "ss", "d", "string", "ps", "gs", "ms", "ws", "source", "c"], "ret": ["success", "match", "xt", "obj", "bf", "key", "def", "reply", "default", "std", "RET", "nt", "valid", "val", "replace", "info", "result", "array", "ext", "out", "value", "Return", "fun", "rets", "rev", "alt", "pass", "al", "data", "pat", "rt", "secret", "Ret", "continue", "arr", "res", "addr", "hash", "det", "mem", "re", "arg", "repl"], "md": ["mm", "mac", "mo", "ind", "m", "Cmd", "dig", "mad", "pg", "ad", "pkg", "pd", "metadata", "arm", "um", "ma", "od", "cd", "editor", "mb", "amd", "nm", "df", "wd", "gd", "mand", "bd", "mg", "dm", "pm", "mt", "MD", "di", "mp", "me", "mc", "rpm", "mag", "hd", "d", "mod", "am", "meta", "cmd", "dd", " MD", "cb"]}}
{"id1": "5035872", "id2": "18974466", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    protected boolean copyFile(File sourceFile, File destinationFile) {\n        try {\n            FileChannel srcChannel = new FileInputStream(sourceFile).getChannel();\n            FileChannel dstChannel = new FileOutputStream(destinationFile).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            dstChannel.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n            return false;\n        }\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "src": ["image", "in", "sc", "sl", "upload", "obj", "stream", "files", "rc", "s", "sit", "input", "slice", "ls", "copy", "sin", "sb", "conn", "loc", "rb", "http", "path", "resource", "inst", "img", "dest", "file", "root", "dist", "config", "storage", "sel", "url", "st", "this", "data", "download", "b", "uri", "iv", "source", "filename"], "dst": ["Dcr", "addest", " dsts", "dsts", " dcr", "dds", "fdds", "ddest", "dbds", "Dsts", "fdput", " ddest", "fdot", "Ddest", "dbput", "Dst", "dot", "tdst", "dput", "adst", "tdds", "dbot", "tdot", "adcr", "adsts", "fdst", "dbst", "dcr", "tdput"], "inChannel": ["InContext", "againCamera", "outStream", "inputChannel", " inchannel", " inContext", "inchannel", "INStream", "innerChan", "INChan", "outchannel", "outChan", "loginCamera", "binChannel", "againChan", "outMessage", " inChan", "inMessage", "inCamera", "incChan", "againStream", "InStream", "incCamera", "inputchannel", "inputConnection", "innerStream", "incChannel", "binchannel", "INChannel", " inConnection", "InChan", "incStream", "inputChan", "inChan", "outConnection", "binChan", " inMessage", "loginChan", "againChannel", " inStream", "inConnection", "InChannel", "loginChannel", "binConnection", "Inchannel", "innerConnection", "INchannel", "INConnection", "loginStream", "innerChannel", "outContext", "inputStream", "inputMessage", "inContext", "binStream", "inStream"], "outChannel": ["againGate", "outGate", "outStream", " outchannel", "inputChannel", "inchannel", " outGate", "againConnection", "outchannel", "OutChan", "outChan", " outQueue", "OutChannel", "outputChan", "outputStream", "outWriter", " outWriter", "offChan", "inQueue", "inWriter", "outputchannel", "againchannel", "againStream", "inputchannel", " outChan", "outputChannel", " outConnection", " outStream", "Outchannel", "againChannel", "inputChan", "inChan", "outConnection", "outQueue", "againQueue", "inConnection", "offContext", "offChannel", " outContext", "inGate", "offWriter", "outContext", "inputStream", "OutStream", "inContext", "againChan", "inStream"], "result": ["r", "success", "compl", "match", "error", "card", "default", "comment", "use", "future", "valid", "cache", "complete", "diff", "or", "found", "array", "response", "successful", "Result", "ret", "results", "work", "function", "cash", "ault", "f", "pass", "cup", "err", "data", "false", "done", "test", "status", "continue", "res", "true", "math", "ure", "folder", "event", "current", "func", "length"]}}
{"id1": "14567939", "id2": "2807585", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"baseHash": [" generateHash", " chainFile", " chainHash", "BaseSecret", "BaseFile", "Basehash", "basehash", "BaseHash", " generateSecret", " generatehash", " chainhash", " chainSecret", " generateFile", "baseSecret", "baseFile"], "name": ["image", "hello", "n", "key", "class", "host", "object", "user", "parent", "id", "address", "ame", "alias", "path", "resource", "word", "file", "part", "NAME", "prefix", "normal", "base", "definition", "data", "type", "secret", "Name", "names", "member", "style", "string", "named", "hash", "create", "account"], "password": ["account", "words", "crypt", "key", "profile", "pattern", "input", "attribute", "sword", "phrase", "source", "diff", "padding", "Password", "code", "path", "word", "value", "wd", "prefix", "device", "pass", "security", "wallet", "data", "paste", "token", "secret", "text", "auth", "string", "stroke", "seed", "hash", "priv", "PASS", "username"], "digest": ["mdr", " digested", "signest", "mdester", " digger", "digusher", "DigEST", "digger", "mdest", "diger", "Diger", "modested", "moder", "signger", "Digest", "Digger", " diger", "Digester", " digester", "signusher", "modest", "digester", "digEST", "decest", "mdEST", "modester", "Digr", "signer", "decester", "decEST", "Digusher", " digusher", "digested", "digr", "Digested", "decr", "signester"]}}
{"id1": "17202158", "id2": "20128728", "code1": "    static HashSet<Integer> readZoneIDs(String zoneFileName) {\n        HashSet<Integer> zoneids = new HashSet<Integer>();\n        try {\n            URL url = zoneFileName.getClass().getResource(zoneFileName);\n            LineNumberReader lnr = new LineNumberReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = lnr.readLine()) != null) zoneids.add(Integer.parseInt(line));\n        } catch (Exception xc) {\n            xc.printStackTrace();\n        }\n        return zoneids;\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"readZoneIDs": ["readZoneID", "readZoneNames", "readLocationID", "loadzoneID", "loadzoneIDs", "loadZoneID", "readLocationIDS", "readzoneNames", "readzoneID", "loadzoneNames", "readLocationIDs", "readzoneIDs", "readZoneIDS", "readCodeIDs", "readCodeID", "loadzoneIDS", "readCodeIDS", "readzoneIDS", "loadZoneIDS", "loadZoneNames", "loadZoneIDs", "readLocationNames", "readCodeNames"], "zoneFileName": ["zonefileUrl", "ZoneFilename", "ZonefilePath", "zoneFilePath", "zoneFilesName", "ZoneFileUrl", "zoneFileUrl", "ZonefileUrl", "zoneFullUrl", " zoneDirUrl", "zoneFullName", "zoneClassName", "zoneClassPath", "zoneFilesPath", "zoneLinePath", " zoneFilePath", "Zonefilename", "zoneDirName", "zoneLineUrl", "ZoneFilePath", "zoneFilesname", "zoneDirUrl", "zoneFilename", " zoneDirName", "zoneLineName", "ZonefileName", "zoneFilesUrl", "zoneDirPath", "ZoneFileName", "zoneFullname", "zonefilename", "zoneClassname", " zoneDirPath", "zoneClassUrl", " zoneFileUrl", "zoneFullPath", "zonefileName", "zonefilePath"], "zoneids": ["zipids", "sizeips", " zoneips", " zoneints", "sizeids", " zonelines", "sizeid", "zoneIDs", "typeips", "sizeints", "typeids", "poIDs", "typeid", "poids", "Zoneids", " zoneid", "typeints", "pofiles", " zoneIDs", "zonelines", " zonefiles", "zoneints", "Zoneid", "ziplines", "zipid", "poid", "zoneid", "Zonefiles", "polines", "zoneips", "zipIDs", "ZoneIDs", "zonefiles"], "url": ["ball", "job", "r", "client", "buffer", "service", "sl", "stream", "class", "feed", "user", "page", "server", "address", "bel", "connection", "http", "location", "URL", "resource", "path", "hub", "io", "ssl", "file", "f", "Url", "this", "api", "base", "channel", "data", "loader", "b", "name", "l", "reader", "string", "ur", "uri", "re", "source"], "lnr": ["lenr", "nlw", "rlr", "rlb", "linrb", "lnw", "nlr", "slr", "linr", "rln", "sln", "linb", "slb", "nlp", "rlrb", "lenw", "lnrb", "lenb", "linn", "lnp", "lnb", "slrb", "lnn", "nlb", "lenp", "linp", "linw"], "line": ["ne", "sl", "lf", "entry", "block", "key", "cell", "comment", "el", "parse", "id", "page", "lc", "rule", "lines", "Line", "lin", "code", "response", "message", "word", "row", "file", "str", "part", "link", "ge", "sel", "col", "letter", "no", "base", "unit", "inline", "data", "log", "char", "LINE", "number", "cl", "name", "l", "string", "header", "nl", "le", "look", "column", "c", "jo"]}}
{"id1": "6260216", "id2": "873012", "code1": "    public InputStream send(String s, String s1) throws IOException {\n        HttpURLConnection httpurlconnection = null;\n        DataInputStream datainputstream = null;\n        System.setProperty(\"java.protocol.handler.pkgs\", \"com.sun.net.ssl.internal.www.protocol\");\n        URL url = new URL(s1);\n        httpurlconnection = (HttpURLConnection) url.openConnection();\n        configureURLConnection(httpurlconnection);\n        DataOutputStream dataoutputstream = new DataOutputStream(httpurlconnection.getOutputStream());\n        dataoutputstream.write(s.getBytes());\n        httpurlconnection.connect();\n        datainputstream = new DataInputStream(httpurlconnection.getInputStream());\n        if (httpurlconnection.getResponseCode() != 200) {\n            System.out.println(\"Invalid Response Code! Code Returned = \" + Integer.toString(httpurlconnection.getResponseCode()));\n            return null;\n        }\n        if (!httpurlconnection.getContentType().equalsIgnoreCase(\"Text/xml\")) {\n            System.out.println(\"Invalid Content-Type! Content type of response received = \" + httpurlconnection.getContentType());\n            return null;\n        } else {\n            return datainputstream;\n        }\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"send": ["request", "get", "process", "Send", "transfer", "reply", "sent", "write", "open", "from", "submit", "report", "pack", "exec", "update", "download", "execute", "append", "transform", "text", "method", "export", "call", "invoke", "command", "flush", "dump"], "s": ["S", "os", "details", "bytes", "p", "n", "qs", "files", "i", "is", "bs", "strings", "its", "ls", "ns", "ips", "ses", "es", "t", "sb", "lines", "objects", "services", "aws", "params", "ssl", "ions", "ings", "abs", "f", "opens", "sets", "uploads", "o", "u", "b", "rows", "ops", "ids", "l", "d", "string", "ps", "gs"], "s1": ["S1", "p1", "strings1", "s81", "s2", "ssl0", "strings2", "p0", "ses81", "ssl2", "p01", "S0", "S2", "ses1", "ses0", "strings0", "s0", "S01", "ses2", "s01", "ssl1", "S81", "strings01", "ssl81", "p2"], "httpurlconnection": ["httpstringsystem", "httpstringConnection", " httpurlsystem", "httplookconnect", "httpllconnect", "Httpurlproblem", "httpurlconnect", "httpreturnposition", "httpsurlconnect", "workhttpconnection", "urlllconnection", " httpshellConnection", "httphttpconnection", "httphttpconnect", "httpwebreference", "httpwebconn", "httpsurlConnection", "urlURLurl", "httpresourceconnection", "httpurlmanager", "httphttpcreation", "httpsbaserelation", "httplproblem", "httpshellconnection", "httpsurlcommunication", "httpwebrelation", " httpshellchannel", "httppullconnect", "httpURLconn", "Httpurlposition", "httpslcommunication", "workurlconn", " httpurlConnection", "Httpfileposition", "urlurlConnection", "httpwebconnection", "httpbreakcreation", "httpfileproblem", "httpweburl", "httpsurlmanager", "httpresourceconnect", "httpstringchannel", "httpshellConnection", "httpurlservice", "httpllrelation", "httpurlposition", "httplogrelation", "httplookrelation", "httpslreference", "httpslogcommunication", "httpURLurl", "httpURLcommunication", "httpurlreference", "httpllconnection", "httpcollconnection", "httplconnect", "httplogcommunication", "httpwebcommunication", "httpurlconn", "httplogConnection", "httpURLreference", "httpsurlfunction", "httpurlfunction", " httpresourceposition", "httpsbaseconnect", "httpresourceconn", "httpslconnection", "Httpurlconnection", "httpcollconn", "httpurlsystem", "httpresourceposition", "httpreturnconnection", "httplcommunication", " httpurlconn", "httpslservice", "httpslurl", "httpstringconnection", "httpscollservice", "httphttpConnection", "httpURLservice", " httpshellconnection", " httpresourceconnection", "httphttpcommunication", "httpsurlconnection", " httpshellsystem", " httpresourceconn", "workhttpconnect", "urlllConnection", "httpbasefunction", "workhttpconn", "urlllcommunication", "httpfileposition", "httplconn", "httpbreakconn", "httpreturnConnection", "httpsbaseconnection", "httpURLconnection", "Httpfilecommunication", " httpurlposition", "urlurlcommunication", "httpshellchannel", "httpsurlservice", " httpurlchannel", "workhttpcreation", "urlURLcommunication", "httpurlurl", "httpreturnproblem", "httpsURLrelation", "httpsbasefunction", " httpurlconnect", "httpfilecommunication", "httplconnection", "httplogconn", "httplogconnect", "httplookconnection", "httpslconn", "httppullConnection", "httpbreakconnect", "httpurlchannel", "httpcollchannel", "Httpfileproblem", "httplookfunction", "httpshellsystem", "urlURLconnection", "httpsURLconnection", "httpllConnection", "httpreturncommunication", "httpslogconn", "httpurlrelation", "httpsurlrelation", "httpbreakconnection", "httpurlcreation", "urlURLreference", " httpresourceconnect", "Httpurlcommunication", "httpurlproblem", "httpsurlconn", "httpscollconnection", "httplposition", "httpcollservice", "httpslogconnection", "urlurlreference", "urlllconnect", "httpURLmanager", "httpscollmanager", "httpscollconn", "httpbaserelation", "httpbaseconnection", "Httpfileconnection", "httplogfunction", "httpslmanager", "httpURLrelation", "httpsURLcommunication", "httpcollConnection", "workurlconnection", "httplConnection", "httpslogConnection", "httpsURLconn", "httpfileconnection", "httpbaseconnect", "urlurlconnection", "httpurlcommunication", "httpcollsystem", "workurlcreation", "httpllconn", "httpcollmanager", "httpreturnconnect", "urlurlurl", "httpllcommunication", "urlurlconnect", "httppullcommunication", "httppullconnection", "httplogposition", "workurlconnect", "httpurlConnection", "httphttpconn", "httplogconnection", "httpllcreation"], "datainputstream": ["datrainoutputpath", "datanacutpath", "datainlogstream", "dataincutpath", "datainlogsw", "datainststream", "datrainputsw", "datainoutputpath", "dataincutview", "datainstform", "datainstructform", "datainoutputStream", "datanacutstream", "datainlogpath", "datainstructpath", "datanaputsw", "datanacutview", "dataincutsw", "datainutpath", "datanaputstream", "datainstructstream", "datainutstream", "datainutview", "datrainoutputsw", "datanaputview", "datrainoutputform", "datainputsw", "datainputStream", "datrainputpath", "datainvalsw", "datainstructStream", "datainvalstream", "datainlogview", "datainstpath", "datrainputStream", "datanacutsw", "datainutsw", "dataincutstream", "datainoutputsw", "datrainputstream", "datainutStream", "datainvalStream", "datainoutputform", "datrainoutputstream", "datainvalpath", "datrainoutputStream", "datainoutputstream", "datainputpath", "datanaputpath", "datainstStream", "datainputview", "datainputform", "datrainputform"], "url": ["fr", "sl", "ul", "g", "stream", "rl", "host", "feed", "fl", "ls", "bb", "lc", "www", "page", "server", "address", "conn", "loc", "connection", "http", "li", "URL", "resource", "ob", "ssl", "file", "f", "Url", "api", "base", "gl", "log", "org", "ll", "l", "string", "web", "ur", "uri", "source", "config", "c"], "dataoutputstream": [" dataoutputpath", "dataOutputStream", "dataOutputpath", "datainputchannel", " dataoutputStream", " dataputpath", " dataoutputchannel", "datainputStream", "dataoutputchannel", " dataputstream", " dataputchannel", "dataOutputchannel", "dataputchannel", " dataputStream", "dataputpath", "dataputStream", "dataoutputpath", "dataputstream", "dataoutputStream", "datainputpath", "dataOutputstream"]}}
{"id1": "22993368", "id2": "18433984", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "6457199", "id2": "13333160", "code1": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"doRequest": [" doCall", "doResponse", "doProxy", "runProxy", "DoCall", "runCall", "runResponse", "DoRequest", " doResponse", "doCall", " doProxy", "DoProxy", "DoResponse", "runRequest"], "request": ["error", "client", "buffer", "query", "hello", "queue", "view", "object", "context", "user", "instance", "reference", "route", "server", "json", "complete", "result", "http", "report", "message", "xml", "url", "req", "session", "application", "method", "call", "name", "Request", "reader", "string", "uri", "event", "re", "right"], "response": ["success", "error", "client", "writer", "template", "service", " Response", "host", "output", "reply", "view", "object", "feed", "respons", "reference", "parent", "route", "page", "server", "json", "more", "result", "connection", "http", "report", "message", "index", "results", "Response", "out", "resp", "api", "onse", "model", "v", "status", "application", "document", "site", "body", "respond", "re"], "path": ["image", "template", "p", "PATH", "left", "full", "walk", "key", "host", "pattern", "object", "context", "slice", "route", "id", "patch", "port", "child", "info", "alias", "relative", "pointer", "Path", "http", "location", "message", "code", "content", "inner", "index", "work", "part", "end", "dir", "url", "prefix", "ith", "api", "base", "data", "type", "arc", "partial", "token", "text", "method", "name", "ath", "anc", "string", "uri", "source", "self", "right"], "internal": ["actual", "absolute", "special", "original", "attr", "rc", "context", "impl", "parent", "rx", "route", "origin", "outside", "source", "alias", "relative", "http", "ident", "inner", "standard", "single", "central", "regular", "storage", "inside", "x", "url", "prefix", "normal", "api", "base", "binary", "inline", "primary", "system", "re", "local", "exclusive", "personal", "foreign", "name", "intern", "background", "Internal", "custom", "remote", "string", "uri", "join", "shared", "external", "initial", "international"], "resource": ["r", "image", "client", "buffer", "ruby", "stream", "src", "Resource", "relation", "rc", "use", "context", "reference", "route", "rule", "server", "address", "result", "media", "connection", "http", "pointer", "resources", "real", "manager", "file", "rera", "sr", "url", "this", "api", "base", "rest", "range", "record", "res", "external", "string", "resolution", "uri", "re", "ource", "source"], "mimeType": ["pipTypes", "smimeName", "manceTypes", "smIMEInfo", " mileTypes", " mileInfo", "mimesType", "mimetype", "mipTypes", "pimePath", "mancePath", "mIMEType", "milePath", "mpePath", "pimeType", "mimesPath", "smIMEtype", "mipType", "mimeName", "modType", "mpeType", "smIMEType", "pimeTypes", "monseTypes", "mimePath", " mileType", "mimeTypes", "mancetype", "monsetype", "pimetype", "maxName", "smimeType", "miptype", "piptype", "pipType", "monsePath", "modInfo", "smIMEName", " mimeTypes", "pipPath", "mileInfo", "maxtype", "mimesInfo", " mimeInfo", "maxType", "monseType", "smimetype", "mpeTypes", " milePath", "manceType", "mIMEName", "mimesTypes", "mimeInfo", " mimePath", "mileType", "mileTypes", "maxInfo", "mIMEtype", "modtype", "smimeInfo", "mpeInfo", "modName", "mipPath", "mIMEInfo"], "is": ["lis", "ip", "in", "Is", "us", "bis", "iso", "isa", "i", "ois", "its", "was", "isi", "ris", "IS", "ui", "info", "or", "iss", "http", "ios", "ori", "isc", "nis", "ras", "ir", "iris", "ais", "fs", "api", "serv", "sis", "ri", "are", "im", "ops", "vs", "res", "as", "ps", "uri"], "os": ["us", "iso", "oss", "ies", "dos", "ose", "bs", "s", "cs", "ows", "ros", "aos", "los", "cos", "ios", "ori", "oses", "io", "ais", "nos", "OS", "osi", "ols", "o", "opens", "oS", "so", "ops", "vs", "bos", "res", "acs", "as", "ps", "Os", "outs", "oes"]}}
{"id1": "8166767", "id2": "20602651", "code1": "    public Object invoke(MethodInvocation invocation, int retryTimes) throws Throwable {\n        retryTimes--;\n        try {\n            String url = getServiceUrl() + \"/\" + invocation.getMethod().getName();\n            HttpPost postMethod = new HttpPost(url);\n            if (invocation.getMethod().getParameterTypes().length > 0) postMethod.setEntity(new StringEntity(JsonUtils.toJson(invocation.getArguments())));\n            HttpResponse rsp = HttpClientUtils.getDefaultInstance().execute(postMethod);\n            StatusLine sl = rsp.getStatusLine();\n            if (sl.getStatusCode() >= 300) {\n                throw new RuntimeException(\"Did not receive successful HTTP response: status code = \" + sl.getStatusCode() + \", status message = [\" + sl.getReasonPhrase() + \"]\");\n            }\n            HttpEntity entity = rsp.getEntity();\n            StringBuilder sb = new StringBuilder();\n            InputStream is = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(is, \"utf-8\"));\n            String line;\n            while ((line = reader.readLine()) != null) sb.append(line).append(\"\\n\");\n            reader.close();\n            is.close();\n            String responseBody = null;\n            if (sb.length() > 0) {\n                sb.deleteCharAt(sb.length() - 1);\n                responseBody = sb.toString();\n            }\n            Type t = invocation.getMethod().getGenericReturnType();\n            if (t.equals(Void.class) || responseBody == null) return null;\n            return JsonUtils.fromJson(responseBody, t);\n        } catch (ConnectTimeoutException e) {\n            if (retryTimes < 0) throw e;\n            if (urlFromDiscovery) {\n                String serviceUrl = discoverServiceUrl(getServiceInterface().getName());\n                if (!serviceUrl.equals(getServiceUrl())) {\n                    setServiceUrl(serviceUrl);\n                    log.info(\"relocate service url:\" + serviceUrl);\n                }\n            }\n            return invoke(invocation, retryTimes);\n        }\n    }\n", "code2": "    protected void readURL(URL url) {\n        InputStream istream = null;\n        InputStreamReader isr = null;\n        BufferedReader in = null;\n        try {\n            istream = url.openStream();\n            isr = new InputStreamReader(istream);\n            in = new BufferedReader(isr);\n            String line = in.readLine();\n            while (null != line) {\n                System.out.println(line);\n                line = in.readLine();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            IOUtilities.close(in);\n            IOUtilities.close(isr);\n            IOUtilities.close(istream);\n        }\n    }\n", "label": 1, "substitutes": {"invoke": ["request", "next", "process", "in", "timeout", "service", "fire", "reply", "object", "java", "construct", "reflect", " invoking", "instance", "online", "run", "apply", "open", "info", "evaluate", " execute", "to", "handle", "connection", "http", "submit", "resource", "operation", "send", "post", "start", "exec", "execute", "oke", "via", "call", "wrap", "olve", "create", "func", "initial"], "invocation": ["implocation", "imploked", "imploice", "alloker", "invoking", "envoid", "alloke", "convoice", " invoker", " invoking", " invoked", "convoke", "allocation", "Invoice", "envocation", "inoking", "inoker", "invoked", "installoid", "inocation", "inviation", "Inviation", " invoice", "alloked", "alloice", "invoid", "Invocation", "installoker", "Invoking", "Invoker", "enviation", "imploke", "invoice", "convoker", "convocation", "Invoid", "installocation", "envoker", "invoker", "installiation", "Invoke"], "retryTimes": ["retayYears", "retryPoints", "rettryPoints", "RetryYears", "RetryTS", "retriedTS", "rettryTimes", "retryTokens", "retrainTime", "retryDays", "rettryTime", "retyPoints", "retryYears", "RetryPoints", "retyTime", "retvalDays", "reryTime", "reryTimes", "retrowTime", "RetryHours", "retyHours", "retryTime", "RetryingTS", "RetryingHours", "retriedTimes", "retryingHours", "retayTimes", "retryingYears", "retryingPoints", "retryingTokens", "retayTime", "retyTimes", "retriedYears", "retryingTimes", "RetryTime", "reryDays", "retrowTokens", "retrowTimes", "retryingTS", "retrainTokens", "retrowPoints", "retvalPoints", "RetryTokens", "retvalTimes", "retriedHours", "RetryingTime", "retryHours", "retryingTime", "RetryingPoints", "retrainTimes", "RetryingYears", "retvalTime", "retryTS", "RetryingTokens", "RetryingTimes", "retriedTime", "rettryDays", "retrainPoints", "RetryTimes", "retryingDays", "retriedPoints", "retayTS", "reryPoints"], "url": ["r", "image", "enabled", "service", "email", "html", "rl", "src", "host", "ls", "route", "id", "server", "json", "address", "loc", "location", "http", "URL", "resource", "response", "path", "ssl", "f", "Url", "channel", "base", "ll", "method", "name", "l", "string", "href", "uri", "source", "config", "www"], "postMethod": ["headMethod", "headFunction", " postPost", "postMethods", "PostPost", "PostMethod", "PostRequest", "headPost", "postPost", "POSTPost", " postMethods", "POSTMethod", "getMethods", "PostFunction", "getFunction", " postOperation", "getMethod", "headMethods", "PostOperation", "postFunction", "postRequest", "PostMethods", " postRequest", " postFunction", "POSTOperation", "getRequest", "postOperation", "POSTFunction"], "rsp": [" rSp", "srsp", "srpc", "frSp", "rpc", "srsl", "Rserv", "rSp", " rsc", " rpc", " rsl", "Rpc", "rcsh", "srserv", "rsc", "rssl", " rserv", "RSp", "frsc", "rcsc", "rsh", "rcsl", "Rsc", "rssp", "rsl", "rserv", " rsh", "Rsl", "Rsp", "frsp", "rssc", "rssh", "rcsp", "frsl"], "sl": ["sil", "su", "la", "fr", "sw", "sync", "isl", "cel", "rl", "el", "SB", "Sl", "fl", "ls", "il", "cli", "sn", "lc", "hl", "SL", "coll", "sf", "sh", "bl", "se", "sle", "ssl", "sr", "sel", " Sl", "dl", "ll", "shell", "cl", "status", "kl", "l", "si", "nl", "ser", "pl", "sp"], "entity": ["service", "email", "obj", "output", "el", "e", "environment", "page", "json", "metadata", "agent", "info", "result", "connection", "content", "http", "response", "resource", "Entity", "message", "xml", "oter", "translation", "enc", "api", "model", "data", "type", "ent", "article", "collection", "em", "application", "document", "node", "et", "body", "string", "person", "source"], "sb": ["lr", "db", "su", "bp", "txt", "bf", "src", "ab", "lb", "bs", "s", "bt", "SB", "ib", "bb", "sa", "usb", "sf", "info", "sg", "bc", "rb", "fb", "bm", "kb", "bg", "mb", "ob", "buff", "gb", "ssl", "bj", "pb", "ub", "bh", "abs", "sr", "bd", "eb", "wb", "sm", "sq", "b", "split", "bsp", "xb", "obb", "ss", "string", "si", "nb", "lab", "sth", "sv", "ws", "orb", "cb", "rob", "sp"], "is": ["lis", "ai", "ip", "in", "os", "Is", "iri", "bis", "ie", "iso", "stream", "isa", "src", "i", "s", "was", "its", "ib", "rx", "id", "es", "isi", "ris", "address", "IS", "ui", "info", "or", "iss", "ios", "io", "has", "ob", "ir", "out", "iris", "str", "ais", "iter", "fs", "api", "serv", "ri", "data", "it", "ar", "as", "si", "uri", "ser"], "reader": ["lr", "r", "in", "writer", "buffer", "ner", "Reader", "entry", "stream", "rer", "ink", "i", "rc", "s", "feed", "e", "rx", "ry", "handler", "server", "per", "or", "ler", "rb", "inner", "editor", "io", "ob", "ir", "rr", "ini", "row", "reading", "rar", "iter", "f", " Reader", "ri", "er", "oder", "it", "l", "parser", "ser", "read"], "line": ["job", "lf", "sync", "block", "entry", "i", "key", "cell", "comment", "feed", "character", "e", "page", "lc", "cle", "lines", "end", "Line", "lin", "code", "response", "message", "li", "row", "str", "len", "ge", "sel", "part", "letter", "no", "unit", "base", "pass", "inline", "data", "pe", "b", "char", "LINE", "number", "text", "cl", "name", "l", "frame", "style", "body", "string", "header", "le", "non"], "responseBody": ["requestBody", "entitybody", "replyBody", "respText", "ResponsePart", "respMail", " responseContent", "replyContent", " responsePart", "responseMail", "entityBody", "responseMessage", "Responsebody", "requestbody", " responseMessage", "replyPart", "replyMessage", "ResponseMessage", "replybody", "ResponseContent", "ResponseBody", "respBody", "responsebody", "responsePart", "entityMail", "respbody", " responsebody", " responseText", "entityText", " responseMail", "responseContent", "responseText", "requestContent"], "t": ["r", "T", "m", "h", "p", "template", "g", "n", "i", "class", "types", "s", "e", "target", "format", "ext", "dt", "ant", "en", "x", "f", "ot", "o", "st", "k", "type", "u", " type", "y", "v", "w", "it", "ct", "total", "l", " T", "et", "d", "wt", "te", "tf", "tor", "Type", "c", "ts"], "serviceUrl": ["storageLine", " serviceName", "ServiceSl", "serviceId", "storageURL", "ServiceName", " serviceUr", "serverStr", "playURL", " serviceStr", "serverName", "ServiceLine", "ServiceUr", "serviceStr", "storageUrl", "playName", "playUrl", "serviceName", " serviceSl", "serviceLine", "ServiceLink", "serviceURL", "ServiceURL", "ServiceId", "serviceLink", "ServiceStr", "ServiceUrl", " serviceURL", "playSl", "serverUr", "serverId", "responseUrl", "responseLink", "responseLine", "serverUrl", "serverURL", "responseURL", "serviceSl", "storageLink", "serviceUr", " serviceId"]}}
{"id1": "2834524", "id2": "15645004", "code1": "    public void write() throws IOException {\n        JarOutputStream jarOut = new JarOutputStream(outputStream, manifest);\n        if (includeJars != null) {\n            HashSet allEntries = new HashSet(includeJars);\n            if (!ignoreDependencies) expandSet(allEntries);\n            for (Iterator iterator = allEntries.iterator(); iterator.hasNext(); ) {\n                JarFile jar = getJarFile(iterator.next());\n                Enumeration jarEntries = jar.entries();\n                while (jarEntries.hasMoreElements()) {\n                    ZipEntry o1 = (ZipEntry) jarEntries.nextElement();\n                    if (o1.getName().equalsIgnoreCase(\"META-INF/MANIFEST.MF\") || o1.getSize() <= 0) continue;\n                    jarOut.putNextEntry(o1);\n                    InputStream entryStream = jar.getInputStream(o1);\n                    IOUtils.copy(entryStream, jarOut);\n                    jarOut.closeEntry();\n                }\n            }\n        }\n        jarOut.finish();\n        jarOut.close();\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 1, "substitutes": {"write": ["process", "writer", "save", " rewrite", "sync", "all", "output", "delete", "rite", "load", "parse", "after", "println", "check", "run", "open", "handle", "out", "file", "post", "end", "Write", "update", "zip", "download", "append", "flush", "create"], "jarOut": ["garout", "jarIn", "garIn", "sheetOutput", " jarout", "jarCatalog", "javaOut", " jarCatalog", "tarOutput", "javaIn", "serOUT", "jarOUT", "JarOut", "serout", "jarout", " jarOutput", "JarCatalog", "javaOutput", "garOut", "tarOUT", " jarIn", "jarOutput", "sheetIn", "tarOut", "javaOUT", "sheetOUT", "serIn", "javaout", " jarOUT", "tarout", "sheetOut", "JarOutput", "javaCatalog", "garOUT", "Jarout", "JarIn", "serOut", "JarOUT"], "allEntries": [" allEntories", "allAddrys", "Allentrys", "AllEntry", "allentrs", "allEntrys", "allChries", "allentries", "AllEntrys", "allTries", "AllEntrs", "allTrys", "AllEntries", "allChrys", "allentry", "Allentrs", "allTry", "allenties", "allEntry", "allAddry", " allEnties", "allentrys", "allEnties", "allEntrs", " allEntrys", "allentories", "allTrs", "allAddries", "Allentries", "allChies", "Allentry", "allChories", "allEntories"], "iterator": ["former", "next", "Iterator", "consider", "size", "creator", "query", "ie", "entry", "stream", "Iter", "eni", "i", "order", "river", "init", "slice", "basic", "instance", "section", "handler", "or", "division", "oper", "inst", "inner", "gener", "later", "keeper", "starter", "step", "now", "started", "start", "iter", "end", "engine", "ator", "set", "ators", "loader", "pie", "er", "inter", "runner", "collection", "heid", "done", "running", "skip", "processor", "ter", "finder", "reader", "list", "parser", "loop", "filter", "outer", "cmp", "uri", "ski", "walker"], "jar": ["job", "image", "in", "entry", "tar", "java", "sheet", "parse", "pkg", "archive", "json", "cookie", "jam", "module", "ler", "container", "tab", "audio", "war", "zone", "pack", "Jar", "keeper", "ssl", "magic", "file", "bag", "start", "dir", "space", "url", "binary", "base", "zip", "bar", "er", "drop", "tag", "star", "record", "browser", "ar", "mag", "plugin", "style", "folder", "pod", "ser", "docker", "ski", "config", "jo"], "jarEntries": ["parseEntrs", "jarAires", "jarEnies", " jarEntories", "jarEries", "jarEntorts", "jarEntryrys", " jarEnires", "jarIntories", "jarErs", "parseEntries", "jarEntories", " jarEntires", "jarEntrys", " jarEnies", "parseErs", "jarAories", "jarEntryorts", "parseEntories", "jarTires", "jarEntryies", "jarEnries", "jarErries", "jarEntrs", "jarIntries", "JarEntorts", "JarEntrys", "parseEntriers", "jarTies", "jarTories", "jarEnties", " jarEnries", "jarEriers", "jarEories", "jarIntrs", "JarEnties", "jarAies", " jarEnories", "parseEries", "jarEntriers", "JarEntries", "jarIntriers", " jarEnties", "jarEnories", "parseEriers", "jarEntryries", "jarErorts", "jarEnires", "jarAries", "jarEntires", "parseEories", "jarTries", "jarErrys"], "o1": ["oeinf", " oOne", "oinf", "oaOne", "oe1", "O0", "op3", "oaone", "so1", "soOne", "po1", "oainf", "o11", "oOne", "Opart", " opart", " oinf", "oa91", "oa0", " o91", " o0", "so3", "op1", "o0", "oe11", " oone", "O1", "oeone", "o4", "o91", "oe91", "oa1", "O3", " o3", "oa11", "oepart", "oe3", "OOne", "o3", "oone", "opOne", "oa4", " o4", "po11", "O11", "opart", "po4", " o11"], "entryStream": ["EntrySteam", "entrystream", "entrySteam", "entryReader", "Entrystream", "connectionReader", "zipStream", " entrySteam", "zipString", " entrystream", " entryString", "connectionStream", "EntryString", "EntryStream", "inputSteam", " entryReader", "connectionSteam", "entryString", "inputReader", "zipstream", "zipSteam", "inputStream"]}}
{"id1": "4398382", "id2": "5441579", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"digest": [" digested", "mdester", "encress", "Digse", "generest", "Digress", "digress", "mdest", " digests", "generests", "digests", "digse", "mdests", "Digest", "Digester", " digester", " digse", "digester", "encse", " digress", "encest", "generester", "mdested", "encester", "digested", "generested"], "algorithm": ["malgebra", "algebra", "aroding", "algo", "Alignment", "malignment", "challgebra", "aloding", "alenge", "Algebra", " alenge", "Algorithm", " algo", "challgo", "arignment", "argorithm", "Alenge", "Aloding", " algebra", "alignment", "argebra", "maloding", "malgorithm", "challgorithm", "Algo", "challenge"], "text": ["image", "buffer", "bytes", "output", "pattern", "object", "feed", "username", "Text", "sequence", "input", "attribute", "address", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "word", "value", "str", "url", "letter", "data", "struct", "token", "test", "secret", "name", "password", "string", "source", "config", "length", "txt"], "mDigest": ["mPostested", "mCodener", "MDgest", "mdigested", "mDEST", "mDester", " mDigester", " mDigast", "mCodest", "mDenge", "mDgest", " mGest", "amDigener", "mSignge", "MDest", "mdigester", "mDiger", "mDesignest", "mdigest", "mPostest", "mSignast", "mdiggest", "mGge", "mSignester", "mDesignester", "mSignEST", "mGester", "MDiger", "mDest", "amDigested", "mDigested", "amPostener", "amDigest", "mDigener", "mEncester", "MDigEST", "mCodested", " mGge", " mDigge", "mGast", "mSignest", "mDer", "mSignenge", "mDigEST", "MDester", "amPostested", " mGast", "mDigenge", "MDiggest", "MDigest", " mGester", "MDigenge", "mDigge", "amPostest", "mdigener", "mEncest", "mDiggest", "mGest", "mDigester", "mdiger", "mDesigner", "mPostener", "MDigester", "mDigast", "mDesigngest", "mEncast", "mEncge", "MDer"], "raw": ["image", "clean", "buffer", "original", "RAW", "full", "output", "default", "feed", "input", "instance", "internal", "unsigned", "serial", "json", "result", "array", "content", "response", "Raw", "message", "orig", "container", "row", "binary", "buf", "enc", "none", "null", "data", "partial", "wrap", "source", "initial", "hex"], "encoder": ["Encoded", " encoded", "enoder", "deccode", "enode", "enoding", "Encode", "Encoder", "encoding", "ecoded", "ecode", "encoded", "ecoder", "decoder", "enccode", "decode", "ecoding", "Encoding", "encode", "decoding", " encoding", " encode", "eccode"]}}
{"id1": "16353490", "id2": "1508161", "code1": "    private String executePost(String targetURL, String urlParameters) {\n        URL url;\n        HttpURLConnection connection = null;\n        try {\n            url = new URL(targetURL);\n            connection = (HttpURLConnection) url.openConnection();\n            connection.setRequestMethod(\"POST\");\n            connection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            connection.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(urlParameters.getBytes().length));\n            connection.setRequestProperty(\"Content-Language\", \"en-US\");\n            connection.setUseCaches(false);\n            connection.setDoInput(true);\n            connection.setDoOutput(true);\n            DataOutputStream wr = new DataOutputStream(connection.getOutputStream());\n            wr.writeBytes(urlParameters);\n            wr.flush();\n            wr.close();\n            InputStream is = connection.getInputStream();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n            String line;\n            StringBuffer response = new StringBuffer();\n            while ((line = rd.readLine()) != null) {\n                response.append(line);\n                response.append('\\r');\n            }\n            rd.close();\n            return response.toString();\n        } catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        } finally {\n            if (connection != null) {\n                connection.disconnect();\n            }\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"executePost": ["invokePosts", " executePosts", "executePOST", "sendPosts", "executePosts", " executePut", "sendPost", "sendPut", "sendPOST", "invokePut", " executePOST", "executePut", "invokePost", "invokePOST"], "targetURL": ["sourceLocation", "outputURI", " targetURI", "TargetURL", "targetUrl", "sourceURI", "outputURL", "TargetURI", "Targeturl", "outputurl", " targetUrl", "targetURI", "targeturl", "outputUrl", " targetLocation", "TargetLocation", "sourceurl", "targetLocation", "sourceURL", "TargetUrl", "sourceUrl"], "urlParameters": ["implParameters", "implRequirements", "formRequest", "httpParameters", "formParameters", "urlBytes", "URLParameters", "URLParameter", " urlRequest", "URLBytes", "urlRequirements", "httpPosition", "urlPosition", "httpRequest", "urlRequest", " urlBytes", " urlPosition", "URLString", "urlParameter", "URLRequirements", "httpParameter", "URLPosition", " urlRequirements", "implParameter", "implString", " urlParameter", "httpBytes", "urlString", " urlString", "formParameter"], "url": ["r", "image", "db", "client", "sl", "host", "proxy", "feed", "e", "page", "cache", "server", "address", "conn", "loc", "bc", "http", "location", "URL", "resource", "li", "path", "ob", "ssl", "file", "link", "f", "Url", "channel", "base", "zip", "session", "data", "log", "l", "string", "web", "uri", "Connection", "source", "config", "www"], "connection": ["image", "error", "query", "ctx", "sync", "entry", "environment", "section", "conn", "http", "director", "link", "wrapper", "conv", "body", "reader", "uri", "request", "db", "client", "connect", "component", "creator", "relation", "proxy", "character", "cache", "loc", "io", "close", "unit", "database", "ion", "command", "lock", "union", "writer", "service", "object", "use", "context", "lc", "directory", "result", "nc", "manager", "function", "channel", "log", "driver", "password", "remote", "communication", "source", "c", "position", "socket", "instance", "handler", "server", "resource", "con", "connected", "sql", "session", "contact", "collection", "application", "document", "network", "Connection", "current", "config", "condition"], "wr": ["wi", "r", "fw", "wire", "fr", "writer", "sw", "wal", "worker", "WR", "Wr", "raft", "rx", "RW", "cro", "dr", "ru", "wh", "rss", "war", "raf", "rh", "angler", "rr", "raw", "shr", "nr", "hr", "rw", "sr", "mr", "wb", "wer", "wa", "wp", "w", "nw", "vr", "wx", "wt", "usr", "ws", "rou", "pr", "wm"], "is": ["r", "os", "ai", "in", "Is", "bis", "iso", "stream", "isa", "src", "i", "isin", "s", "ois", "was", "rs", "rx", "ci", "isi", "ris", "conn", "IS", "ui", "iss", "rss", "ios", "war", "isc", "io", "has", "ir", "ini", "iris", "ais", "str", "sr", "serv", "ri", "rt", "ar", "as", "js", "ws"], "rd": ["lr", "r", "RD", "fr", "writer", "rl", "fd", "rc", "ro", "rs", "cr", "rx", "pd", "ud", "dra", "dr", "ru", "rb", "adr", "rm", "rss", "raf", "rh", "ra", "rr", "rod", "rar", "hr", "bd", "rw", "mr", "rt", "xd", "arr", "rn", "rg", "reader", "respond", "ld", "dd", "rob", "pr"], "line": ["r", "error", "part", "buffer", "obj", "lf", "sync", "sl", "block", "i", "key", "cell", "comment", "character", "parse", "e", "cr", "page", "lc", "lines", "Line", "lin", "code", "content", "message", "li", "raw", "row", "file", "str", "len", "link", "ge", "f", "letter", "end", "unit", "inline", "data", "pe", "err", "LINE", "text", "name", "l", "frame", "body", "string", "header", "reader", "source"], "response": ["request", "image", "error", "r", "buffer", "writer", "bytes", "one", "tree", "queue", "output", "reply", "default", "object", "feed", "view", "respons", "version", "page", "json", "server", "example", "answer", "result", "content", "array", "resource", "report", "message", "Response", "value", "description", "resp", "cover", "function", "out", "api", "data", "collection", "application", "text", "document", "site", "body", "respond", "string", "uri", "source"]}}
{"id1": "14001795", "id2": "18489832", "code1": "    public static void copyOverWarFile() {\n        System.out.println(\"Copy Over War File:\");\n        File dir = new File(theAppsDataDir);\n        FileFilter ff = new WildcardFileFilter(\"*.war\");\n        if (dir.listFiles(ff).length == 0) {\n            dir = new File(System.getProperty(\"user.dir\") + \"/war\");\n            if (dir.exists()) {\n                File[] files = dir.listFiles(ff);\n                for (File f : files) {\n                    try {\n                        File newFile = new File(\"\" + theAppsDataDir + \"/\" + f.getName());\n                        System.out.println(\"Creating new file \\\"\" + f.getAbsolutePath() + \"\\\"\");\n                        newFile.createNewFile();\n                        InputStream fi = new FileInputStream(f);\n                        OutputStream fo = new FileOutputStream(newFile);\n                        IOUtils.copy(fi, fo);\n                        moveUnzipAndExtract(newFile);\n                    } catch (Exception ex) {\n                        Logger.getLogger(AppDataDir.class.getName()).log(Level.SEVERE, null, ex);\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"Found a war in the apps data dir, ignoring a fresh copy\");\n        }\n        new JFileChooser().setCurrentDirectory(new File(theAppsDataDir));\n        System.setProperty(\"user.dir\", theAppsDataDir);\n        System.out.println(\"User.dir : \" + System.getProperty(\"user.dir\"));\n    }\n", "code2": "    private static URL downLoadZippedFile(URL url, File destDir) throws Exception {\n        URLConnection urlConnection = url.openConnection();\n        File tmpFile = null;\n        try {\n            tmpFile = File.createTempFile(\"remoteLib_\", null);\n            InputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = urlConnection.getInputStream();\n                out = new FileOutputStream(tmpFile);\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n                if (in != null) {\n                    in.close();\n                }\n            }\n            unzip(tmpFile, destDir);\n        } finally {\n            if (tmpFile != null) {\n                tmpFile.delete();\n            }\n        }\n        URL localURL = destDir.toURI().toURL();\n        return localURL;\n    }\n", "label": 1, "substitutes": {"copyOverWarFile": ["copyOverwarfile", "copyOverWarFiles", "copyOverWarfile", "copyOverWARPath", "copyOverWARfile", "copyoverwarPath", "copyOverWARFiles", "copyoverWarPath", "copyOverWARFile", "copyoverWarfile", "copyOverWebfile", "copyoverWarFile", "copyOverwarFiles", "copyoverWarFiles", "copyOverwarPath", "copyoverwarFile", "copyOverWebFiles", "copyOverwarFile", "copyoverwarFiles", "copyOverWebPath", "copyOverWarPath", "copyoverwarfile", "copyOverWebFile"], "dir": ["r", "db", "clean", "direct", "DIR", "def", "up", "fd", "class", "feed", "pkg", "parent", "directory", "handler", "cache", "coll", "md", " directory", "loc", "group", "dn", "dr", "handle", "dc", "http", "desc", "cur", "direction", "ir", "df", "work", "manager", "wd", "file", "director", "dist", "build", "part", "store", "url", "lib", "doc", "zip", "data", "download", "log", "keep", "local", "Dir", "di", "plugin", "d", "folder", "draft", "window", "lock", "config"], "ff": ["fw", "ph", "lf", "bf", "TF", "pp", "fox", "fd", "fam", "flow", "feed", "fl", "bb", "ft", "cf", "sf", "fe", "eph", "ef", "fb", "iff", "xff", "fp", "buff", "df", "now", "fold", "fed", "bd", "rf", "buf", "FF", "uff", "ffe", "ffff", "uf", "cpp", "eff", "cl", "fff", "fx", "upp", " buff", "dd", "aff", "cb"], "files": ["items", "balls", "locks", "models", "fa", "bs", "s", "sections", "fl", "ls", "events", "features", "lines", "keys", "objects", "fe", "jobs", "images", "results", "apps", "iles", "file", "classes", "Files", "pages", "fs", "data", "blocks", "users", "groups", "split", "rows", "names", "ums", "ps", "flows", "plugins"], "f": ["fr", "p", "lf", "bf", "n", "fa", "i", "fd", "feed", "fl", "fen", "e", " fa", "cf", "handler", "t", " file", "fe", "info", "sf", "inf", "fb", "fp", "fn", "fc", "file", "fold", "of", "part", "x", "rf", "fs", "flat", "v", "name", "l", "d", "tf", "F", "aff", "filename", "c"], "newFile": ["nextDir", "NewF", "newDir", "NewFolder", "NewFile", " newfile", "updateFile", "andDir", "oldF", " newF", "NewFiles", "updatefile", "updateLine", "nextFile", "oldFiles", "smallDir", "newLine", "oldDir", "newfile", "nextFolder", "NewDir", "existingLine", "nextFiles", "existingfile", "newF", "existingF", "oldFile", " newDir", "andfile", " newFolder", "smallFile", " newLine", " newFiles", "existingFile", "smallfile", "newFiles", "andFile", "newFolder", "updateF"], "fi": ["ico", "fin", "fw", "ifa", "fr", "flo", "lf", "cci", "fa", "i", "sci", "FI", "fy", "abi", "cf", "isi", "py", "sf", "fe", "info", "zi", "fb", "ii", "fp", "ini", "fc", "bi", "pi", "uci", "fs", "xi", "fine", "ffe", "afe", "shi", "Fi", "si", "ife", "qi", "afi", "ifi", "wi"], "fo": ["mo", "ico", "fw", "os", "lo", "ki", "obi", "flo", "fa", "olo", "ho", "ato", "po", "tto", "cf", "bo", "xf", "sf", "fe", "info", "oo", "inf", "FO", "io", "osa", "ko", "ofi", "zo", "wo", "o", "ni", "uf", "so", "co", "di", "afe", "shi", "si", "obo", "afi"]}}
{"id1": "4686922", "id2": "18793482", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceInResource", "extractResourcesAsResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceAndfile", "extractResourceAsResource", "extractResourceAsFile", "extractResourceAsfile", "extractResourcesAsfile", "extractResourcesAsFile", "extractResourceTofile", "extractResourceAndFile", "extractResourceAsFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceToResource", "extractResourcesTofile", "extractResourceInFile", "extractResourceAndResource", "extractResourceInfile", "extractResourceToFiles", "extractResourcesToFile", "extractResourcesAsFiles"], "resourcePath": ["servicePath", " resourceUrl", " resourceId", "resourceId", "stringFolder", "resourceFolder", "sourceId", "Resourcepath", "ResourceUrl", "ResourcePath", "sourcePath", "servicepath", " resourcepath", "resourcepath", "serviceFolder", "sourcepath", "ResourceId", "stringPath", "resourceUrl", "sourceUrl", "stringpath", " resourceFolder"], "dest": ["de", " Dest", "src", "output", "class", "transfer", "tmp", "comb", "default", "route", "const", "home", "Dest", "target", "result", "content", "desc", "path", "resource", "resources", "later", "img", "file", "sup", "dist", "config", "store", "sac", "die", "wb", "data", "temp", "flat", "trans", "done", "contract", " destination", "project", "prop", "folder", "destroy", "source", "filename", "txt"], "in": ["r", "image", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "thin", "id", "arin", "din", "sin", "plus", "conn", "lin", "connection", "inner", "resource", "nin", "ini", "con", "rec", "file", "rin", "kin", "inside", "f", "url", "this", "pass", "login", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "like", "re", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "auto", "client", "writer", "sync", "obj", "n", "off", "one", "all", "i", "output", "socket", "s", "app", "user", "copy", "parent", "ex", "server", "cache", "cookie", "outside", "conn", "boot", "ax", "a", "cos", "ext", "io", "at", "file", "f", "o", "null", "this", "exec", "lib", "err", "temp", "b", "norm", "w", "ins", "net", "co", "bin", "In", "OUT", "again", "outs", "outer", "source", "up", "inc"]}}
{"id1": "3801655", "id2": "13063241", "code1": "    @SuppressWarnings(\"unchecked\")\n    public static void main(String[] args) throws Exception {\n        if (args.length != 2) {\n            System.out.println(\"usage: \" + EvaluatorHelper.class.getName() + \" <output> <data set file>\");\n            System.exit(1);\n        }\n        Helper helper = Helper.getHelper(args[1]);\n        Dataset dataset = helper.read(args[1]);\n        ZipFile zip = new ZipFile(new File(args[0]), ZipFile.OPEN_READ);\n        Enumeration entries = zip.entries();\n        Unit<?>[] performance = new Unit<?>[LIMIT];\n        int index = 0;\n        while (entries.hasMoreElements()) {\n            ZipEntry entry = (ZipEntry) entries.nextElement();\n            if (entry.getName().endsWith(\".out\")) {\n                File temp = File.createTempFile(\"PARSER\", \".zip\");\n                temp.deleteOnExit();\n                PrintStream writer = new PrintStream(new FileOutputStream(temp));\n                BufferedInputStream reader = new BufferedInputStream(zip.getInputStream(entry));\n                byte[] buffer = new byte[4096];\n                int read = -1;\n                while ((read = reader.read(buffer)) != -1) {\n                    writer.write(buffer, 0, read);\n                }\n                writer.close();\n                reader.close();\n                BufferedReader outfile = new BufferedReader(new FileReader(temp));\n                String line = null;\n                RuleParser parser = new RuleParser();\n                ProbabilisticRuleList list = new ProbabilisticRuleList();\n                while ((line = outfile.readLine()) != null) {\n                    if (line.startsWith(\"IF\")) {\n                        ProbabilisticRule rule = new ProbabilisticRule(dataset.getMetadata());\n                        list.add(fill(dataset.getMetadata(), rule, parser.parse(line)));\n                    }\n                }\n                outfile.close();\n                PooledPRCurveMeasure measure = new PooledPRCurveMeasure();\n                performance[index] = measure.evaluate(dataset, list);\n                System.out.println(entry.getName() + \": \" + performance[index]);\n                index++;\n                if (index >= LIMIT) {\n                    break;\n                }\n            }\n        }\n        System.out.println(UnitAveragingMode.get(Double.class).average(performance));\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"helper": ["worker", "helpler", "scheHelper", "help", "helpHelper", "helppherd", "Helmer", "helpper", "workmer", "Help", "helpherd", "harler", "workper", "shp", "scheper", "shper", "heller", "scheler", "heler", "helmer", "Helper", "schepherd", "workp", "helHelper", "harper", "sher", "shmer", "harpherd", "harHelper", "Heler"], "dataset": ["datAset", "DatasET", "datapsert", "datASeter", "metaset", "datasets", "datasteter", "Dataseter", " DatASets", "datASheet", " Datasets", "datastET", "datacET", "datasET", "metasET", "datASets", "datapsheet", "DatASeter", "datassheet", "dataseter", "Dataset", "datasheet", " DatASet", " DatasET", "DatASets", "datAsheet", "datassets", " DatASheet", "datapsET", "datAsets", "datacet", "Datasets", "datASET", "datapset", "datacheet", " Dataset", "metassheet", "datastet", "datassert", "datasset", "metassert", " Datasheet", "datacert", "DatASET", "datAsET", "DatASet", "datrasets", "datASet", "metasert", " DatASET", "metasset", "datrasET", "datastets", "metasheet", "datasert", "datassET", "datraseter", "metassET", "datraset"], "zip": ["ip", "pdf", "service", "p", "sl", "git", "tar", "java", "slice", "sea", "bug", "parse", "copy", "pkg", "directory", "archive", "handler", "py", "Zip", "code", "zone", "se", "io", "pack", "ssl", "z", "out", "xml", "file", "secure", "bag", "dir", "f", "binary", "data", "flat", "system", "split", "wrap", "plugin", "folder", "loop", "gz", "lock", "jar", "window", "source", "pipe"], "entries": ["entrys", "contries", "contents", "entlines", "entrants", "entities", "intries", "infrees", "entsrants", " entlements", "infrants", "entlements", "intlements", "ENTrees", "ntents", "entryents", "iterries", "contrys", "entrees", " entities", "entryries", "entrylements", "contry", "infries", "ENTrants", "delements", "ntry", "intities", "ENTries", "ntries", " entlines", "intlines", "iterlements", "entsries", "entsrees", "itrys", "inflements", "itries", "deents", "entlections", "iterents", "itents", "deries", "ENTlections", "entslections", "itry", "infities", "entents", "ntrys", "inflines", "inflections"], "performance": ["stats", "union", " units", "ul", " u", "Unit", "units", "its", " Unit", "rank", "slave", " split", "U", "ui", " result", " writers", " suite", "work", "book", " output", "util", " group", "unit", "exec", " unit", " ratio", "runner", "each", "it", " Units"], "index": ["position", "level", "pos", "i", "key", "order", "write", "id", "page", "limit", "num", "path", "value", "count", "iter", "x", "depth", "unit", "type", "offset", "number", "Index", "name", "head", "length"], "entry": ["r", "in", "service", "obj", "element", "ie", "stream", "cel", "key", "cell", "pattern", "feed", "input", "install", "write", "e", "parse", "section", "ry", "nt", "archive", "office", "server", "lc", "route", "child", "info", "or", "result", "connection", "inner", "se", "xml", "row", "file", "part", "post", "data", "pe", "her", "it", "record", "export", "Entry", "style", "si", "folder", "uri", "add"], "temp": ["fake", "clean", "template", "p", "original", "ctx", "cel", " temporary", "full", "output", "layout", "tmp", "context", "input", "copy", "parent", "office", "Temp", "archive", "directory", "cache", "valid", "http", "path", "io", "single", "out", "thread", "dest", "file", "part", "tc", "storage", "store", "iter", "tem", "f", "binary", "stable", "base", "porary", "data", "emp", "flat", "session", "local", "partial", "test", "w", "table", "wrap", "folder", "lock", "empty", "config", "pipe", "txt"], "writer": ["r", "wire", "sw", "worker", "element", "stream", "author", "key", "output", "feed", "write", "handler", "server", "Writer", "written", "per", "ler", "or", "writers", "inner", "war", "editor", "io", "out", "manager", "wr", "file", "riter", "rw", "iter", "engine", "wrapper", "builder", "wer", "player", "log", "loader", "er", "w", "wave", "driver", "outer", "ws", "writing", "holder", "layer"], "reader": ["r", "iterator", "ner", "worker", "Reader", "element", "stream", "rer", "i", "feed", "input", "write", "ry", "handler", "server", "per", "ler", "or", "http", "inner", "editor", "io", "rr", "reading", "file", "rar", "iter", "f", "wrapper", "ri", "builder", "loader", "oder", "er", "driver", "ter", "upper", "ser"], "buffer": ["position", "bytes", "size", "batch", "capacity", "queue", "transfer", "feed", "character", "input", "sequence", "slice", "reference", "write", "layer", "limit", "Buffer", "server", "address", "result", "message", "resource", "buff", "row", "uffer", "iter", "buf", "binary", "channel", "device", "null", "data", "offset", "wave", "document", "memory", "table", "header", "seed", "flush", "source", "length", "initial"], "read": ["get", "process", "ind", "next", "connect", "size", "max", "save", "sync", "g", "Read", "current", "old", "view", "use", "print", "load", "feed", "input", "default", "ad", "write", "parse", "copy", "id", "reads", "run", "check", "open", "child", "seek", "eval", "report", "READ", "se", "sleep", "readable", "work", "send", "count", "reading", "build", "book", "find", "fill", "start", "end", "x", "iter", "close", "available", "pass", "exec", "k", "data", "download", "type", "wait", "allow", "text", "ride", "skip", "raw", "play", "add", "create", "config", "length", "select"], "outfile": ["infilename", "logfile", " outfilename", "outdir", "outf", " outstream", "Outfile", "indir", "Outline", "logFile", " outline", "outstream", "inf", "Outdir", "outdata", "indata", "Outf", " outdata", "againstream", "instream", "Outstream", "outfilename", " outFile", "inline", "outline", "logfilename", "logdata", "againdir", "infile", "outFile", "inFile", "againline", " outf", "againfile"], "line": ["job", "error", "ip", "side", "lf", "sync", "block", "cell", "object", "comment", "el", "parse", "on", "section", "page", "cle", "lines", "val", "Line", "lin", "code", "strip", "band", "word", "row", "file", "str", "end", "link", "sel", "url", "letter", "pass", "inline", "data", "type", "log", "range", "ine", "split", "status", "LINE", "text", "name", "l", "frame", "style", "string", "header", "le", "filter", "item", "look", "column"], "parser": ["r", "p", "worker", "cher", "class", "pattern", "par", "parse", "Parser", "handler", "server", "per", "ler", "lp", "params", "pool", "xml", "angler", "manager", "function", "book", "plan", "wrapper", "data", "system", "type", "loader", "builder", "er", "oder", "test", "arser", "driver", "processor", "plugin", "string", "umper"], "list": ["get", "r", "match", "p", "left", "best", "all", "chain", "map", "LIST", "parent", "val", "info", "group", "result", "listed", "array", "li", "lp", "pool", "out", "part", "plan", "base", "set", "data", "type", "can", "er", "lists", "v", "collection", "test", "other", "l", "table", "member", "and", "filter", "join", "right"], "rule": ["lr", "r", "match", "rate", "service", "ul", "tree", "ule", "rl", "class", "dict", "rol", "parse", "ee", "val", "per", "group", "li", "function", "row", "str", "Rule", "base", "model", "data", "pe", "ri", "range", "er", "record", "table", "plugin", "style", "header", "rules", "field", "item", "event", "layer"], "measure": ["measuring", "speasuring", "feasure", "feasuring", "Measures", "speasure", "feasures", "Measuring", "Measure", "measured", "Measured", "measures", "feasured", "speasured", "speasures"]}}
{"id1": "1769771", "id2": "3187685", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "pin", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "f", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "off", "n", "up", "output", "default", "user", "write", "ex", "server", "cache", "conn", "target", "ext", "resource", "io", "file", "x", "dot", "o", "prefix", "base", "exec", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "extra", "external", "OUT", "c"], "inChannel": [" inClient", "inClient", "insClient", "insStream", "outStream", "binClient", " inchannel", "inchannel", "inputChannel", "INStream", "INChan", "outchannel", "outChan", "binChannel", " inChan", "InClient", "InStream", "winchannel", "inputchannel", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", " inStream", "InChannel", "winChannel", "winStream", "Inchannel", "insChan", "INchannel", "winChan", "insChannel", "outClient", "inputStream", "binStream", "inStream"], "outChannel": ["inputController", "outStream", " outchannel", "inputChannel", " outCh", "inchannel", "nChannel", "OutChan", "outchannel", "outChan", "outputController", "outCh", "inCh", "OutChannel", "outController", "outputChan", "outputStream", "OutConnection", "outputchannel", "nChan", "inputchannel", "outputCh", " outChan", "outputChannel", "nStream", " outConnection", " outStream", "inputChan", "inChan", "outConnection", " outManager", "inConnection", "nManager", "outManager", "inManager", "Outchannel", "inController", "inStream"]}}
{"id1": "5744493", "id2": "1180878", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doFileCopy", " doFileWrite", " doFolderWrite", " dofileProxy", "newBlockCopy", " doFolderProxy", "newBlockWrite", " doBlockcopy", "newFileCopy", " doFilecopy", "newFilecopy", "newBlockProxy", "newFileWrite", " doFolderCopy", " doBlockWrite", " doFileProxy", " doBlockCopy", " dofileCopy", " dofileWrite", " doBlockProxy", "newFileProxy", " doFoldercopy", " dofilecopy", "newBlockcopy"], "in": ["image", "m", "buffer", "pin", "query", "inn", "isin", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "file", "part", "min", "url", "base", "login", "data", "err", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "buffer", "off", "output", "socket", "pre", "default", "user", "write", "copy", "ex", "page", "server", "cache", "conn", "source", "target", "connection", "ext", "resource", "io", "file", "part", "dot", "o", "prefix", "base", "exec", "temp", "b", "v", "name", "again", "string", "point", "outs", "external", "OUT"], "inChannel": [" inClient", "outStream", "inClient", "inputChannel", " inchannel", "inchannel", "INStream", "INChan", "outchannel", "outChan", "binSocket", "binChannel", " inChan", "InStream", "INSocket", "INChannel", "InChan", "outSocket", "inChan", "inputChan", "binChan", "binStream", "INClient", " inStream", "InChannel", "inSocket", " inSocket", "InSocket", "Inchannel", "INchannel", "outClient", "inputStream", "inputSocket", "inStream"], "outChannel": [" outBuffer", "outStream", " outchannel", "intChan", "inchannel", "OutChan", "outchannel", "outChan", "OutChannel", "outButton", "intChannel", "againSocket", " outButton", "againStream", " outChan", " outStream", "againChannel", "outSocket", "inChan", " outSocket", "intchannel", "inContainer", "inSocket", "outContainer", "OutBuffer", "inButton", "outBuffer", "intButton", "inBuffer", "OutStream", "OutContainer", " outContainer", "againChan", "inStream"], "maxCount": [" maxSize", " maxLength", "MaxSize", "MaxSum", "Maxcount", "maxSize", "blockcount", "maxLength", "MaxCount", "axcount", "maxSum", " maxcount", "axLength", "maxcount", "MaxLength", "axSize", "blockSum", "blockCount", "axCount", " maxSum", "blockSize"], "size": ["position", "bytes", "shape", "max", "ize", "p", "n", "capacity", "fee", "transfer", "sized", "limit", "address", "loc", "seek", "sum", "time", "send", "count", "available", "len", "start", "en", "min", "end", "unit", "mode", "scale", "data", "Size", "type", "range", "cap", "offset", "width", "volume", "name", "small", "speed", "empty", "shift", "flush", "SIZE", "length"], "pos": ["position", "os", "p", "obj", "off", "block", "i", "slice", "po", "id", "limit", "port", "address", "val", "open", "loc", "diff", "pointer", "cos", "index", "ref", "pose", "count", "POS", "part", "len", "start", "iter", "min", "o", "unit", "base", "pass", "no", "data", "rel", " position", "offset", "spec", "Pos", "point", "push", "slot", "pid", "neg", "pt", "length"]}}
{"id1": "22977189", "id2": "20100809", "code1": "    public static void main(String args[]) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(args[0]));\n        Writer out = new FileWriter(args[1]);\n        out = new WrapFilter(new BufferedWriter(out), 40);\n        out = new TitleCaseFilter(out);\n        String line;\n        while ((line = in.readLine()) != null) out.write(line + \"\\n\");\n        out.close();\n        in.close();\n    }\n", "code2": "    public static void copy(File srcPath, File dstPath) throws IOException {\n        if (srcPath.isDirectory()) {\n            if (!dstPath.exists()) {\n                boolean result = dstPath.mkdir();\n                if (!result) throw new IOException(\"Unable to create directoy: \" + dstPath);\n            }\n            String[] files = srcPath.list();\n            for (String file : files) {\n                copy(new File(srcPath, file), new File(dstPath, file));\n            }\n        } else {\n            if (srcPath.exists()) {\n                FileChannel in = null;\n                FileChannel out = null;\n                try {\n                    in = new FileInputStream(srcPath).getChannel();\n                    out = new FileOutputStream(dstPath).getChannel();\n                    long size = in.size();\n                    MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n                    out.write(buf);\n                } finally {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"in": ["r", "image", "n", "g", "inn", "gin", "isin", "read", "i", "is", "socket", "init", "cin", "input", "ln", "id", "din", "plus", "lin", "inner", "nin", "con", "ini", "inside", "min", "f", "url", "this", "pass", "login", "data", "err", "b", "er", "ins", "bin", "In", "reader", "IN", "again", "as", "re", "win", "source", "up", "c", "inc"], "out": ["Out", "plain", "error", "query", "sync", "key", "flow", "s", "comment", "parent", "ex", "conn", "a", "editor", "word", "raw", "at", "prefix", "this", "w", "name", "outs", "window", "flush", "OUT", "r", "client", "off", "user", "page", "cache", "strip", "inner", "io", "pool", "file", "part", "err", "b", "again", "as", "inc", "writer", "output", "object", "init", "app", "copy", "ext", "o", "log", "password", "point", "outer", "up", "obj", "n", "block", "default", "write", "server", "connection", "f", "exec", "data", "temp", "call", "bin", "list", "self"], "line": ["next", "lf", "sl", "block", "entry", "i", "key", "cell", "comment", "feed", "character", "write", "id", "page", "lc", "rule", "lines", "Line", "lin", "code", "content", "message", "word", "value", "row", "file", "str", "end", "link", "f", "url", "letter", "unit", "pass", "inline", "data", "pe", "log", "char", "cl", "LINE", "text", "name", "l", "style", "string", "header", "lock", "source", "column", "c"]}}
{"id1": "9319440", "id2": "4830847", "code1": "    public static String load(String id) {\n        String xml = \"\";\n        if (id.length() < 5) return \"\";\n        try {\n            working = true;\n            URL url = new URL(\"http://pastebin.com/download.php?i=\" + id);\n            URLConnection conn = url.openConnection();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            xml = \"\";\n            String str;\n            while ((str = reader.readLine()) != null) {\n                xml += str;\n            }\n            reader.close();\n            working = false;\n            return xml.toString();\n        } catch (IOException ex) {\n            JOptionPane.showMessageDialog(null, \" Load error\");\n        }\n        working = false;\n        return xml;\n    }\n", "code2": "    @Override\n    public synchronized void deleteJvmStatistics(String contextName, Date dateFrom, Date dateTo) throws DatabaseException {\n        final Connection connection = this.getConnection();\n        try {\n            connection.setAutoCommit(false);\n            String queryString = \"DELETE \" + this.getJvmInvocationsSchemaAndTableName() + \" FROM \" + this.getJvmInvocationsSchemaAndTableName() + \" INNER JOIN \" + this.getJvmElementsSchemaAndTableName() + \" ON \" + this.getJvmElementsSchemaAndTableName() + \".element_id =  \" + this.getJvmInvocationsSchemaAndTableName() + \".element_id WHERE \";\n            if (contextName != null) {\n                queryString = queryString + \" context_name LIKE ? AND \";\n            }\n            if (dateFrom != null) {\n                queryString = queryString + \" start_timestamp >= ? AND \";\n            }\n            if (dateTo != null) {\n                queryString = queryString + \" start_timestamp <= ? AND \";\n            }\n            queryString = DefaultDatabaseHandler.removeOrphanWhereAndAndFromSelect(queryString);\n            final PreparedStatement preparedStatement = DebugPreparedStatement.prepareStatement(connection, queryString);\n            int indexCounter = 1;\n            if (contextName != null) {\n                preparedStatement.setString(indexCounter, contextName);\n                indexCounter = indexCounter + 1;\n            }\n            if (dateFrom != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateFrom.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            if (dateTo != null) {\n                preparedStatement.setTimestamp(indexCounter, new Timestamp(dateTo.getTime()));\n                indexCounter = indexCounter + 1;\n            }\n            preparedStatement.executeUpdate();\n            preparedStatement.close();\n            connection.commit();\n        } catch (final SQLException e) {\n            try {\n                connection.rollback();\n            } catch (final SQLException ex) {\n                JeeObserverServerContext.logger.log(Level.SEVERE, \"Transaction rollback error.\", ex);\n            }\n            JeeObserverServerContext.logger.log(Level.SEVERE, e.getMessage());\n            throw new DatabaseException(\"Error deleting JVM statistics.\", e);\n        } finally {\n            this.releaseConnection(connection);\n        }\n    }\n", "label": 0, "substitutes": {"load": ["get", "loading", "loaded", "upload", "loads", "transfer", "init", "install", "check", "open", "LOAD", "resource", "show", "library", "work", "file", "find", "start", "link", "update", "download", "Load", "loader", "read", "dump", "create"], "id": ["request", "image", "ip", "i", "key", "is", "Id", "json", "bid", "ID", "info", "did", "code", "path", "resource", "file", "root", "start", "link", "uid", "f", "sid", "base", "data", "type", "create", "token", "text", "ids", "name", "plugin", "string", "aid", "uri", "pid", "kid", "source", "filename"], "xml": ["request", "plain", "image", "job", "writer", "email", "ul", "element", "html", "entry", "stream", "full", "form", "layout", "el", "feed", "java", "impl", "input", "sheet", "expl", "write", "bug", "enter", "page", "json", "server", "address", "dr", "content", "php", "http", "path", "response", "audio", "ssl", "line", "work", "raw", "file", "x", "doc", "model", "zip", "data", "wl", "xxx", "log", "spec", "text", "document", "name", "ml", "string", "parser", "web", "event", "ws", "layer", "www", "txt"], "url": ["image", "blog", "db", "client", "connect", "service", "sl", "tool", "stream", "socket", "feed", "user", "layer", "bb", "page", "server", "address", "open", "connection", "http", "URL", "resource", "ob", "ssl", "file", "build", "f", "Url", "channel", "base", "api", "zip", "download", "gl", "loader", "log", "b", "org", "ll", "l", "browser", "string", "web", "uri", "source", "config", "www"], "conn": ["r", "client", "Conn", " db", " mc", " connection", " pool", "ci", " manager", " factory", "connection", "nc", "http", " con", " auth", "io", "ssl", "con", " net", "Url", "ch", "loader", "er", " conf", "l", " internet", "Connection", "c"], "reader": ["lr", "r", "iterator", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "rc", "feed", "input", "rx", "handler", "server", "ler", "dr", "connection", "http", "inner", "editor", "io", "rr", "row", "reading", "rar", "hr", "iter", "f", "ri", "err", "builder", "loader", "rt", "er", "oder", "driver", "l", "finder", "parser", "ser", "uri", "read", "bird"], "str": ["STR", "r", "in", "fr", "p", "sl", "obj", "br", "entry", "i", "s", "input", "dict", "e", "cr", "lc", "Str", "stri", "t", "coll", "val", "dr", "code", "strip", "inst", "line", "wr", "iter", "x", "f", "sr", "st", "enc", "doc", "data", "err", "er", "char", "kr", "cl", "text", "arr", "l", "string", "tr", "read", "pr", "txt"]}}
{"id1": "19934218", "id2": "10214218", "code1": "    public static String doCrypt(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"UTF-8\"), 0, text.length());\n        sha1hash = md.digest();\n        return convertToHex(sha1hash);\n    }\n", "code2": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 1, "substitutes": {"doCrypt": [" doMac", " runExt", "murDec", "murCrypt", " doDec", " runCrypt", "murExt", "DoCrypt", "DoMac", "DoDec", " doExt", "DoExt", "murMac", " runMac", " runDec"], "text": ["font", "image", "in", "buffer", "obj", " Text", "crypt", "key", "class", "pattern", "object", "context", "input", "Text", "code", "connection", "content", "format", "path", "message", "TEXT", "ext", "editor", "word", "value", "EXT", "str", "url", "binary", "this", "letter", "data", " TEXT", "struct", "secret", "token", "contract", "name", "password", "string", "seed", "source", "config", "length", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncodedError", "UnsupportedEncodingEx", "UnsupportedEncodedException", "UnsupportedEncasingEx", "UnsupportedEncasingException", "UnsupportedEncodingError", "UnsupportedEncodedEx", "UnsupportedEncoderError", "UnsupportedEncoderException", "UnsupportedEncoderEx", "UnsupportedEncasingError"], "md": ["mac", "mm", "mo", "sd", "m", "Cmd", "dig", "bf", "def", "mad", "map", "ad", "mn", "pd", "ud", "valid", "metadata", "ma", "dr", "code", "od", "bm", "rm", "message", "mb", "amd", "nm", "df", "wd", "gd", "mand", "bd", "mg", "mode", "dm", "data", "pm", "sha", "mt", "MD", "method", "mp", "me", "mc", "mod", "mag", "vd", "d", "body", "hd", "ld", "ms", "meta", "hash", " Md", "am", "cmd", "dd", " MD", "hm"], "sha1hash": ["sha256sha", "md6h", "sha5sha", "sha0hash", "md1hex", "SHA2sha", "sha5Hash", "SHA1hex", "sha1h", "sha2hash", "SHA2hash", "sha5hex", "sha1Hash", "SHA2h", "sha6h", "sha0hex", "SHA1hash", "shaonehex", "sha256Hash", "md1hash", "md6hex", "SHA2Hash", "SHA1sha", "SHA2hex", "sha2h", "sha6hash", "SHA1sum", "shaonesha", "sha2sha", "sha2hex", "md6hash", "md1sha", "sha256hex", "sha6sha", "SHA1Hash", "sha256hash", "sha6hex", "sha2sum", "sha256sum", "sha2Hash", "SHA1h", "shaonehash", "sha256h", "SHA2sum", "md6sha", "sha1sum", "sha1hex", "md1h", "sha1sha", "sha5h", "sha0sha", "shaoneh", "sha0sum", "sha5hash"]}}
{"id1": "1362", "id2": "1180878", "code1": "    public static int[] bubbleSort(int... a) {\n        boolean swapped;\n        do {\n            swapped = false;\n            for (int i = 0; i < a.length - 1; i++) {\n                if (a[i] > a[i + 1]) {\n                    int tmp = a[i];\n                    a[i] = a[i + 1];\n                    a[i + 1] = tmp;\n                    swapped = true;\n                }\n            }\n        } while (swapped);\n        return a;\n    }\n", "code2": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"bubbleSort": ["ubblingCompare", "bubblingsort", "ubblesort", "ubbleCompare", "bubblesort", "ubblingOrder", "ubbleSort", "bubblessort", "bubblingSort", "bubblesCompare", "bubblersort", "bubbleCompare", "ubblingSort", "ubbleOrder", "bubblingOrder", "bubbleOrder", "bubblerCompare", "bubblesSort", "bubblerSort", "bubblingCompare", "ubblingsort", "bubblesOrder", "bubblerOrder"], "a": ["auto", "an", "la", "m", "p", "access", "alpha", "all", "ab", "ga", "s", "na", "ad", "sa", "e", "address", "aaa", "aj", "A", "ma", "aux", "tta", "result", "va", "array", "index", "something", "img", "apps", "work", "aw", "at", "sup", "oa", "abs", "another", "f", "area", "active", "o", "data", "ac", "ans", "u", "ama", "b", "ack", "ba", "any", "aa", "l", "d", "as", "ae", "ata", "am", "list", "empty", "au", "c"], "swapped": ["swaps", "swoped", "flapped", "waps", "rewoped", "rewapping", "rewaped", "flapping", " swaped", " swap", "Swapped", "flap", "swap", "Swap", "floped", " swaps", "swapping", " swapping", "Swoped", "wap", "Swapping", "wapped", "swaped", "rewaps", "wapping", "waped", "rewap", "Swaped", "rewapped"], "i": ["next", "ind", "ai", "ip", "in", "m", "ki", "h", "p", "j", "ie", "eni", "key", "init", "multi", "fi", "ix", "e", "id", "ci", "gi", "ui", "info", "module", "mini", "adi", "index", "li", "ii", "ori", "io", "iu", "ini", "anti", "sup", "bi", "uni", "start", "x", "pi", "f", "xi", "api", "ami", "ti", "k", "ri", "u", "ni", "b", "y", "v", "mi", "oi", "it", "di", "hi", "l", "d", "si", "qi", "uri", "iv", "I"], "tmp": ["pad", "amp", "m", "j", "p", "opp", "obj", "alpha", "pp", "ie", " ff", "vt", "pre", "qq", "bb", "t", "stuff", "tt", "foo", "tv", "dest", "sup", "angle", "part", "tc", "x", "f", "area", "st", "xxx", "yy", "temp", "emp", "append", "b", "v", "test", "mp", "kk", "front", "mmm", "nb", "prev", "addr", "cmp", "txt"]}}
{"id1": "7143591", "id2": "11005804", "code1": "    public void getWebByUrl(String strUrl, String charset, String fileIndex) {\n        try {\n            System.out.println(\"Getting web by url: \" + strUrl);\n            addReport(\"Getting web by url: \" + strUrl + \"\\n\");\n            URL url = new URL(strUrl);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            InputStream is = null;\n            is = url.openStream();\n            String filePath = fPath + \"/web\" + fileIndex + \".htm\";\n            PrintWriter pw = null;\n            FileOutputStream fos = new FileOutputStream(filePath);\n            OutputStreamWriter writer = new OutputStreamWriter(fos);\n            pw = new PrintWriter(writer);\n            BufferedReader bReader = new BufferedReader(new InputStreamReader(is));\n            StringBuffer sb = new StringBuffer();\n            String rLine = null;\n            String tmp_rLine = null;\n            while ((rLine = bReader.readLine()) != null) {\n                tmp_rLine = rLine;\n                int str_len = tmp_rLine.length();\n                if (str_len > 0) {\n                    sb.append(\"\\n\" + tmp_rLine);\n                    pw.println(tmp_rLine);\n                    pw.flush();\n                    if (deepUrls.get(strUrl) < webDepth) getUrlByString(tmp_rLine, strUrl);\n                }\n                tmp_rLine = null;\n            }\n            is.close();\n            pw.close();\n            System.out.println(\"Get web successfully! \" + strUrl);\n            addReport(\"Get web successfully! \" + strUrl + \"\\n\");\n            addWebSuccessed();\n        } catch (Exception e) {\n            System.out.println(\"Get web failed!       \" + strUrl);\n            addReport(\"Get web failed!       \" + strUrl + \"\\n\");\n            addWebFailed();\n        }\n    }\n", "code2": "    public String kodetu(String testusoila) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            new MezuLeiho(\"Ez da zifraketa algoritmoa aurkitu\", \"Ados\", \"Zifraketa Arazoa\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        try {\n            md.update(testusoila.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            new MezuLeiho(\"Errorea kodetzerakoan\", \"Ados\", \"Kodeketa Errorea\", JOptionPane.ERROR_MESSAGE);\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "label": 0, "substitutes": {"getWebByUrl": ["getWebbyurl", "getwebByurl", "getWebByIdurl", "getWebFromurl", "getWebbyLocation", "getWebByURL", "getWebbyURL", "getWebByIdLocation", "getWebFromURL", "getWebFromLocation", "getwebByURL", "getwebbyUrl", "getwebbyURL", "getWebByLocation", "getWebFromUrl", "getWebByurl", "getWebByIdURL", "getwebbyurl", "getWebbyUrl", "getwebByLocation", "getWebByIdUrl", "getwebByUrl", "getwebbyLocation"], "strUrl": ["strLink", " strFile", "arrURL", "stUr", "stEmail", "Strurl", "slURL", "arrurl", " strURL", "srLink", "STRUr", "StrEmail", "strURL", "strFile", " strLink", "slUrl", "strUr", "wrURL", "objUr", "StrUrl", " strBase", "objURL", "strEmail", "arrUrl", "slUr", "StrLink", " strurl", "StrUr", "srURL", "arrRoute", "wrUr", "strPath", "strRoute", "slBase", " strRoute", "StrPath", "STRFile", "wrEmail", "strBase", "arrPath", "srurl", "StrURL", "STRUrl", "sturl", "StrBase", "StrFile", "objUrl", "wrUrl", " strUr", "arrUr", "STRURL", "stUrl", "strurl", "srUrl", "objFile", "stFile", " strPath", "stURL", "StrRoute"], "charset": ["chactersetting", "charsetting", "chasec", "chactersET", "chactersec", " ChARSec", "chaset", " Charsec", "chasetting", "chARSetting", " ChARSet", "chARSET", "chARSet", " CharsET", "chacterset", " Charsetting", "charsec", " Charset", " ChARSetting", "charsET", "chARSec", "chasET", " ChARSET"], "fileIndex": ["Fileindex", "fullindex", "webVersion", " fileindex", "fileNumber", " fileVersion", "FileName", "fullIndex", "FileNumber", "fullPath", "fullNumber", " fileNumber", "FilePath", "fileindex", " fileName", "webindex", "fileName", "fileVersion", "FileVersion", "FileIndex", "webName", "webIndex"], "url": ["blog", "image", "r", "client", "service", "sl", "host", "proxy", "fl", "ib", "ls", "bb", "id", "page", "server", "address", "bel", "open", "connection", "http", "URL", "path", "resource", "ssl", "file", "str", "link", "f", "Url", "api", "base", "serv", "zip", "download", "loader", "b", "org", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "conn": ["r", "client", "connect", "ca", "Conn", "sync", "ctx", "n", "cp", "cn", "cli", "sn", "ci", "nt", "server", "loc", "open", "ann", "connection", "nc", "http", "ssl", "con", "conf", "config", "f", "ch", "Url", "api", "serv", "enc", "conv", "exec", "ac", "b", "w", "l", "Connection", "cb", "c"], "is": ["lis", "os", "in", "ai", "ip", "Is", "mis", "h", "us", "bis", "ie", "iso", "oss", "isa", "src", "i", "ab", "s", "init", "was", "its", "ib", "ls", "il", "isi", "es", "ris", "IS", "info", "ui", "iss", "http", "ios", "isc", "li", "ii", "io", "ob", "ir", "ssl", "out", "iris", "ais", "iter", "x", "fs", "serv", "ri", "err", "are", "b", "im", "it", "ins", "browser", "ar", "internet", "as", "si", "ps", "jar"], "filePath": ["pagePath", "cachepath", "cacheLocation", "outputPath", "basePath", "filepath", "outputBase", " fileBase", "cacheIndex", "basepath", "fileLocation", "FileHome", "FileBase", "cachePath", "fileHome", "baseLocation", "fileUrl", "FilePath", "pageIndex", "fileBase", "baseIndex", "outputUrl", " fileHome", " fileUrl", "outputHome", "pagepath", "pageLocation", "FileUrl"], "pw": [" pws", "PW", "cpW", " pwa", " pb", "psw", "spv", "ppb", "pwb", "cpw", "Pow", "cpwr", "Pwb", "Pwa", "spwb", "ppow", "Pv", "pws", "pv", " pwr", "ppws", "spw", "ppw", "Pws", "Psw", " pow", "pb", "pwa", "cpwa", "pow", " pwb", "Pwr", "Pb", "spW", " pv", "pW", " pW", "Pw", "spow", "spws", "pwr", "ppsw", " psw", "ppwa", "ppW"], "fos": ["Faos", "fsaos", "pos", "fOS", "faos", "Fos", "fsis", "fsops", "fsos", " fops", "Fops", " faos", " fis", "fops", "pOS", "FOS", " fOS", "pops", "Fis", "fis"], "writer": ["r", "wire", "buffer", "worker", "output", "fd", "write", "ee", "handler", "Writer", "format", "writers", "war", "editor", "io", "xml", "angler", "out", "wr", "file", "director", "riter", "rw", "store", "wb", "null", "wer", "builder", "wa", "er", "w", "wave", "driver", "wrap", "writ", "reader", "wt", "ws", "writing", "walker"], "bReader": ["rWriter", "rbWriter", "BWriter", " bResource", "rReader", " bCh", "bbWriter", "rRead", " bWriter", "rbReader", "rbRead", "bbRead", "bbReader", "rCh", "bRead", " bRead", "bCh", "BReader", "bbResource", "BResource", "rbCh", "bWriter", "BRead", "bResource"], "sb": ["db", "abb", "bp", "bf", "src", "ab", "lb", "zb", "tmp", "SB", "ib", "bb", "sa", "usb", "sf", "sg", "rb", "fb", "bm", "kb", "bg", "lp", "mb", "bps", "stab", "gb", "ssl", "pb", "wb", "sm", "sq", "b", "wp", "bsp", "xb", "obb", "si", "nb", "lab", "sth", "cb", "rob", "erb"], "rLine": [" rUrl", "rtLo", "prLine", " rRange", "rrUrl", "prRange", " rLo", "lrRange", " rLin", "arLine", "arLo", "lrLin", "rtWr", "rline", "prLin", "srLine", "rrBlock", "rRange", "rrLine", " rBlock", "rrLin", "rtline", "rtLine", "rLin", "rLo", "lrBlock", "srLin", "rUrl", " rWr", "lrLine", "srBlock", "arline", "arWr", "rBlock", "prBlock", "rWr", "srUrl", " rline"], "tmp_rLine": ["tmp_nrFile", "tmp_vrCopy", "tmp_RLine", "tmp_lBlock", "tmp_roLine", "tmp_vrline", "tmp_Rline", "tmp_roFile", "tmp_rCopy", "tmp_lLine", "tmp_RValue", "tmp_rtLine", "tmp_rbLine", "tmp_rnCopy", "tmp_RBlock", "tmp_errLine", "tmp_RItem", "tmp_errCopy", "tmp_nrBlock", "tmp_RPage", "tmp_roSe", "tmp_rPage", "tmp_errLink", "tmp_rLetter", "tmp_brFile", "tmp_roPage", "tmp_rbBlock", "tmp_RLetter", "tmp_rRecord", "tmp_prLine", "tmp_rBlock", "tmp_rValue", "tmp_rFile", "tmp_lRecord", "tmp_rnline", "tmp_RRecord", "tmp_vrLink", "tmp_errline", "tmp_rtline", "tmp_RFile", "tmp_rSe", "tmp_rbItem", "tmp_prFile", "tmp_lPage", "tmp_rnLink", "tmp_roValue", "tmp_rbline", "tmp_rtBlock", "tmp_rLink", "tmp_prSe", "tmp_rline", "tmp_lFile", "tmp_RSe", "tmp_lLetter", "tmp_vrLine", "tmp_roRecord", "tmp_rItem", "tmp_rtItem", "tmp_nrLine", "tmp_rnLine", "tmp_roBlock", "tmp_nrline", "tmp_brLetter", "tmp_prValue", "tmp_brLine"], "str_len": ["stri_ler", "str5len", "str2lin", "str_ln", "stri_pos", "stri_len", "str64len", "stri5lin", "str5lin", "str2pos", "dr_ln", "stri_lin", "str_ler", "str64lin", "dr_length", "stri5ler", "stri5len", "str5ler", "str_Len", "dr_Len", "dr_len", "str64ler", "str_pos", "stri5pos", "str_lin", "str5pos", "str64pos", "str2ler", "str2len", "str_length"]}}
{"id1": "1421557", "id2": "6171406", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static void createTar(File directoryToPack, File targetTarFile) throws IOException {\n        if (directoryToPack == null) {\n            throw new NullPointerException(\"The parameter 'directoryToPack' must not be null\");\n        }\n        if (targetTarFile == null) {\n            throw new NullPointerException(\"The parameter 'targetTarFile' must not be null\");\n        }\n        if (!directoryToPack.exists() || !directoryToPack.isDirectory()) {\n            throw new IllegalArgumentException(\"The target file '\" + directoryToPack + \"' does not exist or is not a directory.\");\n        }\n        if (targetTarFile.exists()) {\n            log.warn(\"The target file '\" + targetTarFile + \"' already exists. Will overwrite\");\n        }\n        log.debug(\"Creating tar from all files in directory '\" + directoryToPack + \"'\");\n        byte buffer[] = new byte[BUFFER_SIZE];\n        FileOutputStream targetOutput = new FileOutputStream(targetTarFile);\n        TarOutputStream targetOutputTar = new TarOutputStream(targetOutput);\n        try {\n            List<File> fileList = collectFiles(directoryToPack);\n            for (Iterator<File> iter = fileList.iterator(); iter.hasNext(); ) {\n                File file = iter.next();\n                if (file == null || !file.exists() || file.isDirectory()) {\n                    log.info(\"The file '\" + file + \"' is ignored - is a directory or non-existent\");\n                    continue;\n                }\n                if (file.equals(targetTarFile)) {\n                    log.debug(\"Skipping file: '\" + file + \"' - is the tar file itself\");\n                    continue;\n                }\n                log.debug(\"Adding to archive: file='\" + file + \"', archive='\" + targetTarFile + \"'\");\n                String filePathInTar = getFilePathInTar(file, directoryToPack);\n                log.debug(\"File path in tar: '\" + filePathInTar + \"' (file=\" + file + \")\");\n                TarEntry tarAdd = new TarEntry(file);\n                tarAdd.setModTime(file.lastModified());\n                tarAdd.setName(filePathInTar);\n                targetOutputTar.putNextEntry(tarAdd);\n                if (file.isFile()) {\n                    FileInputStream in = new FileInputStream(file);\n                    try {\n                        while (true) {\n                            int nRead = in.read(buffer, 0, buffer.length);\n                            if (nRead <= 0) break;\n                            targetOutputTar.write(buffer, 0, nRead);\n                        }\n                    } finally {\n                        StreamUtil.tryCloseStream(in);\n                    }\n                }\n                targetOutputTar.closeEntry();\n            }\n        } finally {\n            StreamUtil.tryCloseStream(targetOutputTar);\n            StreamUtil.tryCloseStream(targetOutput);\n        }\n        log.info(\"Tar Archive created successfully '\" + targetTarFile + \"'\");\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "3375722", "id2": "10715601", "code1": "    public void importarSetor(File pArquivoXLS, String pCabecalhoSetor, Andamento pAndamento) throws FileNotFoundException, IOException, SQLException, InvalidFormatException {\n        int iLinha = -1;\n        Statement stmtLimpezaInicialDestino = null;\n        OraclePreparedStatement stmtDestino = null;\n        try {\n            Workbook arquivo = WorkbookFactory.create(new FileInputStream(pArquivoXLS));\n            Sheet plan1 = arquivo.getSheetAt(0);\n            int QUANTIDADE_DE_REGISTROS_DE_CABECALHO = 7;\n            int QUANTIDADE_DE_REGISTROS_DE_RODAPE = 14;\n            int QUANTIDADE_DE_REGISTROS_DE_METADADOS = QUANTIDADE_DE_REGISTROS_DE_CABECALHO + QUANTIDADE_DE_REGISTROS_DE_RODAPE;\n            int quantidadeDeRegistrosEstimada = plan1.getPhysicalNumberOfRows() - QUANTIDADE_DE_REGISTROS_DE_METADADOS;\n            String vSetor = \"\", vSubsetor = \"\", vSegmento = \"\";\n            LinhaDaPlanilhaDosSetores registroAtual;\n            int vPapeisPorSegmento = 0;\n            stmtLimpezaInicialDestino = conDestino.createStatement();\n            String sql = \"TRUNCATE TABLE TMP_TB_SETOR_SUBSETOR_SEGMENTO\";\n            stmtLimpezaInicialDestino.executeUpdate(sql);\n            sql = \"INSERT INTO TMP_TB_SETOR_SUBSETOR_SEGMENTO(SIGLA_EMPRESA, NOME_SETOR, NOME_SUBSETOR, NOME_SEGMENTO) VALUES(:SIGLA_EMPRESA, :NOME_SETOR, :NOME_SUBSETOR, :NOME_SEGMENTO)\";\n            stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosImportados = 0;\n            iLinha = 8;\n            while (true) {\n                registroAtual = new LinhaDaPlanilhaDosSetores(plan1.getRow(iLinha));\n                if (registroAtual.nomeDoSetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    if (registroAtual.nomeDoSubsetor.equalsIgnoreCase(\"\")) {\n                        break;\n                    } else {\n                        vSetor = registroAtual.nomeDoSetor;\n                        vSubsetor = null;\n                        vSegmento = null;\n                    }\n                }\n                if (registroAtual.nomeDoSubsetor.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor)) {\n                    vSubsetor = registroAtual.nomeDoSubsetor;\n                    vSegmento = null;\n                }\n                String nomeDoSegmento = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (nomeDoSegmento.length() > 0 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && registroAtual.siglaDaEmpresa.equals(\"\")) {\n                    if (vSegmento != null && vPapeisPorSegmento == 0) {\n                        vSegmento = vSegmento + \" \" + nomeDoSegmento;\n                    } else {\n                        vSegmento = nomeDoSegmento;\n                    }\n                    vPapeisPorSegmento = 0;\n                }\n                String nomeDaEmpresa = registroAtual.nomeDoSegmentoOuDaEmpresa;\n                if (registroAtual.siglaDaEmpresa.length() == 4 && !registroAtual.nomeDoSetor.equalsIgnoreCase(pCabecalhoSetor) && !nomeDaEmpresa.equals(\"\")) {\n                    String vCodneg = registroAtual.siglaDaEmpresa;\n                    stmtDestino.clearParameters();\n                    stmtDestino.setStringAtName(\"SIGLA_EMPRESA\", vCodneg);\n                    stmtDestino.setStringAtName(\"NOME_SETOR\", vSetor);\n                    stmtDestino.setStringAtName(\"NOME_SUBSETOR\", vSubsetor);\n                    stmtDestino.setStringAtName(\"NOME_SEGMENTO\", vSegmento);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    vPapeisPorSegmento++;\n                }\n                iLinha++;\n                double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosEstimada * 100;\n                pAndamento.setPercentualCompleto((int) percentualCompleto);\n            }\n            conDestino.commit();\n        } catch (Exception ex) {\n            conDestino.rollback();\n            ProblemaNaImportacaoDeArquivo problemaDetalhado = new ProblemaNaImportacaoDeArquivo();\n            problemaDetalhado.nomeDoArquivo = pArquivoXLS.getName();\n            problemaDetalhado.linhaProblematicaDoArquivo = iLinha;\n            problemaDetalhado.detalhesSobreOProblema = ex;\n            throw problemaDetalhado;\n        } finally {\n            pAndamento.setPercentualCompleto(100);\n            if (stmtLimpezaInicialDestino != null && (!stmtLimpezaInicialDestino.isClosed())) {\n                stmtLimpezaInicialDestino.close();\n            }\n            if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                stmtDestino.close();\n            }\n        }\n    }\n", "code2": "    public static synchronized String toSHA1(String str) {\n        Nulls.failIfNull(str, \"Cannot create an SHA1 encryption form a NULL string\");\n        try {\n            MessageDigest md;\n            md = MessageDigest.getInstance(SHA1);\n            byte[] sha1hash = new byte[40];\n            md.update(str.getBytes(ISO_CHARSET), 0, str.length());\n            sha1hash = md.digest();\n            return convertToHex(sha1hash);\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        } catch (UnsupportedEncodingException ex) {\n            ex.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"importarSetor": [" importarProcessorn", " importarsetori", " importarProcessori", " importarProcessor", " importarProcessutor", " importarsetor", " importarsetorn", " importarStructorn", " importTarSetorn", " importarStructutor", " importarStructori", " importarsetutor", " importarSetutor", " importTarSetutor", " importTarsetori", " importarSetorn", " importarStructor", " importTarsetutor", " importarSetori", " importTarSetori", " importTarsetorn", " importTarsetor", " importTarSetor"], "pArquivoXLS": ["pArquivoYls", "pArquivoYCL", "pArquivoEXCL", "pArquivaEXSL", "pArquivoTXls", "pArquivoYML", "pArquivoXCL", "pArquivoXML", "pArquivaEXLS", "pArquivoXls", "pArquivoXSL", "pArquivaXLS", "pArquivoZXLS", "pArquivaXCL", "pArquivaXSL", "pArquivoZXML", "pArquivoEXls", "pArquivaEXCL", "pArquivoZXSL", "pArquivoEXML", "pArquivoTXCL", "pArquivoYLS", "pArquivoTXSL", "pArquivoEXSL", "pArquivaEXls", "pArquivoTXML", "pArquivaEXML", "pArquivoEXLS", "pArquivoTXLS", "pArquivaXML", "pArquivaXls", "pArquivoZXls"], "pCabecalhoSetor": ["pCabecalhoSeteur", "pCabecalhoEdite", "pCabecalhoSetors", "pCabecalhaSetor", "pCabecalhoSelecte", "pCabecalhoEditeur", "pCabecalhaSelecteur", "pCabecalhoEditor", "pCabecalhaSelecte", "pCabecalhoSelectors", "pCabecalhaSetors", "pCabecalhoSete", "pCabecalhoSelector", "pCabecalhaSelector", "pCabecalhoSelecteur", "pCabecalhaSelectors", "pCabecalhaSete", "pCabecalhaSeteur", "pCabecalhoEditors"], "pAndamento": ["pAndietono", "pAndmento", "pOramentono", "pAndmentO", "pOrementono", "pAndementono", "pOramentO", "pAndementO", "pOramentos", "pAndietos", "pAndmentono", "pOremento", "pAndamentO", "pAndmentos", "pAndieto", "pOrementos", "pAndietO", "pAndementos", "pAndemento", "pAndamentono", "pOramento", "pOrementO", "pAndamentos"], "iLinha": ["iPlanya", "iLinya", "NumPlanya", "iFranHa", "iFraneno", "iMaleno", "NumPlanha", "iLineno", "iMalHa", "iLinHa", "NumPlanHa", "iPlanha", "NumPlaneno", "NumLinya", "iMalya", "iPlanHa", "iPlaneno", "NumLinha", "iFranya", "NumLinHa", "NumLineno", "iMalha", "iFranha"], "stmtLimpezaInicialDestino": ["stmtLimpezaInicialdestino", "stmtLimpezaInicialESTination", "stmtLimpezaInicialDestina", "stmtLimpezaInicialCombino", "stmtLimpezaIniciodestino", "stmtLimpezaIniciaDestination", "stmtLimpezaIniciodestination", "stmtLimpezaInicialdestINO", "stmtLimpezaInicialDesino", "stmtLimpezaInicialdestania", "stmtLimpezaIniciodestina", "stmtLimpezaIniciadestin", "stmtLimpezaIniciodestaco", "stmtLimpezaInicioDestania", "stmtLimpezaInicialDesination", "stmtLimpezaInicialDesINO", "stmtLimpezaInicioDestina", "stmtLimpezaInicialDestania", "stmtLimpezaIniciodestania", "stmtLimpezaInicialESTaco", "stmtLimpezaIniciadestaco", "stmtLimpezaInicioDestino", "stmtLimpezaInicialDestin", "stmtLimpezaIniciaDestino", "stmtLimpezaInicialdestination", "stmtLimpezaInicialCombina", "stmtLimpezaInicialdestina", "stmtLimpezaInicioDestaco", "stmtLimpezaInicialCombINO", "stmtLimpezaInicioDestination", "stmtLimpezaInicialDestination", "stmtLimpezaIniciadestination", "stmtLimpezaIniciadestino", "stmtLimpezaInicialDestINO", "stmtLimpezaInicialDestaco", "stmtLimpezaInicialDesania", "stmtLimpezaInicialdestin", "stmtLimpezaIniciaDestaco", "stmtLimpezaInicialdestaco", "stmtLimpezaIniciodestINO", "stmtLimpezaInicialCombaco", "stmtLimpezaInicioDestINO", "stmtLimpezaInicialESTino", "stmtLimpezaInicialESTin", "stmtLimpezaIniciaDestin"], "stmtDestino": ["stmtLocationino", "stmDestin", "stmtDestinos", "stmtDistorno", "stmDestINO", "stmrdestaco", "stmtRestinos", "stmrdestinning", "stmtDestaco", "stmpDestaco", "stmDestinos", "stmpDestINO", "stmpDestorno", "stmtLocationaco", "stmtdestino", "stmtCombinos", "stmtDestorno", "stmtDistino", "stmrDestinning", "stmtdestINO", "stmdestINO", "stmpdestINO", "stmtLocationinning", "stmtdestinos", "stmrDestINO", "stmrdestino", "stmdestin", "stmDestino", "stmpDestino", "stmtRestino", "stmtDistINO", "stmtCombINO", "stmtCombino", "stmtDistaco", "stmtRestaco", "stmrDestino", "stmtDestin", "stmpdestino", "stmtdestaco", "stmpdestorno", "stmrdestINO", "stmtRestin", "stmtLocationINO", "stmtdestin", "stmtRestinning", "stmdestinos", "stmtCombin", "stmtDestINO", "stmrDestaco", "stmdestino", "stmtDestinning", "stmpdestaco", "stmtdestorno", "stmtdestinning", "stmtRestINO"], "arquivo": [" arQuarius", " arqivo", "arQUiva", "arqiva", " ar\u00e7arius", " ar\u00e7ivo", "arqivo", "arQUico", " arquicio", "arquico", "arQUivo", " arqiva", "arquarius", "Arqiva", "arQuico", "arquoso", "arqicio", "Arquiva", "arquicio", " arQuiva", "Arquico", " ar\u00e7iva", " arQuicio", "arQuivo", "arqico", "arqarius", "arQUoso", " arquarius", "arQuoso", " arqicio", " arquiva", "arQuiva", " arqarius", "Arqoso", "arqoso", "Arquivo", "Arqico", " ar\u00e7icio", " arQuivo", "Arquoso", "Arqivo", "arquiva"], "plan1": [" PlanOne", " plan0", "PlanOne", " plan2", "product0", "Plan0", " Plan1", "Plan1", "product1", "product2", "plan2", "planOne", " planOne", "plan0", "PlanName", " Plan2", " planName", "planName", "productName", " Plan0", "Plan2"], "QUANTIDADE_DE_REGISTROS_DE_CABECALHO": ["QUANTIDADE_DE_REGISTRASAD", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRO__", "QUANTIDADE_DE_REGISTRONS__", "QUANTIDADE_DE_REGISTEROS__", "QUANTIDADE_DE_REGISTRATES__", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTROS__", "QUANTIDADE_DE_REGISTEROSAD", "QUANTIDADE_DE_REGISTROAD", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTROSAD", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTRosAD", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTRONS_", "QUANTIDADE_DE_REGISTEROAD", "QUANTIDADE_DE_REGISTERO__", "QUANTIDADE_DE_REGISTROSJ"], "QUANTIDADE_DE_REGISTROS_DE_RODAPE": ["QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTROs_", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRYOSJ", "QUANTIDADE_DE_REGISTROsJ", "QUANTIDADE_DE_REGISTROsEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRYAS_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTRYASJ", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRosJ", "QUANTIDADE_DE_REGISTRAS_", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRosEC", "QUANTIDADE_DE_REGISTRASJ", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRYOS_", "QUANTIDADE_DE_REGISTROSJ"], "QUANTIDADE_DE_REGISTROS_DE_METADADOS": ["QUANTIDADE_DE_REGISTROSID", "QUANTIDADE_DE_REGISTEROS_", "QUANTIDADE_DE_REGISTRONID", "QUANTIDADE_DE_REGISTRATESJ", "QUANTIDADE_DE_REGISTROSEC", "QUANTIDADE_DE_REGISTRO_", "QUANTIDADE_DE_REGISTRos_", "QUANTIDADE_DE_REGISTEROSJ", "QUANTIDADE_DE_REGISTRESJ", "QUANTIDADE_DE_REGISTRATES_", "QUANTIDADE_DE_REGISTERO_", "QUANTIDADE_DE_REGISTRON_", "QUANTIDADE_DE_REGISTEROSID", "QUANTIDADE_DE_REGISTROEC", "QUANTIDADE_DE_REGISTEROID", "QUANTIDADE_DE_REGISTEROSEC", "QUANTIDADE_DE_REGISTRESEC", "QUANTIDADE_DE_REGISTROJ", "QUANTIDADE_DE_REGISTEROJ", "QUANTIDADE_DE_REGISTROS_", "QUANTIDADE_DE_REGISTROID", "QUANTIDADE_DE_REGISTEROEC", "QUANTIDADE_DE_REGISTRES_", "QUANTIDADE_DE_REGISTRATESEC", "QUANTIDADE_DE_REGISTROSJ", "QUANTIDADE_DE_REGISTRosID"], "quantidadeDeRegistrosEstimada": ["quantidadeDeRegistrosEstimmada", "quantidadeDeRegistrosEstivadas", "quantidadeDeRegistrosEstimmator", "quantidadeDeRegistrosEstivada", "quantidadeDeRegistrosEstifado", "quantidadeDeRegistrosEstivado", "quantidadeDeRegistrosEstivator", "quantidadeDeRegistrosEstimadas", "quantidadeDeRegistrosEstimado", "quantidadeDeRegistrosEstifadas", "quantidadeDeRegistrosEstimmado", "quantidadeDeRegistrosEstifator", "quantidadeDeRegistrosEstimmadas", "quantidadeDeRegistrosEstifada", "quantidadeDeRegistrosEstimator"], "vSetor": ["vSelecte", " vSetors", " vSetoring", "vSelector", "vSelectors", "vShipors", "vShiporing", " vSete", "vSetors", "vShipor", "vSelectoring", "vShipe", "vSetoring", "vSete"], "vSubsetor": ["vsubscor", "vSubsetors", "vsubsetors", "vSubjectr", "vsubsetr", "vSubsetr", "vSubsco", "vsubscors", "vSubjectors", "vSubscriptr", "vSubjector", "vsubscr", "vSubscriptors", "vSubscor", "vsubsco", "vsubsetor", "vSubscriptor", "vSubscors", "vSubseto", "vsubseto", "vSubjecto", "vSubscr", "vSubscripto"], "vSegmento": ["vSegMENTa", "vGmentor", "vSegamenta", "vSegmentationo", "vSegmentationor", "vGamentos", "vSegmentationa", "vSegMENTos", "vGmento", "vSegMENTo", "vGamenta", "vSegmentationos", "vSegamentor", "vSegmentos", "vGamento", "vSegamento", "vSegmenta", "vGmentos", "vGamentor", "vSegmentor", "vGmenta", "vSegamentos", "vSegMENTor"], "registroAtual": ["RegistrosAtual", "RegistroExual", "Registroatial", "RegistroExional", "Registrosatial", "Registroational", "RegistroAtial", "RegistrosAtial", "RegistroAtUAL", "RegistroAtional", "RegistroExUAL", "RegistroAtual", "RegistrosAtUAL", "RegistroGenUAL", "RegistroGenional", "RegistrosAtional", "RegistroGenial", "RegistroatUAL", "Registroatual", "RegistroGenual", "RegistrosatUAL", "Registrosational", "Registrosatual", "RegistroExial"], "vPapeisPorSegmento": ["vPapeisPorFragmento", "vPapeisPorSegmentso", "vPapeisPorFragmentso", "vPapeisPorFragmentor", "vPapeisPorSegmentse", "vPapeisPorFragmentsor", "vPapeisPorFragmente", "vPapeisPorSegmente", "vPapeisPorSegamentor", "vPapeisPorSegmentsor", "vPapeisPorSegmentationo", "vPapeisPorSegmentationos", "vPapeisPorFragmentsos", "vPapeisPorSegmentos", "vPapeisPorSegmentor", "vPapeisPorSegmentsos", "vPapeisPorFragmentse", "vPapeisPorSegamente", "vPapeisPorSegmentationor", "vPapeisPorSegamentos", "vPapeisPorSegmentatione", "vPapeisPorFragmentos", "vPapeisPorSegamento"], "sql": ["where", "db", "os", "term", "query", "sl", "script", "msg", "html", "QL", "layout", "s", "comment", "slice", "install", "ln", "ls", "id", "statement", " SQL", "sn", "sol", "SQL", "json", "sb", "section", "sf", "sg", "http", "pr", "params", "acl", "ssl", "csv", "description", "str", "util", "url", "base", "serv", "zip", "data", "sq", "log", "spec", "dl", "eps", "shell", "ql", "body", "string", "nl", "seed", "setup", "sv", "spr", "select"]}}
{"id1": "7872659", "id2": "7006052", "code1": "    private static boolean genCustRatingFileAndMovieIndexFile(String completePath, String masterFile, String CustRatingFileName, String MovieIndexFileName) {\n        try {\n            File inFile = new File(completePath + fSep + \"SmartGRAPE\" + fSep + masterFile);\n            FileChannel inC = new FileInputStream(inFile).getChannel();\n            File outFile1 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + MovieIndexFileName);\n            FileChannel outC1 = new FileOutputStream(outFile1, true).getChannel();\n            File outFile2 = new File(completePath + fSep + \"SmartGRAPE\" + fSep + CustRatingFileName);\n            FileChannel outC2 = new FileOutputStream(outFile2, true).getChannel();\n            int fileSize = (int) inC.size();\n            int totalNoDataRows = fileSize / 7;\n            ByteBuffer mappedBuffer = inC.map(FileChannel.MapMode.READ_ONLY, 0, fileSize);\n            int startIndex = 1, count = 0;\n            short currentMovie = 1;\n            while (mappedBuffer.hasRemaining()) {\n                count++;\n                short movieName = mappedBuffer.getShort();\n                int customer = mappedBuffer.getInt();\n                byte rating = mappedBuffer.get();\n                if (movieName != currentMovie) {\n                    ByteBuffer outBuf1 = ByteBuffer.allocate(10);\n                    outBuf1.putShort(currentMovie);\n                    outBuf1.putInt(startIndex);\n                    outBuf1.putInt(count - 1);\n                    outBuf1.flip();\n                    outC1.write(outBuf1);\n                    currentMovie = movieName;\n                    startIndex = count;\n                }\n                ByteBuffer outBuf2 = ByteBuffer.allocate(5);\n                outBuf2.putInt(customer);\n                outBuf2.put(rating);\n                outBuf2.flip();\n                outC2.write(outBuf2);\n            }\n            ByteBuffer endOfIndexFile = ByteBuffer.allocate(10);\n            endOfIndexFile.putShort(currentMovie);\n            endOfIndexFile.putInt(startIndex);\n            endOfIndexFile.putInt(100480506);\n            endOfIndexFile.flip();\n            outC1.write(endOfIndexFile);\n            outC1.close();\n            outC2.close();\n            return true;\n        } catch (IOException e) {\n            System.err.println(e);\n            return false;\n        }\n    }\n", "code2": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"genCustRatingFileAndMovieIndexFile": ["genCustRatingFileAndmovieindexfile", "genCustRatingFileAndmovieindexPath", "genCustRatingFileAndMovieLinkFiles", "genCustRatingFileAndMovieindexFile", "genCustRatingFileAndmovieindexFile", "genCustRatingFileAndMovieindexPath", "genCustRatingFileAndmovieIndexFile", "genCustRatingFileAndmovieIndexfile", "genCustRatingFileAndMovieindexFiles", "genCustRatingFileAndMovieLinkfile", "genCustRatingFileAndMovieIndexfile", "genCustRatingFileAndMovieLinkFile", "genCustRatingFileAndMovieindexfile", "genCustRatingFileAndmovieIndexFiles", "genCustRatingFileAndMovieLinkPath", "genCustRatingFileAndmovieindexFiles", "genCustRatingFileAndMovieIndexPath", "genCustRatingFileAndmovieIndexPath", "genCustRatingFileAndMovieIndexFiles"], "completePath": ["completeLoader", "successpath", "itePath", "execpath", "correctRoot", "iteMusic", "correctCorp", "CompleteFile", "completepath", "correctPath", " CompleteFile", "progressPath", "completePoint", "execVol", "itepath", "completeVol", "completeRoot", " completePoint", "progressVol", "successMusic", "correctPoint", "flatPath", "successPath", " completeCorp", " CompleteDir", " completeRoot", "doneVol", "successCh", "flatPoint", "completeCorp", "progresspath", "CompletePath", "donePath", "CompleteDir", " CompletePath", " completeHome", "doneLoader", " completeMusic", "flatCorp", " completeCh", "flatRoot", " completeFile", "completeCh", " CompleteHome", " completeDir", "completeDir", "completeHome", "execPath", "execLoader", "CompleteHome", "iteCh", "progressLoader", "completeFile", " completepath", "donepath", "completeMusic"], "masterFile": ["configName", " masterFilename", "MasterFILE", "MasterName", "mastersFile", " masterName", "mastersFiles", "cacheFiles", "masterName", "cachePath", "MasterFilename", "masterFILE", "masterFiles", "configFile", " masterPath", "configFilename", "cacheFile", "configPath", "MasterFiles", "mastersFILE", "mastersPath", "masterPath", "masterFilename", "MasterPath", "MasterFile", "cacheFILE"], "CustRatingFileName": ["CustRatingFilesPath", "CustIndexFilesPath", "CustRatingLinePath", "CustRatingFullName", "CustRatingFileVersion", "CustRateFilenameSize", "CustRateFileDesc", "CustRatingFullSize", "CustRatingFileType", "CustRatingFilenameDesc", "CustRatingFullDesc", "CustRatingClassType", "CustIndexFilesVersion", "CustRateFilePath", "CustRatingFileDesc", "CustRatingFileSize", "CustRatingFilesVersion", "CustRatingClassVersion", "CustIndexFilesName", "CustRateFilenameDesc", "CustRatingFullPath", "CustRateFileName", "CustRatingLineType", "CustRatingFilenameSize", "CustRatingClassName", "CustIndexFilesType", "CustRateFileSize", "CustRatingFilesSize", "CustRatingFilenamePath", "CustIndexFileType", "CustRatingFilePath", "CustRateFilenameName", "CustRatingFilesType", "CustIndexFileName", "CustIndexFilePath", "CustRatingFilesName", "CustIndexFileVersion", "CustRateFilenamePath", "CustRatingLineVersion", "CustRatingFilesDesc", "CustRatingClassPath", "CustRatingLineName", "CustRatingFilenameName"], "MovieIndexFileName": ["MovieIndexFilesName", "MovieIndexFileUrl", "MovieIndexFileFile", "MovieConfigFolderVersion", "MovieIndexFolderFile", "MovieEditFilename", "MovieIndexFolderVersion", "MovieIndexFolderName", "MovieConfigFileName", "MovieIndexFolderHandle", "MovieIndexFilesUrl", "MovieConfigFolderName", "MovieIndexFILEFile", "MovieConfigFolderFile", "MovieIndexFileSize", "MovieIndexClassName", "MovieEditFName", "MovieConfigFileFile", "MovieIndexFileHandle", "MovieConfigFileHandle", "MovieIndexFilesname", "MovieIndexFUrl", "MovieConfigFileVersion", "MovieEditFileSize", "MovieIndexFSize", "MovieIndexFName", "MovieIndexFileVersion", "MovieIndexPlaceName", "MovieIndexFILEHandle", "MovieEditFUrl", "MovieIndexClassSize", "MovieIndexFILEVersion", "MovieIndexClassUrl", "MovieIndexPlaceVersion", "MovieIndexPlaceFile", "MovieIndexFILEName", "MovieIndexClassname", "MovieIndexFilename", "MovieIndexFilesSize", "MovieEditFname", "MovieEditFileUrl", "MovieEditFileName", "MovieEditFSize", "MovieIndexFname", "MovieConfigFolderHandle", "MovieIndexPlaceHandle"], "inFile": ["Infile", "incC", "inSourceFile", "outC", "inputF", "incFile", " inF", "incSourceFile", "inputSourceFile", "outfile", "outSourceFile", "InSourceFile", " infile", "incfile", "inputfile", "InF", "infile", "inputFile", "outFile", "inF", "InFile", " inSourceFile"], "inC": ["outCL", "outCI", "InB", "inCI", "InCC", "outC", "outF", "inputF", "InCL", "inputC", "outCC", " inF", "innerC", "innerCC", "innerFile", " inCL", "inB", "inCC", "InF", "InC", "InCI", "inputCC", "innerCI", " inCC", "inputFile", "outFile", "inCL", "inF", " inB", "InFile", "outB"], "outFile1": ["againC2", "outPath3", "outFName", "outFiles1", "againFile2", "outputFile2", "outFiles3", "againCFirst", "outfileName", "outFiles2", "againC3", "outputFile1", "outCFirst", "outputfileName", "outFilesFirst", "outfile2", "outPlace2", "outPlaceId", "outPath2", "outPathFirst", "outFId", "againFile1", "againFileFirst", "outputFileId", "outputFileName", "outFileName", "outPlaceName", "outF2", "againFile3", "againC1", "outputfile1", "outPath1", "outPlace1", "outFile3", "outfile1", "outF1", "outFileFirst", "outfileId", "outputfileId", "outC3", "outputfile2", "outFileId"], "outC1": ["outcOne", "againC2", "outC8", "againB8", "outc1", "outCOne", "outB8", "newc81", "newCOne", "outF8", "newcFirst", "outD8", "newC1", "newCFirst", "againCOne", "outCF1", "newC81", "outBOne", "againBOne", "outCFirst", "againB1", "outc81", "outB2", "outFOne", "newcOne", "outDFirst", "outB1", "againB2", "outcFirst", "outF2", "newc1", "outD2", "againC1", "outD1", "outD81", "outF1", "outCFFirst", "againC8", "outDOne", "outC81", "outCFOne", "outCF81"], "outFile2": ["outFiles1", "outDirectoryTwo", "againFile2", "outputfile5", "outfile4", "outputFile2", "outChannel2", "againLineTwo", "outFiles2", "outLine1", "outputfile4", "outFiles6", "outFiles5", "againLine2", "outFileTwo", "outputfileTwo", "outfile2", "outfileTwo", "againFile1", "outDirectory4", "outChannel6", "outLine2", "outfile5", "outFiles4", "outFile4", "outDirectory5", "outFile6", "againFileTwo", "outputFileTwo", "outDirectory2", "againLine6", "outChannelTwo", "outFilesTwo", "outFile5", "outLine6", "outputFile5", "outLineTwo", "outChannel1", "outputFile4", "againLine1", "outputfile2", "againFile6"], "outC2": ["outCTwo", "againC2", "outCache2", "OutC1", "outFII", "OutC2", "OutFII", "OutF2", "outFileII", "againBTwo", "againCTwo", "OutF4", "outFileTwo", "againB1", "outB2", "outB4", "outB1", "OutCII", "OutF1", "outCache1", "outFTwo", "againB2", "outF4", "outFile4", "outF2", "outCacheII", "outBTwo", "againC1", "OutC4", "againB4", "outF1", "outC4", "againC4", "outCII", "outCache4"], "fileSize": ["imageSIZE", "FileSIZE", " fileSIZE", "imageLength", " fileLength", "fileLength", "FileLength", "imageSize", "fileAddress", " fileAddress", " fileMode", "bufferLength", "bufferMode", "bufferSize", "FileSize", "FileAddress", "resourceSize", "resourceSIZE", "fileSIZE", "FileMode", "resourceAddress", "fileMode"], "totalNoDataRows": ["totalNoDataCrows", "totalNoPageLows", "totalNoDataLows", "totalNoPageLues", "totalNoDataChows", "totalNoDataLrows", "totalNoDataChOWS", "totalNoDataCOWS", "totalNoDataLues", "totalNoDataLOWS", "totalNoDataROWS", "totalNoDataCues", "totalNoDataChues", "totalNoPageLOWS", "totalNoDataRues", "totalNoDataRrows", "totalNoPageROWS", "totalNoPageRows", "totalNoPageRues", "totalNoDataCows", "totalNoPageRrows", "totalNoDataChrows", "totalNoPageLrows"], "mappedBuffer": ["mippedBuffer", "machedFile", "machedbuffer", "mappingFile", "MappedURL", "mappedbuffer", "mappingBuff", "mppedBuff", "mappedBuff", "mappingChannel", "mppedBuffer", "mashedFile", "mapedBuff", "mactedBuff", "mappedURL", "mactedBuffer", "mapedFile", "MappedChannel", "Mappedbuffer", "machedURL", "MappedBuff", "mappedChannel", "MachedURL", "mapedStream", "MappingChannel", "machedStream", "mactedStream", "MappedBuffer", "MappedFile", "mappingbuffer", "mashedBuff", "mappingBuffer", "mappingStream", "mappedFile", "MappingFile", "mashedChannel", "MachedBuffer", "MachedChannel", "Machedbuffer", "MachedFile", "MappedStream", "machedChannel", "MappingBuffer", "mappedStream", "MachedStream", "mactedbuffer", "mppedChannel", "mippedBuff", "mapedURL", "MappingBuff", "machedBuffer", "MachedBuff", "mppedStream", "machedBuff", "mippedURL", "mapedBuffer", "mashedBuffer", "mippedStream"], "startIndex": ["endInfo", "useIndex", "initOffset", "endindex", "endSection", "startInfo", "initindex", "startCode", "startSection", " startCode", "useInfo", "initIndex", "stopindex", " startSection", "StartPosition", "endPosition", "startingSection", " startInfo", "Startindex", " startPosition", "StartInfo", " startPoint", "stopCode", "StartIndex", "stopRow", "StartOffset", " startOffset", "startOffset", "endRow", "startPosition", "initInfo", "startindex", "stopIndex", "endCode", "startingPoint", "usePosition", " startRow", "endPoint", "startingIndex", " startindex", "useindex", "startRow", "startPoint", "startingPosition", "endIndex"], "count": ["ind", "size", "max", "Count", "i", "key", "order", "all", "old", "id", "limit", "coll", "cache", "child", "more", "group", "code", "sum", "found", "index", "time", "weight", "pool", "thread", "find", "part", "len", "start", "depth", "col", "close", "type", "keep", "test", "number", "force", "allow", "other", "total", "call", "name", "counter", "follow", "list", "loop", "first", "add", "current", "c", "self", "length"], "currentMovie": ["currentMusic", "currentlyMusic", "defaultImage", "parentmovie", "reportedMusic", "thismovie", "thisFilm", "reportedFilm", "validTheme", " currentmovie", "CurrentFilm", "currentFilm", "currentImage", "Currentmovie", "CurrentMovie", " currentPicture", "parentPicture", "defaultMusic", "currentPicture", " currentFilm", "defaultFilm", "reportedTheme", "thisMovie", "reportedPicture", "validmovie", " currentMusic", " currentImage", "currentlyPicture", "reportedMovie", "currentlyMovie", "validFilm", "parentMovie", "currentTheme", "CurrentTheme", "reportedmovie", "thisPicture", "validMovie", "reportedImage", "currentmovie", "defaultMovie", "parentFilm"], "movieName": ["camName", "filmFamily", "filmNumber", "movieId", "camFamily", " movieFamily", "MovieFamily", "voiceName", "filmName", "MovieId", " moviename", "moneyNumber", "Moviename", "voiceId", "MovieNumber", "movieInfo", "filmname", "moneyFamily", "MovieInfo", "MovieName", "voiceInfo", "moneyName", "voicename", " movieId", "movieNumber", "moviename", " movieInfo", "movieFamily", "camname"], "customer": ["mixor", "Customers", "Customor", "ustomeri", "customor", "ustomor", "customers", "customER", "Customeri", " customeri", "CustomER", "mixer", "mixER", " customers", "ustomers", "customeri", "ustomer", "Customer", " customER", "ustomER", "mixers"], "rating": ["r", "rolling", "error", "writer", "rate", "alpha", "rc", "comment", "Rating", "rank", "id", "attribute", "RC", "info", "including", "padding", "rage", "http", "radius", "resource", "rr", "value", "reading", "url", "feature", "data", "type", "missing", "range", "rates", "packing", "number", "rated", "ring", "ranking", "ing", "reader", "string", "score", "rice", "setting", "ruby", "writing"], "outBuf1": ["outBiffOne", "outKuf3", "outBuffn", "outBaf1", "outKbuf1", "outKuf8", "outFuf01", "outKbuf3", "outBum1", "outBbuff8", "outKbuff1", "outBummerOne", "outBuff8", "outFbuf01", "outBum01", "outBbuff1", "outFafCloud", "outBbuf01", "outFbuf1", "outCuf1", "outFbuf91", "outDuff3", "outBummer1", "outDuff11", "outFaf1", "outBuf8", "outKbuff3", "outBbuf91", "outBufn", "outFuf91", "outBufOne", "outBaf8", "outKufOne", "outDufn", "outBafCloud", "outFufOne", "outBuff2", "outBaft11", "outBalth3", "outFafOne", "outBiff1", "outBum91", "outBuf01", "outBuff1", "outBiff91", "outBbuf11", "outBbuf1", "outKuf2", "outCuff0", "outKuf1", "outBaft1", "outBbufOne", "outCufOne", "outFuf1", "outDuff1", "outBaf3", "outBbuffOne", "outBbuf2", "outBuffCloud", "outBuff3", "outFufCloud", "outBalth2", "outKbuff8", "outDuf11", "outBuff0", "outBbuf3", "outBafOne", "outKbuffOne", "outBbufn", "outBbuff0", "outBuff11", "outBbuff3", "outBuf0", "outBaftn", "outBaf0", "outBuf11", "outDuf3", "outDuf1", "outBummerCloud", "outBuf3", "outBaft3", "outBuffOne", "outKbuf2", "outFbufOne", "outCuf0", "outDuffn", "outBiff01", "outBalth1", "outBuf91", "outCuffOne", "outCuff1", "outBufCloud", "outBumOne"], "outBuf2": ["outFuf4", "outBbufTwo", "outBoff8", "outFuf8", "outBoff200", "outBum2", "outBaitTwo", "outWBuff4", "outBait0", "outBbuffer4", "outBbuff8", "outBbufferB", "outWBuff0", "outFuf2", "outBait4", "outBuffTwo", "outBbuff82", "outFbuf12", "outBbuffer12", "outBuf82", "outWBbuff2", "outBuff8", "outBbuff1", "outBbufB", "outFbufB", "outFbuff4", "outBuf12", "outFbuf4", "outBuff4", "outBuber82", "outBuffB", "outBoff2", "outBbuffer2", "outFbuff20", "outBuf200", "outFbuff82", "outWBuf2", "outFuf12", "outWBuff2", "outBuf8", "outFufTwo", "outBbuf4", "outBait8", "outBufB", "outFbuff1", "outWBuf4", "outBuff2", "outBbuff2", "outBoffTwo", "outFufB", "outBuff1", "outBait200", "outWBbuff200", "outWBuf200", "outBbuf1", "outBuff12", "outWBuf0", "outWBuf8", "outBuf4", "outFuf1", "outBbuf2", "outWBuff8", "outBuff0", "outBbuff20", "outBait2", "outBufTwo", "outBbuff0", "outBum8", "outBbuf12", "outWBbuff8", "outBuf0", "outBuber20", "outFbuffTwo", "outBbuff200", "outFbuf2", "outBbuffTwo", "outBum20", "outWBufTwo", "outBuber2", "outFuf20", "outBuber8", "outBum82", "outBbuff4", "outFuf82", "outBuf20", "outWBbuffTwo", "outFbuff8", "outFbuff2"], "endOfIndexFile": ["endOfClientDir", " end\n", "endofLinkTime", "endOfLinkDir", "endofIndexFile", "endOfDataDir", "endedfile", "endfile", "endOfindexTime", "endOfDataTime", "endOfClientFile", "end\n", "ended\n", "endofLinkFile", "endofindexFolder", "endOfindexFolder", "endofindexTime", "endOfDataFile", "endofindexFile", "endofindexFiles", "endOfLinkTime", "endOfLinkFile", "endofIndexDir", "endOfindexfile", " endfile", "endOfClientTime", "endOfClientFiles", "endofIndexTime", "End\n", "endOfImageFolder", "endOfLinkfile", "endOfIndexFiles", "endOfImageTime", "endOfindexFile", "endOfindexDir", "endOfIndexfile", "endOfIndexDir", "endOfLinkFiles", "endofLinkDir", "endofIndexFolder", "endOfImageFile", "Endfile", "endOfDatafile", "endofLinkFiles", "endofIndexFiles", "endOfImageFiles", "endOfIndexTime", "endOfIndexFolder", "endOfindexFiles"]}}
{"id1": "8266672", "id2": "6371580", "code1": "    public static void updatePicInfo(Connection conn, int nr, int lock, DBPicInfo picInfo) throws SQLException {\n        String sql = \"\";\n        PreparedStatement pstmt = null;\n        try {\n            if (!picInfo.getName().equals(\"\")) {\n                sql = \"update DBPic set name=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setString(1, picInfo.getName());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            if (picInfo.getRate() != 0) {\n                sql = \"update DBPic set rate=? where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, picInfo.getRate());\n                pstmt.setInt(2, nr);\n                pstmt.executeUpdate();\n            }\n            sql = \"update DBThumb set thumb_lock=? where bnr=?\";\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setInt(1, lock);\n            pstmt.setInt(2, nr);\n            pstmt.executeUpdate();\n            if (picInfo.getCategories() != null) {\n                sql = \"delete from Zuordnen where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInCategories(conn, nr, picInfo.getCategories());\n            }\n            if (picInfo.getKeywords() != null) {\n                sql = \"delete from Haben where bnr=?\";\n                pstmt = conn.prepareStatement(sql);\n                pstmt.setInt(1, nr);\n                pstmt.executeUpdate();\n                DaoUpdate.insertPicInKeywords(conn, nr, picInfo.getKeywords());\n            }\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            pstmt.close();\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"updatePicInfo": ["updatepicInfo", "updatePicInf", "savePicinfo", "saveImageinfo", "updatepicinfo", "updatePictureInfo", "updatePicinfo", "savePicInfo", "updatePictureinfo", "updateImageInfo", "updateImageInf", "updateImageinfo", "saveImageInf", "updatePictureInf", "savePicInf", "saveImageInfo", "updatepicInf"], "conn": ["orp", "db", "client", "connect", "ca", "Conn", "sync", "ctx", "oss", "stat", "cp", "rc", "cn", "cc", "pg", "cat", "cr", "cli", "nt", "ci", "mn", "core", "server", "coll", "cf", "reg", "loc", "ann", "gn", "dn", "connection", "nc", "dc", "pool", "manager", "con", "conf", "config", "pub", "en", "util", "col", "ch", "enc", "serv", "exec", "conv", "session", "rt", "jc", "ct", "pc", "co", "mc", "sys", "cms", "cmp", "act", "cmd", "cb", "c", "vol"], "nr": ["lr", "r", "gr", "fr", "ner", "nor", "n", "rl", "eni", "ctr", "chain", "nn", "orr", "rx", "mn", "sn", "dr", "ru", "adr", "rb", "radius", "our", "num", "nc", "nis", "rr", "nir", "rin", "wr", "rar", "sr", "NR", "mr", "dir", "rf", "rw", "nil", "major", "err", "ni", "range", "nick", "nw", "number", "nie", "inv", "rn", "yr", "vr", "arr", "counter", "nl", "nb", "random", "nar", "usr", "np", "lvl"], "lock": ["lr", "locks", "gr", "max", "pin", "sync", "sl", "ok", "block", "locking", "rc", "delay", "sol", "lc", "limit", "sn", "locked", "loc", "lin", "bl", "pull", "ssl", "Lock", "row", "len", "dir", "min", "zip", "lang", "rel", "live", "ock", "ll", "cl", "number", "arr", "l", "ml", "list", "pl", "LOCK", "lvl", "length"], "picInfo": ["pinInit", "pixelINFO", "moduleLi", "pinInfo", "collInf", "PicConf", "picINFO", "picSetup", "PicInf", "syncInf", "niceInf", "niceSetup", "pictureInf", "picEx", "collEx", "moduleInf", "pixelArea", "pinArea", " picInf", "pictureINFO", "kinSync", "picObj", "collINFO", "pictureArea", "pictureStyle", "picUpdate", "moduleInfo", "moduleINFO", "PicINFO", "iconInf", "pixelInfo", "studyInfo", "picInf", " picEx", "syncLi", "PicEx", "kinInfo", "iconStyle", "pictureObj", "pictInfo", "pictureInfo", "kinStyle", "iconInfo", "picInit", "styleSetup", " picINFO", "studyObj", "pictureId", "PicSetup", "pictType", "styleInfo", "studyUpdate", " picType", "syncInfo", "pictureUpdate", "pictureLi", "styleInf", "PicType", "picSync", "kinInf", "pinId", "PicInfo", "syncINFO", "pictInf", "picStyle", "niceConf", "pinInf", "pinUpdate", "picType", "pictureSync", "collInfo", "PicObj", "pinObj", "pictureInit", "niceInfo", "pictId", "pictObj", "picConf", "styleConf", " picInit", "picArea", "picLi", "picId", "studyInf", "iconSync", "pixelInf", " picObj", " picArea"], "sql": ["generic", "sync", "s", "comment", "sk", "ln", "serial", "http", "params", "fn", "str", "sq", "lang", "dl", "shell", "string", "tf", "uri", "cmp", "db", "details", "sl", "lambda", "html", "rl", "QL", "summary", "json", "loc", "lv", "pool", "err", "ll", "status", "utils", "sal", "job", "su", "email", "msg", "ls", "pkg", "cli", "lc", "limit", "sf", "result", "reason", "ssl", "function", "util", "url", "serv", "log", "printf", "kl", "auth", "ql", "nl", "seed", "sv", "filename", "tool", "socket", "install", "il", "sn", " SQL", "sol", "SQL", "sg", "rup", "xml", "csv", "zip", "session", "eps", "general", "sys", "select"], "pstmt": ["prestcl", "pstdtp", "pflmt", "pustsp", "pusttool", "ipstnl", "pstert", "psthrm", "pctmb", "Postmt", "ppstsp", "pstrtr", "pestmb", "pconstm", "ipstrnl", "pstatmc", "ppstql", " pftmn", " pftrt", "Pstret", "Pstpt", "pfmb", "lpstmt", "prestmn", "ipstrpm", "pclmn", "prestmd", "prsthmt", "psthtool", " pftmm", "pestsp", "pctpt", "pestau", "prestmb", "ppesttool", "pfmt", "putmt", "pstmc", "psthmc", "ppestql", "pstdemb", "ppstmb", "postmd", "pstatt", " pstemb", "ppmb", "pfrm", "pdm", "ppestmt", " pstert", "pdmn", "preostmn", "pstdm", "ppatt", "perstsmt", "pconstpm", "postret", " postmd", " pstm", "ppstdr", "pprmb", "lpsttr", "pstsmt", "Pctm", "pctcl", "perstmc", "pstdtool", " pstmb", "pctpm", "pctdr", "pstret", "pstau", "pctm", "pfcl", "pstpm", "pctmt", "ppmt", "pestatt", "pctgr", "putdr", "prestnl", "pflert", "pflm", "prstbh", "prestpm", "pfm", " pfmn", "ipstmt", "pstpl", "pstsgr", "ppsthmt", "postm", "presttool", "prsthmb", "Postmon", "pstrm", "pfpt", "postmon", "hstmn", "pctpl", "Pstmt", "lpstrtr", " pstrel", "lpstgr", "ppsthgr", "pconstql", "pftemb", "pctmd", "pustql", "pprmt", "hsttor", "prstmt", "pestmt", "pstsrm", "psthcl", "pstrret", "lpstm", "pconstcl", "ppstmd", "perstsmc", "postmb", "ppstgr", "postmn", "Pctmt", " pfm", "ppbh", "pprrm", "pfttp", "pfbh", "prsthql", "pstdrel", "pftmt", "psthrel", " postrel", "pcttr", "psthm", "pctrel", "pstsp", "pstrpm", "pdmt", "postau", "psthmt", "psthdr", "prstatt", "pdpl", "postmt", "perstsrm", "psthgr", "pclbh", "pconstmb", " pfmt", "lpstrmt", "pconstmn", "pstmb", "pustmt", "pftmn", "Pstmb", "Pctpl", "perstsgr", "Pstmon", " postm", "pconstpt", "ipstpm", "prestql", "pclmt", "pstdmn", "pstatmt", "ppestsp", "postrel", "preostau", "ipstrmt", " pstrm", "Pstm", "psthmn", "pstdr", " pfrel", "lpstrgr", "psctor", "psthrt", "lpstrm", " postert", "ppsthmd", "psttr", "pftmm", "postcl", "pscbh", "pptp", "putmd", "Pstpl", "pstdert", "Postret", "pctmn", "pstrgr", "pstpt", "pfatt", "prpmb", "psthql", "pfret", "perstrm", "pstgr", "pstemb", "pestcl", "pstddr", "Pstmn", "psttool", " pfrm", "pstrrt", "pstnl", " pfttp", "pestql", " pstcl", "perstmt", "ppstmt", "pstmon", "pfrel", "prestrel", "hstbh", "pscmt", " pfmb", " postmb", "pestbh", "pscpm", "pestdr", "postert", " pfcl", "Pctmb", "pstrnl", "pstmm", "prpbh", " psttp", "pstrmon", "pestgr", "prpmt", "pstsmc", " pstrt", "prpatt", "pstmd", "psttor", "pstmn", "prstql", "prestsp", "prstmb", "pprmn", "pstql", "pstatrm", "pstm", "ppsthdr", "preostcl", "ppmn", "Postmn", "perstgr", "pstrmt", "ppsttool", "psthmb", "ipstrtr", "pscnl", "prestau", " pstmn", "psthpm", "psctr", "puttool", "prsthpm", " pftmt", "ipsttr", "ppsthtool", "pstrmn", "prstpm", "pstatgr", "pfmon", "pstrmm", "pesttool", " pftemb", "pstrt", "pftrt", " pstmm", "pctql", "pcltor", "prestmt", "pstrpl", "pctrm", " pstmd", "pflrel", "pconstmt", "ppemb", "pscmn", "psthmm", "pstdmd", "psttp", "psthmd", " postmt", "ppsthmb", "hstmt", "preostmt", "presttr", "pstdmt", "pstrel", "pstcl", "pfmn", "pestmn", "pconstau", "Pctmn", "pstbh", "psthtr", "Pctpt"]}}
{"id1": "12197169", "id2": "324679", "code1": "    public void read() throws IOException {\n        if (log.isInfoEnabled()) {\n            log.info(\"Reading the camera log, \" + url);\n        }\n        final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        String line;\n        int i = 0;\n        try {\n            while ((line = in.readLine()) != null) {\n                i++;\n                try {\n                    final CameraLogRecord logDatum = new CameraLogRecord(line);\n                    records.add(logDatum);\n                } catch (LogParseException e) {\n                    if (log.isInfoEnabled()) {\n                        log.info(\"Bad record in \" + url + \" at line:\" + i);\n                    }\n                }\n            }\n        } finally {\n            in.close();\n        }\n        Collections.sort(records);\n        if (log.isInfoEnabled()) {\n            log.info(\"Finished reading the camera log, \" + url);\n        }\n    }\n", "code2": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "label": 1, "substitutes": {"read": ["request", "get", "process", "Read", "stream", "print", "load", "init", "parse", "write", "println", "check", "run", "open", "replace", "ready", "report", "readable", "work", "reading", "start", "end", "download", "continue", "reader", "loop", "create"], "in": ["r", "error", "image", "fr", "buffer", "n", "inn", "stream", "isin", "is", "s", "input", "e", "on", "id", "ex", "din", "server", "conn", "from", "info", "connection", "a", "inner", "path", "index", "io", "nin", "ssl", "out", "ini", "con", "file", "at", "of", "min", "f", "url", "o", "doc", "login", "data", "err", "b", "log", "er", "token", "it", "ins", "bin", "In", "l", "by", "ing", "reader", "IN", "again", "cms", "scan", "source", "c", "inc"], "line": ["ne", "buffer", "sl", "lf", "block", "entry", "key", "cell", "object", "el", "comment", "parse", "e", "id", "page", "lc", "lines", "val", "Line", "lin", "code", "message", "se", "value", "row", "file", "str", "end", "link", "ge", "f", "url", "col", "unit", "inline", "data", "log", "b", "ine", "LINE", "L", "status", "text", "record", "name", "l", "frame", "reader", "string", "le", "source"], "i": ["ai", "ip", "j", "p", "n", "ie", "eni", "is", "fi", "ix", "slice", "e", "phi", "abi", "ci", "gi", "ui", "info", "zi", "li", "index", "ii", "io", "ori", "ini", "uni", "bi", "x", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "oi", "di", "l", "si", "qi", "ski", "I"], "logDatum": ["exDDam", "exDDatum", "Logdum", "logdum", "logDatata", "logDsatum", "logDatictionary", "LogDict", "logDatam", "Logdata", "LogDatum", "logFictionary", "logDatatum", "logDict", "exDam", "exDData", "logDum", "logDsata", "exDDictionary", "exData", "logDDatum", "exDatum", "logDatict", "logDsum", "logDDam", "LogDum", "logData", "logFatum", "exDictionary", "logDictionary", "logDData", "logdata", "logdict", "Logdict", "logFam", "Logdatum", "logDsict", "logDDictionary", "LogData", "logFata", "logdatum", "logDam"]}}
{"id1": "12766394", "id2": "11562165", "code1": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 1, "substitutes": {"testReadHelloWorldTxt": ["testReadHelloWorldFxt", "testReadHelloWorldMxt", "testReadHelloWorldFext", "testReadHelloWordMext", "testReadHelloWordText", "testReadHelloWorldMtxt", "testReadHelloWorldMext", "testReadHelloWorldFXT", "testReadHelloWordTxt", "testReadHelloWordMXT", "testReadHelloWorldMXT", "testReadHelloWorldFtxt", "testReadHelloWordMxt", "testReadHelloWordMtxt", "testReadHelloWordTtxt", "testReadHelloWordTXT", "testReadHelloWorldTXT", "testReadHelloWorldTtxt", "testReadHelloWorldText"], "helloWorldIS": [" helloCityIR", " helloWorldIDE", "helloCommunityIDE", " helloWorldIR", "helloCityAS", "helloWorldIR", " helloWorldAS", "helloWorldIDE", " helloWorldis", " helloWorldIs", "helloCityIS", "helloCityIR", "helloWestAS", "helloCityIs", "helloWorldIs", "helloCommunityIS", "helloWestIS", "helloWestIs", "helloCommunityIs", "helloWorldAS", "helloWorldis", "helloCityis", " helloCityIS", " helloCityIs", "helloCityIDE", " helloCityAS", "helloWestIR"], "helloWorldPath": [" helloWorldpath", "hiWorldFile", "helloWorldCorp", "helloworldPATH", "helloCommunityPATH", "helloCommunitypath", "helloWorldLocation", "helloWorldFile", "helloWallName", "hiWorldUrl", "helloCommunityLocation", "hiWebpath", "helloCommunityPath", "officeCommunityPath", "officeWorldPath", "helloCommunityDir", "hiWorldPath", "helloWorldPATH", "helloWallpath", "officeCommunityPATH", "helloWallPath", "officeCommunityCorp", "helloworldCorp", "helloCommunityCorp", " helloWorldDir", "hiWebPath", "hiWorldpath", "helloWorldUrl", "helloWebFile", "helloWebUrl", "officeCommunityLocation", "officeWorldCorp", "helloWebpath", "hiWebFile", "helloWebPath", "officeWorldPATH", "helloWallDir", "helloworldLocation", "helloworldPath", " helloWorldName", "helloWorldDir", "helloWorldName", "officeWorldLocation", "helloWorldpath", "hiWebUrl", "helloCommunityName"], "fileOutputStream": ["fileWriteSteam", "resourceOutputSteam", "FileInputHandler", "FileOutputFile", "fileInputSteam", "fileoutputStream", "FileOutputSteam", "fileOutputHandler", "fileWritePath", "FileInputFile", "resourceOutputFile", "resourceInputFile", "fileWritestream", "fileWriteFile", "FileInputSteam", "resourceInputPath", "FileInputstream", "fileOutputPath", "fileOutSteam", "resourceInputStream", "fileInputFile", "fileInputHandler", "fileOutPath", "fileOutputSteam", "fileOutStream", "resourceOutputPath", "FileOutputStream", "fileoutputSteam", "fileWriteStream", "fileOutFile", "resourceInputSteam", "FileOutputHandler", "fileoutputHandler", "fileOutputstream", "resourceOutputStream", "fileInputStream", "fileoutputstream", "fileOutputFile", "FileOutputstream", "FileInputStream", "fileInputPath", "fileInputstream"], "contentResolver": [" contentresolver", "contentResponseistor", "contentRolution", "contentResolves", "contentReslier", "contentAbsoser", "contentRevolved", "contentRlier", "resourceRolved", "messageResolve", "contentResponseolved", "contentRevolution", "contentResoser", "resourceResolver", " contentRevolver", " contentResolves", "contentResolution", " contentresolve", "contentAbsolver", "contentResistor", "contentresolution", "ContentRoser", "contentResultolution", "ContentResolving", "messageResultolve", "contentRevolver", "contentResolving", "messageReslier", "resourceResolve", "contentRolve", "contentResultolve", "ContentResolve", "contentAbsolve", "contentRolves", "contentRolver", "contentRolved", "resourceRolve", "resourceRolution", "contentresolve", "contentRevolve", "messageResultlier", "contentresolving", "contentreslier", "ContentResoser", "contentResolve", "ContentRolve", " contentRevolve", "messageResultolver", "contentresolver", "ContentRolution", " contentRevolved", "resourceRolver", "contentresolved", "resourceResolved", "contentResultistor", "ContentResolver", "contentResultolved", "contentAbsolution", " contentresolves", "contentRevistor", "ContentRolving", " contentResistor", "resourceResolution", "contentResolved", " contentResolved", "contentRoser", " contentRevistor", "contentRevolves", "messageResolver", "contentResultolver", "contentResponseolver", "messageResolution", " contentResolution", "ContentResolution", "contentResultlier", "contentRolving", "ContentRolver", "contentresolves", "messageResultolution", "contentResponseolve", " contentResolve", " contentresolution"], "content": ["next", "image", "job", "size", "children", "script", "html", "full", "Content", "current", "output", "default", "comment", "load", "feed", "java", "handle", "title", "version", "write", "copy", "parent", "page", "css", "lc", "core", "json", "cache", "address", "valid", "ontent", "example", "conn", "complete", "server", "result", "child", "code", "media", "connection", "ext", "message", "resource", "path", "response", "word", "xml", "work", "value", "fill", "file", "url", "model", "update", "data", "temp", "activity", "status", "any", "text", "document", "name", "password", "body", "string", "header", "column", "play", "cont", "empty", "read", "draft", "layer", "config"]}}
{"id1": "9210168", "id2": "23532405", "code1": "            @Override\n            public void run() {\n                try {\n                    URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n                    InputStream fis = url.openStream();\n                    InputStreamReader r = new InputStreamReader(fis, \"UTF-8\");\n                    BufferedReader br = new BufferedReader(r);\n                    String line;\n                    StringBuilder sb = new StringBuilder();\n                    while (null != (line = br.readLine())) {\n                        sb.append(line);\n                        sb.append(\"\\r\\n\");\n                    }\n                    br.close();\n                    r.close();\n                    fis.close();\n                    final String text = sb.toString();\n                    SwingUtilities.invokeLater(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            MainPanel.this.source.setText(text);\n                            MainPanel.this.source.setCaretPosition(0);\n                        }\n                    });\n                } catch (Exception ex) {\n                }\n            }\n", "code2": "    public void persist(FreeFormConfigurable ffConfigurable, String relativePath) {\n        File file = getConfigFile(ffConfigurable, relativePath, PROPERTIES_CONFIG_EXT);\n        InputStream is = ffConfigurable.getInputConfigStream();\n        try {\n            OutputStream os = new FileOutputStream(file);\n            IOUtils.copy(is, os);\n        } catch (Exception e) {\n            throw new ConfigurationException(\"Failed to store free from config for class \" + ffConfigurable.getClass().getName() + \" into file \" + file.getAbsolutePath());\n        }\n    }\n", "label": 0, "substitutes": {"run": ["process", "job", "in", "image", "display", "output", "render", "home", "apply", "replace", "register", "code", "inner", "show", "Run", "work", "out", "start", "unit", "exec", "base", "update", "execute", "test", "runner", "running", "call", "name", "invoke", "background", "un", "stop", "runs", "loop", "add", "create", "launch"], "url": ["lr", "image", "fr", "service", "sl", "rl", "user", "id", "server", "address", "loc", "http", "URL", "resource", "path", "ssl", "file", "nr", "str", "f", "Url", "api", "base", "plug", "err", "loader", "b", "l", "browser", "remote", "string", "ur", "uri", "re", "source"], "fis": ["fIS", "FIS", "bis", "bIS", "pis", "Fais", "FIs", "fIs", "flis", "fliss", " fiss", "biss", " fIs", " fisa", "bIs", "flIs", "bais", " fais", "pIs", "fiss", " fIS", "pisa", "fisa", "fais", "piss", "Fis", "flisa", "Fiss"], "r": ["fr", "p", "Reader", "rl", "i", "is", "rc", "s", "rs", "cr", "e", "rx", "ler", "ru", "rb", "resource", "rh", "ir", "rr", "wr", "rar", "nr", "hr", "sr", "mr", "f", "rf", "ri", "err", "b", "rt", "er", "BR", "kr", "vr", "l", "ar", "res", "reader", "d", "tr", "rus", "R", "ur", "c", "pr"], "br": ["lr", "gr", "fr", "HR", "bf", "bb", "cr", "rx", "result", "dr", "bc", "rb", "bl", "fb", "be", "ob", "Br", "bro", "wr", "str", "hr", "B", "sr", "bh", "mr", "ch", "buf", "err", "b", "rt", "BR", "brush", "arr", "yr", "vr", "browser", "res", "reader", "bridge", "tr"], "line": ["part", "buffer", "sl", "lf", "entry", "rl", "i", "key", "cell", "comment", "el", "character", "cr", "id", "lc", "lines", "Line", "lin", "code", "bl", "li", "word", "row", "file", "str", "liner", "link", "ge", "f", "letter", "end", "sel", "base", "pass", "inline", "data", "b", "char", "split", "cl", "number", "LINE", "shell", "name", "l", "style", "string", "nl", "header", "le", "column"], "sb": ["lr", "db", "abb", "bp", "buffer", "bf", "bis", "src", "ab", "bt", "bs", "lb", "zb", "SB", "amb", "ib", "bb", "ls", "usb", "sa", "sn", "sf", "sg", "bc", "rb", "fb", "bm", "bl", "mb", "buff", "gb", "bj", "pb", "bh", "storage", "bd", "eb", "buf", "binary", "wb", "BB", "b", "bsp", "xb", "obb", "si", "nb", "sth", "sv", "cb", "rob", "erb"], "text": ["font", "buffer", "obj", "entry", "output", "object", "comment", "input", "Text", "title", "id", "info", "result", "code", "format", "content", "connection", "path", "TEXT", "message", "ext", "translation", "value", "str", "letter", "data", "b", "test", "name", "string", "source", "config", "txt"]}}
{"id1": "14168494", "id2": "23510383", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public boolean saveProject(File file, Set<String> types, Set<String> images, Set<String> trajectories, boolean databasesIncluded, boolean onlyLinks) throws IOException, SQLException {\n        int index = file.getName().lastIndexOf(\".\");\n        String name = file.getName().substring(0, index);\n        DecimalFormat format = new DecimalFormat(\"####\");\n        format.setMinimumIntegerDigits(4);\n        int count = 0;\n        File main = new File(name);\n        if (main.exists()) {\n            throw new IOException(main.getAbsolutePath());\n        }\n        main.mkdir();\n        File version = new File(main, \"version\");\n        version.createNewFile();\n        PrintWriter writer = new PrintWriter(version);\n        writer.write(Videso3D.VERSION);\n        writer.flush();\n        writer.close();\n        File xmlDir = new File(main.getAbsolutePath() + \"/xml\");\n        xmlDir.mkdir();\n        if (types != null && !types.isEmpty()) {\n            File databases = new File(main.getAbsolutePath() + \"/databases\");\n            databases.mkdir();\n            for (String t : types) {\n                Type type = DatabaseManager.stringToType(t);\n                if (type != null) {\n                    if (onlyLinks) {\n                        if (databasesIncluded) {\n                            String currentName = DatabaseManager.getCurrentName(type);\n                            File baseCopy = new File(databases, currentName + \".\" + type);\n                            baseCopy.createNewFile();\n                            FileChannel source = new FileInputStream(new File(currentName)).getChannel();\n                            FileChannel destination = new FileOutputStream(baseCopy).getChannel();\n                            destination.transferFrom(source, 0, source.size());\n                            source.close();\n                            destination.close();\n                            List<String[]> clefs = new ArrayList<String[]>();\n                            Statement st = DatabaseManager.getCurrent(Type.Databases);\n                            ResultSet rs = st.executeQuery(\"select * from clefs where type='\" + currentName + \"'\");\n                            while (rs.next()) {\n                                clefs.add(new String[] { rs.getString(\"name\"), rs.getString(\"value\") });\n                            }\n                            st.close();\n                            if (!clefs.isEmpty()) {\n                                File clefsFile = new File(databases, currentName + \"_clefs\");\n                                clefsFile.createNewFile();\n                                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(clefsFile));\n                                oos.writeObject(clefs);\n                                oos.close();\n                            }\n                            File filesDir = new File(currentName + \"_files\");\n                            if (filesDir.exists() && filesDir.isDirectory()) {\n                                File baseFiles = new File(databases, currentName + \"_files\");\n                                baseFiles.mkdirs();\n                                for (File f : filesDir.listFiles()) {\n                                    File copy = new File(baseFiles, f.getName());\n                                    copy.createNewFile();\n                                    source = new FileInputStream(f).getChannel();\n                                    destination = new FileOutputStream(copy).getChannel();\n                                    destination.transferFrom(source, 0, source.size());\n                                    source.close();\n                                    destination.close();\n                                }\n                            }\n                        }\n                        File selectedObjects = new File(databases, type.toString());\n                        selectedObjects.createNewFile();\n                        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(selectedObjects));\n                        oos.writeObject(objects.get(type));\n                        oos.close();\n                    } else {\n                        for (Restorable r : DatasManager.getController(type).getSelectedObjects()) {\n                            this.saveObjectInXml(r, new File(xmlDir, r.getClass().getName() + \"-\" + type + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                }\n            }\n        }\n        File imagesDir = new File(main.getAbsolutePath() + \"/images\");\n        imagesDir.mkdir();\n        for (EditableSurfaceImage si : this.getImages()) {\n            if (images.contains(si.getName())) {\n                int idx = si.getName().lastIndexOf(\".\");\n                String newName = si.getName();\n                if (idx != -1) {\n                    newName = si.getName().substring(0, idx);\n                }\n                File img = new File(imagesDir, newName + \".gtif\");\n                ImageUtils.writeImageToFile(si.getSector(), (BufferedImage) si.getImageSource(), img);\n            }\n        }\n        File trajectoDir = new File(main, \"trajectory\");\n        trajectoDir.mkdirs();\n        for (Layer l : wwd.getModel().getLayers()) {\n            if (l instanceof GEOTracksLayer && trajectories.contains(l.getName())) {\n                GEOWriter geoWriter = new GEOWriter(trajectoDir.getAbsolutePath() + \"/\" + l.getName(), true);\n                for (VidesoTrack track : ((GEOTracksLayer) l).getModel().getVisibleTracks()) {\n                    geoWriter.writeTrack((GEOTrack) track);\n                }\n                geoWriter.close();\n            }\n        }\n        if (types != null && types.contains(\"Autres objets affich\u00e9s.\")) {\n            for (Layer l : wwd.getModel().getLayers()) {\n                if (l.getName().equals(AIRSPACE_LAYER_NAME)) {\n                    for (Airspace r : ((AirspaceLayer) l).getAirspaces()) {\n                        this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(RENDERABLE_LAYER_NAME)) {\n                    for (Renderable r : ((RenderableLayer) l).getRenderables()) {\n                        if (r instanceof Restorable) {\n                            this.saveObjectInXml((Restorable) r, new File(xmlDir, r.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                        }\n                    }\n                } else if (l.getName().equals(BALISES2D_LAYER_NAME)) {\n                    for (Balise2D b : ((Balise2DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                } else if (l.getName().equals(BALISES3D_LAYER_NAME)) {\n                    for (Balise3D b : ((Balise3DLayer) l).getVisibleBalises()) {\n                        this.saveObjectInXml(b, new File(xmlDir, b.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n                    }\n                }\n            }\n        }\n        for (Airspace a : PolygonEditorsManager.getLayer().getAirspaces()) {\n            if (a.isVisible()) this.saveObjectInXml(a, new File(xmlDir, a.getClass().getName() + \"-\" + format.format(count++) + \".xml\"));\n        }\n        this.saveObjectInXml(this.wwd.getView(), new File(main, \"globe.xml\"));\n        FileManager.createZipFile(file, main);\n        FileManager.deleteFile(main);\n        return true;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copiedfile", "transferfile", " copiedClass", "copyClass", " copiedFiles", " copiedFile", "copyFiles", "copyfile", "transferFile", "transferFiles", " copyClass", "transferClass"], "dest": [" Dest", "obj", "output", "class", "transfer", "tmp", "comb", "Dest", "loc", "target", "desc", "path", "resource", "orig", "later", "out", "file", "sup", "dist", "dir", "st", "null", "this", "wb", "data", "temp", "done", "name", " destination", "true", "d", "destroy", "source", "txt"], "src": ["sc", "sl", "upload", "sync", "stream", "master", "rc", "tmp", "s", "sit", "slice", "copy", "sin", "sb", "cb", "Dest", "loc", "source", "target", "rb", "inst", "ssl", "img", "gb", "sup", "ds", "dist", "file", "storage", "config", "sel", "url", "st", "download", "sq", "split", "bin", "sub", "filename", "rob"], "srcChannel": ["srcCh", "srcChan", "sourceChan", "distChannel", " srcchannel", " srcChan", "rcChannel", "inputChannel", "destChan", "srcchannel", "distCh", "srcConnection", " srcButton", " srcStream", "rcButton", "rcCh", "rcSection", "distChan", "distStream", "rcchannel", "srcSection", "inputConnection", "inputchannel", "srcStream", " srcCh", "rcConnection", "inputSection", "rcChan", " srcSection", "rcStream", "destChannel", "sourceChannel", "srcButton", "destchannel", "sourceButton", " srcConnection", "destConnection", "sourcechannel"], "dstChannel": ["dstVideo", " dstContext", "dstschannel", "DdestChannel", " dstStream", "dstContext", " dstsStream", "drcChan", "dstStream", "ddestStream", "ddestVideo", "dDestchannel", "Ddestchannel", " drdChannel", "dDestChannel", "dDestStream", "ddestChannel", "Dstchannel", " dstChan", "drcChannel", " dstConnection", " dstschannel", "dstConnection", " drdContext", "dstsConnection", "drdContext", " dstsConnection", "DstChannel", "DdestVideo", "drdchannel", " dstchannel", "dstsChannel", " drdchannel", " drdChan", "dsrcChannel", "dsrcVideo", "dstChan", "DstVideo", "drcContext", "dstsStream", "drdChan", "drdChannel", "drcchannel", "ddestchannel", "drcVideo", "ddestChan", " dstsChannel", "ddestConnection", "ddestContext", "dsrcchannel", "dstchannel", "dDestConnection"]}}
{"id1": "5125848", "id2": "8062076", "code1": "    @SuppressWarnings({ \"ResultOfMethodCallIgnored\" })\n    public static Node combineJs(URL base, List<Node> linkJs, List<File> newFiles) throws IOException {\n        File dir = File.createTempFile(\"javascript\", \"\" + System.currentTimeMillis());\n        StringBuilder name = new StringBuilder();\n        try {\n            if (dir.delete() && dir.mkdirs()) {\n                File minDir = new File(dir, \"min\");\n                minDir.mkdir();\n                File combineFile = new File(minDir, \"script.js\");\n                File concatFile = new File(minDir, \"concat.js\");\n                Writer combineWriter = new FileWriter(combineFile);\n                Writer concatWriter = new FileWriter(concatFile);\n                final List<Boolean> fails = new LinkedList<Boolean>();\n                boolean first = true;\n                for (Node link : linkJs) {\n                    String path = ((Element) link).getAttribute(\"src\");\n                    URL url = new URL(buildUrl(base, path));\n                    InputStream inputStream = url.openStream();\n                    File jsFile = new File(dir, fileName(url));\n                    FileOutputStream outputStream = new FileOutputStream(jsFile);\n                    IOUtils.copy(inputStream, outputStream);\n                    outputStream.close();\n                    inputStream.close();\n                    if (!first) {\n                        combineWriter.write(\"\\n;\\n\");\n                        concatWriter.write(\"\\n;\\n\");\n                    } else {\n                        first = false;\n                    }\n                    if (Configuration.jsMinification()) {\n                        Reader reader = new FileReader(jsFile);\n                        try {\n                            JavaScriptCompressor jsCompressor = new JavaScriptCompressor(reader, new ErrorReporter() {\n\n                                @Override\n                                public void warning(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public void error(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                }\n\n                                @Override\n                                public EvaluatorException runtimeError(String s, String s1, int i, String s2, int i1) {\n                                    fails.add(true);\n                                    return null;\n                                }\n                            });\n                            jsCompressor.compress(combineWriter, 0, false, false, true, true);\n                        } catch (Exception e) {\n                            fails.add(true);\n                        }\n                        reader.close();\n                    }\n                    Reader reader = new FileReader(jsFile);\n                    IOUtils.copy(reader, concatWriter);\n                    reader.close();\n                    String fileName = jsFile.getName();\n                    int pos = fileName.lastIndexOf('.');\n                    if (pos >= 0) {\n                        fileName = fileName.substring(0, pos);\n                    }\n                    name.append(fileName).append(\",\");\n                }\n                combineWriter.close();\n                concatWriter.close();\n                FileReader reader;\n                if (fails.size() == 0 && Configuration.jsMinification()) {\n                    reader = new FileReader(combineFile);\n                } else {\n                    reader = new FileReader(concatFile);\n                }\n                name.append(hashCode(IOUtils.toString(reader))).append(\".js\");\n                reader.close();\n                File targetFile = new File(Configuration.getJsLocalDir(), name.toString());\n                if (!targetFile.exists()) {\n                    targetFile.getParentFile().mkdirs();\n                    if (fails.size() == 0 && Configuration.jsMinification()) {\n                        FileUtils.copyFile(combineFile, targetFile);\n                    } else {\n                        FileUtils.copyFile(concatFile, targetFile);\n                    }\n                    newFiles.add(targetFile);\n                    logger.info(\"Combined several js files into the single \" + targetFile + \" [size=\" + targetFile.length() + \"].\");\n                }\n            }\n        } finally {\n            FileUtils.deleteQuietly(dir);\n        }\n        if (name.length() != 0) {\n            Element element = (Element) linkJs.get(0);\n            element.setAttribute(\"src\", Configuration.getJsUrlPrefix() + name.toString());\n            return element;\n        } else {\n            return null;\n        }\n    }\n", "code2": "    public void updateUser(User portalUserBean, AuthSession authSession) {\n        DatabaseAdapter dbDyn = null;\n        PreparedStatement ps = null;\n        try {\n            dbDyn = DatabaseAdapter.getInstance();\n            String sql = \"update WM_LIST_USER \" + \"set    FIRST_NAME=?,MIDDLE_NAME=?,LAST_NAME=?, \" + \"       ADDRESS=?,TELEPHONE=?,EMAIL=? \" + \"where  ID_USER=? and is_deleted=0 and  ID_FIRM in \";\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    String idList = authSession.getGrantedCompanyId();\n                    sql += \" (\" + idList + \") \";\n                    break;\n                default:\n                    sql += \"(select z1.ID_FIRM from v$_read_list_firm z1 where z1.user_login = ?)\";\n                    break;\n            }\n            ps = dbDyn.prepareStatement(sql);\n            int num = 1;\n            ps.setString(num++, portalUserBean.getFirstName());\n            ps.setString(num++, portalUserBean.getMiddleName());\n            ps.setString(num++, portalUserBean.getLastName());\n            ps.setString(num++, portalUserBean.getAddress());\n            ps.setString(num++, portalUserBean.getPhone());\n            ps.setString(num++, portalUserBean.getEmail());\n            ps.setLong(num++, portalUserBean.getUserId());\n            switch(dbDyn.getFamaly()) {\n                case DatabaseManager.MYSQL_FAMALY:\n                    break;\n                default:\n                    ps.setString(num++, authSession.getUserLogin());\n                    break;\n            }\n            int i1 = ps.executeUpdate();\n            if (log.isDebugEnabled()) log.debug(\"Count of updated record - \" + i1);\n            dbDyn.commit();\n        } catch (Exception e) {\n            try {\n                if (dbDyn != null) {\n                    dbDyn.rollback();\n                }\n            } catch (Exception e001) {\n            }\n            String es = \"Error update of portal user\";\n            log.error(es, e);\n            throw new IllegalStateException(es, e);\n        } finally {\n            DatabaseManager.close(dbDyn, ps);\n            dbDyn = null;\n            ps = null;\n        }\n    }\n", "label": 0, "substitutes": {"combineJs": ["Combinejs", "combineJS", "CombinateJS", "CombineJs", "combinScript", "combinedJS", "combinedJs", "CombineScript", "combinateScript", "combinedScript", "combinejs", "CombinateScript", "combinateJS", "combinJS", "combineScript", "combinateJs", "CombineJS", "combinedjs", "combinjs", "CombinateJs", "combinatejs", "Combinatejs", "combinJs"], "base": ["image", "db", "absolute", "proxy", "page", "cache", "server", "home", "address", "info", "relative", "http", "resource", "ref", "based", "out", "file", "build", "root", "bas", "part", "store", "f", "area", "prefix", "api", "builder", "data", "b", "log", "bot", "site", "string", "Base", "uri", "source", "config"], "linkJs": [" linkjs", "loadJs", "linkedjs", "likeLinks", " linkLinks", "likeJS", "loadScript", "loadjs", " linkScript", "likejs", "linkedLinks", "linkedJs", "linkjs", "linkScript", "linkJS", "loadJS", "linkLinks", " linkJS", "likeJs", "linkedJS", "linkedScript"], "newFiles": ["addFiles", "addResources", "oldFiles", " newLinks", "oldLinks", "oldResources", "addfiles", "addLinks", " newfiles", "newfiles", "newLinks", "oldfiles", "newResources", " newResources"], "dir": ["domain", "db", "in", "DIR", " db", " download", "src", " folder", "object", "id", "directory", " manager", "cache", "home", "md", " Dir", " directory", "loc", "module", "or", "relative", "http", "container", " d", "dep", "editor", "direction", "ir", "out", "manager", "work", "wd", "file", "build", "root", "dist", " dep", "lib", "zip", "session", "div", "download", "log", "b", "local", "keep", "Dir", " module", "plugin", "d", "folder", " repo", "uri", "lock", " block", "source", " director"], "name": [" resource", " build", " bundle", " info", " zip", " folder", " root", " init", " manager", " abs", " relative", " source", " prefix", " title", " id", " suffix", " dest", "Dir", " head", " cache", " parent", " module", " app", " repo"], "minDir": ["minJar", "miniDriver", "tempDir", " minDriver", "minidir", "miniDb", "blockDir", "versionDir", "blockFile", "minManager", "blockdir", "Mindir", "MinMin", "minDriver", "minDb", "versionManager", "tempdir", "blockDriver", "mindir", "minDest", "initManager", " minFile", " minDb", " minMin", "versionDirectory", "tempJar", "miniFile", "initFolder", " minManager", " minJar", "MinJar", " mindir", " minDest", "minFile", "tempMin", "MinDb", "initDir", "minDirectory", "miniDest", "initDirectory", "minMin", "minFolder", " minFolder", "MinDest", "MinDir", "miniDir", " minDirectory", "versionFolder", "MinFile"], "combineFile": ["comboseWriter", "combinateWriter", "CombineSourceFile", "combinerSourceFile", "CombinateLog", "combinedWriter", "comboseFile", "combinateReader", "combinerLog", "CombinateFile", "combinateFile", "CombinateWriter", "combinerWriter", "combineDir", "comboseDir", "joinateWriter", "joinateFile", "combinedDir", "CombineWriter", "joineReader", "joineWriter", "CombineLog", "combineSourceFile", "combicateFile", "combinedFile", "combineReader", "combinerFile", "joineFile", "joinateReader", "combineLog", "joineDir", "combinateSourceFile", "combinateDir", "CombineFile", "combinateLog", "combinedReader", "combicateSourceFile", "joinateDir", "combicateLog", "combicateWriter", "comboseReader", "CombinateSourceFile"], "concatFile": ["Concatsfile", "concatDir", "concDir", "concWriter", "concatFiles", "concfile", "ConcatsWriter", "concentFile", "ConcatsStream", "concatsFile", "concentWriter", "conatefile", "Concatfile", "concFiles", "ConcatFile", "concentDir", "ConcatFiles", "conateDir", "ConcatWriter", "concatsDir", "concentStream", "ConcatDir", "concFile", "concatsfile", "ConcatsDir", "conateFile", "concatsStream", "concatfile", "concatsFiles", "ConcatsFiles", "ConcatsFile", "concatsWriter", "conateFiles", "concStream", "ConcatStream", "concatStream"], "combineWriter": ["comboseWriter", "combinerReader", "ComboseFile", "combinateWriter", "combineWalker", "combiseWriter", "combideWalker", "combideReader", "combineRW", "comboseFile", "combinateReader", "combinateFile", "mixineWalker", "combideRW", "mixineWriter", "mixinerReader", "comboseWalker", "combideWriter", "CombineWriter", "combineWrite", "ComboseWriter", "CombineWrite", "combiseFile", "combineReader", "ComboseReader", "combiseWrite", "comboseWrite", "mixinerRW", "mixinerWriter", "CombineReader", "combiseReader", "combinerWalker", "combinerRW", "CombineFile", "ComboseWrite", "mixineRW", "mixineReader", "comboseRW", "comboseReader", "mixinerWalker", "combinerWriter", "combinateWrite"], "concatWriter": ["concilFile", "syncatWriter", "ConcatsWrite", "concWriter", "syncWriter", "syncWrite", "ConcatWrite", "convertWrite", "ConcatsWriter", "concReader", "concatsFile", "ConcatFile", "syncatReader", "concatsReader", "ConcatWriter", "syncReader", "concatDriver", "convertReader", "ConcatDriver", "convertWriter", "concilDriver", "concatReader", "concFile", "convertFile", "syncFile", "ConcatsDriver", "concilWrite", "ConcatsFile", "concatsWriter", "concilWriter", "concatWrite", "convertDriver", "syncatFile", "concWrite", "concatsWrite", "concatsDriver", "syncatWrite"], "fails": ["Frors", "frors", "Fls", "fls", "Falls", " fls", "Fails", "foralls", "ifls", "trors", "Fakes", "forils", "Failed", "infils", "Faults", "foraults", "ifils", "ifakes", "failed", "dfailing", "failing", "tils", "infaults", "tails", "dfils", " failing", "forails", "ifails", " fakes", " fils", "dfails", "falls", "Fils", "Failing", "infails", " failed", "fakes", "fils", "faults", "dfailed", "infalls", "tls", " frors"], "link": [" resource", "image", "match", " comment", "block", "ink", "Link", "comment", "load", "dd", " config", "bug", "parse", "e", " node", "links", "address", "open", " Link", "info", "loc", " tag", " inline", "connection", "li", "message", " site", " http", " target", "line", " entry", " source", " page", " html", "linked", " module", " lang", " document", "l", " item", "style", "follow", " anchor", "uri", "add", " location"], "path": ["PATH", "script", "attr", "entry", "src", "key", "class", "pattern", "input", "id", "attribute", "route", "loc", "info", "code", "Path", "location", "content", "pointer", "value", "wd", "file", "step", "data", "type", "text", "node", "ath", "string", "href", "point", "uri", "source", "filename"], "url": ["image", "r", "sl", "html", "stream", "host", "key", "route", "page", "server", "address", "open", "loc", "result", "connection", "http", "location", "URL", "resource", "pull", "xml", "ssl", "file", "build", "str", "f", "Url", "api", "channel", "data", "download", "ri", "loader", "b", "log", "l", "browser", "string", "web", "uri", "source", "www"], "inputStream": ["InputFile", " inputWriter", "inputChannel", "outputstream", "outputFile", "Inputstream", "InputChannel", "outputStreamer", "downFile", "downStreamer", " inputstream", "outputChannel", "outputReader", "outputWriter", "downStream", "InputReader", " inputFile", "InputStreamer", "InputStream", "inputReader", " inputChannel", "downReader", "inputFile", "InputWriter", "inputStreamer", "inputWriter", "inputstream"], "jsFile": ["jsonFile", "javascriptDir", "scriptSource", "scriptPath", "javascriptReader", " jsWriter", "javascriptPath", "scriptFile", "javascriptStream", "JsFile", "jsStream", "jsfile", "jsWriter", "javascriptWriter", "jsonSource", "JsStream", "javascriptFile", "JsWriter", "javascriptSource", " jsfile", "jsReader", "jsSource", "jsPath", "jsDir", "jsonDir", " jsLog", "Jsfile", "JsReader", "scriptDir", "javascriptfile", "jsLog", "JsLog", "jsonPath", "javascriptLog", " jsReader", " jsStream"], "fileName": ["fileSize", " fileSize", "resourceSize", "fileNumber", " fileNumber", "FilePath", "filePath", "resourcePath", "FileName", " filePath", "FileNumber", "resourceNumber", "FileSize", "resourceName"], "outputStream": ["responseWriter", "outputstream", "OutputStream", "outputFile", " outputReader", "resourceSteam", " outputstream", " outputSteam", "OutputWriter", "responseStream", "outputReader", "responseSteam", "outputWriter", "outputSteam", "inputSteam", " outputWriter", "resourceReader", "OutputFile", " outputFile", "responseReader", "Outputstream", "resourcestream", "resourceStream", "inputFile", "OutputSteam", "OutputReader", "inputWriter"], "first": ["next", "auto", "success", "error", "before", "p", "third", "left", "alpha", "one", "full", "all", "same", "default", "use", "user", "required", "then", "stack", "replace", "last", "th", "result", "found", "only", "top", "count", "now", "root", "must", "start", "second", "st", "primary", "each", "split", "it", "other", "First", "again", "prev", "always", "current", "self", "right", "initial"], "reader": ["r", "image", "in", "writer", "buffer", "h", "Reader", "entry", "stream", "rc", "object", "feed", "context", "input", "e", "handler", "reads", "server", "info", "inner", "report", "resource", "io", "xml", "reading", "file", "f", " Reader", "data", "builder", "loader", "er", "driver", "parser", "read", "dd", "source", "config"], "jsCompressor": ["jsRepress", "jsExpressor", "jsExpression", "jsExporter", "jsReporter", "jsCompress", "jsComporter", " jsCompression", "jsRepression", "jsRepressor", " jsCompress", "jsCompression", "jsExpress", " jsComporter"], "s": ["S", "os", "m", "words", "scripts", "g", "qs", "n", "is", "types", "strings", "xs", "ls", "ns", "comments", "ses", "ens", "es", "t", "gets", "lines", "objects", "states", "ions", "ings", "abs", "en", "fs", "sets", "v", "groups", "l", "ing", "ments", "ss", "gs", "ps", "sys", "ws", "ts"], "s1": ["atsAP", "ats2", "sAP", "ings2", "esB", "s81", "ingsB", "qsIP", "ats1", "ys2", "sPre", "esPre", "esAP", "etsPre", "es1", "etsAP", "ys01", "ings1", "ys1", "es2", "qs2", "qs81", "qs1", "s01", "ets2", "ings01", "ets1", "es81", "sB", "esIP", "sIP", "ysB", "atsPre", "es01"], "i": ["ip", "m", "j", "p", "ic", "is", "ik", "q", "e", "phi", "id", "t", "ui", "ifier", "a", "ii", "z", "bi", "x", "pi", "f", "o", "xi", "u", "b", "v", "w", "l", "ing", "d", "si", "qi", "I", "c"], "s2": ["s62", "esSecond", "etsCloud", "etsSecond", "ets82", "ings2", "sSecond", "qs12", "es82", "esCloud", "sets1", "lsSecond", "ls2", "ings12", "ls62", "setsCloud", "qsSecond", "es1", "ets62", "ings1", "ingsSecond", "es2", "es12", "qs2", "qs1", "ets2", "sCloud", "sets2", "ets1", "es62", "s82", "sets82", "s12", "ls1"], "i1": ["e2", "l1", "e1", "a9", "s9", "iFirst", "pi9", "piFirst", "i0", "a1", "i2", "pi4", "e0", "pi0", "a4", "l2", "sFirst", "s4", "iOne", "pi1", "l0", "i9", "eFirst", "s0", "eOne", "i4", "sOne", "lOne", "a2", "pi2"]}}
{"id1": "10214218", "id2": "17773263", "code1": "    public synchronized String encrypt(String plaintext) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    public boolean visar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ps = null;\n        Date fechaSystem = new Date();\n        DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n        DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n        DateFormat sss = new SimpleDateFormat(\"S\");\n        String ss = sss.format(fechaSystem);\n        if (ss.length() > 2) {\n            ss = ss.substring(0, 2);\n        }\n        boolean visado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            String sentenciaSql = \"UPDATE BZMODIF SET FZJCUSVI=?, FZJFVISA=?, FZJHVISA=?\" + ((hayVisadoExtracto) ? \", FZJIEXTR=?\" : \"\") + ((hayVisadoRemitente) ? \", FZJIREMI=?\" : \"\") + \" WHERE FZJCENSA='S' AND FZJCAGCO=? AND FZJNUMEN=? AND FZJANOEN=? AND FZJFMODI=? AND FZJHMODI=?\";\n            ps = conn.prepareStatement(sentenciaSql);\n            ps.setString(1, usuarioVisado);\n            ps.setInt(2, Integer.parseInt(aaaammdd.format(fechaSystem)));\n            ps.setInt(3, Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n            int contador = 4;\n            if (hayVisadoExtracto) {\n                ps.setString(contador++, \"X\");\n            }\n            if (hayVisadoRemitente) {\n                ps.setString(contador++, \"X\");\n            }\n            ps.setInt(contador++, oficina);\n            ps.setInt(contador++, numeroRegistro);\n            ps.setInt(contador++, anoSalida);\n            ps.setString(contador++, fechaModificacion);\n            ps.setString(contador++, horaModificacion);\n            int registrosAfectados = ps.executeUpdate();\n            if (registrosAfectados > 0 && !hayVisadoExtracto && !hayVisadoRemitente) {\n                visado = true;\n            }\n            if (registrosAfectados > 0 && (hayVisadoExtracto || hayVisadoRemitente)) {\n                boolean generado = generarBZVISAD(conn, Integer.parseInt(aaaammdd.format(fechaSystem)), Integer.parseInt(hhmmss.format(fechaSystem) + ss));\n                if (generado) {\n                    visado = actualizarBZSALIDA(conn);\n                }\n                String rem = \"\";\n                String com = \"\";\n                if (hayVisadoRemitente) {\n                    if (!remitente.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1, entidad2 + \"\");\n                        valor.remove();\n                    }\n                } else {\n                    if (!altres.trim().equals(\"\")) {\n                        rem = remitente;\n                    } else {\n                        javax.naming.InitialContext contexto = new javax.naming.InitialContext();\n                        Object ref = contexto.lookup(\"es.caib.regweb.ValoresHome\");\n                        ValoresHome home = (ValoresHome) javax.rmi.PortableRemoteObject.narrow(ref, ValoresHome.class);\n                        Valores valor = home.create();\n                        rem = valor.recuperaRemitenteCastellano(entidad1Old, entidad2Old + \"\");\n                        valor.remove();\n                    }\n                }\n                if (hayVisadoExtracto) {\n                    com = extracto;\n                } else {\n                    com = comentario;\n                }\n                try {\n                    Class t = Class.forName(\"es.caib.regweb.module.PluginHook\");\n                    Class[] partypes = { String.class, Integer.class, Integer.class, Integer.class, Integer.class, String.class, String.class, String.class, Integer.class, Integer.class, String.class, Integer.class, String.class };\n                    Object[] params = { \"V\", new Integer(anoSalida), new Integer(numeroRegistro), new Integer(oficina), new Integer(fechaDocumento), rem, com, tipoDocumento, new Integer(fechaRegistro), new Integer(fzacagge), fora, new Integer(destinatario), idioma };\n                    java.lang.reflect.Method metodo = t.getMethod(\"salida\", partypes);\n                    metodo.invoke(null, params);\n                } catch (IllegalAccessException iae) {\n                } catch (IllegalArgumentException iae) {\n                } catch (InvocationTargetException ite) {\n                } catch (NullPointerException npe) {\n                } catch (ExceptionInInitializerError eiie) {\n                } catch (NoSuchMethodException nsme) {\n                } catch (SecurityException se) {\n                } catch (LinkageError le) {\n                } catch (ClassNotFoundException le) {\n                }\n            }\n            conn.commit();\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            String Stringsss = sss.format(fechaSystem);\n            switch(Stringsss.length()) {\n                case (1):\n                    Stringsss = \"00\" + Stringsss;\n                    break;\n                case (2):\n                    Stringsss = \"0\" + Stringsss;\n                    break;\n            }\n            int horamili = Integer.parseInt(hhmmss.format(fechaSystem) + Stringsss);\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            logLopdBZMODIF(\"UPDATE\", sessioEjb.getCallerPrincipal().getName().toUpperCase(), fzafsis, horamili, 'S', numeroRegistro, anoSalida, oficina, Integer.parseInt(fechaModificacion), Integer.parseInt(horaModificacion));\n        } catch (Exception e) {\n            System.out.println(\"Error: \" + e.getMessage());\n            e.printStackTrace();\n            visado = false;\n            try {\n                if (conn != null) conn.rollback(); else System.out.println(\"ERROR: No es pot fer rollback sense connexi\u00f3!\");\n            } catch (Exception ex) {\n                System.out.println(\"Error: \" + e.getMessage());\n                ex.printStackTrace();\n            }\n        } finally {\n            ToolsBD.closeConn(conn, ps, null);\n        }\n        return visado;\n    }\n", "label": 0, "substitutes": {"encrypt": ["deccrypt", "enipher", "encress", "enress", "decress", "enccrypt", " encipher", "decrypt", "encipher", " encress", " enccrypt", "enrypt", "decipher"], "plaintext": ["anytext", " plainsource", "plainText", "mainText", "batsource", "anytxt", "anyText", " plaintxt", "plaintxt", "battxt", "plainstruct", " plainText", "maintext", "batstruct", "batText", " plainstruct", "plainsource", "battext", "mainsource", "anystruct", "mainstruct"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "dig", "kg", "mad", "key", "pg", "ad", "mu", "pd", "metadata", "arm", "ma", "od", "dr", "message", "amd", "cm", "mb", "nm", "wd", "dh", "mand", "bd", "sm", "mg", "dm", "data", "pm", "sha", "em", "mt", "MD", "mp", "mc", "mod", "mag", "d", "mage", "ld", "ms", "meta", "am", "cmd", "dd", " MD", "hm"], "raw": ["image", "clean", "buffer", "original", "bytes", "words", "RAW", "block", "full", "rc", "load", "feed", "input", "instance", "dec", "unsigned", "serial", "ng", "good", "content", "array", "Raw", "message", "initial", "pack", "rew", "unknown", "row", "binary", "enc", "null", "buf", "wrapper", "none", "data", "ack", "text", "wave", " RAW", "hex"], "hash": ["mac", "image", "ha", "h", "alpha", "html", "ash", "block", "key", " hex", "version", "id", "abi", "cache", "sh", "code", "sum", "array", "response", "message", "rh", "Hash", "ashes", "url", "base", "data", "her", "log", "secret", "sha", "header", "kh", "ruby", "hed", "hex"]}}
{"id1": "62362", "id2": "21425787", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    private static void copyFile(File in, File out) {\n        try {\n            FileChannel sourceChannel = new FileInputStream(in).getChannel();\n            FileChannel destinationChannel = new FileOutputStream(out).getChannel();\n            sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n            sourceChannel.close();\n            destinationChannel.close();\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconvert", "Convert", "unvert", "unverted", "subversion", "oconverted", "CONversion", "converting", "subverted", "subverting", "unception", "unversion", " deconverted", " deconvert", "conversion", "subvert", "CONverting", "CONception", "Converted", "CONverted", " deconverting", "conception", " deconversion", "oconverting", "CONvert", "oconversion", "Conception", "Conversion", "Converting", "converted"], "src": ["video", "feat", "stage", "sc", "component", "obj", "upload", "ctx", "attr", "stream", "rl", "rc", "tmp", "load", "s", "impl", "input", "slice", "sit", "sn", "sin", "RC", "sb", "cb", "scene", "Dest", "loc", "code", "rb", "ource", "inst", "path", "ref", "fp", "resource", "ssl", "img", "proc", "gb", "fn", "file", "Source", "supp", "config", "storage", "secure", "sel", "dist", "url", "buf", "st", "prot", "req", "download", "spec", "cpp", "SourceFile", "name", "reader", "string", "href", "sth", "sys", "uri", "gz", "cmp", "back", "source", "filename", "username"], "dest": ["obj", "class", "tmp", "std", "home", "Dest", "target", "dc", "path", "orig", "disk", "img", "fn", "dist", "dir", "lib", "null", "temp", "test", "di", "bin", " destination", " dst", "cont", "dat", "source", "txt"], "in": ["r", "pin", "n", "inn", "stream", "isin", "i", "is", "input", "ex", "din", "t", "val", "inas", "inf", "a", "io", "ini", "file", "f", "pass", "doc", "login", "data", "err", "ins", "bin", "In", "d", "IN", "reader", "as", "ps", "win", "source", "up", "inc"], "p": ["r", "bp", "m", "h", "j", "P", "pp", "g", "pa", "cp", "i", "pre", "s", "pg", "e", "po", "pd", "t", "py", "per", "lp", "fp", "op", "cop", "pb", "part", "pi", "f", "tp", "o", "pe", "jp", "b", "v", "pm", "wp", "pc", "l", "d", "ps", "parser", "np", "c", "pr", "sp"], "ds": ["os", "ups", "words", "sync", "ipes", "styles", "cs", "s", "bs", "xs", "dds", "DS", "gd", "icks", "dm", "dl", "hs", "ins", "vs", "da", "dat", " DS", "tests", "dates", "dp", "db", "dos", "nas", "cons", "ths", "lines", "docs", "posts", "tools", "dist", "ays", "ans", " sd", "utils", "ss", "d", "parts", "js", "ded", "ts", "qs", "models", "rs", "ls", "pd", "ges", "ks", "obs", "services", "lp", "groups", "ys", " props", "ps", "ld", "dd", "uds", "Ds", "plugins", "vals", "sts", "ils", "points", "scripts", "ns", "els", "dc", "ads", "ants", "dt", "df", " ps", "des", "data", "eps", "di", "amps", "gs", "sys"], "format": ["template", "host", "form", "pattern", "class", "layout", "sche", "fd", "version", "handler", "t", "Format", "filename", "path", "fp", "magic", "function", "ant", "at", "file", "fn", "part", "feat", "f", "url", "letter", "prefix", "unit", "api", "model", "scale", "data", "type", "struct", "spec", "tag", "atter", "record", "language", "nat", "name", "table", "frame", "style", "plugin", "string", "parser", "filter", "act", "source", "config"], "hasPixelData": ["hasByteSize", "showsPixeldata", "hasPixeldata", "showsPixelStyle", "hasBytedata", "hasByteStyle", "hasPictureData", "hasByteData", "hasPixelStyle", "haspixelData", "showsByteDATA", "hasPictureSize", " hasPixelSize", " hasPixeldata", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPixelDATA", "showsByteData", "haspixeldata", "haspixelSize", "hasPicturedata", "showsPixelDATA", "showsPixelData", "hasPixelSize"], "inflate": ["invenode", "infolate", "inadequate", "infface", "inadequATE", "insvenode", "insflate", "Inflace", "inflation", "infloation", "inflATE", "inffation", "infloate", "inflace", "insvenating", "infloated", "infloace", "invenATE", "inffate", "inflode", "Inflate", "inFlate", "InFlate", "inFlated", "insflATE", "invenating", "Inflated", "infolating", "invenate", "inFlace", "inflated", "insflating", "infolode", "insvenate", "inadequode", "inffated", "InFlated", "insvenATE", "Inflation", "insflode", "InFlace", "inflating", "inFlation", "inadequating", "infolATE", "InFlation"], "pxlen": ["axln", "fxln", "axlon", "mxsize", "pgl", "xpcount", "pplen", "pngcount", "camlen", "pxpos", "pxlon", "xplength", "pclin", "fxl", "pgden", "axlin", "pxcount", "pngsize", "pxLen", "fxpos", "mxlength", "pgLen", "campos", "fxdata", "pxl", "fxden", "ppl", "mxpos", "pnglength", "mxln", "axlen", "pxdata", "txlin", "xpsize", "txlon", "ppden", "pglen", "pnglen", "mxlen", "pxln", "fxLen", "mxcount", "xplen", "mxdata", "txln", "camln", "pcln", "pxden", "camdata", "fxlen", "pclon", "pclen", "txlen", "pxlength", "pxlin", "pxsize", "ppLen"], "out": ["Out", "pad", "error", "obj", "query", "up", "output", "user", "copy", "parent", "cli", "page", "server", "cache", "conn", "group", "state", "io", "line", "work", "step", "post", "store", "lib", "session", "re", "err", "log", "v", "inter", "co", "again", "list", "point", "sys", "outs", "lock", "gen", "dump", "OUT"]}}
{"id1": "62362", "id2": "1862616", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"convert": ["oconvert", "Convert", "unvert", "unverted", "subversion", "oconverted", "CONversion", "converting", "subverted", "subverting", "unception", "unversion", " deconverted", " deconvert", "conversion", "subvert", "CONverting", "CONception", "Converted", "CONverted", " deconverting", "conception", " deconversion", "oconverting", "CONvert", "oconversion", "Conception", "Conversion", "Converting", "converted"], "src": ["video", "feat", "stage", "sc", "component", "obj", "upload", "ctx", "attr", "stream", "rl", "rc", "tmp", "load", "s", "impl", "input", "slice", "sit", "sn", "sin", "RC", "sb", "cb", "scene", "Dest", "loc", "code", "rb", "ource", "inst", "path", "ref", "fp", "resource", "ssl", "img", "proc", "gb", "fn", "file", "Source", "supp", "config", "storage", "secure", "sel", "dist", "url", "buf", "st", "prot", "req", "download", "spec", "cpp", "SourceFile", "name", "reader", "string", "href", "sth", "sys", "uri", "gz", "cmp", "back", "source", "filename", "username"], "dest": ["obj", "class", "tmp", "std", "home", "Dest", "target", "dc", "path", "orig", "disk", "img", "fn", "dist", "dir", "lib", "null", "temp", "test", "di", "bin", " destination", " dst", "cont", "dat", "source", "txt"], "in": ["r", "pin", "n", "inn", "stream", "isin", "i", "is", "input", "ex", "din", "t", "val", "inas", "inf", "a", "io", "ini", "file", "f", "pass", "doc", "login", "data", "err", "ins", "bin", "In", "d", "IN", "reader", "as", "ps", "win", "source", "up", "inc"], "p": ["r", "bp", "m", "h", "j", "P", "pp", "g", "pa", "cp", "i", "pre", "s", "pg", "e", "po", "pd", "t", "py", "per", "lp", "fp", "op", "cop", "pb", "part", "pi", "f", "tp", "o", "pe", "jp", "b", "v", "pm", "wp", "pc", "l", "d", "ps", "parser", "np", "c", "pr", "sp"], "ds": ["os", "ups", "words", "sync", "ipes", "styles", "cs", "s", "bs", "xs", "dds", "DS", "gd", "icks", "dm", "dl", "hs", "ins", "vs", "da", "dat", " DS", "tests", "dates", "dp", "db", "dos", "nas", "cons", "ths", "lines", "docs", "posts", "tools", "dist", "ays", "ans", " sd", "utils", "ss", "d", "parts", "js", "ded", "ts", "qs", "models", "rs", "ls", "pd", "ges", "ks", "obs", "services", "lp", "groups", "ys", " props", "ps", "ld", "dd", "uds", "Ds", "plugins", "vals", "sts", "ils", "points", "scripts", "ns", "els", "dc", "ads", "ants", "dt", "df", " ps", "des", "data", "eps", "di", "amps", "gs", "sys"], "format": ["template", "host", "form", "pattern", "class", "layout", "sche", "fd", "version", "handler", "t", "Format", "filename", "path", "fp", "magic", "function", "ant", "at", "file", "fn", "part", "feat", "f", "url", "letter", "prefix", "unit", "api", "model", "scale", "data", "type", "struct", "spec", "tag", "atter", "record", "language", "nat", "name", "table", "frame", "style", "plugin", "string", "parser", "filter", "act", "source", "config"], "hasPixelData": ["hasByteSize", "showsPixeldata", "hasPixeldata", "showsPixelStyle", "hasBytedata", "hasByteStyle", "hasPictureData", "hasByteData", "hasPixelStyle", "haspixelData", "showsByteDATA", "hasPictureSize", " hasPixelSize", " hasPixeldata", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPixelDATA", "showsByteData", "haspixeldata", "haspixelSize", "hasPicturedata", "showsPixelDATA", "showsPixelData", "hasPixelSize"], "inflate": ["invenode", "infolate", "inadequate", "infface", "inadequATE", "insvenode", "insflate", "Inflace", "inflation", "infloation", "inflATE", "inffation", "infloate", "inflace", "insvenating", "infloated", "infloace", "invenATE", "inffate", "inflode", "Inflate", "inFlate", "InFlate", "inFlated", "insflATE", "invenating", "Inflated", "infolating", "invenate", "inFlace", "inflated", "insflating", "infolode", "insvenate", "inadequode", "inffated", "InFlated", "insvenATE", "Inflation", "insflode", "InFlace", "inflating", "inFlation", "inadequating", "infolATE", "InFlation"], "pxlen": ["axln", "fxln", "axlon", "mxsize", "pgl", "xpcount", "pplen", "pngcount", "camlen", "pxpos", "pxlon", "xplength", "pclin", "fxl", "pgden", "axlin", "pxcount", "pngsize", "pxLen", "fxpos", "mxlength", "pgLen", "campos", "fxdata", "pxl", "fxden", "ppl", "mxpos", "pnglength", "mxln", "axlen", "pxdata", "txlin", "xpsize", "txlon", "ppden", "pglen", "pnglen", "mxlen", "pxln", "fxLen", "mxcount", "xplen", "mxdata", "txln", "camln", "pcln", "pxden", "camdata", "fxlen", "pclon", "pclen", "txlen", "pxlength", "pxlin", "pxsize", "ppLen"], "out": ["Out", "pad", "error", "obj", "query", "up", "output", "user", "copy", "parent", "cli", "page", "server", "cache", "conn", "group", "state", "io", "line", "work", "step", "post", "store", "lib", "session", "re", "err", "log", "v", "inter", "co", "again", "list", "point", "sys", "outs", "lock", "gen", "dump", "OUT"]}}
{"id1": "3558512", "id2": "345515", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    public Configuration(URL url) {\n        InputStream in = null;\n        try {\n            load(in = url.openStream());\n        } catch (Exception e) {\n            throw new RuntimeException(\"Could not load configuration from \" + url, e);\n        } finally {\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException ignore) {\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["serialization", "serialized", "Serialze", "Serialization", "finalify", " serialization", " serialze", "normalized", "finalized", "erializable", " serializable", "normalize", "serializable", "erialize", "normalze", "Serializable", "erialization", "Serialize", "Serialized", "Serialify", "serialify", "erialze", "serialze", "normalify", "finalze", "finalize"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "up", "i", "output", "copy", "parent", "ex", "page", "archive", "cache", "server", "conn", "filename", "content", "a", "report", "io", "pool", "raw", "file", "png", "o", "exec", "data", "temp", "err", "loader", "w", "name", "bin", "string", "outs", "gen", "dump", "source", "OUT"], "parser": ["writer", "p", "worker", "upload", "pp", "cp", "master", "class", "instance", "parse", "pkg", "copy", "pillar", "Parser", "handler", "parent", "server", "cache", "per", "tt", "php", "lp", "xml", "manager", "file", "rar", "base", "wrapper", "system", "pe", "builder", "loader", "er", "test", "arser", "processor", "ss", "reader", "as", "plugin", "seed", "up", "txt"], "on_disk": ["on_storage", "onbootlock", "off_demand", "onJdisk", "onjdrive", "onJdrive", "off_lock", "onbootdisk", "onnetdemand", "onJdemand", "onbookdrive", "on_lock", "off_file", "off_drive", "onnetdrive", "onbookdisk", "onJlock", "onbootstorage", "onnetspace", "off_disk", "on_demand", "off_delete", "off_storage", "onnetfile", "onnetdisk", "on_drive", "onjspace", "onjfile", "on_file", "onjdisk", "off_space", "on_delete", "onbootdrive", "on_space", "onbookdelete"], "in": ["r", "pin", "inn", "stream", "i", "socket", "input", "copy", "thin", "din", "conn", "inas", "info", "ax", "lin", "connection", "inner", "ini", "con", "rin", "file", "kin", "min", "f", "o", "pass", "login", "data", "ac", "ins", "bin", "In", "reader", "IN", "again", "as", "win", "source", "c", "inc"]}}
{"id1": "19147279", "id2": "5951610", "code1": "    public boolean actualizarDatosFinal(int idJugadorDiv, int idRonda, jugadorxDivxRonda unjxdxr) {\n        int intResult = 0;\n        String sql = \"UPDATE jugadorxdivxronda \" + \" SET resultado = ?, puntajeRonda = ? \" + \" WHERE jugadorxDivision_idJugadorxDivision = \" + idJugadorDiv + \" AND ronda_numeroRonda = \" + idRonda;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            populatePreparedStatementActFinal(unjxdxr);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"actualizarDatosFinal": [" actualizarDatOSFinal", " actualizarDatosResult", " actualizarDatocFinal", " actualizarDatocTotal", " actualizarBatosTotal", " actualizarDataoComplete", " actualizarDataoTotal", " actualizarDatOSComplete", " actualizarBatocResult", " actualizarDataoFinal", " actualizarBatosResult", " actualizarDatOSTotal", " actualizarBatocFinal", " actualizarDataoResult", " actualizarDatOSResult", " actualizarBatocComplete", " actualizarBatosFinal", " actualizarDatosTotal", " actualizarDatocComplete", " actualizarDatocResult", " actualizarBatocTotal", " actualizarBatosComplete", " actualizarDatosComplete"], "idJugadorDiv": ["idJudadeDec", "idJugordDec", "idJugaderDec", "idJugordOrd", "idJugrarDoc", "idJugaderDoc", "idJugaderDIV", "idJubordDiv", "idJugordDiv", "idJugadorDIV", "idJubadorDec", "idJugordDIV", "idJudadorDiv", "idJubadorDoc", "idJugadorDec", "idJudadorDIV", "idJudadorDec", "idJugrarDiv", "idJugaderDiv", "idJubordDoc", "idJugordDoc", "idJugadeDec", "idJugadorOrd", "idJubordOrd", "idJugaderOrd", "idJugadorDoc", "idJubordDec", "idJudadeDIV", "idJubadorOrd", "idJubadorDiv", "idJugadeDiv", "idJugadeDIV", "idJugrarOrd", "idJugrarDec", "idJudadeDiv"], "idRonda": ["idrora", "idRona", "idRado", "idRhonda", "idGrora", "idRhanna", " idRora", "pidRhado", "idRhado", "idRora", "idRhona", " idRanna", "pidRhora", "pidRado", " idrora", "idGrado", "idRhora", "idrado", "idrona", "pidRonda", "idGronda", "pidRhona", " idronda", "idGrona", " idRona", "pidRhonda", "idronda", "idranna", " idrona", " idranna", "pidRona", "pidRora", "idRanna"], "unjxdxr": ["unjxfexr", "unjddxxR", "unjxdxxl", "unjxdxl", "unjxdddR", "unjxfexR", "unjxdxtr", "unjddxl", "unjxdddrs", "unjxdexer", "unjddxxl", "unjxdxrs", "unjxdxtrs", "unjxdxter", "unjxfxR", "unjxdxxr", "unjxfxr", "unjxdddr", "unjxdxxR", "unjxfexrs", "unjddxxer", "unjddxr", "unjxdexl", "unjxdexR", "unjxdxtl", "unjddxer", "unjxdxR", "unjxdexr", "unjxdxer", "unjxdxxer", "unjxdxtR", "unjddxR", "unjxdexrs", "unjddxxr", "unjxfxrs"], "intResult": ["IntReturn", "longResult", "intRes", " intOrder", " intRest", "INTReturn", "intCode", "ntCode", "IntCode", "intReturn", "mintRate", "longRes", "longResponse", "INTRest", "IntRate", "intRate", "ntResult", "IntResponse", "INTResult", "intRest", " intReturn", "mintResult", "ntRes", " intRes", "longCode", "intOrder", "mintOrder", "intResponse", " intRate", "IntRes", "ntResponse", "IntResult", "IntOrder", "INTRes", "mintReturn", "IntRest"], "sql": ["job", "db", "query", "sl", "sync", "msg", "QL", "socket", "comment", "pg", "select", "section", "statement", " SQL", "limit", "SQL", "sb", "conn", "params", "ssl", "fn", "str", "plan", "url", "sq", "log", "printf", "dl", "database", "eps", "joined", "mt", "search", "l", "ql", "string", "nl", "cmd", "join", "dd", "pr"], "connection": ["position", "db", "client", "connect", "BC", "writer", "query", "ctx", "cp", "relation", "socket", "cc", "proxy", "character", "context", "pg", "environment", "section", "statement", "handler", "server", "conn", "loc", "bc", "container", "index", "manager", "con", "function", "connected", "engine", "session", "log", "database", "collection", "application", "document", "driver", "table", "reader", "ion", "communication", "Connection", "config", "c", "condition"], "ps": ["ppa", "os", "ups", "details", "ping", "p", "PS", "qs", "pp", "pa", "cp", "bs", "cs", "proxy", "pg", "syn", "rs", "ls", "ns", "ips", "po", "conn", "ks", "pers", "posts", "params", "ds", "changes", "ts", "relations", "pe", "eps", "hs", "ins", "pc", "ops", "mp", "Ps", "pse", "gs", "pps", "ms", "ports", "pr", "sp"]}}
{"id1": "300397", "id2": "18164929", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "18731843", "id2": "5951610", "code1": "    public void doBody(JWebLiteRequestWrapper req, JWebLiteResponseWrapper resp) throws SkipException {\n        BufferedInputStream bis = null;\n        BufferedOutputStream bos = null;\n        try {\n            bis = new BufferedInputStream(new FileInputStream(this.loadData(req)));\n            bos = new BufferedOutputStream(resp.getOutputStream());\n            IOUtils.copy(bis, bos);\n            bos.flush();\n        } catch (Exception e) {\n            _cat.warn(\"Write data failed!\", e);\n        } finally {\n            IOUtils.closeQuietly(bis);\n            IOUtils.closeQuietly(bos);\n        }\n    }\n", "code2": "    public void testNetworkHTTP() {\n        Log.v(\"Test\", \"[*] testNetworkHTTP()\");\n        URL url = null;\n        HttpURLConnection urlConnection = null;\n        try {\n            url = new URL(\"http://code.google.com/p/droidbox/\");\n            urlConnection = (HttpURLConnection) url.openConnection();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            @SuppressWarnings(\"unused\") String line = \"\";\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/imei.php?imei=\" + hashedImei);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/phone.php?phone=\" + phoneNbr);\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/msg.php?msg=\" + msg.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            url = new URL(\"http://pjlantz.com/file.php?file=\" + fileContent.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n            url = new URL(\"http://pjlantz.com/app.php?installed=\" + installedApps.replace(\" \", \"+\"));\n            urlConnection = (HttpURLConnection) url.openConnection();\n            rd = new BufferedReader(new InputStreamReader(urlConnection.getInputStream()));\n            while ((line = rd.readLine()) != null) ;\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            urlConnection.disconnect();\n        }\n    }\n", "label": 0, "substitutes": {"doBody": ["doResponse", "doFile", " doFile", " doBytes", "handleResponse", "DoFile", "handleBytes", "DoBody", "handleFile", " doResponse", "doBytes", "DoBytes", "DoResponse", "handleBody"], "req": ["request", "r", "fr", "obj", "query", "src", "q", "def", "qq", "rx", "reg", "conn", "info", "cgi", "rss", "http", "report", "ref", "resource", "rh", "rr", "proc", "qt", "rec", "crit", "this", "serv", "data", "err", "jp", "download", "spec", "comp", "requ", "sem", "Request", "res", "reader", "respond", "config"], "resp": ["request", "r", "job", "p", "obj", "html", "pos", "reply", "pre", "respons", "bb", "cache", "val", "result", "response", "ref", "report", "ret", "rr", "Response", "proc", "Resp", "rec", "exc", "part", "prot", "rev", "serv", "api", "rep", "data", "err", "jp", "download", "b", "comp", "inv", "res", "respond", "cmp", "re", "cb", "sp"], "bis": ["lis", "os", "mis", "obi", "isin", "oris", "is", "bs", "ois", "phis", "bb", "usb", "abi", "ses", "lins", "sin", "sb", "bid", "ris", "alis", "boot", "los", "ubis", "obs", "iss", "ios", "bps", "ori", "nis", "bes", "atis", "fb", "iris", "bi", "bas", "bh", "ais", "bits", "binary", "sis", "bian", "pins", "b", "bin", "obb", "obos", "rots", "tis", "uds"], "bos": ["os", "obi", "oos", "zos", "oops", "bris", "bs", "ois", "bott", "phis", "lol", "lins", "bo", "abi", "ros", "aos", "los", "boot", "ubis", "obs", "ios", "bps", "bes", "oses", "osa", "antis", "bas", "bi", "bh", "osi", "zo", "bits", "oks", "mos", "oS", "las", "fits", "ops", "bin", "obb", "bones", "oros", "obos", "obo", "opus", "tis", "uds"]}}
{"id1": "7351534", "id2": "1141361", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromsystemidentifier", "getStreamFromsystemIdentifier", "getStreamFromSystemIdentification", "getStreamFromSystemIdifier", "getStreamFromsystemidentification", "getStreamFromSystemidentifiers", "getStreamFromSystemidentification", "getStreamFromsystemidentifer", "getStreamFromsystemIdentification", "getStreamFromSystemIdification", "getStreamFromSystemidentifier", "getStreamFromSystemIdifiers", "getStreamFromsystemIdentifiers", "getStreamFromSystemidentifer", "getStreamFromsystemidentifiers", "getStreamFromSystemIdifer", "getStreamFromsystemIdentifer", "getStreamFromSystemIdentifer", "getStreamFromSystemIdentifiers"], "systemId": ["customid", "servicePath", "sysPath", "machineID", "systemPath", "systemName", "serviceId", "ystemId", "customName", "systemid", " systemID", "ystemName", " systemName", "securityName", "SystemID", "serviceid", " systemPath", "securityID", "securityid", "ystemID", "sysId", "machineid", "ystemid", " systemid", "serverId", "sysid", "SystemId", "securityId", "systemID", "serverID", "customID", "customId", "Systemid", "machineId", "serverid", "SystemName"], "resolver": ["presolve", "Resolver", "reolution", "resolve", "presolving", " resolution", "reolving", " resol", "reolve", "Resolving", "Resolve", "presolution", "reol", "resolving", "reolver", "presolver", " resolving", "resolution", "resol", " resolve", "Resolution", "Resol"], "source": ["position", "client", "component", "service", "size", "creator", "sl", "sync", "element", "large", "src", "i", "class", "ce", "object", "proxy", "scope", "slice", "context", "instance", "parse", "e", "parent", "slave", "id", "handler", "server", "from", "info", "result", "target", "connection", "container", "response", "resource", "path", "resources", "Source", "secure", "storage", "iter", "o", "channel", "null", "unit", "model", "session", "data", "type", "spec", "SOURCE", "text", "document", "entity", "name", "reader", "string", "remote", "seed", "uri", "ource", "ources"], "stream": ["image", "clean", "client", "buffer", "service", "sw", "sl", "flash", "src", "host", "form", "output", "view", "object", "load", "feed", "proxy", "input", "context", "instance", "parent", "handler", "port", "valid", "server", "child", "result", "or", "connection", "wh", "content", "path", "resource", "report", "message", "response", "pool", "row", "dest", "file", "channel", "wrapper", "model", "session", "zip", "data", "temp", "log", "trans", "live", "allow", "document", "Stream", "body", "string", "reader", "speed", "steam", "cont", "event", "read", "length"], "url": ["image", "client", "large", "service", "sl", "src", "host", "object", "feed", "proxy", "id", "page", "server", "address", "loc", "connection", "http", "location", "URL", "resource", "path", "ssl", "file", "link", "Url", "channel", "base", "zip", "data", "control", "gl", "loader", "l", "string", "web", "uri", "ource"]}}
{"id1": "13757855", "id2": "6966398", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public static void main(String[] args) {\n        System.out.println(\"Chapter 16: example SignedPdf\");\n        System.out.println(\"-> Creates a signed PDF;\");\n        System.out.println(\"-> jars needed: iText.jar\");\n        System.out.println(\"-> files generated in /results subdirectory:\");\n        System.out.println(\"   Resource needed: .keystore\");\n        System.out.println(\"-> Resulting PDFs: unsigned_message.pdf, signed_message.pdf,\");\n        System.out.println(\"   corrupted_message.pdf, signed_message_invisible.pdf,\");\n        System.out.println(\"   double_signed_message.pdf, revision_1.pdf and revision_2.pdf\");\n        createPdf();\n        PdfReader reader;\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setCertificationLevel(PdfSignatureAppearance.CERTIFIED_FORM_FILLING);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(30, 750, 500, 565), 1, null);\n            stamper.close();\n        } catch (KeyStoreException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (CertificateException e) {\n            e.printStackTrace();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (UnrecoverableKeyException e) {\n            e.printStackTrace();\n        } catch (DocumentException e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            Document document = new Document(reader.getPageSizeWithRotation(1));\n            PdfCopy copy = new PdfCopy(document, new FileOutputStream(\"results/in_action/chapter16/corrupted_message.pdf\"));\n            document.open();\n            copy.addPage(copy.getImportedPage(reader, 1));\n            document.close();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (DocumentException de) {\n            de.printStackTrace();\n        }\n        try {\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            reader = new PdfReader(\"results/in_action/chapter16/unsigned_message.pdf\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/signed_message_invisible.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0');\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"It's personal.\");\n            appearance.setLocation(\"Foobar\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            reader = new PdfReader(\"results/in_action/chapter16/signed_message.pdf\");\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(new FileInputStream(\"resources/in_action/chapter16/.keystore\"), \"f00b4r\".toCharArray());\n            PrivateKey key = (PrivateKey) ks.getKey(\"foobar\", \"r4b00f\".toCharArray());\n            Certificate[] chain = ks.getCertificateChain(\"foobar\");\n            FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/double_signed_message.pdf\");\n            PdfStamper stamper = PdfStamper.createSignature(reader, os, '\\0', null, true);\n            PdfSignatureAppearance appearance = stamper.getSignatureAppearance();\n            appearance.setCrypto(key, chain, null, PdfSignatureAppearance.SELF_SIGNED);\n            appearance.setReason(\"Double signed.\");\n            appearance.setLocation(\"Foobar\");\n            appearance.setVisibleSignature(new Rectangle(300, 750, 500, 800), 1, \"secondsig\");\n            stamper.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        try {\n            CertificateFactory cf = CertificateFactory.getInstance(\"X509\");\n            Collection col = cf.generateCertificates(new FileInputStream(\"resources/in_action/chapter16/foobar.cer\"));\n            KeyStore ks = KeyStore.getInstance(KeyStore.getDefaultType());\n            ks.load(null, null);\n            for (Iterator it = col.iterator(); it.hasNext(); ) {\n                X509Certificate cert = (X509Certificate) it.next();\n                System.out.println(cert.getIssuerDN().getName());\n                ks.setCertificateEntry(cert.getSerialNumber().toString(Character.MAX_RADIX), cert);\n            }\n            reader = new PdfReader(\"results/in_action/chapter16/double_signed_message.pdf\");\n            AcroFields af = reader.getAcroFields();\n            ArrayList names = af.getSignatureNames();\n            String name;\n            for (Iterator it = names.iterator(); it.hasNext(); ) {\n                name = (String) it.next();\n                System.out.println(\"Signature name: \" + name);\n                System.out.println(\"Signature covers whole document: \" + af.signatureCoversWholeDocument(name));\n                System.out.println(\"Document revision: \" + af.getRevision(name) + \" of \" + af.getTotalRevisions());\n                FileOutputStream os = new FileOutputStream(\"results/in_action/chapter16/revision_\" + af.getRevision(name) + \".pdf\");\n                byte bb[] = new byte[8192];\n                InputStream ip = af.extractRevision(name);\n                int n = 0;\n                while ((n = ip.read(bb)) > 0) os.write(bb, 0, n);\n                os.close();\n                ip.close();\n                PdfPKCS7 pk = af.verifySignature(name);\n                Calendar cal = pk.getSignDate();\n                Certificate pkc[] = pk.getCertificates();\n                System.out.println(\"Subject: \" + PdfPKCS7.getSubjectFields(pk.getSigningCertificate()));\n                System.out.println(\"Document modified: \" + !pk.verify());\n                Object fails[] = PdfPKCS7.verifyCertificates(pkc, ks, null, cal);\n                if (fails == null) System.out.println(\"Certificates verified against the KeyStore\"); else System.out.println(\"Certificate failed: \" + fails[1]);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"process": ["request", "cess", "output", "view", "load", "construct", "parse", "run", "evaluate", "handle", "code", "path", "resource", "submit", "proc", "build", "exec", "update", "transform", "processing", "call", "processor", "project", "create", "Process"], "tpl": ["stPL", "lple", " tcl", "tplate", "tmyl", "temPL", "tml", "ttemplate", "tplug", "stpl", "Tplates", "Tper", "lcl", "fpl", "Tsl", "tpp", " tplates", "tmple", "fplate", "tple", "latpl", "tcl", "temtemplate", "qtple", "templates", "tipl", "latple", "Tpl", "stplate", "tmcp", " tml", "Tml", "itPL", "lPL", "fplug", "pipl", "templ", "stpp", "lplate", " ttemplate", " tplug", "latyl", "itpl", "lper", "tmpl", "tcp", "atml", " tplate", "Tfc", "qtpl", "atplate", "fml", "Tbl", "qtfc", " tper", "itplates", "ppl", "tbl", "tPL", " tsl", "atplug", "pPL", "qtbl", "qtcp", "Tipl", "Tpp", " tbl", "psl", " tple", "latcp", "itplate", "lpl", " tpp", " tfc", "tper", "qtyl", "Tcl", " tipl", "atpl", "Tple", "lml", "tplates", "Ttemplate", "Tplate", "pcl", "TPL", " tPL", "tsl", "tfc", "tyl"], "model": ["where", "m", "models", "copy", "Model", "json", "module", "result", "media", "location", "graph", "message", "param", "params", "xml", "conf", "doc", "data", "log", "language", "document", "node", "project", "body", "command", "config"], "packageName": ["projectName", "projectKey", "packagename", "groupKey", "groupname", "packageInfo", "moduleUrl", "moduleKey", "contextname", "Packagename", " packageInfo", "projectname", "contextNames", "groupName", "PackageName", "moduleName", "packageUrl", " packagename", "PackageInfo", "modulename", "packageKey", "packageNames", " packageNames", "PackageNames", "groupUrl", "contextName", "projectUrl", "contextInfo"], "outFileName": ["outRuleInfo", "outRuleType", "outLineNames", "outfileNames", "outDirEnd", "OUTBufferName", "inFilePath", "diffFileName", "outDirCopy", "outfileName", "outFullTime", "outfileCopy", "outDirPath", "outFileTime", "inDirCopy", "outDirInfo", "outStreamName", "OUTFileName", " outFileLine", "outfileOnce", "OUTBufferMode", "outDirOnce", "outBufferMode", "outFileOnce", "outFileEnd", "outFilesPath", "outStreamType", "outFilenameName", "outfileInfo", "outFilesTime", "OutDirLine", "outFilename", "outfileHalf", "outBufferHalf", "outFileLine", "inDirName", "OutDirNames", "outFilesName", "outBufferNames", "outFileType", "outFullname", "outFileHalf", "difffileInfo", "outFilenameNames", "outFileCopy", "outFilenameCopy", "outLineInfo", "OutFileNames", " outFileInfo", "diffFileOnce", "outFullName", "inDirPath", "outFullInfo", "inFileName", "diffFileInfo", "outLineName", "diffFileTime", "difffileTime", "outFilenameEnd", "outFullType", "outFilenameMode", " outDirTime", " outFullType", "outFilenameHalf", "outfileTime", "outLineTime", "outFullPath", "outLineLine", "inFileCopy", " outDirLine", "OutDirname", "outFilesLine", " outFileType", "OutFilename", " outFilePath", "OUTFileNames", " outDirName", "outFileNames", "outLineOnce", "outBufferName", "outfileMode", "outDirTime", "inFileEnd", "outFullLine", "difffileOnce", "inDirEnd", "OUTBufferNames", " outFullName", "outStreamInfo", "outDirLine", "outLinename", "outfileEnd", "OutFileLine", " outDirPath", "outFullNames", "outFilenamePath", "OUTBufferHalf", "outFileInfo", "difffileName", "outDirname", "OutFileName", "outfilePath", "outFileMode", "outDirNames", "OUTFileHalf", " outFullInfo", "outDirName", " outFileTime", "OUTFileMode", "OutDirName", "outFilePath", "outRuleName"], "xsltParam": ["xslicparam", "xslpMode", "xslicMode", "xsldVal", "xslicParam", "xsltMode", "xslpparam", "xslpParam", "xltVal", "xsltVal", "xsldparam", "xsldParam", "xldMode", "xldparam", "xldVal", "xsltparam", "xltParam", "xltMode", "xslicVal", "xltparam", "xslpVal", "xldParam", "xsldMode"], "artifact": ["artfact", "Artfact", "Arturation", " artribution", "Artifacts", "advertribution", "Artifest", " arturation", "advertifacts", "adverturation", "artifest", " artifacts", "ARTifest", "arturation", "ARTifact", "ARTfact", "ARTifacts", "artifacts", "aratifacts", "Artifact", "advertifact", "aratifest", "aratifact", "aratfact", "artribution", "Artribution"], "destinationPath": ["destinatedPoint", "destinationFile", "constinationContext", "destinatorUrl", "datinationPath", "destificationPath", "destinatorFile", "tempinationPath", "restinatorPath", "tempinationpath", "destensionPoint", "destplingPath", "destinatorPath", "destinatorString", "distinatorStep", "constinatorpath", "destensionName", "destinatePath", "desticationKey", "destinatedHalf", "destinatorStep", "destinationsName", "destinateHandler", "destinerPath", "constinatorUrl", "destignmentCase", "destiationDir", "destinatedDir", "desticationPart", "distinationCase", "destinatingPath", "combinationName", "destinateText", "destinationspath", "constinationWidth", "destinationsPath", "restinationString", "tempinatedDir", "destinatepath", "destificationAuth", "destinatePart", "destinateName", "datinationpath", "destinationName", "destiationPath", "destinatedCase", "tempinatedpath", "destributionName", "datinateTime", "desturationName", "constinationName", "desticationPath", "DestinatingName", "destinationUrl", " destificationLog", "datinationTime", "destplingDir", "destplingAuth", "restinationLocation", "restinationpath", "destinatedFile", "destinateDir", " destinationLog", "destiationAuth", "destificationLog", "distinationStep", "desticationFile", "destributionCry", "destinationText", "DestinationPart", "destinateString", "combinationPath", "restinatorPoint", "destinationHandler", "destinationContext", "destinatedString", "constinationsPoint", "distinatorKey", "destplingWidth", "restinationPoint", "destificationLocation", "destationpath", "tempinationHalf", "restificationPath", "desturationPath", "destinationAuth", "distributionCase", "destiningDir", "restificationPoint", "destinatorName", "destinatorPoint", "constinationUrl", "destributionCase", "DestificationPath", "constinatorPath", "destinatedpath", "destinateLocation", "destinationpath", "destensionPath", "destcreationPath", "destinatingpath", "desturationpath", " destinationDir", "destificationpath", "destinatorpath", "destiationLog", "destignmentPath", "destationPath", "destificationName", "destinatorCase", "destplingLog", "destinationCase", "destinationWidth", "combinatorName", "combinatorPath", "destinationsPoint", "restinationHalf", "constinationPath", "constinatorContext", "destinatingName", "destributionDir", "destinerDir", "destinationTime", "restinatorHalf", "destiningContext", " destinationAuth", "DestinatingPath", "destinatorDir", "tempinatedPath", " destificationAuth", "distinationpath", "destinatedPath", "distinationCry", "combinatorHandler", "distributionpath", "distinatorName", " destificationDir", "datinationLocation", "constinatorWidth", "destinateTime", "DestificationPart", "restinatorString", "distinatorCase", "destinationLocation", "distinationDir", "destinationDir", "DestificationName", "destinatePoint", "destinatorHandler", "destinatorHalf", "destplingUrl", "destributionPath", "destinatingLocation", "destcreationUrl", "DestinationPath", "desticationStep", "destinerContext", "desticationName", "distinatorCry", "destinationKey", " destificationPath", "destinatedKey", "destationTime", "DestinationText", "constinatorDir", "combinatorpath", "constinationDir", "destinatingText", "distinationName", "constinationpath", "destiningName", "constinationsPath", "restinationPath", "destiningPath", "combinationHandler", "destributionpath", "distinatorPath", "constinationsName", "restificationpath", "destensionText", "destinationStep", "destinationPart", "destinatorWidth", "destificationPart", "desturationHandler", "destinateHalf", "destinatorTime", "constinationPoint", "distinationKey", "DestinatingText", "DestinationName", "destiningPoint", "destinatorLocation", "destinationLog", "distinationFile", "destationLocation", "destificationPoint", "datinatePath", "DestinationPoint", "distributionPath", "destinerpath", "distinationPath", "constinationspath", "destinationPoint", "destinatorKey", "destignmentName", "destinatingPoint", "destinationString", "combinationpath", "DestinatingPoint", "destiningpath", "destificationDir", "tempinationDir", "destinatedStep", "distributionDir", "distinatorFile", "destcreationWidth", "destinationHalf", "destinatorContext", "tempinatedHalf", "destinatorCry", "destignmentCry", "destinationCry", "datinateLocation", "restificationLocation", "datinatepath"], "in": ["r", "image", "n", "i", "input", "ex", "din", "t", "cache", "connection", "con", "x", "min", "doc", "data", "ins", "name", "bin", "In", "reader", "IN", "d", "source", "config", "c", "inc"], "out": ["Out", "error", "ne", "client", "writer", "obj", "msg", "full", "all", "up", "key", "output", "comment", "user", "version", "free", "write", "parent", "copy", "cli", "page", "ex", "cache", "server", "conn", "group", "state", "result", "connection", "path", "index", "io", "pool", "line", "manager", "file", "str", "post", "part", "store", "prefix", "lib", "o", "exec", "doc", "Output", "session", "err", "with", "temp", "log", "w", "name", "bin", "again", "string", "list", "point", "sys", "outer", "outs", "gen", "lock", "dump", "source", "OUT"], "root": ["r", "query", "tree", "pattern", "instance", "cat", "parent", "id", "include", "json", "cache", "history", "module", "format", " result", "index", "graph", "path", "params", "modules", "resources", "results", " roots", "roots", "_", "xml", "options", "url", "loader", "values", "collection", "transform", "node", "Root", "meta"]}}
{"id1": "2461169", "id2": "9081749", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "23118425", "id2": "2807585", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static String encodeMd5(String key) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(key.getBytes());\n            byte[] bytes = md.digest();\n            String result = toHexString(bytes);\n            return result;\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 1, "substitutes": {"encrypt": ["enipher", "Enccrypt", " Encrypted", "Encrypt", "enccrypt", " Enccrypt", "encrypted", "encipher", " Encrypt", "Encipher", "enrypted", " Encipher", "enrypt", "Encrypted"], "plaintext": [" plaindata", " plainsource", "broadtext", "plainText", "broadstring", "protecteddata", "flatstring", "flattext", " plainstring", "broadsource", "protectedtext", "flatdata", "protectedstruct", "flatsource", "plainstruct", " plainText", "protectedText", "plainstring", "broadText", " plainstruct", "flatstruct", "plainsource", "plaindata", "flatText"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "kg", "dig", "ph", "mad", "pg", "ad", "pkg", "mu", "pd", "metadata", "ma", "od", "cd", "dc", "code", "message", "amd", "nm", "mb", "wd", "dh", "mand", "bd", "mg", "dm", "data", "pm", "sha", "mt", "MD", "mp", "mc", "hd", "mag", "mod", "d", "material", "vd", "ld", "am", "meta", "ms", "cmd", "mem", "dd", " MD", "hm"], "raw": ["image", "clean", "buffer", "original", "RAW", "block", "stream", "full", "def", "load", "feed", " hex", "input", "instance", "unsigned", "serial", "dec", "ng", "content", "array", "Raw", "message", "response", "initial", "pack", "unknown", "rew", "row", "binary", "enc", "null", "channel", "buf", "ack", "local", "partial", "wrap", "custom", "empty", "shared", " RAW", "hex"], "hash": ["mac", "image", "buffer", "h", "html", "block", "ash", "crypt", "key", "full", "version", "id", "cache", "code", "sum", "array", "response", "message", "rh", "value", "row", "Hash", "build", "url", "base", "data", "her", "log", "secret", "sha", "text", "auth", "password", "string", "header", "empty", "kh", "hex"]}}
{"id1": "20991673", "id2": "23335922", "code1": "    public NodeId generateTopicId(String topicName) {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA\");\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"No SHA support!\");\n        }\n        if (m_ready) System.out.println(\"Scribe is ready at\" + getNodeId() + \" , topic is \" + topicName);\n        md.update(topicName.getBytes());\n        byte[] digest = md.digest();\n        NodeId newId = new NodeId(digest);\n        return newId;\n    }\n", "code2": "    public String digest(String message) throws NoSuchAlgorithmException, EncoderException {\n        MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n        messageDigest.update(message.getBytes());\n        byte[] raw = messageDigest.digest();\n        byte[] chars = new Base64().encode(raw);\n        return new String(chars);\n    }\n", "label": 1, "substitutes": {"generateTopicId": ["generatedTopicName", "generatedtopicID", "generateTopicInfo", "generatedTopicID", "generatetopicID", "generatedTopicInfo", "generatetopicId", "generatedtopicName", "generateTopicsId", "generateTopicsID", "generatedtopicId", "generatetopicInfo", "generatetopicName", "generateTopicName", "generateTopicID", "generatedTopicId", "generatedtopicInfo", "generateTopicsInfo", "generateTopicsName"], "topicName": [" topicInfo", "topname", " topicNames", "subjectName", "channelKey", "channelId", "TopicInfo", "subjectType", "channelType", " topicId", "topId", "channelName", "topicname", "TopicId", "channelInfo", "subjectId", "topicKey", "topicInfo", " topicPath", "Topicname", "topicId", "TopicNames", "topNames", "TopicKey", "topicNames", " topicType", "TopicName", "subjectPath", "topicPath", "topicType", "channelPath", "topName", " topicname", " topicKey"], "md": ["km", "mm", "mac", "mo", "m", "Cmd", "dig", "ad", "pkg", "id", "po", "pd", "ud", "metadata", "ma", "dr", "od", "dc", "rm", "editor", "mb", "amd", "cm", "df", "dh", "mand", "bd", "gd", "sm", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "mc", "hd", "mag", "vd", "d", "ld", "ms", "meta", "hash", "am", "cmd", "dd", " MD"], "digest": [" digested", "mdester", "signest", "signests", "cdgest", "DigEST", "mdest", "mdhed", "signEST", "diggest", "digests", "cdEST", " digEST", "dighed", "cdest", "Digest", "dest", " digester", " dighed", "Digester", "dhed", "Digests", "digester", "decests", "digEST", "cdester", "decest", " diggest", "mdested", "decEST", "dested", "digested", "dester", "Diggest"], "newId": ["nextid", "newID", "NewID", "newInfo", "NewInfo", "nextInfo", " newID", "newid", " newid", "Newid", "nextID", " newInfo", "nextId", "NewId"]}}
{"id1": "2221297", "id2": "8778962", "code1": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"getURLContent": ["getPageContent", "getStringBody", "getStringcontent", "geturlContents", "getPageBody", "getStringContent", "geturlContent", "parseurlContent", "parseurlBody", "parseURLContent", "getPagecontent", "parseurlcontent", "getURLContents", "geturlcontent", "parseurlContents", "parseURLContents", "getPageContents", "getURLBody", "geturlBody", "parseURLcontent", "getStringContents", "parseURLBody", "getURLcontent"], "urlToSearchString": ["urlToFindString", "urlTOFindArray", "urlTosearchString", "urltosearchArray", "urlToSearchStr", "urlToFindSection", "urlTOFindStr", "urltosearchString", "urlTosearchSection", "urlTOSearchSection", "urltoSearchString", "urlTOFindString", "urltosearchStr", "urlToCreateString", "urltoSearchStr", "urltosearchSection", "urlToSearchArray", "urlTosearchArray", "urlTOSearchString", "urlToCreateArray", "urlToCreateSection", "urlTOFindSection", "urltoSearchSection", "urlToFindArray", "urltoSearchArray", "urlToCreateStr", "urlToSearchSection", "urlToFindStr", "urlTosearchStr", "urlTOSearchArray", "urlTOSearchStr"], "url": ["job", "db", "blog", "client", "sl", "rl", "host", "bb", "ls", "lc", "page", "www", "server", "open", "connection", "http", "URL", "resource", "cur", "ssl", "file", "str", "f", "Url", "ch", "base", "zip", "download", "b", "log", "org", "ll", "l", "web", "ur", "uri", "jar", "cb", "c"], "conn": ["db", "client", "connect", "Conn", "sync", "ctx", "n", "g", "cp", "host", "socket", "cn", "rc", "cli", "nt", "cb", "open", "loc", "connection", "nc", "http", "dc", "cur", "io", "ssl", "con", "conf", "connected", "ch", "enc", "api", "exec", "conv", "err", "rt", "ct", "auth", "Config", "Connection", "act", "config", "c"], "encoding": ["Encatin", "acoder", " encatin", "encatin", "decoded", "engoder", "Encoded", "noding", "locoder", " encoded", "enoder", "enoding", "Encoder", "noder", "loccode", "encoded", "engcode", "decoder", "engoding", "enccode", "acoded", "locoded", "acatin", "enale", "engoring", " encoring", "nale", "Encoding", "encode", "decoding", "encoring", "engoded", "encoder", "enoded", "decoring", "Encale", " encoder", "encale", "noded", "locoding", "acoding"], "br": ["lr", "r", "db", "fr", "stream", "src", "ab", "bb", "cr", "cro", "grab", "result", "dr", "bc", "rb", "bl", "ber", "fb", "ref", "http", "ob", "Br", "bro", "img", "str", "bh", "hr", "sr", "mr", "ch", "buf", "err", "b", "bar", "BR", "arr", "browser", "reader", "bridge", "tr", "jar", "orb", "cb", "sp"], "sb": ["db", "abb", "bp", "bf", "src", "ab", "lb", "bs", "bt", "SB", "amb", "ib", "bb", "ls", "sa", "sn", "sf", "sg", "bc", "rb", "fb", "bm", "kb", "bps", "lp", "mb", "ob", "buff", "gb", "ssl", "bj", "pb", "bh", "bd", "eb", "binary", "wb", " SB", "BB", "builder", "b", "bot", "bsp", "xb", "obb", "si", "nb", "lab", "ruby", "cb", "erb"], "line": ["next", "r", "buffer", "sl", "lf", "n", "pos", "i", "key", "cell", "comment", "feed", "character", "e", "lc", "page", "lines", "Line", "lin", "code", "content", "response", "word", "out", "row", "str", "len", "link", "f", "end", "letter", "part", "base", "inline", "data", "err", "b", "char", "cl", "number", "text", "LINE", "name", "l", "reader", "string", "body", "source", "c"]}}
{"id1": "17791385", "id2": "19251426", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "src": ["image", "sc", "sl", "obj", "upload", "ipl", "stream", "files", "rc", "s", "input", "sit", "ls", "sin", "sb", "loc", "inf", "rb", "http", "inst", "resource", "img", "dest", "file", "sup", "dist", "config", "sel", "url", "st", "b", "ins", "uri", "back", "source", "filename", "txt"], "dst": ["fdsp", " dsts", "dfd", "stlt", "ddst", "dsts", "ddft", "stst", "ddfd", "pdft", "ddest", "Dsts", " ddest", "Ddest", "ststs", "stdest", "Dst", "fdfd", "Dlt", "dsp", "pdsp", "dlt", "fdft", "fdst", "dft", "pdfd", "pdst", " dlt", "ddsp"], "in": ["r", "m", "h", "pin", "n", "inn", "gin", "i", "is", "socket", "init", "cin", "impl", "input", "ln", "id", "sin", "din", "conn", "lin", "inner", "pull", "nin", "rin", "ini", "kin", "con", "file", "inside", "f", "url", "login", "data", "err", "oin", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "inc"], "out": ["Out", "plain", "client", "writer", "self", "obj", "sync", "n", "off", "i", "output", "s", "copy", "parent", "ex", "server", "cache", "conn", "exp", "ext", "io", "at", "file", "raw", "part", "post", "line", "x", "f", "o", "null", "exec", "err", "temp", "w", "other", "net", "bin", "OUT", "again", "outs", "outer", "up", "inc"], "buf": ["pad", "buffer", "seq", "bytes", "batch", "bf", "ctx", "br", "off", "queue", "fd", "rc", "ff", "lim", "fl", "cat", "bb", "val", "loc", "bc", "rb", "fb", "bl", "cur", "buff", "raw", "uc", "count", "bag", "bd", "bh", "wb", "base", "vec", "data", "b", "cap", "v", "uf", "bin", "cmd", "c", "cb", "length"], "len": ["ind", "fin", "size", "sl", "lf", "n", "pos", "all", "i", "fd", "el", "lt", "fl", "lim", "ix", "ln", "nt", "lc", "val", "lin", "li", "line", "Len", "count", "part", "en", "end", "f", "rev", "no", "base", "data", "err", "cap", "ll", "split", "cl", "name", "l", "bin", "le", "c", "length"]}}
{"id1": "21063400", "id2": "9846843", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doThumbnailFile", "doimageprocess", " doimageProcess", " doimageprocess", "doFileFile", "doimageProcess", " doImageprocess", "doImageFile", "doThumbnailProcess", " doimageFile", "doFileprocess", "doimageFile", "doFileProcess", "doImageprocess", "doThumbnailprocess", " doImageFile"], "request": ["image", "client", "writer", "query", "stream", "object", "input", "instance", "server", "result", "path", "report", "message", "resource", "xml", "url", "req", "model", "data", "type", "application", "method", "name", "Request", "reader", "header", "config"], "response": ["next", "image", "error", "success", "video", "client", "writer", "service", "full", " Response", "queue", "host", "output", "reply", "view", "object", "feed", "default", "version", "page", "server", "json", "complete", "cache", "example", "more", "result", "connection", "http", "location", "message", "report", "resource", "index", "pool", "results", "Response", "out", "description", "resp", "ception", "api", "onse", "model", "session", "collection", "status", "application", "wave", "document", "site", "body", "respond"], "imgSize": [" imgLength", "imgLen", "imgLength", "largeSize", "imageLength", "imageName", "hrType", "augLen", "imgWidth", "imgHeight", "imgsize", " imgWidth", "bgFamily", "augWidth", "dimsize", "imageSize", "imagesize", "bgLen", " imgsize", "imgScale", "imgC", "largeType", "ifName", "imgFamily", "imageLen", "dimLength", "imagType", "imgName", "refHeight", "imsize", "bgLength", "dimSize", " imgLen", "imagC", "refsize", "imSize", "imgType", "augFamily", "hrsize", "refSize", "imHeight", " imgFamily", "bgScale", "bgWidth", " imgScale", "imagsize", "bgSize", "largesize", "augSize", "largeC", "imLength", "ifLen", "dimHeight", "hrSize", " imgName", "hrC", "ifsize", "imagSize", "refLength", "imageScale", "ifSize"], "imageInputStream": ["photoInputStream", "imageStreamStream", "imageOutputStream", "imageFileStream", "imageUploadSteam", "imageContentStream", "imageStreamSteam", "fileInputString", "imageOutputView", "pictureInputSteam", "imageUploadFile", "imageInLength", "photoReadFile", "fileReadLength", "imageOutputSteam", "imageInputFile", "imageReadLength", "imageContentView", "fileInputLength", "imageUploadView", "imageInputView", "pictureInputstream", "imageInputSteam", "imageReadStream", "imageFileLength", "pictureInputStream", "imageContentSteam", "imageInString", "imageOutputstream", "pictureInputFile", " imageInputFile", "photoReadSteam", "fileInputstream", "fileReadStream", "imageStreamstream", "imageUploadstream", "imageContentFile", "imageStreamFile", "pictureUploadstream", "photoReadstream", "fileReadstream", " imageOutputSteam", "imageReadString", "imageInputLength", "pictureUploadSteam", "imageFilestream", "imageOutputFile", "imageFileString", "pictureUploadFile", "imageInputString", "photoInputstream", "photoInputFile", "fileInputStream", "imageInStream", "photoInputSteam", "fileReadString", " imageOutputView", "pictureUploadStream", "imageReadFile", " imageOutputStream", "imageUploadStream", " imageInputView", "imageInputstream", "photoReadStream", " imageInputSteam", "imageInstream", "imageReadstream", " imageOutputFile", "imageReadSteam"], "imageBytes": [" imageData", "fileBlocks", " imageBuffer", "imageByte", "imgbytes", "pictureData", "audiobytes", "pictureBytes", "imgData", "Imagebytes", "viewbytes", " imageByte", "ImageBytes", "imgBuffer", "imageBuffer", "viewBytes", "audioBuffer", "imageData", "pictureBlocks", "picturebytes", "viewData", " imageUrl", "filebytes", "ImageData", "audioByte", "fileBytes", " imagebytes", "audioBytes", "imageUrl", "imgBytes", "fileData", "imageBlocks", "ImageBlocks", "imagebytes", "imgByte", "viewUrl", "imgUrl"]}}
{"id1": "20855053", "id2": "742465", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 1, "substitutes": {"init": ["process", "connect", "loading", "load", "app", "construct", "install", "parse", "handler", "Init", "check", "register", "info", "boot", "resource", "Initialized", "build", "start", "activate", "loader", "log", "test", "it", "strap", "setup", "create", "config", "launch"], "context": ["request", "sc", "component", "obj", "tx", "ctx", "ce", "cc", "app", "parent", "e", "ex", "cf", " contexts", "or", "bc", "http", "exc", "req", "vc", "cl", "pc", "processor", "cms", "Context", "config", "c", "ec"], "classLoader": ["ClassWriter", "logPath", "objectLoad", "resourcePath", "ClassLoading", "objectLoader", " classLoading", "ClassPath", " classWriter", "logloader", "classWriter", " classloader", " classReader", "logWriter", "ClassLoad", "classPath", "resourceLoading", "classReader", "classloader", "logLoader", "ClassLoader", "classLoading", " classPath", "objectReader", "Classloader", "objectloader", "classLoad", "ClassReader", "resourceloader", "resourceLoader", " classLoad"], "urls": ["urlps", "URLches", " urllines", "resourcelines", "httpions", "sls", "URLps", "resourceions", "URLs", " urlps", "webs", "URLions", "webches", "webls", "resourcels", "urlis", "resources", "slls", "slches", "webis", "urlls", "urlions", "URLlines", "https", "resourceps", "httplines", "URLis", "urllines", "httpls", "urlches", "URLls", "slis", " urlls"], "url": ["lr", "r", "job", "image", "ball", "buffer", "sl", "ul", "element", "entry", "rl", "full", "host", "class", "object", "feed", "user", "layer", "ls", "bb", "id", "page", "coll", "server", "address", "loc", "result", "connection", "found", "http", "URL", "resource", "li", "pull", "io", "path", "ssl", "file", "link", "f", "Url", "channel", "base", "err", "gl", "loader", "b", "rel", "org", "ll", "name", "l", "browser", "string", "uri", "source"], "reader": ["r", "iterator", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "feed", "ro", "input", "e", "rx", "handler", "server", "per", "or", "ler", "editor", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "ri", "re", "loader", "er", "oder", "l", "upper", "parser", "read", "layer"], "className": ["stringType", " classDescription", "typeLine", "stringName", "lassType", "ClassPath", " classInfo", "Classname", "classString", "staticType", " classCode", "typeInfo", " classValue", "CLASSType", "classText", "stringInfo", "ClassLine", "clName", "urlName", "objectPath", "objectNumber", "clCode", "clInfo", " classString", "lassEl", " classNumber", "classLine", "urlname", " classPath", "caseDescription", "caseLine", "typeName", "clNumber", "staticname", "classDescription", "clString", "urlText", "lassBase", "classname", "clText", " classname", "classPath", " classType", "lassInfo", "classInfo", " classText", "objectname", "clBase", "staticEl", "CLASSName", "objectName", "classBase", "clname", "classType", "urlValue", "caseValue", "caseName", "typeType", "CLASSEl", "staticName", "objectString", "CLASSname", " classLine", "stringLine", "ClassString", "clValue", "classCode", "lassname", "classValue", "classEl", "lassCode", " classBase", "clPath", "lassName", "ClassValue", "classNumber", "ClassDescription", "ClassName"], "clazz": ["clclass", " cllass", "Clazz", "plade", "cluster", "class", " clclass", "clade", "Class", "glass", "gllass", "classazz", "classuster", "cllass", "pllass", "classlass", "glade", "classclass", "plazz", "glazz", "plass", "Cllass", "Clclass", "Clade", "Cluster", " cluster"]}}
{"id1": "17475530", "id2": "9327525", "code1": "    @TestProperties(name = \"Simple test for adding different image files to report as link\")\n    public void testAddLinkToImage() throws Exception {\n        InputStream in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/splash.jpg\");\n        report.report(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"splash.jpg\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/blue.png\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"blue.png\")));\n        in = this.getClass().getClassLoader().getResourceAsStream(\"regression/generic/images/classDir.gif\");\n        IOUtils.copy(in, new FileOutputStream(new File(report.getCurrentTestFolder() + System.getProperty(\"file.separator\") + \"classDir.gif\")));\n        report.addLink(\"Link to JPG\", \"splash.jpg\");\n        report.addLink(\"Link to PNG\", \"blue.png\");\n        report.addLink(\"Link to GIF\", \"classDir.gif\");\n    }\n", "code2": "    @Test\n    public void test02_ok() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(chartURL);\n            List<NameValuePair> nameValuePairs = new ArrayList<NameValuePair>(1);\n            nameValuePairs.add(new BasicNameValuePair(\"ws\", \"getDomainEvolution\"));\n            nameValuePairs.add(new BasicNameValuePair(\"chartTitle\", \"test\"));\n            nameValuePairs.add(new BasicNameValuePair(\"type\", \"chart\"));\n            nameValuePairs.add(new BasicNameValuePair(\"firstDate\", \"20111124\"));\n            nameValuePairs.add(new BasicNameValuePair(\"lastDate\", \"20111125\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParams\", \"type,counting,protocol,unit,proxy,domain,timeScale,period\"));\n            nameValuePairs.add(new BasicNameValuePair(\"wsParamsValues\", \"chart,volume,all,hits,all,google.com,day,360\"));\n            nameValuePairs.add(new BasicNameValuePair(\"serieTitle\", \"serie\"));\n            post.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n            HttpResponse response = client.execute(post);\n            HttpEntity entity = response.getEntity();\n            assertNotNull(entity);\n            InputStream instream = entity.getContent();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(instream));\n            System.out.println(reader.readLine());\n            instream.close();\n            assertEquals(\"error :\" + response.getStatusLine(), 200, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"testAddLinkToImage": ["testAddLinkOfPicture", "testAddLinkToPicture", "testAddLinkFromPicture", "testAddLinktoFile", "testAddLinksToLink", "testAddLinkOfLink", "testAddLinksToPicture", "testAddLinkstoPicture", "testAddLinkFromLink", "testAddLinkOfFile", "testAddLinktoLink", "testAddLinkstoLink", "testAddLinkToLink", "testAddLinkToFile", "testAddLinksToImage", "testAddLinkFromImage", "testAddLinkstoFile", "testAddLinkOfImage", "testAddLinktoImage", "testAddLinkFromFile", "testAddLinkstoImage", "testAddLinksToFile", "testAddLinktoPicture"], "in": ["r", "image", "get", "m", "pin", "n", "inn", "gin", "isin", "stream", "is", "i", "socket", "el", "cin", "input", "version", "copy", "id", "ex", "din", "val", "conn", "diff", "ax", "or", "connection", "exp", "index", "resource", "path", "nin", "xml", "ssl", "out", "ini", "con", "work", "file", "rin", "at", "min", "f", "url", "pass", "exec", "serv", "login", "doc", "data", "err", "with", "token", "ins", "name", "bin", "In", "reader", "IN", "as", "again", "uri", "win", "source", "ac", "inc"]}}
{"id1": "14303294", "id2": "7633336", "code1": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "code2": "    private JSONObject executeHttpGet(String uri) throws Exception {\n        HttpGet req = new HttpGet(uri);\n        HttpClient client = new DefaultHttpClient();\n        HttpResponse resLogin = client.execute(req);\n        BufferedReader r = new BufferedReader(new InputStreamReader(resLogin.getEntity().getContent()));\n        StringBuilder sb = new StringBuilder();\n        String s = null;\n        while ((s = r.readLine()) != null) {\n            sb.append(s);\n        }\n        return new JSONObject(sb.toString());\n    }\n", "label": 0, "substitutes": {"getServerHash": [" getSecureSHA", "getServerSHA", " getServerSHA", " getSecureSalt", "getserverHash", "getSessionSalt", "getSecureSHA", "getSessionSHA", " getSecureAddress", "getSecureHash", "getSessionAddress", "getSecureSalt", "getserverSHA", "getserverAddress", "getServerSalt", " getServerAddress", "getSecureAddress", " getSecureHash", " getServerSalt", "getserverSalt", "getServerAddress", "getSessionHash"], "passwordHash": ["passwordPass", " passwordSalt", " passwordPassword", "privatePassword", "passwordhash", " passwordhash", "PasswordCode", "Passwordhash", " PasswordPass", "PasswordHash", "passwordCode", " PasswordHash", " passwordCode", "privateHash", "PasswordPass", "passwordSalt", " passwordPass", "privateSalt", "passwordPassword", "privatehash", "PasswordPassword", " PasswordCode"], "PasswordSalt": [" passwordSalt", " passwordPassword", " PasswordSecret", "PASSPassword", " Password256", " PasswordPassword", "PasswordSecret", " PasswordHash", "PasswordHash", " passwordSecret", "password256", "passwordSecret", "Password256", "PASSHash", "passwordSalt", "PASS256", "passwordPassword", "PasswordPassword", "PASSSalt"], "hash": ["ha", "image", "error", "mac", "buffer", "h", "size", "dig", "html", "ash", "block", "crypt", "key", "user", "copy", "cache", "address", "check", "sh", "result", "sum", "array", "content", "response", "message", "code", "pool", "change", "value", "row", "Hash", "build", "work", "url", "base", "update", "data", "her", "log", "sha", "number", "search", "auth", "password", "string", "kh", "hex"], "digest": ["hashester", " digested", "signest", "mdester", " digger", "generest", "hasher", "signher", "digusher", "mdusher", "digger", "mdest", "integall", "integested", "diger", "integester", "Diger", "generall", "Digest", "signger", "Digger", " diger", "Digester", " digester", "hashest", " digall", "digener", "digall", "digester", "Digener", "generester", "Digher", "mdested", "signer", "digher", "Digusher", " digusher", "hashener", "digested", "integest", " digener", "Digested", "generested", "signester", " digher"]}}
{"id1": "442381", "id2": "17337238", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String develBuild = null;\n            String stableBuild = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".build\")) develBuild = line.substring(6).trim(); else if (line.startsWith(\".stablebuild\")) stableBuild = line.substring(12).trim();\n            }\n            bin.close();\n            if (develBuild != null && stableBuild != null) {\n                doVersionCheck(view, stableBuild, develBuild);\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": ["doVersionWork", "doReleaseWork", "doBuildCheck", " doReleasecheck", "doVERSIONWork", " doBuildWork", "doversioncheck", "doversionTest", "doBuildWork", " doVersionTest", "doVERSIONcheck", "doBuildcheck", " doVersioncheck", "doBuildTest", "doReleaseTest", "doReleaseCheck", " doBuildCheck", " doReleaseCheck", "doReleasecheck", " doVersionWork", " doBuildcheck", "doVERSIONTest", "doVersionTest", " doBuildTest", "doversionCheck", "doVERSIONCheck", " doReleaseTest", "doVersioncheck"], "view": ["request", "image", "client", "buffer", "accept", "self", "vis", "html", "block", "full", "display", "q", "form", "cell", "object", "layout", "comment", "use", "input", "app", "el", "e", "page", "port", "server", "cache", "ui", "http", "see", "show", "screen", "gui", "out", "change", "row", "gu", "box", "edit", "sel", "this", "model", "update", "div", "session", "can", "v", "VIEW", "views", "l", "style", "reader", "body", "View", "window", "event", "lock", "widget", "config"], "url": ["blog", "image", "client", "buffer", "service", "sl", "stream", "host", "socket", "input", "user", "bb", "server", "bel", "address", "open", "connection", "http", "hub", "URL", "resource", "path", "ob", "ssl", "file", "build", "f", "Url", "lib", "channel", "base", "zip", "loader", "log", "ll", "browser", "l", "string", "web", "uri", "source"], "in": ["buffer", "bis", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "sin", "din", "lin", "inner", "resource", "nin", "out", "ini", "con", "rin", "file", "binary", "login", "data", "b", "ins", "In", "reader", "IN", "as", "win", "source", "ac", "inc"], "bin": ["fin", "buffer", "pin", "inn", "gin", "socket", "bn", "init", "cin", "input", "ln", "bb", "abi", "sin", "din", "spin", "run", "lin", "inner", "out", "con", "kin", "file", "bi", "part", "binary", "lib", "inline", "data", "loader", "b", "log", "border", "oin", "bot", "record", "browser", "reader", "IN", "body", "nb", "lock", "win", "ruby"], "line": ["job", "ip", "lo", "lf", "block", "entry", "i", "key", "cell", "object", "el", "comment", "load", "layer", "parse", "e", "id", "page", "lc", "valid", "rule", "home", "lines", "Line", "lin", "code", "band", "message", "day", "word", "row", "file", "str", "end", "link", "ge", "part", "letter", "no", "unit", "base", "pass", "inline", "definition", "data", "pe", "model", "b", "log", "ine", "split", "LINE", "cl", "text", "name", "l", "site", "style", "string", "nl", "le", "look", "source", "up", "non"], "develBuild": ["deviousbuild", "dewardBuild", "deelBuilder", "deelRun", "deployRun", "desvenRun", "desvelRun", "deployBuilt", "desvelBuilder", "desvenbuild", "DEvelBuilder", "dewardBuilder", "deVELBuilt", "devenBuild", "deelRelease", "desvelRelease", "devenBuilt", "DEVELBuilder", "dellBuilder", "devenBuilder", "deploybuild", "dewardbuild", "DEvelBuilt", "devenRelease", "develBuilt", "devenbuild", "deVELRun", "develRun", "develbuild", "desvenBuilt", "dellRun", "deVELbuild", "deVELBuild", "deelBuild", "develBuilder", "desvenRelease", "desvelbuild", "DEvelBuild", "DEVELbuild", "deviousBuild", "deployBuild", "desvenBuild", "dellRelease", "desvenBuilder", "deVELBuilder", "DEVELBuilt", "DEVELBuild", "dewardBuilt", "devenRun", "deviousBuilt", "desvelBuilt", "dellBuild", "develRelease", "deployBuilder", "DEvelbuild", "desvelBuild"], "stableBuild": ["staticBuild", "stableBuilder", "prettyVersion", "staticBuilder", "prettybuild", "compatiblebuild", "secureBuild", "validbuild", "validBuild", "latestBuild", " stablebuild", "validBuilder", "compatibleBuilder", "latestBuilder", " stableVersion", "securebuild", "baseBuild", "prettyBuild", "stableVersion", "baseVersion", "secureBuilder", "latestbuild", "baseBuilder", "basebuild", "stablebuild", "prettyBuilder", "staticbuild", " stableBuilder", "compatibleBuild"]}}
{"id1": "947406", "id2": "8182932", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "clone", "p", "sync", "cp", "transfer", "Copy", "write", "cat", " cp", "replace", "Cop", "clip", "cop", "csv", "file", "zip", "download", "log", "paste", "put", "split", "it", " Copy", "cmp", "dump", " transfer"], "src": ["sc", "sl", "stream", "files", "rc", "use", "s", "input", "sit", "rs", "id", "sin", "sb", "loc", "source", "rb", "inst", "resource", "cur", "stab", "gb", "img", "fn", "dist", "config", "bh", "sel", "url", "data", "sq", "ins", "name", "string", "js", "href", "uri", "ource", "sub", "filename", "rob", "txt"], "dest": ["de", "obj", " Dest", "output", "delete", "class", "tmp", "comb", "opt", "thin", "const", "home", "Dest", "replace", "target", "result", "desc", "orig", "later", "img", "wd", "sup", "dist", "dir", "die", "st", "wb", "rest", "des", "temp", "flat", "done", "test", "name", "bin", "d", "prop", "folder", "destroy", "dat", "source", "txt"], "in": ["r", "m", "pin", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "cf", "din", "conn", "info", "diff", "lin", "a", "inner", "vin", "pull", "nin", "con", "ini", "rin", "kin", "work", "url", "lib", "pass", "base", "this", "login", "data", "err", "download", "b", "trans", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "issue", "source", "up", "inc"], "out": ["Out", "image", "os", "timeout", "client", "writer", "plain", "sync", "one", "off", "obj", "up", "output", "socket", "app", "init", "ou", "user", "write", "id", "ex", "aos", "cache", "conn", "or", "exp", "ext", "index", "our", "io", "inner", "exit", "nin", "pool", "img", "file", "at", "part", "x", "o", "no", "exec", "this", "lib", "data", "err", "vert", "log", "w", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "inc"], "buf": ["fab", "pad", "bp", "buffer", "bytes", "seq", "batch", "p", "bf", "ctx", "pos", "block", "br", "off", "ff", "ab", "fd", "rc", "queue", "bn", "fl", "loc", "result", "bc", "rb", "fb", "num", "orig", "ref", "cur", "buff", "raw", "count", "uc", "box", "len", "bh", "bag", "bd", "f", "feat", "data", "b", "cv", "v", "cap", "uf", "bin", "nb", "cb", "c"], "n": ["ind", "ne", "m", "j", "p", "size", "max", "i", "na", "nn", "write", "ns", "nt", "sn", "ng", "t", "N", "length", "dn", "nc", "index", "num", "nin", "z", "count", "nr", "len", "x", "en", "f", "no", "o", "k", "u", "b", "v", "w", "nd", "number", "rn", "l", "un", "d", "nb", "c"]}}
{"id1": "16590954", "id2": "4468255", "code1": "    public void createJAR(String fileString, String ext) {\n        try {\n            File file = new File(fileString);\n            int i = fileString.lastIndexOf(java.io.File.separator);\n            String dir = fileString.substring(0, i + 1);\n            if (ext.matches(\"jar\")) {\n                jarFile = new File(getClass().getClassLoader().getResource(\"jsdviewer.jar\").toURI());\n                java.io.FileOutputStream fstrm = new java.io.FileOutputStream(file);\n                FileChannel in = (new java.io.FileInputStream(jarFile)).getChannel();\n                FileChannel out = fstrm.getChannel();\n                in.transferTo(0, jarFile.length(), out);\n                in.close();\n                out.close();\n            } else {\n                file.mkdir();\n            }\n            File.umount(file);\n            File temp = new File(dir + \"document.jsd\");\n            FileOutputStream fstrm2 = new FileOutputStream(temp.getCanonicalPath());\n            ostrm = new ObjectOutputStream(fstrm2);\n            ostrm.writeObject(doc);\n            ostrm.flush();\n            ostrm.close();\n            File.umount();\n            File docFile = new File(file.getCanonicalPath() + java.io.File.separator + \"document.jsd\");\n            File.cp_p(temp, docFile);\n            File.umount();\n            temp.delete();\n            File.umount(file);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"createJAR": ["createJARS", "createAMJar", "createJPAP", "createPHAR", " createPHARS", "createJJar", "createJAP", " createJARS", " createPHAP", "createAMAR", "createAMAP", "createJPARS", " createPHJar", "createAMARS", "createPHJar", " createJAP", "createPHARS", " createJJar", "createJPAR", "createPHAP", " createPHAR", "createJPJar"], "fileString": ["loadText", "FileStr", "loadstring", " fileText", "resourceString", "FileArray", "resourceText", "modelStr", "fileFile", "baseStr", "fileStr", "fileArray", "FileStream", "fileText", "FileName", "FileText", "modelStream", " fileArray", "lineString", "FileFile", "basestring", "fileStream", "loadString", "lineArray", "linestring", " fileName", "loadName", "FileString", "modelText", "fileName", "baseFile", "resourceStream", "Filestring", "modelString", " fileStr", "baseString", "filestring", "resourceStr", "lineName", " filestring", " fileFile"], "ext": ["xt", "class", "app", "exe", "version", "ex", "Ext", "info", "ax", "format", "filename", "content", "desc", "path", "dep", "exp", "code", "EXT", "str", "dist", "end", " Ext", "url", "x", "enc", "prot", "req", "zip", "data", "type", "append", "v", "text", "name", "extra", "external", "config", "txt"], "file": ["get", "db", "buffer", "h", "full", "files", "up", "class", "socket", "queue", "use", "output", "parent", "ger", "page", "File", "cache", "per", "fe", "module", "let", "http", "resource", "path", "fp", "single", "work", "FILE", "line", "ile", "part", "build", "change", "f", "url", "binary", "unit", "base", "doc", "model", "zip", "pe", "flat", "log", "b", "local", "bar", "test", "force", "wave", "it", "name", "l", "place", "folder", "le", "jar", "source", "filename"], "i": ["ind", "ai", "ip", "j", "p", "eni", "key", "multi", "slice", "phi", "abi", "ci", "limit", "ui", "mini", "ori", "index", "li", "ii", "iu", "ini", "uni", "x", "pi", "f", "xi", "ni", "v", "mi", "it", "di", "hi", "l", "si", "yi", "qi", "uri", "I", "c"], "dir": ["domain", "db", "DIR", "src", "output", "class", "tmp", "pkg", "id", "directory", "coll", " directory", "info", "loc", "module", "filename", "format", "path", "cur", "direction", "ir", "manager", "str", "dist", "url", "prefix", "lib", "area", "base", "doc", "zip", "data", "div", "type", "rel", "Dir", "name", "string", "folder", "uri", "jar", "config"], "jarFile": ["sessionLine", "javaSourceFile", "tarLine", "sessionfile", "archiveFiles", "jarLine", "javaDir", " jarDir", "javaF", "sessionFile", "tarF", "javaFiles", "tarSourceFile", "tarfile", "reportFile", "reportF", "jarFiles", "javaFolder", "archiveFolder", "jarDir", " jarfile", "archiveFile", " jarFolder", "reportfile", "tarFile", "sessionSourceFile", " jarSourceFile", "javaFile", " jarFiles", "jarF", "jarfile", "jarSourceFile", "jarFolder", "javafile", " jarLine", "reportSourceFile", "archiveDir"], "fstrm": ["fgrm", "fstcm", "fsrum", " fsrm", "fgrcm", "fsrcm", "fsrmd", " fsrum", "fstrcm", "fgrmd", "fbrm", "FstrM", "fstum", "Fstrmd", "Fstrcm", "fstmd", "fbrM", "fstrum", "fbrcm", "Fstrm", "fgrM", " fstrcm", "Fsrmd", "Fsrcm", "fstrmd", "fsrM", "fstm", " fstrum", "Fsrm", "fbrum", "FsrM", " fsrM", " fstrM", "fstM", "fstrM", " fsrcm", "fsrm"], "in": ["r", "image", "m", "p", "pin", "sync", "n", "inn", "stream", "gin", "is", "socket", "s", "init", "input", "id", "din", "to", "conn", "or", "inner", "io", "pull", "nin", "rin", "into", "part", "inside", "min", "f", "binary", "login", "ac", "ins", "bin", "In", "l", "reader", "IN", "again", "read", "up", "c", "inc"], "out": ["Out", "image", "plain", "client", "m", "self", "writer", "sync", "off", "all", "up", "output", "flow", "init", "user", "server", "outside", "to", "conn", "plus", "group", "connection", "inner", "exp", "resource", "io", "pool", "line", "part", "this", "channel", "null", "doc", "err", "b", "v", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "c", "inc"], "temp": ["get", "fake", "db", "clean", "buffer", "template", "writer", "p", " temporary", "full", "key", " Temp", "output", "form", "tmp", "input", " tmp", "Temp", "directory", "archive", "cache", "server", "home", "or", "path", "single", "dest", "build", "storage", "store", "f", "tem", "Output", "iter", "api", "base", "doc", "unit", "porary", "zip", "emp", "local", "v", "test", "w", "controller", "it", "export", "wrap", "folder", "dump", "source", "config", "c", "pipe"], "fstrm2": ["fhrms002", "fhrms02", "fstrmr02", "fstrms0", "fstrm1", "fstrms002", "fhrms2", "fhrm002", "fstrp2", "fstrp0", "fstrmr002", "fhrm02", "fstM2", "fstm2", "fstrm02", "fstrM1", "fhrm2", "fstrM2", "fstrm0", "fstm0", "fstrM02", "fstm1", "fstrM0", "fstM1", "fstM0", "fstrms1", "fstrm002", "fhrm1", "fstrmr1", "fstrp1", "fstrM002", "fstrms02", "fstrmr2", "fhrms1", "fstrms2"], "ostrm": ["oopmr", "odrt", "istmr", "odmr", "ooprm", "istrom", "ostrem", "obsrem", "oodrt", "otherrm", "obrt", "ophmr", "ostrom", "oodrob", "obmr", "oodrm", "oscm", "obsrob", "othermr", "istrm", "odm", "ostrt", "otherrom", "oodrem", "oscrt", "oscmr", "ooprom", "istrt", "ophrm", "odrm", "obrm", "otherrt", "ostrob", "ooprt", "ophrt", "obrom", "obsrm", "obsrt", "ophm", "ostmr", "oscrm", "ostm"], "docFile": ["DocDir", "docDir", " docF", "docFiles", "documentFiles", "documentDir", "DocFiles", " docDir", "DocF", "docF", "DocFile", "documentFile", "documentF", " docFiles"]}}
{"id1": "18782385", "id2": "14450108", "code1": "    public void saveFile(MainWindow window) {\n        FileOutputStream stream = null;\n        try {\n            Document outputDoc = new Document();\n            DocType dtd = new DocType(UI, DIRECTORY + File.separator + FILE_NAME_DTD);\n            Element uiElement = new Element(UI);\n            outputDoc.setDocType(dtd);\n            outputDoc.addContent(uiElement);\n            outputDoc.setRootElement(uiElement);\n            uiElement.setAttribute(USE_DEFAULT, \"false\");\n            uiElement.setAttribute(SHOW_TOOL_BAR, Boolean.toString(window.getToolToolBar().isVisible()));\n            uiElement.setAttribute(SHOW_UNIT_BAR, Boolean.toString(window.getUnitToolBar().isVisible()));\n            String currentLFClassName = UIManager.getLookAndFeel().getClass().getName();\n            String systemLFClassName = UIManager.getSystemLookAndFeelClassName();\n            if (currentLFClassName.equals(systemLFClassName)) uiElement.setAttribute(LOOK_AND_FEEL, \"native\"); else uiElement.setAttribute(LOOK_AND_FEEL, \"default\");\n            Element mainWindowElement = new Element(MAIN_WINDOW);\n            uiElement.addContent(mainWindowElement);\n            mainWindowElement.setAttribute(LOCATION_X, Integer.toString(window.getFrame().getX()));\n            mainWindowElement.setAttribute(LOCATION_Y, Integer.toString(window.getFrame().getY()));\n            mainWindowElement.setAttribute(WIDTH, Integer.toString(window.getFrame().getWidth()));\n            mainWindowElement.setAttribute(HEIGHT, Integer.toString(window.getFrame().getHeight()));\n            Element volumeElement = new Element(VOLUME);\n            uiElement.addContent(volumeElement);\n            AudioPlayer player = window.getDesktop().getSoundPlayer();\n            volumeElement.setAttribute(SOUND, Float.toString(player.getVolume()));\n            volumeElement.setAttribute(MUTE, Boolean.toString(player.isMute()));\n            Element internalWindowsElement = new Element(INTERNAL_WINDOWS);\n            uiElement.addContent(internalWindowsElement);\n            MainDesktopPane desktop = window.getDesktop();\n            JInternalFrame[] windows = desktop.getAllFrames();\n            for (JInternalFrame window1 : windows) {\n                Element windowElement = new Element(WINDOW);\n                internalWindowsElement.addContent(windowElement);\n                windowElement.setAttribute(Z_ORDER, Integer.toString(desktop.getComponentZOrder(window1)));\n                windowElement.setAttribute(LOCATION_X, Integer.toString(window1.getX()));\n                windowElement.setAttribute(LOCATION_Y, Integer.toString(window1.getY()));\n                windowElement.setAttribute(WIDTH, Integer.toString(window1.getWidth()));\n                windowElement.setAttribute(HEIGHT, Integer.toString(window1.getHeight()));\n                windowElement.setAttribute(DISPLAY, Boolean.toString(!window1.isClosed()));\n                if (window1 instanceof ToolWindow) {\n                    windowElement.setAttribute(TYPE, TOOL);\n                    windowElement.setAttribute(NAME, ((ToolWindow) window1).getToolName());\n                } else if (window1 instanceof UnitWindow) {\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, ((UnitWindow) window1).getUnit().getName());\n                } else {\n                    windowElement.setAttribute(TYPE, \"other\");\n                    windowElement.setAttribute(NAME, \"other\");\n                }\n            }\n            Unit[] toolBarUnits = window.getUnitToolBar().getUnitsInToolBar();\n            for (Unit toolBarUnit : toolBarUnits) {\n                UnitWindow unitWindow = desktop.findUnitWindow(toolBarUnit);\n                if ((unitWindow == null) || unitWindow.isIcon()) {\n                    Element windowElement = new Element(WINDOW);\n                    internalWindowsElement.addContent(windowElement);\n                    windowElement.setAttribute(TYPE, UNIT);\n                    windowElement.setAttribute(NAME, toolBarUnit.getName());\n                    windowElement.setAttribute(DISPLAY, \"false\");\n                }\n            }\n            File configFile = new File(DIRECTORY, FILE_NAME);\n            if (!configFile.getParentFile().exists()) {\n                configFile.getParentFile().mkdirs();\n            }\n            InputStream in = getClass().getResourceAsStream(\"/dtd/ui_settings.dtd\");\n            IOUtils.copy(in, new FileOutputStream(new File(DIRECTORY, \"ui_settings.dtd\")));\n            XMLOutputter fmt = new XMLOutputter();\n            fmt.setFormat(Format.getPrettyFormat());\n            stream = new FileOutputStream(configFile);\n            OutputStreamWriter writer = new OutputStreamWriter(stream, \"UTF-8\");\n            fmt.output(outputDoc, writer);\n        } catch (Exception e) {\n            logger.log(Level.SEVERE, e.getMessage());\n        } finally {\n            IOUtils.closeQuietly(stream);\n        }\n    }\n", "code2": "    public FTPFile[] connect() {\n        if (ftpe == null) {\n            ftpe = new FTPEvent(this);\n        }\n        if (ftp == null) {\n            ftp = new FTPClient();\n        } else if (ftp.isConnected()) {\n            path = \"\";\n            try {\n                ftp.disconnect();\n            } catch (IOException e1) {\n                log.error(\"could not disconnect -\" + e1.getMessage());\n            }\n        }\n        currentDir = new FTPFile[0];\n        log.debug(\"try to connect\");\n        try {\n            int reply;\n            ftp.connect(ftpsite);\n            reply = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                ftp.disconnect();\n                log.error(\"FTP server refused connection.\");\n            }\n        } catch (IOException e) {\n            log.error(\"FTPConnection error: \" + e.getMessage());\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException f) {\n                }\n            }\n        }\n        try {\n            if (!ftp.login(user, password)) {\n                log.error(\"could not login with: \" + user);\n                ftp.logout();\n            }\n            log.debug(\"Remote system is \" + ftp.getSystemName());\n            ftp.enterLocalPassiveMode();\n            currentDir = ftp.listFiles();\n        } catch (FTPConnectionClosedException e) {\n            log.error(\"FTPConnectionClosedException: \" + e.getMessage());\n        } catch (IOException e) {\n            log.error(\"IOException: \" + e.getMessage());\n        }\n        ftpe.setType(FTPEvent.CONNECT);\n        fireFTPEvent(ftpe);\n        return currentDir;\n    }\n", "label": 0, "substitutes": {"saveFile": [" saveFiles", "saveDirectory", " saveImage", "uploadFiles", " saveDirectory", "saveImage", "uploadDirectory", "writeFile", "writeImage", "writeDirectory", "uploadImage", "writeFiles", "uploadFile", "saveFiles"], "window": [" wid", "video", "stage", "image", "flow", " Window", "parent", " host", "gallery", "target", " world", " office", "box", "space", "wa", "w", "draw", "GUI", " video", "visual", "volume", "win", "angular", "client", "widget", "console", "layout", "view", "scope", "input", "dom", "home", "band", "media", "audio", "screen", "scroll", "file", " GUI", "youtube", "feature", "motion", "microsoft", "wx", "command", "event", "button", " widget", "host", "directory", "Window", "time", " wizard", "show", " canvas", "manager", "hw", "doc", "driver", "frame", "remote", "layer", "device", "buffer", "office", "server", "ui", "game", "gui", "img", " container", "session", "system", "document", "browser", "style", "project", "menu", " dialog", "wall", "machine"], "stream": [" resource", "os", " OUT", "output", " webpage", " upload", " temp", " buffer", "io", " w", "out", "file", " bout", " console", " webcam", "f", " this", " prog", "w", " streams", "document", " video", "Stream", " app", " form", "OU"], "outputDoc": [" outputDiv", " outputDocument", "outputFile", "inputDoc", "updateDocument", "targetDocument", "externalDoc", "updateDir", "outputDir", "outputDocument", "OutputDiv", "targetDoc", "externalDocument", "updateDoc", "updateDiv", "OutputDir", "externalFile", "OutputFile", " outputFile", "inputDocument", " outputDir", "inputFile", "externalDiv", "inputDir", "OutputDocument", "targetFile", "outputDiv", "OutputDoc", "targetDiv"], "dtd": ["dTD", "fdTD", "fdtd", "std", " dTD", "sTD", "ddd", "Ddt", " ddt", "sdt", "Ddl", "fddl", "ddl", " ddd", "Dtd", "slt", "DTD", "Dlt", "Ddd", "ddt", "dlt", "fddd", " ddl", " dlt"], "uiElement": ["uiEmail", "uelement", "urielement", "uiDocument", "UIObject", "luEntity", " UIEl", "uielement", "guiE", "uiE", "ouEl", "utilEl", "uriE", "suElement", "unielement", "UIEle", "clielement", "apiEl", "UIDoc", "UIEntry", "uEl", "ioModule", "UISource", "utilDoc", "uiEntry", "uriEl", "apiEntity", "suEntity", "uriEmail", "ioDoc", "cliSource", "ouElement", "volumeEntry", "cliEl", "guiMember", "ioEl", "uniE", "uniEl", "uniMember", "guiDoc", "UIMember", "uiEditor", "guiModule", "ouEle", "guielement", "luEngine", "luEmail", "UIEl", "guiEntity", "guiElement", " UIElement", "UIModule", "UIEditor", "uriElement", "apiElement", "uriEntity", "apiE", "uniEntity", "UIDocument", "uSource", "uiDoc", "uiModule", "ioElement", "luElement", "uiEle", "uElement", "uiMember", "uriEntry", "uiEntity", "volumeDocument", "UIelement", "uriDocument", "cliElement", "UIElement", "UIE", "uiEngine", "uniElement", "uiObject", "uiSource", "volumeObject", "guiEl", "uriEngine", " UIEditor", "ouEditor", "cliEntry", " UIEle", "uiEl", "suEmail", "utilElement", "uriObject", "suEngine"], "currentLFClassName": ["currentLFClassname", "currentLFFileDesc", "currentLDFFileDesc", "currentLFclassAlias", "currentLELFCLASSName", "currentLFClassDesc", "currentLFclassPath", "currentLFCLASSDesc", "currentLFFunctionDesc", "currentLDFFileString", "currentLFclassname", "currentLDFClassDesc", "currentLFFileString", "currentLFClassPath", "currentLFclassName", "currentLFclassDesc", "currentLFclassString", "currentLDFFilename", "currentLELFCLASSDesc", "currentLFClassAlias", "currentLFClassString", "currentLDFClassString", "currentLELFCLASSPath", "currentLFFileName", "currentLDFClassName", "currentLFFilename", "currentLFFunctionName", "currentLFCLASSPath", "currentLFCLASSAlias", "currentLELFClassAlias", "currentLELFClassPath", "currentLFCLASSName", "currentLDFClassname", "currentLELFClassDesc", "currentLFFunctionPath", "currentLFFunctionAlias", "currentLDFFileName", "currentLELFCLASSAlias", "currentLELFClassName"], "systemLFClassName": ["systemLFFullName", "systemLfClassString", "systemLfClassName", "systemLFClassname", "systemLFclassString", "systemLFPackageString", "systemLFClassCode", "systemLfPackageDesc", "systemLfPackageString", "systemLFClassString", "systemLFPackagename", "systemLfPackageName", "systemLfClassDesc", "systemLFclassDesc", "systemLFPackageDesc", "systemLFClassDesc", "systemLfPackagename", "systemLFFullDesc", "systemLFPackageCode", "systemLfClassname", "systemLFPackageName", "systemLFFullString", "systemLFclassName", "systemLfPackageCode", "systemLfClassCode"], "mainWindowElement": ["mainWindowelement", "MainFrameEl", "mainQueueEl", "mainWindowsE", "mainWindowPage", "currentFramePage", "mainHostE", "mainTimeElement", "mainTimeEl", "mainWindowsEl", "mainFrameEnvironment", "mainWindowAddress", "mainFrameE", "centralWindowEl", "mainWheelEl", "mainMenuElement", "currentWindowEl", " mainWebObject", "centralFrameEl", "mainWindowEnvironment", "MainWindowEl", "currentWindowPage", "mainWheelMember", "mainWebE", "mainWebEl", " mainHostAddress", "mainWindowEl", "mainWindowsFrame", "mainStreamEl", "currentWindowElement", "mainStreamContainer", "mainFrameElement", "mainWheelElement", " mainWindowEl", "mainFlowEnvironment", "MainWindowElement", "mainTimeelement", " mainWebEnvironment", " mainWindowBuilder", "mainFlowEngine", "mainWindowObject", " mainWebEngine", "mainWindowE", "mainWindowBuilder", "mainFlowE", "mainFlowBuilder", "currentWindowContainer", " mainWheelMember", " mainWindowEngine", "mainWindowFrame", "MainFrameFrame", " mainHostE", "mainStreamElement", " mainWheelElement", "mainFlowAddress", "mainWebElement", "mainMenuContainer", "mainMenuPage", "mainFlowObject", "mainWindowsElement", "currentFrameContainer", "centralFrameelement", "mainWebBuilder", "mainFrameEl", " mainHostElement", "mainWebMember", "mainQueueFrame", "mainWebEngine", "mainScreenEl", "mainScreenelement", "centralFrameElement", "mainFrameMember", " mainWheelEl", "mainGroupEnvironment", "mainFramePage", "MainFrameElement", "mainFrameFrame", "mainWebAddress", "mainFrameContainer", "mainFlowElement", " mainWindowMember", " mainWindowObject", "mainWindowEngine", "centralWindowelement", "mainWindowContainer", "mainScreenElement", "MainFrameE", " mainWindowEnvironment", "mainStreamPage", "mainFrameelement", " mainWheelEnvironment", " mainWindowE", " mainWebElement", "mainWheelEnvironment", " mainWindowAddress", "MainWindowE", "mainQueueElement", "centralWindowElement", "mainGroupObject", "mainQueueE", "currentFrameEl", "mainWebObject", " mainHostBuilder", "mainWindowMember", "MainWindowFrame", "mainMenuEl", "mainHostAddress", "mainGroupEngine", "mainHostElement", "mainGroupElement", "mainHostBuilder", "mainWebEnvironment", "currentFrameElement"], "volumeElement": [" volumeEl", "VolumeContainer", "audioEntry", "VolumeEl", "soundElement", "VolumeElement", " volumeEngine", "volumeContainer", "VolumeEntry", "volumePart", "audioEl", " volumelement", "voiceContainer", "voiceEntry", "audioPart", " volumeEntry", "soundPart", "soundlement", " volumeLayer", "voiceLayer", "audioEngine", "voiceElement", "voiceEngine", "volumeLayer", " volumePart", "soundEl", "audioElement", "voiceEl", "audiolement", "volumelement", "audioLayer", " volumeContainer", "volumeEntry", "volumeEngine", "volumeEl"], "player": ["video", "position", "db", "aster", "caster", "profile", "apper", "players", "transfer", "par", "app", "roller", "plays", "ader", "ayer", "e", "monitor", "handler", "per", "ler", "ater", "playing", "game", "Player", "audio", "file", "part", "min", "active", "ower", "loader", "er", "live", "mor", "driver", "Play", "ser", "watch", "act", "play", " Player", "layer", "able"]}}
{"id1": "6379126", "id2": "5551393", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public static byte[] getMD5(String source) {\n        byte[] tmp = null;\n        try {\n            java.security.MessageDigest md = java.security.MessageDigest.getInstance(\"MD5\");\n            md.update(source.getBytes());\n            tmp = md.digest();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return tmp;\n    }\n", "label": 0, "substitutes": {"gerarTutorialPage": ["riarTinyPage", "riarTinyDir", "riartourpage", "riarTourDir", "riarTutorialElement", "riartutorialPage", "riarTutorialDir", "riarTourElement", "riarTravispage", "riartutorialDir", "riarTinypage", "riarTinyElement", "riarTourPage", "riarTutorialPage", "riarTravisElement", "riartourElement", "riarTravisPage", "riartutorialElement", "riarTourpage", "riartutorialpage", "riarTutorialpage", "riartourPage", "riartourDir", "riarTravisDir"], "indexDir": ["IndexTier", "includeJar", "zipJar", "indexJar", "includeTier", "zipTier", "IndexDir", "zipDir", "zipDIR", "IndexDIR", "includeDir", "indexDIR", "indexTier", "includeDIR", "IndexJar"], "cssDir": ["catsDoc", "javascriptDir", "CSSLen", "ssUrl", "fontDIR", "fontDir", "cssDIR", "piecesDie", "cssDie", "ssD", "CSSDir", "catsDir", "javascriptDb", "CSSDirectory", "javascriptDar", "ssDIR", "CSSDar", "gzDir", "cssDb", "fontD", "cssD", "CSSDIR", "codesDoc", "javascriptDIR", "CSSDb", "ssDir", "cssDar", "codesDir", "catsLen", "piecesD", "ssDb", "gzDIR", "CSSDoc", "cssLen", "cssDirectory", "fontDie", "gzDirectory", "gzUrl", "piecesDir", "ssDar", "codesLen", "ssDie", "CSSUrl", "ssDirectory", "cssDoc", "cssUrl", "piecesDIR"], "capDir": ["capdir", "CapVol", "capDirectory", "casDir", "casdir", "Capdir", "CapDirectory", "casVol", "apsDir", "apsdir", "casDirectory", "apsVol", "CapDir", "capVol", "apsDirectory"], "licDir": ["volDoc", "lifManager", "lifDir", "libManager", "licManager", "libDoc", "lifDoc", "voldir", "volDir", "licdir", "volManager", "lifdir", "licDoc", "libdir", "libDir"], "midDir": ["middir", "casDir", "limTier", "mindDir", "limDir", "midTier", "casDIR", "casdir", "limDIR", "casTier", "mindTier", "mindDIR", "minddir", "midDIR", "limdir"], "filesDir": ["ballsPos", "ballsVol", "filesFolder", "pagesVol", "ballsDir", "pagesPos", "stylesDir", "FilesDir", "filesVol", "videosFile", "videosFolder", "imagesFile", " filesVol", "filesDur", "opensDIR", "stylesDirectory", "stylesDIR", "videosDirectory", "filesPos", "filesDirectory", "opensDirectory", "filesDIR", "opensDur", "stylesDur", "locksDirectory", "imagesDir", "locksDIR", "imagesDirectory", " filesPos", "FilesFolder", "FilesDirectory", "pagesDir", "imagesFolder", "FilesFile", "opensDir", "filesFile", "locksDir", "locksDur"], "videosDir": ["viewsUrl", "videosDb", "videoUrl", "videoFile", " videosDb", " videosDirectory", "videosFile", "viewsDir", "viewsDirectory", "videosDirectory", "viewsFile", "imagesDir", " videosFile", "videoDb", " videosUrl", "imagesDb", "videosUrl", "videoDirectory", "videoDir"], "imagensDir": ["imgentsFile", " imagensDirectory", " imagersDirectory", "imagentsFile", "imagenciesDir", "imgensDir", " imagensFile", " imagersFile", "imgensDirectory", "imagersDirectory", "imgentsDirectory", "imgentsDIR", " imagersJar", "imagentsJar", "imgentsDir", "imagersDIR", "imagenJar", "imagenFile", "imagensDirectory", "imagersDir", " imagersDir", "imagenciesDirectory", "imgensFile", "imgensDIR", "imagensDIR", "imagenDirectory", "imagenciesDIR", "imagenciesFile", "imagensJar", "imagersJar", "imagenDir", " imagensJar", "imagersFile", "imagentsDir", "imagentsDIR", "imagentsDirectory", "imagensFile"], "local": ["request", "where", "localhost", "shared", "p", "upload", "same", "defined", "tmp", "global", "user", "basic", "managed", "internal", "serial", "pal", "input", "directory", "valid", "json", "home", "loc", "relative", "state", "location", "safe", "path", "inner", "standard", "http", "conf", "file", "available", "part", "dir", "util", "active", "Location", "prefix", "pass", "base", "Local", "data", "temp", "LOC", "log", "partial", "personal", "total", "name", "l", "small", "specified", "d", " Local", "remote", "present", "lock", "current", "back", "self", "initial", "username"], "srcCss1": ["srcRcss0", "srcCpe4", "srcCrss1", "srcCss11", "srcCrss3", "srcRss2", "srcPss81", "srcRss0", "srcCcss0", "srcPcss1", "srcPssPre", "srcCss81", "srcRss1", "srcCse1", "srcCcss1", "srcRcss2", "srcCrss2", "srcPss1", "srcCass2", "srcCass0", "srcCcssPre", "srcPcss2", "srcPcss3", "srcCpe1", "srcPcssPre", "srcCpe2", "srcCcss81", "srcCpePre", "srcRcss11", "srcCass1", "srcCssPre", "srcRss81", "srcRss11", "srcCfg1", "srcCass3", "srcCrss11", "srcCcss3", "srcRcss81", "srcPcss4", "srcCse2", "srcPss3", "srcCcss4", "srcRcss1", "srcPcss81", "srcCcss2", "srcCse11", "srcCfg4", "srcCass81", "srcCcss11", "srcCrss81", "srcCass11", "srcCse0", "srcCss0", "srcCfg2", "srcPss4", "srcPss2", "srcCfgPre"], "destCss1": ["destCass1", "destPcss3", "destPssCard", "destCcss3", "destCfg3", "destPcss81", "destPss2", "destCss0", "destCrss81", "destCxxCard", "destPcss1", "destCxx1", "destCass81", "destCass3", "destCss81", "destCssCard", "destPss0", "destCcss2", "destCcss1", "destCcssCard", "destCfg1", "destPcss2", "destCass2", "destCrss1", "destCcss0", "destCfg0", "destCassCard", "destCrss0", "destCfg2", "destCrss2", "destPcssCard", "destCxx3", "destPss1", "destCrss3", "destPss3", "destPcss0", "destCxx2", "destCcss81", "destPss81"], "srcCss2": ["srcCcssL", "srcCass52", "srcCrssL", "srcCssTwo", "srcCrss1", "srcChessTwo", "srcCssB", "srcCrss3", "srcCss27", "srcChess1", "srcUcssTwo", "srcCfgL", "srcCng27", "srcCross4", "srcPss27", "srcChessB", "srcAcss2", "srcPcss1", "srcUssTwo", "srcCross1", "srcCrss2", "srcCcss1", "srcPss1", "srcUcss1", "srcCass2", "srcUcssB", "srcAccss2", "srcAccss52", "srcPcss27", "srcCross2", "srcPcss2", "srcPcss3", "srcCng1", "srcCng2", "srcCass1", "srcPssL", "srcCcss27", "srcUcss2", "srcChess2", "srcCfg1", "srcAcss4", "srcPcssL", "srcCcss3", "srcPss3", "srcCcss4", "srcCcss52", "srcCssL", "srcCcssB", "srcCfg3", "srcCfgB", "srcAccss1", "srcCass4", "srcCcss2", "srcCcssTwo", "srcUss1", "srcUss2", "srcAcss52", "srcCfgTwo", "srcCss52", "srcUssB", "srcAccss4", "srcCross52", "srcCrss27", "srcAcss1", "srcCfg2", "srcPss2"], "destCss2": ["destCess1", "destCfg3", "destCcss72", "destCcss3", "destNcss32", "destNcss2", "destNss1", "destCess32", "destCest2", "destCcss4", "destCcssB", "destCess4", "destNcss3", "destNcssB", "destNss2", "destNss32", "destCcss32", "destCfg32", "destNss4", "destCest3", "destCcss2", "destCcss1", "destNssB", "destNcss4", "destCfg1", "destNss72", "destCess72", "destCfgB", "destCfg4", "destNss3", "destCess2", "destCestB", "destCssB", "destCfg2", "destNcss72", "destCfg72", "destCest1", "destCss32", "destNcss1", "destCss72"], "srcCss3": ["srcRss2", "srcCsh183", "srcScss3", "srcCsl183", "srcRss1", "srcScstyle93", "srcCssThird", "srcCstyle6", "srcScstyle2", "srcCsh2", "srcCcss4", "srcCstyleAND", "srcPss6", "srcCstyle15", "srcCstyle93", "srcCfg2", "srcCcss93", "srcCss15", "srcCssAND", "srcCsl3", "srcCstyle3", "srcCss183", "srcCass2", "srcRcss3", "srcCcss15", "srcCrss6", "srcRss3", "srcCass1", "srcCfg1", "srcCcss3", "srcPss3", "srcClass3", "srcRcss1", "srcCss93", "srcPcss6", "srcCass4", "srcCcssThird", "srcCrss3", "srcScstyle3", "srcCstyle2", "srcCcss6", "srcClass2", "srcRcss183", "srcClass15", "srcPcss2", "srcPssAND", "srcCrssAND", "srcClass93", "srcCass3", "srcRssThird", "srcCslThird", "srcCsh3", "srcRss183", "srcCsl2", "srcRcss4", "srcCfg3", "srcCfg4", "srcRss4", "srcRcssThird", "srcPcss3", "srcScss93", "srcCcss183", "srcCrss2", "srcRcss2", "srcCcss1", "srcScss15", "srcPcssAND", "srcCcssAND", "srcScss2", "srcCshThird", "srcScstyle15", "srcCcss2", "srcPss2"], "destCss3": ["destPcss3", "destCcss3", "destCross3", "destNcss2", "destCstyle2", "destScss183", "destCstyle03", "destCja6", "destPss2", "destScss3", "destCrss183", "destCss43", "destCross03", "destCstyle53", "destCstyle43", "destCross53", "destNcss3", "destScrss2", "destCrss6", "destNss2", "destNss43", "destScrss6", "destCass3", "destNcss43", "destCss53", "destScss6", "destCja3", "destPcss53", "destPcss03", "destCcss2", "destScrss3", "destCstyle3", "destPcss2", "destCass2", "destCss03", "destPss53", "destScrss183", "destCss183", "destNss3", "destCja183", "destScss2", "destCja2", "destCrss2", "destCcss6", "destCross2", "destCrss3", "destPss3", "destCcss183", "destPss03", "destCcss53", "destCcss03", "destCcss43", "destCass43"], "srcCss4": ["srcCrss1", "srcPcss1", "srcPssFour", "srcCrss2", "srcCcss1", "srcPss1", "srcCass2", "srcPcss2", "srcCass1", "srcCssFour", "srcCassFour", "srcCrss4", "srcCrssFour", "srcCcssFour", "srcPcss4", "srcCcss4", "srcPcssFour", "srcCcss2", "srcCass4", "srcPss4", "srcPss2"]}}
{"id1": "8667872", "id2": "3536332", "code1": "    public static final synchronized String hash(String data) {\n        if (digest == null) {\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException nsae) {\n                System.err.println(\"Failed to load the MD5 MessageDigest. \" + \"unable to function normally.\");\n                nsae.printStackTrace();\n            }\n        }\n        digest.update(data.getBytes());\n        return encodeHex(digest.digest());\n    }\n", "code2": "    private String digest(String input) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[64];\n        md.update(input.getBytes(\"iso-8859-1\"), 0, input.length());\n        md5hash = md.digest();\n        return this.convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"hash": ["component", "h", " hashing", "print", "write", "copy", " sum", "code", "sum", " decipher", " Hash", "Hash", "build", "str", " fingerprint", "SHA", " hashes", "update", "text", "string", "add", "gen", "dump", "hex"], "data": ["image", "buffer", "bytes", "size", "alpha", "key", "output", "input", "picture", "json", "cache", "address", "info", "result", "padding", "format", "media", "content", "response", "message", "a", "connection", "value", "str", "storage", "this", "base", "dump", "database", "text", "name", "memory", "body", "string", "DATA", "reader", "dat", "source", "length", "hex"], "digest": ["signest", "hedester", " digger", "Digse", "DigEST", "digger", "signEST", "diger", "digse", "Diger", " digEST", "bigester", "signse", "hedge", "Digest", " digge", "Digge", "Digger", " digit", "signit", " diger", "digit", "Digester", " digester", "digge", "hedest", " digse", "digester", "digEST", "hedger", "decit", "decest", "bigger", "signer", "decester", "decEST", "bigest", "signester", "bigse"]}}
{"id1": "17630906", "id2": "8069594", "code1": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        if (in.getCanonicalPath().equals(out.getCanonicalPath())) {\n            return;\n        }\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) {\n                inChannel.close();\n            }\n            if (outChannel != null) {\n                outChannel.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"sortAscending": ["sortAascEND", "sortUscending", "sortAscend", "sortUascending", "sortUascend", "sortASCEND", "sortAascend", "sortAescEND", "sortAascending", "sortAscender", "sortASCender", "sortAascender", "sortUascender", "sortUascEND", "sortAescend", "sortAscEND", "sortUscender", "sortAescending", "sortASCending", "sortASCend", "sortAescender", "sortUscend", "sortUscEND"], "input": ["request", "image", "error", "in", "position", "accept", "progress", "batch", "element", "alpha", "argument", "stream", "entry", "up", "output", "form", "view", "object", "load", "context", "flow", "dict", "version", "instance", "feed", "parent", "select", "address", "integer", "inf", "result", "format", "target", "array", "index", "audio", "pull", "single", "xml", "img", "raw", "value", "out", "now", "work", "key", "area", "null", "model", "update", "data", "type", "Input", "text", "table", "string", "list", "sample", "filter", "field", "event", "current", "source", "config", "initial"], "order": ["request", "position", "process", "image", "error", "sort", "attr", "element", "block", "asc", "key", "output", "use", "app", "map", "default", "user", "Order", "instance", "rank", "parent", "enter", "page", "reverse", "after", "version", "rule", "e", "address", "info", "group", "ordering", "result", "code", "array", "grade", "index", "only", "work", "date", "count", "now", "root", "end", "ordered", "class", "type", "are", "err", "comment", "er", "test", "orders", "force", "search", "record", "call", "name", "table", "style", "list", "seed", "event", "sign", "move"], "i": ["ind", "ai", "ip", "m", "h", "p", "ie", "n", "ik", "is", "key", "fi", "ix", "J", "e", "phi", "ci", "gi", "jit", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "ij", "bi", "start", "x", "pi", "f", "iter", "o", "xi", "api", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "di", "l", "si", "qi", "uri", "I"], "j": ["job", "fr", "m", " dj", "oj", "p", "n", "g", "br", "obj", "q", "key", "ie", "uj", "J", "jen", "ix", "e", "section", "jit", "json", "aj", "ui", "adj", "jj", "ja", "dj", "li", "ii", "jl", "z", "bj", "ij", "x", "f", "o", "k", "jp", "u", "b", "y", "v", "ji", "jc", "je", "l", "d", "js", "si", "jet", "qi", "kj", "jo"], "mem": ["dim", "ind", "image", "ip", "mm", "mo", "m", "max", "dem", "lim", "nt", "md", "ui", "info", "um", "ram", "mini", "sum", "Mem", "ref", "num", "mb", "buff", "pool", "img", "value", "count", "dist", "part", "fun", "len", "cpu", "mind", "data", "mi", "mor", "mp", "memory", "name", "dev", "vm"], "id": ["ind", "ip", "in", "max", "n", "key", "is", "init", "kind", "oid", "Id", "mid", "ID", "info", "code", "a", "index", "num", "ref", "z", "count", "end", "x", "start", "uid", "area", "base", "sid", "data", "type", "b", "offset", "ids", "name", "d", "pid", "kid"]}}
{"id1": "14820302", "id2": "3756429", "code1": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"innerProcess": ["binaryprocess", "subWrite", "subProcess", "binaryConnect", "subConnect", " innerConnect", " innerprocess", " innerWrite", "binaryProcess", "subprocess", "innerWrite", "innerprocess", "innerConnect", "binaryWrite"], "curi": [" curl", "pURI", "curl", "ciri", "pri", "Curl", "Ciri", "cURI", "lURI", " capi", " cri", "fui", "lcri", " cURI", "fri", "lcURI", "cgui", "lurl", " cgui", "capi", "furi", "Cgui", "Curi", "lciri", "cui", " cunit", "Capi", "fURI", "firi", "lcgui", "CURI", "Cunit", "lcui", " cui", "papi", "lcuri", "lri", "puri", "Cui", "luri", "cri", "cunit", "lcunit", "Cri"], "regexpr": ["prenexer", "RenexPR", "renexpre", "Renexp", "recreer", "renexpl", "rerepl", "regexr", "regexPR", "rerupr", "Regexpr", "prenexp", "regexper", "regnexpl", "relexp", "relexPR", "regnexpr", "relexpr", "reggexr", "relexpre", "reggexper", "Regexp", "rerup", "renexr", "rerepr", "Renexpre", "recepr", "pregexpl", "rereper", "recrepr", "recrep", "regnexper", "recrepre", "regexpre", "renexpr", "regexp", "reggexpl", "RegexPR", "regnexr", "pregexer", "renexer", "rerupl", "Regexpre", "recrePR", "reruer", "renexp", "pregexpr", "reggexpr", "Renexpr", "regexer", "prenexpl", "recrepl", "recer", "renexper", "rerer", "regexpl", "receper", "pregexp", "renexPR", "recepl", "prenexpr"], "cs": ["os", "sc", "ca", "details", "cas", "sync", "cus", "ctx", "qs", "cp", "ce", "cers", "cc", "bs", "rc", "cells", "cn", "rs", "ls", "cr", "ns", "cons", "lc", "ci", "cf", "css", "cache", "coll", "es", "conn", "CS", "ks", "cases", "bc", "cos", "ios", "cm", "codes", "ches", "ds", "cks", "tc", "wcs", "fs", "icks", "ac", "ars", "spec", "ces", "ced", "pc", "ins", "acts", "vs", "cer", "acks", "ss", "ics", "acs", "js", "ps", "gs", "ms", "cms", "Cs", "cing", "cb", "c", "ec"], "digest": ["hashester", " digested", "signest", " digger", "signests", "igested", "igity", "Digity", "logger", "Digit", "signgest", "digger", "digcher", " digcher", " digests", "digity", "signEST", "diggest", "diger", "hashger", "digests", "Diger", " digEST", "signger", "Digest", "logest", " digit", "Digger", "Digcher", "logester", "biggest", " diger", "bigests", "digit", "Digester", " digester", "hashest", "digester", "digEST", "bigEST", "igester", " diggest", " digity", "signer", "digested", "igest", "bigest", "logit", "Digested", "signested", "hashcher", "signester"], "s": ["S", "r", "su", "os", "h", "p", "bytes", "sl", "sync", "n", "g", "is", "bs", "strings", "rs", "ls", "e", "ns", "ses", "t", "sb", "address", "obs", "sum", "services", "sym", "states", "ds", "str", "abs", "f", "binary", "o", "sets", "data", "u", "ans", "b", "v", "groups", "settings", "l", "ss", "string", "js", "si", "ps", "ms", "gs", "ws", "c"], "m": ["mm", "r", "mo", "match", "p", "man", "map", "e", "om", "M", "fm", "bm", "rm", "cm", "nm", "mr", "ym", "sm", "imm", "dm", "v", "pm", "mi", "tm", "me", "mc", "gm", "string", "ms", "am", "machine", "vm", "c", "hm", "wm"], "newDigestValue": ["newDigestedVal", "newSignestedString", "newDigeterValue", "newDigESTKey", "newSignestedKey", "newDigESTValue", "newDigestedString", "newDigestVal", "newDigeterKey", "newSignestedValues", "newDigestedValue", "newDigesterString", "newDigesterValues", "newSignestKey", "newDigesterValue", "newDigestValues", "newDigesterVal", "newDigeterString", "newDigeterVal", "newDigesterKey", "newDigESTValues", "newDigESTString", "newDigestedKey", "newSignestString", "newSignestValues", "newDigestedValues", "newDigestKey", "newSignestedValue", "newSignestValue", "newDigestString"]}}
{"id1": "8983517", "id2": "11562165", "code1": "    public User getUser(String userlogin) {\n        UserDAO userDAO = new UserDAO();\n        User user = null;\n        try {\n            user = userDAO.load(userlogin);\n            if (user == null) {\n                URL url = Thread.currentThread().getContextClassLoader().getResource(\"users.cfg\");\n                BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                String linea = br.readLine();\n                while (linea != null) {\n                    StringTokenizer st = new StringTokenizer(linea, \":\");\n                    if (st.countTokens() == 3) {\n                        String login = st.nextToken();\n                        String password = st.nextToken();\n                        String profile = st.nextToken();\n                        if (login.equals(userlogin)) {\n                            user = new User(login, password, profile);\n                            userDAO.save(user);\n                        }\n                    } else {\n                    }\n                    linea = br.readLine();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return user;\n    }\n", "code2": "    private void streamContains(String in, InputStream stream) throws IOException {\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        IOUtils.copy(stream, baos);\n        byte[] bytes = baos.toByteArray();\n        String cmp = new String(bytes, \"UTF-8\");\n        assertTrue(cmp.contains(in));\n        baos.close();\n    }\n", "label": 0, "substitutes": {"getUser": ["createUsers", "readUser", "newUsers", "readuser", "getuser", "createuser", "newCustomer", "readCustomer", "getUsers", "newUser", "createUser", "createCustomer", "newuser", "readUsers", "getCustomer"], "userlogin": ["customlogin", "courselogin", "userline", "customuser", "verusername", "pluginpassword", "pluginlogin", " userauth", " useruser", " userusername", "bugLogin", "bugline", "useruser", "userauth", "buglogin", "userLogin", "uselogin", "useline", "verpassword", "pluginusername", "useusername", "vername", "courseuser", "userpassword", "courseauth", " userline", "coursepassword", "useLogin", " username", " userLogin", "customauth", "bugusername", "verlogin", "userusername", "pluginname", "custompassword", " userpassword", "username"], "userDAO": ["userDAOB", "userDSOO", "userRAOO", "userMAB", "userDKo", " userRAO", "userDSo", " userRAB", " userDAB", "userDSB", "userDKB", "usernameDSB", " userRAOO", "usernameDAO", "UserDAOO", "userAB", "userTAO", "usernameDSO", "userDAOs", "UserMAO", " userDAOO", "userDAo", "userMAOO", " userDAOB", "userRAOB", "userAOB", "UserMAOs", "UserDAOs", "userAO", "usernameDAo", "userMAO", "userDSOB", "usernameDSo", "UserDAOB", "usernameDSOB", "userDSOs", "usernameDAB", "userRAB", "userDAOO", " userRAOB", "userDKO", "userMAOB", "userTAB", "UserMAOB", "userRAO", "userTAOB", "userDAB", "userDKOB", "UserDAO", "userDSO", "userMAOs", "userTAOO", "UserMAOO", "userAo", "usernameDAOB"], "user": ["author", "key", "comment", "dict", "parent", "info", "ver", "str", "config", "u", "er", "v", "name", "facebook", "usr", "sp", "blog", "db", "creator", "one", "html", "full", "USER", "bug", "page", "cache", "rule", "home", "state", "response", "io", "users", "plugin", "usa", "lock", "account", "job", "service", "class", "object", "use", "e", "per", "um", "result", "manager", "log", "auth", "item", "person", "up", "claim", "match", "User", "default", "ou", "ee", "po", "oo", "group", "or", "resource", "uc", "model", "session", "data", "type", "record", "other", "me", "member", "current", "who", "username"], "url": ["lr", "blog", "r", "fr", "sl", "stream", "src", "host", "feed", "fl", "server", "coll", "address", "bel", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "str", "Url", "channel", "base", "plug", "gl", "loader", "b", "rel", "org", "l", "browser", "string", "href", "ur", "uri", "orb", "source", "account"], "br": ["lr", "r", "db", "fr", "buffer", "HR", "ner", "sl", "bf", "stream", "src", "bt", "bb", "cr", "ler", "result", "dr", "bc", "rb", "bl", "fb", "bm", "ref", "ber", "Br", "bro", "rr", "img", "str", "bh", "hr", "bd", "mr", "sr", "buf", "ch", "err", "b", "bar", "rt", "BR", "brush", "arr", "yr", "bed", "vr", "browser", "reader", "body", "tr", "jar", "cb", "sp"], "linea": ["LINEp", " linean", "frameaa", " lineas", " lineva", "linkA", "lina", "linep", "sea", "lineva", " lineaf", "seas", "linesa", "framea", " linesa", "lineea", "linA", "linean", "linan", "LINEsa", "LINEas", "linsa", "linas", " linep", "linaf", "sean", "linva", "frameas", "frameA", " lineea", "linkaf", "lineas", " lineA", "linaa", "seea", " lineaa", "LINEa", "linka", "linp", "linkva", "lineA", "lineaa", "lineaf"], "st": ["STR", "ST", "sts", "sc", "fr", "sl", "ast", "St", "rd", "ste", "s", "std", "lt", "sa", "sn", "ft", "stri", "t", "ist", "stack", "sb", "sf", "sh", "fe", "bl", "be", "se", "td", "sta", "str", "start", "est", "sm", "set", "rest", "b", "rt", "trans", "cl", "nd", "mt", "ct", "l", "ost", "d", "string", "ld", "sth", "sv", "ser", "first", "pt", "sp"], "login": ["blog", "email", "service", "pin", "stat", "gin", "display", "phone", "summary", "layout", "username", "title", "photo", "id", "picture", "home", "register", "alias", "connection", "resource", "Login", "line", "config", "pass", "security", "license", "log", "token", "secret", "status", "joined", "name", "auth", "company", "site", "plugin", "string", "facebook", "lock", "join", "mobile", "filename", "inc", "account"], "password": ["account", "pad", "email", "service", "access", "fax", "phone", "pattern", "sword", "picture", "mask", "phrase", "alias", "padding", "Password", "resource", "screen", "PASS", "wd", "pass", "security", "money", "session", "token", "secret", "sha", "database", "name", "auth", "style", "string", "sudo", "config", "username"], "profile": ["account", "email", "prof", "phone", "summary", "class", "key", "theme", "title", "Profile", "photo", "picture", "option", "family", "alias", "module", "property", "pocket", "file", "money", "pass", "platform", "person", "type", "secret", "role", "company", "settings", "name", "site", "style", "mobile", "filename", "username"]}}
{"id1": "14168494", "id2": "7911686", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static void copyFile(File source, File destination) throws IOException {\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(destination).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copiedfile", "transferfile", " copiedClass", "copyClass", " copiedFiles", " copiedFile", "copyFiles", "copyfile", "transferFile", "transferFiles", " copyClass", "transferClass"], "dest": [" Dest", "obj", "output", "class", "transfer", "tmp", "comb", "Dest", "loc", "target", "desc", "path", "resource", "orig", "later", "out", "file", "sup", "dist", "dir", "st", "null", "this", "wb", "data", "temp", "done", "name", " destination", "true", "d", "destroy", "source", "txt"], "src": ["sc", "sl", "upload", "sync", "stream", "master", "rc", "tmp", "s", "sit", "slice", "copy", "sin", "sb", "cb", "Dest", "loc", "source", "target", "rb", "inst", "ssl", "img", "gb", "sup", "ds", "dist", "file", "storage", "config", "sel", "url", "st", "download", "sq", "split", "bin", "sub", "filename", "rob"], "srcChannel": ["srcCh", "srcChan", "sourceChan", "distChannel", " srcchannel", " srcChan", "rcChannel", "inputChannel", "destChan", "srcchannel", "distCh", "srcConnection", " srcButton", " srcStream", "rcButton", "rcCh", "rcSection", "distChan", "distStream", "rcchannel", "srcSection", "inputConnection", "inputchannel", "srcStream", " srcCh", "rcConnection", "inputSection", "rcChan", " srcSection", "rcStream", "destChannel", "sourceChannel", "srcButton", "destchannel", "sourceButton", " srcConnection", "destConnection", "sourcechannel"], "dstChannel": ["dstVideo", " dstContext", "dstschannel", "DdestChannel", " dstStream", "dstContext", " dstsStream", "drcChan", "dstStream", "ddestStream", "ddestVideo", "dDestchannel", "Ddestchannel", " drdChannel", "dDestChannel", "dDestStream", "ddestChannel", "Dstchannel", " dstChan", "drcChannel", " dstConnection", " dstschannel", "dstConnection", " drdContext", "dstsConnection", "drdContext", " dstsConnection", "DstChannel", "DdestVideo", "drdchannel", " dstchannel", "dstsChannel", " drdchannel", " drdChan", "dsrcChannel", "dsrcVideo", "dstChan", "DstVideo", "drcContext", "dstsStream", "drdChan", "drdChannel", "drcchannel", "ddestchannel", "drcVideo", "ddestChan", " dstsChannel", "ddestConnection", "ddestContext", "dsrcchannel", "dstchannel", "dDestConnection"]}}
{"id1": "23666973", "id2": "21152728", "code1": "    private InputStream openStreamRaw(String filename) {\n        InputStream stream = null;\n        if (filename == null) return null;\n        if (filename.length() == 0) {\n            return null;\n        }\n        try {\n            URL url = new URL(filename);\n            stream = url.openStream();\n            return stream;\n        } catch (MalformedURLException mfue) {\n        } catch (FileNotFoundException fnfe) {\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        ClassLoader cl = getClass().getClassLoader();\n        stream = cl.getResourceAsStream(\"data/\" + filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        stream = cl.getResourceAsStream(filename);\n        if (stream != null) {\n            String cn = stream.getClass().getName();\n            if (!cn.equals(\"sun.plugin.cache.EmptyInputStream\")) {\n                return stream;\n            }\n        }\n        return stream;\n    }\n", "code2": "    private boolean authenticate(Module module) throws Exception {\n        SecureRandom rand = SecureRandom.getInstance(\"SHA1PRNG\");\n        rand.setSeed(System.currentTimeMillis());\n        byte[] challenge = new byte[16];\n        rand.nextBytes(challenge);\n        String b64 = Util.base64(challenge);\n        Util.writeASCII(out, RSYNCD_AUTHREQD + b64 + \"\\n\");\n        String reply = Util.readLine(in);\n        if (reply.indexOf(\" \") < 0) {\n            Util.writeASCII(out, AT_ERROR + \": bad response\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"bad response\");\n        }\n        String user = reply.substring(0, reply.indexOf(\" \"));\n        String response = reply.substring(reply.indexOf(\" \") + 1);\n        if (!module.users.contains(user)) {\n            Util.writeASCII(out, AT_ERROR + \": user \" + user + \" not allowed\\n\");\n            if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n            socket.close();\n            throw new IOException(\"user \" + user + \" not allowed\");\n        }\n        LineNumberReader secrets = new LineNumberReader(new FileReader(module.secretsFile));\n        MessageDigest md4 = MessageDigest.getInstance(\"BrokenMD4\");\n        String line;\n        while ((line = secrets.readLine()) != null) {\n            if (line.startsWith(user + \":\")) {\n                String passwd = line.substring(line.lastIndexOf(\":\") + 1);\n                md4.update(new byte[4]);\n                md4.update(passwd.getBytes(\"US-ASCII\"));\n                md4.update(b64.getBytes(\"US-ASCII\"));\n                String hash = Util.base64(md4.digest());\n                if (hash.equals(response)) {\n                    secrets.close();\n                    return true;\n                } else {\n                    Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n                    if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n                    socket.close();\n                    secrets.close();\n                    logger.error(\"auth failed on module \" + module.name);\n                    return false;\n                }\n            }\n        }\n        Util.writeASCII(out, AT_ERROR + \": auth failed on module \" + module.name + \"\\n\");\n        if (remoteVersion < 25) Util.writeASCII(out, RSYNCD_EXIT + \"\\n\");\n        socket.close();\n        secrets.close();\n        logger.error(\"auth failed on module \" + module.name);\n        return false;\n    }\n", "label": 0, "substitutes": {"openStreamRaw": ["openFileSource", "openStreamAsync", "createSteamRaw", "openStreamInternal", "openSteamAsync", "openstreamInternal", "openStreamSource", "openSteamSource", "createStreamRaw", "openstreamRaw", "createSteamAsync", "openSteamInternal", "createSteamSource", "openFileRaw", "createStreamInternal", "openFileAsync", "openstreamAsync", "openFileInternal", "openstreamSource", "createStreamAsync", "createStreamSource", "createSteamInternal", "openSteamRaw"], "filename": ["actual", "ppa", "lua", "size", "Filename", "txt", "n", "fax", "jpg", "rl", "src", "class", "fd", "title", "il", "directory", "phrase", "sf", "location", "path", "resource", "fp", "word", "acl", "fn", "FILE", "file", "which", "kn", "f", "prefix", "sql", "nil", "login", "data", "license", "download", "loader", "wl", "fil", "undle", "database", "subject", "kl", "SourceFile", "name", "l", "password", "sound", "string", "ename", "href", "utf", "uri", "journal", "source", "length", "dll", "username"], "stream": ["video", "stage", "image", "size", "sync", "upload", "ream", "impl", "through", "parent", "open", "content", "http", "raw", "value", "wrapper", "trans", "w", "continue", "Stream", "body", "string", "reader", "steam", "iv", "draft", "back", "length", "clean", "client", "sw", "sl", "full", "view", "feed", "load", "input", "stack", "response", "path", "message", "pool", "thread", "file", "live", "event", "host", "output", "form", "object", "class", "context", "slice", "bb", "core", "port", "valid", "child", "result", "cur", "hook", "pull", "pair", "ssl", "row", "enc", "channel", "null", "callback", "download", "log", "transform", "method", "sample", "cont", "source", "buffer", "accept", "socket", "instance", "server", "coll", "resource", "uc", "f", "model", "session", "zip", "temp", "control", "rest", "loop", "current"], "url": ["image", "sl", "ul", "el", "feed", "fl", "e", "id", "page", "server", "coll", "loc", "http", "URL", "path", "resource", "ssl", "line", "file", "f", "Url", "lib", "channel", "base", "api", "plug", "data", "loader", "b", "rel", "ll", "name", "l", "string", "web", "uri", "source", "www"], "cl": ["sc", "CL", "client", "sl", "ctx", "cel", "class", "decl", "cc", "el", "comb", " CL", "fl", "ls", "cr", "cli", "lc", "cle", "coll", "loc", "sh", "bc", "bl", "acl", "ssl", "con", "uc", "scl", "hell", "ctrl", "sel", "col", "lib", "ocl", "pe", "gl", "loader", "ll", "shell", "kl", "ct", "l", "ml", "lock", "cont", "pl", "c", "Cl", "ec"], "cn": ["ca", "CN", "ain", "icon", "auc", "n", "gin", "bn", "cc", "ln", "cr", "ns", "mn", "cy", "cf", "core", "lc", "sn", "coll", "cone", "conn", "gn", "nam", "dn", "uh", "nc", "dc", "cm", "con", "fn", "cdn", "kin", "xc", "wcs", "kn", "enc", "abc", "nic", "jc", "ct", "Ns", "net", "rn", "nat", "hn", "ains", "mc", "ae", "CA", "act", "cb", "CW", "arn", "ec"]}}
{"id1": "17630906", "id2": "12417893", "code1": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "code2": "    @Override\n    public byte[] download(URI uri) throws NetworkException {\n        log.info(\"download: \" + uri);\n        HttpGet httpGet = new HttpGet(uri.toString());\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpGet);\n            return EntityUtils.toByteArray(httpResponse.getEntity());\n        } catch (IOException e) {\n            throw new NetworkException(e);\n        } finally {\n            httpGet.abort();\n        }\n    }\n", "label": 0, "substitutes": {"sortAscending": ["sortAascEND", "sortUscending", "sortAscend", "sortUascending", "sortUascend", "sortASCEND", "sortAascend", "sortAescEND", "sortAascending", "sortAscender", "sortASCender", "sortAascender", "sortUascender", "sortUascEND", "sortAescend", "sortAscEND", "sortUscender", "sortAescending", "sortASCending", "sortASCend", "sortAescender", "sortUscend", "sortUscEND"], "input": ["request", "image", "error", "in", "position", "accept", "progress", "batch", "element", "alpha", "argument", "stream", "entry", "up", "output", "form", "view", "object", "load", "context", "flow", "dict", "version", "instance", "feed", "parent", "select", "address", "integer", "inf", "result", "format", "target", "array", "index", "audio", "pull", "single", "xml", "img", "raw", "value", "out", "now", "work", "key", "area", "null", "model", "update", "data", "type", "Input", "text", "table", "string", "list", "sample", "filter", "field", "event", "current", "source", "config", "initial"], "order": ["request", "position", "process", "image", "error", "sort", "attr", "element", "block", "asc", "key", "output", "use", "app", "map", "default", "user", "Order", "instance", "rank", "parent", "enter", "page", "reverse", "after", "version", "rule", "e", "address", "info", "group", "ordering", "result", "code", "array", "grade", "index", "only", "work", "date", "count", "now", "root", "end", "ordered", "class", "type", "are", "err", "comment", "er", "test", "orders", "force", "search", "record", "call", "name", "table", "style", "list", "seed", "event", "sign", "move"], "i": ["ind", "ai", "ip", "m", "h", "p", "ie", "n", "ik", "is", "key", "fi", "ix", "J", "e", "phi", "ci", "gi", "jit", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "ij", "bi", "start", "x", "pi", "f", "iter", "o", "xi", "api", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "di", "l", "si", "qi", "uri", "I"], "j": ["job", "fr", "m", " dj", "oj", "p", "n", "g", "br", "obj", "q", "key", "ie", "uj", "J", "jen", "ix", "e", "section", "jit", "json", "aj", "ui", "adj", "jj", "ja", "dj", "li", "ii", "jl", "z", "bj", "ij", "x", "f", "o", "k", "jp", "u", "b", "y", "v", "ji", "jc", "je", "l", "d", "js", "si", "jet", "qi", "kj", "jo"], "mem": ["dim", "ind", "image", "ip", "mm", "mo", "m", "max", "dem", "lim", "nt", "md", "ui", "info", "um", "ram", "mini", "sum", "Mem", "ref", "num", "mb", "buff", "pool", "img", "value", "count", "dist", "part", "fun", "len", "cpu", "mind", "data", "mi", "mor", "mp", "memory", "name", "dev", "vm"], "id": ["ind", "ip", "in", "max", "n", "key", "is", "init", "kind", "oid", "Id", "mid", "ID", "info", "code", "a", "index", "num", "ref", "z", "count", "end", "x", "start", "uid", "area", "base", "sid", "data", "type", "b", "offset", "ids", "name", "d", "pid", "kid"]}}
{"id1": "18504192", "id2": "2668634", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    public WebmillDeploy(String inputName, String outputName, boolean stripLoggers) throws Exception {\n        File tempFile = null;\n        JarFile jin = null;\n        JarOutputStream jout = null;\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            String portletApplicationName = getPortletApplicationName(outputName);\n            System.out.println(\"portletApplicationName = \" + portletApplicationName);\n            tempFile = File.createTempFile(\"webmill-delpoy-\", \"\");\n            tempFile.deleteOnExit();\n            jin = new JarFile(inputName);\n            jout = new JarOutputStream(new FileOutputStream(tempFile));\n            Document webXml = null;\n            Document portletXml = null;\n            Document contextXml = null;\n            ZipEntry src;\n            InputStream source;\n            Enumeration zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    if (WEB_INF_WEB_XML.equals(target)) {\n                        System.out.println(\"Found web.xml\");\n                        webXml = parseXml(source);\n                    } else if (WEB_INF_PORTLET_XML.equals(target)) {\n                        System.out.println(\"Found WEB-INF/portlet.xml\");\n                        portletXml = parseXml(source);\n                    } else if (META_INF_CONTEXT_XML.equals(target)) {\n                        System.out.println(\"Found META-INF/context.xml\");\n                        contextXml = parseXml(source);\n                    }\n                } finally {\n                    source.close();\n                }\n            }\n            if (webXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/web.xml not found\");\n            }\n            if (portletXml == null) {\n                throw new IllegalArgumentException(\"WEB-INF/portlet.xml not found\");\n            }\n            WebmillWebApplicationRewriter webRewriter = new WebmillWebApplicationRewriter(webXml);\n            webRewriter.processWebXML();\n            WebmillContextRewriter contextRewriter = new WebmillContextRewriter(contextXml, portletApplicationName);\n            contextRewriter.processContextXML();\n            jin = new JarFile(inputName);\n            zipEntries = jin.entries();\n            while (zipEntries.hasMoreElements()) {\n                src = (ZipEntry) zipEntries.nextElement();\n                source = jin.getInputStream(src);\n                try {\n                    String target = src.getName();\n                    String fullTarget = '/' + target;\n                    if (stripLoggers && target.endsWith(\".jar\") && (target.startsWith(\"WEB-INF/lib/commons-logging\") || target.startsWith(\"WEB-INF/lib/log4j\"))) {\n                        System.out.println(\"Skip logger \" + target);\n                        continue;\n                    } else {\n                        if (webRewriter.getRealPortletTldFile() != null && fullTarget.equals(webRewriter.getRealPortletTldFile())) {\n                            System.out.println(\"Skip portlet tld file \" + fullTarget);\n                            continue;\n                        } else if (target.equals(WEB_INF_WEB_XML)) {\n                            System.out.println(\"Skip web.xml file \" + target);\n                            continue;\n                        } else if (target.equals(WEB_INF_PORTLET_XML)) {\n                            System.out.println(\"Skip portlet.xml file \" + target);\n                            continue;\n                        } else if (target.equals(META_INF_CONTEXT_XML)) {\n                            System.out.println(\"Skip context.xml file \" + target);\n                            continue;\n                        }\n                        System.out.println(\"Add file \" + target);\n                    }\n                    addFile(target, source, jout);\n                } finally {\n                    source.close();\n                }\n            }\n            addFile(WEB_INF_WEB_XML, webXml, jout);\n            addFile(WEB_INF_PORTLET_XML, portletXml, jout);\n            addFile(META_INF_CONTEXT_XML, contextXml, jout);\n            System.out.println(\"Attempting to add portlet.tld to war...\");\n            InputStream is = this.getClass().getResourceAsStream(\"/org/riverock/webmill/container/tags/portlet.tld\");\n            if (is == null) {\n                System.out.println(\"Failed to find portlet.tld in classpath\");\n            } else {\n                String portletTldFile = webRewriter.getRealPortletTldFile();\n                if (portletTldFile.charAt(0) == '/') {\n                    portletTldFile = portletTldFile.substring(1);\n                }\n                System.out.println(\"Adding file \" + portletTldFile);\n                try {\n                    addFile(portletTldFile, is, jout);\n                } finally {\n                    is.close();\n                }\n            }\n            jout.close();\n            jin.close();\n            jin = null;\n            jout = null;\n            System.out.println(\"Creating war \" + outputName + \" ...\");\n            System.out.flush();\n            srcChannel = new FileInputStream(tempFile).getChannel();\n            dstChannel = new FileOutputStream(outputName).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n            srcChannel.close();\n            srcChannel = null;\n            dstChannel.close();\n            dstChannel = null;\n            tempFile.delete();\n            tempFile = null;\n            System.out.println(\"War \" + outputName + \" created\");\n            System.out.flush();\n        } finally {\n            if (srcChannel != null && srcChannel.isOpen()) {\n                try {\n                    srcChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (dstChannel != null && dstChannel.isOpen()) {\n                try {\n                    dstChannel.close();\n                } catch (IOException e1) {\n                }\n            }\n            if (jin != null) {\n                try {\n                    jin.close();\n                    jin = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (jout != null) {\n                try {\n                    jout.close();\n                    jout = null;\n                } catch (IOException e1) {\n                }\n            }\n            if (tempFile != null && tempFile.exists()) {\n                tempFile.delete();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "inn", "src", "i", "old", "input", "copy", "parent", "id", "info", "diff", "or", "inner", "index", "io", "ini", "at", "file", "part", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "d", "again", "c", "inc"], "out": ["Out", "client", "writer", "p", "obj", "n", "output", "object", "copy", "ex", "cache", "conn", "target", "connection", "io", "dest", "file", "line", "part", "prefix", "o", "base", "exec", "data", "temp", "err", "b", "w", "call", "name", "password", "again", "string", "point", "outs", "external", "OUT", "c", "inc"], "source": ["get", "client", "clone", "component", "service", "size", "writer", "sl", "sync", "ie", "stream", "src", "i", "view", "use", "proxy", "scope", "input", "slice", "slave", "parent", "copy", "sin", "core", "server", "origin", "from", "target", "connection", "se", "ssl", "dest", "Source", "secure", "storage", "iter", "start", "channel", "unit", "null", "SOURCE", "settings", "reader", "project", "ource", "self", "ources"], "destination": ["Destinated", "declinated", "continated", "destinations", "dependinated", "declination", "Destinations", "declification", "contination", "Destinator", "dependination", "testinator", "Destification", " destinated", "dependification", "destinator", "destinated", " destinations", "contining", "destification", "destining", "testinations", " destinator", "testination", "Destination", "testinated", "continator", "Destining", " destining", "dependinator", "declinator"]}}
{"id1": "530882", "id2": "19739421", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    public static void main(final String[] args) throws RecognitionException, TokenStreamException, IOException, IllegalOptionValueException, UnknownOptionException {\n        try {\n            CmdLineParser cmdLineParser = new CmdLineParser();\n            Option formatOption = cmdLineParser.addStringOption('f', \"format\");\n            Option outputEncodingOption = cmdLineParser.addStringOption('c', \"outcharset\");\n            Option inputEncodingOption = cmdLineParser.addStringOption('i', \"incharset\");\n            cmdLineParser.parse(args);\n            String format = (String) cmdLineParser.getOptionValue(formatOption);\n            String outputEncoding = (String) cmdLineParser.getOptionValue(outputEncodingOption);\n            if (outputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                outputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to output charset utf-8 as argument -c is missing or not valid.\");\n            }\n            String inputEncoding = (String) cmdLineParser.getOptionValue(inputEncodingOption);\n            if (inputEncoding == null || outputEncoding.trim().equals(\"\")) {\n                inputEncoding = \"utf-8\";\n                System.out.println(\"Defaulting to input charset utf-8 as argument -i is missing or not valid.\");\n            }\n            String[] remainingArgs = cmdLineParser.getRemainingArgs();\n            if (remainingArgs.length != 2) {\n                printUsage(\"Input and output file are not specified correctly. \");\n            }\n            File inputFile = new File(remainingArgs[0]);\n            if (!inputFile.exists()) {\n                printUsage(\"Input file \" + remainingArgs[0] + \" does not exist. \");\n            }\n            if (format == null || format.trim().equals(\"\")) {\n                format = (String) FileUtil.cutExtension(inputFile.getName()).getValue();\n            }\n            File outputFile = new File(remainingArgs[1]);\n            if (!outputFile.exists()) {\n                outputFile.createNewFile();\n            }\n            System.out.println(\"format detected: \" + format);\n            if (\"html\".equals(format)) {\n                Reader reader = new HtmlEntityDecoderReader(new InputStreamReader(new FileInputStream(inputFile), inputEncoding));\n                OutputStreamWriter out = new OutputStreamWriter(new FileOutputStream(outputFile), outputEncoding);\n                char[] buffer = new char[1024];\n                int read;\n                do {\n                    read = reader.read(buffer);\n                    if (read > 0) {\n                        out.write(buffer, 0, read);\n                    }\n                } while (read != -1);\n                out.flush();\n                out.close();\n            } else {\n                printUsage(\"Format not specified via argument -f. Also guessing for the extension of input file \" + inputFile.getName() + \" failed\");\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n            printUsage(ex.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "3024987", "id2": "300397", "code1": "    @Test\n    public void testCopy_readerToOutputStream_Encoding() throws Exception {\n        InputStream in = new ByteArrayInputStream(inData);\n        in = new YellOnCloseInputStreamTest(in);\n        Reader reader = new InputStreamReader(in, \"US-ASCII\");\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, false, true);\n        IOUtils.copy(reader, out, \"UTF16\");\n        byte[] bytes = baout.toByteArray();\n        bytes = new String(bytes, \"UTF16\").getBytes(\"US-ASCII\");\n        assertTrue(\"Content differs\", Arrays.equals(inData, bytes));\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testCopy_readerToOutputStream_Encoding": ["testCopy_readerToOutputStream_encoder", "testCopy_readerToOutputStream_Coder", "testCopy_readerToOutputStream_Coded", "testCopy_readerToOutputStream_Integoded", "testCopy_readerToOutputStreamForEncoded", "testCopy_readerToOutputStreamForEncode", "testCopy_readerToOutputStream_Integode", "testCopy_readerToOutputStream_encode", "testCopy_readerToOutputStreamForencoding", "testCopy_readerToOutputStream_Encoded", "testCopy_readerToOutputStreamForEncoding", "testCopy_readerToOutputStream_Encode", "testCopy_readerToOutputStreamForencoded", "testCopy_readerToOutputStream_Integoding", "testCopy_readerToOutputStreamForencode", "testCopy_readerToOutputStream_Code", "testCopy_readerToOutputStreamForencoder", "testCopy_readerToOutputStreamForEncoder", "testCopy_readerToOutputStream_Coding", "testCopy_readerToOutputStream_encoding", "testCopy_readerToOutputStream_encoded", "testCopy_readerToOutputStream_Encoder", "testCopy_readerToOutputStream_Integoder"], "in": ["r", "image", "buffer", "m", "n", "inn", "entry", "Reader", "i", "is", "init", "input", "slice", "id", "include", "arin", "din", "inas", "or", "a", "inner", "io", "ini", "rin", "rec", "reading", "file", "inside", "min", "url", "pass", "login", "re", "data", "err", "with", "ins", "bin", "In", "IN", "again", "read", "win", "source", "inc"], "reader": ["r", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "ink", "i", "feed", "input", "rx", "handler", "per", "ler", "or", "pointer", "inner", "io", "rr", "iner", "ra", "reading", "file", "rar", "iter", "x", "loader", "b", "her", "oder", "er", "driver", "parser", "read", "source"], "baout": ["waout", "BAin", "waoutput", "BaOut", "baparent", "BAout", "aain", "vaparent", "abain", "bain", "daout", "abaOut", "vaout", "daOut", "vaOut", "baoutput", "Bain", "baOUT", "daOUT", "wain", "BAOut", "Baout", "vain", "aaout", "waOut", "Baparent", "BAparent", "dain", "aaoutput", "abaout", "baOut", "BAOUT", "BAoutput", "abaOUT", "aaOut"], "out": ["Out", "image", "client", "buffer", "writer", "obj", "output", "object", "user", "write", "parent", "cache", "server", "to", "inas", "array", "inner", "ext", "ref", "io", "pool", "line", "file", "o", "null", "exec", "base", "lib", "builder", "err", "with", "arr", "OUT", "again", "outs", "up", "inc"], "bytes": ["items", "os", "size", "ipes", "ies", "files", "output", "les", "bs", "units", "strings", "cells", "its", "ls", "ns", "ips", "comments", "odes", "css", "reads", "es", "lines", "objects", "android", "seconds", "content", "tes", "bps", "Bytes", "codes", "pieces", "classes", "bits", "binary", "pages", "ones", "null", "zip", "data", "blocks", "values", "rows", "text", "body", "string", "parts", "outs"]}}
{"id1": "21181542", "id2": "8079516", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "    public void buildSiteForEdit(String sBasePath, String sOutputPath, String sCtrlPath, String sMenuPath, String sIntegradorPath, String sSelPageOptions, Properties oEnvironmentProps, Properties oUserProps) throws IOException, DOMException, TransformerException, TransformerConfigurationException, MalformedURLException {\n        Transformer oTransformer;\n        StreamResult oStreamResult;\n        StreamSource oStreamSrcXML;\n        StringWriter oStrWritter;\n        InputStream oXMLStream = null;\n        String sTransformed;\n        StringBuffer oPostTransform;\n        String sKey;\n        String sMedia;\n        Object sVal;\n        Page oCurrentPage;\n        int iCloseHead, iOpenBody, iCloseBody;\n        int iReaded;\n        char CharBuffer[] = new char[8192];\n        String sCharBuffer;\n        long lElapsed = 0;\n        final String sSep = System.getProperty(\"file.separator\");\n        if (DebugFile.trace) {\n            lElapsed = System.currentTimeMillis();\n            DebugFile.writeln(\"Begin Pageset.buildSiteForEdit(\" + sBasePath + \",\" + sOutputPath + \",\" + sCtrlPath + \",\" + sMenuPath + \")\");\n            DebugFile.incIdent();\n        }\n        FileSystem oFS = new FileSystem();\n        Vector vPages = pages();\n        if (!sBasePath.endsWith(sSep)) sBasePath += sSep;\n        String sWebServer = oEnvironmentProps.getProperty(\"webserver\", \"\");\n        if (DebugFile.trace && sWebServer.length() == 0) DebugFile.writeln(\"WARNING: webserver property not set at EnvironmentProperties\");\n        if (!sWebServer.endsWith(\"/\")) sWebServer += \"/\";\n        Node oContainers = oMSite.seekChildByName(oMSite.getRootNode().getFirstChild(), \"containers\");\n        if (oContainers == null) {\n            if (DebugFile.trace) DebugFile.writeln(\"ERROR: <containers> node not found.\");\n            throw new DOMException(DOMException.NOT_FOUND_ERR, \"<containers> node not found\");\n        }\n        if (DebugFile.trace) DebugFile.writeln(\"new FileInputStream(\" + (sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI) + \")\");\n        for (int c = 0; c < vPages.size(); c++) {\n            oCurrentPage = (Page) vPages.get(c);\n            oXMLStream = new FileInputStream(sURI.startsWith(\"file://\") ? sURI.substring(7) : sURI);\n            oStreamSrcXML = new StreamSource(oXMLStream);\n            oStrWritter = new StringWriter();\n            oStreamResult = new StreamResult(oStrWritter);\n            try {\n                oTransformer = StylesheetCache.newTransformer(sBasePath + \"xslt\" + sSep + \"templates\" + sSep + oMSite.name() + sSep + oCurrentPage.template());\n                sMedia = oTransformer.getOutputProperty(OutputKeys.MEDIA_TYPE);\n                if (DebugFile.trace) DebugFile.writeln(OutputKeys.MEDIA_TYPE + \"=\" + sMedia);\n                if (null == sMedia) sMedia = \"html\"; else sMedia = sMedia.substring(sMedia.indexOf('/') + 1);\n                if (null == oCurrentPage.getTitle()) throw new NullPointerException(\"Page \" + String.valueOf(c) + \" title is null\");\n                if (DebugFile.trace) DebugFile.writeln(\"Page.filePath(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia + \")\");\n                oCurrentPage.filePath(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \".\" + sMedia);\n                StylesheetCache.setParameters(oTransformer, oEnvironmentProps);\n                StylesheetCache.setParameters(oTransformer, oUserProps);\n                oTransformer.setParameter(\"param_page\", ((Page) (vPages.get(c))).getTitle());\n                oTransformer.transform(oStreamSrcXML, oStreamResult);\n            } catch (TransformerConfigurationException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                SourceLocator sl = e.getLocator();\n                if (DebugFile.trace) {\n                    if (sl == null) {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage());\n                    } else {\n                        DebugFile.writeln(\"ERROR TransformerConfigurationException \" + e.getMessage() + \" line=\" + String.valueOf(sl.getLineNumber()) + \" column=\" + String.valueOf(sl.getColumnNumber()));\n                    }\n                }\n            } catch (TransformerException e) {\n                oLastXcpt = e;\n                sMedia = null;\n                if (DebugFile.trace) DebugFile.writeln(\"ERROR TransformerException \" + e.getMessageAndLocation());\n            }\n            oTransformer = null;\n            oStreamResult = null;\n            sTransformed = oStrWritter.toString();\n            if (DebugFile.trace) DebugFile.writeln(\"transformation length=\" + String.valueOf(sTransformed.length()));\n            if (sTransformed.length() > 0) {\n                iCloseHead = sTransformed.indexOf(\"</head\");\n                if (iCloseHead < 0) iCloseHead = sTransformed.indexOf(\"</HEAD\");\n                iOpenBody = sTransformed.indexOf(\"<body\", iCloseHead);\n                if (iOpenBody < 0) iOpenBody = sTransformed.indexOf(\"<BODY\", iCloseHead);\n                iCloseBody = sTransformed.indexOf(\">\", iOpenBody + 5);\n                for (char s = sTransformed.charAt(iCloseBody + 1); s == '\\r' || s == '\\n' || s == ' ' || s == '\\t'; s = sTransformed.charAt(++iCloseBody)) ;\n                oPostTransform = new StringBuffer(sTransformed.length() + 4096);\n                oPostTransform.append(sTransformed.substring(0, iCloseHead));\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sMenuPath + \"\\\"></script>\");\n                oPostTransform.append(\"\\n<script language=\\\"JavaScript\\\" src=\\\"\" + sIntegradorPath + \"\\\"></script>\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseHead, iCloseHead + 7));\n                oPostTransform.append(sTransformed.substring(iOpenBody, iCloseBody));\n                try {\n                    sCharBuffer = oFS.readfilestr(sCtrlPath, \"UTF-8\");\n                    if (DebugFile.trace) DebugFile.writeln(String.valueOf(sCharBuffer.length()) + \" characters readed\");\n                } catch (com.enterprisedt.net.ftp.FTPException ftpe) {\n                    throw new IOException(ftpe.getMessage());\n                }\n                try {\n                    if (DebugFile.trace) DebugFile.writeln(\"Gadgets.replace(\" + sCtrlPath + \",http://demo.hipergate.com/,\" + sWebServer + \")\");\n                    Gadgets.replace(sCharBuffer, \"http://demo.hipergate.com/\", sWebServer);\n                } catch (org.apache.oro.text.regex.MalformedPatternException e) {\n                }\n                oPostTransform.append(\"<!--Begin \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sCharBuffer);\n                sCharBuffer = null;\n                oPostTransform.append(\"\\n<!--End \" + sCtrlPath + \"-->\\n\");\n                oPostTransform.append(sTransformed.substring(iCloseBody));\n            } else {\n                oPostTransform = new StringBuffer(\"Page \" + ((Page) vPages.get(c)).getTitle() + \" could not be rendered.\");\n                if (oLastXcpt != null) oPostTransform.append(\"<BR>\" + oLastXcpt.getMessageAndLocation());\n            }\n            if (DebugFile.trace) DebugFile.writeln(\"new FileWriter(\" + sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia + \")\");\n            if (sSelPageOptions.length() == 0) oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, oPostTransform.toString(), \"UTF-8\"); else try {\n                oFS.writefilestr(sOutputPath + oCurrentPage.getTitle().replace(' ', '_') + \"_.\" + sMedia, Gadgets.replace(oPostTransform.toString(), \":selPageOptions\", sSelPageOptions), \"UTF-8\");\n            } catch (Exception e) {\n            }\n            oPostTransform = null;\n            sTransformed = null;\n        }\n        oXMLStream.close();\n        if (DebugFile.trace) {\n            DebugFile.writeln(\"done in \" + String.valueOf(System.currentTimeMillis() - lElapsed) + \" miliseconds\");\n            DebugFile.decIdent();\n            DebugFile.writeln(\"End Pageset.buildSiteForEdit()\");\n        }\n    }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteRoleTyp", "deleteResourceTypes", " deleteroleTypes", " deleteRoleTyp", "deleteFunctionType", " deleteRoletype", " deleteRoleTypes", "deleteResourceType", "deleteFunctionTyp", "deleteroleTyp", "deleteResourceTyp", "deleteRoleTypes", "deleteroletype", "deleteFunctionTypes", "deleteroleTypes", " deleteroleType", "deleteResourcetype", "deleteroleType", " deleteroletype", " deleteroleTyp", "deleteFunctiontype", "deleteRoletype"], "id": ["request", "error", "in", "ip", "i", "key", "is", "object", "vid", "oid", "view", "version", "parent", "Id", "section", "mid", "ID", "address", "info", "code", "connection", "ident", "index", "path", "edit", "part", "start", "end", "uid", "url", "f", "sid", "model", "data", "type", "it", "ids", "name", "string", "like", "aid", "rid", "uri", "lock", "pid", "kid", "source", "length"], "namespaceId": ["asentityName", "asentityID", "nspaceId", "namesenceId", "namesentityName", "NamespacedId", "namesaceContext", "namespacedid", "namesaneType", "memberspaceid", "nsaceId", "nspaceID", "namesenceType", "memberspaceId", "namesentityId", "namespacedType", "worksspaceKey", "namesetName", "namesaceInfo", "workspaceid", "namespacesPath", "namespacesName", "workspacesId", "namesspaceInfo", "namespaceInfo", "namesetInfo", "namesspaceKey", "namesetid", "namespacesType", "NamespacedName", "namespaceName", "nsaceInfo", "aspaceID", "NamespacedType", "aspaceId", "namespacePath", "workspaceInfo", "worksspaceId", "namesplaceid", "namespaceid", "namesplaceID", "namesenceContext", "workspacePath", "namespacedPath", "Namespacedid", "membersetId", "namesaceID", "namesaceId", "namesplaceId", "membersetid", "namesaceid", "NamespaceId", "workspacesType", "namespacesID", "namespacedInfo", "nspaceid", "workspaceType", "nsaceid", "workspaceId", "namespacesKey", "worksspaceInfo", "namesentityID", "namesaneId", "namesaneName", "namespacedName", "asentityId", "namespacesContext", "namesentityInfo", "namesaceType", "namespaceKey", "namespacesid", "namesspaceId", "membersetName", "membersetType", "aspaceName", "worksspacePath", "namespaceID", "aspaceInfo", "namesetId", "namesaneid", "namesetID", "namesspacePath", "memberspaceName", "workspacesid", "workspacesContext", "namespacedId", "nsaceID", "Namespaceid", "namespacedKey", "asentityInfo", "nspaceInfo", "NamespaceName", "namesplaceInfo", "namespacesId", "namespaceContext", "namespaceType", "workspaceContext", "workspaceKey", "NamespaceType", "namesenceid", "memberspaceType", "namespacesInfo", "namesetType"], "removeReferencesInRoleTypes": ["removeReferencesedInroletypes", "removeReferencesInRoletypes", "removeReferencesedInroleNames", "removeReferencesedInRoleNames", "removeReferencesFromroleRelations", "removeReferencesedInroleType", "removeReferencesInServiceTypes", "removeReferencesInroleNames", "removeReferencesInServiceNames", "removeReferencesInroleRelations", "removeReferencesInRoleNames", "removeReferencesInRuletypes", "removeReferencesedInRoletypes", "removeReferencesFromroleNames", "removeReferencesInRuleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInServiceRelations", "removeReferencesedInRoleTypes", "removeReferencesFromRoleType", "removeReferencesInroletypes", "removeReferencesInRuleType", "removeReferencesFromRoleRelations", "removeReferencesInRuleNames", "removeReferencesedInRoleType", "removeReferencesInRoleType", "removeReferencesFromroleTypes", "removeReferencesFromRoleTypes", "removeReferencesInRoleRelations", "removeReferencesInServiceType", "removeReferencesedInroleTypes", "removeReferencesInroleTypes", "removeReferencesInroleType", "removeReferencesFromRoleNames"], "permit": ["PERmission", "permits", "PerMIT", "permissions", "PERMIT", "perMIT", "Permit", "Permits", "recmit", "PERmit", "permmission", " perit", "permmit", " permits", "permission", "Permissions", "recmission", " permission", "recit", "permmissions", "Perit", "Permission", "permMIT", "PERmissions", "perit", "recmits"], "exist": ["match", "stick", "support", "same", "form", "delete", "write", "purpose", "include", "fail", "check", "apply", "register", "diff", "ident", "index", "icate", "destruct", "fill", "edit", "start", "update", "existent", "except", "know", "keep", "existing", "continue", "draw", "existence", "front", "list", "present", "destroy", "cmp", "cont", "add", "create", "inc", "ist"], "msgBuf": [" msgLundle", "msgCbuf", "msgFBob", "msgFBuf", "msgLUF", "messageAuff", "msgAUF", "msgEBbox", " msgBbuff", " msgFraf", "messageBuf", "messageFbox", "messageAuf", "msgPluff", "messageFuff", "msgDBbuf", "messageBbox", "msgLuf", "msgEBuff", " msgFbuff", "msgAbox", "messageBbuf", "msgFraf", "msgAaf", " msgFuf", "msgBob", "msgBaf", "msgFundle", "messageBuff", "msgFbuf", "msgBUF", " msgLuff", "messageFUF", "messageAUF", "msgEBuf", "msgLob", "msgFuff", "msgAuf", "msgBundle", "messageBUF", "msgBbuf", "msgPlaf", "messageFuf", "msgCuf", "msgFbox", "msgDaf", "msgDBuf", "msgAraf", "msgAbuf", "msgBraf", "messageBob", " msgBbuf", "msgFaf", "msgFUF", "msgFBUF", " msgBaf", "msgLundle", "msgLuff", "msgDuf", " msgFaf", " msgFbuf", "msgPluf", "msgDBuff", "msgEBbuf", "msgFob", "msgAuff", "msgAob", " msgBraf", "msgBbuff", "msgDbuf", "msgFBuff", "msgPlundle", " msgLuf", "msgFbuff", "msgCob", "msgBbox", "messageFbuf", " msgBuff", "msgDBUF", " msgFuff", "msgCuff", "messageAbuf", "msgFuf", " msgBundle", " msgLaf", "msgBuff", "msgLaf", "msgDuff", "msgAbuff", "messageFob"], "objects": ["items", "locks", "os", "cats", "children", "obj", "points", "models", "people", "files", "types", "notes", "object", "boxes", "phones", "products", "cells", "archives", "projects", "links", "features", "properties", "lines", "keys", "ks", "obs", "owners", "jobs", "images", "resources", "results", "frames", "apps", "roots", "members", "kids", "oids", "classes", "relations", "actions", "articles", "agents", "values", "pins", "groups", "blocks", "organisms", "users", "parents", "ins", "bugs", "ops", "ids", "names", "parts", "pps", "archs", "plugins"], "sqlRightId": ["sqlRid", "sqlRightRef", "SQLRestid", "sqlLeftid", "SQLRightID", "sqlRId", "SQLRightid", "sqlrightid", " sqlrightType", "SQLRestID", "sqlLeftType", "sqlRestID", "sqlRestRef", " sqlrightid", "sqlRightID", "sqlRRef", "sqlRightPoint", "sqlRestid", "sqlrightType", "sqlLeftId", "SQLRightRef", " sqlRightPoint", "sqlRestId", " sqlrightId", " sqlRightType", "SQLRightId", "sqlLeftPoint", "sqlrightId", "sqlRightType", " sqlRightid", " sqlrightPoint", "sqlRID", "SQLRestRef", "SQLRestId", "sqlRightid", "sqlrightPoint"], "sqlParent": [" sqlparent", "suParents", "suRoot", "suParent", "sqlRoot", "sqlparent", "qlRoot", "qlParent", " sqlRoot", "qlParents", " sqlParents", "suparent", "sqlParents", "qlparent"], "sql": [" session", "where", "db", "error", "sl", "msg", " db", " params", "delete", "s", " SQL", " msg", "SQL", "conn", "replace", "acl", "operation", "description", "link", "url", "update", "session", "log", "dl", "ql", " url", "select", "repl"], "pstmt": ["New", "pctm", " pndbl", "Security", "s", "pctmr", "pstmb", "pmtmb", "pstmd", "pctmb", "pctmt", "pstrtr", "pStm", " psttr", "this", "pStmt", "Pctct", "pstatmr", " pStmt", "Pstct", "postmr", "pstrct", "pfmd", " pstnt", "pstm", "All", "pstatmt", " pStm", "Pstmd", "The", "pstrmt", "pndmb", "postnt", "Delete", " pndmb", "pfct", "pstrm", "pstbl", "Pstmt", "pmtbl", "pmtmt", "psttr", "pctmd", " pstmr", " pSttr", "Pctmd", "pfmt", "pstmr", " postmr", "delete", "pctct", "pSttr", "pndbl", "pftr", " pstbl", "Psttr", "postct", "pndct", "pstatct", "Pctmt", "Error", " postnt", " postct", "pctbl", "pctnt", "add", " pndct", "pcttr", "pstatnt", "pStct", "pndmt", " postmt", "pstct", "pmtct", "pstnt", "_", " pstm", "pmtmd", "pmttr", " pStct", "Pcttr", " pndmt", " pstmb", "postmt", " pstct"], "typeGid": ["typeGVID", "typeGoid", "TypeGmin", "TypeCmin", "typeGVid", "typeGUoid", "typeWname", "typeWid", "TypeCname", "typeGUid", "linkGname", "typeWmin", "TypeCID", "TypeGname", "linkGVoid", "linkGID", "typeAccid", "typegid", "linkGid", "typeGUID", "typeGUname", "typeAccmin", "typegname", "linkGoid", "linkGVid", "TypeGid", "typeAccID", "typeGname", "typegID", "typegoid", "typeGmin", "typeCID", "typeAccname", "typeCname", "linkGVname", "TypeCid", "typeGVname", "typeWID", "TypeGID", "linkGVID", "typeCmin", "typeGID", "typeGVoid", "typeCid"], "defaultLevel": ["configCl", "DefaultMode", "DefaultCl", "DefaultDepth", "defaultMode", " defaultCl", " defaultMode", " defaultDepth", "configMode", "DefaultLevel", "configLevel", "defaultDepth", "configDepth", "defaultCl"], "success": ["error", "match", "progress", "accept", "batch", "serial", "fail", "complete", "reg", "replace", "result", "Success", "failed", "submit", "response", "successful", "message", "results", "resp", "successfully", "warning", "data", "test", "status", "continue", "roll", "launch"]}}
{"id1": "5274228", "id2": "18433984", "code1": "    public String put(String resourceID, Map<String, String> headersMap) {\n        HttpClient httpClient = new DefaultHttpClient();\n        httpClient.getParams().setParameter(\"http.useragent\", \"sla@soi OCCI Client v0.2\");\n        HttpPut httpPut = new HttpPut(resourceID);\n        List<Header> headersList = this.convert2Headers(headersMap);\n        for (Iterator<Header> iterator = headersList.iterator(); iterator.hasNext(); ) {\n            httpPut.addHeader(iterator.next());\n        }\n        logger.info(httpPut.getRequestLine());\n        logger.info(httpPut.getAllHeaders());\n        Header[] headersArray = httpPut.getAllHeaders();\n        String[] fields = { Response.Location };\n        HashMap<String, String> occiHeaders = new HashMap<String, String>();\n        for (int H = 0; H < headersArray.length; H++) {\n            Header header = headersArray[H];\n            logger.info(\"header - request  -\" + header.toString());\n            logger.info(\"\theaderName - \" + header.getName());\n            logger.info(\"\theaderValue - \" + header.getValue());\n        }\n        String statusLine = null;\n        try {\n            HttpResponse httpResponse = httpClient.execute(httpPut);\n            statusLine = httpResponse.getStatusLine().toString();\n            int statusCode = httpResponse.getStatusLine().getStatusCode();\n            logger.info(\"----------------------------------------\");\n            logger.info(\"StatusLine - (full) - \" + httpResponse.getStatusLine());\n            logger.info(\"\tStatusCode - \" + statusCode);\n            logger.info(\"\tReason - \" + httpResponse.getStatusLine().getReasonPhrase());\n            logger.info(\"\tProtocol - \" + httpResponse.getStatusLine().getProtocolVersion().toString());\n            logger.info(\"----------------------------------------\");\n            if (StatusCode.validate(statusCode)) {\n                logger.info(\"Response Validated\");\n            } else {\n                logger.error(\"Response NOT Validated\");\n                return null;\n            }\n            Header[] headers = httpResponse.getAllHeaders();\n            for (int i = 0; i < headers.length; i++) {\n                Header header = headers[i];\n                logger.info(\"header - response - \" + header.toString());\n                logger.info(\"\theaderName - \" + header.getName());\n                logger.info(\"\theaderValue - \" + header.getValue());\n                for (int h = 0; h < fields.length; h++) {\n                    logger.info(\"\tLooking for  - \" + fields[h]);\n                    if (fields[h].equals(header.getName().toString())) {\n                        logger.info(\"\tFound an OCCI Header - \" + header.getName());\n                        occiHeaders.put(header.getName(), header.getValue());\n                    }\n                }\n            }\n        } catch (org.apache.http.conn.HttpHostConnectException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            logger.error(e);\n            return null;\n        } finally {\n            httpClient.getConnectionManager().shutdown();\n        }\n        logger.info(\"occiHeaders - \" + occiHeaders);\n        if (occiHeaders.containsKey(Response.Location)) {\n            logger.info(\"Valid Provision\" + statusLine);\n            return occiHeaders.get(Response.Location).toString().replaceAll(Response.jobs, \"\");\n        }\n        logger.info(\"NOT a Valid Provision - \" + statusLine);\n        return statusLine;\n    }\n", "code2": "    protected void doUpload(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        HttpSession reqSession = request.getSession();\n        ArrayList<File> uploadFiles = new ArrayList<File>();\n        LOG.info(\"UploadServlet Upload request received\");\n        if (ServletFileUpload.isMultipartContent(request)) {\n            LOG.debug(\"UploadServlet Received a multipart request.\");\n        } else {\n            LOG.debug(\"UploadServlet Received a non-multipart request.\");\n        }\n        String tempDirName = UUID.randomUUID().toString();\n        File tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        tempUploadDir.getParentFile().mkdir();\n        while (tempUploadDir.exists()) {\n            tempDirName = UUID.randomUUID().toString();\n            tempUploadDir = new File(adapter.getRootPath() + File.separator + \"temp\" + File.separator + tempDirName);\n        }\n        tempUploadDir.mkdir();\n        File attachmentDir = (File) (reqSession.getAttribute(\"up2p:attachdir\"));\n        if (attachmentDir != null) {\n            LOG.info(\"UploadServlet: Copying provided attachment to upload dir from: \" + attachmentDir.getAbsolutePath());\n            tempUploadDir.delete();\n            attachmentDir.renameTo(tempUploadDir);\n            reqSession.removeAttribute(\"up2p:attachdir\");\n        }\n        LOG.info(\"UploadServlet: Using temporary directory: \" + tempUploadDir.getPath());\n        PairList paramMap = null;\n        if (ServletFileUpload.isMultipartContent(request)) {\n            paramMap = getMultipartParameters(request, uploadHandler, LOG, tempUploadDir.getPath());\n            if (paramMap.size() == 0) {\n                LOG.debug(\"UploadServlet Parsed multipart request and \" + \"found no parameters. Parsing as regular\" + \" request instead.\");\n                paramMap = copyParameters(request);\n                LOG.debug(\"UploadServlet Parsed as regular request and found \" + paramMap.size() + \" parameters.\");\n            }\n        } else {\n            paramMap = copyParameters(request);\n        }\n        String communityId = getCurrentCommunityId(request.getSession());\n        String newcommunity = paramMap.getValue(HttpParams.UP2P_COMMUNITY);\n        LOG.debug(\"UploadServlet: Got active community: \" + newcommunity);\n        if (newcommunity != null) {\n            communityId = newcommunity;\n            LOG.debug(\"switching to community\" + communityId);\n        }\n        if (communityId == null || communityId.length() == 0) {\n            LOG.warn(\"UploadServlet Current community ID is missing from\" + \"the user session.\");\n            writeError(request, response, \"The current community is unknown.\" + \" Please select a community before performing \" + \"any actions.\", paramMap);\n            for (File f : tempUploadDir.listFiles()) {\n                f.delete();\n            }\n            tempUploadDir.delete();\n            return;\n        }\n        LOG.info(\"UploadServlet Uploading to community \" + communityId + \".\");\n        uploadFiles.clear();\n        Iterator<String> uploadedFileIter = paramMap.getValues(HttpParams.UP2P_FILENAME);\n        String filename = \"\";\n        try {\n            if (uploadedFileIter.hasNext()) {\n                filename = uploadedFileIter.next();\n            } else {\n                throw new IOException(\"UploadServlet: No up2p:filename parameters were found.\");\n            }\n            if (filename.startsWith(\"file:\")) filename = filename.substring(5);\n            if (filename.length() == 0) {\n                throw new IOException(\"UploadServlet: An empty up2p:filename parameter was submitted.\");\n            }\n            File resourceFile = null;\n            resourceFile = new File(adapter.getStorageDirectory(communityId), filename);\n            File tempResFile = new File(tempUploadDir, filename);\n            if (!tempResFile.exists() && !resourceFile.exists()) {\n                throw new IOException(\"UploadServlet: The uploaded resource could not be found.\");\n            }\n            if ((tempResFile.exists() && resourceFile.exists()) || (tempResFile.exists() && !resourceFile.exists())) {\n                resourceFile = FileUtil.createUniqueFile(resourceFile);\n                LOG.info(\"UploadServlet: Direct upload, copying resource file.\\n\\tOriginal: \" + tempResFile.getPath() + \"\\n\\tNew: \" + resourceFile.getPath());\n                resourceFile.getParentFile().mkdir();\n                FileOutputStream resourceCopyStream = new FileOutputStream(resourceFile);\n                FileUtil.writeFileToStream(resourceCopyStream, tempResFile, true);\n                filename = resourceFile.getName();\n            }\n            LOG.info(\"UploadServlet: resource file name: \" + filename);\n            uploadFiles.add(resourceFile);\n        } catch (IOException e) {\n            LOG.error(\"UploadServlet: \" + e.getMessage());\n            writeError(request, response, e.getMessage(), paramMap);\n            return;\n        }\n        String editResourceId = paramMap.getValue(HttpParams.UP2P_EDIT_RESOURCE);\n        if (editResourceId != null && editResourceId.length() > 0) {\n            LOG.debug(\"UploadServlet: Got edit resource: \" + editResourceId);\n            File editAttach = new File(adapter.getAttachmentStorageDirectory(communityId, editResourceId));\n            if (editAttach.exists() && editAttach.isDirectory()) {\n                LOG.debug(\"UploadServlet: Copying additional attachments from: \" + editAttach.getAbsolutePath());\n                for (File oldFile : editAttach.listFiles()) {\n                    File newFile = new File(tempUploadDir, oldFile.getName());\n                    if (!newFile.exists()) {\n                        LOG.debug(\"UploadServlet: Copying attachment: \" + oldFile.getAbsolutePath() + \" to \" + newFile.getAbsolutePath());\n                        FileOutputStream attachCopyStream = new FileOutputStream(newFile);\n                        FileUtil.writeFileToStream(attachCopyStream, oldFile, true);\n                    } else {\n                        LOG.debug(\"UploadServlet: Attachment \" + newFile.getName() + \" explicitly replaced in new upload.\");\n                    }\n                }\n            }\n        }\n        String batchUploadString = paramMap.getValue(HttpParams.UP2P_BATCH);\n        boolean batchUpload = batchUploadString != null && batchUploadString.length() > 0;\n        if (batchUpload) {\n            LOG.info(\"UploadSerlvet Recieved batch upload request.\");\n            File batchFile = new File(adapter.getStorageDirectory(communityId), uploadFiles.get(0).getName());\n            uploadFiles.clear();\n            LOG.debug(\"UploadServlet resource file stored at: \" + batchFile.getPath());\n            XMLReader reader = TransformerHelper.getXMLReader();\n            reader.setContentHandler(new BatchCopyHandler(communityId, uploadFiles));\n            try {\n                FileInputStream batchInput = new FileInputStream(batchFile);\n                reader.parse(new InputSource(batchInput));\n                batchInput.close();\n            } catch (Exception e) {\n                LOG.error(\"UploadServlet: Error parsing batch upload file.\");\n                LOG.error(\"UploadServlet: \" + e.getMessage());\n                writeError(request, response, \"Uploaded content was not a valid batch resource file.\", paramMap);\n                return;\n            }\n            batchFile.delete();\n            adapter.addNotification(\"Batch file succesfully processed into \" + uploadFiles.size() + \" resources.\");\n        }\n        boolean pushUpload = paramMap.getValue(HttpParams.UP2P_PUSH) != null && paramMap.getValue(HttpParams.UP2P_PUSH).length() > 0;\n        String id = \"\";\n        boolean duplicateResource = false;\n        int uploadCount = 0;\n        for (int i = 0; i < uploadFiles.size(); i++) {\n            LOG.info(\"UploadServlet Publishing resource to WebAdapter: \" + uploadFiles.get(i).getName());\n            try {\n                id = adapter.publish(communityId, new File(uploadFiles.get(i).getName()), tempUploadDir);\n                uploadFiles.remove(i);\n                i--;\n                uploadCount++;\n                LOG.info(\"UploadServlet Resource published with id: \" + id);\n            } catch (IOException e) {\n                LOG.warn(\"UploadServlet IO Error occured in reading the uploaded file: \" + e.getMessage(), e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"An error occured in reading the uploaded file: \" + e.getMessage(), paramMap);\n                return;\n            } catch (SAXParseException e) {\n                LOG.warn(\"UploadServlet SAX Parse Error occured in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in the uploaded resource.<br/>\" + e.getMessage() + \"<br/><br/>File location: \" + uploadFiles.get(i).getAbsolutePath() + \"<br/>Line: \" + e.getLineNumber() + \" Column: \" + e.getColumnNumber();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (SAXException e) {\n                LOG.warn(\"UploadServlet Invalid XML in uploaded resource: \" + e.getMessage());\n                String errMsg = \"Invalid XML in uploaded resource<br/><i>\" + e.getMessage() + \"</i><br/>\" + \"File location: \" + uploadFiles.get(i).getAbsolutePath();\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, errMsg, paramMap);\n                return;\n            } catch (DuplicateResourceException e) {\n                LOG.info(\"UploadServlet Duplicate Resource: \" + e.getResourceId() + \" Community: \" + e.getCommunityId());\n                if (batchUpload) {\n                    if (!duplicateResource) {\n                        adapter.addNotification(\"Warning: Batch upload contained previously published \" + \" resources which have been discarded.\");\n                        duplicateResource = true;\n                    }\n                } else {\n                    uploadFilesCleanup(uploadFiles, tempUploadDir);\n                    String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n                    if (respondWithXml != null && respondWithXml.length() > 0) {\n                        writeError(request, response, \"This resource is already shared with resource \" + \" id: \" + e.getResourceId(), paramMap);\n                        return;\n                    }\n                    String redirect = response.encodeURL(\"/overwrite.jsp?up2p:community=\" + e.getCommunityId() + \"&up2p:resource=\" + e.getResourceId());\n                    LOG.info(\"UploadServlet Redirecting to \" + redirect);\n                    RequestDispatcher rd = request.getRequestDispatcher(redirect);\n                    rd.forward(request, response);\n                    return;\n                }\n            } catch (NetworkAdapterException e) {\n                LOG.info(\"UploadServlet Error in the Network Adapter for\" + \" community ID \" + communityId, e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error in the Network Adapter for this community. <br/>\" + e.getMessage(), paramMap);\n                return;\n            } catch (ResourceNotFoundException e) {\n                LOG.info(\"UploadServlet Error Resource not found \" + e);\n                uploadFilesCleanup(uploadFiles, tempUploadDir);\n                writeError(request, response, \"Error : <br/>\" + e.getMessage(), paramMap);\n                return;\n            }\n        }\n        uploadFilesCleanup(uploadFiles, tempUploadDir);\n        String ajaxRequest = paramMap.getValue(HttpParams.UP2P_XMLHTTP);\n        String respondWithXml = paramMap.getValue(HttpParams.UP2P_FETCH_XML);\n        if (respondWithXml != null && respondWithXml.length() > 0) {\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.println(\"<upload success=\\\"true\\\" >\");\n            out.println(\"<resid>\" + id + \"</resid>\");\n            out.println(\"</upload>\");\n        } else if (ajaxRequest != null && ajaxRequest.length() > 0) {\n            LOG.debug(\"UploadServlet Recieved xmlHttp request, responding with XML\");\n            response.setContentType(\"text/xml\");\n            PrintWriter out = response.getWriter();\n            out.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n            out.print(\"<resource id=\\\"\" + request.getParameter(HttpParams.UP2P_RESOURCE) + \"\\\" \");\n            if (request.getParameter(HttpParams.UP2P_PEERID) != null) {\n                out.print(\"peerid=\\\"\" + request.getParameter(HttpParams.UP2P_PEERID) + \"\\\" \");\n            }\n            out.println(\"/>\");\n        } else if (batchUpload) {\n            adapter.addNotification(uploadCount + \" resources were succesfully published.\");\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:community=\" + communityId);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        } else if (!pushUpload) {\n            request.setAttribute(\"up2p.display.mode\", \"view\");\n            String redirect = response.encodeURL(\"/view.jsp?up2p:resource=\" + id);\n            LOG.info(\"UploadServlet Redirecting to \" + redirect);\n            RequestDispatcher rd = request.getRequestDispatcher(redirect);\n            rd.forward(request, response);\n        }\n        return;\n    }\n", "label": 0, "substitutes": {"put": ["get", "client", "output", "transfer", "write", "parse", "patch", "cache", "replace", "format", "submit", "resource", "pull", "operation", "build", "file", "UT", "Put", "post", "st", "update", "data", "transform", "string", "add", "create", "PUT"], "resourceID": ["serviceIDs", "requestKey", "ResourceKey", "objectId", "serviceId", "resourceId", "serviceID", "ResourceIDs", "objectIDs", "requestID", "requestId", "ResourceID", "resourceIDs", "serviceid", "responseID", "Resourceid", "resourceid", "objectid", "ResourceId", "responseId", "responseKey", "requestURL", "responseURL", "resourceKey", "resourceURL", "ResourceURL", "objectID"], "headersMap": ["httpList", "headerSet", "httpArray", "headersFile", " headersFile", "ersMap", "headersSet", " headersSet", "headerList", "ersArray", "httpSet", "headerFile", "httpMap", "ersFile", "headerArray", "headerMap", "ersList"], "httpClient": ["httpConnection", "httpContext", " httpContext", "httpsPut", "HttpPut", "HttpCase", " httpConnection", "httpsClient", "httpServer", "HttpClient", "httpCall", "httpsContext", "httpCase", "HttpCall", "ttpBase", "HttpContext", "phpCase", "HttpServer", "ttpClient", " httpBase", "httpsConnection", "httpsBase", "ttpPut", "ttpConnection", "phpPut", "httpBase", " httpCase", "phpCall", "phpClient", " httpCall", "httpsServer", " httpServer"], "httpPut": [" httpPush", "httpsPut", "internalGet", "HttpPut", "HttpPush", "webGet", "Httpput", " httpPUT", "httpAdd", "HttpDo", "httpWrite", "httpsClient", "httpPush", "HttpClient", " httpDo", "HttpPUT", "httpSplit", "httpGet", " httpSplit", "internalWrite", "httpPUT", "httpsput", "phpAdd", "viewput", "httpsSplit", "phpGet", "webPut", "httpsPush", "HttpGet", "viewPut", "webPUT", "httpsPUT", "httpDo", " httpWrite", "httpsAdd", "phpWrite", "internalPut", "httpsDo", "webPush", "viewPush", "httpsGet", " httpAdd", "httpput", "phpPush", "internalPush", "viewPUT", "phpSplit", "phpPut", " httpGet"], "headersList": [" headersL", "ersSet", "ersList", "headerSet", "ersL", "headersSet", "headerList", "headersL", "headerL", "ersArray", "driversArray", "driversList", "headerArray", "driversMap", "headerMap", " headersSet", "driversL"], "iterator": ["former", "next", "Iterator", "kick", "adder", "writer", "size", "creator", "ie", "entry", "stream", "Iter", "eni", "multi", "init", "slice", "sequence", "basic", "instance", "handler", "interstitial", "oper", "division", "pointer", "inner", "li", "gener", "later", "starter", "step", "operator", "start", "iter", "end", "started", "engine", "ator", "set", "loader", "append", "inter", "runner", "collection", "done", "driver", "processor", "ter", "finder", "reader", "parser", "loop", "vector", "random", "outer", "ski", "walker"], "headersArray": ["ersHash", "headersLength", "ersAr", "filesHash", " headersAr", "hersAr", "headsList", "hersList", "headsAr", "filesMap", "ersMap", " headersLength", "hersArray", "hersLength", "headersHash", "ersArray", "headsLength", "filesArray", "headsArray", "headersAr", "filesAr", " headersHash"], "fields": ["details", "Field", "files", "types", "pattern", "comments", "FIELD", "json", "properties", "lines", "keys", "format", "content", "region", "params", "codes", "dir", "prefix", "zip", "data", "values", "errors", "rows", "body", "field", "dates"], "occiHeaders": ["occiHosters", "occiBuilder", "occiHeader", "occiBuilders", "occiHeaderers", "ocsiHeaderers", "ocsiBufferers", "occiBuffer", "occiBuffers", "occiBufferers", "ocsiBuffers", "ocsiHeadlers", "occiHostlers", "occiBuilderers", "ocsiHeader", "occiHoster", "occiHosterers", "occiBuildlers", "ocsiBuffer", "ocsiBufflers", "ocsiHeaders", "occiBufflers", "occiHeadlers"], "H": ["S", "C", "K", "T", "TH", "HR", "MH", "P", "HM", "EH", "J", "G", "SH", "HTTP", "U", "X", "Head", "M", "ID", "N", "Hop", "Length", "HB", "D", "rh", "HH", "CH", "B", "HI", "HT", "DH", "NH", "OH", "L", "Index", "Handler", "Y", "HE", "I", "HS", "Header", "Q", "R", "V", "F", "W", "HC"], "header": ["request", "former", "back", "writer", "detail", "buffer", "cher", " request", "service", "entry", "block", "key", "comment", "consumer", "handler", "rule", "metadata", "server", "per", "info", "ler", "dr", "result", "http", "inner", "response", "message", "ker", "later", "manager", "value", "row", "file", "cover", "liner", "second", "f", "feature", "definition", "builder", "player", "her", "er", "token", "document", "driver", "ter", "frame", "reader", "string", "bridge", "head", "Header", "outer", "event", "extra", "holder", "layer"], "statusLine": ["StatusBody", "statusText", "statusFile", "StatusFile", "errorString", " statusText", "responseCode", " statusBody", "statusBody", "errorCode", "StatusLine", "StatusText", "responseFile", " statusString", "StatusCode", "errorLine", "statusString", " statusFile", "responseLine", "errorBody", "StatusString", "responseText"], "httpResponse": ["HttpBody", " httpBody", "httpResult", "httpBody", "Httpresponse", "httpResp", "httpsPage", "httpLine", "actualResponse", " httpResp", "ttpResult", "statusResponse", " httpStatus", " httpResult", "HttpLine", "httpStatus", "templateResponse", "httpsRequest", "HttpEnvironment", "httpEnvironment", "httpsResponse", "httpRequest", "ttpResp", "ttpResponse", "statusResult", "HttpResponse", "httpsBody", " httpPage", "statusBody", " httpLine", "templateResp", "httpsResult", "templateStatus", "HttpStatus", "HttpRequest", "actualresponse", "HttpPage", "httpPage", "HttpResult", " httpBlock", "actualLine", "HttpBlock", "ttpRequest", "httpsEnvironment", " httpresponse", "statusBlock", "httpBlock", "templateLine", " httpEnvironment", "HttpResp", "actualRequest", "httpresponse", " httpRequest"], "statusCode": [" statusData", "resultCode", "statusCount", "statusType", "resultCount", "StatusData", "statusText", "errorText", " StatusLine", "resultcode", "Statuscode", "statusData", " statusCount", "responseCode", "resultLine", " statusType", "StatusType", "errorCode", "StatusLine", "responseType", "StatusText", "StatusCount", " statuscode", "StatusCode", "errorLine", "responseLine", " StatusData", " StatusType", " StatusCode", "errorType", "statuscode", "responseText"]}}
{"id1": "1986417", "id2": "8047989", "code1": "    @Override\n    public void export(final Library lib) throws PluginException {\n        try {\n            new Thread(new Runnable() {\n\n                public void run() {\n                    formatter.format(lib, writer);\n                    writer.flush();\n                    writer.close();\n                }\n            }).start();\n            ftp.connect(host);\n            if (!FTPReply.isPositiveCompletion(ftp.getReplyCode())) {\n                ftp.disconnect();\n                throw new PluginException(\"Unable to connect to FTP\");\n            }\n            ftp.login(user, pass);\n            ftp.pasv();\n            ftp.changeWorkingDirectory(dir);\n            ftp.storeFile(file, inStream);\n            ftp.logout();\n        } catch (SocketException e) {\n            throw new PluginException(e);\n        } catch (IOException e) {\n            throw new PluginException(e);\n        } finally {\n            if (ftp.isConnected()) {\n                try {\n                    ftp.disconnect();\n                } catch (IOException e) {\n                }\n            }\n        }\n    }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"export": ["process", "output", " exports", "print", "write", "handler", " upload", "module", "io", "fp", "work", "function", "fn", "file", " reporter", " output", "f", " report", "exec", " transform", " fn", " writer"], "lib": ["db", "os", "ruby", "script", "ctx", "src", " libraries", "Lib", "lc", "server", " script", "val", "module", "ler", "editor", "io", "library", "fn", " library", "file", "LIB", "url", " Library", "Library", "data", "lang", "loader", " fn", "local", "log", "dl", "language", " module", " Lib", "l", "bin", "browser", "plugin", "reader", "ld", "loop", "ino", "config", "dll"]}}
{"id1": "20375440", "id2": "7087108", "code1": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        InputStream src = new FileInputStream(srcFile);\n        OutputStream dest = new FileOutputStream(destFile);\n        byte buffer[] = new byte[1024];\n        int read = 1;\n        while (read > 0) {\n            read = src.read(buffer);\n            if (read > 0) {\n                dest.write(buffer, 0, read);\n            }\n        }\n        src.close();\n        dest.close();\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "srcFile": ["srcFiles", " srcDir", "sourcefile", "sourceFiles", "destDir", "destfile", "srcDir", "destFiles", "srcfile", " srcPath", "sourceFile", " srcFiles", "sourcePath", "sourceDir", "srcPath", " srcfile", "rcFile", "rcFiles", "rcPath", "rcfile"], "destFile": ["tempFile", "DestPlace", "destPlace", " destPath", "targetPlace", "DestFile", "Destfile", "destfile", "targetfile", "destFiles", "restPlace", "tempfile", "DestPath", " destfile", "destPath", "targetFiles", "restFiles", "tempPath", "restfile", "tempFiles", "DestFiles", "targetFile", "restFile", " destFiles"], "src": ["in", "sc", "client", "self", "sl", "ctx", "upload", "sec", "stat", "stream", "sync", "rc", "func", "bs", "impl", "slice", "input", "rs", "construct", "RC", "sb", "conn", "loc", "source", "rb", "inst", "cur", "ssl", "img", "proc", "gb", "sup", "dist", "config", "start", "secure", "sr", "sel", "url", "req", "conv", "sq", "loader", "reader", "sys", "cmp", "ser", "ws", "sub", "cb", "ources"], "dest": ["writer", "de", " Dest", "obj", "stream", "cp", "output", "class", "tmp", "comb", "std", "opt", "slave", "thin", "home", "Dest", "ui", "target", "result", "dc", "wh", "desc", "path", "ssl", "img", "proc", "out", "cdn", "sup", "ds", "dist", "end", "dir", "this", "wb", "null", "rest", "des", "div", "temp", "trans", "test", "transform", "d", "destroy", "usr", "dev", "ws", "dat", "source"], "buffer": ["request", "position", "writer", "bytes", "size", "batch", "capacity", "block", "queue", "key", "transfer", "feed", "input", "slice", "layer", "reference", "write", "copy", "Buffer", "limit", "cache", "address", "info", "result", "message", "buff", "raw", "value", "row", "uffer", "iter", "buf", "channel", "null", "base", "data", "b", "offset", "number", "wave", "memory", "bin", "reader", "string", "header", "flush", "source", "length"], "read": ["get", "ind", "ip", "next", "connect", "level", "size", "shape", "sync", "ok", "n", "Read", "block", "i", "key", "default", "use", "feed", "load", "input", "slice", "write", "parse", "copy", "id", "limit", "reads", "check", "run", "open", "seek", "index", "pick", "READ", "not", "show", "sleep", "se", "work", "send", "count", "reading", "find", "fill", "raw", "build", "start", "x", "end", "iter", "close", "no", "pass", "exec", "k", "data", "b", "wait", "number", "ride", "allow", "text", "skip", "reader", "d", "play", "add", "create", "length", "select"]}}
{"id1": "3558512", "id2": "8665649", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private BufferedImage _getImage(String urlStr) throws IOException {\n        URL url = new URL(urlStr);\n        HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n        conn.connect();\n        InputStream in = null;\n        try {\n            in = conn.getInputStream();\n            return ImageIO.read(in);\n        } finally {\n            IOUtilities.close(in);\n        }\n    }\n", "label": 0, "substitutes": {"serialize": ["serialization", "serialized", "Serialze", "Serialization", "finalify", " serialization", " serialze", "normalized", "finalized", "erializable", " serializable", "normalize", "serializable", "erialize", "normalze", "Serializable", "erialization", "Serialize", "Serialized", "Serialify", "serialify", "erialze", "serialze", "normalify", "finalze", "finalize"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "up", "i", "output", "copy", "parent", "ex", "page", "archive", "cache", "server", "conn", "filename", "content", "a", "report", "io", "pool", "raw", "file", "png", "o", "exec", "data", "temp", "err", "loader", "w", "name", "bin", "string", "outs", "gen", "dump", "source", "OUT"], "parser": ["writer", "p", "worker", "upload", "pp", "cp", "master", "class", "instance", "parse", "pkg", "copy", "pillar", "Parser", "handler", "parent", "server", "cache", "per", "tt", "php", "lp", "xml", "manager", "file", "rar", "base", "wrapper", "system", "pe", "builder", "loader", "er", "test", "arser", "processor", "ss", "reader", "as", "plugin", "seed", "up", "txt"], "on_disk": ["on_storage", "onbootlock", "off_demand", "onJdisk", "onjdrive", "onJdrive", "off_lock", "onbootdisk", "onnetdemand", "onJdemand", "onbookdrive", "on_lock", "off_file", "off_drive", "onnetdrive", "onbookdisk", "onJlock", "onbootstorage", "onnetspace", "off_disk", "on_demand", "off_delete", "off_storage", "onnetfile", "onnetdisk", "on_drive", "onjspace", "onjfile", "on_file", "onjdisk", "off_space", "on_delete", "onbootdrive", "on_space", "onbookdelete"], "in": ["r", "pin", "inn", "stream", "i", "socket", "input", "copy", "thin", "din", "conn", "inas", "info", "ax", "lin", "connection", "inner", "ini", "con", "rin", "file", "kin", "min", "f", "o", "pass", "login", "data", "ac", "ins", "bin", "In", "reader", "IN", "again", "as", "win", "source", "c", "inc"]}}
{"id1": "255765", "id2": "17729554", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "7103223", "id2": "17286898", "code1": "    public void testPost() throws Exception {\n        HttpPost request = new HttpPost(baseUri + \"/echo\");\n        request.setEntity(new StringEntity(\"test\"));\n        HttpResponse response = client.execute(request);\n        assertEquals(200, response.getStatusLine().getStatusCode());\n        assertEquals(\"test\", TestUtil.getResponseAsString(response));\n    }\n", "code2": "                public void run() {\n                    BufferedReader reader = null;\n                    String message = null;\n                    int messageStyle = SWT.ICON_WARNING;\n                    try {\n                        URL url = new URL(Version.LATEST_VERSION_URL);\n                        URLConnection conn = url.openConnection();\n                        reader = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                        String latestVersion = reader.readLine();\n                        latestVersion = latestVersion.substring(latestVersion.indexOf(' ') + 1);\n                        if (!Version.getVersion().equals(latestVersion)) {\n                            message = Labels.getLabel(\"text.version.old\");\n                            message = message.replaceFirst(\"%LATEST\", latestVersion);\n                            message = message.replaceFirst(\"%VERSION\", Version.getVersion());\n                            messageStyle = SWT.ICON_QUESTION | SWT.YES | SWT.NO;\n                        } else {\n                            message = Labels.getLabel(\"text.version.latest\");\n                            messageStyle = SWT.ICON_INFORMATION;\n                        }\n                    } catch (Exception e) {\n                        message = Labels.getLabel(\"exception.UserErrorException.version.latestFailed\");\n                        Logger.getLogger(getClass().getName()).log(Level.WARNING, message, e);\n                    } finally {\n                        try {\n                            if (reader != null) reader.close();\n                        } catch (IOException e) {\n                        }\n                        final String messageToShow = message;\n                        final int messageStyleToShow = messageStyle;\n                        Display.getDefault().asyncExec(new Runnable() {\n\n                            public void run() {\n                                statusBar.setStatusText(null);\n                                MessageBox messageBox = new MessageBox(statusBar.getShell(), messageStyleToShow);\n                                messageBox.setText(Version.getFullName());\n                                messageBox.setMessage(messageToShow);\n                                if (messageBox.open() == SWT.YES) {\n                                    BrowserLauncher.openURL(Version.DOWNLOAD_URL);\n                                }\n                            }\n                        });\n                    }\n                }\n", "label": 0, "substitutes": {"testPost": ["testingPost", " testPOST", "testingTest", "Testpost", "testPOST", "TestPost", " testTest", "TestPOST", "TestTest", "testingPOST", "testingpost", "testpost", "testTest", " testpost"], "request": ["next", "get", "client", "buffer", "rate", "query", "upload", "worker", "i", "q", "transfer", "delete", "use", "object", "user", "instance", "reference", "e", "copy", "server", "complete", "address", "open", "child", "result", "http", "resource", "message", "report", "submit", "xml", "send", "build", "post", "url", "req", "throw", "api", "rest", "session", "data", "update", "test", "remove", "application", "method", "call", "document", "Request", "string", "push", "QUEST", "add", "create", "claim", "condition"], "response": ["next", "image", "error", "success", "client", "tree", "block", "full", "output", "reply", "object", "feed", "parent", "environment", "page", "server", "json", "result", "connection", "http", "report", "message", "resource", "index", "pool", "xml", "Response", "out", "resp", "f", "ception", "o", "api", "onse", "session", "data", "collection", "status", "application", "method", "document", "site", "body", "respond"]}}
{"id1": "16557837", "id2": "23666867", "code1": "    public static void copyFromTo(File srcFile, File destFile) {\n        FileChannel in = null, out = null;\n        FileInputStream fis = null;\n        FileOutputStream fos = null;\n        try {\n            fis = new FileInputStream(srcFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + srcFile.toString());\n            System.out.println(\"file does not exist, \" + \"is a directory rather than a regular file, \" + \"or for some other reason cannot be opened for reading\");\n            System.exit(-1);\n        }\n        try {\n            fos = new FileOutputStream(destFile);\n        } catch (FileNotFoundException fnfe) {\n            System.out.println(\"File: \" + destFile.toString());\n            System.out.println(\"file exists but is a directory rather than a regular file, \" + \"does not exist but cannot be created, \" + \"or cannot be opened for any other reason\");\n            System.exit(-1);\n        }\n        try {\n            in = fis.getChannel();\n            out = fos.getChannel();\n            in.transferTo(0, in.size(), out);\n            fos.flush();\n            fos.close();\n            out.close();\n            fis.close();\n            in.close();\n            System.out.println(\"Completed copying \" + srcFile.toString() + \" to \" + destFile.toString());\n        } catch (IOException ioe) {\n            System.out.println(\"IOException copying file: \" + ioe.getMessage());\n            System.exit(-1);\n        }\n        long srcModified = srcFile.lastModified();\n        if (srcModified > 0L && destFile.exists()) {\n            destFile.setLastModified(srcModified);\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFromTo": ["copyFileFrom", "transferFromFile", "transferfromFrom", "transferFromWith", "copyFromWith", "transferFromFrom", "copyfromFile", "copyFileFile", "copyDirTo", "transferfromWith", "copyDirFrom", "copyfromFrom", "transferfromFile", "copyDirWith", "copyFileTo", "transferfromTo", "copyfromTo", "copyfromWith", "copyFromFile", "copyFileWith", "transferFromTo", "copyDirFile", "copyFromFrom"], "srcFile": ["srcFiles", "rcDir", " srcClass", "srcClass", " srcDir", "sourcefile", "sourceFiles", "destDir", "srcPage", "sourceSourceFile", "destfile", "srcDir", "destFiles", "srcfile", " srcPath", "sourceFile", " srcFiles", "sourcePath", "sourceClass", "rcSourceFile", "sourceDir", "srcSourceFile", "srcPath", "destPage", " srcPage", " srcfile", "destClass", "rcFile", " srcSourceFile", "destSourceFile", "rcPage", "rcFiles", "rcPath", "rcfile"], "destFile": [" destinationFilename", "targetDir", "DestSourceFile", "destPlace", " destPath", " destFilename", "srcPlace", "wbFilename", "DestFile", " destDir", "destroyFine", " destSourceFile", " destinationfile", "targetPath", "destDir", " destinationFine", "Destfile", "destFilename", "defaultDir", "srcDir", "destfile", "destFiles", "southPlace", "srcFilename", "DestPath", " destfile", "southFile", " destinationFile", "destroyPage", "targetFiles", "destPath", " destinationPage", "DestDir", " destPage", "defaultfile", " destPlace", "wbFile", "DestFiles", "destPage", " destinationDir", "DestFilename", "defaultFiles", "southDir", "destroyFilename", " destFine", "destroyFile", " destinationFiles", "defaultFile", "destSourceFile", "southFilename", "wbSourceFile", "targetFile", " destFiles", "wbFiles", "destFine"], "in": ["Out", "r", "image", "h", "p", "pin", "n", "inn", "isin", "i", "is", "socket", "init", "cin", "input", "id", "ci", "din", "lin", "connection", "inner", "index", "io", "pull", "nin", "con", "rin", "ini", "file", "part", "x", "inside", "f", "min", "url", "o", "channel", "login", "ac", "err", "b", "ins", "co", "bin", "In", "reader", "IN", "again", "as", "like", "win", "source", "c", "inc"], "out": ["Out", "image", "error", "sync", "query", "key", "comment", "parent", "ger", "ex", "to", "conn", "raw", "post", "store", "prefix", "no", "this", "base", "name", "In", "string", "outs", "window", "cmd", "win", "dump", "OUT", "ico", "client", "off", "user", "input", "page", "cache", "json", "diff", "state", "inner", "io", "file", "part", "down", "err", "net", "again", "lock", "inc", "job", "auto", "writer", "output", "pre", "copy", "cli", "ext", "line", "url", "o", "lib", "channel", "doc", "log", "IN", "point", "outer", "source", "up", "c", "term", "obj", "note", "socket", "ou", "write", "server", "group", "connection", "code", "resource", "exec", "session", "call", "co", "bin", "list", "sys", "extra", "gen"], "fis": ["lis", " foss", "pos", "cfris", "flios", "gis", "fros", "fios", "flos", "cfos", "pis", "fi", "hios", " fris", "pris", "hos", "gi", "FIs", "fIs", "foss", "Fos", "his", "cfios", "flis", "los", "gais", "li", " fIs", "cfis", "cfi", "fli", "fris", " fais", "pIs", "gos", "hi", "cfoss", "frris", "fross", "Fris", "fais", "Fis", "lais", " fi"], "fos": ["lis", "boes", "Faos", " fics", " foes", "eoss", "infose", "flo", "bis", "go", "pos", "foes", "eose", "flos", "eis", "flose", "pis", "faos", "infis", " fout", "po", "foss", "fo", "Fos", "paos", "infoss", "gout", "infos", "los", "tics", "lose", "loss", "toes", "tos", " faos", "fics", "flout", " fo", "gose", "Fo", "bics", "poes", "gos", "bos", " fose", "eos", "Foes", "Fis", "fose", "tis", "fout"], "srcModified": ["srcVerification", "srcmodified", "srcXification", "srcVerified", " srcModed", "srcMetification", "srcMetressed", "srcXed", "sourceModIFIED", "srcMinify", "srcModressed", " srcModined", "srcMinification", "srcMinIFIED", "srcMetified", "srcXined", "srcModification", " srcModIFIED", "srcVerined", "srcMinified", "srcModed", " srcModressed", "sourceModify", "srcmodify", "srcXified", "sourceMinIFIED", " srcModification", "srcMetIFIED", "sourceMinify", "sourceModification", "srcmodressed", "srcVered", "srcmodIFIED", "srcModIFIED", "sourceMinification", "sourceModified", "srcModined", "sourceMinified", "srcModify", "srcmodification"]}}
{"id1": "8385785", "id2": "6756635", "code1": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 1, "substitutes": {"MD5": ["MP5", " MD512", "MP4", "MP512", " MD4", " MD8", "SHA8", "SHA5", "MD4", "SHA4", "SHA512", "MP8", "MD8", "MD512"], "text": ["font", "image", "in", "buffer", "template", "bytes", " Text", "key", "class", "pattern", "object", "output", "input", "Text", "version", "code", "format", "content", "path", "message", "TEXT", "ext", "editor", "word", "EXT", "str", "url", "letter", "this", "binary", "prefix", "data", " TEXT", "struct", "secret", "test", "token", "number", "contract", "name", "password", "string", "source", "config", "length", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncagingException", "UnsupportedEncagingception", "UnsupportedEncasingATION", "UnsupportedEncodedception", "UnsupportedEncodingception", "Unsupportedencodedception", "UnsupportedEncodedException", "UnsupportedEncasingception", "Unsupportedencodingception", "UnsupportedEncodingATION", "UnsupportedEncasingException", "UnsupportedEncodedATION", "UnsupportedencodingException", "UnsupportedEncagingATION", "UnsupportedencodingATION", "UnsupportedencodedException", "UnsupportedencodedATION"], "md": ["mac", "mm", "mo", "match", "m", "Cmd", "dig", "bf", "pg", "ad", "pd", "valid", "metadata", "ma", "cd", "code", "od", "rm", "message", "mb", "amd", "cm", "nm", "df", "manager", "wd", "mand", "bd", "mg", "dm", "mode", "data", "pm", "sha", "mt", "MD", "method", "mp", "di", "me", "mc", "mod", "mag", "hd", "d", "body", "vd", "rpm", "ld", "ms", "meta", "hash", "cmd", "docker", "dd", " MD"], "md5hash": ["md5sum", "md8Hash", "md6Hash", "md5Hash", "mand53html", "md6kh", "mand5version", "md4Hash", " md5kh", "md4hex", " md6hash", "md2kh", "md53Hash", "mddownhash", "md2hash", "md5hex", "md8hash", "mddownHash", "md6hex", "md25Hash", "mand53Hash", "md5html", "mand5hash", "md25html", "md4sum", "mand53hash", "md53version", "md6sum", "mddownsum", "md2version", "md53html", "mand53version", "md6hash", "mand5Hash", " md6Hash", "md4hash", "md5version", "mddownkh", "md2sum", " md5sum", " md5hex", "md5kh", " md6sum", " md5Hash", "mand5html", "md25version", "md8sum", "md2Hash", " md6kh", "md53hash", "md8hex", "md25hash", " md6hex", "md2html"]}}
{"id1": "12066447", "id2": "6756635", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public static String MD5(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "label": 0, "substitutes": {"truncate": ["tratenator", "trunational", "trrenate", "trunator", "trunate", "truncation", "autuncational", "autuncation", "tratenational", "autatenation", "autuncator", "truncator", "tratenation", "autatenator", "tratenate", "autuncate", "autatenational", "autatenate", "trrenator", "truncational", "trrenation", "trrenational", "trunation"], "file": ["get", "image", "db", "one", "stream", "full", "files", "queue", "class", "object", "future", "e", "parent", "page", "directory", "handler", "archive", "File", "cache", "address", "per", "plus", "info", "or", "format", "connection", "http", "path", "resource", "fp", "single", "io", "time", " File", "out", "function", "FILE", "ile", "line", "f", "url", "binary", "this", "base", "model", "zip", "data", "type", "log", "local", "it", "document", "name", "l", "body", "string", "folder", "uri", "current", "source", "filename"], "backupRoot": ["backupsPath", "backUproot", "backupsRoot", "backdownRoot", "backuproot", "backdownroot", "Backbackroot", "backupDirectory", "backUpDir", "backflowroot", "backureDirectory", "frontdownroot", "backflowDir", "frontdownFolder", "frontupDir", "BackureRoot", "backbackroot", "backbaseDirectory", "backupDir", "BackdownRoot", "BackureDirectory", "frontuproot", "backupHome", "backbackDir", "backupFile", "Backuproot", "BackupHome", "backUpFolder", "backflowRoot", "backbaseRoot", "backbackFile", "backUpRoot", "BackupRoot", "backureDir", "BackupDirectory", "backdownDir", "backdownHome", "backbaseroot", "backureRoot", "backbackHome", "backdownFolder", "backupsDir", "backdownDirectory", "backbasePath", "BackupPath", "backureHome", "backflowFile", "frontupFolder", "backdownFile", "frontdownRoot", "BackbackRoot", "frontupRoot", "frontdownDir", "backupsFolder", "BackdownDirectory", "backbackDirectory", "BackdownPath", "backupsroot", "backupPath", "BackbackFile", "backupFolder", "BackureDir", "BackbackDir", "backdownPath", "Backdownroot", "BackupFile", "backupsDirectory", "backbackRoot", "BackupDir", "BackureHome"], "df": ["db", "pdf", "fr", "de", "bf", "def", "flow", "fd", "dict", "cf", "pd", "xf", "md", "sf", "fe", "dn", "format", "dc", "fb", "af", "deb", "fp", "dt", "io", "raf", " def", "fn", "fc", "ds", "f", "fs", "CF", "dm", "data", "dl", "DF", "di", "d", "tf", "da", "dq", "dd", "func", "dp"], "date": ["db", "stage", "atom", "m", "j", "sync", "fee", "form", "output", "pre", "use", "created", "input", "year", "version", "bug", "valid", "rule", "complete", "open", "diff", "updated", "module", "format", "code", "time", "day", "D", " Date", "dt", "message", "modified", "work", "dat", "out", "value", "str", "ale", "days", "x", "min", "ge", "url", "update", "data", "type", "pe", "log", "tag", "ate", "dose", "name", "custom", "d", "string", "age", "style", "Date", "re", "back", "create", "dates"], "zipFile": ["zfile", "zFiles", "ressModel", "ZipFiles", "ZipEntry", " zipFiles", "sqlfile", "zipfile", "ZipFile", "zFile", "sqlModel", "Zipfile", "zEntry", "ressfile", "zipEntry", " zipfile", "ressFile", "zipFiles", "zModel", "zipModel", "zSection", "ressSection", "zipSection", "sqlSection", "sqlFile", " zipEntry"], "zos": ["os", "ils", "dylib", "inos", "nox", "dos", "zag", "zb", "proxy", "uz", "ls", "lins", "ses", "han", "ros", "zon", "css", "iffs", "zan", "address", "zn", "bitcoin", "zy", "los", "zona", "zx", "tz", "liquid", "zi", "cos", "zero", "bes", "jas", "hess", "exit", "ssl", "z", "nz", "closure", "budget", "rez", "osi", "ZA", "zo", "cash", "zar", "zen", "zip", "eros", "chini", "zes", "her", "las", "zik", "ozo", "zer", " sands", "fits", "ops", "settings", "forge", "bos", "zzy", "obb", "robe", "js", "gz", "outs", "zh", "kos", "webkit", "asio", "zl"], "fis": ["lis", "flisp", "rafis", " fiz", "viz", " fias", " fos", "vis", "bis", "infias", "flris", "bisl", "Fisl", " fisl", "fiz", "fias", "infis", " fris", "flias", "rafris", "Fos", "rafiss", "infils", "flis", "fliss", "rafias", "infiss", " fiss", "fisp", "infits", "biss", "flids", "lids", "fids", "vits", "fris", " fils", "fisl", "infids", "fiss", "Fias", "lias", "fits", " fits", "fils", "liss", "bos", " fisp", "fos", "Fris", "infiz", "Fis", "vils", "Fisp", "Fiss"], "entry": ["next", "r", "image", "auto", "the", "ace", "de", "card", "obj", "term", "ie", "element", "cel", "key", "cell", "comment", "feed", "e", "lc", "ry", "archive", "server", "address", "per", "info", "ui", "or", "array", "exp", "index", "se", "z", "row", "ge", "zo", "letter", "zip", "data", "her", "offset", "it", "record", "ries", "so", "Entry", "style", "reader", "ion", " Entry", "si", "and", "uri", "extra", "add", "event"], "buffer": ["position", "pad", "writer", "bytes", "shape", "batch", "FFER", "queue", "transfer", "comment", "feed", "slice", "sequence", "reference", "bb", "page", "Buffer", "cache", "server", "address", "result", "padding", "beta", "buff", "row", "uffer", "available", "iter", "buf", "binary", "channel", "device", "null", "data", "b", "border", "number", "wave", "memory", "reader", "header", "seed", "vector", "flush", "layer", "length"], "readed": ["readered", "readED", "intended", "bootable", " ReadED", "inputned", " readended", " readered", "readized", "inted", "bootED", " readED", " readable", "readable", "inputled", " Readered", "readned", " Readed", " readized", "inputED", "bootered", " readned", "textended", " Readable", " Readled", " Readned", "texted", "readended", "intED", "textized", " readled", "booted", "textED", "intized", "inputed", "readled"]}}
{"id1": "21995302", "id2": "23666867", "code1": "        public void open(Input input) throws IOException, ResolverException {\n            if (!input.isUriDefinitive()) return;\n            URI uri;\n            try {\n                uri = new URI(input.getUri());\n            } catch (URISyntaxException e) {\n                throw new ResolverException(e);\n            }\n            if (!uri.isAbsolute()) throw new ResolverException(\"cannot open relative URI: \" + uri);\n            URL url = new URL(uri.toASCIIString());\n            input.setByteStream(url.openStream());\n        }\n", "code2": "    public static void copyFile(File in, File out) {\n        try {\n            FileChannel inChannel = null, outChannel = null;\n            try {\n                out.getParentFile().mkdirs();\n                inChannel = new FileInputStream(in).getChannel();\n                outChannel = new FileOutputStream(out).getChannel();\n                outChannel.transferFrom(inChannel, 0, inChannel.size());\n            } finally {\n                if (inChannel != null) {\n                    inChannel.close();\n                }\n                if (outChannel != null) {\n                    outChannel.close();\n                }\n            }\n        } catch (Exception e) {\n            ObjectUtils.throwAsError(e);\n        }\n    }\n", "label": 0, "substitutes": {"open": ["opening", "process", "get", " OPEN", "ize", "stream", " opening", "use", "load", "init", "parse", "write", "to", " transfer", "handle", "resource", " reopen", "oc", "xml", "change", "Open", "build", "start", "end", "en", "close", "o", " opened", "set", "update", " start", " close", " Open", "it", "un", " opener", "res", "fix", "add", "re", "create", "initial"], "input": ["request", "image", "error", "in", "client", "buffer", "accept", "upload", "element", "argument", "stream", "ink", "i", "output", "socket", "class", "object", "form", "context", "feed", "instance", "inf", "state", "connection", "http", "inner", "container", "resource", "audio", "io", "pull", "ssl", "out", "file", "this", "base", "exec", "data", "type", "temp", "keep", "Input", "text", "document", "reader", "command", "event", "current", "source", "config", "inc", "PUT"], "uri": ["next", "image", "absolute", "iri", "service", " URI", "ki", "element", "eni", "i", "object", "URI", "instance", "id", "abi", "cli", "directory", "gi", "ci", "route", "address", "origin", "picture", "ui", "info", "result", "state", "adi", "connection", "http", "li", "resource", "response", "path", "io", "direction", "manager", "uni", "file", "str", "pi", "uid", "prefix", "api", "base", "definition", "ri", "data", "database", "mi", "via", "document", "di", "string", "si", "verb", "bridge", "qi", "doi", "source", "username"], "url": ["ball", "buffer", "sl", "stream", "i", "socket", "feed", "impl", "ls", "id", "server", "coll", "address", "bel", "source", "state", "connection", "http", "li", "URL", "resource", "io", "ref", "path", "ob", "ssl", "file", "link", "f", "Url", "api", "base", "channel", "plug", "data", "b", "char", "text", "l", "browser", "string", "layer", "config"]}}
{"id1": "21363911", "id2": "1586662", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    int doOne(int bid, int tid, int aid, int delta) {\n        int aBalance = 0;\n        if (Conn == null) {\n            bench.incrementFailedTransactionCount();\n            return 0;\n        }\n        try {\n            if (Benchmark.prepared_stmt) {\n                pstmt1.setInt(1, delta);\n                pstmt1.setInt(2, aid);\n                pstmt1.executeUpdate();\n                pstmt1.clearWarnings();\n                pstmt2.setInt(1, aid);\n                ResultSet RS = pstmt2.executeQuery();\n                pstmt2.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                pstmt3.setInt(1, delta);\n                pstmt3.setInt(2, tid);\n                pstmt3.executeUpdate();\n                pstmt3.clearWarnings();\n                pstmt4.setInt(1, delta);\n                pstmt4.setInt(2, bid);\n                pstmt4.executeUpdate();\n                pstmt4.clearWarnings();\n                pstmt5.setInt(1, tid);\n                pstmt5.setInt(2, bid);\n                pstmt5.setInt(3, aid);\n                pstmt5.setInt(4, delta);\n                pstmt5.executeUpdate();\n                pstmt5.clearWarnings();\n            } else {\n                Statement Stmt = Conn.createStatement();\n                String Query = \"UPDATE accounts\";\n                Query += \" SET Abalance = Abalance + \" + delta;\n                Query += \" WHERE Aid = \" + aid;\n                int res = Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"SELECT Abalance\";\n                Query += \" FROM accounts\";\n                Query += \" WHERE Aid = \" + aid;\n                ResultSet RS = Stmt.executeQuery(Query);\n                Stmt.clearWarnings();\n                while (RS.next()) {\n                    aBalance = RS.getInt(1);\n                }\n                Query = \"UPDATE tellers\";\n                Query += \" SET Tbalance = Tbalance + \" + delta;\n                Query += \" WHERE Tid = \" + tid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"UPDATE branches\";\n                Query += \" SET Bbalance = Bbalance + \" + delta;\n                Query += \" WHERE Bid = \" + bid;\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Query = \"INSERT INTO history(Tid, Bid, Aid, delta)\";\n                Query += \" VALUES (\";\n                Query += tid + \",\";\n                Query += bid + \",\";\n                Query += aid + \",\";\n                Query += delta + \")\";\n                Stmt.executeUpdate(Query);\n                Stmt.clearWarnings();\n                Stmt.close();\n            }\n            if (Benchmark.transactions) {\n                Conn.commit();\n            }\n            return aBalance;\n        } catch (java.lang.Exception e) {\n            if (Benchmark.verbose) {\n                System.out.println(\"Transaction failed: \" + e.getMessage());\n                e.printStackTrace();\n            }\n            bench.incrementFailedTransactionCount();\n            if (Benchmark.transactions) {\n                try {\n                    Conn.rollback();\n                } catch (SQLException e1) {\n                }\n            }\n        }\n        return 0;\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testtransacts", "testTransact", "testtransact", "testTacts", " testTransacts", "testTransactionact", "testTaction", "testTransactionactions", "testtransaction", "testTransactionaction", "testTactions", "testTact", "testTransactionacts", " testtransactions", "testTransacts", "testtransactions", "testTransaction", " testtransact", " testtransaction", " testTransaction", " testTransact", " testtransacts"], "con": ["db", "an", "client", "connect", "ca", "ain", "sync", "ctx", "cond", "rc", "cn", "cc", "common", "cons", "cr", "CON", "po", "cf", "core", "com", "cache", "coll", "run", "const", "conn", "ran", "connection", "ver", "ec", "bc", "cm", "conf", "xc", "fc", "crit", "Con", "pub", "uc", "en", "min", "ctrl", "col", "don", "enc", "close", "exec", "sql", "conv", "x", "ac", "can", "log", "cl", "contract", "pc", "ct", "co", "fac", "un", "ocon", "mc", "custom", "pen", "act", "win", "pl", "create", "c", "pr", "condition"], "st": ["ST", "r", "sts", "db", "sc", "fr", "la", "ck", "sw", "sl", "tx", "sync", "St", "rd", "src", "ste", "rc", "s", "std", "cr", "sa", "sn", "ut", "ist", "t", "sb", "const", "sh", "fe", "ks", "inst", "bl", "se", "td", "sy", "sta", "str", "en", "est", "set", "rest", "pe", "put", "cl", "mt", "pc", "ct", "co", "l", "ost", "ss", "d", "ld", "sth", "ust", "act", "pl", "pt", "c", "pr", "sp"], "rs": ["r", "rys", "details", "sw", "yrs", "RS", "tx", "arms", "qs", "rd", "rl", "src", "rc", "cs", "s", "Rs", "bs", "xs", "ls", "cr", "ns", "rx", "ows", "ros", "maps", "ges", "ris", "lines", "ks", "dr", "vers", "rss", "pers", "ras", "results", "rr", "ra", "row", "ds", "str", "changes", "hr", "sr", "mr", "ts", "ars", "ans", "rt", "errors", "hs", "kr", "rows", "ins", "ys", "co", "vs", "acks", "res", "ss", "ums", "ps", "rors", "runs", "ws", " RS", "pr", "repl"]}}
{"id1": "947406", "id2": "17999474", "code1": "    static void copy(String src, String dest) throws IOException {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) > 0) out.write(buf, 0, n);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "code2": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "label": 1, "substitutes": {"copy": ["get", "clone", "p", "sync", "cp", "transfer", "Copy", "write", "cat", " cp", "replace", "Cop", "clip", "cop", "csv", "file", "zip", "download", "log", "paste", "put", "split", "it", " Copy", "cmp", "dump", " transfer"], "src": ["sc", "sl", "stream", "files", "rc", "use", "s", "input", "sit", "rs", "id", "sin", "sb", "loc", "source", "rb", "inst", "resource", "cur", "stab", "gb", "img", "fn", "dist", "config", "bh", "sel", "url", "data", "sq", "ins", "name", "string", "js", "href", "uri", "ource", "sub", "filename", "rob", "txt"], "dest": ["de", "obj", " Dest", "output", "delete", "class", "tmp", "comb", "opt", "thin", "const", "home", "Dest", "replace", "target", "result", "desc", "orig", "later", "img", "wd", "sup", "dist", "dir", "die", "st", "wb", "rest", "des", "temp", "flat", "done", "test", "name", "bin", "d", "prop", "folder", "destroy", "dat", "source", "txt"], "in": ["r", "m", "pin", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "cf", "din", "conn", "info", "diff", "lin", "a", "inner", "vin", "pull", "nin", "con", "ini", "rin", "kin", "work", "url", "lib", "pass", "base", "this", "login", "data", "err", "download", "b", "trans", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "issue", "source", "up", "inc"], "out": ["Out", "image", "os", "timeout", "client", "writer", "plain", "sync", "one", "off", "obj", "up", "output", "socket", "app", "init", "ou", "user", "write", "id", "ex", "aos", "cache", "conn", "or", "exp", "ext", "index", "our", "io", "inner", "exit", "nin", "pool", "img", "file", "at", "part", "x", "o", "no", "exec", "this", "lib", "data", "err", "vert", "log", "w", "net", "call", "bin", "again", "outs", "outer", "source", "OUT", "inc"], "buf": ["fab", "pad", "bp", "buffer", "bytes", "seq", "batch", "p", "bf", "ctx", "pos", "block", "br", "off", "ff", "ab", "fd", "rc", "queue", "bn", "fl", "loc", "result", "bc", "rb", "fb", "num", "orig", "ref", "cur", "buff", "raw", "count", "uc", "box", "len", "bh", "bag", "bd", "f", "feat", "data", "b", "cv", "v", "cap", "uf", "bin", "nb", "cb", "c"], "n": ["ind", "ne", "m", "j", "p", "size", "max", "i", "na", "nn", "write", "ns", "nt", "sn", "ng", "t", "N", "length", "dn", "nc", "index", "num", "nin", "z", "count", "nr", "len", "x", "en", "f", "no", "o", "k", "u", "b", "v", "w", "nd", "number", "rn", "l", "un", "d", "nb", "c"]}}
{"id1": "23402240", "id2": "3375718", "code1": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "code2": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "label": 1, "substitutes": {"actualizarNdivisiones": [" actualizarNisionen", " actualizarNiones", " actualizarNionen", " actualizarNdivisione", " actualizarMdivisiones", " actualizarMdive", " actualizarMdivisione", " actualizarNdivisionen", " actualizarNdive", " actualizarMdivisionen", " actualizarMdives", " actualizarNdivis", " actualizarMdivis", " actualizarNdiven", " actualizarNione", " actualizarNionis", " actualizarNisionis", " actualizarNisione", " actualizarMdiven", " actualizarNdives", " actualizarNisiones", " actualizarMdivisionis", " actualizarNdivisionis"], "idTorneo": ["idFordeo", "idForneoid", "idTorioid", "idTrone", "idTorie", "idTorio", "idForneo", "idFordeos", "idFordeof", "idForneof", "idTorios", "idTordeof", "idTordeoid", "idTordeos", "idTenseo", "idTendone", "idFordeoid", "idTordeo", "idTorneof", "idTronof", "idTenseos", "idFornee", "idTrono", "idTenseof", "idTorneos", "idTendono", "idTendonoid", "idTensee", "idTorneoid", "idForneos", "idTronos", "idTornee", "idTendonos", "idTordee", "idFordee"], "nDivisiones": ["nDivisionse", "nDIVisionales", "nDivisionsales", "nDivione", "nDiviones", "nDivitionales", "nDivionES", "nDivisionses", "nDIVisionsales", "nDIVisionES", "nDIVisionses", "nDivisionsES", "nDivisione", "nDivionions", "nDivisionsions", "nDivitione", "nDivitionions", "nDIVisionse", "nDivitionES", "nDivitiones", "nDivisionions", "nDivisionES", "nDIVisiones", "nDIVisionsES", "nDivisionales", "nDIVisione", "nDivionales"], "intResult": ["IntReturn", "intResults", "floatResult", "floatRes", "intRes", "floatReturn", "intTr", "floatresult", " intResponse", "floatTr", "INTReturn", " intResults", "boolResults", "boolResult", "intReturn", "ntTr", "colResponse", "floatResponse", "floatResults", "ntResult", "IntResponse", "intresult", "INTResult", " intReturn", " intresult", "boolresult", "boolReturn", "ntRes", "colTr", " intRes", "INTResponse", "colResult", "intResponse", "ntResponse", "IntRes", "IntResult", "INTRes", "colRes"], "sql": ["job", "db", "query", "sl", "sync", "QL", "q", "comment", "pg", "s", "action", "install", "ls", "section", " SQL", "SQL", "conn", "params", "ssl", "fn", "str", "url", "base", "pass", "zip", "serv", "sq", "log", "printf", "dl", "database", "shell", "l", "ql", "string", "seed", "setup", "cmd", "up", "select", "repl"], "connection": ["position", "db", "client", "connect", "BC", "writer", "query", "ctx", "relation", "socket", "proxy", "context", "pg", "environment", "section", "po", "statement", "lc", "port", "server", "coll", "cache", "conn", "loc", "que", "container", "index", "pool", "manager", "con", "function", "tc", "connected", "unit", "session", "log", "database", "collection", "application", "document", "table", "mc", "ongo", "ion", "communication", "Connection", "event", "config", "c", "condition"], "ps": ["ppa", "process", "os", "ups", "p", "PS", "script", "pp", "pos", "qs", "pa", "cp", "cs", "bs", "proxy", "pg", "par", "rs", "ls", "ips", "po", "pd", "per", "ks", "pointer", "params", "cop", "proc", "ds", "ts", "relations", "pe", "eps", "pc", "mp", "settings", "Ps", "vs", "processor", "ss", "pse", "gs", "pps", "ms", "pt", "pr"]}}
{"id1": "12389873", "id2": "10728243", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    private byte[] scramble411(String password, String seed) {\n        MessageDigest md;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            byte[] passwordHashStage1 = md.digest(password.getBytes());\n            md.reset();\n            byte[] passwordHashStage2 = md.digest(passwordHashStage1);\n            md.reset();\n            md.update(seed.getBytes());\n            md.update(passwordHashStage2);\n            byte[] toBeXord = md.digest();\n            int numToXor = toBeXord.length;\n            for (int i = 0; i < numToXor; i++) {\n                toBeXord[i] = (byte) (toBeXord[i] ^ passwordHashStage1[i]);\n            }\n            return toBeXord;\n        } catch (NoSuchAlgorithmException e) {\n            if (logger.isLoggable(Level.SEVERE)) {\n                logger.log(Level.SEVERE, e.getMessage(), e);\n            }\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"load": [" reload", "get", "process", "clone", "loading", "save", "sync", "transfer", "init", " loaded", "construct", " Load", "write", " loading", "ready", "Loading", "build", " loads", "link", "download", "Load", "test", "add", "read", "dump", "config", "select"], "conn": ["db", "pt", "client", "connect", "ca", "Conn", "h", "p", "ctx", "n", "cp", "cc", "cn", "pg", "ls", "ns", "cat", "cr", "nt", "ci", "cache", "coll", "sb", "reg", "ann", "loc", "Exec", "dn", "state", "connection", "dc", "nc", "con", "conf", "dh", "pub", "util", "oci", "ch", "enc", "sql", "exec", "col", "session", "rt", "ct", "pc", "co", "mc", "Connection", "act", "config", "c", "pr", "ec"], "stmt": ["strs", "STnt", "Stml", "elrs", "STmn", "astql", "putml", "slr", "Stmc", "STct", "ostmt", "stmd", "slnt", " stor", "putur", "playtr", "stpl", "putmb", "Stmb", "sttor", "str", "actmt", " stmi", "playml", "estmt", "STpl", " stpl", "stpr", "stm", "acttr", "Stnt", " stml", "ostager", "atmt", "tm", "Stbt", "dmt", "stmn", "Stdb", "plb", "themc", " stbl", "Stb", "dmd", "stql", "putbt", "fldo", " stm", "estdo", "stmr", "Stager", "Stmr", "atmn", "plmn", " sttor", " stmn", "stmi", "tmt", "atMT", "flmd", "astmn", "Stmd", "flk", "plmt", "cltr", "slager", "playmt", "stmc", "stur", "Stts", "STager", " sttr", "stMT", "strmt", "estth", " str", " stts", "STmt", "playor", "ostpr", "dnt", "putmi", "clmt", "actbl", "estql", "themt", " stmb", "astk", "Stbl", " stager", "Stmt", "Stmn", "tpl", "stbt", "estk", "putmt", "estmd", "strk", "Stur", " stct", "Stm", " stdb", "osttr", " stpr", " stk", "STql", "dMT", "sttr", "stager", "Sttor", "ostmn", "elml", "atb", "plnt", "ostct", "acttor", " stmc", "strmd", "ostpl", " strs", "strdo", "STmd", "Sttr", "stnt", "Stct", "tct", "estMT", "esttr", "stmb", "puttr", "putmn", "slmn", "stdb", " stmr", " stMT", "STMT", "putts", "stml", "stdo", "clmn", "stbl", "flmt", "elmt", " stb", "STbl", "stts", "slmt", "stor", "plMT", "StMT", "plr", "putrs", "Stql", "estmr", " stbt", "themn", "elmi", "stb", " stql", "Stor", "stct", "stk", " stnt", "STml", "theb", "playmn", " stth", "slk", "Stth", "estct", "stth", "clur", "astmt", "Stpl", "STk", "playpl", "STdb", "Stpr"]}}
{"id1": "4937535", "id2": "2113444", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private VelocityEngine newVelocityEngine() {\n        VelocityEngine velocityEngine = null;\n        InputStream is = null;\n        try {\n            URL url = ClassPathUtils.getResource(VELOCITY_PROPS_FILE);\n            is = url.openStream();\n            Properties props = new Properties();\n            props.load(is);\n            velocityEngine = new VelocityEngine(props);\n            velocityEngine.init();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not find velocity props file, file=\" + VELOCITY_PROPS_FILE, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n        return velocityEngine;\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProps", "loadPropertyps", "loadProproperties", "loadPperties", "getprops", "getProproperty", "loadPropertyperties", "getproperties", "loadProproperty", "loadPropertyproperty", "loadPproperties", "loadproproperty", "loadproperties", "loadproproperties", "getProps", "getProproperties", "getproproperty", "loadPps", "loadprops", "getProperties", "getproproperties", "loadPproperty", "loadPropertyproperties"], "properties": ["os", "perties", "details", "ils", "obj", "styles", "types", "notes", "limits", "fixes", "object", "prototype", "ls", "ips", "events", "features", "address", "gets", "lines", "objects", "info", "property", "reports", "posts", "params", "resources", "results", "pb", "options", "values", "groups", "bugs", "fps", "settings", "utils", "table", "style", "prop", "pro", "parts", "ps", "ports", "pps", "beans", "rules", "tests", "plugins"], "url": ["r", "image", "in", "client", "buffer", "sl", "element", "entry", "i", "class", "object", "user", "instance", "ls", "page", "server", "bel", "address", "connection", "http", "URL", "resource", "path", "not", "xml", "file", "f", "Url", "api", "base", "channel", "data", "gl", "loader", "b", "org", "article", "name", "l", "reader", "string", "uri", "event", "source"]}}
{"id1": "8329093", "id2": "6036012", "code1": "    public void parse(ParserEvent event) {\n        logger.debug(\"parse() called for link \" + event.getLink().getURI());\n        if (event.getLink().getURI().matches(itemFilter)) {\n            logger.debug(\"Content \" + event.getLink().getURI() + \" matched\");\n            Statement stmt = null;\n            ResultSet rs = null;\n            long checksum1 = 0;\n            try {\n                URL url = new URL(event.getLink().getURI());\n                checksum1 = url.openConnection().getLastModified();\n            } catch (MalformedURLException mfe) {\n                logger.error(\"Malformed url \" + event.getLink().getURI() + \" - \" + mfe.getMessage());\n                return;\n            } catch (IOException ioe) {\n                logger.error(\"Couldn't read \" + event.getLink().getURI() + \" - \" + ioe.getMessage());\n                return;\n            }\n            if ((checksum1 == 0) || (checksum1 == 1)) {\n                Adler32 adler32 = new Adler32();\n                NodeList nodes = (NodeList) event.getPageData().getData();\n                adler32.update(nodes.toHtml().getBytes());\n                checksum1 = adler32.getValue();\n            }\n            try {\n                stmt = conn.createStatement();\n                rs = stmt.executeQuery(\"SELECT * FROM documents WHERE url='\" + event.getLink().getURI() + \"'\");\n                if (rs.first()) {\n                    long checksum2 = rs.getLong(\"checksum\");\n                    if (checksum1 == checksum2) {\n                        stmt.executeUpdate(\"UPDATE documents SET checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    } else {\n                        stmt.executeUpdate(\"UPDATE documents SET checksum=\" + checksum1 + \", checked=\" + String.valueOf(System.currentTimeMillis()) + \" WHERE id=\" + rs.getString(\"id\"));\n                    }\n                } else {\n                    stmt.executeUpdate(\"INSERT INTO documents VALUES \" + \"(DEFAULT, '\" + event.getLink().getURI() + \"', \" + checksum1 + \", '\" + providerId + \"', \" + String.valueOf(System.currentTimeMillis()) + \")\");\n                }\n            } catch (SQLException e) {\n                logger.error(\"Could't perform database query or update - \" + e.getMessage());\n            } finally {\n                if (rs != null) {\n                    try {\n                        rs.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    rs = null;\n                }\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException sqlEx) {\n                    }\n                    stmt = null;\n                }\n            }\n        }\n    }\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"parse": [" dissect", "process", " build", " merge", " setup", " assemble", "arse", " scan", " serve", " split", "Parser", "patch", "apply", "replace", "info", " sniff", "handle", " extract", "se", "pack", " parser", " parsing", " discover", " explode", " patch", " analyse", "parser", " read"], "event": ["actual", "request", "image", "error", "original", "element", "g", "entry", "stream", "author", "version", "flow", "ce", "object", "view", "comment", "context", "load", "input", "action", "instance", "app", "e", "user", "vent", "events", "attribute", "handler", "environment", "parent", "cache", "address", "open", "info", "source", "result", "content", "response", "message", "resource", "xml", "function", "x", "ev", "this", "update", "data", "type", "v", "text", "Event", "other", "document", "entity", "node", "style", "item", "layer", "config"], "stmt": [" stm", "rql", "stbl", "dql", " stct", "Stm", "STmn", " stmn", "tmd", "tmt", "Stmd", "stmd", "rpt", "admd", "adart", "spmt", "spmd", " stmd", "spart", "rnt", "Stmb", "tmn", "STmt", "rmt", "admt", "start", "tbl", "adql", "STmd", "stct", "dnt", " stpt", "adnt", "stm", "adbl", " start", " stmb", "spbl", "tm", "Stbl", "tmb", "stnt", "dmt", "Stmt", "stmn", "tpt", "adpt", "Stct", "tct", "STm", "Stpt", "stmb", " stbl", "stql", "stpt", "dpt"], "rs": ["stats", "eers", "r", "vals", "rys", "details", "RS", "qs", "rd", "src", "rc", "cs", "Rs", "bs", "otes", "xs", "ls", "nas", "events", "odes", "ows", "RC", "ros", "maps", "ges", "ris", "lines", "ks", "sels", "result", "vers", "rss", "obs", "ras", "resources", "results", "rr", "ds", "hr", "sr", "mr", "relations", "ts", "opens", "icks", "ars", "rt", "hs", "rows", "ins", "ys", "acks", "res", "ps", "gs", "runs", "ms", "ats", "ws", "pr", "repl"], "checksum1": ["checksummer91", "checksull1", "checksque2", " checkssumOnce", "checksumOne", "checksnum0", "checkssumOne", "checksum61", "checksUMOne", " checksum0", "checksumOnce", "checksull61", "checkssum1", "checksumbOne", "checksnum91", "checkssum91", " checksum61", "checksnumOne", "checksummer2", "checksnum2", "checksumi1", "checksumbOnce", "checksnum61", "checksums2", "checksummer1", "checksque0", "checksUM1", "checksUM3", "checksum91", "checksque100", " checkssum3", " checksumOnce", " checkssum91", "checksam0", "checksam2", " checkssum1", "checksums1", "checksumsOnce", " checksum3", "checksumi2", "checksUM2", "checksum100", "checksum3", " checkssum100", "checksam1", " checkssum0", "checksummOne", "checksumsOne", "checksumi3", " checkssumOne", "checkssum0", " checkssum61", " checkssum2", "checkssum100", "checksumb1", "checkssum3", " checksum91", "checksumm1", " checksumOne", " checksum100", "checksam100", "checkssum2", "checkssum61", "checksque1", "checksnum3", "checksum0", "checksumm2", "checksullOne", "checkssumOnce", "checksummer0", "checksumb2", "checksnum1", "checksull2"], "url": ["r", "image", "ball", "job", "blog", "buffer", "match", "error", "sl", "ul", "html", "stream", "Link", "object", "el", "impl", "fl", "user", "URI", "ls", "id", "page", "server", "coll", "address", "bel", "conn", "loc", "connection", "http", "location", "URL", "resource", "content", "pull", "ob", "path", "xml", "ssl", "message", "file", "link", "f", "Url", "channel", "base", "api", "data", "b", "org", "ll", " URL", "text", "l", "string", "web", "uri", "orb", "layer", "www"], "adler32": ["aclr32", "adle32", "adler52", "adger16", "adger40", " adler16", "adlr52", " adler2", "adger2", "adlor2", "acler32", "adler40", "adlr32", " adler40", "acler16", " adlr32", "aclr52", "adlor32", "adlor52", "adler31", " adger32", " adger40", " adlr16", "acler52", "adler2", " adger31", "adger31", "adlr2", "adder31", " adger16", "aclr16", "aclr2", "adle16", "adlor16", " adler31", " adlr40", "adlr16", "adder16", "adler16", "adlr31", "adlr40", " adlr2", "adle2", "adle40", "acler2", "adger52", "adger32", "adder32", "adder40"], "nodes": ["Nods", "Nents", "sods", "sode", "tode", "nubes", "tods", "sodes", "nods", " node", "sents", "Node", " nubes", "snobs", "nents", "todes", "tents", "snode", "snubes", "Nodes", "node", " nobs", "Nobs", "snodes", "nobs", "Nubes"], "checksum2": ["checksummer82", "checksha1", "checksums2", " checkssum82", " checksum82", "checkssum2", "checksub0", "checksha2", "checksummer1", " checksum0", "checksum82", "checksum0", " checkssum0", "checksub1", "checkssum82", "checkssum1", "checksha82", "checksub2", "checksummer0", "checksha0", "checksums0", "checkssum0", " checkssum2", "checksummer2", " checkssum1", "checksums1"]}}
{"id1": "12389873", "id2": "21531069", "code1": "    private void load() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (100, 'Living Thing')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (200, 'Inanimate Object')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (300, 'Dog')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (400, 'Sheltie')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (500, 'Eskimo')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (600, 'Person')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (700, 'Collar')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (800, 'Ball')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (401, 'Fido')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (501, 'Samantha')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (801, 'A collar')\");\n            stmt.executeQuery(\"select setval('objects_objectid_seq', 1000)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('hasa', 2)\");\n            stmt.executeUpdate(\"insert into ClassLinkTypes (LinkName, LinkType) values ('partof', 2)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (100, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (200, 'isa', 1)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (300, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (400, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (500, 'isa', 300)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (600, 'isa', 100)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (700, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (800, 'isa', 200)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'instance', 400)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (501, 'instance', 500)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (801, 'instance', 800)\");\n            stmt.executeUpdate(\"insert into ObjectLinks (ObjectId, LinkName, LinkToObject) values (401, 'hasa', 801)\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('color')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('weight')\");\n            stmt.executeUpdate(\"insert into AttributeCategories (CategoryName) values ('length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('green', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('blue', 'color')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('light', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('heavy', 'weight')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('short', 'length')\");\n            stmt.executeUpdate(\"insert into Attributes (AttributeName, Category) values ('long', 'length')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'light')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (401, 'short')\");\n            stmt.executeUpdate(\"insert into ObjectAttributes (ObjectId, AttributeName) values (801, 'blue')\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('LEFT-WALL', '1', 'AV+ | NP+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('the', '1', 'D+', 1)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('big', '1', 'ADJ+', 400)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('dog', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 700)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('run', '1', '[S-] & AV- & [PREP+]', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('across', '1', 'PREP- & PO+', 800)\");\n            stmt.executeUpdate(\"insert into Dictionary (Word, SenseNumber, GrammarString, ObjectId) values ('street', '1', '[@ADJ-] & [D-] & (S+ | DO- | PO- | NP-)', 800)\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('with', 100, 'hasa')\");\n            stmt.executeUpdate(\"insert into AdjectivePrepositions (PrepositionName, ObjectId, LinkName) values ('in', 200, 'partof')\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 1, 'good', 'best', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 2, '*y', '*iest', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 3, '*e', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'superlative', 4, '*', '*est', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 1, 'good', 'better', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 2, '*y', '*ier', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 3, '*e', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'comparative', 4, '*', '*er', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 1, '*s', '*s\\\\'', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'possessive', 2, '*', '*\\\\'s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 1, 'be', 'being', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 2, '*Vy', '*Vying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 3, '*c', '*cking', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 4, '*VVC', '*VVCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 5, '*VC', '*VCCing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 6, '*ie', '*ying', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 7, '*e', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'present perfect', 8, '*', '*ing', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 1, 'sing', 'sang', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 2, 'give', 'gave', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 3, 'swim', 'swam', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 5, 'run', 'ran', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 6, 'do', 'did', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 7, 'be', 'was', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 8, 'throw', 'threw', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 9, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 10, '*c', '*cked', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 11, '*VVC', '*VVCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 12, '*VC', '*VCCed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 13, '*y', '*ied', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 14, '*oe', '*oed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 15, '*e', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past', 16, '*', '*ed', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 1, 'sing', 'sung', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 2, 'give', 'given', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 3, 'swim', 'swum', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 4, 'have', 'had', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 5, 'do', 'done', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 6, 'be', 'been', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 7, 'sleep', 'slept', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 8, '*e', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'past perfect', 9, '*', '*ed', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 1, 'be', 'am', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 1, 'be', 'are', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 2, 'have', 'have', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'second singular', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 1, 'be', 'is', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 2, 'have', 'has', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 3, 'do', 'do', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 4, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 5, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 6, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 7, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 8, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 9, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 10, '*o', '*oes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third singular', 11, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'first plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 1, 'be', 'are', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 2, 'have', 'have', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'third plural', 3, '*', '*', FALSE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 1, 'leaf', 'leaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 2, 'knife', 'knives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 3, 'elf', 'elves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 4, 'half', 'halves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 5, 'loaf', 'loaves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 6, 'shelf', 'shelves', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 7, 'wife', 'wives', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 8, 'person', 'people', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 9, 'deer', 'deer', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 10, 'child', 'children', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 11, '*Co', '*Coes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 12, '*s', '*ses', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 13, '*ch', '*ches', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 14, '*sh', '*shes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 15, '*x', '*xes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 16, '*z', '*zes', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 17, '*Cy', '*Cies', TRUE)\");\n            stmt.executeUpdate(\"insert into LanguageMorphologies (LanguageName, MorphologyTag, Rank, Root, Surface, Used) values ('English', 'plural', 18, '*', '*s', TRUE)\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (1, '$N[.N]', 'D+', 100, 'money')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (2, 'N/N/N', 'D+', 200, 'date')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (3, '[/](C/)C', 'D+', 300, 'unix path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (4, '[A:](C\\\\\\\\)C', 'D+', 400, 'dos path')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (5, 'N:N', 'D+', 500, 'time')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (6, 'N.N.N.N', 'D+', 600, 'internet')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (7, 'E(.E)', 'D+', 700, 'hostname')\");\n            stmt.executeUpdate(\"insert into WordClassifications (Rank, Pattern, GrammarString, ObjectId, Description) values (8, '{+-}N[.N]', 'D+', 800, 'number')\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('i', 1, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('we', 1, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('they', 3, 3, TRUE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('he', 3, 1, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('she', 3, 2, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('it', 3, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into Pronouns (Pronoun, Person, Gender, Plural) values ('you', 2, 3, FALSE)\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('actor')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('origin')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('destination')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('object')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('instrument')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('beneficiary')\");\n            stmt.executeUpdate(\"insert into FrameSlots (SlotName) values ('location')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('throw', 'actor', 'destination', 'object')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('melt', 'actor', '', '')\");\n            stmt.executeUpdate(\"insert into Verbs (VerbName, SubjectSlot, IndirectObjectSlot, PredicateNounSlot) values ('kill', 'actor', '', 'object')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('with', 200, 'instrument')\");\n            stmt.executeUpdate(\"insert into AdverbPrepositions (PrepositionName, ObjectId, FrameSlot) values ('at', 1, 'location')\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('the', 1)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('a', 2)\");\n            stmt.executeUpdate(\"insert into Articles (ArticleName, Dereference) values ('an', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('S', 1)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PN', 2)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('DO', 3)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('IO', 4)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PO', 5)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('NP', 6)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('AV', 7)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('LV', 8)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PREP', 9)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('D', 10)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADJ', 11)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('ADV', 12)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('CONJ', 13)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('INTJ', 14)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('PA', 15)\");\n            stmt.executeUpdate(\"insert into GrammarLinks (LinkName, LinkType) values ('HV', 16)\");\n            stmt.executeQuery(\"select setval('instructions_instructionid_seq', 1)\");\n            int next = 2;\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'throw', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'test', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'actor', 1, 'hasa', '300', '')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (2, null, 'instrument', 3, null, null, 'blue')\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (1, null, null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'get', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into Instructions (Type, ExecuteString, FrameSlot, Operator, LinkName, ObjectId, AttributeName) \" + \"values (3, 'drop', null, 0, null, null, null)\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 1, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 2) + \", 2, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 1, \" + (next + 1) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 3) + \", 2, \" + (next + 0) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 1, \" + (next + 2) + \")\");\n            stmt.executeUpdate(\"insert into InstructionGroups (InstructionId, Rank, GroupInstruction) values (\" + (next + 4) + \", 2, \" + (next + 3) + \")\");\n            stmt.executeQuery(\"select setval('transactions_transactionid_seq', 1)\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 4) + \", 'throw something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 5) + \", 'get something')\");\n            stmt.executeUpdate(\"insert into Transactions (InstructionId, Description) values (\" + (next + 6) + \", 'drop something')\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'actor', 1, 'hasa', 'object', '', 3)\");\n            stmt.executeUpdate(\"insert into TransactionPreconditions (TransactionId, IfFrameSlot, Operator, LinkName, LinkFrameSlot, AttributeName, SatisfyTransactionId) \" + \"values (2, 'object', 4, '', '', 'heavy', 4)\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'object', \" + (next + 6) + \")\");\n            stmt.executeUpdate(\"insert into TransactionSlots (TransactionId, FrameSlot, InstructionId) values (2, 'destination', \" + (next + 5) + \")\");\n            stmt.executeQuery(\"select setval('verbtransactions_verbid_seq', 1)\");\n            stmt.executeUpdate(\"insert into VerbTransactions (VerbString, MoodType, TransactionId) values ('throw', 2, 2)\");\n            stmt.executeUpdate(\"insert into VerbConstraints (VerbId, FrameSlot, ObjectId) values (2, 'object', 200)\");\n            stmt.executeUpdate(\"update SystemProperties set value = 'Play Data' where name = 'DB Data Version'\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public int updateuser(User u) {\n        int i = 0;\n        Connection conn = null;\n        PreparedStatement pm = null;\n        try {\n            conn = Pool.getConnection();\n            conn.setAutoCommit(false);\n            pm = conn.prepareStatement(\"update user set username=?,passwd=?,existstate=?,management=? where userid=?\");\n            pm.setString(1, u.getUsername());\n            pm.setString(2, u.getPasswd());\n            pm.setInt(3, u.getExiststate());\n            pm.setInt(4, u.getManagement());\n            pm.setString(5, u.getUserid());\n            i = pm.executeUpdate();\n            conn.commit();\n            Pool.close(pm);\n            Pool.close(conn);\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n            Pool.close(pm);\n            Pool.close(conn);\n        } finally {\n            Pool.close(pm);\n            Pool.close(conn);\n        }\n        return i;\n    }\n", "label": 1, "substitutes": {"load": [" reload", "get", "process", "clone", "loading", "save", "sync", "transfer", "init", " loaded", "construct", " Load", "write", " loading", "ready", "Loading", "build", " loads", "link", "download", "Load", "test", "add", "read", "dump", "config", "select"], "conn": ["db", "pt", "client", "connect", "ca", "Conn", "h", "p", "ctx", "n", "cp", "cc", "cn", "pg", "ls", "ns", "cat", "cr", "nt", "ci", "cache", "coll", "sb", "reg", "ann", "loc", "Exec", "dn", "state", "connection", "dc", "nc", "con", "conf", "dh", "pub", "util", "oci", "ch", "enc", "sql", "exec", "col", "session", "rt", "ct", "pc", "co", "mc", "Connection", "act", "config", "c", "pr", "ec"], "stmt": ["strs", "STnt", "Stml", "elrs", "STmn", "astql", "putml", "slr", "Stmc", "STct", "ostmt", "stmd", "slnt", " stor", "putur", "playtr", "stpl", "putmb", "Stmb", "sttor", "str", "actmt", " stmi", "playml", "estmt", "STpl", " stpl", "stpr", "stm", "acttr", "Stnt", " stml", "ostager", "atmt", "tm", "Stbt", "dmt", "stmn", "Stdb", "plb", "themc", " stbl", "Stb", "dmd", "stql", "putbt", "fldo", " stm", "estdo", "stmr", "Stager", "Stmr", "atmn", "plmn", " sttor", " stmn", "stmi", "tmt", "atMT", "flmd", "astmn", "Stmd", "flk", "plmt", "cltr", "slager", "playmt", "stmc", "stur", "Stts", "STager", " sttr", "stMT", "strmt", "estth", " str", " stts", "STmt", "playor", "ostpr", "dnt", "putmi", "clmt", "actbl", "estql", "themt", " stmb", "astk", "Stbl", " stager", "Stmt", "Stmn", "tpl", "stbt", "estk", "putmt", "estmd", "strk", "Stur", " stct", "Stm", " stdb", "osttr", " stpr", " stk", "STql", "dMT", "sttr", "stager", "Sttor", "ostmn", "elml", "atb", "plnt", "ostct", "acttor", " stmc", "strmd", "ostpl", " strs", "strdo", "STmd", "Sttr", "stnt", "Stct", "tct", "estMT", "esttr", "stmb", "puttr", "putmn", "slmn", "stdb", " stmr", " stMT", "STMT", "putts", "stml", "stdo", "clmn", "stbl", "flmt", "elmt", " stb", "STbl", "stts", "slmt", "stor", "plMT", "StMT", "plr", "putrs", "Stql", "estmr", " stbt", "themn", "elmi", "stb", " stql", "Stor", "stct", "stk", " stnt", "STml", "theb", "playmn", " stth", "slk", "Stth", "estct", "stth", "clur", "astmt", "Stpl", "STk", "playpl", "STdb", "Stpr"]}}
{"id1": "19549489", "id2": "18748516", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static void copy(String fromFile, String toFile) throws IOException {\n        File inputFile = new File(fromFile);\n        File outputFile = new File(toFile);\n        FileReader in = new FileReader(inputFile);\n        FileWriter out = new FileWriter(outputFile);\n        int c;\n        while ((c = in.read()) != -1) out.write(c);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copy": ["clone", "p", "sync", "upload", "Transfer", "all", "transfer", "delete", "Copy", " move", "write", "Cop", " transfer", " copied", "cop", "io", " copying", "file", "zip", "download", "create", "paste", "split", " Copy", " copies", "source", "move"], "sourceFile": ["servicefile", "serviceFile", "sourceFILE", "resourcefile", "searchfile", "siteFiles", "Sourcefile", "sourcefile", " sourceDirectory", "searchFile", "serviceFilename", "serviceFiles", "SourceFILE", " sourcefile", "siteFile", " sourceFilename", " sourceFiles", "resourceFile", " sourceFILE", "resourceFiles", "sourceDirectory", "SourceDirectory", "SourceFile", "siteFILE", "SourceFiles", "searchFilename", "siteDirectory", "searchFiles", "sourceFilename", "resourceDirectory", "sourceFiles"], "destinationFile": ["destinationDirectory", "destinatedFile", "DestinationDir", "Destinatorfile", "DestinatorFile", "destinatedFiles", "destinatorFile", "destinatedImage", "Destinationfile", "destationFiles", "distinatedImage", "destinatorDir", "DestinatorDir", "DestinatorFiles", "distinatedDirectory", "distinationFile", "destationFile", "destinatorDirectory", "destinatorImage", "destinationfile", "destationfile", "destinatedDir", "destationDirectory", "destinationDir", "destinatorfile", "destinationImage", "destinatorFiles", "destinationFiles", "destationDir", "distinatedFile", "DestinationFiles", "distinationImage", "distinationDirectory", "destationImage", "destinatedfile", "DestinationFile", "distinatedFiles", "destinatedDirectory", "distinationFiles"], "sourceFileChannel": ["ourceStreamStream", "targetLibraryChan", " sourceFileService", "targetFileChannel", "sourceStreamService", "sourceDirectorySocket", "sourceDirchannel", "sourceFileSocket", "sourceDirChan", "sourceFilesContext", "sourceFileClient", "sourceLineChan", "sourceFileContext", "sourceFileConnection", "sourceFilechannel", "sourceDirStream", "ourceFileChannel", " sourceFileConnection", "sourceLibraryChan", "sourceLineSocket", "sourceStreamStream", "sourceFunctionContext", "sourceLibraryClient", "sourceStreamchannel", "sourceStreamChan", " sourceFilesConnection", " sourceFileContext", "sourceDirectoryClient", "ourceStreamChan", "sourceFileService", "sourceStreamChannel", "sourceFunctionChannel", "ourceFileChan", "sourceLineClient", "sourceDirectoryChannel", "sourceLibrarySocket", " sourceFilesChannel", "sourceLibraryChannel", "targetFileClient", "sourceStreamContext", "sourceLineChannel", " sourceFilesService", "targetFileChan", "targetLibraryClient", " sourceFilesContext", "sourceStreamConnection", "targetLibraryChannel", "sourceFileChan", "ourceFileStream", "ourceStreamChannel", "targetFileSocket", "sourceDirChannel", "sourceLinechannel", "sourceLineStream", "sourceFilesChannel", "sourceDirectoryChan", "ourceStreamchannel", "sourceFunctionConnection", "sourceFilesService", "ourceFilechannel", "sourceFilesConnection", "sourceFileStream", "targetLibrarySocket", "sourceFunctionService"], "destinationFileChannel": ["destinationFilesClient", "destinatorFileService", "destinationFilesChan", "destinationDirectoryChannel", "destinatorFilesClient", "destinationLineService", "destinationFileConnection", "destinationFileService", "destinationFilesService", "destinationIOChannel", "destinatorFileClient", "destinationLineChannel", "destinationFileClient", "destinationLineChan", "destinationFileHandler", "destinationLineConnection", "destinationFilesHandler", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileConnection", "destinationDirectoryConnection", "destinatorFilesChannel", "destinatorFilesConnection", "destinationFilesChannel", "destinatorFilesService", "destinationFilesConnection", "destinationFileChan", "destinatorFileCache", "destinationDirectoryHandler", "destinationDirectoryService", "destinationLineHandler", "destinatorFilesCache", "destinatorFileHandler", "destinatorFilesChan", "destinationFilesCache", "destinationFileCache", "destinationDirectoryCache", "destinatorFileChan", "destinationLineClient", "destinationIOService", "destinationIOCache", "destinatorFileChannel", "destinationIOClient", "destinatorFilesHandler"]}}
{"id1": "14324112", "id2": "11477906", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    private static void loadDefaultSettings(final String configFileName) {\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = Thread.currentThread().getContextClassLoader().getResourceAsStream(META_INF_DEFAULT_CONFIG_PROPERTIES);\n            out = new FileOutputStream(configFileName);\n            IOUtils.copy(in, out);\n        } catch (final Exception e) {\n            log.warn(\"Unable to pull out the default.\", e);\n            throw new RuntimeException(e);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": [" outerprocess", " innerAccept", "middleprocess", " outerProcess", "innerAccept", "middleProcess", " innerprocess", "middleMethod", " outerAccept", " outerMethod", "middleAccept", " innerMethod", "innerprocess", "innerMethod"], "curi": ["funi", "cdu", "numi", "biri", " cri", "ucURI", "fcri", " cuni", "cui", "fcumi", "luni", "requuni", "ctURI", "nri", "ciri", "cacheui", "bdirectory", "ctiri", "cuni", "cURI", "lcri", "fui", "fri", "fcuri", "lciri", "cdirectory", "firi", "cuid", "CURI", "ldirectory", "ucuni", "Cui", "cri", "cachedu", "Cdu", "liri", "uciri", "cturi", "lURI", "lcouri", " cdirectory", "buri", "cacheURI", " couri", " cURI", "fcURI", "Couri", " ciri", "Curi", "requumi", "bURI", "cumi", "lcui", "requiri", "luri", "ctuid", " cumi", "ucuri", "requuri", " cuid", "nuri", " cdu", "Ciri", "couri", "lcURI", "luid", "furi", "nURI", "fURI", "lumi", " cui", "lcuri", "lri", "cacheuri", "Cri"], "maxsize": ["lastsize", " maxSize", "MaxSize", " maxscale", "totalscale", "maxaddress", " maxaddress", "maxSize", "minsize", " maxSIZE", "MAXname", "defaultize", "lastSize", "Maxize", "MAXsize", "defaultSize", "Maxsize", "minSize", "totalize", "MAXSize", "maxname", "maxize", "axSize", "defaultsize", "MAXSIZE", "MaxSIZE", "maxscale", "Maxscale", " maxize", "maxSIZE", "axize", "axsize", "minaddress", "totalSize", "totalsize", "Maxname", " maxname", "lastaddress"], "regexpr": ["rexpl", "requps", "rerePR", "egexps", "pereexpr", "requpr", "equPr", "resexpr", "rerexPr", "rexpp", "refplexpr", "reqpt", "reuxpl", "rexPr", "replexpp", "pegexexpr", "refplexPr", "equps", "replaypt", "replexpr", "rentaxpr", "reuxpr", "egexpect", "rexpr", "REqr", "reqr", "REgexor", "replexPr", "pegexpr", "refgexpp", "refplexpl", "replaypr", "regexps", "REgexr", "equpr", "regexPr", "rereexpr", "resexpect", "resexps", "regexor", "perePR", "reuxPr", "rerexpr", "regexexpr", "rerePr", "replayor", "rerexps", "rerexpect", "perePr", "refgexpr", "egexPr", "perepr", "REqpt", "replayr", "replexPR", "refplexpp", "egexpr", "requpect", "regexpect", "reqor", "REqpr", "regexpt", "regexpl", "REqor", "replexexpr", "regexr", "REgexpt", "regexPR", "replexpl", "refgexPr", "refgexpl", "rerepr", "regexpp", "requPr", "equpect", "resexPr", "rentaxPr", "reqpr", "pegexPr", "rentaxPR", "reuxpp", "REgexpr", "pegexPR", "rentaxexpr"], "cs": ["sc", "ca", "cas", "cus", "ctx", "sync", "qs", "ences", "cp", "ce", "cc", "bs", "cn", "cells", "rs", "ls", "ns", "cr", "cons", "lc", "ci", "cf", "css", "GC", "coll", "cache", "CS", "ks", "cos", "ras", "cm", "ches", "ds", "str", "cks", "tc", "wcs", "ch", "fs", "spec", "ces", "cl", "ins", "pc", "acts", "acks", "mc", "ics", "TS", "js", "ps", "acs", "gs", "ms", "Cs", "cms", "c", "ts", "ec"], "digest": ["signest", "shaEST", "digusher", "DigEST", "shaest", "returnester", "signEST", "diggest", "diger", "Diger", " digEST", "Digest", "returnest", " diger", "returnEST", "Digester", " digester", "signusher", "digester", "shaer", "returngest", "digEST", "Digher", " diggest", "digher", "Digusher", " digusher", "Diggest", "shaher", "signester", " digher"], "s": ["r", "S", "su", "details", "h", "p", "sl", "sync", "g", "n", "i", "summary", "strings", "cells", "ls", "ns", "t", "sb", "lines", "services", "params", "single", "states", "str", "f", "o", "sets", "session", "u", "b", "v", "groups", "w", "l", "ss", "d", "string", "js", "ps", "si", "ms", "sv", "ws", "c"], "m": ["mm", "mo", "r", "mac", "h", "p", "n", "g", "i", "t", "M", "arm", "fm", "um", "bm", "rm", "nm", "cm", "f", "ym", "sm", "imm", "dm", "b", "im", "v", "pm", "mi", "text", "tm", "l", "mc", "d", "gm", "ms", "am", "machine", "wm"]}}
{"id1": "4686922", "id2": "5299276", "code1": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"extractResourceToFile": ["extractResourceInResource", "extractResourcesAsResource", "extractResourceAndFiles", "extractResourcesToResource", "extractResourceAndfile", "extractResourceAsResource", "extractResourceAsFile", "extractResourceAsfile", "extractResourcesAsfile", "extractResourcesAsFile", "extractResourceTofile", "extractResourceAndFile", "extractResourceAsFiles", "extractResourceInFiles", "extractResourcesToFiles", "extractResourceToResource", "extractResourcesTofile", "extractResourceInFile", "extractResourceAndResource", "extractResourceInfile", "extractResourceToFiles", "extractResourcesToFile", "extractResourcesAsFiles"], "resourcePath": ["servicePath", " resourceUrl", " resourceId", "resourceId", "stringFolder", "resourceFolder", "sourceId", "Resourcepath", "ResourceUrl", "ResourcePath", "sourcePath", "servicepath", " resourcepath", "resourcepath", "serviceFolder", "sourcepath", "ResourceId", "stringPath", "resourceUrl", "sourceUrl", "stringpath", " resourceFolder"], "dest": ["de", " Dest", "src", "output", "class", "transfer", "tmp", "comb", "default", "route", "const", "home", "Dest", "target", "result", "content", "desc", "path", "resource", "resources", "later", "img", "file", "sup", "dist", "config", "store", "sac", "die", "wb", "data", "temp", "flat", "trans", "done", "contract", " destination", "project", "prop", "folder", "destroy", "source", "filename", "txt"], "in": ["r", "image", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "thin", "id", "arin", "din", "sin", "plus", "conn", "lin", "connection", "inner", "resource", "nin", "ini", "con", "rec", "file", "rin", "kin", "inside", "f", "url", "this", "pass", "login", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "like", "re", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "auto", "client", "writer", "sync", "obj", "n", "off", "one", "all", "i", "output", "socket", "s", "app", "user", "copy", "parent", "ex", "server", "cache", "cookie", "outside", "conn", "boot", "ax", "a", "cos", "ext", "io", "at", "file", "f", "o", "null", "this", "exec", "lib", "err", "temp", "b", "norm", "w", "ins", "net", "co", "bin", "In", "OUT", "again", "outs", "outer", "source", "up", "inc"]}}
{"id1": "19849797", "id2": "20924119", "code1": "    public static void copyFile(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            if (source != null) {\n                source.close();\n            }\n            if (destination != null) {\n                destination.close();\n            }\n        }\n    }\n", "code2": "    public static void gzip() throws Exception {\n        System.out.println(\"gzip()\");\n        GZIPOutputStream zipout = new GZIPOutputStream(new FileOutputStream(\"/zip/myzip.gz\"));\n        byte buffer[] = new byte[BLOCKSIZE];\n        File dir = new File(\"/zip/covers\");\n        System.out.println(\"Dir '\" + dir.getAbsolutePath() + \"' exists: \" + dir.exists());\n        FileInputStream in = new FileInputStream(dir);\n        for (int length; (length = in.read(buffer, 0, BLOCKSIZE)) != -1; ) zipout.write(buffer, 0, length);\n        in.close();\n        zipout.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", "cloneFiles", "transferfile", " copySource", "transferSource", "cloneSource", "clonefile", "copyFiles", "copyfile", "transferFile", "cloneFile", "transferFiles", "copySource"], "sourceFile": ["ourceUrl", "SourceUrl", "ourceDirectory", "SourceDir", "Sourcefile", "sourcefile", "ourcefile", "ourceFile", "destDirectory", " sourcefile", "SourceFolder", "destUrl", "destfile", "srcDir", "sourceFolder", "srcfile", "srcFile", "srcFolder", " sourceDir", "sourceDirectory", "sourceDir", "SourceDirectory", "SourceFile", "sourceUrl", " sourceFolder"], "destFile": ["srcFiles", "targetDir", "foreignfile", "sourcePoint", "foreignFiles", "srcLine", "srcDirectory", " destDir", "DestFile", " destPoint", "resultfile", "targetPath", "destDir", "Destfile", "destDirectory", "destfile", "srcDir", "targetfile", "DestDirectory", "destFiles", "resultLine", "srcfile", "resultDir", "targetLine", "srcFile", "DestPath", " destfile", "targetFiles", "destPath", "destLine", "foreignFile", "DestDir", "foreignPath", "sourceDir", "resultFile", "DestFiles", " destDirectory", "targetFile", "DestPoint", " destFiles", "destPoint", "sourceFiles"], "source": ["get", "image", "client", "component", "service", "size", "ie", "stream", "src", "ce", "output", "object", "use", "proxy", "context", "scope", "slice", "input", "view", "reference", "slave", "parent", "id", "route", "sin", "core", "cache", "server", "scene", "from", "target", "result", "connection", "inner", "index", "resource", "manager", "dest", "file", "Source", "root", "secure", "storage", "start", "iter", "url", "this", "null", "api", "unit", "channel", "session", "wrapper", "SOURCE", "status", "table", "site", "reader", "remote", "si", "seed", "uri", "current", "ource", "config"], "destination": [" destion", "Destinated", "distinator", "identination", "constination", "identinated", "destation", "distination", "constribution", " destruction", "destruction", "Destruction", "Destribution", "generinated", "domation", "identinate", "identinator", "distruction", "participination", "Destinator", "generination", "participinated", "participinator", " destation", "construction", " destinated", "distion", "destinator", "generruction", "Destion", "destinated", "generinator", "destribution", "Destation", "destion", "destinate", "domination", "participinate", " destribution", " destinator", "Destinate", "Destination", "dominated", "distinated", "constinator", "dominator"]}}
{"id1": "20724937", "id2": "1235538", "code1": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "code2": "    public static String encrypt(final String pass) {\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"SHA\");\n            md.update(pass.getBytes(\"UTF-8\"));\n            return new String(Base64.encodeBase64(md.digest()));\n        } catch (final Exception e) {\n            throw new RuntimeException(\"No se pudo encriptar el password.\", e);\n        }\n    }\n", "label": 0, "substitutes": {"getTopicMap": ["createTopicsData", "getTopicsFile", "gettopicmap", "createTopicMap", "createTopicList", "getTopicList", "getResourceMap", "getTopicsMap", "getTopicFile", "createTopicsList", "getTopicmap", "getTopicData", "gettopicList", "getResourceFile", "getTopicsmap", "createTopicsFile", "getResourcemap", "createTopicsMap", "getResourceList", "createTopicFile", "gettopicFile", "createTopicmap", "gettopicData", "gettopicMap", "getResourceData", "createTopicsmap", "getTopicsData", "createTopicData", "getTopicsList"], "url": ["request", "image", "job", "buffer", "service", "sl", "html", "host", "class", "key", "object", "el", "feed", "input", "user", "id", "page", "server", "address", "connection", "http", "location", "URL", "resource", "path", "ssl", "file", "str", "link", "f", "Url", "api", "base", "data", "loader", "name", "l", "string", "uri", "source", "config"], "baseURI": ["absolutePath", "absoluteURL", " baseuri", "BasePath", "absoluteUrl", " basePath", "basePath", " baseUrl", " baseURL", "baseURL", "fullUrl", "BaseUrl", "fullURL", "Baseuri", "baseuri", "BaseURI", "absoluteURI", "fullURI", "BaseURL", "baseUrl", "fulluri"], "inputStream": [" inputWriter", "outputstream", "outputPath", "Inputstream", "readerPath", "outputStream", "inputWriter", " inputstream", "readerStream", "InputSteam", "streamSteam", "outputWriter", "outputSteam", "readerFlow", " inputPath", "readerstream", "inputSteam", "InputStream", "streamstream", "inputFlow", "InputFlow", "InputPath", "InputWriter", " inputFlow", "streamStream", "inputPath", "inputstream"]}}
{"id1": "11341711", "id2": "20210699", "code1": "    public static void makeBackup(File dir, String sourcedir, String destinationdir, String destinationDirEnding) {\n        String[] files;\n        files = dir.list();\n        File checkdir = new File(destinationdir + System.getProperty(\"file.separator\") + destinationDirEnding);\n        if (!checkdir.isDirectory()) {\n            checkdir.mkdir();\n        }\n        ;\n        Date date = new Date();\n        long msec = date.getTime();\n        checkdir.setLastModified(msec);\n        File checkFile = new File(checkdir + System.getProperty(\"file.separator\") + \"azureus.config\");\n        if (checkFile.exists()) {\n            checkFile.setLastModified(msec);\n        }\n        try {\n            for (int i = 0; i < files.length; i++) {\n                File f = new File(dir, files[i]);\n                File g = new File(files[i]);\n                if (f.isDirectory()) {\n                } else {\n                    String destinationFile = checkdir + System.getProperty(\"file.separator\") + g;\n                    String sourceFile = sourcedir + System.getProperty(\"file.separator\") + g;\n                    FileInputStream infile = new FileInputStream(sourceFile);\n                    FileOutputStream outfile = new FileOutputStream(destinationFile);\n                    int c;\n                    while ((c = infile.read()) != -1) outfile.write(c);\n                    infile.close();\n                    outfile.close();\n                }\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public List<RTTicket> getTicketsForQueue(final String queueName, long limit) {\n        getSession();\n        final List<NameValuePair> params = new ArrayList<NameValuePair>();\n        params.add(new BasicNameValuePair(\"query\", \"Queue='\" + queueName + \"' AND Status='open'\"));\n        params.add(new BasicNameValuePair(\"format\", \"i\"));\n        params.add(new BasicNameValuePair(\"orderby\", \"-id\"));\n        final HttpGet get = new HttpGet(m_baseURL + \"/REST/1.0/search/ticket?\" + URLEncodedUtils.format(params, \"UTF-8\"));\n        final List<RTTicket> tickets = new ArrayList<RTTicket>();\n        final List<Long> ticketIds = new ArrayList<Long>();\n        try {\n            final HttpResponse response = getClient().execute(get);\n            int responseCode = response.getStatusLine().getStatusCode();\n            if (responseCode != HttpStatus.SC_OK) {\n                throw new RequestTrackerException(\"Received a non-200 response code from the server: \" + responseCode);\n            } else {\n                InputStreamReader isr = null;\n                BufferedReader br = null;\n                try {\n                    if (response.getEntity() == null) return null;\n                    isr = new InputStreamReader(response.getEntity().getContent());\n                    br = new BufferedReader(isr);\n                    String line = null;\n                    do {\n                        line = br.readLine();\n                        if (line != null) {\n                            if (line.contains(\"does not exist.\")) {\n                                return null;\n                            }\n                            if (line.startsWith(\"ticket/\")) {\n                                ticketIds.add(Long.parseLong(line.replace(\"ticket/\", \"\")));\n                            }\n                        }\n                    } while (line != null);\n                } catch (final Exception e) {\n                    throw new RequestTrackerException(\"Unable to read ticket IDs from query.\", e);\n                } finally {\n                    IOUtils.closeQuietly(br);\n                    IOUtils.closeQuietly(isr);\n                }\n            }\n        } catch (final Exception e) {\n            LogUtils.errorf(this, e, \"An exception occurred while getting tickets for queue \" + queueName);\n            return null;\n        }\n        for (final Long id : ticketIds) {\n            try {\n                tickets.add(getTicket(id, false));\n            } catch (final RequestTrackerException e) {\n                LogUtils.warnf(this, e, \"Unable to retrieve ticket.\");\n            }\n        }\n        return tickets;\n    }\n", "label": 0, "substitutes": {"makeBackup": ["makeCleanup", "makePickups", "createBackUp", "createbackups", "createBackdown", "makeCleandown", "createBackup", "makeCleanUp", "makebackups", "makebackup", "createbackUp", "makeBackdown", "makePickUp", "makePickdown", "makePickup", "makeCleanups", "makebackdown", "createbackdown", "makeBackUp", "makebackUp", "createbackup", "makeBackups", "createBackups"], "dir": ["Directory", "db", "DIR", "up", "rc", "init", "dict", "pkg", "directory", "cache", "run", "md", "group", "module", "diff", "desc", "path", "dep", "io", "direction", "ir", "work", "manager", "dest", "wd", "file", "root", "dist", "build", "director", "store", "url", "lib", "base", "doc", "zip", "data", "download", "log", "done", "Dir", "name", "d", "folder", "source", "config"], "sourcedir": ["seediri", "sodedir", "asortedirs", "sodedIR", "sourcesore", "sourcesirs", "sodedore", "sourcesdir", "ssodedir", "ssodedIR", "sodediri", "seedIR", "sourcedore", "sourcediri", "ssourcedIR", "sourcesIR", "asourcedirs", "ssourcediri", "asourcedIR", "asourcedir", "sortedir", "sourcesir", "ssodeddir", "ssodediri", "asortedore", "asortedIR", "sortedirs", "asourcedore", "sourceddir", "sodedirs", "sortedore", "sortedIR", "ssourcedir", "sodeddir", "sourcedirs", "seeddir", "asortedir", "seedir", "sourcesiri", "sourcedIR", "ssourceddir"], "destinationdir": ["DestinationDir", "destinateDir", "destinatedirection", "destinationsDIR", "desturationDir", "destinatorDir", "destinationsfile", "Destinationdir", "destificationfolder", "dominatorDir", "Destificationdirection", "Destificationdir", "destinationfile", "destificationdirection", "dominatordir", "dominatorfile", "DestificationDir", "destinationDir", "dominationDIR", "destinationsDir", "destinatorfile", "desturationdir", "destinationsdir", "dominationDir", "destinatorDIR", "desturationdirection", "destinationdirection", "destinateDIR", "destinatefile", "Destinationdirection", "destificationDir", "desturationfolder", "dominationfile", "destinatedir", "destinatefolder", "Destificationfolder", "dominationdir", "Destinationfolder", "destinationDIR", "destificationdir", "destinationfolder", "destinatordir", "dominatorDIR"], "destinationDirEnding": ["destinationDirENDing", "destinationDirectorySigning", "destinationDirectoryEndening", "destinationDirEndening", "destinationDirSignING", "destinationDirPassING", "destinationDirLeadining", "destinationPathBeginING", "destinationDirENDING", "destinationDirectoryEndining", "destinationDirEndning", "destinationDirPassing", "destinationDirLeading", "destinationDirPassning", "destinationDirectorySignING", "destinationDirSignining", "destinationDirBeginning", "destinationDirectorySignining", "destinationDirSigning", "destinationDirectorySignening", "destinationPathEndning", "destinationDirBeginening", "destinationDirENDning", "destinationDirBegining", "destinationDirPassging", "destinationDirBeginining", "destinationDirEndging", "destinationDirectoryEnding", "destinationDirENDging", "destinationPathBegining", "destinationPathEndING", "destinationPathEndging", "destinationDirEndING", "destinationPathEnding", "destinationDirLeadening", "destinationDirLeadING", "destinationDirSignening", "destinationDirBeginging", "destinationPathBeginging", "destinationDirEndining", "destinationDirBeginING", "destinationDirectoryEndING", "destinationPathBeginning"], "files": ["items", "balls", "locks", "words", "children", "models", "types", "output", "boxes", "sections", "strings", "its", "ls", "ips", "events", "projects", "links", "features", "lines", "keys", "objects", "docs", "reports", "index", "services", "images", "modules", "xml", "resources", "results", "iles", "file", "classes", "Files", "pages", "fs", " Files", "uploads", "planes", "actions", "data", "log", "blocks", "groups", "users", "split", "errors", "rows", "parents", "bugs", "ins", "names", "ids", "l", "ps", "runs", "books", "thumbnails", "rules", "tests", "flows", "fields"], "checkdir": ["searchdir", "checkdirectory", " checkfile", "worklog", "calldir", "blockDir", "blockdirectory", "CheckDir", "workfile", "workdir", "Checkfile", "ckDir", "checkfolder", "blockdir", "workdraft", "calld", "searchDir", "workfolder", "lockFolder", "CheckDIR", "callfolder", " checkFolder", " checkd", " checkDIR", "lockDir", "checkDIR", "searchdirectory", "ckd", " checkDir", "workFolder", "ckdirectory", "workdirectory", "blockdraft", "checkDir", "calldirectory", "checkdraft", "ckfolder", "checkFolder", "locklog", "checklog", " checkdirectory", "workDir", " checkfolder", "workDIR", "Checkdir", " checklog", "checkfile", "searchdraft", "checkd", "ckfile", "lockdir", "ckdir"], "date": ["image", "late", "m", "de", "mate", "rate", "user", "e", "mu", "md", "open", "state", "time", "day", " Date", "dt", "zone", "change", "now", "file", "at", "start", "ge", "set", "update", "doc", "data", "contact", "log", "ate", "tag", "name", "age", "d", "month", "sign", "Date", "event", "ime", "dat", "config"], "msec": ["mss", "rseconds", "cseconds", "Msec", "lss", " mif", "fmseconds", "Misec", "csecond", "mSec", "Msecond", "fmsec", "lseconds", "dsec", "css", "Mseconds", "misec", " minsc", "lsecond", "mif", "rss", "msecond", "csec", "lsec", " minif", " msc", "rsecond", "mnif", "dseconds", "mnsec", "disec", " minSec", "dsecond", "mnSec", "fmisec", "fmsecond", " minsec", "mnsc", "mseconds", " mSec", "rsec", "msc"], "checkFile": [" checkDirectory", "ckFile", "controlFilename", "CheckFile", "workFile", " checkfile", "CheckDirectory", "CheckDir", "checkLine", "workfile", "CheckFiles", "Checkfile", "controlLine", "controlfile", "checkFilename", "changefile", "changeFile", "changeLine", " checkFilename", "checkFiles", " checkDir", "checkDir", "controlFile", " checkLine", "workFiles", "checkDirectory", "workDir", "ckDirectory", "changeFilename", "checkfile", " checkFiles", "ckfile", "ckFiles"], "i": ["ai", "ip", "m", "j", "p", "n", "ie", "eni", "is", "key", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "ui", "info", "li", "index", "ii", "io", "vi", "iu", "ini", "bi", "part", "x", "pi", "xi", "ti", "ri", "u", "b", "y", "v", "im", "ji", "oi", "di", "hi", "si", "qi", "uri", "field", "I"], "f": ["r", "fr", "m", "h", "p", "j", "n", "fd", "q", "feed", "fi", "fl", "e", "cf", "t", "sf", "fe", "info", "fb", "fp", "df", "fn", "fc", "file", "fun", "fs", "o", "u", "b", "v", "w", "fx", "l", "d", "folder", "F"], "g": ["r", "m", "h", "p", "go", "msg", "gin", "n", "q", "ga", "s", "pg", "erg", "global", "G", "gp", "e", "gg", "ger", "gi", "ng", "tg", "t", "reg", "gn", "sg", "group", "bg", "gc", "gb", "eg", "gu", "gar", "file", "gd", "ge", "mg", "u", "b", "w", "vg", "gh", "ig", "l", "rg", "gm", "og", "gs", "d"], "destinationFile": ["destacementFilename", "DestinationDir", "destinationDirectory", "destinationsDirectory", "DestinationFilename", "DestinationLocation", "destacementFile", "DestificationLocation", "destinatorFile", "Destinationfile", "destinatorDir", "destacementfile", "destacementDir", "destinatorLocation", "destificationLocation", "destationFile", "destinatorDirectory", "destinationsLocation", "destinationfile", "destinationLocation", "destiningDir", "DestificationFile", "destationfile", "DestificationDir", "destinationDir", "destinationsDir", "destationFilename", "destiningfile", "DestationDir", "DestinationDirectory", "destinationsFile", "destificationDir", "destificationFile", "destationDir", "Destationfile", "destiningFilename", "DestificationDirectory", "destiningFile", "DestationFilename", "DestationFile", "DestinationFile", "destificationDirectory", "destinationFilename"], "sourceFile": ["srcModule", "ourceFiles", "ourceDirectory", "SourceDir", "Sourcefile", "sourcefile", " sourceDirectory", "sourceModule", "SourceModule", "ourceFile", " sourcefile", "srcDir", "ourceDir", " sourceFiles", "srcfile", "srcFile", " sourceDir", "sourceDirectory", "inputDirectory", "sourceDir", "SourceFile", "inputFile", "inputFiles", "inputDir", " sourceModule", "sourceFiles"], "infile": ["Infile", "inputf", "winfile", " instream", "outdir", "winFile", "difffile", "outf", "indir", "outstream", "windir", "winstream", "diffstream", "inf", "inputdata", "indata", "outdata", "instream", "Instream", "diffFile", "Inf", "inputfile", "diffdir", "inputFile", " indata", " inFile", "outFile", "inFile", "InFile", "inputstream"], "outfile": ["againpage", "inputfunction", "intlive", " outstream", "Outfile", "Outline", " outline", "outstream", " outfunction", "outpage", "againFile", "againstream", "Outstream", "exFile", " outFile", "OutFile", "inputline", " outpage", "outlive", "outline", "Outlive", "Outfunction", " outlive", "inputfile", "intstream", "exfile", "inputFile", "outFile", "againfile", "exstream", "outfunction", "expage", "intFile", "intfile"], "c": ["r", "C", "in", "m", "h", "p", "ice", "n", "rc", "comment", "character", "dec", "e", "cr", "id", "lc", "cy", "ci", "t", "cu", "code", "pointer", "a", "index", "cm", "z", "xc", "uc", "esc", "end", "x", "col", "ch", "enc", "o", "channel", "abc", "k", "ac", "u", "b", "v", "char", "w", "cl", "ct", "pc", "l", "d", "string", "cont", "ec"]}}
{"id1": "14688886", "id2": "16079868", "code1": "    static void populateResources() throws BasicException {\n        try {\n            List<URL> templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/\" + Locale.getDefault().getLanguage());\n            if (templates.size() == 0) {\n                templates = DatabaseValidator.listResources(\"/net/adrianromero/templates/en\");\n            }\n            for (URL url : templates) {\n                String fileName = url.getFile();\n                fileName = fileName.substring(fileName.lastIndexOf('/') + 1);\n                if (fileName.endsWith(\".xml\") || fileName.endsWith(\".txt\")) {\n                    Resource templateResource = new Resource(fileName.substring(0, fileName.length() - 4));\n                    InputStream is = url.openStream();\n                    StringBuffer strBuff = new StringBuffer();\n                    BufferedReader br = new BufferedReader(new InputStreamReader(is));\n                    String str;\n                    while ((str = br.readLine()) != null) {\n                        strBuff.append(str + \"\\n\");\n                    }\n                    templateResource.setText(strBuff.toString());\n                    templateResource.save();\n                }\n            }\n        } catch (MalformedURLException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        } catch (IOException e1) {\n            logger.error(\"Unable to load templates\", e1);\n        }\n        String[][] images = new String[][] { { \"default.user\", \"yast_sysadmin.png\" }, { \"default.product\", \"colorize.png\" }, { \"Window.Logo\", \"windowlogo.png\" }, { \"Image.Backarrow\", \"3backarrow.png\" } };\n        for (int i = 0; i < images.length; i++) {\n            Image img = new Image();\n            img.setBufferedImage(ImageUtils.readImage(DatabaseValidator.class.getResource(\"/net/adrianromero/images/\" + images[i][1])));\n            img.save();\n            Property imgProperty = new Property(images[i][0]);\n            imgProperty.setValue(\"\" + img.getId());\n            imgProperty.save();\n        }\n    }\n", "code2": "    private void readIntoList(URL url, Map<String, JMenuItem> list) {\n        try {\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                int commandNameBegin = inputLine.indexOf(\">\") + 1;\n                int commandNameEnd = inputLine.indexOf(\"</a>\");\n                JMenuItem item = new JMenuItem(\"<html>\" + inputLine + \"</html>\");\n                if (list == allRooms) {\n                    item.setActionCommand(\"/room \" + inputLine.substring(commandNameBegin, commandNameEnd));\n                } else {\n                    item.setActionCommand(\"/\" + inputLine.substring(commandNameBegin, commandNameEnd) + \" \");\n                }\n                item.addActionListener(new ActionListener() {\n\n                    public void actionPerformed(ActionEvent e) {\n                        jTextField1.setText(e.getActionCommand());\n                        popup.setVisible(false);\n                    }\n                });\n                list.put(inputLine.substring(commandNameBegin, commandNameEnd), item);\n            }\n            in.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"populateResources": ["compureResource", "poputeRelations", "compureRelations", "popractResources", "poputeResource", "populateRelations", "popureFiles", "poputeFiles", "poputeResources", "compulateFiles", "compureResources", "popureResources", "compulateRelations", "compureFiles", "popractFiles", "compulateResources", "popureResource", "populateResource", "popureRelations", "compulateResource", "popractRelations", "populateFiles", "popractResource"], "templates": ["Template", "template", "filens", "Temeters", "temures", "filures", "templateps", "templateples", "stemples", "tomplates", "prompl", "Temens", "templateplates", "Templ", " temures", "promplate", "promplates", "temps", " templ", "stemplates", "tempplates", "Temples", "Temps", "stempl", "temeters", "tompl", "typlates", "tometers", "stemps", "temples", "tempplate", "filpl", "typs", "templ", "prometers", "temppl", " temens", "templatepl", "tempps", "typlate", "Templates", "typl", "tomplate", "temens", "Temures", "filplates"], "url": ["image", "r", "job", "template", "buffer", "service", "email", "sl", "html", "entry", "host", "pattern", "object", "el", "feed", "fl", "il", "e", "route", "page", "server", "address", "connection", "http", "location", "URL", "resource", "path", "ob", "xml", "ssl", "file", "config", "link", "f", "Url", "channel", "base", "data", "download", " URL", "name", "l", "string", "href", "uri", "pl", "source", "filename"], "fileName": ["FileKey", "resourcePath", "stringType", "FileType", "stringName", " fileTime", "fDir", " fileInfo", "sourceName", "FileName", "filenameName", "filePart", "fileDir", "FileFull", "fileSync", " fileDir", "filePath", "fileTime", " filePart", "folderPath", "foldername", "sourceInfo", " fileKey", "folderPart", "fileString", "objectTime", "fname", "FileDir", "modelname", "fileSystem", " fileSystem", "FILELocation", " fileDirectory", "fileDirectory", "resourcePart", "FILESync", "filenamename", "stringDirectory", "modelLocation", "sourcename", "Filename", " fileLength", "sourceString", "FILESystem", "fileType", " fileType", "folderName", " fileSync", "resourcename", "fName", " filePath", "filenameString", " fileLocation", "fKey", "resourceName", "filenameType", "objectname", " filename", "filename", "objectName", "sourceLength", "fileLength", " fileFull", "filenameFull", "fileLocation", "FILEname", "modelName", "FileDirectory", "modelSystem", "filenameLength", "fileFull", "fileInfo", "fileKey", "FileInfo", "FileString", " fileString", "objectSync", "FILETime", "FILEName"], "templateResource": ["tempFile", "eventReader", " templateFile", "plateResource", "translationContent", "plateContainer", "copyUrl", "templateUrl", "translationRing", "templateReader", "privateResource", "privateUrl", "xmlFile", "templateresource", "xmlRole", "layoutResource", "templateType", "privateresource", "translationContainer", "eventresource", "tempResource", "translationResource", "layoutRing", "templateRing", "templateFile", " templateType", "plateRing", "templateContent", "templateContainer", "privateReader", "copyresource", "eventUrl", "xmlType", "tempRole", "copyReader", "plateContent", "xmlResource", "copyResource", "tempType", "eventResource", " templateRole", "templateRole", "layoutContent", "layoutContainer"], "is": ["lis", "r", "os", "in", "ip", "irc", "Is", "bis", "iso", "isl", "isa", "src", "s", "app", "its", "was", "ib", "isi", "ris", "IS", "iss", "rss", "ios", "isc", "ori", "nis", "io", "has", "ir", "out", "iris", "abs", "ais", "api", "serv", "ri", "im", "it", "ar", "as", "cms", "uri"], "strBuff": ["brBuff", "arrBuffer", "strGrab", "rBuffer", "StrText", "brBuffer", "StrTab", " strBuffer", " strTab", " strbuff", "StrBuffer", "strbuff", "stringFlow", "strText", " strGrab", "strTab", " strPref", "stringGrab", "rBuff", "StrBuff", "Strbuff", "stringBuffer", "brFlow", "strBuffer", " strFlow", "StrPref", "arrTab", "stringBuff", "brGrab", "strFlow", " strText", "arrPref", "arrBuff", "rText", "strPref", "rbuff"], "br": ["r", "gr", "fr", "Reader", "stream", "ctr", "cr", "result", "dr", "bc", "rb", "bl", "ber", "ori", "io", "Br", "bro", "hr", "nr", "sr", "mr", "buf", " reader", "data", "div", "err", "b", "bar", "er", "BR", "brush", "text", "arr", "yr", "browser", "res", "reader", "tr", "orb", "cb", "sp"], "str": ["STR", "r", "sc", "fr", "strike", "p", "sl", "sec", "key", "cr", "lc", "Str", "stri", "t", "coll", "or", "dr", "cur", "line", "wr", "hr", "sr", "iter", "f", "oct", "st", "enc", "data", "type", "err", "div", "char", "er", "spec", "kr", "cl", "text", "star", "arr", "name", "style", "string", "tr", "pr", "sp"], "images": ["image", "letters", "ups", "words", "scripts", "styles", "models", "people", "assets", "files", "types", "boxes", "holes", "tags", "xs", "dates", "sites", "games", "gallery", "ages", "events", "ips", "picture", "features", "objects", "rooms", "quarters", "media", "bands", "services", "jobs", "resources", "frames", "apps", "ions", "pieces", "icons", "png", "classes", "pages", "opens", "inches", "agents", "gif", "ims", "users", "groups", "views", "ins", "versions", "shows", "videos", "stars", "lights", "thumbnails", "Images", "photos", "tests", "flows", "plugins"], "i": ["image", "j", "key", "s", "ci", "gi", "info", "format", "http", "x", "this", "u", "v", "yi", "uri", "I", "ind", "ip", "p", "html", "eni", "multi", "fi", "phi", "diff", "index", "li", "io", "iu", "gu", "bi", "ti", "b", "mi", "d", "si", "ai", "in", "app", "slice", "e", "id", "cli", "lc", "z", "ini", "Url", "xi", "y", "ji", "it", "hi", "chi", "add", "ie", "n", "mu", "ui", "ii", "xml", "_", "ij", "uni", "pi", "f", "ni", "di", "qi", "config"], "img": ["att", "image", "fw", "iframe", "m", "icon", "p", "sl", "jpg", "ie", "src", "ff", "tmp", "app", "map", "input", "fig", "gallery", "ng", "cb", "info", "bg", "fb", "inst", "ext", "li", "bl", "exp", "file", "gd", "hr", "png", "f", "ch", "lib", "imp", "abc", "data", "ani", "gif", "im", "v", "norm", "arr", "small", "aut", "tif", "aff", "config"], "imgProperty": ["cachePro", " imgProp", "imgPro", "cacheImage", "bgPro", "cacheProperty", " imgPro", " imgImage", "imgProp", "bgImage", "imgImage", "bgProp", "cacheProp", "bgProperty"]}}
{"id1": "18891988", "id2": "23452437", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "        private void internalCopy(File fSource, File file) throws FileNotFoundException, IOException {\n            if (fSource.getName().equals(\"Thums.db\")) return;\n            System.out.println(\"copying \" + fSource + \" in \" + file);\n            OutputStream o = new BufferedOutputStream(new FileOutputStream(file));\n            InputStream i = new BufferedInputStream(new FileInputStream(fSource));\n            byte[] b = new byte[8192];\n            int n;\n            while ((n = i.read(b)) > 0) o.write(b, 0, n);\n            i.close();\n            o.close();\n        }\n", "label": 1, "substitutes": {"getFile": ["getfile", "loadFile", "loadString", "Getfile", "GetFilename", "GetString", "downloadFilename", "loadFilename", "downloadString", "getString", "getFilename", "loadfile", "downloadFile", "GetFile", "downloadfile"], "serviceName": ["servicePath", "projectName", "packagename", "serviceType", "projectPath", "packageName", "ServiceName", " servicePath", " servicename", "packagePath", " serviceType", "packageUrl", "serviceUrl", "Servicename", "ServicePath", "servicename", "ServiceUrl", " serviceUrl", "projectUrl", "ServiceType", "projectType"], "wsdlLocation": ["wsDLFile", "wllAddress", "wslpFolder", "wsllUrl", "wslLocation", "wsllLocation", "wsslLocation", "wsdlFolder", "wllFolder", "wslFile", "awslFile", "wsllFolder", "wdlDirectory", "wsDLUrl", "wddlFolder", "wsdlDirectory", "wslpFile", "wslpDirectory", "awslLocation", "wsslFolder", "wssdAddress", "wdlAddress", "awslDirectory", "wsdlUrl", "wsllFile", "wddlFile", "wslUrl", "wsDLLocation", "wssdFolder", "wdlFile", "awsdlLocation", "awslUrl", "wddlDirectory", "wllLocation", "wslFolder", "wsdlFile", "wsslFile", "wsDLDirectory", "wsllDirectory", "awsdlDirectory", "wsllAddress", "wsdlAddress", "wddlLocation", "wssdFile", "wslpLocation", "wdlFolder", "wdlLocation", "wssdLocation", "wllFile", "awsdlUrl", "wsslAddress", "awsdlFile", "wslDirectory"], "endpoint": ["endsocol", " endpointer", "ENDpoint", "endocol", "endination", "EndPoint", "enPoint", "endsword", "startaddress", " endPoint", "startpoint", "Endpoint", "endpointer", "endpo", " endpo", " endaddress", "enaddress", "enpointer", "Endocol", " endocol", "Endpo", "Endpoints", " endword", "enpoints", "enination", "ENDpoints", "Endination", "Endword", "ENDination", "endspo", "ENDPoint", "endPoint", "endaddress", "endword", "endpoints", "startPoint", "enpoint", "startpointer", "endspoint"], "fileLocation": ["fileUrl", "FILEDirectory", " fileDirectory", "fileDirectory", "fileURI", "FILEUrl", "FileLocation", "FileUrl", " fileURI", "FileDirectory", "FILEURI", " fileUrl", "FileURI", "FILELocation"], "tempDir": [" temporaryDir", "tmpVer", " tempVer", "TempDir", " temporaryPath", "tempdir", "tmpDir", "tempVer", "Tempdir", "tmpDirectory", "tmpPath", " temporaryDirectory", "tempPath", " tempdir", " tempPath", " tempDirectory", "tmpdir", "TempDirectory", "TempPath", "tempDirectory", " temporaryVer"], "url": ["image", "client", "service", "sl", "ul", "stream", "host", "socket", "el", "fl", "ls", "server", "coll", "address", "conn", "open", "connection", "http", "URL", "path", "pull", "io", "ssl", "file", "f", "Url", "channel", "base", "download", "contact", "log", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "WSDLFile": ["WINDELFolder", "WSDDLPath", "WSDDLSourceFile", "WDDLSourceFile", "WDDlFile", "WINDLPath", "WDDLBase", "WSDLFolder", "WSDDLFolder", "WSDLLFolder", "WDDlSourceFile", "WSDELFolder", "WSDLSourceFile", "WINDLFile", "WSDDLFiles", "WDDLPath", "WSDLLPath", "WDDlfile", "WSDlSourceFile", "WSDLfile", "WSDlFile", "WINDLFiles", "WSDDLfile", "WSDlBase", "WINDLFolder", "WSDLPath", "WINDELFiles", "WSDLLFiles", "WDDlFolder", "WDDlBase", "WSDELFiles", "WSDLFiles", "WSDELFile", "WDDLFile", "WDDLFolder", "WSDLLSourceFile", "WSDlfile", "WDDLfile", "WSDDLBase", "WDDlPath", "WSDLLBase", "WSDLLfile", "WSDLBase", "WSDLLFile", "WINDELFile", "WSDlFolder", "WSDELPath", "WSDDLFile", "WSDlPath", "WINDELPath"], "tmpWSDLFile": ["tmpWDDLFolder", "tmpWDDlFile", "tmpWSDLFiles", "tmpWDDLFiles", "tmpWSDlUrl", "tmpWSDlFile", "tmpWSDELUrl", "tmpWSDELFile", "tmpWDDlFiles", "tmpWDDlUrl", "tmpWSDlFolder", "tmpWDDELFiles", "tmpWSDLLUrl", "tmpWDDELLocation", "tmpWDDLLocation", "tmpWSDlLocation", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDDLFile", "tmpWSDDLLocation", "tmpWSDLLFiles", "tmpWSDlFiles", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDLLFolder", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWDDlFolder", "tmpWSDELFolder", "tmpWSDDLUrl", "tmpWDDELFile", "tmpWSDDLFiles", "tmpWDDLUrl", "tmpWDDELUrl", "tmpWSDLUrl"], "inputFile": ["InputFile", " inputPage", "tempFile", "tempBase", " inputBase", " inputFactory", "InputBuffer", " inputPlace", "tempPage", "outputFile", "InputFiles", "outputDir", " inputfile", "inputUrl", "InputUrl", "tempBuffer", " inputStream", "inputBase", "Inputfile", "InputDir", "inputPlace", "requestStream", "requestFile", " inputFiles", "inputFactory", "tempfile", "outputFiles", "tempUrl", "InputStream", "InputFactory", "InputPage", "inputBuffer", "InputBase", "InputPlace", "inPage", " inputBuffer", " inputUrl", "inputfile", "inDir", "inputFiles", "infile", " inputDir", "inputDir", "inFile", "inputPage", "tempFactory", "tempPlace", "requestFiles", "outputfile", "inputStream", "requestfile"], "tmpFile": ["tempFile", "uploadStream", "TempFiles", "uploadFiles", "tempPage", " tmpPage", "tmpPage", "uploadFile", " tmpDirectory", " tmpFiles", "tmpFiles", "TempPage", "TempFile", "tmpDirectory", "tempFiles", "inputDocument", "uploadDocument", "tempStream", "tempDirectory", "inputFiles", "tempDocument", "inputStream", "tmpStream", "TempDirectory"], "in": ["r", "image", "client", "m", "p", "pin", "inn", "gin", "is", "socket", "init", "impl", "input", "on", "id", "din", "conn", "lin", "connection", "inner", "ssl", "file", "f", "login", "data", "ins", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "timeout", "client", "writer", "sync", "output", "socket", "input", "copy", "on", "parent", "server", "cache", "conn", "to", "group", "connection", "inner", "io", "line", "file", "conf", "part", "ch", "o", "channel", "conv", "err", "can", "log", "net", "co", "name", "bin", "In", "again", "OUT", "IN", "outs", "outer", "source", "up", "c", "inc"], "con": ["plain", "client", "connect", "Conn", "sync", "gin", "socket", "cn", "rc", "thin", "CON", "com", "conn", "open", "ran", "connection", "nc", "bc", "inner", "cm", "ssl", "uc", "fc", "rec", "conf", "Con", "kin", "ctrl", "en", "ch", "close", "channel", "conv", "can", "ins", "co", "un", "IN", "win", "c", "inc"], "fileLength": ["fileSize", "contentSize", "FileLength", " fileWidth", "channelWidth", "contentLen", "FileSize", "channelLen", "filelength", "fileLen", "FileLen", "FileWidth", " filelength", "channelLength", "channelSize", "contentlength", " fileSize", "fileWidth", " fileLen", "Filelength", "contentLength"], "channelIn": ["channelin", " channelConn", "ChannelIn", " channelin", "Channelin", "connectionIn", "channelConn", "connectionOut", "connectionin", "characterIN", "resourceIN", "connectionConn", "characterIn", "resourcein", "channelIN", "resourceOut", "ChannelIN", "ChannelConn", " channelIN", "resourceIn", "characterin", "characterOut", "ChannelOut"], "channelOut": ["connectionOutside", "ChannelOutput", "ChannelIn", "channelOutside", " channelOutput", "channelOUT", "connectionIn", "chanIn", "connectionOut", "canIn", "connectionOutput", "chanout", "chanOutside", "ChannelOutside", " channelout", "canOutside", "canOUT", "chanOUT", "Channelout", "channelout", "connectionout", "chanOut", "channelOutput", "canOut", "ChannelOUT", "ChannelOut"], "tmpDocument": ["tempContent", "tempFile", "tmNode", "newFile", "tmFile", "tempdocument", "tmdocument", " tmpNode", "tempNode", " tmpContent", "tmpDoc", "tmpdocument", "tmpContent", "tempDoc", "newDocument", "tmpNode", "mpFile", " tmpdocument", "newContent", " tmpDoc", "mpNode", "tempDocument", "newdocument", "tmDocument", "mpDoc", "mpDocument"], "nl1": ["arl1", "jlone", "nn2", "nn0", "arl5", "nl5", "jl5", "klFirst", "ln11", "kl1", "nn6", "nn1", "arlFirst", "NL0", "NL6", "NL11", "klone", "NL1", "jlFirst", "ln6", "nl2", "nn11", "ln1", "jl1", "dl0", "dl1", "nlFirst", "nl11", "nl0", "NL2", "kl5", "ln2", "arlone", "nlone", "dl2", "nl6"], "i": ["ai", "ip", "uli", "m", "j", "p", "ie", "n", "eni", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "index", "li", "ii", "io", "iu", "z", "ini", "bi", "part", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "chi", "qi", "uri", "I"], "node1": ["layerOne", "node91", "layer2", "node0", " node0", "nodeone", "Node1", "packageOne", "Node0", "layer91", "n0", " nodeone", "Node91", "shape91", "shapeOne", "layer1", "n1", "nOne", "packageone", "NodeOne", " nodeOne", "shapeone", " node91", "Node2", "nodeOne", "package91", "shape1", "node2", "package1", "n2", " node2"], "tmpOut": ["tempFile", "ptyOutput", "vmout", "cacheOUT", "txtOut", "vmOUT", "txtWriter", "tempout", "txtOutput", " tmpOutput", "cacheOut", "tmpIn", " tmpIn", "tempWriter", "tmpWriter", "tempOutput", "tmpOutput", "txtout", "cacheFile", "tmpout", "tmpOUT", "ptyIn", "tempIn", "ptyOut", " tmpWriter", "vmOut", "tempOut", "cacheIn", "tempOUT", " tmpout", "ptyout", " tmpOUT", "vmIn"], "retVal": [" retObj", "valRet", "RETval", "RETVal", "retval", "retObj", "RETObj", " retval", "valval", "retRet", "valObj", " retRet", "valVal", "RETRet"]}}
{"id1": "15896098", "id2": "21033686", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    public File read() throws IOException {\n        URLConnection conn = url.openConnection();\n        conn.setConnectTimeout(5000);\n        conn.setReadTimeout(5000);\n        conn.connect();\n        int length = conn.getContentLength();\n        String tempDir = System.getProperty(\"java.io.tmpdir\");\n        if (tempDir == null) {\n            tempDir = \".\";\n        }\n        File tempFile = new File(tempDir + \"/\" + new GUID() + \".dat\");\n        tempFile.deleteOnExit();\n        InputStream in = null;\n        OutputStream out = null;\n        ProgressMonitor monitor = new ProgressMonitor(parentComponent, \"Downloading \" + url, null, 0, length);\n        try {\n            in = conn.getInputStream();\n            out = new BufferedOutputStream(new FileOutputStream(tempFile));\n            int buflen = 1024 * 30;\n            int bytesRead = 0;\n            byte[] buf = new byte[buflen];\n            ;\n            long start = System.currentTimeMillis();\n            for (int nRead = in.read(buf); nRead != -1; nRead = in.read(buf)) {\n                if (monitor.isCanceled()) {\n                    return null;\n                }\n                bytesRead += nRead;\n                out.write(buf, 0, nRead);\n                monitor.setProgress(bytesRead);\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n            monitor.close();\n        }\n        return tempFile;\n    }\n", "label": 0, "substitutes": {"getSHA256Checksum": ["getSHA256Checsum", "getSHA256Checsumber", "getSHA256Chechecksums", "getSHA256Chcksam", "getSHA256Checksam", "getSHA256Chchecksam", "getSHA256Chchecksums", "getSHA256Chcksums", "getSHA256Checsam", "getSHA256Checksums", "getSHA256Cheicksam", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Cheicksums", "getSHA256Chcksum", "getSHA256Chchecksum", "getSHA256Cheicksum", "getSHA256Chchecksumber", "getSHA256Chcksumber", "getSHA256Checsums", "getSHA256Chechecksumber", "getSHA256Cheicksumber", "getSHA256Checksumber"], "source": ["buffer", "service", "size", "src", "output", "object", "input", "slice", "cache", "from", "result", "target", "format", "connection", "content", "code", "path", "message", "resource", "fp", "dest", "file", "Source", "url", "base", "data", "SOURCE", "text", "reader", "string", "seed", "uri", "ource", "config", "length", "ources"], "checksum": ["checksums", "cssum", "check256", "checkum", "hssum", "hsam", " checksums", "checksam", "cksums", " checkssum", " checksumption", " checksam", "hexumption", "hexet", "checksup", "checkssum", " checkset", "hexum", "checks256", "cksum", "checkup", "cksam", "checksumption", "ckset", "hexsum", " checksup", "cksumption", "ckssum", " checks256", "csup", "checkset", "csum", "hsum", "cs256", "hsums"], "md": ["mm", "mac", "mo", "ind", "m", "Cmd", "dig", "bf", "grad", "MB", "pd", "metadata", "M", "um", "od", "rm", "mb", "cm", "amd", "nm", "df", "wd", "dh", "mand", "bd", "gd", "f", "sm", "dm", "pm", "mt", "MD", "mp", "mc", "hd", "vd", "mag", "d", "rpm", "ms", "am", "hash", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "ByteSize", "connectionDATA", "byteInfo", "byteText", "ipDATA", "characterData", "ipArray", "connectionSize", "ByteDATA", " bytedata", "wordInfo", "wordBytes", "ByteData", "byteList", "ipNumber", "byteSize", "bitList", "ByteInfo", "byteArray", "bitText", " byteArray", "numberdata", "ByteBytes", "characterArray", "bitData", "bytedata", "pixelData", " byteNumber", "wordData", " byteBytes", "wordArray", "numberDATA", " byteString", " byteDATA", "numberData", " byteText", " byteInfo", "numberString", "byteNumber", "pixelString", "connectionArray", "byteString", "characterList", "bitDATA", "bitNumber", "pixeldata", "pixelDATA", "characterText", " byteList", "connectionData", "ipData", " byteSize", "byteBytes", "byteDATA", "bitArray"], "sb": ["db", "abb", "bp", "buffer", "bf", "src", "ab", "lb", "bs", "bt", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "bm", "fb", "kb", "bg", "mb", "ob", "buff", "gb", "pb", "ub", "bh", "bd", "eb", "buf", "binary", "wb", " SB", "BB", "sq", "b", "bsp", "xb", " eb", "si", "nb", "sv", "ws", "cb"], "i": ["r", "ai", "ip", "in", "j", "p", "h", "n", "ie", "key", "is", "q", "multi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "data", "u", "ni", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"], "hexString": ["formService", " hexArray", "shortBuffer", "charStr", "checkString", " hexStr", "hexstring", "formString", "checkService", "hexArray", " hexService", " hexFile", "hexCode", "charBuffer", "formstring", "shortString", "rawArray", "rawService", "rawstring", "crossBuffer", "charString", "crossStr", "hexFile", "checkCode", "crossFile", "exFile", "checkArray", "shortStr", "rawString", "hashService", "charArray", "exStr", " hexCode", "hashString", "exBuffer", " hexBuffer", "hashCode", "crossString", "hashArray", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "hexService", "formArray"], "hex": ["ip", "sync", "alpha", "bit", "form", "character", "serial", "nexus", "id", "ex", "sex", "cookie", "sum", "format", "wh", "exp", "num", "http", "rh", "buff", "pack", "digit", "closure", "cross", "raw", "lit", "str", "pex", "oct", "letter", "null", "none", "zip", "data", "temp", "rex", "char", "comp", "transform", "color", "text", "pixel", "bin", "coord", "string", "utf", "hash", "cmp", "shift", "length"]}}
{"id1": "2461169", "id2": "14191679", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    protected File EncodeReturn() throws EncodeFailedException, IOException {\n        CryptoClient c = getNode().getCryptoClientByID(PiggybackCrypto);\n        File tmpf = getNode().getTempFM().createNewFile(\"encodereturn\", \"download\");\n        ChannelWriter cw = new ChannelWriter(tmpf);\n        cw.putLongFile(DownloadData);\n        cw.close();\n        File encdata = c.RawEncode(tmpf, RawKey);\n        File pigdata = PigData.EncodeData(encdata);\n        File pigroute = ReturnPigRoute.EncodeData(ReturnRouteFile);\n        FileOutputStream fos = new FileOutputStream(pigroute, true);\n        FileChannel foc = fos.getChannel();\n        FileInputStream fis = new FileInputStream(pigdata);\n        FileChannel fic = fis.getChannel();\n        fic.transferTo(0, fic.size(), foc);\n        foc.close();\n        fic.close();\n        pigdata.delete();\n        ReturnRouteFile.delete();\n        encdata.delete();\n        return pigroute;\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "13362846", "id2": "18613870", "code1": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"setContenu": ["setTenu", "setContonenues", "setContonenuit", "setTenuer", "setContonenu", "setContenues", "setContineues", "setContineuer", "setContineuit", "setTonenu", "setContenuer", "setContonenuer", "setContennuer", "setTonenues", "setContennu", "setContennues", "setTonenuer", "setTenues", "setContennuit", "setContineu", "setTenuit", "setTonenuit", "setContenuit"], "contenuFichier": ["contenuPhactoryiere", "contenuPFicher", "contenuFaffier", "contenuPrefaffiers", "contenuPrefichiers", "contenuMichie", "contenuMrenchiere", "contenuTicheery", "contenuFochiere", "contenuPFochier", "contenuPrefichie", "contenuTicheiere", "contenuFicoyer", "contenuFochiers", "contenuPFochique", "contenuPhichiere", "contenuFactoryoyer", "contenuPrefichier", "contenuFrencherer", "contenuPrefaffiere", "contenuMichiere", "contenuPrefichiere", "contenuFichtieri", "contenuFichoyer", "contenuPhichier", "contenuFrenchie", "contenuFicheier", "contenuMaffiere", "contenuFrenchoyer", "contenuPhactoryier", "contenuPFocher", "contenuFaffique", "contenuPFichier", "contenuFrenchiere", "contenuFicheery", "contenuMrenchie", "contenuFicherer", "contenuFicier", "contenuFichtique", "contenuMaffiers", "contenuFicheiere", "contenuFchiere", "contenuFrenchery", "contenuTicheerer", "contenuFichique", "contenuMichique", "contenuFochier", "contenuFactoryie", "contenuTichiere", "contenuFichieri", "contenuFichtie", "contenuMichieri", "contenuFrenchique", "contenuTichier", "contenuTichery", "contenuFichery", "contenuFcherer", "contenuTicherer", "contenuPFichique", "contenuFicher", "contenuFicheerer", "contenuPhichie", "contenuMrenchique", "contenuFrenchier", "contenuFactoryier", "contenuFicie", "contenuMaffier", "contenuFicheieri", "contenuPhactoryie", "contenuPrefaffie", "contenuFochique", "contenuFaffer", "contenuFaffiere", "contenuFiciere", "contenuPFichiere", "contenuFichtiere", "contenuPhactoryoyer", "contenuMichier", "contenuFrenchiers", "contenuFichtier", "contenuMaffie", "contenuFichie", "contenuFaffiers", "contenuFicheique", "contenuFactoryiere", "contenuFicheie", "contenuFocher", "contenuFchier", "contenuFochie", "contenuTicheier", "contenuPFochiere", "contenuMrenchier", "contenuPhichoyer", "contenuFaffieri", "contenuPrefaffier", "contenuMaffieri", "contenuFicheer", "contenuMichiers", "contenuFichiers", "contenuFichiere", "contenuFchery", "contenuFaffie"], "fichierElectronique": ["fichierAdministronical", "fichierElectaronier", "fichierCentornlique", "fichierElectroneie", "fichierElectornique", "fichierElectonlique", "fichierElectronslique", "fichierAdministronslique", "fichierElectroneiere", "fichierElectproniques", "fichierElectronsiques", "fichierAdministron\u00e9e", "fichierElectromical", "fichierElectronie", "fichierElectrolie", "fichierAdministronie", "fichierElectron\u00e9e", "fichierAdministrons\u00e9e", "fichierElectronelique", "fichierAdministronsie", "fichierElectorniques", "fichierElectolonique", "fichierElectronlique", "fichierCentorniques", "fichierElectonie", "fichierAdministronlique", "fichierAdministronique", "fichierElectroneier", "fichierAdministronistic", "fichierAdministronsical", "fichierElectronier", "fichierAdministronsiques", "fichierElectromique", "fichierElectonique", "fichierElectroliere", "fichierAdministronsier", "fichierElectoloniques", "fichierCentornier", "fichierElectrolier", "fichierElectonier", "fichierElectpronistic", "fichierAustrolier", "fichierElectpronique", "fichierElectronsical", "fichierElectrons\u00e9e", "fichierElectronistic", "fichierElectronsiere", "fichierAustronique", "fichierElectaronique", "fichierAustrolique", "fichierElectrol\u00e9e", "fichierElectroneiques", "fichierAustroliere", "fichierAdministroniques", "fichierElectaronie", "fichierElectronsier", "fichierCentronlique", "fichierCentornique", "fichierCentronique", "fichierAustroniques", "fichierAdministronier", "fichierElectromiques", "fichierElectronical", "fichierElectpronical", "fichierElectroniere", "fichierCentronier", "fichierElectronica", "fichierElectroneique", "fichierElectroniques", "fichierElectaron\u00e9e", "fichierAdministronsique", "fichierElectoloniere", "fichierElectrolica", "fichierElectronsica", "fichierElectronsistic", "fichierElectolonica", "fichierAustroliques", "fichierElectromistic", "fichierElectroliques", "fichierElectronsique", "fichierAustronier", "fichierElectornier", "fichierAustroniere", "fichierElectornlique", "fichierElectrolique", "fichierAdministronsistic", "fichierCentroniques", "fichierElectronsie"], "utilisateurCourant": ["utilisateurParticipant", "utilisateurGovernante", "utilisateurParticipants", "utilisationApplicante", "utilisateurCourante", "utilisateurGovernant", "utilisationCourateur", "utilisationApplicants", "utilisateurGovernants", "utilisateurParticipateur", "utilisateurCourants", "utilisationCourants", "utilisationApplicateur", "utilisationCourante", "utilisationCourant", "utilisateurApplicants", "utilisateurCourateur", "utilisateurApplicant", "utilisateurApplicateur", "utilisationApplicant", "utilisateurParticipante", "utilisateurApplicante", "utilisateurGovernateur"], "support": ["client", "accept", "service", "compatible", "best", "protection", "concept", "summary", "knowledge", "help", "proxy", "bank", "evidence", "ann", "pport", "info", "format", "share", "media", "services", "pull", "library", "Support", "supp", "cover", "storage", "util", "feature", "review", "supported", "Library", "control", "system", "contact", "know", "allow", "force", "document", "settings", "utils", "plugin", "friend", "facebook", "push", "respect", "config", " Support"], "ficheDocument": ["affinedocument", " fcheDocument", "fraudNumber", "finedocument", "affineDoc", "infraudDocument", "fielCompany", "fchedocument", "ficheDocuments", "fchaDoc", "afficheDoc", "FicheDocument", "inficheNumber", "fraudDoc", "fraudCompany", "fineFeature", "fineDocument", " ficheDirectory", "fraudDocument", "fraudCatalog", "financedocument", "ficheCompany", "friqueContent", "financeNumber", "fcheDoc", "fruitDocument", "inficheDoc", "fielDocument", "fcheDirectory", "foinedocument", "enfoiceDirectory", " ficheMatrix", "facheMatrix", " ficheDocuments", "ficheNumber", "friquedocument", "foineFeature", "fruitNumber", "foiceDocument", "enfoiceCatalog", "fagueDocuments", "affineFeature", "fineDoc", "fruitdocument", "FicheDoc", "foineDoc", "fagueDocument", "friqueDocument", "fetchDocument", "fcheMatrix", "facheDocuments", "Fichedocument", "financeDoc", "affichedocument", "enficheDocument", "fruitDoc", "frauddocument", "ficheDirectory", "afficheFeature", "FcheDocument", "FcheDoc", "ficheContent", "fetchFeature", "fraudDirectory", "enfoiceDocument", "Fchedocument", "fetchDoc", "FcheContent", "infraudDoc", "foiceCompany", "ficheFeature", "foiceCatalog", "fetchdocument", " fcheDocuments", "infraudNumber", "fchaDocument", "facheDocument", "enfoiceCompany", "fcheContent", " fcheMatrix", "fichedocument", "infichedocument", "fchadocument", "fcheDocuments", "infrauddocument", "inficheDocument", "fielCatalog", "foiceDirectory", "fagueDirectory", "fchaContent", "fcheDocument", "enficheDirectory", " fcheDirectory", "affineDocument", "ficheDoc", "fielDirectory", "financeDocument", "ficheCatalog", "enficheCatalog", "ficheMatrix", "FicheContent", "afficheDocument", "fagueMatrix", "foineDocument", "facheDirectory", "friqueDoc", "enficheCompany"], "nomFichier": ["nomPrefchier", "nomFchrier", "nomFicherer", "nomFiscery", "nomPchier", "nomFchery", "nomWchiere", "nomFchy", "nomF\u00e9tier", "nomFichter", "nomPrefichrier", "nomPichy", "nomPrefichire", "nomWichery", "nomFchien", "nomFacher", "nomFiscer", "nomFichiner", "nomFrenchier", "nomPhichier", "nomVich\u00e8re", "nomNichtiller", "nomFisciller", "nomFithieri", "nomVicher", "nomPichien", "nomFithier", "nomNicher", "nomFichy", "nomPhachier", "nomFachire", "nomFiquire", "nomFachrier", "nomFochire", "nomFachier", "nomF\u00e9ty", "nomPchien", "nomNichtiner", "nomNichtier", "nomWichire", "nomPichery", "nomFichien", "nomFochery", "nomPrefchieri", "nomPhachiere", "nomFachiner", "nomNichiner", "nomNichier", "nomFichtier", "nomVchier", "nomPrefichieri", "nomFichtire", "nomVch\u00e8re", "nomVichier", "nomFachiere", "nomFisciner", "nomPhichiere", "nomPhicherer", "nomFichtiller", "nomFochiere", "nomFchieri", "nomFiscien", "nomPhichieri", "nomVchieri", "nomPrefchrier", "nomFrenchieri", "nomFichtiner", "nomFchire", "nomFichterer", "nomPrefchire", "nomFrencher", "nomVcher", "nomFach\u00e8re", "nomPhacherer", "nomFiscier", "nomFich\u00e8re", "nomFachieri", "nomFiquier", "nomFithiere", "nomWchire", "nomWichier", "nomFacherer", "nomWchery", "nomFichrier", "nomNichiller", "nomFiscy", "nomWchier", "nomPchy", "nomPrefichier", "nomWichiere", "nomNichter", "nomFochier", "nomFrench\u00e8re", "nomFcher", "nomF\u00e9tery", "nomFichtieri", "nomFicher", "nomVichieri", "nomFchier", "nomFichieri", "nomFch\u00e8re", "nomFichiller", "nomFachiller", "nomFiqurier", "nomFichiere", "nomPchery", "nomFichtiere", "nomFiquieri", "nomF\u00e9tien", "nomFichery", "nomFichtery", "nomFichire", "nomFchiere", "nomPhachieri", "nomFitherer", "nomPichier"], "extension": ["Extion", "EXTime", "encression", "Extception", "Extression", "anchension", "EXTension", "exception", "Extension", "extression", "Extime", "anchensions", "encension", "encion", "EXTensions", "anchime", "extion", "extensions", "exression", "Extensions", "extception", "exion", "encception", "extime", "exension"], "fichierElectroniqueExistant": ["fichierElectroniqueexist", "fichierElectroniqueSilingual", "fichierElectroniquesExclusive", "fichierElectroniqueSistance", "fichierElectroniqueexilingual", "fichierElectroniqueExistent", "fichierElectroniqueExclusive", "fichierElectroniqueexistant", "fichierElectroniqueExplclusive", "fichierElectroniqueXivist", "fichierElectroniqueExists", "fichierElectroniqueexistent", "fichierElectroniqueXist", "fichierElectroniqueExplistance", "fichierElectroniqueExplist", "fichierElectroniquesXilingual", "fichierElectroniquesXists", "fichierElectroniqueexclusive", "fichierElectroniqueXistance", "fichierElectroniqueXclusive", "fichierElectroniquesExistance", "fichierElectroniqueXilingual", "fichierElectroniquesXistent", "fichierElectroniqueExplivist", "fichierElectroniquesXistance", "fichierElectroniqueSistent", "fichierElectroniqueexists", "fichierElectroniqueExplists", "fichierElectroniqueExist", "fichierElectroniquesXist", "fichierElectroniqueXistant", "fichierElectroniqueexivist", "fichierElectroniqueExistance", "fichierElectroniquesExist", "fichierElectroniquesExistant", "fichierElectroniqueXistent", "fichierElectroniqueExilingual", "fichierElectroniquesExivist", "fichierElectroniqueExplistant", "fichierElectroniquesExists", "fichierElectroniqueXists", "fichierElectroniquesXclusive", "fichierElectroniquesXivist", "fichierElectroniqueExivist", "fichierElectroniqueSistant", "fichierElectroniquesExilingual", "fichierElectroniquesExistent", "fichierElectroniqueexistance", "fichierElectroniquesXistant"], "idIgid": ["idUguname", "idIggid", "idIgudid", "idIogid", "idIogdid", "idEGdid", "idIgdid", "idIguname", "idIgbit", "idIguid", "idUgID", "idIgnids", "idIgubit", "idEGid", "idIguID", "idIgmID", "idIgnid", "idEGids", "idEgid", "idIggod", "idIgmid", "idUguid", "idIguids", "idUgname", "idIguod", "idIgnID", "idIGbit", "idIgenID", "idEGbit", "idIgids", "idEgdid", "idIgenids", "idIgID", "idUguids", "idEgids", "idIGid", "idIGids", "idIggID", "idIggids", "idIgnod", "idIgname", "idIogids", "idIGdid", "idIgenid", "idIgod", "idUgid", "idIogbit", "idUgids", "idIgenname", "idUguID", "idIgmids", "idEgbit", "idIgmname"], "inputStream": ["outputThread", " inputThread", "outputstream", "eventStreamer", "Inputstream", " inputSteam", "outputStreamer", "InputThread", "InputSteam", " inputstream", "eventStream", "outputSteam", "InputLength", "InputStreamer", "inputSteam", "outputLength", "InputStream", "inputThread", " inputLength", "eventstream", "inputStreamer", "eventSteam", "inputLength", "inputstream"], "outputStream": ["outputContext", "officeSteam", "entityStream", "outputstream", "inputContext", "OutputStream", "entityStreamer", "OutputStreamer", " outputstream", " outputSteam", "outputStreamer", "outputSteam", "entitySteam", "officeStream", "inputSteam", "entitystream", "officestream", "Outputstream", "OutputContext", "officeStreamer", "OutputSteam", " outputContext", "inputStreamer", "inputstream"], "typeMime": ["TypeSmime", "TypeSmangle", "typeMatime", "typeMatimes", "typeMetime", "typeMetide", "typeSmime", "typeMatide", "TypeSmimes", "TypeMide", "typeMimes", "TypeSmide", "typeMangle", "TypeMimes", "typeMatangle", "typeSmimes", "TypeMime", "typeMetimes", "typeMide", "typeSmangle", "typeSmide", "typeMetangle", "TypeMangle"], "tailleFichier": [" taillefichie", " tailleFicheiers", " tailleFicheie", " taillefichier", " taillefochie", " tailleFignie", " tailleFigniers", " taillefochiers", " tailleFocher", " taillefochier", " tailleFigner", " taillefocher", " tailleFignier", " tailleFicheer", " tailleFicher", " tailleficher", " taillefichiers", " tailleFichie", " tailleFochiers", " tailleFochie", " tailleFicheier", " tailleFichiers", " tailleFochier"]}}
{"id1": "18891988", "id2": "4562786", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private String GetResponse(URL url) {\n        String content = null;\n        try {\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.setDoOutput(false);\n            conn.setRequestMethod(\"GET\");\n            if (conn.getResponseCode() == HttpURLConnection.HTTP_OK) {\n                BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n                String line;\n                while ((line = br.readLine()) != null) content += line;\n            } else {\n            }\n        } catch (MalformedURLException e) {\n            e.getStackTrace();\n        } catch (IOException e) {\n            e.getStackTrace();\n        }\n        return content;\n    }\n", "label": 0, "substitutes": {"getFile": ["getfile", "loadFile", "loadString", "Getfile", "GetFilename", "GetString", "downloadFilename", "loadFilename", "downloadString", "getString", "getFilename", "loadfile", "downloadFile", "GetFile", "downloadfile"], "serviceName": ["servicePath", "projectName", "packagename", "serviceType", "projectPath", "packageName", "ServiceName", " servicePath", " servicename", "packagePath", " serviceType", "packageUrl", "serviceUrl", "Servicename", "ServicePath", "servicename", "ServiceUrl", " serviceUrl", "projectUrl", "ServiceType", "projectType"], "wsdlLocation": ["wsDLFile", "wllAddress", "wslpFolder", "wsllUrl", "wslLocation", "wsllLocation", "wsslLocation", "wsdlFolder", "wllFolder", "wslFile", "awslFile", "wsllFolder", "wdlDirectory", "wsDLUrl", "wddlFolder", "wsdlDirectory", "wslpFile", "wslpDirectory", "awslLocation", "wsslFolder", "wssdAddress", "wdlAddress", "awslDirectory", "wsdlUrl", "wsllFile", "wddlFile", "wslUrl", "wsDLLocation", "wssdFolder", "wdlFile", "awsdlLocation", "awslUrl", "wddlDirectory", "wllLocation", "wslFolder", "wsdlFile", "wsslFile", "wsDLDirectory", "wsllDirectory", "awsdlDirectory", "wsllAddress", "wsdlAddress", "wddlLocation", "wssdFile", "wslpLocation", "wdlFolder", "wdlLocation", "wssdLocation", "wllFile", "awsdlUrl", "wsslAddress", "awsdlFile", "wslDirectory"], "endpoint": ["endsocol", " endpointer", "ENDpoint", "endocol", "endination", "EndPoint", "enPoint", "endsword", "startaddress", " endPoint", "startpoint", "Endpoint", "endpointer", "endpo", " endpo", " endaddress", "enaddress", "enpointer", "Endocol", " endocol", "Endpo", "Endpoints", " endword", "enpoints", "enination", "ENDpoints", "Endination", "Endword", "ENDination", "endspo", "ENDPoint", "endPoint", "endaddress", "endword", "endpoints", "startPoint", "enpoint", "startpointer", "endspoint"], "fileLocation": ["fileUrl", "FILEDirectory", " fileDirectory", "fileDirectory", "fileURI", "FILEUrl", "FileLocation", "FileUrl", " fileURI", "FileDirectory", "FILEURI", " fileUrl", "FileURI", "FILELocation"], "tempDir": [" temporaryDir", "tmpVer", " tempVer", "TempDir", " temporaryPath", "tempdir", "tmpDir", "tempVer", "Tempdir", "tmpDirectory", "tmpPath", " temporaryDirectory", "tempPath", " tempdir", " tempPath", " tempDirectory", "tmpdir", "TempDirectory", "TempPath", "tempDirectory", " temporaryVer"], "url": ["image", "client", "service", "sl", "ul", "stream", "host", "socket", "el", "fl", "ls", "server", "coll", "address", "conn", "open", "connection", "http", "URL", "path", "pull", "io", "ssl", "file", "f", "Url", "channel", "base", "download", "contact", "log", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "WSDLFile": ["WINDELFolder", "WSDDLPath", "WSDDLSourceFile", "WDDLSourceFile", "WDDlFile", "WINDLPath", "WDDLBase", "WSDLFolder", "WSDDLFolder", "WSDLLFolder", "WDDlSourceFile", "WSDELFolder", "WSDLSourceFile", "WINDLFile", "WSDDLFiles", "WDDLPath", "WSDLLPath", "WDDlfile", "WSDlSourceFile", "WSDLfile", "WSDlFile", "WINDLFiles", "WSDDLfile", "WSDlBase", "WINDLFolder", "WSDLPath", "WINDELFiles", "WSDLLFiles", "WDDlFolder", "WDDlBase", "WSDELFiles", "WSDLFiles", "WSDELFile", "WDDLFile", "WDDLFolder", "WSDLLSourceFile", "WSDlfile", "WDDLfile", "WSDDLBase", "WDDlPath", "WSDLLBase", "WSDLLfile", "WSDLBase", "WSDLLFile", "WINDELFile", "WSDlFolder", "WSDELPath", "WSDDLFile", "WSDlPath", "WINDELPath"], "tmpWSDLFile": ["tmpWDDLFolder", "tmpWDDlFile", "tmpWSDLFiles", "tmpWDDLFiles", "tmpWSDlUrl", "tmpWSDlFile", "tmpWSDELUrl", "tmpWSDELFile", "tmpWDDlFiles", "tmpWDDlUrl", "tmpWSDlFolder", "tmpWDDELFiles", "tmpWSDLLUrl", "tmpWDDELLocation", "tmpWDDLLocation", "tmpWSDlLocation", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDDLFile", "tmpWSDDLLocation", "tmpWSDLLFiles", "tmpWSDlFiles", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDLLFolder", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWDDlFolder", "tmpWSDELFolder", "tmpWSDDLUrl", "tmpWDDELFile", "tmpWSDDLFiles", "tmpWDDLUrl", "tmpWDDELUrl", "tmpWSDLUrl"], "inputFile": ["InputFile", " inputPage", "tempFile", "tempBase", " inputBase", " inputFactory", "InputBuffer", " inputPlace", "tempPage", "outputFile", "InputFiles", "outputDir", " inputfile", "inputUrl", "InputUrl", "tempBuffer", " inputStream", "inputBase", "Inputfile", "InputDir", "inputPlace", "requestStream", "requestFile", " inputFiles", "inputFactory", "tempfile", "outputFiles", "tempUrl", "InputStream", "InputFactory", "InputPage", "inputBuffer", "InputBase", "InputPlace", "inPage", " inputBuffer", " inputUrl", "inputfile", "inDir", "inputFiles", "infile", " inputDir", "inputDir", "inFile", "inputPage", "tempFactory", "tempPlace", "requestFiles", "outputfile", "inputStream", "requestfile"], "tmpFile": ["tempFile", "uploadStream", "TempFiles", "uploadFiles", "tempPage", " tmpPage", "tmpPage", "uploadFile", " tmpDirectory", " tmpFiles", "tmpFiles", "TempPage", "TempFile", "tmpDirectory", "tempFiles", "inputDocument", "uploadDocument", "tempStream", "tempDirectory", "inputFiles", "tempDocument", "inputStream", "tmpStream", "TempDirectory"], "in": ["r", "image", "client", "m", "p", "pin", "inn", "gin", "is", "socket", "init", "impl", "input", "on", "id", "din", "conn", "lin", "connection", "inner", "ssl", "file", "f", "login", "data", "ins", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "timeout", "client", "writer", "sync", "output", "socket", "input", "copy", "on", "parent", "server", "cache", "conn", "to", "group", "connection", "inner", "io", "line", "file", "conf", "part", "ch", "o", "channel", "conv", "err", "can", "log", "net", "co", "name", "bin", "In", "again", "OUT", "IN", "outs", "outer", "source", "up", "c", "inc"], "con": ["plain", "client", "connect", "Conn", "sync", "gin", "socket", "cn", "rc", "thin", "CON", "com", "conn", "open", "ran", "connection", "nc", "bc", "inner", "cm", "ssl", "uc", "fc", "rec", "conf", "Con", "kin", "ctrl", "en", "ch", "close", "channel", "conv", "can", "ins", "co", "un", "IN", "win", "c", "inc"], "fileLength": ["fileSize", "contentSize", "FileLength", " fileWidth", "channelWidth", "contentLen", "FileSize", "channelLen", "filelength", "fileLen", "FileLen", "FileWidth", " filelength", "channelLength", "channelSize", "contentlength", " fileSize", "fileWidth", " fileLen", "Filelength", "contentLength"], "channelIn": ["channelin", " channelConn", "ChannelIn", " channelin", "Channelin", "connectionIn", "channelConn", "connectionOut", "connectionin", "characterIN", "resourceIN", "connectionConn", "characterIn", "resourcein", "channelIN", "resourceOut", "ChannelIN", "ChannelConn", " channelIN", "resourceIn", "characterin", "characterOut", "ChannelOut"], "channelOut": ["connectionOutside", "ChannelOutput", "ChannelIn", "channelOutside", " channelOutput", "channelOUT", "connectionIn", "chanIn", "connectionOut", "canIn", "connectionOutput", "chanout", "chanOutside", "ChannelOutside", " channelout", "canOutside", "canOUT", "chanOUT", "Channelout", "channelout", "connectionout", "chanOut", "channelOutput", "canOut", "ChannelOUT", "ChannelOut"], "tmpDocument": ["tempContent", "tempFile", "tmNode", "newFile", "tmFile", "tempdocument", "tmdocument", " tmpNode", "tempNode", " tmpContent", "tmpDoc", "tmpdocument", "tmpContent", "tempDoc", "newDocument", "tmpNode", "mpFile", " tmpdocument", "newContent", " tmpDoc", "mpNode", "tempDocument", "newdocument", "tmDocument", "mpDoc", "mpDocument"], "nl1": ["arl1", "jlone", "nn2", "nn0", "arl5", "nl5", "jl5", "klFirst", "ln11", "kl1", "nn6", "nn1", "arlFirst", "NL0", "NL6", "NL11", "klone", "NL1", "jlFirst", "ln6", "nl2", "nn11", "ln1", "jl1", "dl0", "dl1", "nlFirst", "nl11", "nl0", "NL2", "kl5", "ln2", "arlone", "nlone", "dl2", "nl6"], "i": ["ai", "ip", "uli", "m", "j", "p", "ie", "n", "eni", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "index", "li", "ii", "io", "iu", "z", "ini", "bi", "part", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "chi", "qi", "uri", "I"], "node1": ["layerOne", "node91", "layer2", "node0", " node0", "nodeone", "Node1", "packageOne", "Node0", "layer91", "n0", " nodeone", "Node91", "shape91", "shapeOne", "layer1", "n1", "nOne", "packageone", "NodeOne", " nodeOne", "shapeone", " node91", "Node2", "nodeOne", "package91", "shape1", "node2", "package1", "n2", " node2"], "tmpOut": ["tempFile", "ptyOutput", "vmout", "cacheOUT", "txtOut", "vmOUT", "txtWriter", "tempout", "txtOutput", " tmpOutput", "cacheOut", "tmpIn", " tmpIn", "tempWriter", "tmpWriter", "tempOutput", "tmpOutput", "txtout", "cacheFile", "tmpout", "tmpOUT", "ptyIn", "tempIn", "ptyOut", " tmpWriter", "vmOut", "tempOut", "cacheIn", "tempOUT", " tmpout", "ptyout", " tmpOUT", "vmIn"], "retVal": [" retObj", "valRet", "RETval", "RETVal", "retval", "retObj", "RETObj", " retval", "valval", "retRet", "valObj", " retRet", "valVal", "RETRet"]}}
{"id1": "11484416", "id2": "7499186", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    private void bootKernel(String conf) {\n        try {\n            AssetManager am = getResources().getAssets();\n            InputStream is = am.open(conf + \".conf\");\n            Properties props = new Properties();\n            props.load(is);\n            is.close();\n            Log.d(\"bootKernel\", \"Listing sdcard assets...\");\n            String[] sdcardfiles = am.list(\"sdcard\");\n            for (String file : sdcardfiles) {\n                Log.d(\"bootKernel\", \"Copying sdcard asset \" + file + \".\");\n                AssetFileDescriptor afd = am.openFd(\"sdcard/\" + file);\n                FileInputStream fis = afd.createInputStream();\n                FileChannel fic = fis.getChannel();\n                FileOutputStream fos = new FileOutputStream(\"/sdcard/\" + file);\n                FileChannel foc = fos.getChannel();\n                fic.transferTo(0, fic.size(), foc);\n                fic.close();\n                foc.close();\n            }\n            Configuration gconf = new JavaPropertiesConfiguration(props);\n            Configuration bconf = gconf.subset(\"boot\");\n            String kclass_name = bconf.getString(\"kernel\");\n            Log.d(\"bootKernel\", \"Attempting to load kernel from class '\" + kclass_name + \"'...\");\n            Class<? extends Kernel> kclass = Class.forName(kclass_name).asSubclass(Kernel.class);\n            Kernel kernel = kclass.newInstance();\n            Log.d(\"bootKernel\", \"Kernel loaded, proceeding with boot...\");\n            BootContext bctx = new SimpleBootContext(gconf, AndroidBridgeService.class, AndroidBridgeServiceImpl.class);\n            kernel.boot(bctx).get();\n            Log.d(\"bootKernel\", \"Kernel boot complete.\");\n        } catch (Exception e) {\n            Log.e(\"bootKernel\", \"Unable to boot kernel due to exception.\", e);\n            finish();\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "15810440", "id2": "13499897", "code1": "    public static void addRecipe(String name, String instructions, int categoryId, String[][] ainekset) throws Exception {\n        PreparedStatement pst1 = null;\n        PreparedStatement pst2 = null;\n        ResultSet rs = null;\n        int retVal = -1;\n        try {\n            pst1 = conn.prepareStatement(\"INSERT INTO recipes (name, instructions, category_id) VALUES (?, ?, ?)\");\n            pst1.setString(1, name);\n            pst1.setString(2, instructions);\n            pst1.setInt(3, categoryId);\n            if (pst1.executeUpdate() > 0) {\n                pst2 = conn.prepareStatement(\"SELECT recipe_id FROM recipes WHERE name = ? AND instructions = ? AND category_id = ?\");\n                pst2.setString(1, name);\n                pst2.setString(2, instructions);\n                pst2.setInt(3, categoryId);\n                rs = pst2.executeQuery();\n                if (rs.next()) {\n                    int id = rs.getInt(1);\n                    System.out.println(\"Lis\ufffdt\ufffd\ufffdn ainesosat\");\n                    String[] aines;\n                    for (int i = 0; i < ainekset.length; ++i) {\n                        aines = ainekset[i];\n                        addIngredient(id, aines[0], aines[1], Integer.parseInt(aines[2]), Integer.parseInt(aines[3]));\n                    }\n                    retVal = id;\n                } else {\n                    retVal = -1;\n                }\n            } else {\n                retVal = -1;\n            }\n            conn.commit();\n        } catch (Exception e) {\n            conn.rollback();\n            throw new Exception(\"Reseptin lis\ufffdys ep\ufffdonnistui. Poikkeus: \" + e.getMessage());\n        }\n    }\n", "code2": "    public static String CopyFile(String sourcefile, String destfile) throws FileNotFoundException, IOException {\n        int last = destfile.lastIndexOf('/');\n        if (last < 0) {\n            DrxWriteError(\"CopyFile\", \"Destination filepath \" + destfile + \" doesn't contain /\");\n            throw new java.io.FileNotFoundException(destfile);\n        }\n        String parent = destfile.substring(0, last);\n        if (parent.length() > 0) {\n            File f = new File(parent);\n            if (!f.isDirectory()) {\n                if (!f.mkdirs()) {\n                    DrxWriteError(\"CopyFile\", \"Folder \" + parent + \" doesn't exist, cannot create\");\n                }\n            }\n        }\n        FileChannel srcChannel = new FileInputStream(sourcefile).getChannel();\n        FileChannel dstChannel = new FileOutputStream(destfile).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n        return destfile;\n    }\n", "label": 0, "substitutes": {"addRecipe": ["addApplication", "AddRecipe", "saveFood", "AddFood", "AddCourse", "saveCourse", "setFood", "addCourse", "AddApplication", "setRecipe", "setCourse", "saveApplication", "saveRecipe", "addFood", "setApplication"], "name": ["image", "template", "large", "size", "one", "n", "full", "label", "key", "class", "comment", "action", "common", "old", "title", "version", "parent", "home", "ame", "plus", "family", "alias", "module", "mini", "connection", "time", "path", "word", "description", "file", "part", "config", "NAME", "url", "prefix", "none", "base", "model", "data", "type", "create", "database", "Name", "collection", "search", "admin", "names", "company", "table", "style", "string", "named", "source", "filename", "username"], "instructions": [" inscriptures", "insstructions", "insemptories", "injection", "incriptions", " instructutions", "injectures", "inSTRUCTures", "insstructories", "INstructs", "inemptations", " instructures", "INstruction", "incorrection", "inscriptions", "injectutions", "inemptes", "inemptures", "inemptutions", "inscriptutions", "inSTRUCTs", "insemptures", "injects", " inscriptations", "INSTRUCTion", "inemptories", "insemption", "inSTRUCTions", "instruction", "inscriptures", "inscriptations", "insstructures", "incorrections", "instructories", "injectations", "instructes", "incorrectories", "insstructes", "INstructures", "instructs", "injections", "INSTRUCTures", "instructations", " instructations", "incriptes", "inemption", "INSTRUCTs", "INstructions", "inscriptories", "incorrectures", "INSTRUCTions", "injectes", "inscription", "instructures", "instructutions", "insemptes", "incriptures", " inscriptions", " inscriptutions", "insstruction", "inempts", "inSTRUCTion", "insemptions", "incription", "inemptions"], "categoryId": ["categoryType", " categoryCode", "CategoryId", "sectionID", "CategoryInfo", "categoryID", "sectionCode", "categoryid", "channelId", "packageInfo", " categoryInt", "channelType", "categoryCode", "currencyid", " categoryid", "ategoryId", "ategoryType", "ategorySize", "sectionId", "currencyID", "currencyId", "packageID", "packageId", " categorySize", "packageInt", "categorySize", "CategoryID", " categoryType", "currencyCode", "CategoryInt", "channelSize", "channelid", "ategoryid", "categoryInt", " categoryInfo", " categoryID", "categoryInfo", "sectionid"], "ainekset": ["aincesset", "aineksset", "rainekset", "aineksette", "ainewsset", "ainesset", "aineksET", "aineeksET", "ainnerset", "ainesette", "raineeksette", "raineksette", "aineksets", "ainscesset", "aineticsET", "raineekset", "aineeeksat", "ainesets", "aineticsset", "aineeeksset", "ainsceset", "ainnersset", "ainewsET", "aineeksette", "raineksets", "ainscesheet", "ainewset", "aineeksets", "aineekset", "aineeksset", "aineeekset", "aineticset", "aineticsheet", "ainnersette", "ainesheet", "aineksat", "ainewsat", "aincesET", "ainnersets", "ainseksET", "raineeksset", "aincesheet", "ainscesET", "aineksheet", "ainesET", "raineeksets", "ainsekset", "aineeksat", "ainseksset", "aineset", "ainseksheet", "ainceset", "ainesat", "raineksset", "aineeeksET"], "pst1": [" pcr2", "pmt0", "Pst0", "pcr0", "pST1", " pest1", "pft1", "pest0", "psts100", "pste3", "pest100", "pmt2", "ppste0", "pct1", "pcr01", "psteone", "prest1", " pcr1", " pst01", " pestOne", "psteOne", "pste0", "Pst2", "preste2", "pstOne", "pstr0", "presteone", "pcr1", "ppst1", "pct0", "pct2", "pstone", "psp100", "Pstone", "ppt2", "psts1", " pcr0", "ppst2", "Pst1", "PctOne", "pste1", "ppst0", "preste1", "pftOne", "PstOne", " pst100", "Pct0", "psp1", "pST2", "pptone", "psts0", "pSTOne", "ppste2", "pmt55", "pct55", "pptOne", "pstr2", "prestone", "pst100", " pest100", "ppste3", "pest1", "pstr1", "prest2", "psth01", "ppt1", "ppst3", "psth0", "pftone", "Pct2", "pcr2", "ppste1", "pct01", "pstsOne", "pste2", "pct3", " pest0", "pmt1", "Pst55", "prestOne", "pctOne", "pst3", "pst55", "pft2", " pst0", "pSTone", "psp0", "presteOne", "pspOne", "psth2", "Pctone", "pestOne", " pcr01", "psth1", "pstr55", "pst0", " pstOne", "Pct55", "Pct1", "pst01", "pctone"], "pst2": [" psth1", "Pct10", "pest25", "pST1", "pkttwo", "pSTTwo", "pkt1", "pctTwo", "Pst10", "pcttwo", "pstd1", "Pcttwo", " post2", "pmt4", "pest2", "pmt2", "qest02", "pv2", "pct1", "Pct2012", "psth6", "pct5", "pst5", "Pst2012", "post5", "qest25", "pste0", "pct6", " psth4", "Pst2", "pstSecond", "pst02", " post5", "pstdSecond", " pstSecond", "psth4", "psttwo", "pxt2", "pest02", "pct0", "pct2", "pv10", "pmtSecond", "pste4", "qst25", " pmt1", "Pst1", "ppr2", "pstd2", "pste1", " pstTwo", " pmt2", " psth0", "qst1", " pst4", "qst02", "pkt2", "post1", "pST2", "pv1", "pctSecond", " postTwo", " pmt4", "post2", "pxt1", " pmtSecond", "qest2", "pstd4", "pst4", "ppr1", "pst2012", "postTwo", "pxt2012", "pct02", "qest1", "pct4", "pest1", " post1", "psth10", "pct2012", "ppr02", "psth0", "Pct6", "Pct2", "ppr25", "qst2", " pst5", "pv6", "pct10", " psth2", "pste2", "pmt1", "pstTwo", "pst10", "Pst6", "pxttwo", "Psttwo", " pst0", "psth2", "pkt2012", "pST5", "psth1", "pst0", "pst25", "Pct1", "pct25", "pst6"], "rs": ["r", "rys", "details", "RS", "sl", "qs", "rd", "rl", "rc", "cs", "s", "Rs", "bs", "xs", "ls", "cr", "rx", "ows", "ros", "RC", "ris", "ks", "vers", "rss", "rh", "ras", "results", "rr", "row", "ds", "hr", "sr", "mr", "ars", "rt", "errors", "hs", "rows", "ins", "yr", "acks", "res", "rg", "as", "js", "ps", "runs", "gs", "ers", "ms", "ws", "pr", "repl"], "retVal": ["RETVal", "returnval", "authValue", "Retval", " retval", "RetVAL", "RetValue", "RETTx", " retRet", "altRes", " retTx", " retValue", "RetVal", "retVAL", "authVAL", "retTx", "retRes", "returnValue", "altValue", "altTx", " retRes", " retVAL", "returnVal", "authVal", "altVal", "returnRes", "RETRet", "retValue", "retval", "altval", "altRet", "retRet"], "id": ["error", "ip", "in", "p", "max", "gen", "def", "key", "vid", "version", "cat", "Id", "bid", "ID", "info", "alias", "result", "code", "ident", "path", "ref", "num", "index", "ide", "value", "count", "lit", "row", "root", "str", "start", "end", "uid", "url", "f", "sid", "type", "number", "it", "ids", "d", "string", "aid", "rid", "pid", "kid"], "aines": ["ainsetics", "ainsse", "AINe", "dons", "verse", "rainES", "gines", "aine", "ainens", "AINes", "ginES", "verses", "rouse", "raines", "ainses", "ainES", "anse", "anses", "ainsences", "ginse", "ainess", "AINse", "ainsens", "ainsess", "rainess", "AINess", "gine", "dones", "rouetics", "versens", "ainss", "ainsES", "roue", "ainse", "ainences", "rainens", "rainetics", "done", "ansences", "roues", "ains", "rainences", "raine", "versse", "rains", "ainetics", "ansES", "donse", "rainse"], "i": ["ai", "ip", "in", "uli", "j", "p", "one", "n", "ie", "is", "multi", "fi", "e", "phi", "ci", "gi", "t", "ui", "info", "index", "li", "ii", "io", "ori", "iu", "z", "ini", "bi", "part", "x", "pi", "o", "xi", "ti", "u", "ni", "b", "y", "v", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "qi", "uri", "I", "c"]}}
{"id1": "5744493", "id2": "16820041", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static String encodePassword(String _originalPassword) {\n        MessageDigest md = null;\n        String encodedPassword = null;\n        try {\n            md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(_originalPassword.getBytes(\"UTF-8\"));\n            encodedPassword = (new BASE64Encoder()).encode(md.digest());\n        } catch (NoSuchAlgorithmException _e) {\n            _e.printStackTrace();\n        } catch (UnsupportedEncodingException _e) {\n            _e.printStackTrace();\n        }\n        return encodedPassword;\n    }\n", "label": 0, "substitutes": {"onlyFileCopy": [" doFileCopy", " doFileWrite", " doFolderWrite", " dofileProxy", "newBlockCopy", " doFolderProxy", "newBlockWrite", " doBlockcopy", "newFileCopy", " doFilecopy", "newFilecopy", "newBlockProxy", "newFileWrite", " doFolderCopy", " doBlockWrite", " doFileProxy", " doBlockCopy", " dofileCopy", " dofileWrite", " doBlockProxy", "newFileProxy", " doFoldercopy", " dofilecopy", "newBlockcopy"], "in": ["image", "m", "buffer", "pin", "query", "inn", "isin", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "file", "part", "min", "url", "base", "login", "data", "err", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "buffer", "off", "output", "socket", "pre", "default", "user", "write", "copy", "ex", "page", "server", "cache", "conn", "source", "target", "connection", "ext", "resource", "io", "file", "part", "dot", "o", "prefix", "base", "exec", "temp", "b", "v", "name", "again", "string", "point", "outs", "external", "OUT"], "inChannel": [" inClient", "outStream", "inClient", "inputChannel", " inchannel", "inchannel", "INStream", "INChan", "outchannel", "outChan", "binSocket", "binChannel", " inChan", "InStream", "INSocket", "INChannel", "InChan", "outSocket", "inChan", "inputChan", "binChan", "binStream", "INClient", " inStream", "InChannel", "inSocket", " inSocket", "InSocket", "Inchannel", "INchannel", "outClient", "inputStream", "inputSocket", "inStream"], "outChannel": [" outBuffer", "outStream", " outchannel", "intChan", "inchannel", "OutChan", "outchannel", "outChan", "OutChannel", "outButton", "intChannel", "againSocket", " outButton", "againStream", " outChan", " outStream", "againChannel", "outSocket", "inChan", " outSocket", "intchannel", "inContainer", "inSocket", "outContainer", "OutBuffer", "inButton", "outBuffer", "intButton", "inBuffer", "OutStream", "OutContainer", " outContainer", "againChan", "inStream"], "maxCount": [" maxSize", " maxLength", "MaxSize", "MaxSum", "Maxcount", "maxSize", "blockcount", "maxLength", "MaxCount", "axcount", "maxSum", " maxcount", "axLength", "maxcount", "MaxLength", "axSize", "blockSum", "blockCount", "axCount", " maxSum", "blockSize"], "size": ["position", "bytes", "shape", "max", "ize", "p", "n", "capacity", "fee", "transfer", "sized", "limit", "address", "loc", "seek", "sum", "time", "send", "count", "available", "len", "start", "en", "min", "end", "unit", "mode", "scale", "data", "Size", "type", "range", "cap", "offset", "width", "volume", "name", "small", "speed", "empty", "shift", "flush", "SIZE", "length"], "pos": ["position", "os", "p", "obj", "off", "block", "i", "slice", "po", "id", "limit", "port", "address", "val", "open", "loc", "diff", "pointer", "cos", "index", "ref", "pose", "count", "POS", "part", "len", "start", "iter", "min", "o", "unit", "base", "pass", "no", "data", "rel", " position", "offset", "spec", "Pos", "point", "push", "slot", "pid", "neg", "pt", "length"]}}
{"id1": "2022160", "id2": "2518655", "code1": "    public ByteBuffer[] write(ByteBuffer[] byteBuffers) {\n        if (!m_sslInitiated) {\n            return m_writer.write(byteBuffers);\n        }\n        if (m_engine.getHandshakeStatus() != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n            if (!NIOUtils.isEmpty(byteBuffers)) {\n                m_initialOutBuffer = NIOUtils.concat(m_initialOutBuffer, m_writer.write(byteBuffers));\n                byteBuffers = new ByteBuffer[0];\n            }\n            ByteBuffer buffer = SSL_BUFFER.get();\n            ByteBuffer[] buffers = null;\n            try {\n                SSLEngineResult result = null;\n                while (m_engine.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n                    buffer.clear();\n                    result = m_engine.wrap(byteBuffers, buffer);\n                    buffer.flip();\n                    buffers = NIOUtils.concat(buffers, NIOUtils.copy(buffer));\n                }\n                if (result == null) return null;\n                if (result.getStatus() != SSLEngineResult.Status.OK) throw new SSLException(\"Unexpectedly not ok wrapping handshake data, was \" + result.getStatus());\n                reactToHandshakeStatus(result.getHandshakeStatus());\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            return buffers;\n        }\n        ByteBuffer buffer = SSL_BUFFER.get();\n        buffer.clear();\n        if (NIOUtils.isEmpty(byteBuffers)) {\n            if (m_initialOutBuffer == null) return null;\n        } else {\n            byteBuffers = m_writer.write(byteBuffers);\n        }\n        if (m_initialOutBuffer != null) {\n            byteBuffers = NIOUtils.concat(m_initialOutBuffer, byteBuffers);\n            m_initialOutBuffer = null;\n        }\n        ByteBuffer[] encrypted = null;\n        while (!NIOUtils.isEmpty(byteBuffers)) {\n            buffer.clear();\n            try {\n                m_engine.wrap(byteBuffers, buffer);\n            } catch (SSLException e) {\n                throw new RuntimeException(e);\n            }\n            buffer.flip();\n            encrypted = NIOUtils.concat(encrypted, NIOUtils.copy(buffer));\n        }\n        return encrypted;\n    }\n", "code2": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "label": 1, "substitutes": {"write": ["next", "process", "writer", "connect", "service", "size", "sync", "kill", "read", "flow", "output", "feed", "copy", "written", "run", "wrote", "open", "code", "out", "send", "lex", "end", "store", "Write", "cycle", "close", "exec", "set", "update", "data", "append", "put", "w", "call", "export", "writ", "play", "add", "flush", "dump", "create", "writing", "pipe"], "byteBuffers": ["connectionbuffERS", "bytesBuffatters", "connectionbuffeners", "bytebuffresses", "bytePackapers", " byteComplers", "byteBuffresses", "ByteBuffresses", "byteOrders", "byteBuffererers", " byteOffters", "byteWritlers", "byteBufferelines", "doubleHeadered", "ByteOrderers", " byteOffors", "byteCornatters", "byteOrdERS", "byteHeaders", " byteBuffares", "byteBuffapers", "byteBuildERS", "bytesPackers", "bytesBuffors", "connectionBuffeners", "byteBuffizers", "bytebuffings", "bytesCornatters", "byteDefelines", "connectionbuffers", "bytesPackerers", "byteCornests", "bytePackerers", "doubleHeadERS", "ByteOrdresses", "ByteBufflers", "byteBuffereners", "ByteBuffers", "byteIntegers", "byteDefers", "ByteOrdERS", "bytesBuffizers", "bytesBuffERS", " byteOrdlers", "doubleHeadings", "bytebuffests", "ByteBuffERS", "byteOrderers", "byteOffERS", "bytePackERS", "byteCornered", "bytesCorners", " byteBuffinals", " byteBuffors", "byteBufferERS", "bytebuffeners", "byteAkelines", " byteOrderers", "ByteBufferers", " byteBufflers", "bytesBuffelines", "byteDefatters", " byteCompERS", "byteInferers", "byteComplers", "bytebuffors", "byteChers", "byteCornares", "connectionBuffERS", "byteBuffinals", "byteInteginals", "bytesDefelines", " byteOrders", "bytebuffered", "wordBuffatters", "connectionBuffers", "byteBuilderers", " byteBuffeners", "byteAkizers", "byteChERS", "byteWritelines", "byteOffters", "bytesAkizers", "wordBuffers", "byteOrdeners", "byteOrdlers", "byteWritors", " byteOrdinals", "doubleBuffered", "byteWriters", "byteBuffters", " byteOffERS", " byteOrdERS", " byteOffers", "byteBufferers", "byteBuilders", " byteBuffters", "bytesAkers", " byteBuffERS", "byteDefERS", "byteBufferatters", "bytebuffiners", "doubleHeaders", "byteIntegERS", "byteIntegatters", "bytesBuffapers", "byteCompares", "bytesBuffers", "byteBuffERS", "byteHeadERS", "bytePackers", "bytebuffinals", "byteIntegeners", "bytebuffelines", "byteBuffelines", "bytesAkelines", "wordBufferers", "bytesDefERS", " byteCompares", "bytebuffERS", "byteOffers", "byteAkors", "byteOrdapers", "bytesDefers", "byteBuffings", "connectionbufferers", "bytebuffizers", "ByteOrders", "bytebuffers", "byteAkers", "byteBufflers", "byteChered", "bytebufflers", " byteCompers", "bytesBuffests", "doubleBuffERS", "byteCornERS", " byteOrdeners", "byteCompERS", "byteWritizers", "bytesPackapers", "bytesAkors", "byteChings", "byteBuffatters", "bytebufferers", "doubleBuffers", "byteInfers", " byteBuffiners", "wordBuffERS", "byteIntegelines", "byteHeadings", "byteHeadered", "bytesCornests", "bytesBuffered", "byteCompers", "byteOrdresses", "byteOrdinals", "byteCornlers", "connectionBufferers", "byteBuffered", "byteBuffests", "bytebuffatters", "doubleBuffings", " byteBufferers", "byteBufferlers", "byteOrdiners", "bytesBufferers", "byteCorners", "byteInfatters", "byteBufferapers", "byteWritiners", "byteBuffiners", "byteBuildatters", "byteInfERS", "bytesCornered", "byteWriterers", "byteBuffors", "byteOffors", " byteOrdiners", "byteBuffeners", "bytesPackERS", "bytebuffters", "bytesDefatters", "byteBuffares"], "m_initialOutBuffer": ["m_initialOutBuff", "m_initialAuthBuffer", "m_finalOutChannel", "m_initialShortChannel", "m_InitialOutLayer", "m_initialInLine", "m_initialoutAddress", "m_initialOutLine", "m_initialOutCache", "m_initialShortCache", "m_initialOutputBuff", "m_initialOutFile", "m_initialOutputHeader", "m_initialNewBuff", "m_initialAuthFile", "m_initialSocketBuffer", "m_initialSocketHeader", "m_finalInBuffer", "m_finalOutMessage", "m_initialNewMessage", "m_finalOutBuff", "m_initialOutHeader", "m_finalInMessage", "m_initialShortBuffer", "m_initialoutLine", "m_originalOutAddress", "m_InitialOutBuffer", "m_finalInChannel", "m_InitialOutFile", "m_InitialOutputHeader", "m_finaloutChannel", "m_initialClientLine", "m_originaloutBuffer", "m_initialInMessage", "m_InitialOutputLayer", "m_initialNewBuffer", "m_originalOutLine", "m_finalInFile", "m_initialoutFile", "m_initialInChannel", "m_initialoutChannel", "m_finalOutLine", "m_finalOutFile", "m_InitialOutHeader", "m_initialoutBuff", "m_initialShortFile", "m_finalInLine", "m_initialClientBuffer", "m_initialOutLayer", "m_initialSocketLayer", "m_finalInBuff", "m_initialInCache", "m_initialNewFile", "m_originaloutFile", "m_initialClientBuff", "m_finaloutBuffer", "m_originalOutBuffer", "m_originaloutAddress", "m_initialOutAddress", "m_finaloutFile", "m_initialOutMessage", "m_initialOutChannel", "m_finalOutCache", "m_initialSocketFile", "m_originalOutFile", "m_initialOutputChannel", "m_initialAuthAddress", "m_InitialOutputFile", "m_initialInBuff", "m_initialInLayer", "m_initialInFile", "m_finalOutBuffer", "m_finalInCache", "m_finaloutBuff", "m_initialOutputBuffer", "m_initialoutBuffer", "m_initialoutCache", "m_InitialOutputBuffer", "m_initialInAddress", "m_initialOutputFile", "m_initialInBuffer", "m_originaloutLine", "m_initialClientFile", "m_initialAuthLine", "m_initialOutputLayer", "m_initialInHeader", "m_initialOutputMessage"], "buffer": ["FFER", "cell", "comment", "Buffer", "address", "bc", "fb", "iter", "buf", "engine", "base", "re", "builder", "er", "shell", "reader", "string", "window", "flush", "back", "client", "batch", "console", "view", "feed", "input", "page", "cache", "stack", "array", "response", "message", "buff", "pool", "uffer", "file", "table", "event", "holder", "writer", "worker", "output", "object", "slice", "copy", "limit", "port", "phrase", "cur", "row", "url", "null", "callback", "channel", "wave", "source", "layer", "timeout", "template", "block", "queue", "transfer", "server", "ker", "resource", "f", "binary", "data", "temp", "loader", "document", "header", "bridge", "read", "config"], "buffers": ["ufers", "ufering", "buffERS", "bufering", " buffators", "transformERS", "affaches", "transformler", "Buffered", " buffered", "bufages", "buffler", "bufler", "transformers", " buffler", " buffars", " buffages", " buffERS", "Buffers", "bufered", " buffresses", "buffaches", "affors", "phages", "phators", "buffresses", "buferers", "transformering", "ufors", "Bufferers", "ufaches", "affering", "buffering", " bufferers", "buffors", " buffering", "bufators", "bufars", "bufresses", "phers", "bufferers", "buffars", "Buffars", "bufaches", "bufERS", "buffators", "buffered", "bufers", "bufors", "buffages", "phresses", "affers"], "result": ["request", "r", "success", "error", "match", "rate", "card", "flash", "output", "rc", "view", "use", "default", "comment", "consumer", "user", "future", "cache", "valid", "complete", "val", "json", "info", "diff", "or", "ver", "grade", "response", "report", "resource", "message", "Result", "successful", "inner", "ret", "results", "out", "manager", "function", "row", "date", "sr", "winner", "f", "acc", "url", "session", "data", "err", "cup", "er", "runner", "test", "status", "search", "driver", "res", "true", "event", "re", "up"], "encrypted": ["image", "pad", "selected", "flash", "entry", "stream", "transfer", "internal", "cache", " data", "source", "padding", "inner", "available", "binary", "channel", "temp", "loader", "packed", "secret", "text", "body", "reader", "interrupted", "extra", "flush", "layer", "config"]}}
{"id1": "4398382", "id2": "13207437", "code1": "    public static String digest(String algorithm, String text) {\n        MessageDigest mDigest = null;\n        try {\n            mDigest = MessageDigest.getInstance(algorithm);\n            mDigest.update(text.getBytes(ENCODING));\n        } catch (NoSuchAlgorithmException nsae) {\n            _log.error(nsae, nsae);\n        } catch (UnsupportedEncodingException uee) {\n            _log.error(uee, uee);\n        }\n        byte[] raw = mDigest.digest();\n        BASE64Encoder encoder = new BASE64Encoder();\n        return encoder.encode(raw);\n    }\n", "code2": "    public Object sendRequestObjectResponse(java.lang.String servletName, java.lang.String request) {\n        String osRoot = OSRoot.getRoot();\n        String fname = \"\";\n        Object retobj = null;\n        String myurl = java.util.prefs.Preferences.systemRoot().get(\"serverurl\", \"\");\n        String myport = java.util.prefs.Preferences.systemRoot().get(\"portno\", \"8080\");\n        if (myport == null || myport.trim().equals(\"\")) {\n            myport = \"80\";\n        }\n        if (this.serverURL == null) {\n            try {\n                java.net.URL codebase = newgen.presentation.NewGenMain.getAppletInstance().getCodeBase();\n                if (codebase != null) serverURL = codebase.getHost(); else serverURL = \"localhost\";\n            } catch (Exception exp) {\n                exp.printStackTrace();\n                serverURL = \"localhost\";\n            }\n            newgen.presentation.component.IPAddressPortNoDialog ipdig = new newgen.presentation.component.IPAddressPortNoDialog(myurl, myport);\n            ipdig.show();\n            serverURL = myurl = ipdig.getIPAddress();\n            myport = ipdig.getPortNo();\n            java.util.prefs.Preferences.systemRoot().put(\"serverurl\", serverURL);\n            java.util.prefs.Preferences.systemRoot().put(\"portno\", myport);\n            System.out.println(serverURL);\n        }\n        try {\n            System.out.println(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URL url = new java.net.URL(\"http://\" + serverURL + \":\" + myport + \"/newgenlibctxt/\" + servletName);\n            java.net.URLConnection urlconn = (java.net.URLConnection) url.openConnection();\n            urlconn.setDoOutput(true);\n            urlconn.setRequestProperty(\"Content-type\", \"text/xml; charset=UTF-8\");\n            java.io.OutputStream os = urlconn.getOutputStream();\n            String req1xml = request;\n            java.util.zip.CheckedOutputStream cos = new java.util.zip.CheckedOutputStream(os, new java.util.zip.Adler32());\n            java.util.zip.GZIPOutputStream gop = new java.util.zip.GZIPOutputStream(cos);\n            java.io.OutputStreamWriter dos = new java.io.OutputStreamWriter(gop, \"UTF-8\");\n            System.out.println(req1xml);\n            try {\n                java.io.FileOutputStream pw = new java.io.FileOutputStream(\"log.txt\");\n                pw.write(req1xml.getBytes());\n                pw.flush();\n                pw.close();\n            } catch (Exception exp) {\n                exp.printStackTrace();\n            }\n            dos.write(req1xml);\n            dos.flush();\n            dos.close();\n            System.out.println(\"url conn: \" + urlconn.getContentEncoding() + \"  \" + urlconn.getContentType());\n            java.io.InputStream ios = urlconn.getInputStream();\n            java.io.File f1 = new java.io.File(osRoot + \"/localattachments/Reports\");\n            if (!f1.exists()) f1.mkdirs();\n            java.io.File file = null;\n            if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"application/vnd.oasis.opendocument.text\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".odt\");\n            } else if (urlconn.getContentType() != null && urlconn.getContentType().trim().equals(\"text/html\")) {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".html\");\n            } else {\n                file = new java.io.File(osRoot + \"/localattachments/Reports/\" + System.currentTimeMillis() + \".xls\");\n            }\n            file = new java.io.File(file.getAbsolutePath());\n            java.io.FileOutputStream fos = new java.io.FileOutputStream(file);\n            int c;\n            while ((c = ios.read()) != -1) fos.write(c);\n            fos.close();\n            ios.close();\n            fname = file.getAbsolutePath();\n            System.out.println(fname);\n            newgen.presentation.component.Utility.getInstance().showBrowser(\"file://\" + fname);\n        } catch (Exception exp) {\n            exp.printStackTrace(System.out);\n            javax.swing.JOptionPane.showMessageDialog(null, \"<html>Could not establish connection with the server, <br>Please verify server name/IP adress, <br>Also check if NewGenLib server is running</html>\", \"Critical error\", javax.swing.JOptionPane.ERROR_MESSAGE);\n        }\n        return fname;\n    }\n", "label": 0, "substitutes": {"digest": [" digested", "mdester", "encress", "Digse", "generest", "Digress", "digress", "mdest", " digests", "generests", "digests", "digse", "mdests", "Digest", "Digester", " digester", " digse", "digester", "encse", " digress", "encest", "generester", "mdested", "encester", "digested", "generested"], "algorithm": ["malgebra", "algebra", "aroding", "algo", "Alignment", "malignment", "challgebra", "aloding", "alenge", "Algebra", " alenge", "Algorithm", " algo", "challgo", "arignment", "argorithm", "Alenge", "Aloding", " algebra", "alignment", "argebra", "maloding", "malgorithm", "challgorithm", "Algo", "challenge"], "text": ["image", "buffer", "bytes", "output", "pattern", "object", "feed", "username", "Text", "sequence", "input", "attribute", "address", "code", "format", "content", "connection", "path", "message", "TEXT", "ext", "word", "value", "str", "url", "letter", "data", "struct", "token", "test", "secret", "name", "password", "string", "source", "config", "length", "txt"], "mDigest": ["mPostested", "mCodener", "MDgest", "mdigested", "mDEST", "mDester", " mDigester", " mDigast", "mCodest", "mDenge", "mDgest", " mGest", "amDigener", "mSignge", "MDest", "mdigester", "mDiger", "mDesignest", "mdigest", "mPostest", "mSignast", "mdiggest", "mGge", "mSignester", "mDesignester", "mSignEST", "mGester", "MDiger", "mDest", "amDigested", "mDigested", "amPostener", "amDigest", "mDigener", "mEncester", "MDigEST", "mCodested", " mGge", " mDigge", "mGast", "mSignest", "mDer", "mSignenge", "mDigEST", "MDester", "amPostested", " mGast", "mDigenge", "MDiggest", "MDigest", " mGester", "MDigenge", "mDigge", "amPostest", "mdigener", "mEncest", "mDiggest", "mGest", "mDigester", "mdiger", "mDesigner", "mPostener", "MDigester", "mDigast", "mDesigngest", "mEncast", "mEncge", "MDer"], "raw": ["image", "clean", "buffer", "original", "RAW", "full", "output", "default", "feed", "input", "instance", "internal", "unsigned", "serial", "json", "result", "array", "content", "response", "Raw", "message", "orig", "container", "row", "binary", "buf", "enc", "none", "null", "data", "partial", "wrap", "source", "initial", "hex"], "encoder": ["Encoded", " encoded", "enoder", "deccode", "enode", "enoding", "Encode", "Encoder", "encoding", "ecoded", "ecode", "encoded", "ecoder", "decoder", "enccode", "decode", "ecoding", "Encoding", "encode", "decoding", " encoding", " encode", "eccode"]}}
{"id1": "12039034", "id2": "18046717", "code1": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "code2": "    private String getFullClassName(URL url, String className) throws Exception {\n        JarInputStream jis = new JarInputStream(url.openStream());\n        ZipEntry zentry = null;\n        while ((zentry = jis.getNextEntry()) != null) {\n            String name = zentry.getName();\n            int lastPos = name.lastIndexOf(\".class\");\n            if (lastPos < 0) {\n                continue;\n            }\n            name = name.replace('/', '.');\n            int pos = -1;\n            if (className != null) {\n                pos = name.indexOf(className);\n                if (pos >= 0 && name.length() == pos + className.length() + 6) {\n                    jis.close();\n                    return (name.substring(0, lastPos));\n                }\n            }\n        }\n        jis.close();\n        return (null);\n    }\n", "label": 0, "substitutes": {"importRoles": ["ImportRoles", "importRoleRole", "ImportRorts", "ImportGrorts", "ImportRoots", "importRoleorts", "ImportGrRole", "importGroles", "importroRole", "importRoleoots", "importGroots", "importRoleoles", "ImportGroots", "importroorts", "importRoots", "ImportGroles", "importRorts", "importrooles", "ImportRRole", "importrooots", "importGrorts", "importRRole", "importGrRole"], "urlString": ["urlImport", " urlImport", "resourceString", "urlStream", "fileImport", "serviceStream", "urlstring", "fileString", "fileFile", "servicestring", "resourcestring", "serviceStr", "serviceString", "urlStr", "URLString", " urlFile", "urlFile", "URLstring", " urlStream", "resourceStream", " urlStr", " urlstring", "URLImport", "filestring", "resourceStr", "URLFile"], "results": ["items", "vals", "details", "ils", "models", "authors", "grades", "reads", "es", "features", "properties", "lines", "objects", "result", "vers", "helps", "reports", "services", "params", "resources", "members", "roots", "ings", "changes", "relations", "tops", "data", "values", "RESULTS", "groups", "users", "errors", "times", "rows", "names", "res", "shows", "list", "runs", "rules", "Results", "tests"], "url": ["r", "ball", "client", "buffer", "service", "sl", "stream", "rl", "i", "socket", "feed", "ls", "e", "page", "server", "open", "connection", "http", "hub", "URL", "resource", "path", "io", "ssl", "file", "str", "f", "Url", "this", "api", "base", "loader", "b", "log", "ll", "l", "browser", "reader", "string", "ur", "uri", "source"], "in": ["r", "buffer", "h", "n", "inn", "stream", "gin", "isin", "i", "socket", "s", "init", "input", "e", "id", "din", "server", "lin", "inner", "io", "ssl", "out", "ini", "rec", "file", "f", "doc", "login", "b", "ins", "l", "In", "bin", "by", "reader", "IN", "again", "read", "source", "inc"], "buff": ["agg", "fw", "buffer", "ph", "bf", "prof", "pp", "ctx", "off", "br", "ff", "flow", "ab", "fam", "cp", "comment", "load", "app", "feed", "bug", "ib", "bb", "Buffer", "sb", "info", "rb", "fb", "tab", "bm", "bg", "orig", "raf", "ob", "mb", "gb", "raw", "box", "pb", "Buff", "bag", "bound", "f", "eb", "buf", "null", "base", "callback", "wb", "uff", "append", "b", "uf", "cpp", "nd", "text", "bin", "obb", "front", "nb", "utf", "lab", "back", "cb", "txt"], "line": ["job", "ne", "buffer", "email", "lf", "block", "entry", "profile", "key", "cell", "object", "comment", "el", "parse", "e", "page", "lc", "rule", "server", "lines", "Line", "lin", "code", "response", "message", "word", "out", "row", "value", "file", "str", "end", "link", "ge", "f", "part", "no", "unit", "base", "inline", "model", "data", "log", "range", "LINE", "cl", "text", "status", "l", "string", "nl", "header", "le", "item", "look", "column"], "name": ["job", "attr", "n", " number", " info", " connection", "key", "profile", "cn", "object", "user", " object", "id", " path", " one", " nickname", " file", "ann", "span", "alias", "connection", "path", "resource", " address", "zone", "word", " description", "file", "part", "NAME", "no", "base", " entity", " support", "type", "known", " type", "data", "Name", "number", " lookup", "role", "names", " account", "node", "member", " player"]}}
{"id1": "20232250", "id2": "8778962", "code1": "    private InputStream sendRequest(SequenceI seq) throws UnsupportedEncodingException, IOException {\n        StringBuilder putBuf = new StringBuilder();\n        processOptions(putBuf);\n        putBuf.append(\"INPUT_SEQUENCE=\");\n        putBuf.append(URLEncoder.encode(\">\" + seq.getName() + \"\\n\", ENCODING));\n        putBuf.append(URLEncoder.encode(seq.getResidues(), ENCODING));\n        URL url = new URL(PRIMER_BLAST_URL);\n        URLConnection conn = url.openConnection();\n        conn.setDoOutput(true);\n        OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n        wr.write(putBuf.toString());\n        wr.flush();\n        wr.close();\n        apollo.util.IOUtil.informationDialog(\"Primer-BLAST request sent\");\n        return conn.getInputStream();\n    }\n", "code2": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 0, "substitutes": {"sendRequest": ["processResponse", "getrequest", "sendrequest", "writeResponse", "processCommand", "sendResponse", "sendCommand", "processRequest", "writeCommand", "writeRequest", "writerequest", "getRequest", "getResponse", "getCommand", "processrequest"], "seq": ["job", "iq", "p", "contin", "query", "ctx", "batch", "fast", "pos", "eq", "queue", "sequ", "Sequ", "sci", "lic", "flow", "q", "slice", "sequence", "pkg", "cli", "id", "val", "que", "ext", "ref", "file", "rez", "feat", "iter", "sel", "ctrl", "req", "prefix", "vec", " sequence", "sq", "blast", "struct", "spec", "comp", "test", "cl", "sem", "frame", "pse", "config", "ence"], "IOException": ["TimeoutError", "IOError", " IOError", "TimeoutException", "Timeoutception", "IOception", "IPception", "IPException", "IPError", " IOception"], "putBuf": ["putFuf", "putPluff", "printBbuf", " putBob", "logBBault", "putSBuch", " putBuff", "putBsuf", "putBBob", "putBsault", " putWBurb", "fileBump", "putWBuf", "putBaseuf", "printBuf", "putFump", "putTuf", "printFob", " putPluc", "putWBbuf", "putbuff", "cutBuff", "putBouf", "putBsuff", "putWurb", " putPluf", "printFbuf", "printBuff", "putBBault", "putBaseump", "putBbuf", "putFurb", "fileSBuch", "putPluf", "fileBuf", "putBBbuf", "cutbump", "putFbuf", "putBump", "putBuch", "fileSBlf", " putBbuf", "putWuf", "putFuc", "putGBump", "putBundle", "putBsundle", "fileSBump", "cutbuff", "logBBuff", "putSBlf", "putBurb", "putGBundle", " putPluff", "putFob", "putBolf", "putBBundle", "putFuff", "putGBuc", " putPlump", " putBump", "putbuf", "fileBuch", "cutbault", "putTlf", "putSBuf", " putBurb", "putFault", "logBuf", "putBault", "logBuff", "logBBuf", "putWuff", "putBlf", "putWob", "putWBob", "cutbuf", "printFuff", "putPlump", "fileSBuf", "printFuf", "putBBuff", "putBouch", "putbault", "logBundle", "putBaseault", "putGBuff", " putWBob", "printBob", "putWBurb", "putBob", "putSBump", "putGBault", "fileBlf", "cutBuf", " putWBbuf", "putGBuf", "putTuch", "logBBundle", "logBault", " putWBuf", "putBuc", "putBuff", " putBuc", "putbump", "putTump", "cutBault", "putBaseuff", "putBBuf", "putBoump", "putPluc", "putWbuf", "cutBump"], "url": ["lr", "r", "db", "blog", "client", "fr", "sl", "rl", "host", "socket", "impl", "fl", "ls", "il", "www", "coll", "server", "open", "connection", "http", "URL", "resource", "ssl", "file", "ctrl", "f", "Url", "channel", "base", "download", "log", "org", "ll", "l", "string", "web", "ur", "uri", "jar", "source", "c"], "conn": ["r", "db", "client", "connect", "Conn", "p", "sync", "ctx", "n", "cp", "socket", "cn", "rc", "cr", "nt", "ci", "lc", "coll", "loc", "ann", "open", "connection", "nc", "dc", "cur", "io", "fp", "cm", "ssl", "out", "con", "fn", "ctrl", "util", "ch", "enc", "wb", "exec", "close", "conv", "channel", "err", "org", "rt", "ait", "nw", "ct", "pc", "co", "l", "mc", "addr", "Connection", "act", "cb", "c"], "wr": ["r", "fw", "wire", "fr", "writer", "sw", "wal", "WR", "Wr", " Wr", "raft", "rx", "Writer", "dr", "wh", "rss", "war", "rh", "rr", "raw", "shr", "nr", "hr", "rw", "sr", "mr", "wb", "wer", "wl", "wa", "kr", "w", "nw", " writer", "wrap", "wx", "wt", "wk", "spr", "ws", "RW", "wm"]}}
{"id1": "11032546", "id2": "300397", "code1": "    @Test\n    public void testCopyUnknownSize() throws IOException {\n        final InputStream in = new ByteArrayInputStream(TEST_DATA);\n        final ByteArrayOutputStream out = new ByteArrayOutputStream(TEST_DATA.length);\n        final int cpySize = ExtraIOUtils.copy(in, out, (-1));\n        assertEquals(\"Mismatched copy size\", TEST_DATA.length, cpySize);\n        final byte[] outArray = out.toByteArray();\n        assertArrayEquals(\"Mismatched data\", TEST_DATA, outArray);\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"testCopyUnknownSize": ["testCopyUnknownsize", "testcopyUnknownSize", "testcopyunknownsize", "testCopyKnownSize", "testCopyunknownsize", "testCopyKnownsize", "testCopyunknownSize", "testcopyUnknownsize", "testcopyunknownSize"], "in": ["r", "image", "m", "n", "inn", "src", "i", "is", "input", "id", "din", "conn", "info", "connection", "a", "inner", "io", "nin", "at", "inside", "min", "url", "this", "exec", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "source", "up", "c", "inc"], "out": ["Out", "auto", "image", "error", "client", "next", "buffer", "size", "sync", "one", "off", "obj", "up", "output", "user", "input", "parent", "copy", "ex", "cache", "plus", "conn", "to", "target", "array", "ext", "path", "io", "pool", "work", "at", "file", "post", "prefix", "o", "exec", "base", "data", "with", "temp", "append", "name", "bin", "again", "outs", "extra", "OUT", "inc"], "cpySize": [" cpyMode", "cpiLength", "cpeCount", "CpyCount", "cciCount", "CpeSize", " cpeMode", "CpeLength", "cpyLength", "CpySize", "cPyLength", "CpeCount", " cpyLength", "cpiArray", " cpeSize", "CpyLength", "cpeArray", "cpeMode", "czipMode", "cpyArray", "cpiSize", " cpeLength", " cpyArray", "cpyMode", "czipArray", "cciLength", " cpeArray", "czipSize", "cPyCount", "czipLength", "cpiMode", "cciSize", "cpeSize", "cpyCount", "cpeLength", "cPySize"], "outArray": [" outBuffer", "outputArray", "inSize", " outList", "outMemory", "targetMemory", " outAmount", " outSize", "viewArray", " outMemory", "viewBuffer", "outAmount", "targetBuffer", "outputMemory", "inAmount", "inArray", "outSize", "outputBuffer", "targetList", "outList", "outBuffer", "outputList", "viewSize", "inBuffer", "viewAmount", "targetArray"]}}
{"id1": "9275622", "id2": "9857412", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    @Override\n    public void writeData(byte[] data, byte[] options, boolean transferMetaData) throws Throwable {\n        long startTime = System.currentTimeMillis();\n        long transferredBytesNum = 0;\n        long elapsedTime = 0;\n        Properties opts = PropertiesUtils.deserializeProperties(options);\n        String server = opts.getProperty(TRANSFER_OPTION_SERVER);\n        String username = opts.getProperty(TRANSFER_OPTION_USERNAME);\n        String password = opts.getProperty(TRANSFER_OPTION_PASSWORD);\n        String filePath = opts.getProperty(TRANSFER_OPTION_FILEPATH);\n        if (transferMetaData) {\n            int idx = filePath.lastIndexOf(PATH_SEPARATOR);\n            if (idx != -1) {\n                String fileName = filePath.substring(idx + 1) + META_DATA_FILE_SUFIX;\n                filePath = filePath.substring(0, idx);\n                filePath = filePath + PATH_SEPARATOR + fileName;\n            } else {\n                filePath += META_DATA_FILE_SUFIX;\n            }\n        }\n        URL url = new URL(PROTOCOL_PREFIX + username + \":\" + password + \"@\" + server + filePath + \";type=i\");\n        URLConnection urlc = url.openConnection(BackEnd.getProxy(Proxy.Type.SOCKS));\n        urlc.setConnectTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        urlc.setReadTimeout(Preferences.getInstance().preferredTimeOut * 1000);\n        OutputStream os = urlc.getOutputStream();\n        ByteArrayInputStream bis = new ByteArrayInputStream(data);\n        byte[] buffer = new byte[1024];\n        int br;\n        while ((br = bis.read(buffer)) > 0) {\n            os.write(buffer, 0, br);\n            if (!transferMetaData) {\n                transferredBytesNum += br;\n                elapsedTime = System.currentTimeMillis() - startTime;\n                fireOnProgressEvent(transferredBytesNum, elapsedTime);\n            }\n        }\n        bis.close();\n        os.close();\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copyFolder", "transferfile", "copyFolder", "transferFolder", "copyFiles", "copyfile", "moveFolder", "transferFile", "moveFiles", "transferFiles", "moveFile", "movefile"], "_file1": ["_fileOne", "_file0", "_files1", "_zipone", "_mail2", "_resourceFirst", "_mail1", "_resourceone", "_File0", "_zipOne", "_fOne", "_File01", "_resource1", "_fone", "_fileone", "_files2", "_fileFirst", "_files01", "_mail0", "_mail01", "_files0", "_file01", "_File1", "_zipFirst", "_resourceOne", "_f1", "_fFirst", "_File2", "_zip1"], "_file2": ["jfile5", "jfile2", " _file3", "jmodelsecond", "_playTwo", "_play4", "_fileTwo", " _files4", "_play2", " _filesTwo", "_play5", "_model1", "_playsecond", "_play3", " _fileTwo", "jfilesecond", "_play1", "_files4", "jmodel2", "_filesTwo", " _files3", "_File5", "_filesecond", "jmodel5", "_files2", "_file5", "_model5", " _files2", " _file4", "_File1", "_file3", "_Filesecond", "jfile1", "_modelsecond", "_model2", "_file4", "_File2", "_files3", "jmodel1"], "fis": ["afais", "cfris", "cfos", "lfiss", "fi", " fas", "infis", " fris", "cfiss", "Fos", "infos", "infils", " fi", "afiss", "infiss", " fiss", "lfi", "cfis", "afis", "Fas", "lfis", "lfais", " fils", "fris", "Fils", " fais", "fiss", "fils", "fas", "Fris", "fais", "afi", "Fis", "cfas", "Fiss"], "fos": ["lis", "Faos", "infros", "Fros", "gus", "feus", "loes", "infus", "pos", "fOS", "foes", "gis", "fros", "fios", "flos", " foos", "pis", "infoos", "faos", "Fus", "fo", "Fos", "infos", "foses", "flis", "Foses", "los", "info", "foos", "infaos", "feoses", "floes", " fus", "goses", " faos", "feis", "Fo", " fo", " fios", "poes", "Fios", "gos", "infios", "flOS", "lOS", " fros", "pOS", "Foos", "fus", "feos", "Fis"], "canalFuente": ["canalBuente", "canalFuestro", "canalBuento", "canalCraencia", "canalBuze", "canaledBuje", "canallBuence", "canalBuencia", "canalFUestro", "canalsBuento", "canalFuencia", "canalFuze", "canallBuze", "canalFuento", "canallBuente", "canallFuencia", "canalKuente", "canaledFuente", "canaledFuje", "canalKuze", "canalCraence", "canalBuestro", "canaledBuente", "canalBuje", "canalFUze", "canaledFuze", "canalsFuento", "canalFuence", "canalsBuence", "canalFuje", "canalFUente", "canalSuente", "canalKuence", "canallFuze", "canallFuence", "canalCraente", "canalsBuente", "canalFUencia", "canallBuencia", "canalCraento", "canaledBuze", "canalFUence", "canalsFuence", "canalsFuencia", "canalBuence", "canalSuze", "canaledBuestro", "canalsBuencia", "canalsFuente", "canallFuente", "canaledFuestro", "canalKuento", "canalSuestro", "canalKuencia", "canalFUje", "canalSuje"]}}
{"id1": "7846688", "id2": "15129155", "code1": "    public void postData(String protocol, String host, String form, String data) throws Exception {\n        if ((protocol == null) || (protocol.equals(\"\"))) {\n            protocol = DEFAULT_PROTOCOL;\n        }\n        if ((host == null) || (host.equals(\"\"))) {\n            host = DEFAULT_HOST;\n        }\n        if (form == null) {\n            form = DEFAULT_FORM;\n        }\n        if (data == null) {\n            throw new IllegalArgumentException(\"Invalid data\");\n        }\n        URL url = new URL(protocol, host, form);\n        URLConnection con = url.openConnection();\n        con.setDoOutput(true);\n        con.setDoInput(true);\n        con.setUseCaches(false);\n        con.setRequestProperty(\"Content-type\", \"application/x-www-form-urlencoded\");\n        con.setRequestProperty(\"Content-length\", String.valueOf(data.length()));\n        PrintStream out = new PrintStream(con.getOutputStream(), true);\n        out.print(data);\n        out.close();\n        BufferedReader in = new BufferedReader(new InputStreamReader(con.getInputStream()));\n        while (in.readLine() != null) {\n        }\n        in.close();\n    }\n", "code2": "    public List<String> extractUrlList(String url) throws IOException, XPathExpressionException {\n        LinkedList<String> list = new LinkedList<String>();\n        HttpURLConnection conn = (HttpURLConnection) new URL(url).openConnection();\n        Tidy tidy = new Tidy();\n        tidy.setErrout(new NullPrintWriter());\n        Document doc = tidy.parseDOM(conn.getInputStream(), null);\n        int len = conn.getContentLength();\n        if (len <= 0) len = 32000;\n        ByteArrayOutputStream bout = new ByteArrayOutputStream(len);\n        PrintStream ps = new PrintStream(bout);\n        tidy.pprint(doc, ps);\n        ps.flush();\n        String content = bout.toString();\n        Pattern p = Pattern.compile(\"(http://[\\\\w\\\\\\\\\\\\./=&?;-]+)\");\n        Matcher m = p.matcher(content);\n        while (m.find()) {\n            list.add(m.group());\n        }\n        return list;\n    }\n", "label": 0, "substitutes": {"postData": [" PostPart", "PostText", " postPart", " postText", "PostBody", "postText", " postBody", "postPart", "postBody", " PostBody", " PostData", "PostData", " PostText", "PostPart"], "protocol": ["Proto", "pathol", "theotype", "Protocol", "protose", "protort", "hostocol", "proose", "iolurl", "Protport", "proto", "portotype", "iolort", "cryptport", "intericle", "scheec", "Protort", "cryptol", "prototype", "pathport", "proo", "scheocol", "hosturl", "promo", "hostport", "promol", "theose", "portocol", "porto", "crypto", "pathicle", "promocol", "proport", "iolocol", "cryptocol", "scheotype", "portec", "interocol", "hostort", "scheo", "interol", "protec", "protport", "proturl", "interport", "Proticle", "Proturl", "proticle", "theport", "proec", "theocol", "iolport", "Prototype", "Protol", "Protose", "pathocol", "promport", "protol", "proocol", "prootype"], "host": ["mac", "domain", "ip", "localhost", "arch", "component", "h", "service", "pattern", "view", "object", "proxy", "key", "feed", "Host", "parent", "port", "server", "address", "home", "loc", "target", "format", "hard", "http", "hub", "path", "container", "work", "root", "part", "channel", "base", "type", "topic", "database", "subject", "bind", "controller", "method", "hop", "name", "auth", "node", "site", "project", "string", "header", "front", "uri", "add", "source", "ac", "account"], "form": ["domain", "clean", "template", "term", "query", "one", "off", "stream", "pattern", "object", "view", "feed", "action", "key", "input", "Form", "parent", "port", "address", "format", "path", "raw", "FORM", "function", "file", "str", "post", "f", "pass", "channel", "model", "zip", "type", "with", "session", "range", "forms", "test", "transform", "text", "method", "name", "body", "string", "and", "place", "filter", "field", "act", "source", "config", "ac"], "data": ["request", "what", "buffer", "batch", "query", "one", "alpha", "key", "view", "action", "multi", "input", "version", "patch", "picture", "cache", "json", "valid", "info", "result", "format", "media", "content", "response", "message", "array", "params", "resource", "xml", "raw", "value", "change", "file", "str", "post", "part", "zip", "update", "type", "missing", "append", "database", "text", "name", "style", "body", "string", "DATA", "parts", "da", "uri", "dat", "source", "config"], "url": ["client", "connect", "sl", "proxy", "impl", "fl", "ls", "com", "server", "cache", "conn", "open", "connection", "http", "URL", "resource", "ssl", "fc", "file", "f", "Url", "this", "channel", "base", "api", "session", "log", "b", "l", "web", "ur", "uri", "c", "www"], "con": ["r", "client", "ca", "connect", "Conn", "sync", "fa", "cp", "socket", "cn", "pre", "rc", "cons", "cr", "on", "CON", "com", "core", "cache", "coll", "run", "per", "conn", "open", "ran", "connection", "bc", "http", "ver", "cur", "cos", "cm", "xc", "fc", "uc", "conf", "Con", "part", "en", "f", "close", "enc", "channel", "exec", "conv", "login", "log", "can", "cl", "pc", "co", "un", "ocon", "sub", "Connection", "re", "win", "pen", "c", "inc"], "out": ["Out", "r", "plain", "writer", "p", "obj", "sync", "n", "gin", "up", "key", "output", "socket", "user", "ex", "cache", "conn", "plus", "child", "sum", "io", "line", "file", "raw", "conf", "f", "ch", "o", "pass", "err", "temp", "b", "log", "w", "net", "co", "bin", "again", "web", "outs", "outer", "sub", "OUT", "ac", "inc"], "in": ["r", "fin", "pin", "inn", "stream", "isin", "i", "is", "socket", "s", "init", "cin", "impl", "input", "rx", "id", "ex", "din", "conn", "lin", "inner", "vin", "nin", "line", "rec", "ini", "kin", "rin", "inside", "min", "f", "login", "err", "b", "inter", "ins", "bin", "In", "l", "reader", "IN", "again", "read", "win", "sub", "c", "inc"]}}
{"id1": "324679", "id2": "16621503", "code1": "    public boolean import_hints(String filename) {\n        int pieceId;\n        int i, col, row;\n        int rotation;\n        int number;\n        boolean byurl = true;\n        e2piece temppiece;\n        String lineread;\n        StringTokenizer tok;\n        BufferedReader entree;\n        try {\n            if (byurl == true) {\n                URL url = new URL(baseURL, filename);\n                InputStream in = url.openStream();\n                entree = new BufferedReader(new InputStreamReader(in));\n            } else {\n                entree = new BufferedReader(new FileReader(filename));\n            }\n            pieceId = 0;\n            lineread = entree.readLine();\n            tok = new StringTokenizer(lineread, \" \");\n            number = Integer.parseInt(tok.nextToken());\n            for (i = 0; i < number; i++) {\n                lineread = entree.readLine();\n                if (lineread == null) {\n                    break;\n                }\n                tok = new StringTokenizer(lineread, \" \");\n                pieceId = Integer.parseInt(tok.nextToken());\n                col = Integer.parseInt(tok.nextToken()) - 1;\n                row = Integer.parseInt(tok.nextToken()) - 1;\n                rotation = Integer.parseInt(tok.nextToken());\n                System.out.println(\"placing hint piece : \" + pieceId);\n                place_piece_at(pieceId, col, row, 0);\n                temppiece = board.get_piece_at(col, row);\n                temppiece.reset_rotation();\n                temppiece.rotate(rotation);\n                temppiece.set_as_hint();\n            }\n            return true;\n        } catch (IOException err) {\n            return false;\n        }\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"import_hints": ["import_hins", "import_vits", "import2hint", "import_shints", "import_pints", "import2hints", "import_vints", "import_pint", "import_hint", "import_vins", "import_vint", "import2shits", "import_shits", "import2hins", "import_hits", "import2hits", "import_shins", "import2shint", "import_pits", "import_pins", "import2shins", "import_shint", "import2shints"], "filename": ["that", "Filename", "rl", "files", "username", "title", "sheet", "il", "directory", "File", "metadata", "json", "phrase", "sf", "location", "path", "fp", "params", "FILE", "fn", "file", "which", "kn", "f", "prefix", "nil", "login", "download", "wl", "fil", "database", "kl", "SourceFile", "document", "name", "figure", "string", "href", "utf", "uri", "source", "length", "dll", "txt"], "pieceId": ["ieceid", "towerName", "ieceID", "pieId", "blockName", " pieceCount", "pieid", "componentType", "caseName", "pocketID", "pageId", "pieID", "pocketId", "caseID", "pieceid", "towerId", "pageID", "componentid", "caseid", "pieceID", "quoteID", " pieceid", "caseId", "componentCount", "componentId", "pieceName", "blockId", "quoteid", " pieceID", " pieceType", "componentID", "pageType", " pieceName", "blockID", "pieceCount", "pocketid", "towerid", "towerID", "quoteName", "blockid", "pieceType", "quoteId", "ieceCount", "ieceId", "pageid"], "i": ["ai", "ip", "j", "p", "ie", "eni", "is", "key", "multi", "fi", "slice", "phi", "id", "ci", "gi", "loc", "ui", "info", "zi", "li", "index", "ii", "io", "ori", "iu", "line", "ini", "uni", "bi", "end", "x", "pi", "f", "start", "xi", "ti", "ri", "u", "ni", "ji", "mi", "oi", "it", "di", "l", "hi", "si", "chi", "qi", "uri", "I", "c"], "col": ["cal", "flo", "left", "pos", "block", "cel", "cell", "view", "character", "year", "cat", "Col", "section", "lc", "cy", "core", "coll", "loc", "group", "index", "num", "cur", "cor", "city", "con", "count", "fc", "x", "ch", "channel", "keep", "offset", "foot", "collection", "cl", "ct", "pixel", "width", "co", "COL", "c", "month", "field", "separ", "win", "column", "length", "inc"], "row": ["r", "grow", "position", "ner", "ow", "pos", "block", "key", "cell", "view", "order", "rc", "ro", "slice", "year", "height", "ry", "page", "coll", "loc", "group", "right", "index", "cur", "num", "our", "rr", "line", "step", "x", "hour", "range", "rel", "offset", "w", "rows", "wheel", "round", "stroke", "month", "tr", "roll", "Row", "column", "length"], "rotation": ["reloration", " rotion", "coloration", "relate", "rotion", "Rototation", " rotoration", "relation", " rototation", "polotation", "Rotation", "orientotation", "Rotating", "polating", "Rotion", "poloration", "polation", "colate", "Rotoration", "polion", "orientation", "colation", "rotate", "rotoration", " rotating", " rotate", "relating", "colating", "orientate", "Rotate", "rotating", "rototation", "orientoration", "polate"], "number": ["position", "Number", "size", "ner", "shape", "note", "n", "numbered", "phone", "amount", "key", "object", "nn", "year", "version", "reference", "section", "page", "source", "span", "division", "code", "num", "message", "resource", "zero", "work", "change", "line", "step", "maximum", "book", "part", "x", "area", "letter", "no", "null", "unit", "none", "type", "language", "other", "width", "total", "name", "counter", "string", "resolution", "network", "outer", "layer", "length", "umber", "non"], "temppiece": ["memppiece", "timphart", "tempoart", "templence", "temppedrice", "temptence", "timppoint", "timppart", "temppart", "templpiece", "temploint", "templrice", "temspiece", "templacket", "tempplruit", "temppedawn", "tempopiece", "typtacket", "temppell", "tempiece", " temppore", " tempppiece", "temppaint", "temphoint", "temppedell", "typpiece", "temptacket", "tempoore", "memppedrice", "typpacket", "temppprice", "temppence", "temptaint", "temprice", "temspence", "tempperuit", "memppediece", "memppell", "typpaint", "typtiece", "temppeiece", "tempoiece", "temphell", " tempore", "temppacket", "temphrice", "temppliece", "temppawn", "temppedruit", "temppedoint", " tempiece", "temphiece", "tempppawn", "timphoint", "templore", "temppruit", "templruit", "templell", "typpence", "memppedell", "timphrice", "mempprice", "temppeawn", "tempplrice", "temppore", "templiece", "templaint", "typtence", "timppiece", "tempooint", "typtaint", "temspaint", "tempppiece", "timphiece", "tempppruit", "memppedoint", "templawn", "temppediece", "tempore", "temphart", " tempprice", "temptiece", "timpprice", "memppoint", "temppoint", "temspacket", "tempprice", " temprice", "templart", "temporice", "tempperice", "tempplawn"], "lineread": ["lindata", "linread", "Lineread", "lineRead", "lineload", " lineRead", "LINEreader", "rowread", "rowload", "linedata", "ledata", "Linedata", "linebreak", "blockwrite", "linwrite", "leload", " linereader", "Linebreak", "Linereader", "linRead", " linewrite", "rowwrite", "rowreader", "filereader", "linekey", "leRead", " lineload", "LINERead", "leread", "fileread", "linereader", "blockread", "LINEread", " linedata", "blockreader", "linbreak", "linkey", "filekey", "linreader", "blockload", "linewrite", "blockbreak", "rowkey", "linload", "rowbreak", "Linewrite", "filebreak", " linebreak"], "tok": ["protoke", "atik", " tak", "etract", "untang", "ttoca", "Tak", " toks", " toko", "toololl", "tik", "ataken", "antok", "protore", "itook", "etok", "artok", "otoca", "toolok", "ttik", "itoker", "utoker", "utoken", "utunk", "antoke", "protaken", " taken", "toca", "took", "Tok", "Tock", "toko", "theaken", "tract", "tore", "artoll", " tock", "Token", "otunk", "ttoks", "ttak", "Toks", "artoke", "ttock", "etaken", "toker", "itok", "itorp", "itoken", "untoker", "tunk", "untok", "Toca", "tock", "utorp", "antract", "utok", "itunk", "utang", "atoks", "ttoke", "ttaken", " tract", "taken", "itang", "toke", "ttract", "utook", "ttoken", "untoken", "otok", "theore", "tak", "otook", "etoko", "toks", "theoke", "otoken", "toll", "antoll", "theok", "ttoko", "ttore", "toolract", "artract", "torp", "atok", "otorp", "otak", "token", "protok", "ttok", "tang", " tik", "tooloke"], "entree": ["etrain", "Entrie", "ettree", "artreen", "Entree", "settrees", "artee", "Entode", "etee", "ntrain", "Entrain", "entlock", "etree", "Enttree", "etreen", "settree", "Entlock", "ntrie", "ntee", "ntree", "enttree", "entrie", "entrees", "antrees", "settode", "Entee", "antrue", "ntlock", "entrue", "etrie", "antree", "Entrees", "entode", " entrain", "antode", "Entrue", "settrue", "entee", "artree", "artrie", "ntreen", " entlock", "entreen", "nttree", "entrain", " entrie"], "byurl": ["orfile", "orstr", "orURL", "viaURL", " byfile", "viafile", "orurl", "byfile", "viastr", "Byfile", " byURL", "ByURL", "byURL", "viaurl", "bystr", "Byurl", " bystr", "Bystr"], "url": ["image", "blog", "fr", "sl", "ul", "stream", "key", "feed", "user", "ls", "id", "page", "server", "bel", "open", "connection", "http", "hub", "URL", "resource", "pull", "ob", "ssl", "file", "link", "f", "Url", "base", "plug", "update", "gl", "loader", "log", "ll", "l", "browser", "string", "web", "ur", "uri", "source", "www"], "in": ["r", "image", "client", "fr", "n", "inn", "stream", "gin", "is", "socket", "input", "din", "a", "inner", "resource", "out", "con", "ini", "fc", "file", "part", "f", "serv", "login", "data", "ac", "err", "b", "ins", "bin", "In", "ar", "body", "IN", "reader", "as", "win", "source", "c", "inc"]}}
{"id1": "20660203", "id2": "8182932", "code1": "    public static void main(String args[]) {\n        int temp;\n        int[] a1 = { 6, 2, -3, 7, -1, 8, 9, 0 };\n        for (int j = 0; j < (a1.length * a1.length); j++) {\n            for (int i = 0; i < a1.length - 1; i++) {\n                if (a1[i] > a1[i + 1]) {\n                    temp = a1[i];\n                    a1[i] = a1[i + 1];\n                    a1[i + 1] = temp;\n                }\n            }\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.print(\" \" + a1[i]);\n        }\n    }\n", "code2": "    public static void unzip(File file, ZipFile zipFile, File targetDirectory) throws BusinessException {\n        LOG.info(\"Unzipping zip file '\" + file.getAbsolutePath() + \"' to directory '\" + targetDirectory.getAbsolutePath() + \"'.\");\n        assert (file.exists() && file.isFile());\n        if (targetDirectory.exists() == false) {\n            LOG.debug(\"Creating target directory.\");\n            if (targetDirectory.mkdirs() == false) {\n                throw new BusinessException(\"Could not create target directory at '\" + targetDirectory.getAbsolutePath() + \"'!\");\n            }\n        }\n        ZipInputStream zipin = null;\n        try {\n            zipin = new ZipInputStream(new FileInputStream(file));\n            ZipEntry entry = null;\n            while ((entry = zipin.getNextEntry()) != null) {\n                LOG.debug(\"Unzipping entry '\" + entry.getName() + \"'.\");\n                if (entry.isDirectory()) {\n                    LOG.debug(\"Skipping directory.\");\n                    continue;\n                }\n                final File targetFile = new File(targetDirectory, entry.getName());\n                final File parentTargetFile = targetFile.getParentFile();\n                if (parentTargetFile.exists() == false) {\n                    LOG.debug(\"Creating directory '\" + parentTargetFile.getAbsolutePath() + \"'.\");\n                    if (parentTargetFile.mkdirs() == false) {\n                        throw new BusinessException(\"Could not create target directory at '\" + parentTargetFile.getAbsolutePath() + \"'!\");\n                    }\n                }\n                InputStream input = null;\n                FileOutputStream output = null;\n                try {\n                    input = zipFile.getInputStream(entry);\n                    if (targetFile.createNewFile() == false) {\n                        throw new BusinessException(\"Could not create target file '\" + targetFile.getAbsolutePath() + \"'!\");\n                    }\n                    output = new FileOutputStream(targetFile);\n                    int readBytes = 0;\n                    byte[] buffer = new byte[BUFFER_SIZE];\n                    while ((readBytes = input.read(buffer, 0, buffer.length)) > 0) {\n                        output.write(buffer, 0, readBytes);\n                    }\n                } finally {\n                    FileUtil.closeCloseable(input);\n                    FileUtil.closeCloseable(output);\n                }\n            }\n        } catch (IOException e) {\n            throw new BusinessException(\"Could not unzip file '\" + file.getAbsolutePath() + \"'!\", e);\n        } finally {\n            FileUtil.closeCloseable(zipin);\n        }\n    }\n", "label": 0, "substitutes": {"temp": ["fake", "m", "p", "level", "max", "n", "size", "perature", "output", " Temp", "pre", "tmp", "default", "e", "parent", "Temp", "t", "cache", "adj", "diff", "length", "mini", "num", "index", "modified", "z", "count", "str", "tc", "iter", "pi", "f", "tem", "prefix", "stable", "null", "k", "emp", "flat", "v", "partial", "test", "style", "empty", "current", "source", "pt", "c"], "a1": ["aa2", "amaOne", " a91", "aa4", "aa51", "e100", "a51", "alpha2", "safirst", " a5", "a4", "an5", "a5", "alpha0", " aone", "Afirst", "ama51", " a001", "A91", "sa1", "as2", " afirst", "aa1", "A1", "array1", " a0", " a4", "a9", "aOne", "e127", "aone", "arrayfirst", "afirst", "ama1", "an1", " a51", " a9", "aa001", "ama4", "a0", "anfirst", "a001", "an2", " a100", "asone", "an0", "an100", "A5", "e1", "p4", "p1", "hafirst", "alphaOne", "ha100", "saOne", "array5", "ama100", "A4", "alpha9", "aa91", "alpha1", "a127", "A2", "AOne", " a127", "ha1", "as4", "sa5", "a100", "ha2", "A9", "aaone", "alphaone", "a91", "alpha4", "p0", "arrayOne", "Aone", "ama001", "A100", "saone", "as1", "A0", "eOne", "ama127", "p2", " aOne", "a2", " a2"], "j": ["ind", "m", "p", "h", "n", "g", "ik", "J", "e", "ci", "aj", "length", "jj", "a", "ja", "li", "ii", "jl", "z", "bj", "ij", "bi", "x", "pi", "f", "o", "xi", "k", "jp", "ni", "b", "y", "v", "u", "ji", "oi", "jc", "it", "di", "l", "d", "js", "si", "I", "c"], "i": ["r", "ai", "ip", "in", "ki", "h", "ie", "g", "ik", "is", "init", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "cli", "ui", "info", "mini", "adi", "a", "li", "ori", "ii", "io", "vi", "index", "iu", "z", "ini", "anti", "bi", "x", "pi", "f", "o", "xi", "api", "ami", "ti", "ri", "u", "ni", "b", "y", "jp", "v", "ji", "oi", "mi", "it", "di", "l", "si", "yi", "qi", "uri", "I", "c"]}}
{"id1": "13757855", "id2": "9846843", "code1": "    public void process(@NotNull Template tpl, @NotNull Document model, @NotNull String packageName, @NotNull String outFileName, Map<String, String> xsltParam, String artifact) throws ModelGenerationException {\n        System.out.print(\"Processing with \" + tpl);\n        String destinationPath;\n        switch(tpl.destination) {\n            case target:\n                if (tpl.path == null) {\n                    destinationPath = where.buildDir + separatorChar + \"generated-sources\" + separatorChar + GENERATION_TARGET;\n                } else {\n                    destinationPath = where.buildDir;\n                }\n                break;\n            case source:\n                if (tpl.path == null) {\n                    destinationPath = where.sourceDir;\n                } else {\n                    destinationPath = \"src\";\n                }\n                break;\n            case redora:\n                destinationPath = where.redoraDir;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unused destination \" + tpl.destination);\n        }\n        if (tpl.path == null) {\n            if (tpl.destination == Destination.redora) destinationPath += separator + artifact; else destinationPath += separator + packageName.replace('.', separatorChar);\n        } else {\n            destinationPath += separator + tpl.path.replace('/', separatorChar).replace('\\\\', separatorChar);\n        }\n        System.out.println(\" to \" + destinationPath + \"...\" + outFileName);\n        if (tpl.destination == Destination.source) {\n            if (new File(destinationPath, outFileName).exists()) {\n                System.out.println(\"Stub \" + outFileName + \" already exists.\");\n                return;\n            }\n        }\n        new File(destinationPath).mkdirs();\n        InputStream in = null;\n        Writer out;\n        try {\n            out = new FileWriter(new File(destinationPath, outFileName));\n        } catch (IOException e) {\n            throw new ModelGenerationException(\"Can't find: \" + destinationPath + separatorChar + outFileName, e);\n        }\n        switch(tpl.type) {\n            case freemarker:\n                Map<String, NodeModel> root = new HashMap<String, NodeModel>();\n                root.put(\"doc\", NodeModel.wrap(model));\n                try {\n                    freemarker.template.Template template = freemarkerConf.getTemplate(tpl.getTemplateFileName());\n                    template.process(root, out);\n                } catch (ParseException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"Can't find '\" + tpl + \"' when generating \" + outFileName, e);\n                } catch (TemplateException e) {\n                    throw new ModelGenerationException(\"There is an error in template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                } catch (RuntimeException e) {\n                    throw new ModelGenerationException(\"There is another error while trying this template: \" + tpl + \". I found it when generating \" + outFileName, e);\n                }\n                break;\n            case xslt:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    xsltTransform(model.getFirstChild(), in, out, xsltParam);\n                } catch (FileNotFoundException e) {\n                    throw new ModelGenerationException(\"Can't find \" + tpl, e);\n                } catch (TransformerException e) {\n                    throw new ModelGenerationException(\"Sorry, i failed to use this template: \" + tpl + \". It broke when generating \" + outFileName, e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n                break;\n            case copy:\n                try {\n                    in = new FileInputStream(tpl.getAbsolutePath());\n                    IOUtils.copy(in, out);\n                } catch (IOException e) {\n                    throw new ModelGenerationException(\"File copy failed \" + tpl.getTemplateFileName(), e);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n        }\n        IOUtils.closeQuietly(out);\n    }\n", "code2": "    public byte[] getResponse() {\n        final ByteArrayInputStream bais = new ByteArrayInputStream(request);\n        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        List<String> lines = Collections.emptyList();\n        try {\n            @SuppressWarnings(\"unchecked\") List<String> dl = IOUtils.readLines(bais);\n            lines = dl;\n        } catch (IOException ioex) {\n            throw new AssertionError(ioex);\n        }\n        String resource = null;\n        for (String line : lines) {\n            if (line.startsWith(\"GET \")) {\n                int endIndex = line.lastIndexOf(' ');\n                resource = line.substring(4, endIndex);\n            }\n        }\n        final PrintStream printStream = new PrintStream(baos);\n        if (resource == null) {\n            printStream.println(\"HTTP/1.1 400 Bad Request\");\n        } else {\n            final InputStream inputStream = getClass().getResourceAsStream(resource);\n            if (inputStream == null) {\n                printStream.println(\"HTTP/1.1 404 Not Found\");\n                printStream.println();\n            } else {\n                printStream.println(\"HTTP/1.1 200 OK\");\n                printStream.println();\n                try {\n                    IOUtils.copy(inputStream, printStream);\n                } catch (IOException ioex) {\n                    throw new AssertionError(ioex);\n                }\n            }\n        }\n        printStream.flush();\n        printStream.close();\n        return baos.toByteArray();\n    }\n", "label": 1, "substitutes": {"process": ["request", "cess", "output", "view", "load", "construct", "parse", "run", "evaluate", "handle", "code", "path", "resource", "submit", "proc", "build", "exec", "update", "transform", "processing", "call", "processor", "project", "create", "Process"], "tpl": ["stPL", "lple", " tcl", "tplate", "tmyl", "temPL", "tml", "ttemplate", "tplug", "stpl", "Tplates", "Tper", "lcl", "fpl", "Tsl", "tpp", " tplates", "tmple", "fplate", "tple", "latpl", "tcl", "temtemplate", "qtple", "templates", "tipl", "latple", "Tpl", "stplate", "tmcp", " tml", "Tml", "itPL", "lPL", "fplug", "pipl", "templ", "stpp", "lplate", " ttemplate", " tplug", "latyl", "itpl", "lper", "tmpl", "tcp", "atml", " tplate", "Tfc", "qtpl", "atplate", "fml", "Tbl", "qtfc", " tper", "itplates", "ppl", "tbl", "tPL", " tsl", "atplug", "pPL", "qtbl", "qtcp", "Tipl", "Tpp", " tbl", "psl", " tple", "latcp", "itplate", "lpl", " tpp", " tfc", "tper", "qtyl", "Tcl", " tipl", "atpl", "Tple", "lml", "tplates", "Ttemplate", "Tplate", "pcl", "TPL", " tPL", "tsl", "tfc", "tyl"], "model": ["where", "m", "models", "copy", "Model", "json", "module", "result", "media", "location", "graph", "message", "param", "params", "xml", "conf", "doc", "data", "log", "language", "document", "node", "project", "body", "command", "config"], "packageName": ["projectName", "projectKey", "packagename", "groupKey", "groupname", "packageInfo", "moduleUrl", "moduleKey", "contextname", "Packagename", " packageInfo", "projectname", "contextNames", "groupName", "PackageName", "moduleName", "packageUrl", " packagename", "PackageInfo", "modulename", "packageKey", "packageNames", " packageNames", "PackageNames", "groupUrl", "contextName", "projectUrl", "contextInfo"], "outFileName": ["outRuleInfo", "outRuleType", "outLineNames", "outfileNames", "outDirEnd", "OUTBufferName", "inFilePath", "diffFileName", "outDirCopy", "outfileName", "outFullTime", "outfileCopy", "outDirPath", "outFileTime", "inDirCopy", "outDirInfo", "outStreamName", "OUTFileName", " outFileLine", "outfileOnce", "OUTBufferMode", "outDirOnce", "outBufferMode", "outFileOnce", "outFileEnd", "outFilesPath", "outStreamType", "outFilenameName", "outfileInfo", "outFilesTime", "OutDirLine", "outFilename", "outfileHalf", "outBufferHalf", "outFileLine", "inDirName", "OutDirNames", "outFilesName", "outBufferNames", "outFileType", "outFullname", "outFileHalf", "difffileInfo", "outFilenameNames", "outFileCopy", "outFilenameCopy", "outLineInfo", "OutFileNames", " outFileInfo", "diffFileOnce", "outFullName", "inDirPath", "outFullInfo", "inFileName", "diffFileInfo", "outLineName", "diffFileTime", "difffileTime", "outFilenameEnd", "outFullType", "outFilenameMode", " outDirTime", " outFullType", "outFilenameHalf", "outfileTime", "outLineTime", "outFullPath", "outLineLine", "inFileCopy", " outDirLine", "OutDirname", "outFilesLine", " outFileType", "OutFilename", " outFilePath", "OUTFileNames", " outDirName", "outFileNames", "outLineOnce", "outBufferName", "outfileMode", "outDirTime", "inFileEnd", "outFullLine", "difffileOnce", "inDirEnd", "OUTBufferNames", " outFullName", "outStreamInfo", "outDirLine", "outLinename", "outfileEnd", "OutFileLine", " outDirPath", "outFullNames", "outFilenamePath", "OUTBufferHalf", "outFileInfo", "difffileName", "outDirname", "OutFileName", "outfilePath", "outFileMode", "outDirNames", "OUTFileHalf", " outFullInfo", "outDirName", " outFileTime", "OUTFileMode", "OutDirName", "outFilePath", "outRuleName"], "xsltParam": ["xslicparam", "xslpMode", "xslicMode", "xsldVal", "xslicParam", "xsltMode", "xslpparam", "xslpParam", "xltVal", "xsltVal", "xsldparam", "xsldParam", "xldMode", "xldparam", "xldVal", "xsltparam", "xltParam", "xltMode", "xslicVal", "xltparam", "xslpVal", "xldParam", "xsldMode"], "artifact": ["artfact", "Artfact", "Arturation", " artribution", "Artifacts", "advertribution", "Artifest", " arturation", "advertifacts", "adverturation", "artifest", " artifacts", "ARTifest", "arturation", "ARTifact", "ARTfact", "ARTifacts", "artifacts", "aratifacts", "Artifact", "advertifact", "aratifest", "aratifact", "aratfact", "artribution", "Artribution"], "destinationPath": ["destinatedPoint", "destinationFile", "constinationContext", "destinatorUrl", "datinationPath", "destificationPath", "destinatorFile", "tempinationPath", "restinatorPath", "tempinationpath", "destensionPoint", "destplingPath", "destinatorPath", "destinatorString", "distinatorStep", "constinatorpath", "destensionName", "destinatePath", "desticationKey", "destinatedHalf", "destinatorStep", "destinationsName", "destinateHandler", "destinerPath", "constinatorUrl", "destignmentCase", "destiationDir", "destinatedDir", "desticationPart", "distinationCase", "destinatingPath", "combinationName", "destinateText", "destinationspath", "constinationWidth", "destinationsPath", "restinationString", "tempinatedDir", "destinatepath", "destificationAuth", "destinatePart", "destinateName", "datinationpath", "destinationName", "destiationPath", "destinatedCase", "tempinatedpath", "destributionName", "datinateTime", "desturationName", "constinationName", "desticationPath", "DestinatingName", "destinationUrl", " destificationLog", "datinationTime", "destplingDir", "destplingAuth", "restinationLocation", "restinationpath", "destinatedFile", "destinateDir", " destinationLog", "destiationAuth", "destificationLog", "distinationStep", "desticationFile", "destributionCry", "destinationText", "DestinationPart", "destinateString", "combinationPath", "restinatorPoint", "destinationHandler", "destinationContext", "destinatedString", "constinationsPoint", "distinatorKey", "destplingWidth", "restinationPoint", "destificationLocation", "destationpath", "tempinationHalf", "restificationPath", "desturationPath", "destinationAuth", "distributionCase", "destiningDir", "restificationPoint", "destinatorName", "destinatorPoint", "constinationUrl", "destributionCase", "DestificationPath", "constinatorPath", "destinatedpath", "destinateLocation", "destinationpath", "destensionPath", "destcreationPath", "destinatingpath", "desturationpath", " destinationDir", "destificationpath", "destinatorpath", "destiationLog", "destignmentPath", "destationPath", "destificationName", "destinatorCase", "destplingLog", "destinationCase", "destinationWidth", "combinatorName", "combinatorPath", "destinationsPoint", "restinationHalf", "constinationPath", "constinatorContext", "destinatingName", "destributionDir", "destinerDir", "destinationTime", "restinatorHalf", "destiningContext", " destinationAuth", "DestinatingPath", "destinatorDir", "tempinatedPath", " destificationAuth", "distinationpath", "destinatedPath", "distinationCry", "combinatorHandler", "distributionpath", "distinatorName", " destificationDir", "datinationLocation", "constinatorWidth", "destinateTime", "DestificationPart", "restinatorString", "distinatorCase", "destinationLocation", "distinationDir", "destinationDir", "DestificationName", "destinatePoint", "destinatorHandler", "destinatorHalf", "destplingUrl", "destributionPath", "destinatingLocation", "destcreationUrl", "DestinationPath", "desticationStep", "destinerContext", "desticationName", "distinatorCry", "destinationKey", " destificationPath", "destinatedKey", "destationTime", "DestinationText", "constinatorDir", "combinatorpath", "constinationDir", "destinatingText", "distinationName", "constinationpath", "destiningName", "constinationsPath", "restinationPath", "destiningPath", "combinationHandler", "destributionpath", "distinatorPath", "constinationsName", "restificationpath", "destensionText", "destinationStep", "destinationPart", "destinatorWidth", "destificationPart", "desturationHandler", "destinateHalf", "destinatorTime", "constinationPoint", "distinationKey", "DestinatingText", "DestinationName", "destiningPoint", "destinatorLocation", "destinationLog", "distinationFile", "destationLocation", "destificationPoint", "datinatePath", "DestinationPoint", "distributionPath", "destinerpath", "distinationPath", "constinationspath", "destinationPoint", "destinatorKey", "destignmentName", "destinatingPoint", "destinationString", "combinationpath", "DestinatingPoint", "destiningpath", "destificationDir", "tempinationDir", "destinatedStep", "distributionDir", "distinatorFile", "destcreationWidth", "destinationHalf", "destinatorContext", "tempinatedHalf", "destinatorCry", "destignmentCry", "destinationCry", "datinateLocation", "restificationLocation", "datinatepath"], "in": ["r", "image", "n", "i", "input", "ex", "din", "t", "cache", "connection", "con", "x", "min", "doc", "data", "ins", "name", "bin", "In", "reader", "IN", "d", "source", "config", "c", "inc"], "out": ["Out", "error", "ne", "client", "writer", "obj", "msg", "full", "all", "up", "key", "output", "comment", "user", "version", "free", "write", "parent", "copy", "cli", "page", "ex", "cache", "server", "conn", "group", "state", "result", "connection", "path", "index", "io", "pool", "line", "manager", "file", "str", "post", "part", "store", "prefix", "lib", "o", "exec", "doc", "Output", "session", "err", "with", "temp", "log", "w", "name", "bin", "again", "string", "list", "point", "sys", "outer", "outs", "gen", "lock", "dump", "source", "OUT"], "root": ["r", "query", "tree", "pattern", "instance", "cat", "parent", "id", "include", "json", "cache", "history", "module", "format", " result", "index", "graph", "path", "params", "modules", "resources", "results", " roots", "roots", "_", "xml", "options", "url", "loader", "values", "collection", "transform", "node", "Root", "meta"]}}
{"id1": "7122523", "id2": "15472181", "code1": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"execute": ["next", "process", "transfer", "default", "action", "instance", "route", "run", "apply", "info", "result", "handle", "submit", "message", "report", "send", "post", "start", "forward", "this", "exec", "data", "transform", "method", "call", "invoke", "create", "func"], "mapping": [" mapper", "mapper", "patching", " mappings", "Mapper", "pording", "mappings", "Mappings", "rmapping", "matching", "mmailing", "papping", "mmatching", " mailing", " mapped", "mmapping", "Mapping", " matching", " mording", "mapped", "Mapped", "pailing", "mording", "rmapped", "rmapper", "rmappings", "mmording", "mailing"], "form": ["former", " forms", "template", "query", "upload", "entry", "flow", "view", "object", "app", "input", "Form", "route", "page", "format", "submit", "path", "FORM", "post", "model", "session", "builder", "control", "forms", "transform", "command", "field", "config"], "request": ["image", "client", "query", "queue", "q", "view", "object", "use", "context", "input", "user", "instance", "parent", "enter", "route", "handler", "server", "result", "state", "message", "resource", "report", "submit", "path", "xml", "req", "model", "session", "type", "subject", "application", "method", "Request", "frame", "ware", "web", "QUEST", "event", "current", "create"], "response": ["error", "client", " Response", "output", "reply", "object", " responses", "view", "page", "server", "result", "http", "report", "message", "resource", "results", "Response", "manager", "resp", "req", "model", "session", "data", "status", "application", "res"], "delegate": ["roleplementation", "releg", " deplementation", "deleg", "declegates", "decleg", "deploy", "decider", " delegates", "delic", "Delic", " delic", "DElegate", "declegate", "DElegates", "relegates", "deider", "rolelegate", "Deploy", "reploy", "Deplementation", "DEploy", "rolelic", "Delegate", "rolelegates", "DEleg", "Delegates", "relegate", "Deleg", "deplementation", "Deider", " deleg", " deider", "delegates"], "errors": ["items", "error", "details", "all", "les", "management", "s", " responses", "instance", "asts", "rs", "e", "comments", "ages", "maps", "events", "ros", "es", "effects", "links", "objects", "rss", "array", " Errors", "failed", "issues", "reports", " messages", "params", "xml", "results", "members", "relations", "null", "ays", "data", "err", "values", "blocks", "orders", "ceptions", "rows", " exceptions", "eps", "ins", "ops", "settings", "ae", "rors", "parser", "uments", "runs", "rules", " problems", "ations", "plugins"], "ayudaPantalla": ["ayudaPatantalla", "ayudaPentilla", "ayudaTentalla", "ayudaPantsella", "ayudaPandala", "ayudaPandilla", "ayudaPatantala", "ayudaTantala", "ayudaPataraalla", "ayudaTantalla", "ayudaPandalla", "ayudaPantla", "ayudaParaalla", "ayudaParala", "ayudaTantilla", "ayudaParailla", "ayudaPantala", "ayudaPentala", "ayudaPataraala", "ayudaPatarailla", "ayudaPantsilla", "ayudaPantilla", "ayudaPentella", "ayudaTentilla", "ayudaTentala", "ayudaPatantla", "ayudaPantsalla", "ayudaPatarala", "ayudaTantella", "ayudaPantella", "ayudaPandella", "ayudaParaala", "ayudaPatantilla", "ayudaPandla", "ayudaPentalla", "ayudaPantsla", "ayudaPantsala", "ayudaTentella"], "traAyudaPantalla": ["traAyudaParalla", "traAyudaPentella", "traAyudaVantaya", "traAyudaPlantala", "traAyudaPlantalla", "traAyudaPantilla", "traAyudaPandilla", "traAyudaPlantilla", "traAyudaPlantingalla", "traAyudaPentala", "traAyudaParaala", "traAyudaPartalla", "traAyudaVandala", "traAyudaVandalla", "traAyudaPartaya", "traAyudaPartala", "traAyudaPandaya", "traAyudaPantingella", "traAyudaParaaya", "traAyudaVantalla", "traAyudaPantingalla", "traAyudaVandlla", "traAyudaPantingala", "traAyudaPantaya", "traAyudaPlantella", "traAyudaPandella", "traAyudaPartlla", "traAyudaVandaya", "traAyudaPlantingilla", "traAyudaPlantingala", "traAyudaPentalla", "traAyudaPantingilla", "traAyudaPantala", "traAyudaPandalla", "traAyudaParaalla", "traAyudaPandlla", "traAyudaVantlla", "traAyudaPantlla", "traAyudaPentilla", "traAyudaPandala", "traAyudaPlantingella", "traAyudaPantella", "traAyudaVantala"], "urlSonido": ["urlSonigma", "UrlSonini", "urlBonido", "uriSonini", "UrlBonido", "UrlSonido", "uriSonigma", "urlTonri", "urlSonri", "urlSonado", "urlTonigma", " urlSonini", "UrlSonigo", "urlSenido", "urlBonigo", "urlsonido", "UrlBonida", "urlTonid", " urlTonido", "urlBonini", "urlSonid", "urlSenigo", "urlTonigo", "UrlSonidi", "urlSenini", "urlMonidi", "urlSonigo", "urlSONid", "UrlBonidi", "urlSONigma", "UrlSenini", "UrlSenri", "UrlBonuli", "urlsonid", "urlBonida", "urlMonido", "urlsonado", "urlSONini", "uriSONini", "urlSONido", "UrlSenigo", "urlSenri", "UrlSenido", "urlMonida", "UrlSonuli", " urlTonado", " urlSonigo", "uriSONigma", "urlsonigma", "urlsonigo", " urlTonigo", "urlSonidi", "uriSONido", "urlsonri", "urlBonidi", "urlSONuli", "urlBonuli", "urlSonini", "uriSonido", "urlTonini", "urlSONida", " urlTonini", " urlSonado", "urlSonida", "UrlSonri", "urlMonuli", "urlTonido", "urlSonuli", "UrlSonida", "urlTonado", "urlBonado", "urlsonini", "uriSonid", "urlSONidi", "uriSONid"], "url": ["image", "client", "service", "sl", "full", "impl", "fl", "user", "ls", "page", "server", "json", "connection", "http", "location", "URL", "resource", "path", "ssl", "str", "f", "Url", "base", "system", "control", "gl", "download", "log", "b", "ll", "l", "string", "web", "uri", "source", "config", "www"], "urlConnection": ["UrlConnection", "webconnection", "webConnector", "httpFactory", "httpConnection", "urlConnector", "UrlConnector", "userInfo", "urlconnection", "urlConn", "eventConnection", "eventConnector", "webFactory", "eventconnection", "httpConn", "urlConnect", "URLFactory", "eventConnect", "UrlConnect", "urlClient", "webClient", "httpClient", "webConnect", "urlFactory", "Urlconnection", "URLClient", " urlconnection", "webConnection", "userconnection", "UrlInfo", "URLConnection", "urlInfo", "URLConn", " urlInfo", "userConnection", "webConn"], "tipoMime": [" tipoMile", "tipoMext", "tipoMale", "tipoCorph", "tiposTanche", "tipoTime", " tipoTile", "tiposMike", "tipoPIME", "tiposMime", "tipoKnIME", "tipoMIME", " tiposTIME", "tipoKnanche", "tipoDemIME", " tipoMIME", "tipoManche", " tiposMime", "tipoMike", "tiposTorph", "tipoNime", " tipoSmIME", "tipoTIME", " tipoMetile", " tipoMpe", " tipoTpe", " tipoMetIME", "tipoTanche", " tipoMetime", "tipoDemize", "tiposManche", " tipoSmpe", " tipoSmime", "tipoTize", " tiposTpe", " tipoSmile", "tipoImale", "tipoImime", "tipoPime", "tipoCime", " tiposMile", "tiposMale", "tipoPanche", "tipoNext", "tipoCile", "tipoTale", "tiposTize", "tiposMext", "tipoTile", " tiposMpe", "tipoDemime", "tipoCIME", " tiposTime", " tipoTIME", "tipoImize", "tiposTile", "tipoNile", "tipoMize", "tipoTorph", "tipoMorph", " tiposMIME", "tiposTike", "tipoKnike", "tiposMIME", "tipoText", "tipoNIME", "tiposMize", "tipoCext", "tipoMile", " tiposTile", "tipoImIME", "tiposMorph", "tipoPike", "tiposTIME", "tiposText", "tipoKnime", "tiposTale", "tiposMile", "tiposTime", "tipoTike", "tipoDemale", " tipoTime", " tipoMetpe"], "audioOptions": ["oggOptions", "videoParts", "mediaParts", "audioStyle", "AudioStyle", "videoOptions", " audioColor", "audioContents", "oggRules", "soundOptions", "soundSettings", " audioStream", "mediaSettings", " audioStyle", "archiveOptions", "soundContents", "audioColor", "videoGames", "videoVideo", "mediaGames", "AudioColor", "archiveColor", "musicStream", " audioContents", "musicSettings", "audioOption", " audioParts", "soundOption", " audioOption", "soundRules", "AudioStream", "AudioOptions", "archiveStyle", "videooptions", "oggContents", " audioSettings", "audioGames", "audioSettings", "AudioGames", "musicParts", "mediaOptions", "audioParts", "oggOption", " audioVideo", " audioRules", "AudioSettings", "videoSettings", "audioStream", "videoStream", "audioRules", " audioGames", "soundoptions", "audioVideo", "mediaStyle", "archiveStream", " audiooptions", "musicOptions", "audiooptions", "mediaVideo"]}}
{"id1": "1156851", "id2": "6457199", "code1": "    public void runWeb(String beginURL, String contextRoot, String pageURI) {\n        if (bDebug) System.out.println(\"WEB Path\");\n        List<String> vtURLs = new ArrayList<String>();\n        List<String> vtRobots = getRobots(beginURL, contextRoot);\n        vtURLs.add(\"/\" + contextRoot + \"/\" + pageURI);\n        Indexer indexer = null;\n        IndexDocument indexDoc = null;\n        try {\n            indexer = new Indexer(\"/tmp/tmp/index\");\n            for (String sxURL : vtURLs) {\n                if (bDebug) System.out.println(\"\\n\\n*** INDEXING \" + sxURL);\n                if (bDebug) System.out.println(\"Have - \" + sxURL);\n                boolean bIndexPage = true;\n                if (vtRobots != null) {\n                    for (String sxRobotURL : vtRobots) {\n                        if (bDebug) System.out.println(\"Comparing to - \" + sxRobotURL);\n                        if (sxURL.startsWith(sxRobotURL)) {\n                            if (bDebug) System.out.println(\"Found URL - \" + sxRobotURL + \" - \" + sxURL);\n                            bIndexPage = false;\n                            break;\n                        }\n                    }\n                } else {\n                    bIndexPage = true;\n                }\n                sxURL = beginURL + sxURL;\n                ParserDelegator pd = new ParserDelegator();\n                CallbackHandler cb = new CallbackHandler(vtURLs, bIndexPage, contextRoot);\n                try {\n                    URLConnection urlConn = new URL(sxURL).openConnection();\n                    urlConn.setUseCaches(false);\n                    Date modDate = new Date(urlConn.getLastModified());\n                    if (bDebug) System.out.println(\"\\nMatch - \" + sxURL + \" - Modified Date - \" + modDate);\n                    BufferedReader bfReader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n                    pd.parse(bfReader, cb, true);\n                    if (bIndexPage) {\n                        if (bDebug) System.out.println(\"Adding Index - \" + sxURL + \"\\nContent:\" + cb.getText() + \"\\nSummary:\" + cb.getSummary() + \"\\nTitle:\" + cb.getTitle());\n                        indexDoc = new IndexDocument();\n                        indexDoc.setUID(sxURL + modDate.toString());\n                        indexDoc.setPageURL(sxURL);\n                        indexDoc.setModifiedDate(modDate.toString());\n                        indexDoc.setContents(cb.getText());\n                        indexDoc.setTitle(cb.getTitle());\n                        indexDoc.setSummary(cb.getSummary());\n                        indexer.addDocument(indexDoc);\n                    }\n                } catch (Exception ee) {\n                    PetstoreUtil.getLogger().log(Level.SEVERE, \"Inner Exception\" + ee);\n                }\n            }\n        } catch (Exception e) {\n            PetstoreUtil.getLogger().log(Level.SEVERE, \"Outer Exception\" + e);\n        } finally {\n            try {\n                if (indexer != null) {\n                    indexer.close();\n                }\n            } catch (Exception ee) {\n                ee.printStackTrace();\n            }\n        }\n    }\n", "code2": "    protected boolean doRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String path = request.getPathInfo();\n        if (!path.startsWith(alias)) {\n            throw new ServletException(\"Path '\" + path + \"' does not start with registered alias '\" + alias + \"'\");\n        }\n        String internal;\n        if (alias.equals(\"/\")) {\n            internal = name + path;\n        } else {\n            internal = name + path.substring(alias.length(), path.length());\n        }\n        URL resource = httpContext.getResource(internal);\n        if (resource == null) {\n            return false;\n        }\n        String mimeType = servletContext.getMimeType(internal);\n        if (mimeType != null) {\n            response.setContentType(mimeType);\n        }\n        InputStream is = resource.openStream();\n        OutputStream os = response.getOutputStream();\n        IOUtils.copyAndClose(is, os);\n        return true;\n    }\n", "label": 0, "substitutes": {"runWeb": ["processSite", "processWs", "runningWs", " runweb", "runningWeb", "runweb", "runningSite", "processWeb", " runWs", "runSite", "runWs", " runSite", "runningweb", "processweb"], "beginURL": ["Beginurl", "endURI", "startELF", "untilURI", "useUR", "BeginURI", "BeginURL", "endUrl", "beginELF", "BeginELF", "startUrl", " beginUrl", "beginSSL", "endUR", "untilURL", "beginUR", "beginUrl", "BeginSSL", " beginSSL", "untilurl", "BeginUR", "useUrl", "endurl", "startURL", "useURL", "beginURI", "endURL", "untilUrl", "startSSL", "BeginUrl", "beginurl", " beginELF", "useURI"], "contextRoot": ["conceptBase", "contextGround", " contextRO", "eventroot", "resourcePath", "ContextRO", "eventRoot", " contextHome", "ContextGround", "ContextHome", "ContextBase", " contextPath", " contextBase", " contextGround", "serviceRO", "resourceroot", "contextRO", "resourceRoot", "contextHome", "ContextPath", "serviceRoot", "conceptRoot", "conceptHome", "ContextRoot", "conceptroot", "serviceroot", "contextBase", "Contextroot", "contextroot", "serviceGround", "contextPath", " contextroot"], "pageURI": ["PageID", "endURI", "enduri", "PageUR", "pageuri", " pageuri", "siteURL", "pageURL", " pageURL", "endUR", "pageID", "PageURL", " pageUR", "endURL", " pageID", "pageUR", "PageURI", "Pageuri", "siteUR", "siteID", "siteURI"], "vtURLs": ["rtURLls", "vtGETls", "vtRLS", "vtURLi", "vtURLParts", "tvDownloades", "vtUrlParts", "vtURLobs", "VTURls", "vtUrllines", "vtURLS", "VTURs", "htURs", "vtURLlines", "vtGETs", "vtIPs", "tvURLS", "tvDownloadS", "VTURLs", "vtURs", "htURParts", "vtStreamobs", "vtStreams", "vtDownloades", "vtRLes", "rtURLS", "vtURLes", "vtGETS", "vtDownloadS", "vtURLls", "htURls", "htURobs", "htURLParts", "vturli", "vturlls", "rtURls", "VTURLls", "VTURlines", "VTURi", "vtUrlobs", "VTURLi", "vtURobs", "htURLobs", "vtDownloads", "vtIPS", "rtURLs", "vturls", "vtStreamls", "vtURParts", "vtRLs", "tvDownloads", "tvURLs", "htURLs", "rtURs", "vtURlines", "vtStreamParts", "vtIPes", "vtURls", "VTURLlines", "htURLls", "vtURS", "vtUrlS", "vtUrlls", "vtUrli", "vtURi", "tvURLes", "rtURS", "vturllines", "vtUrls"], "vtRobots": ["vtProops", "VTRobugs", "vtLegibraries", "vtGrorots", "VTProops", "htrobOTS", "VTGroibraries", "vtrobops", "vtBlOTS", "vtPros", "vtGroibraries", "VTRobots", "vtProots", "vtRobot", "vtBOTS", "vtBots", "VTPros", "vtBlots", "vtRobOTS", "vtLogOTS", "vtRobops", "vtPlugs", "VTRobibraries", "vtPlrots", "vtrobOTS", "vtBot", "VTRobs", "htrobops", "vtBlops", "vtLegots", "vtGrougs", "VTRobOTS", "VTGrorots", "vtRobs", "vtLogs", "vtPlibraries", "vtLogots", "VTProOTS", "vtLegugs", "VTProots", "vtLogops", "vtRobrots", "vtRobibraries", "vtProOTS", "vtBlot", "htRobots", "vtBs", "htRobot", "VTGrougs", "vtLegrots", "htrobot", "vtBops", "htrobots", "VTRobops", "vtrobots", "VTGroots", "VTRobrots", "vtrobot", "htRobOTS", "vtGroots", "htRobops", "vtRobugs", "vtPlots"], "indexer": ["indexe", "checkers", " indexers", " indexER", "checkER", "IndexER", "Indexer", " indexed", "checkeer", "findReader", " indexeer", "indexers", "checker", " indexe", "fixed", "indexed", " indexReader", "indexeer", "Indexers", "fixer", "Indexeer", "finded", "fixe", "finder", "finde", "indexReader", "fixReader", "indexER"], "indexDoc": ["documentPage", "indexDom", "officePage", "Indexdoc", "indexdoc", "documentDom", "documentdoc", "documentDoc", "officeDoc", "IndexPage", "officeDom", "officedoc", "indexPage", "IndexDoc", "IndexDom"], "sxURL": ["sxDB", "sxeURL", "sfxURI", "sxiDOM", "sxcELF", "sxeTL", "dsxeURL", " sexURL", " sxcSSL", "sxxurl", " sxcUrl", "SxUrl", "lxUR", "pxUrl", "sxiUR", "SxUR", "sxELF", "sXDB", "sxcUrl", " sexurl", "lXUR", "swwLink", " sxcURI", "sfxUR", "snexURL", "SexURL", " sxURI", "snexurl", "sexURL", "snexUR", "SxURL", "sxtURL", "sXDOM", "sxxURI", " sxcurl", " sxDB", "sxxUR", "sxcLink", " sXURL", "sxSSL", "lxURL", "sXSSL", "sexELF", " sXurl", " sxLink", "pxcUrl", "sxURI", "sxbUR", "sxeUR", "sexDOM", "sxeurl", " sxcURL", "sxeUrl", "dsxURL", "sxcUR", "sxxURL", "sxtDB", " sexUrl", "sexUrl", "lXURL", " sxUrl", "pxcURL", "pxURL", "sXUR", "dsxUR", "dsxTL", "dsxeTL", "sxaurl", "sxLink", "sXURL", "sxiSSL", "swwURL", "sexUR", "sfxURL", "SexELF", "sxUR", "dsxeUR", "lXDOM", "sexSSL", "sxeSSL", " sxurl", "dsxeurl", "sxbURL", "swwUrl", "sxburl", "lXSSL", "swwUR", "sxaTL", " sxUR", "sxxUrl", "sxcURI", "SxELF", "sxtUR", "sxcurl", "sxturl", "pxcURI", "sxurl", " sxcUR", "lxSSL", "dsxurl", "sxUrl", "sxxDB", "sxcURL", "sxTL", "snexTL", "sxbUrl", "pxURI", "sxaUR", "sxaURL", "sxcSSL", "sXELF", "sexurl", " sXUR", "sxtUrl", " sxSSL", "sxiURL", "sfxUrl", "SexUR", "SexUrl", "sxtURI", "sxDOM", "sXurl", " sXDB", " sexUR", "sXUrl", "sfxSSL", "lxDOM"], "sxRobotURL": ["sxRooyTL", "sxRoboPath", "sxRoboyUrl", "sxRubotUR", "sxRooyURL", "sxRobotTL", "sxRobobUR", "sxRobOTPath", "sxRoboURL", "sxRobogTL", "sxRuboPath", "sxRobobTL", "sxRobOTTL", "sxRobobSSL", "sxRobooturl", "sxRobotSSL", "sxRobogURL", "sxRobootURL", "sxRoboUrl", "sxLootTL", "sxRootTL", "sxRubotURL", "sxRobotationCL", "sxRobogSSL", "sxRuboUrl", "sxRobotUR", "sxRoboUR", "sxRobOTURI", "sxRoboyURL", "sxRuboUR", "sxRobotUrl", "sxRobotationURL", "sxRubotUrl", "sxRobotationURI", "sxRobOTCL", "sxRobootTL", "sxLoobTL", "sxRubotPath", "sxRoboburl", "sxRobOTUrl", "sxRobobURI", "sxLootURL", "sxRobotURI", "sxRoboturl", "sxRobortTL", "sxRoboyTL", "sxLootSSL", "sxRooyUR", "sxRobortUR", "sxRobootSSL", "sxRobotCL", "sxRobortURL", "sxRuboURL", "sxRobogurl", "sxRobOTUR", "sxRobobCL", "sxRoboyPath", "sxLoobURL", "sxRoboyUR", "sxRobOTURL", "sxRootUR", "sxLooburl", "sxRobotationUR", "sxLooturl", "sxLoobSSL", "sxRobobURL", "sxRootURL", "sxRobotPath"], "pd": ["ppa", " md", "p", "bf", "pp", " db", " td", "PF", " pp", " pm", "pg", "bb", " dc", "CB", "Parser", " cp", "py", "md", "ht", "cd", "APD", " PD", "lp", "td", "ds", "pb", "gd", "bd", "pi", "PB", "xd", "pm", "dl", "wp", " sd", " pdf", "PD", " df", " DD", "pc", "cpp", "hd", "vd", "d", " cd", "parser", "BT", "dd", " dd"], "cb": ["db", "bp", "ca", "BBC", "ctx", "bf", " db", "cp", "ff", "fd", "func", "Callback", "bb", "handler", "CB", "cf", "sb", "cd", "bc", "rb", "fb", "dc", "kb", "ob", "buff", "cm", "gb", "fn", "fc", "pb", " rc", "bd", "eb", "callback", " CB", "b", "cv", "cpp", "obb", " cd", "cod", " bc", "cmp", "cmd", "c", " dd"], "bIndexPage": ["bindexpage", "bbSearchPage", " bQueryPage", " bIndexPages", " bIndexpage", "bQueryTable", "bindexPages", " bindexpage", "bSearchLine", "bQueryLine", " bindexLine", "bindexFile", "bSearchpage", " bSearchpage", "nbIndexPage", "bindexLine", "bindexPage", "bbIndexLine", "bShortLine", "bindexTable", "nbIndexpage", " bSearchPage", "bbSearchpage", " bIndexFile", "bSearchPage", "bLinkPage", "bShortPage", " bIndexTable", "bQueryFile", "bQueryPage", "bIndexFile", "nbLinkFile", "bLinkLine", "bShortpage", " bQueryFile", "nbLinkLine", "bLinkpage", "bSearchPages", "bIndexPages", "bIndexLine", " bindexPages", " bIndexLine", "bIndexpage", " bindexPage", "bbIndexPage", "bSearchFile", "bSearchTable", "nbIndexFile", "nbLinkpage", "nbIndexLine", "bLinkFile", "bbIndexpage", "bbSearchLine", " bSearchPages", "bLinkPages", " bQueryLine", "nbLinkPage", "bIndexTable", " bQueryTable"], "urlConn": ["httpConnection", "urlCon", "fileConnection", " urlConnect", " urlConf", " urlBuff", "urlConf", "URLBuff", "httpConn", "fileconn", "URLconn", "UrlConfig", "UrlConn", "serverCon", "fileConnect", "httpconn", "urlConnect", "URLCo", " urlConfig", "serverConnect", " urlConnection", "serverConn", " urlCon", "URLConf", "UrlConf", " urlCo", "URLConnect", "URLConfig", "serverConnection", "fileConn", "urlConfig", "urlConnection", "URLConnection", "httpCon", "httpCo", "URLConn", "urlBuff", "UrlBuff", "urlconn", "urlCo", "httpConnect"], "modDate": ["modTime", "modDat", " modTime", "MODDay", "ModTime", " modDat", "ModDay", "ModDate", "modDay", "MODTime", "MODDat", "MODDate", "ModDat", " modDay"], "bfReader": ["btRead", "bfRead", "bdreader", "bfBuffer", "BFRead", "bdReader", "bdWriter", "bdBuffer", "bbWriter", "BFFile", "btWriter", "bbBuffer", "bbRead", "bbReader", "bbreader", "bfFile", "bfreader", "BFReader", "BFWriter", "btFile", "bbFile", "btreader", "btBuffer", "btReader", "bfWriter"]}}
{"id1": "17901739", "id2": "13368520", "code1": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "code2": "    public void sendTextFile(String filename) throws IOException {\n        Checker.checkEmpty(filename, \"filename\");\n        URL url = _getFile(filename);\n        PrintWriter out = getWriter();\n        Streams.copy(new InputStreamReader(url.openStream()), out);\n        out.close();\n    }\n", "label": 0, "substitutes": {"setMembers": ["setJoin", "SetJoin", "SetMembers", "setMember", "SetMethods", " setJoin", "parseMembers", " setMethods", "parseMember", "parseJoin", "setMethods", "parseMethods", "SetMember", " setMember"], "url": ["image", "blog", "client", "service", "email", "sl", "entry", "queue", "socket", "feed", "user", "server", "address", "connection", "http", "location", "URL", "resource", "path", "io", "hub", "ssl", "file", "Url", "channel", "base", "data", "loader", "org", "article", "l", "string", "uri", "source", "www"], "reader": ["r", "iterator", "writer", "ner", "worker", "Reader", "entry", "stream", "rer", "i", "rc", "feed", "input", "e", "handler", "server", "per", "ler", "http", "inner", "editor", "report", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "f", "builder", "err", "loader", "er", "driver", "l", "table", "parser", "read", "bird"], "buffer": ["video", "image", "stage", "sync", "flash", "FFER", "comment", "Buffer", "address", "info", "fb", "http", "str", "iter", "buf", "base", "text", "string", "uri", "window", "flush", "length", "request", "bytes", "batch", "feed", "input", "parse", "page", "cache", "rb", "response", "message", "buff", "file", "uffer", "b", "bar", "border", "pause", "button", "writer", "fr", "received", "output", "bb", "expression", "phrase", "result", "padding", "line", "row", "null", "player", "paste", "wave", "background", "password", "counter", "seed", "layer", "source", "filename", "template", "queue", "read", "transfer", "sequence", "server", "game", "code", "resource", "binary", "data", "loader", "document", "bin", "header", "texture"], "pattern": ["image", "position", " Pattern", "match", "template", "cher", "script", "object", "print", "feed", "app", "slice", "serial", "expression", "patch", "handler", "Pattern", "rule", "cache", "child", "group", "format", "array", "graph", "path", "regular", "df", "function", "file", "part", "str", "letter", "model", "system", "builder", "type", "log", "number", "atter", "document", "password", "counter", "string", "parser", "command", "filter", "event", "re", "layer", "config", "condition"], "matcher": ["reches", "ratger", "patatcher", "manacher", "statcher", "compner", "patner", "mitchers", "ratacher", "Matpattern", "matchpattern", "Matger", "statpattern", "captatter", "attacher", "compatcher", " matter", "captpattern", "patcher", "matacher", "mirher", "matches", " matpattern", "mither", "Matner", "harpattern", "matchher", "matchers", "motpattern", "reched", "harcher", "reach", "compach", "patch", "mather", "Matching", "matatcher", "matchched", "mancher", "compched", " matacher", "harner", " mather", "captter", "motner", "matchches", " matatter", "matger", " matler", "attcher", "matchler", "matchter", "manher", "matching", "patpattern", "compter", "matatter", "patter", "matpattern", "matler", "mirter", "Matacher", "linter", "matach", "matchach", "pather", "ratcher", " matchers", "Matter", "compcher", " match", "ratching", "captcher", "linatter", "statler", "linpattern", "statner", "motter", "lincher", "attching", "match", "matchcher", "mircher", "attger", "patchers", "manner", "mirpattern", "harler", "Matcher", "mitcher", "compches", "matchatcher", "matchacher", "matched", "recher", "motcher", "matter", "matner", " matner", "mitch", "matchner", "Mather"], "erg": ["der", "gr", "ander", "gae", "irc", "orter", "eur", "gru", "eri", "progress", "ag", "worker", "justice", "rator", "rog", "git", "ga", "ord", "eng", "igor", "gra", "east", "ger", "gg", "urg", "ero", "sg", "eric", "yang", "game", "dr", "aug", "alg", "berg", "region", "gy", "magic", "oga", "gd", "feat", "orters", "era", "ager", "porter", "uster", "jing", "org", "arc", "ERG", "er", "agog", "ig", "forge", "rg", "ider", "og", "usa", "clus", "ers", "ocr", "aga", "ard", "anger", "gas", "ung", "agg"], "start": ["pad", "size", "sort", "grad", "old", "mid", "address", "open", "info", "last", "something", "end", "space", "st", "base", "name", "ind", "get", "End", "fit", "off", "load", "begin", "check", "boot", "diff", "state", "inner", "index", "find", "part", "started", "close", "unit", "set", "scale", "pend", "offset", "stop", "like", "middle", "in", "stat", "art", "init", "ad", "starting", "id", "run", "plus", "sum", "grade", "pick", "Start", "show", "work", "count", "step", "min", "it", "seed", "speed", "head", "first", "add", "shift", "source", "position", "match", "cost", "max", "ie", "pos", "read", "sol", "se", "send", "fill", "need", "ish", "none", "rest", "type", "bin", "style", "current"], "von": ["fin", "su", "flo", "jan", "tu", "eni", "melon", "vid", "bn", "endon", "nn", "vu", "ou", "tin", "fen", "oni", "ln", "won", "zon", "han", "jen", "aven", "dn", "lin", "ver", "fat", "bon", "anon", "vin", "andon", "lon", "olson", "fn", "uber", "fun", "feat", "len", "kn", "hon", "wen", "don", "byn", "tun", "mun", "di", "hn", "vor", "onna", "bin", "ten", "mon", "lu", "evin", "endor", "una", "john", "non"], "bis": ["os", "bs", "vid", "ois", "phis", "lins", "bid", "zi", "fb", "bas", "len", "bits", "prefix", "base", "bat", "vs", "bos", "outs", "isin", "eni", "is", "bus", "uno", "nas", "isi", "ris", "val", "boot", "ios", "li", "vin", "buff", "offs", "bi", "uss", "su", "BUS", "us", "cus", "oss", "ls", "bb", "nexus", "abi", "lin", "obs", "cos", "bps", "sis", "bian", "ri", "bles", "cedes", "vals", "pos", "oris", "cin", "oni", "ui", "los", "fat", "ori", "bes", "ours", "pi", "onis", "des", "ni", "pins", "di", "bin", "lus", "bett", "udi", "idis"], "m_strComponents": ["m_strExpales", "m_strComponent", "m_strExpenses", "m_intRepales", "m_intComports", "m_arrCommales", "m_intReports", "m_strRepales", "m_intRepenses", "m_strCompenses", "m_strReports", "m_strExponents", "m_strRepenses", "m_arrCommonent", "m_arrCompenses", "m_arrComponents", "m_strReponents", "m_strCommonent", "m_strExports", "m_arrCommenses", "m_strCommales", "m_intReponents", "m_intCompales", "m_strCommenses", "m_strComponentonents", "m_arrComponent", "m_intCompenses", "m_strCommorts", "m_intComponents", "m_arrCommonents", "m_strExponent", "m_strCommonents", "m_strCompales", "m_strComponentales", "m_strComponentonent", "m_arrCompales", "m_strComponentenses", "m_strComports"], "m_strPriorities": ["m_intPrefries", "m_strActivities", "m_strActivries", "m_StrPriority", "m_strComparifiers", "m_strPrioritives", "m_strMonities", "m_intPrioritions", "m_strMonitives", "m_StrPosity", "m_strComparities", "m_intPriorries", "m_intPriorities", "m_StrPriorities", "m_strPrefitions", "m_StrPrioritions", "m_intPrioritives", "m_strPositions", "m_strComparitions", "m_StrPositions", "m_strPriorries", "m_strActivitions", "m_intPrefitives", "m_strPrefries", "m_strPrefitives", "m_StrPosifiers", "m_strQualitions", "m_strActivitives", "m_strMonitions", "m_strComparity", "m_strPosity", "m_strMonries", "m_intPrefities", "m_strPosities", "m_strPriority", "m_strPriorifiers", "m_intPrefitions", "m_StrPosities", "m_strQuality", "m_strQualifiers", "m_strPosifiers", "m_strQualities", "m_StrPriorifiers", "m_strPrioritions", "m_strPrefities"]}}
{"id1": "17724879", "id2": "22022715", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    protected static final byte[] digest(String s) {\n        byte[] ret = null;\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(s.getBytes());\n            ret = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            System.err.println(\"no message digest algorithm available!\");\n            System.exit(1);\n        }\n        return ret;\n    }\n", "label": 1, "substitutes": {"getDigest": ["createDigest", "createdigHash", "createdigest", "getMDHash", "createDigests", "getMDest", "createDigHash", "getMDester", "getdigHash", "getSignest", "getMDests", "getDigester", "getdigest", "getdigester", "createdigests", "createdigester", "createDigester", "getDigests", "getDigHash", "getSignester", "getSignests", "getSignHash", "getdigests"], "attribute": ["att", "image", "client", "component", "attr", "element", "argument", "entry", "class", "object", "character", "instance", "reference", "layer", "route", "directory", "expression", "metadata", "ribute", "address", "Attribute", "property", "connection", "ident", "resource", "audio", "message", "pair", "operation", "manager", "value", "function", "prefix", "feature", "api", "set", "definition", "data", "type", "subject", "application", "document", "name", "node", "individual", "entity", "plugin", "variable", "uri", "event", "device", "config", "username"], "digestAlgorithm": ["digestalgebra", "digestalgorith", "digestALgo", "digestElger", "digestElgo", "digestALgebra", "digestALgorithm", "digESTAlger", "digestAlgebra", "digESTAlg", "digesterAlgebra", "digestElg", "digestalgorithm", "digestalger", "digestAlgo", "digesterAlgorith", "digestElgorithm", "digESTAlgo", "digestALgorith", "digestAlgorith", "digesterAlgorithm", "digESTAlgorithm", "digestAlger", "digestAlg", "digesterAlgo", "digestalgo", "digestalg"], "digest": [" digested", "Diguration", "Digtest", "signest", "labester", "longEST", "multiplest", "DigEST", "multiplEST", "signgest", "digger", "diggest", "labEST", " digtest", "longest", " digEST", "dger", "bigester", "Digest", "signger", " diguration", "biggest", "multiplester", "dgest", "labtest", "Digester", " digester", "dest", "digester", "multipluration", "digEST", "digtest", "bigger", "labest", "longested", "digested", "bigest", "diguration", "dester", "longester", "Digested", "signester"], "md": ["mm", "mac", "der", "mo", "sd", "m", "db", "kg", "my", "mad", "app", "ad", "po", "mn", "pd", "ht", "ng", "metadata", "arm", "mid", "id", "ui", "um", "module", "cd", "ma", "od", "rm", "editor", "mb", "amd", "nm", "cm", "df", "manager", "wd", "own", "ds", "bd", "mr", "sm", "doc", "dm", "pm", "mi", "nd", "mt", "MD", "mp", "di", "mc", "hd", "mag", "plugin", "d", "ml", "mod", "ld", "ms", "meta", "cmd", "dev", "dd", " MD", "cb"]}}
{"id1": "3514286", "id2": "7087108", "code1": "    public static String getHashedPassword(String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.update(password.getBytes());\n            BigInteger hashedInt = new BigInteger(1, digest.digest());\n            return String.format(\"%1$032X\", hashedInt);\n        } catch (NoSuchAlgorithmException nsae) {\n            System.err.println(nsae.getMessage());\n        }\n        return \"\";\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 0, "substitutes": {"getHashedPassword": ["getHashedpassword", "getHashingPassword", "getHashingHash", "getHhedPassword", "getHampedHash", "getHampedpassword", "getHampedPassword", "getMampedPass", "getMampedpassword", "getHashingPass", "getHhedPass", "getHashingpassword", "getHashedHash", "getMashedPassword", "getMampedPassword", "getHashedPass", "getMampedHash", "getHhedpassword", "getHampedPass", "getMashedpassword", "getMashedPass", "getMashedHash", "getHhedHash"], "password": ["account", "buffer", "words", "p", "email", "crypt", "pattern", "user", "input", "attribute", "sword", "cache", "phrase", "address", "padding", "Password", "code", "content", "message", "word", "out", "wd", "prefix", "pass", "confirmed", "wallet", "data", "token", "secret", "number", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "digest": ["hashester", " digested", "mdester", "mdend", "hashoder", " digoder", " digend", "digoder", "DigEST", "mdest", "dEST", " digests", "diggest", "diger", "digests", "Diger", " digEST", "mder", "digend", "Digest", "hashher", " diger", "dgest", "Digester", " digester", "hashest", "dest", "Digests", "Digoder", "digester", "dests", "digEST", "mdEST", "Digher", "Digend", " diggest", "mdested", "digher", "digested", "Diggest", "Digested", " digher"], "hashedInt": ["hhedint", "hryptedInt", "rhashedInt", "hhedInt", "haledLong", "hashObj", "hryptedint", "hashInteger", "rhashint", "hashedLong", "haledint", "hachedint", "hashedInteger", "rhashedint", "hachedInt", "hashInt", "hryptedInteger", "haledInt", "haledINT", "hhedInteger", "hachedINT", "rhashedInteger", "HhedLong", "Hhedint", "rhashObj", "hashedObj", "HashedINT", "hashedINT", "Hashedint", "rhashedObj", "hhedLong", "hhedObj", "HhedInt", "hryptedObj", "HashedInt", "HashedLong", "HhedINT", "hashint", "hashedint", "hachedLong", "rhashInteger", "rhashInt", "hhedINT"]}}
{"id1": "3756429", "id2": "4798332", "code1": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "code2": "    public static String SHA(String source) {\n        logger.info(source);\n        String result = null;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA\");\n            digest.update(source.getBytes());\n            byte[] bytes = digest.digest();\n            result = EncodeUtils.hexEncode(bytes);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        logger.info(result);\n        return result;\n    }\n", "label": 1, "substitutes": {"scramble": [" scrambling", "scambling", " screambling", "screambles", "screamble", "scrambles", "scamble", "scrouble", " scrambler", "scroubling", "scroubler", "scambles", " screamble", "screambler", "scambler", " scrambles", " screambles", "screambling", " screambler", "scroubles", "scrambler", "scrambling"], "text": ["image", "in", "buffer", "bytes", "obj", "output", "class", "object", "pattern", "username", "input", "Text", "code", "content", "path", "message", "TEXT", "editor", "word", "ext", "out", "str", "binary", "letter", "data", "struct", "secret", "test", "token", "name", "password", "body", "string", "texture", "source", "config", "txt"], "md": ["mm", "mac", "db", "ind", "m", "grad", "mad", "ad", "bb", "mn", "pd", "metadata", "um", "cd", "od", "ma", "bm", "rm", "mb", "cm", "amd", "df", "wd", "dh", "mand", "bd", "gd", "f", "sm", "dm", "pm", "mt", "MD", "mp", "di", "mc", "mod", "hd", "vd", "d", "mag", "rpm", "am", "ms", " Md", "cmd", "dd", " MD", "hm"], "sb": ["db", "su", "bp", "buffer", "sync", "bf", "src", "ab", "lb", "bs", "s", "bt", "SB", "ib", "bb", "ls", "usb", "sa", "sf", "sg", "bc", "rb", "fb", "bm", "kb", "mb", "ob", "gb", "ssl", "pb", "bh", "bd", "sr", "eb", "buf", "binary", "wb", " SB", "BB", "bsp", "xb", "obb", " eb", "nb", "cb", "erb"], "b": ["db", "buffer", "bytes", "p", "obj", "bf", "bis", "br", "block", "i", "ab", "object", "bs", "bb", "boot", "rb", "a", "fb", "beta", "be", "mb", "ob", "pb", "B", "bd", "eb", "f", "binary", "base", "bot", "l", "bin", "d", "body", "nb", "orb", "machine", "cb", "c"]}}
{"id1": "19113613", "id2": "942693", "code1": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "process", "clone", "ssh", "p", "sync", "upload", "save", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "archive", " cp", "replace", "Cop", "share", "clip", "rm", "cop", "change", "opy", "update", "zip", "download", "type", "put", "paste", "split", "create", "move"], "in": ["image", "get", "client", "pin", "ic", "n", "inn", "i", "old", "init", "cin", "input", "thin", "id", "on", "sin", "din", "diff", "lin", "connection", "a", "inner", "index", "work", "ini", "kin", "part", "inside", "min", "f", "url", "this", "base", "login", "update", "data", "token", "ins", "name", "bin", "In", "plugin", "reader", "IN", "as", "again", "project", "win", "config", "c", "inc"], "out": ["Out", "image", "client", "self", "p", "obj", "one", "off", "n", "block", "up", "output", "object", "init", "app", "input", "user", "version", "parent", "ex", "page", "cache", "option", "outside", "conn", "group", "connection", "ext", "path", "resource", "io", "line", "work", "part", "root", "at", "x", "dot", "o", "null", "exec", "base", "goal", "no", "this", "err", "with", "vert", "b", "v", "other", "net", "call", "name", "bin", "external", "again", "remote", "project", "point", "outs", "outer", "OUT", "c", "inc"], "source": ["position", "component", "service", "size", "src", "ce", "class", "view", "use", "proxy", "scope", "internal", "reference", "parent", "route", "attribute", "id", "sin", "origin", "from", "family", "format", "resource", "direction", "dest", "Source", "secure", "iter", "url", "prefix", "alt", "unit", "base", "feature", "missing", "pe", "type", "SOURCE", "subject", "secret", "status", "force", "name", "site", "project", "uri", "ource", "username"], "target": ["next", "template", "detail", "service", "component", "src", "master", "output", "pattern", "host", "wrong", "reference", "cat", "parent", "route", "address", "origin", "home", "tail", "alias", "format", "path", "resource", "top", "direction", "value", "dest", "root", "url", "prefix", "alt", "null", "base", "goal", "Target", "token", "force", "name", "site", "arget", "project", "point", "about", "current", "config"], "files": ["items", "children", "models", "assets", "s", "sections", "cells", "ls", "links", "features", "lines", "keys", "objects", "obs", "docs", "jobs", "images", "resources", "results", "apps", "tools", "iles", "ions", "classes", "f", "Files", "pages", "fs", "data", "blocks", "users", "groups", "ins", "names", "ports", "filename", "flows", "plugins"], "file": ["entry", "object", "el", "feed", "load", "layer", "future", "e", "parent", "id", "page", "directory", "File", "per", "child", "fe", "path", "resource", "fp", "single", " File", "line", "FILE", "function", "ile", "part", "dir", "f", "url", "letter", "binary", "lib", "base", "unit", "data", "b", "local", "live", "it", "name", "entity", "l", "string", "le", "folder", "item", "uri", "current", "filename"], "inCh": ["outCH", "INChan", " inCH", "outChan", " inChan", " inChannel", "inCH", "INChannel", "INCh", "InChan", "inChan", " inch", "outChannel", "inChannel", "InChannel", "Inch", "outch", "inch", "INCH", "InCH", "InCh"], "outCh": ["OutCH", "outCH", "OutChan", "outChan", "OutChannel", "OutCh", "outputChan", " outch", "outputCH", "inCH", "outputCh", " outChannel", "inChan", "outChannel", "inChannel", "outputch", "outch", " outCH", "Outch", "inch"]}}
{"id1": "22993368", "id2": "14691829", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static String getMD5Hash(String in) {\n        StringBuffer result = new StringBuffer(32);\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(in.getBytes());\n            Formatter f = new Formatter(result);\n            for (byte b : md5.digest()) {\n                f.format(\"%02x\", b);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            ex.printStackTrace();\n        }\n        return result.toString();\n    }\n", "label": 0, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "1698200", "id2": "23402240", "code1": "    public static void loginBitShare() throws Exception {\n        HttpParams params = new BasicHttpParams();\n        params.setParameter(\"http.useragent\", \"Mozilla/5.0 (Windows; U; Windows NT 6.1; en-GB; rv:1.9.2) Gecko/20100115 Firefox/3.6\");\n        DefaultHttpClient httpclient = new DefaultHttpClient(params);\n        System.out.println(\"Trying to log in to bitshare.com\");\n        HttpPost httppost = new HttpPost(\"http://bitshare.com/login.html\");\n        List<NameValuePair> formparams = new ArrayList<NameValuePair>();\n        formparams.add(new BasicNameValuePair(\"user\", \"007007dinesh\"));\n        formparams.add(new BasicNameValuePair(\"password\", \"\"));\n        formparams.add(new BasicNameValuePair(\"submit\", \"Login\"));\n        UrlEncodedFormEntity entity = new UrlEncodedFormEntity(formparams, \"UTF-8\");\n        httppost.setEntity(entity);\n        HttpResponse httpresponse = httpclient.execute(httppost);\n        Iterator<Cookie> it = httpclient.getCookieStore().getCookies().iterator();\n        Cookie escookie = null;\n        while (it.hasNext()) {\n            escookie = it.next();\n            System.out.println(escookie.getName() + \" = \" + escookie.getValue());\n        }\n        System.out.println(EntityUtils.toString(httpresponse.getEntity()));\n    }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 0, "substitutes": {"loginBitShare": ["loginbitShare", "loginBitRay", "loginBitshare", " loginBitShares", "loginBandRay", "loginBandShare", "loginBandShares", "loginbitRay", "loginBitShares", "loginbitshare", "loginbitShares", "loginBandshare", " loginBitRay", " loginBitshare"], "params": ["mm", "ip", "Par", "details", "words", "p", "ctx", "bis", "par", "parse", "ns", "ls", "page", "cache", "properties", "server", "json", "phrase", "ams", "http", "php", "radius", "param", "lp", "posts", "reports", "services", "results", "eters", "ssl", "manager", "ds", "options", "pi", "Parameters", "api", "base", "license", "pm", "eps", "fps", "ops", "settings", "vs", "utils", "pro", "parts", "ps", "parser", "rules", "cmp", "photos", "config"], "httpclient": ["ttpserver", "ttphttp", " httpserver", " httpconnection", "httpsconnection", "webserver", "httpconnection", "httpsClient", "webhttp", " httpClient", " httpapi", "httpapi", "htmlclient", "httpserver", "webClient", "phpapi", "ttpClient", "phpclient", "httpClient", "httphttp", "ttpclient", " httphttp", "httpsclient", "webclient", "htmlresponse", "httpsresponse", "phpconnection", "htmlconnection", "htmlClient", "phpClient", "httpsapi"], "httppost": ["httphort", "httpport", "httport", "httplost", "httphost", "httppeoster", " httprost", "httppsoint", "httpood", " httpoint", "httplort", "httposter", "httphoster", "httppeoint", "httpost", " httppeoster", "httphpost", " httplost", "httpoint", " httppeost", " httploster", " httpport", "httcpposter", " httppoint", " httplpost", "httpperost", "httpposter", "httcppoint", "httcppood", "httppsrost", "httppeood", "httppeost", "httppood", " httppeood", "httplpost", "httpppost", " httpposter", " httposter", "httppoint", "httpprost", "httppsoster", "httprost", " httppood", " httppeoint", " httpppost", "httcppost", " httplort", "httppsost", "httploster", " httpost", " httpprost"], "formparams": ["formparam", " formsettings", " formnames", " formams", "fparam", "fams", "formParameters", " formauthors", " formParameters", "FORMams", "Formparams", "formedams", "feedparam", "handParameters", "Formnames", "FORMblock", "formauthors", "Formsettings", "headams", "feedsettings", "handams", "headnames", "Formparam", "fparams", "formams", "Formargs", " formblock", "formedauthors", "formblock", "headparam", "handargs", "formnames", " formparam", "handparams", "FORMparam", "formsettings", " formargs", "formedparams", "formedblock", "FORMparams", "fauthors", "headparams", "FormParameters", "feedparams", "formargs", "feedams", "formedparam", "Formams"], "entity": ["db", "service", "email", "query", "html", "entry", "form", "output", "object", "el", "ities", "e", "environment", "page", "server", "json", "result", " Entity", "connection", "content", "response", "resource", "Entity", "xml", " entities", "translation", "file", "url", "api", "model", "data", "type", "ent", "article", "collection", "document", "et", "body", "event", "person", "ec"], "httpresponse": ["phpresponse", "Httpresponse", " httpserver", "htmlserver", "hyperserver", "httpresp", "htmlclient", "httpserver", "Httpserver", "phpresp", "Httpresp", " httpresp", "htmlresponse", "hyperclient", "phpserver", "hyperresponse"], "it": ["rit", "ind", "in", "ip", "the", "itted", "sort", "ic", "ul", "entry", "i", "you", "ort", "init", "its", "slice", "ist", "or", "pit", " It", "index", "not", "mit", "op", "ite", "ati", "lit", "edit", "which", "end", "start", "st", "set", "iz", "ait", "ins", "IT", "ct", "l", "I", "si", "and", "iv", "cont", "iti", "quit", "It"], "escookie": ["descaddy", " enaddy", "Escerve", "escake", "estaddy", "escerve", "estookie", "esccookie", "asccel", "escale", "ascerve", " enoding", "ecaddy", "descale", "Escinel", "cookie", "sccel", "escenter", "eccookie", "esccel", "escinel", "estenter", "cerve", "estcel", "descake", "Esccel", "ascale", "descookie", "ecoding", "escaddy", "scale", "descenter", " encookie", "desccel", "ecookie", " escaddy", "escoding", "scake", "cinel", " enookie", "Escookie", "ascookie", "Escenter", "ascake", " escoding", "scookie", "ascinel", "Escaddy", "caddy", "ascaddy", " esccookie"]}}
{"id1": "8064604", "id2": "6036012", "code1": "    public void init(ConnectionManager mgr, Hashtable cfg, Socket sock) throws RemoteException {\n        _cman = mgr;\n        _sock = sock;\n        for (int i = 0; i < 256; i++) {\n            String key = Integer.toHexString(i);\n            if (key.length() < 2) key = \"0\" + key;\n            availcmd.push(key);\n            commands.put(key, null);\n        }\n        try {\n            _sout = new PrintWriter(_sock.getOutputStream(), true);\n            _sinp = new BufferedReader(new InputStreamReader(_sock.getInputStream()));\n            String seed = \"\";\n            Random rand = new Random();\n            for (int i = 0; i < 16; i++) {\n                String hex = Integer.toHexString(rand.nextInt(256));\n                if (hex.length() < 2) hex = \"0\" + hex;\n                seed += hex.substring(hex.length() - 2);\n            }\n            String pass = _mpsw + seed + _spsw;\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            String hash = hash2hex(md5.digest()).toLowerCase();\n            String banner = \"INIT \" + \"servername\" + \" \" + hash + \" \" + seed;\n            sendLine(banner);\n            String txt = readLine(5);\n            if (txt == null) {\n                throw new IOException(\"Slave did not send banner !!\");\n            }\n            String sname = \"\";\n            String spass = \"\";\n            String sseed = \"\";\n            try {\n                String[] items = txt.split(\" \");\n                sname = items[1].trim();\n                spass = items[2].trim();\n                sseed = items[3].trim();\n            } catch (Exception e) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            pass = _spsw + sseed + _mpsw;\n            md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(pass.getBytes());\n            hash = hash2hex(md5.digest()).toLowerCase();\n            if (!sname.equals(_name)) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL Unknown\", _sock);\n            }\n            if (!spass.toLowerCase().equals(hash.toLowerCase())) {\n                AsyncSlaveListener.invalidSlave(\"INITFAIL BadKey\", _sock);\n            }\n            _cman.getSlaveManager().addSlave(_name, this, getSlaveStatus(), -1);\n            start();\n        } catch (IOException e) {\n            if (e instanceof ConnectIOException && e.getCause() instanceof EOFException) {\n                logger.info(\"Check slaves.xml on the master that you are allowed to connect.\");\n            }\n            logger.info(\"IOException: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e1) {\n            }\n        } catch (Exception e) {\n            logger.warn(\"Exception: \" + e.toString());\n            try {\n                sock.close();\n            } catch (Exception e2) {\n            }\n        }\n        System.gc();\n    }\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"init": ["client", "transfer", "load", "install", "construct", "cli", "Init", "open", "info", "boot", "connection", "sleep", "build", "start", "activate", "exec", "set", "update", "reset", "it", "setup", "create", "config", "launch", "initial"], "mgr": ["mtr", "mbr", " mrr", "amigr", "pigr", "ambr", "ctr", "amrr", "cr", "mrr", " marr", "carr", "migr", " mbr", "Marr", "pgr", "pbr", "mr", " mtr", " migr", " mr", "Mtr", "Mr", "marr", "amgr", "cgr", "Mgr", "prr"], "cfg": ["db", "g", "gen", "chain", "map", " config", "gp", "cf", "cache", " cf", "bm", "gate", " configuration", "Conf", "conf", "file", "Hash", "config", " ssh", "MC", " chain", " conf", "Msg", " cache", "mc", "password", "mem", " img", "cb"], "sock": ["socket", "opensib", " socks", "opensocket", " socket", " sink", "Socket", "Sock", "sib", "opensock", "gesink", "sink", "gesocks", "opensocks", " sib", "Sink", "gesocket", "socks", "gesock", "Sib", "Socks"], "_cman": ["_mcmn", "_mman", " _mcgr", "_ggr", "_gmn", "_cfg", " _cfg", "_gman", "_mgr", " _mcman", " _cmn", "_cmn", " _cgr", "_mcgr", "_mfg", " _mcmn", "_gfg", "_mmn", " _mcfg", "_mcman", "_cgr", "_mcfg"], "_sock": ["_jsocket", " _svc", "_src", "_svc", "_unsock", "_jsocks", "longnsockets", "_asock", "_dock", "_csock", "_sort", "_Sock", "longsock", "_nsock", "_asocks", "_nsockets", "longnsrc", "_jsock", "_Socket", "_unsocks", "_dort", "_serve", "_csrc", "_Svc", "_jsdk", "_sdk", "_bocks", "longsockets", "_docket", "_unsocket", "_opensock", "longnsock", "_sockets", "_Socks", " _serve", "_socks", "_Serve", "_bort", "_csockets", "_asockets", "longsocks", "_opensort", "_csocks", "_bocket", "_opensvc", "_Sdk", "_nsocks", "_docks", "longsrc", "_asrc", "_opensocket", "_opensocks", "_nsrc", "_openserve", "_unsdk", "_socket", " _socks", "_bock", "longnsocks"], "i": ["r", "ai", "ip", "in", "m", "h", "j", "p", "ie", "my", "n", "is", "q", "s", "multi", "ix", "slice", "e", "phi", "id", "ci", "gi", "ui", "info", "inner", "li", "index", "ii", "io", "iu", "ini", "value", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "l", "hi", "d", "si", "chi", "qi", "field", "uri", "I"], "key": ["query", "fee", "entry", "trust", "section", "cy", "change", "value", "root", "str", "link", "prefix", "base", "search", "text", "name", "string", "kh", "length", "ip", "wire", "ask", "ck", "cert", "label", "patch", "json", "rule", "check", "index", "Key", "fix", "lock", "KEY", "mac", "q", "order", "id", "phrase", "sum", "pick", "op", "pair", "row", "k", "number", "point", "shift", "sign", "kid", "source", "ace", "match", "ki", "ie", "mix", "nice", "code", "connection", "data", "type", "temp", "char", "token", "secret", "qi", "field", "pid"], "_sout": ["_Sin", "_sbout", "_sOut", "_sio", "_seout", "_sein", "_Sout", "_seOut", "_SOut", "_Sio", "_sbio", "_seio", "_sbin", "_sin", "_sbOut"], "_sinp": ["_srpc", "_srb", "_disp", "_sinpc", "_siner", "_srer", "_disb", "_diser", "_inpc", "_inp", "_dispc", "_iner", "_srp", "_sinb", "_inb"], "seed": ["pad", "ruby", "shape", "host", "pattern", "dd", "feed", "theme", "slice", "input", "slave", "serial", "delay", "id", "json", "cookie", "address", "grain", "source", "sum", "finger", "pick", "index", "black", "sleep", "digit", "row", "root", "sql", "zip", "scale", "data", "shadow", "char", "secret", "token", "test", "prime", "sha", "name", "driver", "password", "string", "random", "sample", "parser", "sudo", "shift", "kh", "folder", "kid", "eed", "username"], "rand": ["r", "der", "next", "ind", "max", "go", "grad", "rc", "gram", "chain", "user", "cr", "id", "ng", "Rand", "reg", "dr", "pick", "rh", "rr", "rar", "dist", "who", "start", "min", "re", "range", "nd", "bot", "draw", "round", "random", "sample", " random", "roll", "dev", "gen", "win", "NG", "bird"], "hex": ["pad", "quant", "chain", "serial", "ex", "wh", "closure", "raw", "box", "x", "iter", "letter", "shadow", "text", "string", "cmp", "kh", "length", "ip", "batch", "view", "cube", "json", "check", "loc", "index", "num", "rh", "hess", "buff", "pack", "tri", "lit", "pex", "scale", "div", "alph", "lock", "cross", "alpha", "form", "pattern", "id", "sex", "cf", "cookie", "sum", "row", "ch", "rex", "ticket", "transform", "auth", "shift", "ph", "mix", "code", "exp", "digit", "oct", "zip", "temp", "char", "token", "secret", "sha", "bin", "loop"], "pass": ["process", "ress", "service", "access", "worker", "flash", "oss", "read", "feed", "ass", "parse", "route", "Pass", "fail", "run", "handle", "code", "Password", "strip", "rss", "path", "report", "line", "proc", "step", "mail", "post", "oct", "prefix", "session", "login", "press", "secret", "test", "task", "allow", "ride", "skip", "auth", "password", "ss", "push", "fix", "act", "gen", "sign", "lock", "PASS", "cross"], "md5": ["mand3", " MD\n", " md512", "MD2", "md4", "md7", "MD\t", "ma2", " md2", "mand5", "MD3", "MD5", "sha5", " md85", "mand2", "sha2", "md3", "md2", "md85", "MDody", " md3", " md7", " md\n", "mandody", " md4", "md\n", "sha7", "sha4", " MD\t", "ma4", "MD512", "MD85", "md512", "md\t", "mdody", "ma5", "ma85", "sha512", "MD\n", " mdody", "MD4", "MD7", " md\t", "sha3"], "hash": ["ha", "mac", "db", "h", "dig", "html", "ash", "block", "host", "version", "id", "cache", "code", "sum", "rh", "build", "url", "alt", "base", "her", "secret", "sha", "text", "auth", "password", "string", "header", "addr", "lock", "kh", "ruby", "hed"], "banner": ["planners", "binn", "banorer", "warnler", "binorer", "blueler", "binner", "Banker", "Banning", "blueker", "Banler", "banler", "plann", "ironnet", "planning", "ironner", "Banorer", "warnker", "Bannel", "binning", "warnnel", "annnet", "ironning", "Bann", "planorer", "annning", "banning", "plannet", "planner", "Banner", "bannel", "bannet", "ironners", "annner", "bann", "banners", "bluenel", "annners", "warnner", "banker", "bluener"], "txt": ["pdf", "details", "bytes", "email", "xt", "tx", "obj", "vt", "ff", "git", "notes", "tmp", "Text", "tin", "thin", "rx", "json", "lines", "utt", " text", "info", "diff", "rss", "fb", "ext", "TEXT", "buff", "xml", "img", "qt", "wd", "file", "str", "config", "htm", "gold", "buf", "xxx", "zip", "data", "flat", "struct", "test", "kt", "bot", "text", "pty", "rpm", "hea", "elt", "js", "parser", "tty", "gz", "np", "cb"], "sname": ["nsnames", "asnamed", "sdata", "asname", "esName", "snames", " sName", "snamed", "esnamed", "vesnames", " snamed", "vesnamed", " sdata", "asdata", "vesname", "sName", " snames", "nsnamed", "nsname", "nsdata", "esnames", "asnames", "esname", "vesName"], "spass": ["Sposs", "aspad", "spasses", "slill", "SPasses", "aspass", "Spill", "splass", "sposs", "espash", "spill", "splasses", "aspash", "sloss", "espasses", "aspasses", "Spasses", "slass", "SPill", "spad", "splash", "splad", "SPass", "SPoss", "espass", "spash", "Spass", "espad", "slasses"], "sseed": ["gsgrain", "gseed", "symeed", "ssseed", "Sseed", " spassword", "symkey", "stoken", "psroot", "ssslave", "dseed", "sgrain", "symseed", "submitentry", "sroot", "ssecret", "symgrain", "skey", "Skey", "dpassword", "ssroot", "pssecret", "gsseed", "pslave", "psseed", "sslave", "submitseed", "gskey", " stoken", "dentry", "pseed", "Seed", "proot", " sentry", "submittoken", "dtoken", "psecret", "submitpassword", "psslave", "spassword", "sentry", "Sgrain", "sssecret"], "items": ["locks", "cats", "bytes", "styles", "models", "qs", "files", "loads", "phones", "units", "boxes", "cells", "ips", "events", "projects", "links", "lines", "keys", "objects", "rooms", "ants", "owners", "params", "images", "posts", "xml", "results", "members", "apps", "Items", "pieces", "abs", "bits", "pages", "opens", "articles", "data", "values", "ends", "pins", "groups", "lists", "orders", "rows", "ops", "ids", "names", "js", "parts", "item", "photos", "flows", "plugins"]}}
{"id1": "19912848", "id2": "7087108", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "2518655", "id2": "20920051", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fnIn", " fnEx", "fnOUT", " fnOutput", "FNOutput", " fnFile", "fpOut", " fnIn", "fnOutput", "fpEx", "FNEx", "lsOutput", "fpIn", "lsOut", "fpOutput", "fpFile", "fnEx", "lsFile", "fnFile", "fpOUT", "FNOut", " fnOUT", "FNIn", "lsOUT"], "writer": ["r", "wire", "buffer", "worker", "entry", "key", "output", "socket", "fd", "write", "handler", "server", "Writer", "per", "ler", "writers", "usher", "a", "editor", "inner", "war", "word", "out", "work", "wr", "file", "director", "riter", "winner", "builder", "temp", "wa", "loader", "er", "w", "nw", "driver", "writ", "reader", "parser", "outer", "ws", "writing", "widget", "layer", "walker"], "i": ["ai", "ip", "m", "h", "p", "j", "n", "ie", "eni", "key", "s", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "ui", "strength", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "bi", "part", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "type", "u", "b", "v", "ji", "oi", "mi", "di", "hi", "si", "chi", "qi", "uri", "I", "c"], "fInput": ["fileinput", "sfSource", "fileOutput", "fileFormat", "fFormat", "fSource", "fileInput", "sfInput", "sfOutput", " finput", "fOutput", "sfFormat", " fFormat", " fSource", "sfinput", "finput", "fileSource", " fOutput"], "in": ["ner", "pin", "n", "inn", "isin", "gin", "socket", "s", "init", "cin", "input", "version", "ln", "id", "sin", "din", "conn", "inas", "lin", "connection", "inner", "vin", "nin", "out", "line", "ini", "kin", "rin", "reading", "inside", "min", "f", "login", "data", "b", "ins", "bin", "In", "reader", "IN", "again", "scan", "win", "c", "inc"]}}
{"id1": "23246123", "id2": "18202328", "code1": "    protected Control createDialogArea(Composite parent) {\n        Composite composite = (Composite) super.createDialogArea(parent);\n        setTitle(DialogsMessages.getString(\"LicenseDialog.Caption\"));\n        setMessage(DialogsMessages.getString(\"LicenseDialog.Explanation\"));\n        Composite content = new Composite(composite, SWT.NONE);\n        content.setLayoutData(new GridData(GridData.FILL_BOTH));\n        final int ncol = 1;\n        GridLayout layout = new GridLayout(1, false);\n        layout.numColumns = ncol;\n        content.setLayout(layout);\n        Browser browser = null;\n        Text text = null;\n        try {\n            browser = new Browser(content, SWT.NONE);\n            browser.setLayoutData(new GridData(GridData.FILL_BOTH));\n        } catch (Throwable t) {\n            text = new Text(content, SWT.MULTI | SWT.WRAP | SWT.VERTICAL);\n            text.setLayoutData(new GridData(GridData.FILL_BOTH));\n        }\n        URL url = PalobrowserPlugin.getDefault().getBundle().getResource(browser != null ? \"license.html\" : \"license.txt\");\n        InputStream in = null;\n        BufferedReader r = null;\n        StringBuffer sb = new StringBuffer();\n        try {\n            in = url.openStream();\n            r = new BufferedReader(new InputStreamReader(in, \"ISO-8859-1\"));\n            String line;\n            while ((line = r.readLine()) != null) sb.append(line).append(\"\\r\\n\");\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (r != null) {\n                try {\n                    r.close();\n                } catch (IOException e) {\n                }\n            }\n            if (in != null) {\n                try {\n                    in.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        if (browser != null) browser.setText(sb.toString()); else text.setText(sb.toString());\n        return composite;\n    }\n", "code2": "    public void register(MinecraftSession session, String username, String verificationKey) {\n        if (Configuration.getConfiguration().isVerifyingNames()) {\n            long salt = HeartbeatManager.getHeartbeatManager().getSalt();\n            String hash = new StringBuilder().append(String.valueOf(salt)).append(username).toString();\n            MessageDigest digest;\n            try {\n                digest = MessageDigest.getInstance(\"MD5\");\n            } catch (NoSuchAlgorithmException e) {\n                throw new RuntimeException(\"No MD5 algorithm!\");\n            }\n            digest.update(hash.getBytes());\n            if (!verificationKey.equals(new BigInteger(1, digest.digest()).toString(16))) {\n                session.getActionSender().sendLoginFailure(\"Illegal name.\");\n                return;\n            }\n        }\n        char[] nameChars = username.toCharArray();\n        for (char nameChar : nameChars) {\n            if (nameChar < ' ' || nameChar > '\\177') {\n                session.getActionSender().sendLoginFailure(\"Invalid name!\");\n                return;\n            }\n        }\n        for (Player p : playerList.getPlayers()) {\n            if (p.getName().equalsIgnoreCase(username)) {\n                p.getSession().getActionSender().sendLoginFailure(\"Logged in from another computer.\");\n                break;\n            }\n        }\n        final Player player = new Player(session, username);\n        if (!playerList.add(player)) {\n            player.getSession().getActionSender().sendLoginFailure(\"Too many players online!\");\n            return;\n        }\n        session.setPlayer(player);\n        final Configuration c = Configuration.getConfiguration();\n        session.getActionSender().sendLoginResponse(Constants.PROTOCOL_VERSION, c.getName(), c.getMessage(), false);\n        LevelGzipper.getLevelGzipper().gzipLevel(session);\n    }\n", "label": 0, "substitutes": {"createDialogArea": [" createDialogarea", "createHelparea", "createEditorArea", "createButtonGroup", "createDialogarea", "createControlPanel", "createDialogPanel", "createMessagePanel", "createEditorarea", "createMessagearea", " createButtonGroup", " createButtonArea", "createButtonarea", "createControlarea", " createButtonarea", " createHelpArea", "createDialogGroup", " createDialogGroup", "createControlArea", "createHelpPanel", " createHelparea", "createHelpGroup", "createEditorGroup", "createHelpArea", "createMessageArea", " createHelpPanel", "createButtonArea", " createDialogPanel"], "parent": ["image", "client", "component", "p", "ctx", "g", " scene", "class", "host", "object", "context", "instance", "section", "page", "port", "child", "connection", "clip", "container", "message", "resource", "Parent", " child", " sup", "sup", "root", "this", "null", "panel", "wrapper", "builder", "comp", "cl", "parents", "document", "parser", "menu", "current", "self", "c"], "composite": ["comppositive", "Compositing", "comPOSites", "Complexite", "compositor", "compositionite", "compositionited", "compositing", "compositioniting", "complexite", "Composites", "complexitive", "comppositor", "compositionites", "comppositable", "comppositionite", "Complexites", "comppositionitor", "comppositionites", "composited", "compositionitive", "comvalite", "comppositionited", "compositionitor", "compositable", "comositable", "comosites", "compposited", "composites", "comppositionitive", "compposite", "compositive", "Compositable", "compositionitable", "compposites", "comosited", "comPOSiting", "comvalitor", "Complexiting", "comosite", "complexitable", "comvalitive", "Composite", "comPOSitable", "comPOSite", "Complexitable", "comPOSited", "comvalites", "complexites", "comppositionitable", "complexiting", "complexitor"], "content": ["image", "client", "component", "html", "Content", "host", "output", "cell", "comment", "app", "context", "load", "object", "feed", "version", "title", "copy", "section", "page", "server", "json", "complete", "address", "conn", "child", "source", "format", "media", "container", "connection", "report", "message", "resource", "cm", "code", "xml", "scroll", "file", "exec", "model", "control", "create", "loader", "activity", "application", "document", "ez", "plugin", "header", "folder", "cms", "cont", "layer", "config"], "ncol": ["numcolumn", "Ncolumn", "ncolumn", "numCol", "nbCol", "numrow", " ncolumn", "nCol", "nbcolumn", "Ncol", "nbrow", " nCol", "NCol", " nblock", "Nblock", "numcol", " nrow", "pcolumn", "nbcol", "pblock", "nrow", "pCol", "nblock", "pcol"], "layout": ["font", "position", "image", "where", "design", "shape", " Layout", "Layout", "alpha", "block", "widget", "entry", "flow", "join", "view", "feed", "section", "lc", "address", "ui", "group", "board", "padding", "container", "location", "xml", "closure", "translation", "scroll", "build", "edit", "config", "grid", "base", "model", "data", "scale", "control", "inline", "zip", "shadow", "flat", "offset", "split", "draw", "figure", "l", "mount", " layouts", "follow", "nl", "list", "lock", "nav", "holder", "layer", "lay"], "numColumns": ["numColn", "numControles", "numColumnn", "numColows", "numcolumnn", "nbcolumnn", "nbColumnes", "nbcolumns", "nbColumns", "numControln", "numColumnows", "numcolumnows", "nbcolumnows", "nbColumnows", "numcolumns", "numcolumnes", "numColes", "nbColumnn", "numColumnes", "nbcolumnes", "numControlows", "numCols", "numControls"], "browser": ["image", "iframe", "client", "design", "flash", "br", "google", "html", "river", "chrome", "fire", "fox", "host", "comment", "feed", "Browser", "roller", "theme", "proxy", "ger", "page", "css", "server", "coll", "cookie", "open", "agent", "ver", "http", "editor", "graph", "report", "io", "ssl", "img", "manager", "box", "book", "root", "sim", "binary", "lib", "feature", "platform", "session", "vert", "loader", "shadow", "bar", "runner", "test", "bot", "cart", "driver", "plugin", "finder", "facebook", "js", "front", "remote", "web", "uri", "window", "jar", "nav", "mobile", "config", "webkit"], "text": ["font", "image", "pdf", "client", "writer", "service", "term", "element", " Text", "entry", "off", "label", "output", "form", "object", "comment", "feed", "context", "Text", "title", "user", "input", "ut", "port", "info", "connection", "format", "inner", "editor", "message", "path", "TEXT", "ext", "report", "desc", "str", "abs", "letter", "binary", "unit", "data", "vert", "struct", "test", "it", "atter", "name", "driver", "plugin", "string", "source", "config", "select", "txt"], "url": ["lr", "image", "service", "sl", "host", "feed", "user", "id", "page", "server", "address", "bel", "open", "connection", "http", "URL", "resource", "path", "ref", "pull", "io", "ssl", "file", "f", "Url", "api", "base", "zip", "download", "gl", "rel", "l", "string", "web", "ur", "uri", "re", "source", "config", "www"], "in": ["image", "fr", "p", "pin", "ic", "br", "inn", "gin", "stream", "i", "is", "rc", "s", "el", "init", "input", "on", "arin", "din", "conn", "lin", "dr", "or", "rb", "a", "inner", "resource", "nin", "xml", "out", "rin", "rec", "ini", "str", "x", "min", "f", "o", "serv", "pass", "login", "data", "ri", "err", "b", "er", "w", "it", "ins", "l", "In", "ar", "bin", "reader", "IN", "d", "again", "re", "c", "inc"], "r": ["lr", "gr", "fr", "m", "h", "p", "ner", "br", "rl", "i", "rc", "ro", "rs", "rx", "cr", "or", "ru", "dr", "rb", "right", "rss", "rh", "ir", "rr", "out", "rar", "nr", "hr", "sr", "rw", "f", "mr", "o", "rf", "ri", "err", "b", "rt", "er", "rel", "rob", "kr", "vr", "l", "res", "rg", "ar", "reader", "d", "ur", "R", "re", "c", "pr"], "sb": ["lr", "db", "abb", "bp", "buffer", "bf", "src", "ab", "lb", "bs", "s", "erb", "SB", "ib", "bb", "ls", "usb", "sa", "sn", "sf", "sg", "bc", "rb", "fb", "bm", "kb", "lp", "mb", "ob", "library", "gb", "ssl", "bj", "pb", "bh", "abs", "sr", "storage", "eb", "buf", "binary", "wb", "sm", " SB", "b", "bsp", "xb", "obb", "si", "nl", "lab", "sth", "sv", "ruby", "cb", "rob", "sp"], "line": ["ne", "sl", "obj", "n", "lf", "entry", "block", "i", "key", "cell", "object", "comment", "el", "character", "id", "page", "lc", "cle", "lines", "Line", "lin", "code", "li", "message", "se", "row", "str", "part", "ge", "end", "f", "col", "letter", "pass", "base", "inline", "data", "pe", "b", "char", "split", "LINE", "cl", "record", "name", "l", "stroke", "string", "header", "nl", "le", "source"], "e": ["error", "ne", "de", "p", "one", "oe", "ie", "ue", "ce", "i", "ee", "ze", "es", "fe", "or", "ef", "ite", "ve", "be", "se", "esi", "E", "ale", "exc", "ge", "en", "f", "ception", "ke", "o", "ev", "err", "pe", "er", "ele", "je", "me", "d", "ae", "ise", "le", "te", "ime", "ea", "ec"]}}
{"id1": "21821404", "id2": "5299276", "code1": "    public static String getWebPage(URL urlObj) {\n        try {\n            String content = \"\";\n            InputStreamReader is = new InputStreamReader(urlObj.openStream());\n            BufferedReader reader = new BufferedReader(is);\n            String line;\n            while ((line = reader.readLine()) != null) {\n                content += line;\n            }\n            return content;\n        } catch (IOException e) {\n            throw new Error(\"The page \" + dbg.quote(urlObj.toString()) + \"could not be retrieved.\" + \"\\nThis is could be caused by a number of things:\" + \"\\n\" + \"\\n  - the computer hosting the web page you want is down, or has returned an error\" + \"\\n  - your computer does not have Internet access\" + \"\\n  - the heat death of the universe has occurred, taking down all web servers with it\");\n        }\n    }\n", "code2": "    public void execute(File sourceFile, File destinationFile, String conversionType, Properties java2HtmlConfig) {\n        FileReader reader = null;\n        Writer writer = null;\n        try {\n            reader = new FileReader(sourceFile);\n            logger.info(\"Using source file: \" + trimPath(userDir, sourceFile));\n            if (!destinationFile.getParentFile().exists()) {\n                createDirectory(destinationFile.getParentFile());\n            }\n            writer = new FileWriter(destinationFile);\n            logger.info(\"Destination file:  \" + trimPath(userDir, destinationFile));\n            execute(reader, writer, conversionType, java2HtmlConfig);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (writer != null) {\n                try {\n                    writer.close();\n                    writer = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (reader != null) {\n                try {\n                    reader.close();\n                    reader = null;\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getWebPage": ["getwebpage", "parseWebpages", "parsewebPage", "getVirtualPage", "parseWebPage", "getwebpages", "getVirtualpages", "parseWebpage", "getWebpage", "getWebpages", "getwebPage", "getVirtualpage", "parsewebpages", "parsewebpage"], "urlObj": ["httpOb", "urlInst", "resourceExt", "blogObj", "strObj", "urlExt", " urlobj", "strInst", "resourceobj", "resourceObject", "httpobj", "URLObject", " urlInst", "resourceObj", " urlExt", "UrlObj", "Urlobj", "blogInst", "URLExt", "strObject", "httpObj", "URLobj", "URLObj", " urlObject", "blogObject", "UrlOb", "blogobj", "urlobj", "strobj", "urlOb", "urlObject", " urlOb"], "content": ["clean", "comments", "buffer", "html", "Content", "output", "object", "comment", "load", "feed", "java", "write", "section", "page", "online", "core", "css", "server", "json", "coll", "lines", "address", "result", "code", "array", "response", "message", "resource", "report", "value", "raw", "out", "file", "work", "url", "model", "data", "text", "continue", "document", "body", "string", "header", "cont", "empty", "source", "c"], "is": ["lis", "r", "os", "in", "ip", "mis", "Is", "ai", "irc", "us", "bis", "ie", "iso", "isl", "stream", "isa", "i", "you", "s", "ois", "its", "was", "il", "id", "ires", "isi", "es", "ris", "IS", "ui", "info", "or", "problem", "iss", "ios", "isc", "be", "io", "nis", "ir", "out", "iris", "ais", "abs", "x", "fs", "est", "al", "rest", "ri", "does", "isp", "im", "any", "it", "ins", "ops", "ar", "site", "as", "ise", "ps", "cms", "ser"], "reader": ["r", "in", "writer", "buffer", "h", "ner", "worker", "Reader", "stream", "rer", "i", "rc", "ro", "e", "rx", "handler", "server", "ler", "or", "inner", "editor", "io", "rr", "row", "reading", "rar", "director", "iter", "x", " Reader", "ri", "loader", "er", "oder", "driver", "l", "actor", "parser", "ser", "read", "bird"], "line": ["buffer", "lf", "block", "entry", "key", "cell", "object", "comment", "character", "user", "cr", "section", "page", "lc", "cle", "server", "lines", "Line", "lin", "code", " inline", "strip", "connection", "response", "message", "word", "out", "row", "file", "str", "part", "link", "f", "url", "col", "pass", "inline", "data", "ine", "char", "cl", "LINE", "text", "name", "l", "body", "string", "item", "source", "column"]}}
{"id1": "822452", "id2": "21125261", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    @Test\n    public void test() throws Exception {\n        InputStream is = this.getClass().getResourceAsStream(\"originAndDestination.xml\");\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        IOUtils.copy(is, byteArrayOutputStream);\n        TrafficModelDefinition def = MDFReader.read(byteArrayOutputStream.toByteArray());\n        TrafficSimulationEngine se = new TrafficSimulationEngine();\n        se.init(def);\n        int linkId = 2;\n        int segmentId = 0;\n        Map<Integer, Set<Integer>> linkSegments = new HashMap<Integer, Set<Integer>>();\n        Set<Integer> segments = new HashSet<Integer>();\n        segments.add(segmentId);\n        linkSegments.put(linkId, segments);\n        FrameProperties frameProperties = new FrameProperties(linkSegments, new HashSet<Integer>());\n        se.setFrameProperties(frameProperties);\n        for (float time = 0; time < 60 * 10; time += 0.1f) {\n            se.step(0.1f);\n            for (RoadObject vehicle : se.getDynamicObjects()) {\n                System.out.println(time + \": X=\" + vehicle.getPosition() + \"\\tV=\" + vehicle.getSpeed());\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "471804", "id2": "17193692", "code1": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 0, "substitutes": {"doVersionCheck": [" doversionScan", " doversionCheck", "doChangeCheck", "doversionScan", "doFeatureCheck", "doVersionScan", "doFeatureUpdate", "doversioncheck", "doChangeScan", "doChangecheck", " doVersioncheck", " doversionUpdate", " doVersionUpdate", "doChangeUpdate", "doversionUpdate", "doFeaturecheck", "doFeatureScan", "doVersionUpdate", "doversionCheck", " doVersionScan", " doversioncheck", "doVersioncheck"], "view": ["image", "video", "query", "display", "cell", "comment", "http", "container", "change", "value", "box", "edit", "config", "link", "sel", "this", "base", "update", "v", "body", "View", "window", "client", "vis", "html", "full", "layout", "input", "user", "page", "cache", "fail", "check", "index", "see", "screen", "pool", "gu", "div", "can", "lock", "event", "form", "object", "use", "el", "e", "port", "show", "out", "manager", "row", "views", "head", "up", "vol", "block", "ou", "server", "ui", "group", "ve", "review", "model", "session", "im", "VIEW", "by", "style", "list", "widget", "self"], "url": ["blog", "image", "fr", "buffer", "email", "sl", "ul", "stream", "host", "socket", "impl", "bug", "bb", "ls", "id", "server", "address", "open", "loc", "length", "http", "hub", "URL", "resource", "path", "location", "ob", "ssl", "file", "link", "f", "Url", "null", "base", "zip", "builder", "download", "gl", "loader", "log", "b", "rel", "ll", "name", "l", "browser", "string", "web", "uri", "source", "www"], "in": ["buffer", "m", "pin", "bis", "inn", "isin", "stream", "is", "socket", "s", "init", "cin", "input", "sin", "din", "lin", "inner", "resource", "nin", "out", "ini", "con", "rin", "file", "binary", "doc", "login", "data", "err", "b", "ins", "In", "reader", "as", "IN", "again", "win", "source", "ac", "inc"], "bin": ["fin", "buffer", "pin", "inn", "gin", "is", "socket", "bn", "init", "cin", "input", "bb", "abi", "sin", "din", "spin", "arin", "run", "lin", "inner", "vin", "out", "ini", "con", "ban", "file", "bi", "binary", "lib", "login", "loader", "b", "border", "oin", "bot", "record", "browser", "reader", "body", "IN", "nb", "lock", "win", "ruby"], "line": ["job", "ip", "pin", "lf", "one", "sl", "block", "entry", "key", "cell", "object", "comment", "el", "user", "parse", "e", "write", "id", "page", "lc", "lines", "val", "Line", "lin", "code", "word", "out", "row", "file", "str", "link", "end", "ge", "part", "letter", "unit", "base", "definition", "zip", "inline", "data", "type", "pe", "log", "b", "ine", "range", "LINE", "cl", "text", "name", "l", "string", "nl", "le", "look", "up", "jo"], "version": ["image", "video", "position", "support", "release", "author", "host", "user", "install", "bug", "Version", "section", "id", "patch", "server", "option", "ver", "code", "format", "beta", "pull", "date", "value", "VERSION", "cover", "feature", "unit", "null", "update", "model", "download", "license", "vert", "type", "v", "secret", "name", "driver", "versions", "python", "plugin", "project", "string", "vision", "dev", "device", "latest"], "build": ["job", "Build", "image", "clean", "get", "release", "block", "help", "use", "load", "print", "feed", "install", "bug", "patch", "valid", "home", "run", "info", "boot", "ver", "http", "pull", "show", "work", "building", "how", "row", "post", "link", "uild", "unit", "make", "update", "builder", "log", "rel", "lease", "tag", "built", "mount", "style", "follow", "lock", "add", "hold"]}}
{"id1": "3731077", "id2": "11673907", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    private void _checkLanguagesFiles(ActionRequest req, ActionResponse res, PortletConfig config, ActionForm form) throws Exception {\n        List list = (List) req.getAttribute(WebKeys.LANGUAGE_MANAGER_LIST);\n        for (int i = 0; i < list.size(); i++) {\n            long langId = ((Language) list.get(i)).getId();\n            try {\n                String filePath = getGlobalVariablesPath() + \"cms_language_\" + langId + \".properties\";\n                boolean copy = false;\n                File from = new java.io.File(filePath);\n                if (!from.exists()) {\n                    from.createNewFile();\n                    copy = true;\n                }\n                String tmpFilePath = getTemporyDirPath() + \"cms_language_\" + langId + \"_properties.tmp\";\n                File to = new java.io.File(tmpFilePath);\n                if (!to.exists()) {\n                    to.createNewFile();\n                    copy = true;\n                }\n                if (copy) {\n                    FileChannel srcChannel = new FileInputStream(from).getChannel();\n                    FileChannel dstChannel = new FileOutputStream(to).getChannel();\n                    dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                    srcChannel.close();\n                    dstChannel.close();\n                }\n            } catch (IOException e) {\n                Logger.error(this, \"_checkLanguagesFiles:Property File Copy Failed \" + e, e);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "transferfile", "transferSourceFile", "importFiles", " copySourceFile", "copyFiles", "copyfile", "importfile", "transferFile", "importFile", "transferFiles", "importSourceFile"], "from": ["before", "From", "client", "ca", "original", "left", "src", "form", "ce", "old", "user", "id", "address", "origin", "or", "a", "path", "resource", "io", "se", "at", "file", "of", "part", "start", "f", "url", "o", "this", "base", "data", "with", "range", "name", "by", " form", "d", "front", "without", "as", "remote", "about", "add", "back", "source", "config", "c"], "to": ["auto", "os", "toc", "client", "p", "size", "one", "too", "output", "socket", "object", "parent", "copy", "po", "office", "To", "t", "target", "or", "location", "TO", "top", "io", "into", "at", "file", "dest", "of", "root", "storage", "f", "o", "eto", "null", "until", "api", "base", "this", "temp", "type", "with", "b", "database", "token", "so", "name", "by", "site", "again", "as", "two", "point", "about", "source"], "parentDir": ["parentFile", "rootDir", "parentDirectory", "rootFolder", "ParentDirectory", "ParentFolder", "parentFolder", "currentDir", "currentFolder", "ParentFile", " parentDirectory", "currentdir", "rootDirectory", "rootFile", " parentdir", "outDir", "parentdir", " parentFile", "outFile", "ParentDir", "currentFile", "outFolder", "Parentdir", " parentFolder", "outDirectory"], "in": ["r", "image", "m", "pin", "sync", "ie", "inn", "isin", "gin", "i", "form", "rc", "pre", "init", "cin", "input", "on", "id", "arin", "din", "conn", "diff", "or", "lin", "inner", "vin", "io", "nin", "con", "ini", "fc", "rec", "kin", "work", "part", "inside", "rin", "min", "url", "o", "exec", "login", "err", "with", "trial", "it", "ins", "pc", "bin", "In", "l", "plugin", "again", "IN", "reader", "win", "source", "ac", "inc"], "out": ["Out", "ico", "auto", "client", "writer", "p", "sync", "off", "gin", "output", "init", "app", "cin", "input", "user", "ou", "win", "on", "cy", "ex", "option", "conn", "or", "inner", "io", "op", "at", "ot", "o", "channel", "exec", "vert", "can", "org", "w", "other", "net", "co", "call", "bin", "plugin", "again", "outer", "outs", "about", "c", "OUT", "ac", "inc"], "ic": ["ico", "aic", "ai", "auto", "irc", "cus", "sync", "IC", "i", "ik", "rc", "cc", "cs", "cin", "ix", "input", "ex", "ci", "lc", "conn", "loc", "or", "cu", "bc", "dc", "io", "op", "voc", "uc", "fc", "xc", "pic", "enc", "o", "vc", "ac", "iac", "cl", "nic", "ct", "pc", "co", "anc", "ig", "mc", "ics", "acs", "icc", "c", "inc", "ec"], "oc": ["aic", "toc", "sc", "ca", "cus", "i", "cc", "aco", "cy", "ci", "circ", "OC", "alloc", "loc", "or", "bc", "dc", "cur", "ocol", "io", "ob", "op", "wic", "voc", "uc", "fc", "xc", "oca", "oci", "roc", "o", "enc", "vc", "ac", "can", "ack", "org", "AC", "soc", "nic", "pc", "co", "anc", "mc", "ocon", "acs", "og", "mic", "oco", "c", "inc", "ec"]}}
{"id1": "10504714", "id2": "14865947", "code1": "    private MediaWikiResult getFromUri(String url) throws OntologyServiceException {\n        try {\n            logger.info(\"getting \" + url);\n            HttpURLConnection connection = (java.net.HttpURLConnection) new URL(url).openConnection();\n            connection.setRequestProperty(\"User-Agent\", \"OntoCat-\" + Math.random());\n            BufferedInputStream bin = new BufferedInputStream(connection.getInputStream());\n            JAXBContext jaxbContext = JAXBContext.newInstance(\"uk.ac.ebi.ontocat.mediawiki.jaxb\");\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\n            return (MediaWikiResult) unmarshaller.unmarshal(bin);\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new OntologyServiceException(e);\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"getFromUri": ["getFromRuRI", "getFromRuuri", "getFromURri", "getfromPUuri", "getFromUUrl", "getfromUri", "getfromUUrl", "getFromRuri", "getFromRuUrl", "getFromURUrl", "getfromPUUrl", "getFromPUUrl", "getFromURuri", "getfromPURI", "getFromURI", "getFromURRI", "getFromPUri", "getFromPURI", "getFromUuri", "getfromURI", "getFromPUuri", "getfromUuri", "getfromPUri"], "url": ["request", "lr", "image", "buffer", "email", "sl", "full", "src", "i", "host", "feed", "proxy", "layer", "ls", "route", "page", "id", "server", "rule", "address", "loc", "info", "result", "location", "http", "URL", "path", "resource", "ssl", "file", "build", "str", "Url", "base", "ri", "data", "type", "download", "ll", "language", "name", "l", "href", "string", "ur", "uri", "source", "filename", "www", "username"], "connection": ["image", "db", "in", "position", "client", "connect", "writer", "service", "j", "i", "relation", "object", "socket", "proxy", "context", "use", "character", "section", "directory", "handler", "server", "conn", "bc", "http", "response", "index", "io", "translation", "con", "function", "part", "which", "connected", "channel", "b", "database", "collection", "application", " Connection", "number", "password", "ion", "communication", "network", "Connection", "uri", "config", "c", "condition"], "bin": ["in", "buffer", "pin", "bis", "inn", "bit", "src", "output", "socket", "bn", "input", "bb", "abi", "spin", "din", "brain", "sin", "conn", "ran", "bc", "bon", "inner", "container", "ban", "file", "bi", "binary", "lib", "channel", "base", "login", "data", "b", "border", "database", "bot", "bean", "plugin", "body", "win", "ruby"], "jaxbContext": ["jjbcontext", "jaxaText", "jaxfbChannel", "jjbText", "japaText", "japbcontext", "jaxfbContext", "jjbChannel", "jaxpcontext", "japbText", "jaxfcontext", "japaSupport", "jaxbSupport", "japaContext", "jjfcontext", "jaxpText", "jaxecontext", "jaxbText", "jjfContext", "jaxfChannel", "jjbContext", "jaxeText", "jjfText", "japbContext", "jaxfText", "jaxfContext", "jaxfbcontext", "jaxbcontext", "jaxbChannel", "jaxfbText", "jjfChannel", "jaxfSupport", "japacontext", "jaxacontext", "jaxaContext", "jaxaSupport", "jaxeContext", "jaxpContext", "jaxpChannel", "japbSupport", "jaxeSupport"], "unmarshaller": ["unmarshalleder", "unmarshdaletter", "unmarshalers", "unmarshulletter", "unmarshdaler", "unmarshallER", "unmarshalliner", "unmarshallsER", "unmarshallender", "unmarshalER", "unmarshallingender", "unmarshallingeder", "unmarshulleder", "unmarshaler", "unmarshALLers", "unmarshdalender", "unmarshalletter", "unmarshallser", "unmarshaliner", "unmarshallers", "unmarshallinger", "unmarshallsiner", "unmarshullender", "unmarshALLer", "unmarshALLER", "unmarshallsers", "unmarshuller", "unmarshdaleder", "unmarshallingetter", "unmarshALLiner"]}}
{"id1": "11645260", "id2": "17029388", "code1": "    public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String target = null;\n        boolean allowedToAccess = false;\n        try {\n            URL requestUrl = new URL(\"http:/\" + request.getPathInfo());\n            for (Enumeration en = allowedUrls.elements(); en.hasMoreElements(); ) {\n                URL nextUrl = (URL) en.nextElement();\n                if ((nextUrl).getHost().equalsIgnoreCase(requestUrl.getHost())) {\n                    allowedToAccess = true;\n                }\n            }\n        } catch (MalformedURLException ex) {\n            System.err.println(\"Error in url: \" + \"http:/\" + request.getPathInfo());\n            return;\n        }\n        if (!allowedToAccess) {\n            response.setStatus(407);\n            return;\n        }\n        if (request.getPathInfo() != null && !request.getPathInfo().equals(\"\")) {\n            target = \"http:/\" + request.getPathInfo() + \"?\" + request.getQueryString();\n        } else {\n            response.setStatus(404);\n            return;\n        }\n        InputStream is = null;\n        ServletOutputStream out = null;\n        try {\n            URL url = new URL(target);\n            URLConnection uc = url.openConnection();\n            response.setContentType(uc.getContentType());\n            is = uc.getInputStream();\n            out = response.getOutputStream();\n            byte[] buf = new byte[4096];\n            int bytesRead;\n            while ((bytesRead = is.read(buf)) != -1) {\n                out.write(buf, 0, bytesRead);\n            }\n        } catch (MalformedURLException e) {\n            response.setStatus(404);\n        } catch (IOException e) {\n            response.setStatus(404);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n    }\n", "code2": "    public static InputStream getConfigIs(String path, String name) throws ProgrammerException, DesignerException, UserException {\n        InputStream is = null;\n        try {\n            URL url = getConfigResource(new MonadUri(path).append(name));\n            if (url != null) {\n                is = url.openStream();\n            }\n        } catch (IOException e) {\n            throw new ProgrammerException(e);\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"doGet": ["doRead", "doGET", " doGET", " doPut", "partialGet", "handleRead", "doPut", "handlePut", "partialGET", "handleGet", "partialPut", "handleGET", "partialRead", " doRead"], "request": ["next", "image", "position", "in", "client", "require", "service", "query", "hello", "worker", "queue", "key", "host", "order", "object", "view", "current", "context", "user", "input", "instance", "version", "reference", "e", "enter", "server", "complete", "child", "info", "result", "connection", "resource", "report", "message", "path", "xml", "post", "req", "forward", "this", "rest", "model", "data", "type", "session", "subject", "application", "requ", "method", "call", "name", "Request", "external", "reader", "project", "string", "web", "QUEST", "uri", "event", "join", "create", "authorized", "right", "condition"], "response": ["image", "success", "error", "client", "writer", "service", "fire", "host", "output", "reply", "view", "object", "feed", "queue", "respons", "user", "version", "parent", "environment", "page", "server", "json", "complete", "cache", "result", "connection", "http", "resource", "message", "report", "results", "esi", "Response", "function", "manager", "resp", "ception", "this", "api", "onse", "model", "session", "subject", "status", "application", "wave", "document", "res", "site", "body", "respond", "remote", "event", "re"], "target": ["blank", "timeout", "template", "component", "src", "host", "output", "pattern", "object", "context", "parent", "route", "port", "address", "home", "open", "replace", "loc", "result", "format", "location", "content", "path", "resource", "params", "top", "dest", "root", "base", "session", "type", "Target", "range", "rel", "shadow", "token", "test", "force", "it", "name", "bean", "site", "external", "arget", "remote", "href", "project", "follow", "point", "head", "uri", "join", "source"], "requestUrl": [" requestHost", "requestHost", "raiseUrl", "requestEl", " requestURL", "queryURL", "nextLocation", "adjustLocation", "adjustUrl", "nextURL", "nextEl", "queryEl", "adjustHost", "raiseElement", "requestElement", " requestEl", " requestElement", "adjustElement", "queryUrl", "queryLocation", "requestURL", "raiseLocation", "raiseHost", "requestLocation", " requestLocation"], "en": ["env", "ne", "in", "an", "m", "de", "enn", "n", "EN", "eni", "ane", "el", "eng", "een", "fen", "e", "on", "ener", "ens", " e", "es", "ann", "que", "ven", "den", "esi", " EN", "oa", "len", "end", "wen", "enc", "ena", "set", " En", "pe", "ren", "er", "En", "ent", "ern", "un", "et", "ae", "gen", "au", "ec"], "nextUrl": ["NextLine", " nextURL", " nextLine", "nextURL", "nextPage", "newLine", "nextEl", "NextUrl", " nextEl", "NextURL", "NextEl", "NextPage", "nextLine", " nextPage", "newURL", "newEl", "newPage", "newUrl"], "allowedToAccess": ["allowedTooAccess", "allowedtoAuth", "allowedTOAuth", "allowedTOAccess", " allowedtoAccess", " allowedToAuth", " allowedtoaccess", "allowedFromRead", " allowedTOAccess", " allowedTOaccess", " allowedtoRead", "allowedTooAuth", "allowedToRead", "allowedtoaccess", "allowedFromaccess", "allowedToaccess", " allowedToaccess", " allowedtoAuth", " allowedTORead", "allowedTOaccess", "allowedtoRead", "allowedTORead", "allowedTooRead", "allowedtoAccess", " allowedToRead", "allowedFromAccess", "allowedToAuth"], "is": ["get", "image", "os", "in", "ip", "ai", "Is", "us", "p", "ic", "ie", "isl", "iso", "isa", "src", "i", "bs", "s", "app", "its", "was", "ib", "bb", "ls", "id", "ci", "isi", "address", "ris", "conn", "loc", "IS", "info", "ui", "or", "iss", "cos", "ios", "inner", "isc", "ori", "http", "ob", "has", "ir", "ais", "abs", "close", "api", "serv", "ri", "does", "can", "ack", "over", "it", "ins", "ops", "vs", "browser", "as", "ise", "web", "cms", "uri", "iv", "up"], "out": ["Out", "get", "error", "in", "timeout", "client", "writer", "image", "sync", "obj", "off", "block", "gin", "up", "output", "socket", "object", "app", "init", "ou", "parent", "ex", "cache", "to", "conn", "group", "cos", "exp", "path", "inner", "ext", "io", "resource", "not", "pool", "con", "o", "no", "exec", "err", "temp", "log", "can", "co", "name", "bin", "again", "as", "remote", "c", "outs", "outer", "lock", "win", "external", "OUT", "ac", "inc"], "url": ["get", "image", "blog", "client", "sl", "ul", "stream", "host", "rc", "impl", "user", "bug", "page", "server", "loc", "bc", "connection", "http", "URL", "resource", "path", "cur", "ssl", "f", "Url", "channel", "base", "plug", "log", "l", "mount", "web", "ur", "uri", "c", "source", "config", "www"], "uc": ["in", "sc", "client", "su", "union", "auc", "us", "cus", "ul", "cci", "up", "rc", "unic", "cc", "ou", "lc", "ci", "ud", "uca", "conn", "loc", "um", "bc", "nc", "http", "connection", "path", "oc", "con", "fc", "xc", "ub", "UC", "uci", "uu", "unc", "ac", "ucc", "cv", "soc", "pc", "anc", "mc", "usc", "uri", "self", "c", "ec"], "buf": ["pad", "buffer", "cas", "seq", "bytes", "batch", "bf", "br", "ctx", "block", "queue", "ff", "fd", "lb", "rc", "map", "cat", "bb", "cf", "loc", "bc", "rb", "af", "fb", "buff", "pool", "av", "box", "bag", "len", "bd", "bh", "wb", "vec", "data", "b", "cv", "cap", "uf", "ba", "ucc", "bin", "cmd", "cb"], "bytesRead": ["bytesWrite", "BytesHave", "bitsTotal", "bitsWritten", " bytesWritten", "bytesread", "BytesRead", "bitsRead", "unitsWritten", "wordsread", "bytesHave", "tesWritten", "bytesTotal", "secondsWrite", "BytesWrite", "bytesCopy", "unitsRead", "tesTotal", " bytesHave", "tesread", "tesRead", "bitsread", "bytesWritten", "secondsread", "tesCopy", " bytesWrite", "unitsWrite", "wordsWrite", "tesWrite", " bytesread", " bytesTotal", "wordsCopy", "BytesWritten", "unitsHave", "wordsRead", "secondsCopy", "secondsRead"]}}
{"id1": "6379126", "id2": "12766394", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTinyPage", "riarTinyDir", "riartourpage", "riarTourDir", "riarTutorialElement", "riartutorialPage", "riarTutorialDir", "riarTourElement", "riarTravispage", "riartutorialDir", "riarTinypage", "riarTinyElement", "riarTourPage", "riarTutorialPage", "riarTravisElement", "riartourElement", "riarTravisPage", "riartutorialElement", "riarTourpage", "riartutorialpage", "riarTutorialpage", "riartourPage", "riartourDir", "riarTravisDir"], "indexDir": ["IndexTier", "includeJar", "zipJar", "indexJar", "includeTier", "zipTier", "IndexDir", "zipDir", "zipDIR", "IndexDIR", "includeDir", "indexDIR", "indexTier", "includeDIR", "IndexJar"], "cssDir": ["catsDoc", "javascriptDir", "CSSLen", "ssUrl", "fontDIR", "fontDir", "cssDIR", "piecesDie", "cssDie", "ssD", "CSSDir", "catsDir", "javascriptDb", "CSSDirectory", "javascriptDar", "ssDIR", "CSSDar", "gzDir", "cssDb", "fontD", "cssD", "CSSDIR", "codesDoc", "javascriptDIR", "CSSDb", "ssDir", "cssDar", "codesDir", "catsLen", "piecesD", "ssDb", "gzDIR", "CSSDoc", "cssLen", "cssDirectory", "fontDie", "gzDirectory", "gzUrl", "piecesDir", "ssDar", "codesLen", "ssDie", "CSSUrl", "ssDirectory", "cssDoc", "cssUrl", "piecesDIR"], "capDir": ["capdir", "CapVol", "capDirectory", "casDir", "casdir", "Capdir", "CapDirectory", "casVol", "apsDir", "apsdir", "casDirectory", "apsVol", "CapDir", "capVol", "apsDirectory"], "licDir": ["volDoc", "lifManager", "lifDir", "libManager", "licManager", "libDoc", "lifDoc", "voldir", "volDir", "licdir", "volManager", "lifdir", "licDoc", "libdir", "libDir"], "midDir": ["middir", "casDir", "limTier", "mindDir", "limDir", "midTier", "casDIR", "casdir", "limDIR", "casTier", "mindTier", "mindDIR", "minddir", "midDIR", "limdir"], "filesDir": ["ballsPos", "ballsVol", "filesFolder", "pagesVol", "ballsDir", "pagesPos", "stylesDir", "FilesDir", "filesVol", "videosFile", "videosFolder", "imagesFile", " filesVol", "filesDur", "opensDIR", "stylesDirectory", "stylesDIR", "videosDirectory", "filesPos", "filesDirectory", "opensDirectory", "filesDIR", "opensDur", "stylesDur", "locksDirectory", "imagesDir", "locksDIR", "imagesDirectory", " filesPos", "FilesFolder", "FilesDirectory", "pagesDir", "imagesFolder", "FilesFile", "opensDir", "filesFile", "locksDir", "locksDur"], "videosDir": ["viewsUrl", "videosDb", "videoUrl", "videoFile", " videosDb", " videosDirectory", "videosFile", "viewsDir", "viewsDirectory", "videosDirectory", "viewsFile", "imagesDir", " videosFile", "videoDb", " videosUrl", "imagesDb", "videosUrl", "videoDirectory", "videoDir"], "imagensDir": ["imgentsFile", " imagensDirectory", " imagersDirectory", "imagentsFile", "imagenciesDir", "imgensDir", " imagensFile", " imagersFile", "imgensDirectory", "imagersDirectory", "imgentsDirectory", "imgentsDIR", " imagersJar", "imagentsJar", "imgentsDir", "imagersDIR", "imagenJar", "imagenFile", "imagensDirectory", "imagersDir", " imagersDir", "imagenciesDirectory", "imgensFile", "imgensDIR", "imagensDIR", "imagenDirectory", "imagenciesDIR", "imagenciesFile", "imagensJar", "imagersJar", "imagenDir", " imagensJar", "imagersFile", "imagentsDir", "imagentsDIR", "imagentsDirectory", "imagensFile"], "local": ["request", "where", "localhost", "shared", "p", "upload", "same", "defined", "tmp", "global", "user", "basic", "managed", "internal", "serial", "pal", "input", "directory", "valid", "json", "home", "loc", "relative", "state", "location", "safe", "path", "inner", "standard", "http", "conf", "file", "available", "part", "dir", "util", "active", "Location", "prefix", "pass", "base", "Local", "data", "temp", "LOC", "log", "partial", "personal", "total", "name", "l", "small", "specified", "d", " Local", "remote", "present", "lock", "current", "back", "self", "initial", "username"], "srcCss1": ["srcRcss0", "srcCpe4", "srcCrss1", "srcCss11", "srcCrss3", "srcRss2", "srcPss81", "srcRss0", "srcCcss0", "srcPcss1", "srcPssPre", "srcCss81", "srcRss1", "srcCse1", "srcCcss1", "srcRcss2", "srcCrss2", "srcPss1", "srcCass2", "srcCass0", "srcCcssPre", "srcPcss2", "srcPcss3", "srcCpe1", "srcPcssPre", "srcCpe2", "srcCcss81", "srcCpePre", "srcRcss11", "srcCass1", "srcCssPre", "srcRss81", "srcRss11", "srcCfg1", "srcCass3", "srcCrss11", "srcCcss3", "srcRcss81", "srcPcss4", "srcCse2", "srcPss3", "srcCcss4", "srcRcss1", "srcPcss81", "srcCcss2", "srcCse11", "srcCfg4", "srcCass81", "srcCcss11", "srcCrss81", "srcCass11", "srcCse0", "srcCss0", "srcCfg2", "srcPss4", "srcPss2", "srcCfgPre"], "destCss1": ["destCass1", "destPcss3", "destPssCard", "destCcss3", "destCfg3", "destPcss81", "destPss2", "destCss0", "destCrss81", "destCxxCard", "destPcss1", "destCxx1", "destCass81", "destCass3", "destCss81", "destCssCard", "destPss0", "destCcss2", "destCcss1", "destCcssCard", "destCfg1", "destPcss2", "destCass2", "destCrss1", "destCcss0", "destCfg0", "destCassCard", "destCrss0", "destCfg2", "destCrss2", "destPcssCard", "destCxx3", "destPss1", "destCrss3", "destPss3", "destPcss0", "destCxx2", "destCcss81", "destPss81"], "srcCss2": ["srcCcssL", "srcCass52", "srcCrssL", "srcCssTwo", "srcCrss1", "srcChessTwo", "srcCssB", "srcCrss3", "srcCss27", "srcChess1", "srcUcssTwo", "srcCfgL", "srcCng27", "srcCross4", "srcPss27", "srcChessB", "srcAcss2", "srcPcss1", "srcUssTwo", "srcCross1", "srcCrss2", "srcCcss1", "srcPss1", "srcUcss1", "srcCass2", "srcUcssB", "srcAccss2", "srcAccss52", "srcPcss27", "srcCross2", "srcPcss2", "srcPcss3", "srcCng1", "srcCng2", "srcCass1", "srcPssL", "srcCcss27", "srcUcss2", "srcChess2", "srcCfg1", "srcAcss4", "srcPcssL", "srcCcss3", "srcPss3", "srcCcss4", "srcCcss52", "srcCssL", "srcCcssB", "srcCfg3", "srcCfgB", "srcAccss1", "srcCass4", "srcCcss2", "srcCcssTwo", "srcUss1", "srcUss2", "srcAcss52", "srcCfgTwo", "srcCss52", "srcUssB", "srcAccss4", "srcCross52", "srcCrss27", "srcAcss1", "srcCfg2", "srcPss2"], "destCss2": ["destCess1", "destCfg3", "destCcss72", "destCcss3", "destNcss32", "destNcss2", "destNss1", "destCess32", "destCest2", "destCcss4", "destCcssB", "destCess4", "destNcss3", "destNcssB", "destNss2", "destNss32", "destCcss32", "destCfg32", "destNss4", "destCest3", "destCcss2", "destCcss1", "destNssB", "destNcss4", "destCfg1", "destNss72", "destCess72", "destCfgB", "destCfg4", "destNss3", "destCess2", "destCestB", "destCssB", "destCfg2", "destNcss72", "destCfg72", "destCest1", "destCss32", "destNcss1", "destCss72"], "srcCss3": ["srcRss2", "srcCsh183", "srcScss3", "srcCsl183", "srcRss1", "srcScstyle93", "srcCssThird", "srcCstyle6", "srcScstyle2", "srcCsh2", "srcCcss4", "srcCstyleAND", "srcPss6", "srcCstyle15", "srcCstyle93", "srcCfg2", "srcCcss93", "srcCss15", "srcCssAND", "srcCsl3", "srcCstyle3", "srcCss183", "srcCass2", "srcRcss3", "srcCcss15", "srcCrss6", "srcRss3", "srcCass1", "srcCfg1", "srcCcss3", "srcPss3", "srcClass3", "srcRcss1", "srcCss93", "srcPcss6", "srcCass4", "srcCcssThird", "srcCrss3", "srcScstyle3", "srcCstyle2", "srcCcss6", "srcClass2", "srcRcss183", "srcClass15", "srcPcss2", "srcPssAND", "srcCrssAND", "srcClass93", "srcCass3", "srcRssThird", "srcCslThird", "srcCsh3", "srcRss183", "srcCsl2", "srcRcss4", "srcCfg3", "srcCfg4", "srcRss4", "srcRcssThird", "srcPcss3", "srcScss93", "srcCcss183", "srcCrss2", "srcRcss2", "srcCcss1", "srcScss15", "srcPcssAND", "srcCcssAND", "srcScss2", "srcCshThird", "srcScstyle15", "srcCcss2", "srcPss2"], "destCss3": ["destPcss3", "destCcss3", "destCross3", "destNcss2", "destCstyle2", "destScss183", "destCstyle03", "destCja6", "destPss2", "destScss3", "destCrss183", "destCss43", "destCross03", "destCstyle53", "destCstyle43", "destCross53", "destNcss3", "destScrss2", "destCrss6", "destNss2", "destNss43", "destScrss6", "destCass3", "destNcss43", "destCss53", "destScss6", "destCja3", "destPcss53", "destPcss03", "destCcss2", "destScrss3", "destCstyle3", "destPcss2", "destCass2", "destCss03", "destPss53", "destScrss183", "destCss183", "destNss3", "destCja183", "destScss2", "destCja2", "destCrss2", "destCcss6", "destCross2", "destCrss3", "destPss3", "destCcss183", "destPss03", "destCcss53", "destCcss03", "destCcss43", "destCass43"], "srcCss4": ["srcCrss1", "srcPcss1", "srcPssFour", "srcCrss2", "srcCcss1", "srcPss1", "srcCass2", "srcPcss2", "srcCass1", "srcCssFour", "srcCassFour", "srcCrss4", "srcCrssFour", "srcCcssFour", "srcPcss4", "srcCcss4", "srcPcssFour", "srcCcss2", "srcCass4", "srcPss4", "srcPss2"]}}
{"id1": "18962382", "id2": "411595", "code1": "    protected void connect() throws SocketException, IOException, LoginFailException {\n        logger.info(\"Connect to FTP Server \" + account.getServer());\n        client = new FTPClient();\n        client.connect(account.getServer());\n        if (client.login(account.getId(), account.getPassword()) == false) {\n            logger.info(\"Fail to login with id=\" + account.getId());\n            throw new LoginFailException(account.getId(), account.getPassword());\n        }\n    }\n", "code2": "    private void displayDiffResults() throws IOException {\n        File outFile = File.createTempFile(\"diff\", \".htm\");\n        outFile.deleteOnExit();\n        FileOutputStream outStream = new FileOutputStream(outFile);\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(outStream));\n        out.write(\"<html><head><title>LOC Differences</title>\\n\" + SCRIPT + \"</head>\\n\" + \"<body bgcolor='#ffffff'>\\n\" + \"<div onMouseOver=\\\"window.defaultStatus='Metrics'\\\">\\n\");\n        if (addedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Added:</th>\" + \"<th>Add</th><th>Type</th></tr>\");\n            out.write(addedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (modifiedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Modified:</th>\" + \"<th>Base</th><th>Del</th><th>Mod</th><th>Add</th>\" + \"<th>Total</th><th>Type</th></tr>\");\n            out.write(modifiedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        if (deletedTable.length() > 0) {\n            out.write(\"<table border><tr><th>Files Deleted:</th>\" + \"<th>Del</th><th>Type</th></tr>\");\n            out.write(deletedTable.toString());\n            out.write(\"</table><br><br>\");\n        }\n        out.write(\"<table name=METRICS BORDER>\\n\");\n        if (modifiedTable.length() > 0 || deletedTable.length() > 0) {\n            out.write(\"<tr><td>Base:&nbsp;</td><td>\");\n            out.write(Long.toString(base));\n            out.write(\"</td></tr>\\n<tr><td>Deleted:&nbsp;</td><td>\");\n            out.write(Long.toString(deleted));\n            out.write(\"</td></tr>\\n<tr><td>Modified:&nbsp;</td><td>\");\n            out.write(Long.toString(modified));\n            out.write(\"</td></tr>\\n<tr><td>Added:&nbsp;</td><td>\");\n            out.write(Long.toString(added));\n            out.write(\"</td></tr>\\n<tr><td>New & Changed:&nbsp;</td><td>\");\n            out.write(Long.toString(added + modified));\n            out.write(\"</td></tr>\\n\");\n        }\n        out.write(\"<tr><td>Total:&nbsp;</td><td>\");\n        out.write(Long.toString(total));\n        out.write(\"</td></tr>\\n</table></div>\");\n        redlinesOut.close();\n        out.flush();\n        InputStream redlines = new FileInputStream(redlinesTempFile);\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = redlines.read(buffer)) != -1) outStream.write(buffer, 0, bytesRead);\n        outStream.write(\"</BODY></HTML>\".getBytes());\n        outStream.close();\n        Browser.launch(outFile.toURL().toString());\n    }\n", "label": 0, "substitutes": {"connect": ["request", "localhost", "timeout", "ping", "ssh", "access", "sync", " connection", "host", " reconnect", "socket", "init", "construct", "write", "run", "open", "conn", "register", "boot", "connection", "con", "start", "link", "connected", "close", "exec", "set", "login", "download", "log", " close", "bind", "auth", "Connect", "stop", " login", " disconnect", "setup", "add", "create", "config", "select"], "IOException": [" IOEx", "IPEx", "SSLEx", "SSLException", "IPException", "IOEx"], "LoginFailException": ["LoginWaitception", " LoginFailCause", "LoginReadEvent", "LoginReadException", "LoginFailception", "LoginPassEvent", "LoginPassException", "LoginWaitException", " LoginFlowCause", "LoginFailEvent", " LoginFailEvent", "LoginPassCause", "LoginReadception", "LoginFlowException", "LoginFailExc", "LoginFlowception", " LoginFlowExc", "LoginReadCause", " LoginFlowException", " LoginFailception", "LoginPassception", "LoginFlowEvent", " LoginFailExc", " LoginFlowception", "LoginWaitExc", " LoginFlowEvent", "LoginFlowExc", "LoginPassExc", "LoginFlowCause", "LoginFailCause"], "client": ["request", "clean", "ace", "service", "console", "ce", "socket", "cn", "cell", "app", "proxy", "parent", "cli", "core", "port", "server", "cache", "handler", "conn", "connection", "http", "container", "resource", "pool", "ssl", "manager", "con", "Client", "url", "lib", "api", "session", "local", "cl", "pc", "call", "net", "friend", "remote", "plugin", "web", "config", "c"]}}
{"id1": "255765", "id2": "1508930", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "label": 0, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "21488518", "id2": "13783549", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"createNew": ["openResource", "createCopy", "openNew", "newNew", "openOpen", "createResource", "resourceCopy", "resourceResource", "newOpen", "newResource", "newCopy", "resourceNew", "openCopy", "resourceOpen", "createOpen"], "name": ["image", "client", "self", "large", "size", "one", "n", "full", "key", "class", "old", "label", "comment", "default", "common", "ix", "title", "parent", "e", "id", "office", "directory", "on", "address", "ame", "ui", "alias", "connection", "code", "content", "time", "path", "resource", "ext", "word", "value", "file", "part", "NAME", "end", "x", "url", "prefix", "no", "none", "base", "model", "data", "type", "missing", "Name", "number", "search", "names", "anc", "member", "style", "string", "ename", "named", "folder", "non", "current", "filename", "username"], "in": ["image", "buffer", "size", "src", "i", "init", "input", "slice", "thin", "id", "din", "plus", "diff", "connection", "inner", "resource", "ini", "raw", "file", "work", "con", "len", "pass", "exec", "login", "data", "ins", "record", "bin", "In", "reader", "IN", "read", "win", "source", "up", "inc"], "length": ["timeout", "buffer", "level", "size", "bytes", "load", "sequence", "ength", "id", "limit", "padding", "Length", "content", "path", "time", "line", "count", "len", "url", "type", "offset", "number", "width", "password", "body", "duration", "filename"], "contentType": ["ContentLength", "contentPath", "resourceLength", " contenttype", "resourceType", "contenttype", " contentLength", "ContentType", "resourcePath", "Contenttype", "contentLength", "resourcetype", " contentPath", "ContentPath"], "dest": ["de", "tx", "upload", "src", "output", "tmp", "comb", "opt", "parent", "thin", "route", "home", "Dest", "target", "result", "dc", "desc", "orig", "later", "img", "conf", "sup", "cdn", "dist", "store", "dir", "trip", "wb", "zip", "temp", "flat", "trans", "done", "transform", " destination", "d", "prop", "folder", "destroy", "gz", "cont", "tif", "source", "config", "txt"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "up", "output", "socket", "object", "view", "copy", "parent", "ex", "page", "cache", "server", "conn", "result", "connection", "exp", "path", "resource", "ext", "io", "pool", "img", "line", "file", "f", "url", "o", "null", "this", "exec", "zip", "channel", "data", "temp", "err", "log", "bin", "password", "again", "outs", "lock", "cmd", "gz", "flush", "source", "OUT"], "request": ["get", "job", "client", "buffer", "rate", "access", "query", "upload", "rer", "transfer", "object", "use", "user", "input", "instance", "reference", "route", "directory", "complete", "open", "child", "ext", "report", "resource", "path", "response", "xml", "quest", "store", "url", "req", "forward", "base", "type", "pe", "wheel", "call", "Request", "friend", "remote", "project", "QUEST", "respect", "re", "external", "config", "claim"]}}
{"id1": "16215393", "id2": "19868933", "code1": "    public void importSequences() {\n        names = new ArrayList<String>();\n        sequences = new ArrayList<String>();\n        try {\n            InputStream is = urls[urlComboBox.getSelectedIndex()].openStream();\n            ImportHelper helper = new ImportHelper(new InputStreamReader(is));\n            int ch = helper.read();\n            while (ch != '>') {\n                ch = helper.read();\n            }\n            do {\n                String line = helper.readLine();\n                StringTokenizer tokenizer = new StringTokenizer(line, \" \\t\");\n                String name = tokenizer.nextToken();\n                StringBuffer seq = new StringBuffer();\n                helper.readSequence(seq, \">\", Integer.MAX_VALUE, \"-\", \"?\", \"\", null);\n                ch = helper.getLastDelimiter();\n                names.add(name);\n                sequences.add(seq.toString());\n            } while (ch == '>');\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (EOFException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void copyFromFileToFileUsingNIO(File inputFile, File outputFile) throws FileNotFoundException, IOException {\n        FileChannel inputChannel = new FileInputStream(inputFile).getChannel();\n        FileChannel outputChannel = new FileOutputStream(outputFile).getChannel();\n        try {\n            inputChannel.transferTo(0, inputChannel.size(), outputChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inputChannel != null) inputChannel.close();\n            if (outputChannel != null) outputChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"importSequences": [" importsequements", " importSequFiles", "importMultipleements", " importSequence", "importsequements", "importMultipleences", "importSequements", "importInternence", "importMultipleence", " importSequements", "importInternements", "importSequence", "importInternences", " importsequence", "importMultipleFiles", "importInternFiles", "importsequences", "importSequFiles", " importsequFiles", "importsequFiles", " importsequences", "importsequence"], "names": ["words", "models", "files", "tags", "strings", "headers", "hops", "packages", "ns", "they", "pres", "ens", "lines", "keys", "objects", "obs", "services", "params", "images", "modules", "ons", "members", "frames", "codes", "states", "Names", "nos", "mas", "ames", "ans", "works", "users", "views", "ins", "ids", "named", "stars", "ports", "paces", "sheets"], "sequences": ["Sequences", "contencies", "equence", "equences", "Sequencies", "sequelines", "Sequances", "equations", "Sequelines", "contelines", "responsencies", "occupencies", "sequence", "responsences", "variencies", "occupations", "variances", "contences", "sequencies", "responsence", "sequances", "occupences", "equencies", "contances", "sequations", "occupence", "varielines", "responsations", "variences"], "is": ["lis", "os", "in", "ip", "Is", "h", "us", "p", "bis", "iso", "isa", "i", "s", "app", "init", "its", "ls", "es", "isi", "ris", "IS", "info", "or", "iss", "ios", "isc", "has", "ir", "out", "ais", "url", "close", "api", "sis", "are", "it", "ar", "as"], "helper": ["compen", "thelpers", "hypers", "Helhel", "Helpers", "permer", "hepers", "Heller", "helpar", "calar", "calping", " helPER", " Heller", "heper", "thelper", "comhel", "hyf", "helpper", "Helpen", "calPER", "helpmer", "calper", "perpers", " Helpers", "theller", "helping", "perper", "perler", " helar", "helf", "helhel", "shhel", "perf", "comper", "helpers", "helpping", " helping", "helpen", "shper", "thelmer", "hyler", "heller", "helmer", "Helper", "heler", "helPER", " Helper", "shpen", "helppers", " Helmer", "hemer", "comler", "hyper", "Helf", "shler", "helpPER", "helar", "helpler"], "ch": ["gr", "chan", "arch", "h", "p", "cher", "ctx", "cp", "q", "ce", "quote", "el", "sk", "che", "ci", "coll", "qu", "conn", "sh", "th", " chunk", "cht", "length", "code", "pr", "cho", "cur", "cor", "se", "change", "conf", "bh", "unch", "Ch", "CH", "col", "enc", "anch", "k", "div", "err", "ich", "char", "cl", "ach", "sch", "cha", "chi", "ech", "chu", "ur", "cmp", "zh", "cmd", "c", "och", "hex"], "line": ["job", "sl", "sync", "lf", "pos", "entry", "block", "cell", "e", "page", "lc", "cle", "lines", "Line", "lin", "code", "content", "word", "row", "file", "str", "end", "iter", "part", "url", "letter", "pass", "base", "inline", "data", "char", "cl", "LINE", "text", "l", "frame", "string", "header", "nl", "source", "c"], "tokenizer": ["okenize", " tokenner", " tokenize", "tokenize", "okenner", "Tokenner", "Tokenizer", "okenizer", "tokeniz", "Tokenizing", " tokenizers", "Tokeniz", "okenizing", "Tokenize", " tokenizing", "Tokenizers", " tokeniz", "tokenner", "tokenizing", "okeniz", "okenizers", "tokenizers"], "name": ["next", "size", "attr", "n", "label", "key", "object", "comment", "default", "id", "ame", "info", "alias", "connection", "path", "time", "word", "str", "part", "start", "NAME", "url", "letter", "prefix", "pass", "base", "data", "type", "er", "Name", "number", "search", "string", "named", "filename", "non"], "seq": ["vals", "job", "la", "buffer", "cas", "iq", "fast", "ctx", "sec", "queue", "quote", "sci", "chain", "feed", "sequence", "parse", "pkg", "lc", "phrase", "val", "que", "info", "length", "closure", "resp", "str", "config", "feat", "iter", "sel", "buf", "req", "unit", "vec", "zip", "conv", "data", " sequence", "sq", "struct", "live", "cl", "text", "wave", "sem", "frame", "string", "list", "cb", "c", " buf"]}}
{"id1": "1421557", "id2": "19910627", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "884867", "id2": "742465", "code1": "    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.out.println(\"Usage: GZip source\");\n            return;\n        }\n        String zipname = args[0] + \".gz\";\n        GZIPOutputStream zipout;\n        try {\n            FileOutputStream out = new FileOutputStream(zipname);\n            zipout = new GZIPOutputStream(out);\n        } catch (IOException e) {\n            System.out.println(\"Couldn't create \" + zipname + \".\");\n            return;\n        }\n        byte[] buffer = new byte[sChunk];\n        try {\n            FileInputStream in = new FileInputStream(args[0]);\n            int length;\n            while ((length = in.read(buffer, 0, sChunk)) != -1) zipout.write(buffer, 0, length);\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"Couldn't compress \" + args[0] + \".\");\n        }\n        try {\n            zipout.close();\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    public static void doVersionCheck(View view) {\n        view.showWaitCursor();\n        try {\n            URL url = new URL(jEdit.getProperty(\"version-check.url\"));\n            InputStream in = url.openStream();\n            BufferedReader bin = new BufferedReader(new InputStreamReader(in));\n            String line;\n            String version = null;\n            String build = null;\n            while ((line = bin.readLine()) != null) {\n                if (line.startsWith(\".version\")) version = line.substring(8).trim(); else if (line.startsWith(\".build\")) build = line.substring(6).trim();\n            }\n            bin.close();\n            if (version != null && build != null) {\n                if (jEdit.getBuild().compareTo(build) < 0) newVersionAvailable(view, version, url); else {\n                    GUIUtilities.message(view, \"version-check\" + \".up-to-date\", new String[0]);\n                }\n            }\n        } catch (IOException e) {\n            String[] args = { jEdit.getProperty(\"version-check.url\"), e.toString() };\n            GUIUtilities.error(view, \"read-error\", args);\n        }\n        view.hideWaitCursor();\n    }\n", "label": 0, "substitutes": {"zipname": ["zfile", "zsize", "zipsize", "projectName", "zipno", "gzsize", "gzfile", "zipName", "fileroot", "clipName", "projectname", "clipcache", "zName", "zipfile", "filefile", "zipcache", "clipname", "zroot", "gzname", "zname", "lockName", "gzName", "projectcache", "projectno", "lockno", " zipfile", "fileName", " zipName", "ziproot", " ziproot", "clipno", "lockname", "lockcache", " zipsize", "filename"], "zipout": ["zfile", "clipin", "foldername", "clipoutput", "copout", "zout", "zin", "zcontainer", "zenserver", "folderout", " zipcontainer", "zipcontainer", "clipcache", "zgen", "zcache", "zipfile", "zipoutput", "zoutput", "zipserver", " zipgen", " zipcache", " zipserver", "zipcache", " zipin", "zname", "zipgen", "zserver", "zengen", " zipfile", " zipoutput", "zipin", "folderin", "copname", "clipout", "copin", "foldercontainer", "copfile", "zenin", "zenout"], "out": ["Out", "error", "image", "client", "writer", "p", "term", "query", "obj", "n", "msg", "up", "key", "output", "pre", "print", "user", "write", "copy", "parent", "page", "ex", "cache", "conn", "plus", "diff", "group", "code", "exp", "io", "word", "pool", "line", "file", "raw", "post", "f", "url", "dot", "o", "lib", "exec", "base", "doc", "prefix", "err", "log", "b", "w", "co", "name", "bin", "again", "project", "list", "point", "outs", "lock", "window", "gen", "flush", "dump", "outer", "OUT", "inc"], "buffer": ["position", "image", "bytes", "size", "shape", "batch", "block", "queue", "transfer", "comment", "feed", "slice", "input", "sequence", "reference", "bb", "Buffer", "limit", "cache", "stack", "source", "result", "padding", "array", "resource", "buff", "row", "uffer", "file", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "b", "border", "offset", "number", "wave", "reader", "header", "seed", "read", "layer"], "in": ["r", "image", "fr", "pin", "ic", "inn", "gin", "i", "is", "init", "input", "id", "ex", "din", "conn", "diff", "lin", "a", "inner", "nin", "ini", "con", "rec", "rin", "f", "url", "serv", "pass", "login", "err", "b", "ins", "bin", "In", "l", "again", "IN", "as", "reader", "re", "win", "up", "c", "inc"], "length": ["position", "component", "level", "size", "shape", "ok", "left", "ph", "full", "old", "class", "key", "view", "load", "character", "feed", "slice", "sequence", "ength", "id", "section", "limit", "core", "loc", "last", "tail", "Length", "code", "index", "pull", "ob", "line", "count", "row", "build", "angle", "part", "len", "end", "f", "url", "type", "pe", "append", "range", "partial", "offset", "number", "force", "width", "total", "l", "style", "body", "string", "present", "point", "duration", "lock", "join"]}}
{"id1": "6379126", "id2": "18696387", "code1": "    public boolean gerarTutorialPage() {\n        try {\n            File indexDir = criarDiretorioSite();\n            File cssDir = criarDiretorioCss();\n            File capDir = criarDiretorioCapitulos();\n            File licDir = criarDiretorioLicoes();\n            File midDir = criarDiretorioMidias();\n            File filesDir = criarDiretorioArquivos();\n            File videosDir = new File(filesDir + \"/videos\");\n            videosDir.mkdir();\n            File imagensDir = new File(filesDir + \"/imagens\");\n            imagensDir.mkdir();\n            String local = System.getProperty(\"user.dir\");\n            FileChannel srcCss1 = new FileInputStream(local + \"/bin/style/layout.css\").getChannel();\n            FileChannel destCss1 = new FileOutputStream(cssDir + \"/layout.css\").getChannel();\n            destCss1.transferFrom(srcCss1, 0, srcCss1.size());\n            srcCss1.close();\n            destCss1.close();\n            FileChannel srcCss2 = new FileInputStream(local + \"/bin/style/elementos.css\").getChannel();\n            FileChannel destCss2 = new FileOutputStream(cssDir + \"/elementos.css\").getChannel();\n            destCss2.transferFrom(srcCss2, 0, srcCss2.size());\n            srcCss2.close();\n            destCss2.close();\n            FileChannel srcCss3 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid.css\").getChannel();\n            FileChannel destCss3 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid.css\").getChannel();\n            destCss3.transferFrom(srcCss3, 0, srcCss3.size());\n            srcCss3.close();\n            destCss3.close();\n            FileChannel srcCss4 = new FileInputStream(local + \"/bin/style/layout_ie.css\").getChannel();\n            FileChannel destCss4 = new FileOutputStream(cssDir + \"/layout_ie.css\").getChannel();\n            destCss4.transferFrom(srcCss4, 0, srcCss4.size());\n            srcCss4.close();\n            destCss4.close();\n            FileChannel srcCss5 = new FileInputStream(local + \"/bin/style/elementos_ie.css\").getChannel();\n            FileChannel destCss5 = new FileOutputStream(cssDir + \"/elementos_ie.css\").getChannel();\n            destCss5.transferFrom(srcCss5, 0, srcCss5.size());\n            srcCss5.close();\n            destCss5.close();\n            FileChannel srcCss6 = new FileInputStream(local + \"/bin/style/estilo-cap-lic-mid_ie.css\").getChannel();\n            FileChannel destCss6 = new FileOutputStream(cssDir + \"/estilo-cap-lic-mid_ie.css\").getChannel();\n            destCss6.transferFrom(srcCss6, 0, srcCss6.size());\n            srcCss6.close();\n            destCss6.close();\n            copiarMidias(videosDir, imagensDir);\n            escreverMidiasPage(midDir);\n            escreverLicoesPage(licDir);\n            escreverCapitulosPages(capDir);\n            FileWriter indexHtml = new FileWriter(indexDir + \"/index.html\");\n            indexHtml.write(escreverIndexHead() + escreverBodyHeader() + escreverIndexBodyContent() + escreverFooter());\n            indexHtml.close();\n            System.out.println(\"Site gerado com sucesso\");\n            JOptionPane.showMessageDialog(null, \"Web Site gerado com sucesso\", \"\\\\o/\", JOptionPane.INFORMATION_MESSAGE);\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.err.println(\"Site n\u00e3o gerado\");\n            JOptionPane.showMessageDialog(null, \"Web Site n\u00e3o gerado corretamente\", \"Ops...\", JOptionPane.ERROR_MESSAGE);\n            return false;\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"gerarTutorialPage": ["riarTinyPage", "riarTinyDir", "riartourpage", "riarTourDir", "riarTutorialElement", "riartutorialPage", "riarTutorialDir", "riarTourElement", "riarTravispage", "riartutorialDir", "riarTinypage", "riarTinyElement", "riarTourPage", "riarTutorialPage", "riarTravisElement", "riartourElement", "riarTravisPage", "riartutorialElement", "riarTourpage", "riartutorialpage", "riarTutorialpage", "riartourPage", "riartourDir", "riarTravisDir"], "indexDir": ["IndexTier", "includeJar", "zipJar", "indexJar", "includeTier", "zipTier", "IndexDir", "zipDir", "zipDIR", "IndexDIR", "includeDir", "indexDIR", "indexTier", "includeDIR", "IndexJar"], "cssDir": ["catsDoc", "javascriptDir", "CSSLen", "ssUrl", "fontDIR", "fontDir", "cssDIR", "piecesDie", "cssDie", "ssD", "CSSDir", "catsDir", "javascriptDb", "CSSDirectory", "javascriptDar", "ssDIR", "CSSDar", "gzDir", "cssDb", "fontD", "cssD", "CSSDIR", "codesDoc", "javascriptDIR", "CSSDb", "ssDir", "cssDar", "codesDir", "catsLen", "piecesD", "ssDb", "gzDIR", "CSSDoc", "cssLen", "cssDirectory", "fontDie", "gzDirectory", "gzUrl", "piecesDir", "ssDar", "codesLen", "ssDie", "CSSUrl", "ssDirectory", "cssDoc", "cssUrl", "piecesDIR"], "capDir": ["capdir", "CapVol", "capDirectory", "casDir", "casdir", "Capdir", "CapDirectory", "casVol", "apsDir", "apsdir", "casDirectory", "apsVol", "CapDir", "capVol", "apsDirectory"], "licDir": ["volDoc", "lifManager", "lifDir", "libManager", "licManager", "libDoc", "lifDoc", "voldir", "volDir", "licdir", "volManager", "lifdir", "licDoc", "libdir", "libDir"], "midDir": ["middir", "casDir", "limTier", "mindDir", "limDir", "midTier", "casDIR", "casdir", "limDIR", "casTier", "mindTier", "mindDIR", "minddir", "midDIR", "limdir"], "filesDir": ["ballsPos", "ballsVol", "filesFolder", "pagesVol", "ballsDir", "pagesPos", "stylesDir", "FilesDir", "filesVol", "videosFile", "videosFolder", "imagesFile", " filesVol", "filesDur", "opensDIR", "stylesDirectory", "stylesDIR", "videosDirectory", "filesPos", "filesDirectory", "opensDirectory", "filesDIR", "opensDur", "stylesDur", "locksDirectory", "imagesDir", "locksDIR", "imagesDirectory", " filesPos", "FilesFolder", "FilesDirectory", "pagesDir", "imagesFolder", "FilesFile", "opensDir", "filesFile", "locksDir", "locksDur"], "videosDir": ["viewsUrl", "videosDb", "videoUrl", "videoFile", " videosDb", " videosDirectory", "videosFile", "viewsDir", "viewsDirectory", "videosDirectory", "viewsFile", "imagesDir", " videosFile", "videoDb", " videosUrl", "imagesDb", "videosUrl", "videoDirectory", "videoDir"], "imagensDir": ["imgentsFile", " imagensDirectory", " imagersDirectory", "imagentsFile", "imagenciesDir", "imgensDir", " imagensFile", " imagersFile", "imgensDirectory", "imagersDirectory", "imgentsDirectory", "imgentsDIR", " imagersJar", "imagentsJar", "imgentsDir", "imagersDIR", "imagenJar", "imagenFile", "imagensDirectory", "imagersDir", " imagersDir", "imagenciesDirectory", "imgensFile", "imgensDIR", "imagensDIR", "imagenDirectory", "imagenciesDIR", "imagenciesFile", "imagensJar", "imagersJar", "imagenDir", " imagensJar", "imagersFile", "imagentsDir", "imagentsDIR", "imagentsDirectory", "imagensFile"], "local": ["request", "where", "localhost", "shared", "p", "upload", "same", "defined", "tmp", "global", "user", "basic", "managed", "internal", "serial", "pal", "input", "directory", "valid", "json", "home", "loc", "relative", "state", "location", "safe", "path", "inner", "standard", "http", "conf", "file", "available", "part", "dir", "util", "active", "Location", "prefix", "pass", "base", "Local", "data", "temp", "LOC", "log", "partial", "personal", "total", "name", "l", "small", "specified", "d", " Local", "remote", "present", "lock", "current", "back", "self", "initial", "username"], "srcCss1": ["srcRcss0", "srcCpe4", "srcCrss1", "srcCss11", "srcCrss3", "srcRss2", "srcPss81", "srcRss0", "srcCcss0", "srcPcss1", "srcPssPre", "srcCss81", "srcRss1", "srcCse1", "srcCcss1", "srcRcss2", "srcCrss2", "srcPss1", "srcCass2", "srcCass0", "srcCcssPre", "srcPcss2", "srcPcss3", "srcCpe1", "srcPcssPre", "srcCpe2", "srcCcss81", "srcCpePre", "srcRcss11", "srcCass1", "srcCssPre", "srcRss81", "srcRss11", "srcCfg1", "srcCass3", "srcCrss11", "srcCcss3", "srcRcss81", "srcPcss4", "srcCse2", "srcPss3", "srcCcss4", "srcRcss1", "srcPcss81", "srcCcss2", "srcCse11", "srcCfg4", "srcCass81", "srcCcss11", "srcCrss81", "srcCass11", "srcCse0", "srcCss0", "srcCfg2", "srcPss4", "srcPss2", "srcCfgPre"], "destCss1": ["destCass1", "destPcss3", "destPssCard", "destCcss3", "destCfg3", "destPcss81", "destPss2", "destCss0", "destCrss81", "destCxxCard", "destPcss1", "destCxx1", "destCass81", "destCass3", "destCss81", "destCssCard", "destPss0", "destCcss2", "destCcss1", "destCcssCard", "destCfg1", "destPcss2", "destCass2", "destCrss1", "destCcss0", "destCfg0", "destCassCard", "destCrss0", "destCfg2", "destCrss2", "destPcssCard", "destCxx3", "destPss1", "destCrss3", "destPss3", "destPcss0", "destCxx2", "destCcss81", "destPss81"], "srcCss2": ["srcCcssL", "srcCass52", "srcCrssL", "srcCssTwo", "srcCrss1", "srcChessTwo", "srcCssB", "srcCrss3", "srcCss27", "srcChess1", "srcUcssTwo", "srcCfgL", "srcCng27", "srcCross4", "srcPss27", "srcChessB", "srcAcss2", "srcPcss1", "srcUssTwo", "srcCross1", "srcCrss2", "srcCcss1", "srcPss1", "srcUcss1", "srcCass2", "srcUcssB", "srcAccss2", "srcAccss52", "srcPcss27", "srcCross2", "srcPcss2", "srcPcss3", "srcCng1", "srcCng2", "srcCass1", "srcPssL", "srcCcss27", "srcUcss2", "srcChess2", "srcCfg1", "srcAcss4", "srcPcssL", "srcCcss3", "srcPss3", "srcCcss4", "srcCcss52", "srcCssL", "srcCcssB", "srcCfg3", "srcCfgB", "srcAccss1", "srcCass4", "srcCcss2", "srcCcssTwo", "srcUss1", "srcUss2", "srcAcss52", "srcCfgTwo", "srcCss52", "srcUssB", "srcAccss4", "srcCross52", "srcCrss27", "srcAcss1", "srcCfg2", "srcPss2"], "destCss2": ["destCess1", "destCfg3", "destCcss72", "destCcss3", "destNcss32", "destNcss2", "destNss1", "destCess32", "destCest2", "destCcss4", "destCcssB", "destCess4", "destNcss3", "destNcssB", "destNss2", "destNss32", "destCcss32", "destCfg32", "destNss4", "destCest3", "destCcss2", "destCcss1", "destNssB", "destNcss4", "destCfg1", "destNss72", "destCess72", "destCfgB", "destCfg4", "destNss3", "destCess2", "destCestB", "destCssB", "destCfg2", "destNcss72", "destCfg72", "destCest1", "destCss32", "destNcss1", "destCss72"], "srcCss3": ["srcRss2", "srcCsh183", "srcScss3", "srcCsl183", "srcRss1", "srcScstyle93", "srcCssThird", "srcCstyle6", "srcScstyle2", "srcCsh2", "srcCcss4", "srcCstyleAND", "srcPss6", "srcCstyle15", "srcCstyle93", "srcCfg2", "srcCcss93", "srcCss15", "srcCssAND", "srcCsl3", "srcCstyle3", "srcCss183", "srcCass2", "srcRcss3", "srcCcss15", "srcCrss6", "srcRss3", "srcCass1", "srcCfg1", "srcCcss3", "srcPss3", "srcClass3", "srcRcss1", "srcCss93", "srcPcss6", "srcCass4", "srcCcssThird", "srcCrss3", "srcScstyle3", "srcCstyle2", "srcCcss6", "srcClass2", "srcRcss183", "srcClass15", "srcPcss2", "srcPssAND", "srcCrssAND", "srcClass93", "srcCass3", "srcRssThird", "srcCslThird", "srcCsh3", "srcRss183", "srcCsl2", "srcRcss4", "srcCfg3", "srcCfg4", "srcRss4", "srcRcssThird", "srcPcss3", "srcScss93", "srcCcss183", "srcCrss2", "srcRcss2", "srcCcss1", "srcScss15", "srcPcssAND", "srcCcssAND", "srcScss2", "srcCshThird", "srcScstyle15", "srcCcss2", "srcPss2"], "destCss3": ["destPcss3", "destCcss3", "destCross3", "destNcss2", "destCstyle2", "destScss183", "destCstyle03", "destCja6", "destPss2", "destScss3", "destCrss183", "destCss43", "destCross03", "destCstyle53", "destCstyle43", "destCross53", "destNcss3", "destScrss2", "destCrss6", "destNss2", "destNss43", "destScrss6", "destCass3", "destNcss43", "destCss53", "destScss6", "destCja3", "destPcss53", "destPcss03", "destCcss2", "destScrss3", "destCstyle3", "destPcss2", "destCass2", "destCss03", "destPss53", "destScrss183", "destCss183", "destNss3", "destCja183", "destScss2", "destCja2", "destCrss2", "destCcss6", "destCross2", "destCrss3", "destPss3", "destCcss183", "destPss03", "destCcss53", "destCcss03", "destCcss43", "destCass43"], "srcCss4": ["srcCrss1", "srcPcss1", "srcPssFour", "srcCrss2", "srcCcss1", "srcPss1", "srcCass2", "srcPcss2", "srcCass1", "srcCssFour", "srcCassFour", "srcCrss4", "srcCrssFour", "srcCcssFour", "srcPcss4", "srcCcss4", "srcPcssFour", "srcCcss2", "srcCass4", "srcPss4", "srcPss2"]}}
{"id1": "8216539", "id2": "21608109", "code1": "    protected String getFileContentAsString(String filePath, String encoding) throws IOException {\n        URL testURL = Thread.currentThread().getContextClassLoader().getResource(filePath);\n        InputStream input = null;\n        StringWriter sw = new StringWriter();\n        try {\n            if (testURL != null) {\n                input = testURL.openStream();\n            } else {\n                input = new FileInputStream(filePath);\n            }\n            IOUtils.copy(input, sw, encoding);\n        } finally {\n            if (input != null) {\n                input.close();\n            }\n        }\n        return sw.toString();\n    }\n", "code2": "    public static boolean loadContentFromURL(String fromURL, String toFile) {\n        try {\n            URL url = new URL(\"http://bible-desktop.com/xml\" + fromURL);\n            File file = new File(toFile);\n            URLConnection ucon = url.openConnection();\n            InputStream is = ucon.getInputStream();\n            BufferedInputStream bis = new BufferedInputStream(is);\n            ByteArrayBuffer baf = new ByteArrayBuffer(50);\n            int current = 0;\n            while ((current = bis.read()) != -1) {\n                baf.append((byte) current);\n            }\n            FileOutputStream fos = new FileOutputStream(file);\n            fos.write(baf.toByteArray());\n            fos.close();\n        } catch (IOException e) {\n            Log.e(TAG, e);\n            return false;\n        }\n        return true;\n    }\n", "label": 0, "substitutes": {"getFileContentAsString": ["getFileContentInText", "getFileContentFromString", "getFilecontentInStream", "getFileContentFromStream", "getFilecontentAsString", "getFileContentInStr", "getFileContentFromText", "getFilecontentAsStream", "getFileContentInStream", "getFileContentAsText", "getFilecontentAsText", "getFilecontentAsStr", "getFileContentFromStr", "getFilecontentInText", "getFileContentasStream", "getFileContentasStr", "getFileContentAsStr", "getFileContentasString", "getFilecontentInString", "getFileContentAsStream", "getFileContentasText", "getFilecontentInStr", "getFileContentInString"], "filePath": ["baseName", "FileStr", "FileLocation", "resourcePath", "basePath", "filepath", "singleUrl", "basepath", "fileStr", "baseStr", "fileLocation", "singlePath", "FileName", "baseLocation", "singlepath", "fileUrl", "singleLocation", "FilePath", "resourcepath", "baseUrl", " fileUrl", "fileName", "resourceName", " fileStr", "resourceLocation", " filepath", "Filepath", "FileUrl"], "encoding": ["equoding", "Enclocking", "encging", "decoded", "Encoded", "Encging", "enclocking", "languageging", "cryption", "encpling", "languagepling", "languagelocking", "coded", "encryption", "encoded", "Encryption", "coding", "equlocking", "Encoding", "Encpling", "encasing", "casing", "decasing", "decoding", "equpling", "equging", "Encasing", "decryption", "languageoding"], "testURL": ["appUR", "testTL", "testingURI", "testUR", "testingUrl", "shortTL", "fileRL", "appURL", "testingTL", "testRL", " testUrl", "testingRL", "testingURL", "testURI", "shorturl", "testUrl", "TestURL", "fileUrl", " testURI", "fileURI", "TestUR", "testurl", "appUrl", "TestUrl", " testTL", "appurl", "shortUrl", " testRL", "shortURL", "Testurl", "testingUR", "testingurl", " testurl", "fileURL"], "input": ["get", "image", "error", "in", "client", "upload", "element", "entry", "stream", "ink", "i", "output", "form", "socket", "but", "feed", "rc", "ou", "instance", "init", "through", "parent", "conn", "inf", "result", "connection", "dc", "http", "inner", "path", "resource", "pull", "acl", "audio", "xml", "ssl", "img", "out", "raw", "op", "qa", "file", "inside", "url", "binary", "enc", "null", "this", "wrapper", "exec", "api", "data", "temp", "type", "ack", "Input", "text", "active", "bin", "reader", "flow", "act", "current", "source", "config", "ac", "inc"], "sw": ["sc", "writer", "Sw", "sl", "ow", "stream", "rc", "sk", "tw", "ib", "cr", "ew", "rx", "sn", "sa", "sb", "sf", "sh", " SW", "io", "fp", "rew", "work", "ww", "now", "wr", "we", "aw", "iw", "hw", "rw", "en", "SW", "sm", "wrapper", "wb", "wp", "w", "nw", "WS", "wrap", "wt", "wx", "web", "sv", "ws"]}}
{"id1": "20310134", "id2": "8932510", "code1": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    @Override\n    public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException {\n        InputStream is = null;\n        InputStream page = null;\n        OutputStream os = null;\n        String rootUrl = null;\n        try {\n            boolean isMultipart = ServletFileUpload.isMultipartContent(request);\n            if (!isMultipart) {\n                request.setAttribute(\"error\", \"Form isn't a multipart form\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ServletFileUpload upload = new ServletFileUpload();\n            String webUrl = null;\n            FileItemIterator iter = upload.getItemIterator(request);\n            while (iter.hasNext()) {\n                FileItemStream item = iter.next();\n                String name = item.getFieldName();\n                if (name.equals(\"webpage\")) {\n                    is = item.openStream();\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                    IOUtils.copy(is, baos);\n                    page = new ByteArrayInputStream(baos.toByteArray());\n                } else if (name.equals(\"weburl\")) {\n                    InputStream wpIs = null;\n                    try {\n                        webUrl = Streams.asString(item.openStream());\n                        URL u = new URL(webUrl);\n                        wpIs = new BufferedInputStream(u.openStream());\n                        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                        IOUtils.copy(wpIs, baos);\n                        page = new ByteArrayInputStream(baos.toByteArray());\n                    } finally {\n                        IOUtils.closeQuietly(wpIs);\n                    }\n                } else if (name.equals(\"rooturl\")) {\n                    rootUrl = Streams.asString(item.openStream());\n                }\n            }\n            if (page == null) {\n                request.setAttribute(\"error\", \"Form doesn't have an html file\");\n                RequestDispatcher rd = request.getRequestDispatcher(\"/WEB-INF/error.jsp\");\n                rd.forward(request, response);\n            }\n            ToMailerDelegate delegate = new ToMailerDelegate(page, rootUrl);\n            os = new BufferedOutputStream(response.getOutputStream());\n            os.write(delegate.getMailer());\n            os.flush();\n        } catch (Exception e) {\n            streamException(request, response, e);\n        } finally {\n            IOUtils.closeQuietly(page);\n            IOUtils.closeQuietly(is);\n            IOUtils.closeQuietly(os);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "ic", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "as", "again", "lock", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "n", "off", "output", "default", "user", "write", "ex", "page", "server", "cache", "conn", "connection", "ext", "resource", "io", "img", "file", "x", "dot", "o", "prefix", "exec", "base", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "external", "OUT", "c"], "inChannel": ["outStream", "insStream", "InQueue", "inputChannel", "InGate", "inchannel", " inchannel", "INStream", "iniChannel", "INChan", "outchannel", "loginchannel", "outChan", "binChannel", " inChan", "iniStream", "inQueue", "iniGate", "InStream", "inputConnection", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", "loginChan", "outQueue", "InChannel", "inConnection", "loginChannel", "Inchannel", "insChan", "inGate", "INchannel", " inQueue", "INConnection", "loginStream", "binGate", "insConnection", "insChannel", "iniChan", "inputStream", "binStream", "inStream"], "outChannel": ["outGate", "outStream", " outchannel", "inchannel", " outGate", "netStream", "OutChan", "outchannel", "outChan", "OutChannel", "outputChan", "outputStream", "OutConnection", " outChar", "outputchannel", "ouGate", " outChan", "outputChannel", " outConnection", " outStream", "Outchannel", "ouChan", "outChar", "inChan", "outConnection", "inConnection", "netChan", "ouChannel", "inGate", "outputChar", "netChannel", "inChar", "ouchannel", "netGate", "outputGate", "inStream"]}}
{"id1": "14877116", "id2": "149935", "code1": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"cpFile": ["CopyFiles", " copyFiles", " copyfile", "CopyCode", "cpCode", " cpCode", " cpfile", " copyCode", "cpFiles", "cpfile", " cpFiles", "CopyFile", " copyFile", "Copyfile"], "source": ["image", "client", "template", "component", "service", "element", "stream", "host", "ce", "object", "view", "use", "context", "slice", "scope", "reference", "parent", "route", "directory", "archive", "server", "scene", "from", "connection", "grade", "path", "resource", "se", "dest", "file", "Source", "secure", "config", "start", "iter", "url", "this", "null", "base", "unit", "zip", "channel", "type", "Target", "SOURCE", "subject", "database", "token", "force", "document", "name", "node", "table", "site", "remote", "string", "project", "seed", "current", "ource", "self", "ources"], "target": ["next", "client", "template", "component", "service", "sync", "master", "host", "output", "object", "proxy", "global", "owner", "reference", "parent", "copy", "route", "nt", "archive", "port", "server", "home", "origin", "to", "boot", "alias", "result", "format", "connection", "content", "tail", "path", "resource", "top", "dest", "file", "root", "director", "config", "iter", "url", "null", "base", "type", "download", "Target", "range", "database", "token", "transform", "force", "it", "other", "name", "table", "site", "external", "arget", "project", "remote", "folder", "tor", "current", "ource", "self"], "replace": ["match", "compatible", "sync", "align", "flash", "same", "delete", "reply", "use", "write", "copy", "route", "include", "complete", "apply", "share", "array", "rm", "only", "hide", "change", "fill", "cover", "root", "store", "update", "inline", "reset", "protect", "append", "range", "rel", "remove", "split", "force", "allow", "other", "stall", "follow", "place", "insert", "placed", "repeat", "add", "re", "multiple", "move", "repl"], "bufferSize": ["serversize", "bufferLen", "bufferCount", "queueCount", "bytesize", "flushsize", "byteSize", " buffersize", " bufferCount", "byteCount", "serverSIZE", "flushSize", " bufferLen", "bufferSIZE", "queueSize", "flushSIZE", "flushLen", "buffersize", "serverLen", "queuesize", "serverSize", "byteLen", "queueLen", " bufferSIZE"], "src": ["in", "sc", "ruby", "sl", "ctx", "sync", "obj", "flash", "stream", "rc", "socket", "tmp", "proxy", "input", "reflect", "copy", "archive", "RC", "sb", "server", "loc", "sh", "result", "bc", "rb", "inst", "resource", "cur", "ssl", "gb", "proc", "dest", "fn", "Source", "rec", "secure", "start", "sr", "sel", "url", "req", "zip", "sq", "rt", "sub", "sys", "gz", "ser", "ource", "cb", "ources"], "tarn": [" taron", "yarm", " tarm", " taran", "ntann", "ntarn", "Trn", "ttarn", "ttaron", "tarp", "etarn", "yern", "tron", "wtarn", "ttaro", " tron", "etreen", "yaran", " treen", "tern", "tharo", "wtaran", "ttern", "ttron", "thern", "ntaron", "Taran", "wtern", "ttaur", "tharn", "etann", " taur", "ttann", "Treen", "taro", "trn", "taur", "Tarm", "taron", "treen", " trn", "ttarp", "Tarn", " tann", "ttrn", " tern", "Tron", "yarn", "tarm", "thaur", "Tann", "ntarp", "taran", " taro", "ttarm", "tann", "etaran", " tarp", "wtarm"], "tardir": ["tildar", "Tartirs", "sardire", "tardar", "tardedir", "tildart", "Tartpath", "tardedpath", "tardspath", "tartirt", "tarpirt", "Tardpath", "Tardar", "Tarddir", "tartpath", "tardart", "tarpir", "tariri", "tartar", "tarpar", "Tartar", "tildiri", "tardsirs", "sardsir", "sardsirt", "tardsar", "Tartir", "tartdir", "tartirs", "tardirs", "tardsir", "tartire", "Tartiri", "Tardart", "tildir", "Tartart", "tarar", "tardiri", "tarpire", "tartir", "Tardiri", "tardeddir", "tardirt", "tardsire", "Tartdir", "tartiri", "tartart", "sardsire", "Tardirs", "sardsar", "sardar", "tardsirt", "tarir", "tardsdir", "sardir", "tardire", "sardirt", "tardedirs", "tarart", "tarddir", "Tardir", "tardpath"], "n": ["ne", "in", "m", "j", " i", "p", "nor", "g", "i", "cn", "na", "nn", "ln", "ns", "nu", "mn", "sn", "nt", "ng", "e", "coll", "N", "conn", "dn", "nc", "num", "z", "fn", "x", "min", "en", "o", "none", "k", "pn", "u", "ni", "norm", "v", "nw", "number", "rn", "l", "un", "d", "nl", "nb", "c"], "tar": ["buffer", "ca", "large", "shape", "flash", "transfer", "tmp", "par", "car", "cat", "copy", "cr", "tan", "tg", "archive", "cro", "sh", "dr", "sum", "safe", "cos", "war", "raf", "pack", "ray", "ra", "csv", "dest", "shr", "file", "rar", "box", "cloud", "tc", "sr", "zip", "temp", "trans", "test", "skip", "di", "ar", "tf", "tr", "gz", "tif", "jar", "sv", "Tar"], "bytes": ["items", "vals", "os", "words", "ipes", "steps", "files", "les", "bs", "cells", "ls", "reads", "es", "lines", "keys", "objects", "boot", "seconds", "tes", "bps", "io", "resources", "Bytes", "frames", "out", "pieces", "classes", "bits", "pages", "nets", "ones", "data", "b", "blocks", "values", "eps", "rows", "bles", "ops", "vs", "ps", "runs", "outs"], "readn": ["readno", "Readl", " readN", " readl", "passN", "writens", "readne", " readne", "findne", "readns", "writen", "findN", "passno", "writelen", "runlen", "writene", "readl", "writeno", "readN", "runl", "readlen", "Readlen", "findlen", "writeN", "ReadN", "runns", " readlen", "Readn", "passn", "passns", "runn", "runN", "runno", "findn"]}}
{"id1": "1485383", "id2": "14303294", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    public String getServerHash(String passwordHash, String PasswordSalt) throws PasswordHashingException {\n        byte[] hash;\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"SHA-256\");\n            digest.reset();\n            digest.update(PasswordSalt.getBytes(\"UTF-16\"));\n            hash = digest.digest(passwordHash.getBytes(\"UTF-16\"));\n            return bytesToHex(hash);\n        } catch (NoSuchAlgorithmException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed security algorithms. Please update Java\");\n        } catch (UnsupportedEncodingException ex) {\n            throw new PasswordHashingException(\"Current environment does not supply needed character encoding. Please update Java\");\n        }\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistInfo", "runGetApplicationListling", "runGetApplicationListing", "runGetAppListInfo", "runGetApplisting", "runGetAppSearchInfo", "runGetApplistInfo", "runGetApplicationListInfo", "runGetAppSupportInfo", "runGetApplistling", "runGetApplicationListings", "runGetApplicationlistling", "runGetAppSearching", "runGetAppSearchling", "runGetAppSearchings", "runGetApplicationlistings", "runGetAppSupportling", "runGetAppSupporting", "runGetApplicationlisting", "runGetAppListling", "runGetApplistings", "runGetAppSupportings", "runGetAppListings"], "url": ["image", "client", "buffer", "service", "i", "host", "proxy", "feed", "e", "route", "page", "json", "server", "address", "result", "connection", "http", "location", "URL", "resource", "path", "ssl", "build", "file", "f", "Url", "api", "base", "channel", "data", "builder", "download", "b", "l", "string", "href", "uri", "re", "source", "config"], "appListingList": ["appListingType", "appListingingGroup", "appListininglist", "appListitingData", "appListillingLibrary", "appListingLayer", "appHoldinglist", "appListingInfo", "appListningResult", "appLingList", "appListiningList", "appListningList", "appListINGL", "appListinglist", "appListingResult", "appPoolinglist", "appListingsLayer", "appListingingLibrary", "appListingMap", "appPoolingList", "appListillinglist", "appListdingList", "appListingingList", "appPooliningGroup", "appHoldingType", "appListitingResult", "appListitingEx", "appListdingLayer", "appListitinglist", "appPoolingGroup", "applistningResult", "appListitingLibrary", "appListinginglist", "appLeningList", "appListningData", "applistingResult", "appStingEx", "appPooliningList", "appListitingList", "appListninglist", "appListingData", "appListingEx", "appListdingEx", "appListingsList", "appListdingL", "appLingEx", "appStINGL", "appListeningInfo", "applistningList", "appHoldingingList", "appListgingEx", "applistingData", "appListINGEx", "appListillingType", "appListingLibrary", "appLingInfo", "appListINGLayer", "appStINGList", "appHoldingingType", "appListingsL", "appHoldingLibrary", "appListingsInfo", "appListitingType", "appHoldingingLibrary", "appListingL", "appListningEx", "appListiningGroup", "appListgingInfo", "applistingEx", "appStingList", "appHoldinginglist", "appListillingList", "appLeningMap", "appListingsEx", "applistningEx", "appListingsMap", "appListningGroup", "appLeningEx", "appListingsResult", "appLeningInfo", "applistningData", "appStingL", "applistingList", "appListINGList", "appStINGEx", "appListgingList", "appListingsData", "appStINGLayer", "appListeningEx", "appListingGroup", "appHoldingList", "appListingingType", "appListgingMap", "appListeningList", "appStingLayer", "appListeningMap", "appLingMap", "appPoolininglist"], "request": ["get", "job", "r", "next", "client", "buffer", "writer", "service", "rate", "query", "hello", "queue", "q", "transfer", "object", "use", "proxy", "input", "user", "parse", "e", "page", "json", "server", "address", "complete", "child", "result", "http", "resource", "report", "message", "xml", "build", "post", "req", "trip", "callback", "builder", "application", "method", "call", "have", "Request", "remote", "project", "command", "push", "uri", "re", "create", "condition"], "readTimeout": ["writeTime", "writeSocket", "readertimeout", " readtimeout", "readingAttempt", "writeTimeout", "readingtimeout", "readingTimeout", "readtimeout", "readingSocket", "readTime", " readSocket", " readTime", "readerTime", "readSocket", "readAttempt", "writeAttempt", "readerAttempt", "readingTime", "readerTimeout", "writetimeout"], "response": ["next", "image", "success", "error", "client", "writer", "stream", "received", "full", "output", "reply", "object", "feed", "version", "e", "page", "json", "server", "result", "connection", "http", "array", "resource", "report", "message", "Response", "resp", "api", "onse", "data", "status", "application", "wave", "document", "res", "site", "body", "respond", "generation", "re"]}}
{"id1": "3053403", "id2": "22560224", "code1": "    public static void main(String[] args) throws Exception {\n        FileChannel fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes()));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        ByteBuffer buff = ByteBuffer.allocate(BSIZE);\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        buff.rewind();\n        String encoding = System.getProperty(\"file.encoding\");\n        System.out.println(\"Decoded using \" + encoding + \": \" + Charset.forName(encoding).decode(buff));\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        fc.write(ByteBuffer.wrap(\"Some text\".getBytes(\"UTF-16BE\")));\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n        fc = new FileOutputStream(\"data2.txt\").getChannel();\n        buff = ByteBuffer.allocate(24);\n        buff.asCharBuffer().put(\"Some text\");\n        fc.write(buff);\n        fc.close();\n        fc = new FileInputStream(\"data2.txt\").getChannel();\n        buff.clear();\n        fc.read(buff);\n        buff.flip();\n        System.out.println(buff.asCharBuffer());\n    }\n", "code2": "    public static String hashStringMD5(String string) throws NoSuchAlgorithmException {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(string.getBytes());\n        byte byteData[] = md.digest();\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n        }\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < byteData.length; i++) {\n            String hex = Integer.toHexString(0xff & byteData[i]);\n            if (hex.length() == 1) hexString.append('0');\n            hexString.append(hex);\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"fc": ["fw", "sc", "irc", "flo", "lf", "bf", "console", "fa", "full", "ff", "fd", "rc", "cc", "cs", "feed", "hub", "fi", "fl", "fen", "il", "rx", "lc", "cf", "circ", "FC", "xf", "hl", "fm", "sf", "fe", "loc", "conn", "fact", "bc", "dc", "fb", "nc", "af", "fat", "fp", "io", "exp", "ref", "central", "df", "raf", "con", "fn", "xc", "uc", "f", "roc", "col", "fs", "enc", "exec", "vc", "ac", "dl", "ll", "cl", "ct", "pc", "co", "fx", "mc", " FC", "wk", "win", "pl", "cb", "c", "inc", "ec"], "buff": ["font", "bu", "ctx", "prof", "cell", "comb", "fe", "info", "bc", "fb", "tab", "ob", "build", "pb", "bas", "box", "bd", "eb", "buf", "FF", "text", "front", "cod", "lab", "back", "cb", "ind", "abb", "p", "pp", "ff", "cp", "fam", "feed", "load", "bug", "gg", "fo", "butt", "cast", "home", "loc", "boot", "grab", "rb", "bm", "bl", "bag", "b", "uf", "comp", "hand", "bed", "xb", "np", "aff", "bet", "agg", "fab", "form", "app", "bb", "bo", "cf", "sb", "ref", "gb", "now", "bh", "null", "callback", "gap", "uff", "fx", "utf", "pl", "fw", "buffer", "both", "ph", "bf", "bg", "mb", "img", "Buff", "feat", "f", "obb", "loop", "config", "txt"], "encoding": ["decording", "encording", "decoded", "Encoded", " encaging", "enoder", " encryption", "ecryption", "enoding", "Encording", "Encoder", "encryption", "ecoded", "encoded", "Encryption", "ecoder", "decoder", "ecoding", "enryption", "enaging", "Encaging", "encaging", " encasing", "Encoding", "encasing", "decasing", "decoding", "encoder", " encoder", "Encasing", "decryption", " encording"]}}
{"id1": "20851065", "id2": "5049453", "code1": "    public void open(String openStr) throws IOException {\n        String commProtocol = \"comm:\";\n        String rxtxProtocol = \"rxtx:\";\n        String netProtocol = \"net:\";\n        if (openStr.startsWith(commProtocol)) {\n            CommConnection commConnection = CommConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(commConnection.getInputStream());\n            this.setOutputStream(commConnection.getOutputStream());\n        } else if (openStr.startsWith(rxtxProtocol)) {\n            RXTXConnection rxtxConnection = RXTXConnection.open(openStr.substring(commProtocol.length()));\n            this.setInputStream(rxtxConnection.getInputStream());\n            this.setOutputStream(rxtxConnection.getOutputStream());\n        } else if (openStr.startsWith(netProtocol)) {\n            SocketConnection socketConn = SocketConnection.open(openStr.substring(netProtocol.length()));\n            this.setInputStream(socketConn.getInputStream());\n            this.setOutputStream(socketConn.getOutputStream());\n        } else {\n            URL url = new URL(openStr);\n            URLConnection urlConn = url.openConnection();\n            this.setInputStream(urlConn.getInputStream());\n            try {\n                this.setOutputStream(urlConn.getOutputStream());\n            } catch (UnknownServiceException e) {\n            }\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"open": ["opening", "get", "error", "connect", "accept", "opened", "size", "large", "ize", "one", "stream", "all", "full", "join", "use", "init", "construct", "on", "complete", "run", "register", "from", "plus", "connection", "media", "code", "php", "show", "Open", "build", "oa", "start", "link", "en", "close", "opens", "exec", "set", "update", "make", "type", "bind", "co", "call", "Connect", "list", "uri", "escape", "add", "current", "lock", "closed", "create", "config", "empty"], "openStr": ["closeString", "buildText", "parseStr", "newSt", "enableSTR", "closeLine", "closestr", "parseText", "closeSTR", "OpenStr", "parseSTR", "lockBr", "buildSTR", "closeText", " openText", "coString", "openBr", "closeBr", "OpenString", "enableStr", "lockStr", "Openstr", "coStr", "buildStr", "fullstr", "openString", " openstr", " openBr", "lockSTR", "fullStr", " openLine", "OpenSTR", "fullLine", "coSTR", " openSt", "lockText", "openLine", "OpenSt", "openText", "enableText", "fullString", "closeSt", "openSTR", "openSt", " openString", " openSTR", "buildString", "newStr", "newstr", "OpenBr", "openstr", "newString", "closeStr", "OpenText", "costr"], "commProtocol": ["commprotository", "commMono", "CommMonicle", "commProicle", "comProtository", "commProtport", "comprototype", "commPrefocol", "commShortocol", "cmdprotport", "commprotection", "commLogotype", "CommProticle", "commprototype", "commPatocol", "commShortection", "cmdprotocol", "commProtository", "CommMono", "commProto", "commprotocol", "CommMonocol", "comprotository", "commInterport", "commLogport", "commProticle", "commLogocol", "cmdProtocol", "commInterotype", "cmdProtport", "commInterector", "comprotocol", "cmdPrototype", "commLogector", "commPatository", "commprotector", "commProtection", "CommProtocol", "commProo", "comprotection", "commproticle", "commProocol", "commPhocol", "comProtection", "commMonicle", "cmdProtector", "comPrototype", "commPhotype", "commShortotype", "commInterocol", "cmdprotector", "commMonocol", "comProtocol", "commPrefotype", "cmdprototype", "commProtector", "commPrototype", "CommProto", "commprotport", "commPhository", "commPrefection", "commproto", "commPatotype"], "rxtxProtocol": ["rxtXprototype", "rxtaxProtoc", "rxtxProtost", "rxtXPrototype", "rxtXProtost", "rxtxPhotype", "rxtxPhost", "rxtxProtoc", "rxtxProoc", "rxtxPrefotype", "rxtxprototype", "rxtaxprototype", "rxtxProocol", "rxtxProtose", "rxtxProost", "rxtxPhocol", "rxtXProtose", "rxtxprotost", "rxtxprotocol", "rxtxPrototype", "rxtxPrefocol", "rxtxPhose", "rxtaxprotoc", "rxtXprotocol", "rxtxprotoc", "rxtXprotose", "rxtxProose", "rxtXprotost", "rxtxProotype", "rxtaxPrototype", "rxtXProtocol", "rxtxPrefoc", "rxtaxprotocol", "rxtxprotose", "rxtaxProtocol"], "netProtocol": ["natprototype", "networkprototype", "netprotection", "natProtocol", "networkprotocol", "netTypeection", "netProtunct", "netSecondotype", "netRobotype", " netProocol", "netPrefotype", "netSecondunct", "natProtort", "netTypeotype", "netProection", "netRobort", "netProtology", "networkProtection", "natProtunct", "natPrototype", "networkPrototype", "netprotunct", " netProology", "netPrototype", "netprototype", "netprotocol", "natprotocol", "netProtort", "netprotology", "netProtection", "netTypeocol", "networkProtocol", "netRobocol", "netSecondort", "netSecondocol", "natprotunct", "netProology", "netProocol", " netPrototype", " netProotype", "netRobunct", "networkprotection", "netProotype", "natprotort", " netProtology", "netprotort", "netPrefocol", "netPrefology"], "commConnection": ["cmConnect", "cmdConnect", "Commconnection", "CommConnector", "cmconnection", "cmChannel", "comConnector", "ommConnector", "cmdConnection", "cmClient", "ommConnection", "ommConnect", "CommChannel", "commClient", "comConnect", "cmConnector", "CommConn", "comConnection", "commConnector", "commConnect", "cmdconnection", "ommChannel", "commConn", "cmConnection", "commconnection", "CommConnect", "CommClient", "commChannel", "comConn", "CommConnection", "cmdClient", "cmConn"], "rxtxConnection": ["rxtlexConn", "rextxConn", "rextaxChannel", "rxtaxconnection", "rxtXConn", "rextxConnect", "rextaxConn", "rXTxConnection", "rxtXConnection", "rextxChannel", "rxtaxConnect", "rxtyConnect", "rXTaxConnection", "rxtlexConnection", "rextaxConnection", "rextaxConnect", "rxtXChannel", "rxtxChannel", "rxtlexChannel", "rxtaxChannel", "rXTxConn", "rXTaxConn", "rxtaxConn", "rxtXConnect", "rXTaxconnection", "rXTxConnect", "rxtxConnect", "rxtxconnection", "rextxConnection", "rxtyConn", "rxtXconnection", "rXTxconnection", "rXTaxConnect", "rxtxConn", "rxtlexConnect", "rxtyConnection", "rxtyconnection", "rxtaxConnection", "rxtlexconnection"], "socketConn": ["socketConnector", "networkChan", " socketConnect", "netConnector", "sslConnection", "socketConnection", " socketconn", "netConnection", " socketConnector", "sslChan", "ocketConnector", "sslconn", "ocketconn", "networkconn", " socketConnection", "socketconn", "networkConn", "networkConnector", "socketConnect", "sslConn", "netConn", "netconn", "sslConnect", "cosConn", "ocketConn", "cosConnect", "cosConnection", "ocketChan", "sslConnector", "socketChan"], "url": ["image", "r", "ball", "blog", "large", "service", "sl", "key", "user", "page", "server", "bel", "conn", "connection", "http", "location", "URL", "path", "resource", "pull", "ob", "ssl", "file", "build", "str", "link", "f", "Url", "base", "download", "control", "log", "b", "ll", "l", "browser", "string", "web", "ur", "uri", "config"], "urlConn": ["UrlConnection", " urlCmd", "logDr", "urlCon", " urlConnect", "fileDr", "baseConn", "sslWin", "URLCmd", "UrlCon", "baseCon", "lConnection", "UrlConn", "fileConnect", "logConnect", "urlConnect", "urlCmd", "UrlConnect", "logSync", "urlDr", " urlDr", "sslConn", "fileSync", "fileConn", "baseConnect", " urlSync", "urlConnection", "lConnect", "lConn", "urlWin", "baseConnection", "URLWin", "lCon", "URLConn", "urlSync", "logConn", "sslCmd", " urlWin"]}}
{"id1": "19549489", "id2": "13362846", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    public static void setContenu(ContenuFichierElectronique contenuFichier, FichierElectronique fichierElectronique, UtilisateurIFGD utilisateurCourant) throws IOException, DocumentVideException {\n        if (contenuFichier != null) {\n            SupportDocument support = fichierElectronique.getSupport();\n            support.setFichierElectronique(fichierElectronique);\n            FicheDocument ficheDocument = support.getFicheDocument();\n            String nomFichier = contenuFichier.getNomFichier();\n            String extension = FilenameUtils.getExtension(nomFichier);\n            if (ficheDocument.getFichierElectronique(nomFichier) != null) {\n                FichierElectronique fichierElectroniqueExistant = ficheDocument.getFichierElectronique(nomFichier);\n                if (fichierElectroniqueExistant.getId() != null && !fichierElectroniqueExistant.getId().equals(fichierElectronique.getId())) {\n                    throw new FichierElectroniqueExistantException(nomFichier, ficheDocument);\n                }\n            }\n            if (fichierElectronique.getId() == null) {\n                if (OfficeDocumentPropertiesUtil.canWriteIdIGID(extension)) {\n                    Long idIgid = OfficeDocumentPropertiesUtil.getIdIGID(contenuFichier);\n                    if (idIgid != null) {\n                        throw new FichierElectroniqueExistantException(nomFichier, idIgid, ficheDocument);\n                    }\n                }\n            }\n            InputStream inputStream = contenuFichier.getInputStream();\n            OutputStream outputStream = fichierElectronique.getOutputStream();\n            try {\n                IOUtils.copy(inputStream, outputStream);\n            } finally {\n                try {\n                    inputStream.close();\n                } finally {\n                    outputStream.close();\n                }\n            }\n            String typeMime = contenuFichier.getContentType();\n            long tailleFichier = contenuFichier.getTailleFichier();\n            Date dateDerniereModification = new Date();\n            fichierElectronique.setNom(nomFichier);\n            fichierElectronique.setTypeMime(extension);\n            creerFormatSiNecessaire(typeMime, extension);\n            fichierElectronique.setTaille(tailleFichier);\n            fichierElectronique.setDateDerniereModification(dateDerniereModification);\n            fichierElectronique.setSoumetteur(utilisateurCourant);\n            if (extension.endsWith(\"msg\")) {\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, contenuFichier.getInputStream(), utilisateurCourant);\n            } else if (extension.endsWith(\"eml\")) {\n                Map<String, Object> properties = new GestionnaireProprietesMimeMessageParser().parseMsg(contenuFichier.getInputStream());\n                CourrielUtils.peuplerMetadonneesCourriel(fichierElectronique.getNom(), ficheDocument, properties, utilisateurCourant);\n            } else {\n                FGDProprietesDocumentUtils.copierMetadonneesProprietes(fichierElectronique, ficheDocument);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["clone", "p", "sync", "upload", "Transfer", "all", "transfer", "delete", "Copy", " move", "write", "Cop", " transfer", " copied", "cop", "io", " copying", "file", "zip", "download", "create", "paste", "split", " Copy", " copies", "source", "move"], "sourceFile": ["servicefile", "serviceFile", "sourceFILE", "resourcefile", "searchfile", "siteFiles", "Sourcefile", "sourcefile", " sourceDirectory", "searchFile", "serviceFilename", "serviceFiles", "SourceFILE", " sourcefile", "siteFile", " sourceFilename", " sourceFiles", "resourceFile", " sourceFILE", "resourceFiles", "sourceDirectory", "SourceDirectory", "SourceFile", "siteFILE", "SourceFiles", "searchFilename", "siteDirectory", "searchFiles", "sourceFilename", "resourceDirectory", "sourceFiles"], "destinationFile": ["destinationDirectory", "destinatedFile", "DestinationDir", "Destinatorfile", "DestinatorFile", "destinatedFiles", "destinatorFile", "destinatedImage", "Destinationfile", "destationFiles", "distinatedImage", "destinatorDir", "DestinatorDir", "DestinatorFiles", "distinatedDirectory", "distinationFile", "destationFile", "destinatorDirectory", "destinatorImage", "destinationfile", "destationfile", "destinatedDir", "destationDirectory", "destinationDir", "destinatorfile", "destinationImage", "destinatorFiles", "destinationFiles", "destationDir", "distinatedFile", "DestinationFiles", "distinationImage", "distinationDirectory", "destationImage", "destinatedfile", "DestinationFile", "distinatedFiles", "destinatedDirectory", "distinationFiles"], "sourceFileChannel": ["ourceStreamStream", "targetLibraryChan", " sourceFileService", "targetFileChannel", "sourceStreamService", "sourceDirectorySocket", "sourceDirchannel", "sourceFileSocket", "sourceDirChan", "sourceFilesContext", "sourceFileClient", "sourceLineChan", "sourceFileContext", "sourceFileConnection", "sourceFilechannel", "sourceDirStream", "ourceFileChannel", " sourceFileConnection", "sourceLibraryChan", "sourceLineSocket", "sourceStreamStream", "sourceFunctionContext", "sourceLibraryClient", "sourceStreamchannel", "sourceStreamChan", " sourceFilesConnection", " sourceFileContext", "sourceDirectoryClient", "ourceStreamChan", "sourceFileService", "sourceStreamChannel", "sourceFunctionChannel", "ourceFileChan", "sourceLineClient", "sourceDirectoryChannel", "sourceLibrarySocket", " sourceFilesChannel", "sourceLibraryChannel", "targetFileClient", "sourceStreamContext", "sourceLineChannel", " sourceFilesService", "targetFileChan", "targetLibraryClient", " sourceFilesContext", "sourceStreamConnection", "targetLibraryChannel", "sourceFileChan", "ourceFileStream", "ourceStreamChannel", "targetFileSocket", "sourceDirChannel", "sourceLinechannel", "sourceLineStream", "sourceFilesChannel", "sourceDirectoryChan", "ourceStreamchannel", "sourceFunctionConnection", "sourceFilesService", "ourceFilechannel", "sourceFilesConnection", "sourceFileStream", "targetLibrarySocket", "sourceFunctionService"], "destinationFileChannel": ["destinationFilesClient", "destinatorFileService", "destinationFilesChan", "destinationDirectoryChannel", "destinatorFilesClient", "destinationLineService", "destinationFileConnection", "destinationFileService", "destinationFilesService", "destinationIOChannel", "destinatorFileClient", "destinationLineChannel", "destinationFileClient", "destinationLineChan", "destinationFileHandler", "destinationLineConnection", "destinationFilesHandler", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileConnection", "destinationDirectoryConnection", "destinatorFilesChannel", "destinatorFilesConnection", "destinationFilesChannel", "destinatorFilesService", "destinationFilesConnection", "destinationFileChan", "destinatorFileCache", "destinationDirectoryHandler", "destinationDirectoryService", "destinationLineHandler", "destinatorFilesCache", "destinatorFileHandler", "destinatorFilesChan", "destinationFilesCache", "destinationFileCache", "destinationDirectoryCache", "destinatorFileChan", "destinationLineClient", "destinationIOService", "destinationIOCache", "destinatorFileChannel", "destinationIOClient", "destinatorFilesHandler"]}}
{"id1": "20663364", "id2": "19608872", "code1": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "code2": "    public void genDropSchema(DiagramModel diagramModel, boolean foreignKeys) {\n        try {\n            con.setAutoCommit(false);\n            stmt = con.createStatement();\n            Collection boxes = diagramModel.getBoxes();\n            BoxModel box;\n            String sqlQuery;\n            if (foreignKeys) {\n                for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                    box = (BoxModel) x.next();\n                    if (!box.isAbstractDef()) {\n                        dropForeignKeys(box);\n                    }\n                }\n            }\n            int counter = 0;\n            for (Iterator x = boxes.iterator(); x.hasNext(); ) {\n                box = (BoxModel) x.next();\n                if (!box.isAbstractDef()) {\n                    sqlQuery = sqlDropTable(box);\n                    System.out.println(sqlQuery);\n                    try {\n                        stmt.executeUpdate(sqlQuery);\n                        counter++;\n                    } catch (SQLException e) {\n                        String tableName = box.getName();\n                        System.out.println(\"// Problem while dropping table \" + tableName + \" : \" + e.getMessage());\n                        String msg = Para.getPara().getText(\"tableNotDropped\") + \" -- \" + tableName;\n                        this.informUser(msg);\n                    }\n                }\n            }\n            con.commit();\n            if (counter > 0) {\n                String msg = Para.getPara().getText(\"schemaDropped\") + \" -- \" + counter + \" \" + Para.getPara().getText(\"tables\");\n                this.informUser(msg);\n            } else {\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            }\n        } catch (SQLException e) {\n            System.out.println(e.getMessage() + \" // Problem with the JDBC schema generation! \");\n            try {\n                con.rollback();\n                this.informUser(Para.getPara().getText(\"schemaNotDropped\"));\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection rollback! \");\n            }\n        } finally {\n            try {\n                con.setAutoCommit(true);\n                stmt.close();\n            } catch (SQLException e1) {\n                System.out.println(e1.getMessage() + \" // Problem with the connection disconnect! \");\n            }\n        }\n    }\n", "label": 1, "substitutes": {"testPreparedStatement0009": [" createPreparedStatement5008", " createPreparedstatement000Nine", " createPreparedStatement500Nine", " createPreparedStatement0006", " createPreparedStatement1508", " createPreparedStatement1506", " createPreparedStatement5009", " createPreparedStatement1509", " createPreparedstatement0009", " createPreparedstatement0006", " createPreparedstatement150Nine", " createPreparedStatement5006", " createPreparedStatement000Nine", " createPreparedStatement150Nine", " createPreparedStatement0009", " createPreparedStatement750Nine", " createPreparedstatement1509", " createPreparedStatement7509", " createPreparedstatement1506", " createPreparedstatement1508", " createPreparedStatement0008", " createPreparedStatement7506", " createPreparedstatement0008", " createPreparedStatement7508"], "stmt": ["ptmr", "pprict", "stmr", "stbl", "pmi", "tmp", "StMT", "pppl", "tmd", "stmi", "tmt", "Stmd", "prict", "ptmi", "stmd", "pmb", "stmp", "stMT", " strict", "stpl", " stmd", "Stmp", "pmt", "Stmb", "pmp", "ptmp", "ppl", "ppmt", "ptmb", " stmi", "strict", "tMT", " stpl", "pmr", " stmb", "Stbl", "Stmt", "ptmt", "stmb", " stmp", " stbl", "ppmp", " stmr", "ptbl", " stMT"], "pstmt": ["pctm", "pspsp", "copstatt", "prostemb", "prosthwd", "Pstmr", "Pctwt", "padmn", "pstmb", "pestmi", "padmt", " pstatdb", "pctmr", "punctsp", "padpl", "punctpl", "Pstbl", "pptmt", "pctmb", "Pstmb", "psttor", "psttm", "pestmr", "pctmt", "pftm", "pstmn", "copfrnl", " pctct", "pngtm", "ptwd", "Pctpl", "pfratt", "pstdbh", "pStmt", "pstrtor", "pestmb", "punctm", "pngdb", "pncmt", "Pctms", "ptmt", "pctmi", "Pstwd", "Pstms", "pstm", "pptnt", "pktwt", "pfmb", "pstatmt", "pngpl", "pstdatt", "ptemb", "prosthrt", "pwm", "pwmt", "pstpl", "pstrmt", "Pstm", "Pstsp", "Pstnt", "pstms", "psthwd", " pctpl", "pctwd", "pstdnl", " pstdb", "copfrmt", " pstatpl", "psctor", "pspct", "psthrt", "pstattm", "pncmn", "prosthmt", "pstrm", "Psttor", "pstrbh", "pfrnl", "pestnt", "pstrdb", "pctpl", "pstbl", "Pstmt", "prostmt", " pstatmt", "pftpl", "copstnl", " psttm", "copstmt", "pktmb", "pncpl", "pestbl", "padms", "pfmt", "pstmr", "Pstpl", "Pctmr", "pctwt", "pestmt", "Pctmi", "punctmt", "pctmn", "pstrwd", "pctct", "pStemb", "pstatt", "pscm", "pstrt", "pfrmt", "pfnt", "pptmb", "Pstmi", "pfrbh", "pstdb", "pngmt", "pktnt", "copfrbh", "pStrt", "pstrpl", "pstatpl", "Pcttor", "Pctmt", "prostwd", "psthemb", "pstemb", "copfratt", "pctms", " pctmt", " pctm", "Pctwd", "pctbl", "prostrt", "pctnt", "pstwt", "Pstmn", "pftmt", "copstbh", "Pctnt", "pwbl", "Pctsp", "pcttor", "pStwd", "pncms", "pktmt", "pstsp", "pctsp", "pstnl", "pstatdb", "pstmi", "ptrt", "prosthemb", "pstwd", "pstrtm", "pwmr", "pestm", "pstct", "pstnt", "Pctbl", "pspmt", " pstm", "psthmt", "Pstwt", "pfmi", "Pctm", "pspm", "pscmt", "psppl", "pptwt", "pscwd", " pstattm", "pstdmt", " pstpl", "pstratt", "pftct", "Pctmb", "Pctmn", "pstbh", "pstrnl", " pstct"], "rowsToAdd": ["rowsTOPush", "viewsToAdds", "rowsReAdd", "rowsWillUpdate", "owsToMix", "viewsReadd", "viewsToPush", "owsWillPush", "rowsReAdds", " rowsWillAdd", "rowsFromPush", "rowsTOUpdate", "rowsFromadd", " rowsToSave", "rowsToUpdate", "rowsTOMix", "rowsToMix", "owsWillAdded", "viewsReAdd", "rowsWilladd", " rows\n", " rowsToAdded", " rowsToUpdate", "rowstoAdd", "rowsTOAdd", "rowsWillMix", "rowsCount", "rowsReadd", "owsWillMix", "rownCount", "rowsToPush", "owsWillAdds", "rowstoAdded", "rowsPerAdds", " rowsWillAdded", "rowsDoPush", " rowsWillPush", "rows\n", "rowsPerPush", "owsCount", "rowsWillAdded", "rowsWillSave", "rowstoPush", "rowsWillAdd", "owsWillAdd", "rowsToAdds", "owsToAdds", " rowsToPush", "ows\n", "owsToAdd", "rowsOfAdded", "viewsToadd", "rowstoadd", "rowsFromAdd", "rown\n", " rowsWillUpdate", "rowsPerAdd", "rowsOfPush", " rowsWillAdds", "rowsRePush", "rowsFromAdds", " rowsWillSave", "rowsDoadd", "rowsToadd", "rowsToAdded", "owsToPush", "owsToAdded", "rowsTOAdded", " rowsToAdds", "viewsToAdd", "rowsOfAdd", "rowstoAdds", "owsToadd", "viewsReAdds", "rowsWillAdds", "rowsToSave", "viewsRePush", "rowsPeradd", "rowsOfAdds", " rowsCount", "rowsDoAdd", "rowsTOSave", "rowsFromUpdate", "rowsDoAdds", "rowsWillPush", "rowsTOAdds", "owsWilladd"], "theString": ["testingNumber", "Thestring", "resultstring", "TheString", " theNumber", "resultStr", "testingString", " theArray", "resultArray", " theQuery", "TheArray", "theQuery", "currentstring", "TheNumber", " thestring", "TheQuery", "TheStr", "theArray", " theStr", "resultString", "theStr", "testingArray", "currentStr", "testingQuery", "currentString", "currentNumber", "theNumber", "thestring"], "count": ["error", "size", "Count", "key", "parent", "more", "handle", "found", "len", "base", "test", "allow", "name", "cmp", "cb", "length", "ind", "label", "cc", "cache", "check", "val", "loc", "state", "index", "num", "weight", "pool", "part", "close", "b", "offset", "skip", "success", "cond", "order", "use", "id", "limit", "core", "child", "sum", "low", "time", "now", "start", "keep", "number", "total", "frac", "counter", "carry", "multiple", "c", "process", "match", "cost", "max", "left", "n", "default", "coll", "group", "code", "connection", "second", "f", "depth", "col", "type", "force", "other", "call", "list", "loop", "current"], "i": ["ai", "ip", "in", "m", "iq", "j", "p", "pri", "ic", "ie", "my", "n", "h", "eni", "ik", "q", "is", "init", "multi", "ix", "input", "e", "phi", "id", "ci", "gi", "t", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "bi", "start", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "type", "u", "ni", "b", "y", "v", "ji", "mi", "it", "di", "l", "hi", "d", "si", "yi", "qi", "uri", "source", "I", "c"], "rs": ["r", "rys", "os", "RS", "sl", "rd", "rl", "src", "rc", "cs", "Rs", "s", "bs", "xs", "ls", "asts", "rx", "ubs", "ros", "ows", "RC", "ges", "ris", "lines", "ks", "vers", "rss", "obs", "rb", " rows", "rh", "ras", "results", "rr", "ra", "ds", "hr", "sr", "mr", "relations", "ts", "req", "ars", "rt", "rates", "hs", "kr", "rows", "ins", "ys", "acks", "vs", "res", "rg", "ss", "ums", "ps", "gs", "runs", "ms", "sys", "ats", "ws", "RR", " RS", "pr", "repl"]}}
{"id1": "21092340", "id2": "18613870", "code1": "    public static URL addToArchive(Pod pod, ZipOutputStream podArchiveOutputStream, String filename, InputStream source) throws IOException {\n        ZipEntry entry = new ZipEntry(filename);\n        podArchiveOutputStream.putNextEntry(entry);\n        IOUtils.copy(source, podArchiveOutputStream);\n        podArchiveOutputStream.closeEntry();\n        return PodArchiveResolver.withinPodArchive(pod, filename);\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"addToArchive": ["addToSlives", "addToSlIVE", "addToAsIVE", "addtoArchively", "addtoAsive", "addToAdaptives", "addtoAsively", "addtoAsives", "addToArchIVE", "addtoArchIVE", "addtoAsIVE", "addToAsive", "addToArchively", "addToSlively", "addToArchives", "addToAdaptively", "addToAsively", "addToSlive", "addToAdaptive", "addtoArchive", "addToAdaptIVE", "addToAsives", "addtoArchives"], "pod": ["pad", "component", "p", "host", "ce", "object", "tmp", "Pod", "ad", "pkg", "po", "cache", "per", "child", "module", "od", "proc", "product", "post", "part", "pi", "peer", "plug", "zip", "pe", "loader", "pc", "node", "cer", "ods", "bean", "table", "project", "plugin", "pot", "pid", "pl"], "podArchiveOutputStream": ["podArchivesOutputFile", "podArchivingOutputPath", "podArchIVEOutputDirectory", "podArchiveOutputResource", "podArchiveWritePath", "podArchiveFileFile", "podArchiveIOResource", "podArchivesOutputStream", "podArchiveIOStream", "podArchIVEOutputSteam", "podArchIVEInputFile", "podArchIVEOutputFile", "podArchiveWriteStream", "podArchivesFileSteam", "podArchiveOperationStream", "podArchiveOutputFile", "podArchiveOperationFile", "podArchiveFilePath", "podArchiveByteDirectory", "podArchiveOperationSteam", "podArchiveInputDirectory", "podArchiveByteSteam", "podArchivesFileStream", "podArchiveOutputSteam", "podArchIVEInputDirectory", "podArchIVEInputStream", "podArchiveByteStream", "podArchiveIOSteam", "podArchivingOutputSteam", "podArchiveOutputDirectory", "podArchiveOutputPath", "podArchivingWriteStream", "podArchiveOperationResource", "podArchivingOutputFile", "podArchivingOutputStream", "podArchivesOutputResource", "podArchiveByteFile", "podArchiveInputSteam", "podArchiveIOFile", "podArchiveInputStream", "podArchIVEInputSteam", "podArchiveWriteFile", "podArchiveFileStream", "podArchiveFileSteam", "podArchivesOutputSteam", "podArchivesFileResource", "podArchiveFileResource", "podArchiveInputFile", "podArchiveIODirectory", "podArchivesFileFile", "podArchivingWriteSteam", "podArchiveInputPath", "podArchiveWriteSteam", "podArchIVEOutputStream", "podArchivingWriteFile", "podArchivingWritePath", "podArchiveFileDirectory"], "filename": ["ppa", "Filename", "label", "files", "sequence", "title", "il", "route", "directory", "archive", "sf", "module", "alias", "property", "location", "path", "fp", "word", "fn", "FILE", "file", "which", "kn", "f", "url", "prefix", "binary", "nil", "platform", "download", "loader", "fil", "database", "subject", "kl", "SourceFile", "application", "name", "l", "ename", "string", "named", "folder", "uri", "dll", "username"], "source": ["image", "service", "sl", "stream", "src", "output", "use", "proxy", "input", "slice", "slave", "copy", "parent", "archive", "stack", "target", "result", "connection", "path", "resource", "file", "Source", "url", "unit", "zip", "loader", "SOURCE", "text", "document", "driver", "reader", "string", "seed", "uri", "ource", "config"], "entry": ["image", "iterator", "auto", "r", "obj", "ie", "element", "stream", "object", "feed", "e", "parent", "archive", "address", "child", "result", "or", "pointer", "connection", "index", "resource", "path", "se", "line", "row", "file", "post", "ge", "letter", "this", "zip", "data", "article", "it", "record", "Entry", "reader", "string", "add", "event"]}}
{"id1": "6470716", "id2": "18793482", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"st": ["ST", "r", "sts", "stage", "sc", "fr", "ast", "St", "src", "class", "ste", "s", "std", "id", "Str", "ft", "t", "sb", "stress", "const", "sf", "fe", "tt", "code", "inst", "sta", "str", "start", "f", "est", "rest", "struct", "put", "cl", "ct", "ost", "d", "string", "ld", "sth", "ust", "pt", "www", "ist"], "url": ["blog", "image", "fr", "sl", "ul", "html", "stream", "tool", "host", "feed", "impl", "fl", "user", "bug", "ls", "bb", "id", "page", "server", "coll", "bel", "address", "open", "loc", "or", "connection", "http", "hub", "URL", "path", "ob", "ssl", "file", "build", "link", "f", "Url", "base", "zip", "err", "gl", "download", "log", "b", "org", "ll", "cl", "l", "string", "web", "ur", "uri", "pl", "source", "www"], "fis": ["lis", "fips", "fIS", "FIS", "bis", "flris", "zris", "flos", "zips", "lris", "fi", " fips", " fris", "FIs", "fIs", "Fos", "Fips", "flis", "zIS", "fliss", "afiss", " fiss", "biss", "afos", "bi", "afis", "flIs", "fli", "fris", " fils", "lils", "fiss", "bos", " fIS", "liss", "fils", "afIs", "Fris", "Fis", "Fiss", "flils", " fi"], "zis": ["zenois", "zeIS", " ziss", "qiss", "Zais", "ezIS", " zisa", "Zis", "zips", "qbis", "zipisi", "qis", "ziss", "ezisa", "zenis", "ezis", "zois", "zeisa", " zais", "zipiss", " zits", "zipbis", "zIS", "zais", " zisi", "zi", "zipi", "zisa", "ezips", "zipis", "zeips", "Ziss", " zois", " zips", " zi", "zenisi", " zIS", "zbis", "zits", "zipits", "zipais", "zisi", "zenais", "qi", "Zits", "zeis", " zbis", "zipois"], "entry": ["next", "r", "image", "in", "ace", "match", "la", "de", "country", "auto", "fr", "obj", "ie", "element", "sec", "cel", "key", "cell", "object", "comment", "feed", "rc", "sea", "parse", "e", "enter", "cat", "nt", "ry", "lc", "archive", "address", "info", "result", "or", "dc", "ident", "li", "index", "exp", "inner", "se", "line", "row", "file", "part", "ge", "zip", "session", "pe", "spec", "ent", "record", "ries", "je", "Entry", "reader", "si", "extra", "inc"], "count": ["ind", "buffer", "size", "max", "Count", "i", "current", "use", "load", "feed", "default", "write", "parent", "id", "limit", "cache", "check", "val", "child", "more", "code", "sum", "index", "_", "line", "file", "part", "len", "start", "en", "end", "depth", "base", "type", "log", "offset", "number", "allow", "skip", "name", "counter", "list", "add", "read", "c", "length"], "data": ["image", "error", "buffer", "bytes", "p", "size", "batch", "alpha", "block", "i", "load", "feed", "input", "cache", "info", "result", "code", "content", "a", "message", "zero", "results", "raw", "value", "str", "len", "start", "area", "buf", "number", "text", "body", "string", "d", "DATA", "reader", "empty", "read", "shift", "dat", "length"], "fos": ["efosi", "flnos", "efoses", "zos", "fOS", "fros", "flos", "fosh", "Fos", "zol", "foses", "flol", "fnos", "efosh", "froses", "zOS", "znos", "dfoses", "dfosi", "frosh", "Fol", "dfos", "dfosh", "Fnos", "flOS", "efos", "FOS", "fosi", "frosi", "fol"], "dest": ["writer", "de", "sync", "flash", "stream", "src", "output", "default", "tmp", "comb", "std", "slice", "const", "home", "Dest", "loc", "result", "target", "dc", "wh", "sum", "desc", "inner", "exit", "later", "img", "out", "cdn", "sup", "dist", "end", "die", "wb", "zip", "des", "rest", "temp", "trans", "done", "transform", "test", "south", "di", "coord", "style", "prop", "outer", "cont", "dev", "dat", "source", "txt"]}}
{"id1": "14168494", "id2": "13783898", "code1": "    public static void copyFile(File dest, File src) throws IOException {\n        FileChannel srcChannel = new FileInputStream(src).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copiedfile", "transferfile", " copiedClass", "copyClass", " copiedFiles", " copiedFile", "copyFiles", "copyfile", "transferFile", "transferFiles", " copyClass", "transferClass"], "dest": [" Dest", "obj", "output", "class", "transfer", "tmp", "comb", "Dest", "loc", "target", "desc", "path", "resource", "orig", "later", "out", "file", "sup", "dist", "dir", "st", "null", "this", "wb", "data", "temp", "done", "name", " destination", "true", "d", "destroy", "source", "txt"], "src": ["sc", "sl", "upload", "sync", "stream", "master", "rc", "tmp", "s", "sit", "slice", "copy", "sin", "sb", "cb", "Dest", "loc", "source", "target", "rb", "inst", "ssl", "img", "gb", "sup", "ds", "dist", "file", "storage", "config", "sel", "url", "st", "download", "sq", "split", "bin", "sub", "filename", "rob"], "srcChannel": ["srcCh", "srcChan", "sourceChan", "distChannel", " srcchannel", " srcChan", "rcChannel", "inputChannel", "destChan", "srcchannel", "distCh", "srcConnection", " srcButton", " srcStream", "rcButton", "rcCh", "rcSection", "distChan", "distStream", "rcchannel", "srcSection", "inputConnection", "inputchannel", "srcStream", " srcCh", "rcConnection", "inputSection", "rcChan", " srcSection", "rcStream", "destChannel", "sourceChannel", "srcButton", "destchannel", "sourceButton", " srcConnection", "destConnection", "sourcechannel"], "dstChannel": ["dstVideo", " dstContext", "dstschannel", "DdestChannel", " dstStream", "dstContext", " dstsStream", "drcChan", "dstStream", "ddestStream", "ddestVideo", "dDestchannel", "Ddestchannel", " drdChannel", "dDestChannel", "dDestStream", "ddestChannel", "Dstchannel", " dstChan", "drcChannel", " dstConnection", " dstschannel", "dstConnection", " drdContext", "dstsConnection", "drdContext", " dstsConnection", "DstChannel", "DdestVideo", "drdchannel", " dstchannel", "dstsChannel", " drdchannel", " drdChan", "dsrcChannel", "dsrcVideo", "dstChan", "DstVideo", "drcContext", "dstsStream", "drdChan", "drdChannel", "drcchannel", "ddestchannel", "drcVideo", "ddestChan", " dstsChannel", "ddestConnection", "ddestContext", "dsrcchannel", "dstchannel", "dDestConnection"]}}
{"id1": "23296117", "id2": "18696387", "code1": "    public static void extractNativeLib(String sysName, String name, boolean load, boolean warning) throws IOException {\n        String fullname = System.mapLibraryName(name);\n        String path = \"native/\" + sysName + \"/\" + fullname;\n        URL url = Thread.currentThread().getContextClassLoader().getResource(path);\n        if (url == null) {\n            if (!warning) {\n                logger.log(Level.WARNING, \"Cannot locate native library: {0}/{1}\", new String[] { sysName, fullname });\n            }\n            return;\n        }\n        URLConnection conn = url.openConnection();\n        InputStream in = conn.getInputStream();\n        File targetFile = new File(getExtractionDir(), fullname);\n        OutputStream out = null;\n        try {\n            if (targetFile.exists()) {\n                long targetLastModified = targetFile.lastModified();\n                long sourceLastModified = conn.getLastModified();\n                if (targetLastModified + 1000 > sourceLastModified) {\n                    logger.log(Level.FINE, \"Not copying library {0}. Latest already extracted.\", fullname);\n                    return;\n                }\n            }\n            out = new FileOutputStream(targetFile);\n            int len;\n            while ((len = in.read(buf)) > 0) {\n                out.write(buf, 0, len);\n            }\n            in.close();\n            in = null;\n            out.close();\n            out = null;\n            targetFile.setLastModified(conn.getLastModified());\n        } catch (FileNotFoundException ex) {\n            if (ex.getMessage().contains(\"used by another process\")) {\n                return;\n            }\n            throw ex;\n        } finally {\n            if (load) {\n                System.load(targetFile.getAbsolutePath());\n            }\n            if (in != null) {\n                in.close();\n            }\n            if (out != null) {\n                out.close();\n            }\n        }\n        logger.log(Level.FINE, \"Copied {0} to {1}\", new Object[] { fullname, targetFile });\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 0, "substitutes": {"extractNativeLib": ["extractRemoteLibrary", "extractNativelib", "extractednativelib", "extractRemotelib", "extractRemoteLib", "extractednativeLibrary", "extractedNativelib", "extractNativeLibrary", "extractLibrarylib", "extractedNativeLib", "extractnativelib", "extractnativeLibrary", "extractnativeLib", "extractednativeLib", "extractLibraryLib", "extractedNativeLibrary", "extractLibraryLibrary"], "sysName": ["SysName", "sysDir", "sysname", "ysPath", "systemname", "Sysname", "libTitle", "SysDir", "sysPath", "systemTitle", "systemPath", "systemName", " sysTitle", "sysFull", "SysPath", "libName", "SysFull", "sysTitle", "ysname", "systemDir", " sysPath", " sysDir", " sysFull", " sysname", "ysName", "systemFull", "libname", "libPath"], "name": ["size", "n", "label", "key", "default", "title", "id", "cache", "nice", "nam", "connection", "resource", "word", "nm", "file", "root", "part", "NAME", "no", "prefix", "base", "system", "type", "data", "loader", "Name", "number", "plugin", "string", "named", "source", "filename", "na", "username"], "load": [" reload", "get", "ck", "loading", "progress", "loaded", "require", "save", "sync", "loads", "rc", "delete", "use", "comment", "init", "parse", "write", "copy", "cli", "include", "cache", "fail", "check", "open", "LOAD", "hack", "pull", "pack", "oad", "start", "link", "close", "null", "callback", "set", "zip", "download", "Load", "loader", "wait", "cl", "force", "test", "remove", "call", "skip", "l", "leaf", "play", "push", "lock", "add", "read", "dump", "create", "launch"], "warning": ["auto", "success", "error", "fw", "blocking", "loading", "Warning", "comment", "ew", "misc", "wild", "only", "message", "resource", "fp", "acl", "war", "ww", "aw", "WARNING", "warn", " warn", "lang", "loader", "wa", "alert", "breaking", "notice", "generation", "leaf", "weak", "WARN", "web", " warnings", "random", "watch", "ws", "external", "initial"], "fullname": ["fullNAME", "flatName", "fullName", "FullName", "fulkey", "Fullnumber", "Fullnode", "fulnode", "fullkey", "fullybase", "fulname", "fulName", "fullypath", "fullnode", "fullbase", "Fullname", "fullnumber", "Fullpath", " fullpath", " fullName", "Fullnamed", " fullnode", "flatnamed", "fulbase", "realpath", "fullpath", " fullnumber", " fullnamed", "realName", "fullnamed", " fullNAME", "realname", "flatpath", "fullyname", "fullykey", "flatname", "fullynumber", "fulpath", "realnamed", " fullkey", "FullNAME", " fullbase", "fullyName", "realNAME"], "path": ["image", "PATH", "full", "key", "pattern", "object", "context", "parent", "id", "route", "cache", "filename", "Path", "location", "pointer", "resource", "ref", "code", "work", "file", "root", "str", "part", "link", "enc", "api", "base", "data", "type", "loader", "log", "text", "method", "ath", "string", "filter", "uri", "config"], "url": ["lr", "blog", "image", "fr", "service", "sl", "rl", "src", "impl", "fl", "il", "bb", "coll", "server", "address", "bel", "loc", "connection", "http", "location", "URL", "resource", "ob", "ssl", "file", "link", "f", "Url", "lib", "channel", "api", "base", "serv", "download", "loader", "log", "org", "ll", "l", "string", "ur", "uri", "source", "config", "www"], "conn": ["client", "connect", "Conn", "sync", "ctx", "n", "cp", "socket", "cn", "rc", "init", "cli", "nt", "coll", "cb", "open", "loc", "ann", "dn", "reg", "connection", "nc", "http", "io", "fp", "ob", "ssl", "con", "conf", "resp", "ch", "enc", "serv", "channel", "api", "conv", "session", "err", "log", "org", "rt", "ct", "net", "l", "Connection", "cmp", "act", "lock", "config", "c"], "in": ["request", "r", "image", "client", "pin", "ic", "sync", "n", "inn", "ie", "gin", "src", "i", "up", "socket", "pre", "s", "init", "cin", "input", "on", "id", "din", "cache", "child", "lin", "connection", "a", "inner", "resource", "index", "pull", "nin", "ssl", "ini", "con", "kin", "file", "part", "inside", "min", "f", "this", "serv", "exec", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "again", "like", "c", "lock", "win", "source", "config", "ac", "inc"], "targetFile": ["resourceLine", "targetDir", "argetfile", " targetDir", "resourcefile", " targetClass", "targetFolder", "targetDirectory", " targetPath", "sourcefile", "targetStream", "TargetClass", "hostfile", " targetStream", "hostDir", "targetPath", "hostStream", "argetClass", "targetfile", "targetClass", "argetFiles", " targetfile", "hostFile", "resourceFile", "sourceLine", "sourceFolder", "targetLine", "sourceFile", "sourcePath", " targetDirectory", " targetFolder", " targetLine", "sourceDirectory", "targetFiles", "TargetDirectory", "sourceDir", "resourceDir", "Targetfile", "TargetStream", "argetFile", "TargetDir", " targetFiles", "TargetPath", "argetFolder", "TargetFiles", "TargetFile", "argetPath", "resourceDirectory", "sourceFiles"], "out": ["Out", "error", "image", "client", "writer", "plain", "obj", "sync", "off", "n", "one", "block", "up", "key", "output", "socket", "default", "comment", "init", "app", "user", "on", "parent", "ex", "page", "cache", "server", "option", "group", "result", "target", "connection", "sum", "inner", "resource", "ext", "io", "exp", "at", "file", "line", "part", "post", "buf", "o", "null", "exec", "prefix", "login", "doc", "temp", "err", "log", "token", "w", "net", "call", "co", "bin", "again", "outer", "lock", "cmd", "source", "OUT", "inc"], "targetLastModified": ["targetLastMODamed", "targetFirstModIFIED", "targetLastMODocked", "targetFirstMODed", "targetLastPedified", "targetLastMinified", "targetLastMinamed", "targetFirstMinified", "targetFirstModocked", "targetLastMed", "targetFirstMined", "targetLastPedIFIED", "targetLastSemification", "targetLastSemocked", "targetFirstModification", "targetLastModocked", "targetFirstModed", "targetLastMODIFIED", "targetLastPedamed", "targetFirstMODification", "targetFirstModamed", "targetLastMification", "targetLastModIFIED", "targetFirstModified", "targetLastMODed", "targetFirstMinIFIED", "targetFirstMinamed", "targetLastModed", "targetLastMODification", "targetLastMinIFIED", "targetFirstMODocked", "targetLastMified", "targetLastMined", "targetLastSemified", "targetLastMocked", "targetFirstMODified", "targetLastMODified", "targetLastModamed", "targetLastPeded", "targetLastModification", "targetLastSemed"], "sourceLastModified": ["sourceLastmodified", "sourceLastImified", "sourceFirstModed", "sourceLastMined", "sourceLastMODification", "sourceLastModIFIED", "sourceLastMODed", "sourceLastmodIFIED", "sourceLastModed", "sourceLastMed", "sourceFirstModified", "sourceLastModated", "sourceLastMinIFIED", "sourceFirstMODIFIED", "sourceFirstMODed", "sourceLastImed", "sourceLastMified", "sourceLastMODated", "sourceLastImated", "sourceFirstMODated", "sourceLastmoded", "sourceFirstModIFIED", "sourceFirstModification", "sourceFirstMODified", "sourceLastImification", "sourceLastModification", "sourceFirstModated", "sourceLastMODIFIED", "sourceLastMification", "sourceLastMinified", "sourceLastMODified", "sourceFirstMODification", "sourceLastMated"], "len": ["fin", "part", "size", "sl", "lf", "n", "pos", "el", "lim", "fl", "ln", "id", "nt", "lc", "limit", "val", "lin", "ler", "li", "num", "z", "line", "Len", "count", "lon", "str", "en", "end", "min", "iter", "no", "f", "data", "err", "cl", "net", "bin", "l", "body", "le", "length"]}}
{"id1": "23118425", "id2": "3756429", "code1": "    public synchronized String encrypt(String plaintext) throws Exception {\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n        } catch (Exception e) {\n        }\n        try {\n            md.update(plaintext.getBytes(\"UTF-8\"));\n        } catch (Exception e) {\n        }\n        byte raw[] = md.digest();\n        String hash = (new BASE64Encoder()).encode(raw);\n        return hash;\n    }\n", "code2": "    private static String scramble(String text) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n            md.update(text.getBytes(\"UTF-8\"));\n            StringBuffer sb = new StringBuffer();\n            for (byte b : md.digest()) sb.append(Integer.toString(b & 0xFF, 16));\n            return sb.toString();\n        } catch (UnsupportedEncodingException e) {\n            return null;\n        } catch (NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["enipher", "Enccrypt", " Encrypted", "Encrypt", "enccrypt", " Enccrypt", "encrypted", "encipher", " Encrypt", "Encipher", "enrypted", " Encipher", "enrypt", "Encrypted"], "plaintext": [" plaindata", " plainsource", "broadtext", "plainText", "broadstring", "protecteddata", "flatstring", "flattext", " plainstring", "broadsource", "protectedtext", "flatdata", "protectedstruct", "flatsource", "plainstruct", " plainText", "protectedText", "plainstring", "broadText", " plainstruct", "flatstruct", "plainsource", "plaindata", "flatText"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "kg", "dig", "ph", "mad", "pg", "ad", "pkg", "mu", "pd", "metadata", "ma", "od", "cd", "dc", "code", "message", "amd", "nm", "mb", "wd", "dh", "mand", "bd", "mg", "dm", "data", "pm", "sha", "mt", "MD", "mp", "mc", "hd", "mag", "mod", "d", "material", "vd", "ld", "am", "meta", "ms", "cmd", "mem", "dd", " MD", "hm"], "raw": ["image", "clean", "buffer", "original", "RAW", "block", "stream", "full", "def", "load", "feed", " hex", "input", "instance", "unsigned", "serial", "dec", "ng", "content", "array", "Raw", "message", "response", "initial", "pack", "unknown", "rew", "row", "binary", "enc", "null", "channel", "buf", "ack", "local", "partial", "wrap", "custom", "empty", "shared", " RAW", "hex"], "hash": ["mac", "image", "buffer", "h", "html", "block", "ash", "crypt", "key", "full", "version", "id", "cache", "code", "sum", "array", "response", "message", "rh", "value", "row", "Hash", "build", "url", "base", "data", "her", "log", "secret", "sha", "text", "auth", "password", "string", "header", "empty", "kh", "hex"]}}
{"id1": "11716816", "id2": "14038176", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public static String fetchUrl(String urlString) {\n        try {\n            URL url = new URL(urlString);\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            StringBuilder builder = new StringBuilder();\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            reader.close();\n            return builder.toString();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n", "label": 0, "substitutes": {"updateFile": ["copyFile", "copyFolder", "upFolder", "upDirectory", "upFile", "importFolder", "updateDirectory", "updateFolder", "copyDirectory", "importBody", "upBody", "importFile", "copyBody", "updateBody", "importDirectory"], "file": ["get", "image", "db", "full", "files", "up", "class", "queue", "object", "socket", "load", "input", "future", "e", "parent", "handler", "File", "cache", "info", "connection", "content", "http", "path", "resource", "fp", "single", "io", "line", "FILE", "part", "dir", "f", "url", "this", "base", "model", "zip", "data", "type", "pe", "log", "b", "local", "name", "l", "lock", "current", "source", "filename"], "IOException": ["TimeoutProblem", "Downloadception", " IOProblem", "TimeoutException", "Timeoutception", "IOception", "DownloadException", "DownloadProblem", "IOProblem", " IOception"], "destFile": ["srcFiles", " destFull", " destPath", "destroyfile", "destroyTable", " destDir", "DestFile", "destroyDir", "sourceFiles", " destinationFull", "origTable", "destDir", "Destfile", "destFolder", "destfile", "destFiles", "flatfile", "sourceFolder", "sourceFile", "srcFile", "srcFolder", "DestPath", "DestFolder", " destfile", "origfile", " destinationFile", "destPath", " destTable", "origDir", "destFull", "DestDir", "destTable", "sourceDir", " destinationDir", "DestFiles", "flatDir", "origFile", "destroyFile", "flatFile", "flatFiles", " destFolder", "DestFull", " destFiles", " destinationFiles", "srcPath"], "in": ["r", "image", "client", "p", "pin", "sync", "inn", "gin", "isin", "i", "socket", "s", "init", "cin", "el", "input", "on", "id", "cf", "din", "conn", "ax", "connection", "a", "inner", "io", "pull", "nin", "con", "ini", "work", "inside", "min", "f", "this", "pass", "login", "err", "with", "b", "cl", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "c", "lock", "re", "win", "source", "up", "ac", "inc"], "out": ["Out", "timeout", "client", "writer", "sync", "obj", "off", "n", "i", "output", "socket", "ou", "user", "ex", "option", "outside", "to", "conn", "cookie", "connection", "exp", "ext", "resource", "io", "nin", "at", "of", "url", "o", "no", "exec", "channel", "this", "pass", "lib", "err", "login", "b", "w", "net", "call", "name", "co", "bin", "In", "password", "OUT", "again", "point", "outs", "extra", "outer", "up", "c", "inc"]}}
{"id1": "19810820", "id2": "8490297", "code1": "    public static void copyFileChannel(File src, File dst, boolean preserveModificationTime) throws IOException {\n        FileChannel inputChannel = null;\n        FileChannel outputChannel = null;\n        long length = 0;\n        try {\n            inputChannel = new FileInputStream(src).getChannel();\n            length = inputChannel.size();\n            outputChannel = new FileOutputStream(dst).getChannel();\n            long total = 0;\n            while (total < length) {\n                total += inputChannel.transferTo(0, length, outputChannel);\n            }\n            if (preserveModificationTime) {\n                dst.setLastModified(src.lastModified());\n            }\n        } finally {\n            if (inputChannel != null) {\n                inputChannel.close();\n            }\n            if (outputChannel != null) {\n                outputChannel.close();\n            }\n        }\n    }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"copyFileChannel": ["copyFileStream", "copyfileChan", "transferfileChannel", "copyStreamStream", "copyfileStream", "copyDirectorychannel", "transferFileChan", "copyfilechannel", "copyStreamchannel", "copyStreamChan", "copyFilechannel", "copyDirectoryChannel", "transferfileChan", "copyFileChan", "copyStreamChannel", "transferfileStream", "copyDirectoryChan", "transferFileChannel", "transferfilechannel", "transferFileStream", "copyDirectoryStream", "transferFilechannel", "copyfileChannel"], "src": ["sc", "client", "sl", "sync", "upload", "ctx", "stream", "rc", "func", "s", "tmp", "sit", "slice", "rs", "input", "ls", "ses", "sin", "RC", "server", "sb", "conn", "loc", "source", "scene", "rb", "path", "cur", "inst", "ssl", "img", "dest", "sup", "Source", "dist", "config", "start", "sel", "url", "st", "rest", "download", "sq", "b", "SOURCE", "lower", "sub", "sth", "sys", "ruby", "filename"], "dst": ["bart", "Dost", "bput", "fdST", "stlt", "adrc", " dost", "lddest", "tart", "stst", "dost", "ddest", "dart", " dST", "bst", "fdput", "ldost", " ddest", "dST", "Ddest", "start", "brc", "tST", "Dst", "drc", "ldST", "tst", "dput", "adst", "blt", "tlt", "ldst", "stST", "dlt", "adST", "fdst", "fdrc", "bST", "adput", "DST"], "preserveModificationTime": ["preserveModifiedTime", "preserveModationtime", "preserveMinifiedTime", "preserveMinifiedtime", "preserveModificationFile", "preserveModifyingTime", "preserveMinificationFile", "preserveModifyTime", "preserveModationFile", "preserveModifyingtime", "preserveModifiedFile", "preserveModificationtime", "preserveModifyingFile", "preserveModifytime", "preserveModationTime", "preserveMinifiedFile", "preserveModifiedtime", "preserveMinificationTime", "preserveMinificationtime"], "inputChannel": ["imageGate", "Inputchannel", "imagechannel", " inputSocket", "errorChan", "InputBuffer", "InputSocket", "outputConsole", "InputChannel", "outputCode", "outputChan", "outputStream", "fileChannel", "outputSocket", "outputchannel", "binaryChannel", " inputConnection", "errorStream", " inputStream", "requestChannel", "binaryChan", "inputchannel", "outputCache", "errorCache", "inputConnection", "binaryGate", "requestStream", "requestChan", " inputQueue", "inputQueue", " inputCode", "inputChan", "imageChan", " inputConsole", "inputCode", "inputGate", "fileChan", "outputQueue", "inputBuffer", "requestCode", "fileConsole", "binarychannel", "imageChannel", "inputConsole", " inputBuffer", " inputchannel", " inputCache", "errorChannel", "InputQueue", "outputBuffer", "outputConnection", "inputCache", "inputStream", " inputChan", "outputGate", "fileConnection", "inputSocket", "InputChan"], "outputChannel": ["outStream", "Outputchannel", " outputchannel", "inputButton", "OutputStream", "outchannel", "outChan", " outputQueue", "writeManager", "outButton", "outputChan", "outputStream", "outputManager", "OutputQueue", "outputchannel", "writeChan", " outputStream", " outputChan", "inputChan", "inputManager", "writeQueue", "outChannel", "outputQueue", "writeChannel", "outputButton", "OutputChan", "writeStream", "OutputChannel", " outputButton", " outputManager", "inputStream"], "length": ["next", "position", "buffer", "max", "size", "block", "full", "current", "form", "load", "sequence", "slave", "delay", "section", "id", "limit", "complete", "child", "last", "result", "Length", "sum", "php", "pull", "value", "count", "available", "build", "len", "part", "end", "start", "base", "session", "type", "with", "partial", "offset", "number", "text", "width", "volume", "l", "style", "duration", "head", "lock", "join"], "total": ["toc", "error", "max", "size", "full", "all", "i", "key", "multi", "used", "id", "limit", "valid", "complete", "last", "info", "result", "sum", "found", "failed", "cur", "translation", "Total", "count", "available", "len", "start", "part", "no", "base", "set", "scale", "type", "partial", "offset", "done", "always", "otal", "duration", "current", "less"]}}
{"id1": "5237257", "id2": "21824901", "code1": "    private void download(String fileName) {\n        String filePath = Activator.showSaveDialog(fileName, new String[] { \".xls\" });\n        if (filePath != null) {\n            InputStream in = null;\n            OutputStream out = null;\n            try {\n                in = this.getClass().getResourceAsStream(\"/\" + fileName);\n                out = new FileOutputStream(filePath);\n                IOUtils.copy(in, out);\n            } catch (IOException ioe) {\n                Activator.showExceptionDialog(ioe);\n            } finally {\n                if (in != null) {\n                    try {\n                        in.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n                if (out != null) {\n                    try {\n                        out.close();\n                    } catch (IOException e1) {\n                        Activator.showExceptionDialog(e1);\n                    }\n                }\n            }\n        }\n    }\n", "code2": "    public static void copyExternalResource(File sourceFile, File destFile) throws IOException {\n        if (!destFile.exists()) {\n            destFile.createNewFile();\n        }\n        FileChannel source = null;\n        FileChannel destination = null;\n        try {\n            source = new FileInputStream(sourceFile).getChannel();\n            destination = new FileOutputStream(destFile).getChannel();\n            destination.transferFrom(source, 0, source.size());\n        } finally {\n            closeQuietly(source);\n            closeQuietly(destination);\n        }\n    }\n", "label": 1, "substitutes": {"download": ["process", "upload", "release", "output", "transfer", "delete", "load", "archive", "complete", "run", "open", "register", "submit", "report", "pack", "file", "start", "url", "exec", "update", "zip", " downloading", "log", "paste", "Download", "dump", "select"], "fileName": ["resourcePath", "FileType", " fileFolder", "fileType", " fileType", "resourceFolder", " fileCode", "FileName", "FileDirectory", "fileUrl", "resourceType", "FilePath", " fileUrl", "resourceName", "FileCode", "resourceCode", " fileDirectory", "fileDirectory", "fileCode", "FileUrl", "fileFolder", "resourceUrl", "FileFolder", "resourceDirectory"], "filePath": ["resourcePath", "FileLocation", "filepath", "fileFile", "FilePart", "fileLocation", "FileName", "resourceFile", "FileFile", "filePart", "FilePath", "resourcepath", " fileLocation", "resourceName", "resourceLocation", " filepath", "Filepath", "resourcePart", " filePart", " fileFile"], "in": ["r", "image", "m", "pin", "sync", "n", "inn", "gin", "isin", "i", "is", "socket", "init", "cin", "input", "copy", "on", "id", "spin", "din", "ax", "lin", "cgi", "a", "inner", "resource", "io", "nin", "con", "ini", "rin", "file", "work", "x", "inside", "f", "url", "this", "login", "data", "err", "b", "ins", "name", "bin", "In", "l", "reader", "IN", "as", "again", "re", "win", "issue", "source", "up", "ac", "inc"], "out": ["Out", "image", "error", "client", "writer", "sync", "obj", "n", "off", "one", "up", "output", "socket", "view", "user", "write", "copy", "on", "id", "ex", "office", "cache", "server", "option", "to", "conn", "or", "inner", "ext", "path", "exp", "io", "nin", "line", "at", "file", "x", "url", "prefix", "o", "null", "exec", "this", "base", "lib", "err", "with", "log", "net", "call", "name", "bin", "In", "password", "by", "again", "IN", "string", "point", "outs", "extra", "cmd", "outer", "source", "OUT"]}}
{"id1": "12454178", "id2": "12078471", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static Model tryLoadURL(String url, RDFFormat format) throws MalformedURLException, IOException {\n        URLConnection c = new URL(url).openConnection();\n        c.addRequestProperty(\"Accept\", format.getKey());\n        String data = StreamUtil.toString(c.getInputStream());\n        Model model = ModelFactory.createDefaultModel();\n        model.read(new ByteArrayInputStream(data.getBytes()), \"\", format.getValue());\n        return model;\n    }\n", "label": 0, "substitutes": {"alterar": [" cryar", " creAr", " cryAr", " celebra", " crearan", " crear", " celebrar", " celebraran", " celebrAr", " cultivAr", " cultivar", " crya", " cultiva", " crea", " cultivaran", " cryaran"], "t": ["att", "in", "the", "T", "template", "m", "p", "xt", "n", "tree", "tool", "i", "you", "s", "tower", "tw", "e", "nt", "ut", "to", "tt", "bolt", "let", "target", "dt", "unt", "ta", "tools", "ant", "at", "qt", "tc", " mt", "x", "f", "ot", "o", "tp", "st", "this", "ti", "type", "u", "flat", "rt", "v", "trans", "y", "it", "tm", "l", "table", "et", "d", "wt", "te", "tf", "det", "tr", "pt", "c", "ts"], "stmt": ["stbm", "Stv", "putmt", "stau", "stmr", "Strm", "putmd", " stbm", "Stau", " stct", "formv", " stdb", " stmn", "formmm", "formmt", "formrm", "tmt", "stgr", "swmt", "Stmd", " stau", "istdb", "stmd", "tmr", "strmt", "strau", "istmt", "Stbm", "smr", " stmd", "Stmm", "ustmd", "ctgr", "spt", "smt", "Stmb", "ustau", " strm", " stgr", "Stgr", "stv", "putau", "strdb", "strmn", "swau", "ustmt", "ctct", "strm", "stct", "ustnt", " stpt", " stv", " stmm", " stnt", "stmm", "ctmt", " stmb", "istmn", "ctmb", "stnt", "tpt", "Stmt", "stmn", "swbm", "Stct", "istau", "stmb", "sdb", "swmd", "stdb", " stmr", "stpt", "tdb", "putnt"], "sql": ["where", "db", "job", "details", "sl", "query", "lambda", "stat", "QL", "q", "s", "ls", "statement", " SQL", "limit", "sol", "SQL", "expression", "conn", "result", "params", "plan", "url", "serv", "base", "zip", "sq", "log", "printf", "dl", "database", "shell", "mt", "ql", "string", "seed", "setup", "insert", "lock", "cmd", "up", "pr"], "id_disciplina": ["id_disciplineINA", "id_disciplissa", "id_distciplana", "id_Disciplina", "id_disciplineana", "id_disguina", "id_distciino", "id_disciplini", "id_disciplineina", "id_discomplino", "id_distciplINA", "id_distciini", "id_disciplana", "id_discomplinea", "id_disciana", "id_distrequINA", "id_discomplina", "id_Disciplissa", "id_disrequini", "id_Disciplineina", "id_distciplina", "id_distciana", "id_disciplino", "id_disciina", "id_disguinea", "id_Disciplinea", "id_disciini", "id_distciina", "id_Disciplini", "id_distciplino", "id_disciplineissa", "id_disciplineini", "id_Disciplineinea", "id_disciplineino", "id_disguissa", "id_disciino", "id_disrequINA", "id_disciINA", "id_disciplinea", "id_distrequini", "id_disciplineinea", "id_Disciplineini", "id_discomplissa", "id_disciinea", "id_disrequina", "id_distciplini", "id_disrequinea", "id_disciplINA", "id_distciplinea", "id_distrequinea", "id_discomplana", "id_disguini", "id_distrequina", "id_Disciplineissa", "id_discomplini"], "item": ["items", "request", "r", "ip", "m", "service", "p", "entry", "queue", "q", "i", "order", "object", "action", "instance", "e", "parent", "id", "page", "seller", "server", "info", "or", "result", "container", "index", "at", "edit", "url", "o", "unit", "area", "Item", "data", "type", "pe", "bar", "v", "er", "article", "it", "other", "hop", "name", "site", "reader", "event", "source"]}}
{"id1": "16931472", "id2": "17901739", "code1": "    public void handler(Map<String, String> result, TargetPage target) {\n        try {\n            URL url = new URL(target.getUrl());\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = null;\n            while ((line = reader.readLine()) != null) {\n                for (Map.Entry<String, String> entry : result.entrySet()) {\n                    if (line.indexOf(target.getInclude()) != -1) {\n                        int fromIndex = line.indexOf(target.getFromStr());\n                        String r = line.substring(fromIndex + target.getFromStr().length(), line.indexOf(target.getToStr(), fromIndex));\n                        entry.setValue(r);\n                        line = line.substring(line.indexOf(target.getToStr()) + target.getToStr().length());\n                    }\n                }\n            }\n            reader.close();\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        }\n    }\n", "code2": "    private static void setMembers() {\n        try {\n            URL url = new URL(getTracUrl() + \"newticket\");\n            BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n            String buffer = reader.readLine();\n            while (buffer != null) {\n                if (buffer.contains(\"<select id=\\\"component\\\" name=\\\"component\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strComponents = new String[erg.size()];\n                    erg.toArray(m_strComponents);\n                }\n                if (buffer.contains(\"<select id=\\\"priority\\\" name=\\\"priority\\\">\")) {\n                    Pattern pattern = Pattern.compile(\">[^<]+?<\");\n                    Matcher matcher = pattern.matcher(buffer);\n                    Vector<String> erg = new Vector<String>();\n                    int start = 0;\n                    while (matcher.find(start)) {\n                        int von = matcher.start() + 1;\n                        int bis = matcher.end() - 1;\n                        erg.add(Recoder.recode(buffer.substring(von, bis), \"UTF-8\", Recoder.getDefaultEncoding()));\n                        start = bis;\n                    }\n                    m_strPriorities = new String[erg.size()];\n                    erg.toArray(m_strPriorities);\n                }\n                buffer = reader.readLine();\n            }\n        } catch (MalformedURLException e) {\n            System.out.println(\"e1\");\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n", "label": 1, "substitutes": {"handler": ["process", " callback", " fire", " finish", " rewrite", " setup", " handle", " serve", " init", " notify", " success", " complete", "handle", " response", " handling", " on", " processing", "callback", " fn", " next", " load", "Handler", " dispatch", " f", " done", " redirect", " transfer"], "result": ["match", "buffer", "output", "order", "view", "map", "dict", "page", "json", "cache", "complete", "group", "array", "response", "report", "message", "resource", "Result", "results", "manager", "row", "feature", "session", "data", "status", "record", "document", "table", "res", "list", "event", "re", "source"], "target": ["request", "next", "image", "favorite", "client", "template", "that", "the", "html", "master", "output", "class", "object", "layout", "proxy", "host", "theme", "owner", "version", "reference", "parent", "environment", "route", "page", "server", " Target", "tail", "connection", "content", "location", "response", "resource", "http", "manager", "link", "this", "base", "unit", "goal", "session", "data", "download", "type", "Target", "token", "database", "task", "it", "site", "external", "arget", "project", "style", "about", "event", "current", "source", "config"], "url": ["blog", "buffer", "service", "sl", "stream", "socket", "view", "feed", "user", "page", "server", "address", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "build", "str", "Url", "channel", "base", "loader", "org", "l", "browser", "string", "uri", "source"], "reader": ["iterator", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "rc", "feed", "input", "e", "rx", "ry", "server", "ler", "http", "editor", "report", "io", "rr", "row", "reading", "file", "iter", "f", "ri", "err", "builder", "loader", "er", "over", "driver", "parser", "read", "layer", "bird"], "line": ["error", "sync", "lf", "key", "profile", "cell", "comment", "info", "str", "end", "link", "iter", "no", "base", "range", "ine", "text", "name", "body", "string", "non", "sl", "rl", "view", "user", "parse", "lined", "page", "rule", "home", "lines", "strip", "response", "message", "li", "file", "definition", "err", "live", "status", "l", "plugin", "lock", "look", "email", "el", "e", "id", "lc", "limit", "Line", "lin", "row", "liner", "o", "pe", "log", "cl", "frame", "nl", "point", "source", "lo", "side", "buffer", "block", "or", "code", "zip", "inline", "data", "LINE", "site", "style", "header", "le"], "entry": ["match", "writer", "service", "ner", "term", "element", "ie", "key", "cell", "rc", "feed", "owner", "layer", "e", "enter", "section", "page", "ry", "archive", "ener", "per", "or", "connection", "inner", "editor", "resource", "se", "exit", "value", "row", "part", "link", "ge", "data", "builder", "her", "ent", "entity", "Entry", "member", "string", "counter", "uri", "extra", "source"], "fromIndex": ["toOffset", "FromPoint", "fromSection", "sourcePoint", "fromPoint", "FromOffset", " fromLength", "fromLength", "toIndex", " fromPosition", "FromPosition", "toPosition", "fromPosition", "FromSection", " fromPoint", "FromIndex", "startOffset", "startPosition", "startLength", "toPoint", " fromSection", "startIndex", "sourcePosition", " fromOffset", "fromOffset", "FromLength", "sourceIndex", "sourceSection"], "r": ["lr", "fr", "m", "p", "ner", "attr", "rl", "q", "rc", "rs", "cr", "e", "ru", "rb", "array", "rr", "nr", "sr", "mr", "f", "ri", "u", "range", "b", "v", "er", "w", "vr", "l", "rg", "res", "ar", "d", "R", "re", "c", "pr"]}}
{"id1": "4223002", "id2": "23585985", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    public static StreamSource getStreamSource(Item item, XQueryContext context) throws XPathException, MalformedURLException, IOException {\n        StreamSource streamSource = new StreamSource();\n        if (item.getType() == Type.JAVA_OBJECT) {\n            LOG.debug(\"Streaming Java object\");\n            Object obj = ((JavaObjectValue) item).getObject();\n            if (!(obj instanceof File)) {\n                throw new XPathException(\"Passed java object should be a File\");\n            }\n            File inputFile = (File) obj;\n            InputStream is = new FileInputStream(inputFile);\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(inputFile.toURI().toURL().toString());\n        } else if (item.getType() == Type.ANY_URI) {\n            LOG.debug(\"Streaming xs:anyURI\");\n            String url = item.getStringValue();\n            if (url.startsWith(\"/\")) {\n                url = \"xmldb:exist://\" + url;\n            }\n            InputStream is = new URL(url).openStream();\n            streamSource.setInputStream(is);\n            streamSource.setSystemId(url);\n        } else if (item.getType() == Type.ELEMENT || item.getType() == Type.DOCUMENT) {\n            LOG.debug(\"Streaming element or document node\");\n            if (item instanceof NodeProxy) {\n                NodeProxy np = (NodeProxy) item;\n                String url = \"xmldb:exist://\" + np.getDocument().getBaseURI();\n                LOG.debug(\"Document detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n            Serializer serializer = context.getBroker().newSerializer();\n            NodeValue node = (NodeValue) item;\n            InputStream is = new NodeInputStream(serializer, node);\n            streamSource.setInputStream(is);\n        } else if (item.getType() == Type.BASE64_BINARY || item.getType() == Type.HEX_BINARY) {\n            LOG.debug(\"Streaming base64 binary\");\n            BinaryValue binary = (BinaryValue) item;\n            byte[] data = (byte[]) binary.toJavaObject(byte[].class);\n            InputStream is = new ByteArrayInputStream(data);\n            streamSource.setInputStream(is);\n            if (item instanceof Base64BinaryDocument) {\n                Base64BinaryDocument b64doc = (Base64BinaryDocument) item;\n                String url = \"xmldb:exist://\" + b64doc.getUrl();\n                LOG.debug(\"Base64BinaryDocument detected, adding URL \" + url);\n                streamSource.setSystemId(url);\n            }\n        } else {\n            LOG.error(\"Wrong item type \" + Type.getTypeName(item.getType()));\n            throw new XPathException(\"wrong item type \" + Type.getTypeName(item.getType()));\n        }\n        return streamSource;\n    }\n", "label": 0, "substitutes": {"getPasswordMD5": ["getPasswordMAC512", "getpasswordMD512", "getPasswordMac256", "getPasswordMD1", "getPasswordMAC256", "getpasswordMD1", "getpasswordSHA1", "getpasswordMD256", "getpasswordMD5", "getPasswordSHA5", "getPasswordMAC1", "getPasswordMac1", "getPasswordMac5", "getPasswordMD512", "getpasswordSHA256", "getPasswordMD256", "getPasswordMAC5", "getpasswordSHA5", "getPasswordSHA1", "getpasswordSHA512", "getPasswordMac512", "getPasswordSHA512", "getPasswordSHA256"], "algorithm": ["calgorith", "algebra", "algo", "aggo", "geest", "gem", " alm", "Alignment", "alger", "agignment", "fgorithm", "Algebra", "Alger", "fgo", "Algorithm", " algorith", " alignment", "Alest", " alger", "geger", " algo", "alm", " alphabet", "fgorith", "alrator", "Algorith", "aggorithm", "omalgo", "omalgorith", "Alrator", "omalgorithm", "calgo", "alphabet", "Alm", "calgorithm", "calgebra", "omalphabet", "alignment", "Alphabet", " alest", "agrator", "alest", "fgebra", "gegorithm", " alrator", "Algo", "algorith"], "messageDigest": ["messageMDester", " messageDigString", " messageDigEST", "messageDester", "messageDEST", "messageMDest", "messageDest", "phraseDigested", "messagedigester", "MessageDigested", "phrasedigester", "messageDigester", "messagedigEST", " messageDigester", "MessageDigEST", "messageDested", "messageDigString", "messageModested", "messagedigested", "MessageModEST", "messageMDString", "phraseDigest", "messagedigString", "messageDigEST", "MessageDigest", " messagedigest", " messagedigester", "MessageModester", "phrasedigEST", "messageDigested", "phrasedigest", "MessageModest", "messageMDEST", "phraseDigEST", "MessageModested", "phrasedigested", " messagedigString", "messageModEST", "messagedigest", " messagedigEST", "messageModString", "messageModest", "phraseDigester", "MessageDigester", "messageModester"], "hexString": ["byteStream", "checkStr", " hexArray", "textBuffer", " hexStream", "shortBuffer", "checkString", " hexStr", "checkFunction", "hexstring", " hexLine", "hashBuffer", "hexArray", "byteArray", "hexFunction", "shortString", "checkBuffer", "byteLine", " hexFunction", "hexLine", "textstring", "shortstring", "textLine", "hashFunction", "hashString", " hexBuffer", "textStream", "hashStr", "textArray", "byteString", "hexBuffer", "hexStream", "hexStr", "shortArray", " hexstring", "textString"], "i": ["r", "ai", "in", "m", "h", "p", "j", "n", "key", "s", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "ui", "info", "a", "zi", "li", "index", "ii", "io", "bi", "end", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "b", "v", "oi", "mi", "di", "volume", "l", "hi", "d", "si", "chi", "uri", "I", "c"]}}
{"id1": "397240", "id2": "19134229", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private void copyFile(final String sourceFileName, final File path) throws IOException {\n        final File source = new File(sourceFileName);\n        final File destination = new File(path, source.getName());\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(source).getChannel();\n            dstChannel = new FileOutputStream(destination).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } finally {\n            try {\n                if (dstChannel != null) {\n                    dstChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n            try {\n                if (srcChannel != null) {\n                    srcChannel.close();\n                }\n            } catch (Exception exception) {\n            }\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "14783950", "id2": "23611770", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "                    public void handle() {\n                        FileChannel srcChannel, destChannel;\n                        String destOutFile = logFile + \".\" + System.currentTimeMillis();\n                        String destOutFileCompressed = logFile + \".\" + System.currentTimeMillis() + \".gz\";\n                        if (rotateDest != null) {\n                            (new File(rotateDest)).mkdirs();\n                            if (destOutFile.indexOf(\"/\") != -1) {\n                                destOutFile = rotateDest + \"/\" + destOutFile.substring(destOutFile.lastIndexOf(\"/\") + 1);\n                            }\n                            if (destOutFileCompressed.indexOf(\"/\") != -1) {\n                                destOutFileCompressed = rotateDest + \"/\" + destOutFileCompressed.substring(destOutFileCompressed.lastIndexOf(\"/\") + 1);\n                            }\n                        }\n                        if (rotateCompress) {\n                            try {\n                                GZIPOutputStream out = new GZIPOutputStream(new FileOutputStream(destOutFileCompressed));\n                                FileInputStream in = new FileInputStream(logFile);\n                                byte buf[] = new byte[1024];\n                                int len;\n                                while ((len = in.read(buf)) > 0) {\n                                    out.write(buf, 0, len);\n                                }\n                                in.close();\n                                out.finish();\n                                out.close();\n                                buf = null;\n                                in = null;\n                                out = null;\n                                Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFileCompressed + \"'\");\n                            } catch (Exception e) {\n                                Debug.debug(\"Unable to rotate log file '\" + logFile + \"': \" + e);\n                            }\n                        } else {\n                            try {\n                                srcChannel = new FileInputStream(logFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to read log file '\" + logFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel = new FileOutputStream(destOutFile).getChannel();\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to rotate log file to '\" + destOutFile + \"': \" + e.getMessage());\n                                return;\n                            }\n                            try {\n                                destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n                                srcChannel.close();\n                                destChannel.close();\n                                srcChannel = null;\n                                destChannel = null;\n                            } catch (IOException e) {\n                                Debug.debug(\"Unable to copy data for file rotation: \" + e.getMessage());\n                                return;\n                            }\n                            Debug.debug(\"Rotated log file '\" + logFile + \"' to '\" + destOutFile + \"'\");\n                        }\n                        if (rotateDelete && isFile) {\n                            try {\n                                ps.close();\n                            } catch (Exception e) {\n                            }\n                            isFile = false;\n                            ps = null;\n                            (new File(logFile)).delete();\n                            reconfigureDebug();\n                        }\n                        if (rotateDest != null) {\n                            long comparisonTime = rotateDays * (60 * 60 * 24 * 1000);\n                            long currentTime = System.currentTimeMillis();\n                            File fileList[] = (new File(rotateDest)).listFiles();\n                            DateFormat format1 = new SimpleDateFormat(\"yyyy-MM-dd\");\n                            java.util.Date date = new java.util.Date(currentTime);\n                            String archiveFile = format1.format(date).toString() + \".zip\";\n                            if (rotateArchive != null) {\n                                archiveFile = rotateArchive + \"/\" + archiveFile;\n                                (new File(rotateArchive)).mkdirs();\n                            }\n                            Archive archive = new Archive(archiveFile);\n                            for (int i = 0; i < fileList.length; i++) {\n                                String currentFilename = fileList[i].getName();\n                                long timeDifference = (currentTime - fileList[i].lastModified());\n                                if ((rotateCompress && currentFilename.endsWith(\".gz\")) || (!rotateCompress && currentFilename.indexOf(logFile + \".\") != -1)) {\n                                    if (rotateDest != null) {\n                                        currentFilename = rotateDest + \"/\" + currentFilename;\n                                    }\n                                    if (timeDifference > comparisonTime) {\n                                        archive.addFile(fileList[i].getName(), currentFilename);\n                                        fileList[i].delete();\n                                    }\n                                }\n                            }\n                            archive = null;\n                            fileList = null;\n                            format1 = null;\n                            date = null;\n                        }\n                    }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingZip", "compressedWithSax", "compressedUsingSax", "compresswithSax", "compressedUsingJar", "compressedWithZip", "compressUsingSax", "compressedUsingZip", "compressUsingJar", "compresswithZip", "compresswithJar", "compressedWithJar", "compressInZip", "compressInJar", "compressInSax", "compressWithJar", "compressWithSax"], "fileList": ["filelist", "fileChain", " fileChain", "FileList", "wordName", "inputList", " fileCollection", "zipName", " fileStream", "fileEx", "stringList", "ziplist", "fileString", "stringName", "Filelist", "FileStream", " filelist", "stringChain", "FileSet", "FileName", "wordList", "modelEx", "modelStream", "fileStream", "fileCollection", "zipSet", "zipList", "inputEx", "modelCollection", "stringlist", "FileString", " fileString", "fileSet", "FileChain", "inputCollection", " fileSet", "inputStream", "modelList", "wordStream", " fileEx", "wordString"], "zipFileName": ["zipDirname", "archiveDirDir", "archiveDirPath", "archiveFileDir", "zipFullNames", "zipDirPath", "zipDirNames", "zipFileDir", "folderFileName", "archiveFileName", "archiveFilePath", "zipFullname", "zipFullName", "folderFileNames", "archiveDirName", "zipDirDir", "zipGlobalNames", "zipFullDir", "folderFilename", "zipFilename", "folderGlobalNames", "zipGlobalPath", "zipPackagePath", "folderFilePath", "folderGlobalName", "folderGlobalPath", "zipPackageDir", "folderGlobalname", "zipFileNames", "zipDirName", "zipGlobalname", "zipGlobalName", "zipPackageName", "zipFilePath", "zipFullPath"], "fos": ["Faos", "afoS", "FoS", "flos", "faos", "infis", "fosh", "Fos", "infos", "flosh", "flis", "infoS", "afos", "infaos", "afaos", "afis", " fosh", "foS", "Fis", "Fosh"], "zos": ["os", "iframe", "onz", "inos", "LOS", "bis", "dos", "zag", "zz", "zb", "uz", "fi", "lol", "lins", "ses", "abi", "zon", "ros", "css", "es", "zan", "spin", "ZI", "zy", "seconds", "zx", "tz", "zi", "cos", "packs", "oses", "bes", "jas", "jobs", "closure", "z", "nz", "budget", "rez", "bag", "osi", "ZA", "zo", "zar", "zen", "phi", "zip", "chini", "zes", "zers", "zik", "ozo", "zer", "zzy", "fits", "bos", "obb", "loop", "gz", "outs", "kos", "webkit", "zl"], "iter": ["former", "next", "Iterator", "iterator", "ip", "liter", "fr", "ner", "sort", "cher", "inse", "ie", "Iter", "i", "is", "order", "el", "chain", "slice", "parse", "e", "enter", "ener", "coll", "loc", "oper", "http", "inner", "index", "ite", "gener", "ir", "iner", "file", "end", "f", "ator", "set", "iz", "err", "keep", "inter", "er", "test", "it", "itter", "fer", "ter", "upper", "finder", "list", "outer", "ser", "walker", "inc", "izer"], "fileName": ["pageName", "fullName", "fPart", "fileLine", "Filename", " fileFull", "FileType", "fullOpen", "currentData", "FileLine", "fileString", "currentname", "FilePart", "filenameFull", "fileType", " fileType", " fileInfo", "localName", "FileName", "filenameInfo", "FileData", "currentName", " fileLine", "filenameName", "fileFull", "localname", " fileData", "fileUrl", "fname", "fullPath", " fileOpen", "simplePath", "filePart", "fileInfo", "FilePath", "fName", "fLine", "FileInfo", " filePath", "FileString", "localPart", " fileString", "FileFull", "pagename", "pageString", "pageType", " fileUrl", "simpleName", "fileOpen", "fileData", "filePath", "localPath", "FileUrl", "filenamename", " filename", " filePart", "simpleOpen", "currentUrl", "filename"], "ind": ["rib", "in", "fr", "j", "wind", "inn", "pos", "cond", "i", "ord", "ix", "ad", "id", "ci", "mid", "val", "loc", "index", "ii", "pull", "z", "IND", "count", "Ind", "len", "start", "x", "dir", "end", "mind", "div", "vert", "pend", "bind", "nd", "eff", "d", "ld", "ded", "pt", "length", "inc"], "shortName": ["smallPath", "shortLine", "fullName", "smallName", "smallPart", " shortname", "ShortName", "shortString", "longName", "shortname", "fullPath", "longPath", "ShortPart", "fullLine", "smallname", "shortPath", "shortPart", "fullString", "ShortString", " shortPath", "fullname", "ShortPath", "Shortname", "longPart", " shortLine", "longLine", " shortString", "longname"], "fis": ["Fs", "cfris", "gis", "fios", "gris", "cfos", "pis", " fs", " fris", "gios", "pris", "cfiss", "Fos", "afiss", " fiss", " fisa", "afos", "cfis", "fs", "afis", "gisa", "fris", " fios", "fiss", "cfs", "pisa", "pios", "fisa", "afris", "Fis", "Fiss"], "buf": ["bp", "buffer", "la", "bu", "bytes", "batch", "seq", "bf", "br", "queue", "ff", "fd", "rc", "lb", "tmp", "lim", "bb", "loc", "grab", "bc", "rb", "fb", "bl", "cur", "buff", "uc", "box", "pb", "Buff", "bag", "bh", "bd", "feat", "wb", "vec", "data", "b", "cv", "v", "uf", "ba", "done", "bin", "cb"], "bytesRead": ["bytesWrite", "secondsRead", "bytesLength", " bytesNeed", "bitsSkip", " bytesSkip", "tesLoad", "bitsRead", "bitsUse", "flowsLength", " bytesLength", "wordsLength", "bytesLoad", " bytesLoad", "flowsRead", "flowsWrite", "tesSkip", "bytesSkip", "secondsWrite", "bitsWrite", " bytesUse", "tesRead", "secondsLength", "flowsNeed", "bytesUse", "bitsLoad", "bytesNeed", " bytesWrite", "wordsUse", "tesWrite", "wordsWrite", "wordsRead", "bitsLength", "secondsNeed"]}}
{"id1": "16466743", "id2": "17111859", "code1": "    public String getmd5(String password) {\n        String pwHash = \"\";\n        MessageDigest md = null;\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(password.getBytes());\n            byte[] b = md.digest();\n            for (int i = 0; i < b.length; i++) {\n                pwHash += Integer.toString((b[i] & 0xFF) + 0x100, 16).substring(1);\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.fatal(\"MD5 Hash Algorithm not found\", ex);\n        }\n        Logger.info(\"PWHash erzeugt und wird \u00fcbergeben\");\n        return pwHash;\n    }\n", "code2": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "label": 1, "substitutes": {"getmd5": ["getmn512", "getmetadata12", " getMD512", "getmd12", "getMD5", "getmd6", "getmetadata6", "getmn12", " getmd6", "getmetadata5", "getmn5", "getmn6", " getMD5", "getMD512", " getmd512", "getmetadata512", " getMD12", "getMD6", "getmd512", " getMD6", "getMD12", " getmd12"], "password": ["account", "pad", "buffer", "words", "p", "email", "crypt", "key", "pattern", "input", "attribute", "sword", "phrase", "address", "padding", "Password", "array", "path", "message", "word", "wd", "config", "f", "prefix", "pass", "login", "data", "token", "secret", "number", " passwords", "text", "name", "auth", "string", " Password", "encrypted", "hash", "PASS", "username"], "pwHash": ["pwhMac", "pwdSum", "pwahash", "PwBlock", "PwHash", "pwaMac", "pwdMac", "pWSum", "pWMac", "pwaHash", "pweDig", " pwSum", "pWBlock", "pwDig", "pxDig", "pwhSum", " pwaSum", "qwDig", "pwtHash", "pxSum", "pwaDig", "qxHash", "pwdhash", "pweSum", "qxDig", "PWBlock", "qxSum", " pwhash", "pweHash", " pwahash", "pwaSum", "pwdHash", " pwDig", "pwhash", "qxMac", "pwdDig", "PWMac", "pWHash", "PWHash", "PWSum", "qwMac", " pwaHash", "pwtSum", "pwSum", "pwBlock", "pxMac", "pwhBlock", "qwHash", "pwhHash", "pwehash", "qwSum", " pwaDig", "PwSum", "PwMac", "pwtBlock", "pwtMac", "pwMac", "pxHash"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "kg", "dig", "ad", "mu", "pd", "metadata", "M", "um", "ma", "cd", "od", "dc", "bm", "rm", "mb", "cm", "amd", "nm", "mand", "bd", "sm", "mg", "dm", "pm", "mi", "sha", "mt", "MD", "mp", "me", "mc", "mod", "mag", "d", "mage", "ld", "ms", "meta", "hash", "am", "cmd", "dd", " MD", "hm"], "b": ["r", "db", "buffer", "bytes", "p", "batch", "bis", "br", "bf", "ab", "lb", "bs", "emb", "ib", "bb", "e", "sb", "rb", "fb", "a", "be", "mb", "ob", "buff", "gb", "bi", "B", "bd", "reb", "f", "eb", "buf", "binary", "wb", "base", "u", "ba", "l", "bin", "d", "nb", "orb", "cb"], "i": ["r", "ai", "ip", "h", "p", "j", "n", "block", "s", "multi", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "ui", "info", "a", "zi", "li", "index", "ii", "io", "vi", "z", "bi", "start", "x", "pi", "f", "o", "xi", "base", "ti", "ri", "data", "u", "ni", "v", "ji", "oi", "it", "di", "l", "d", "si", "chi", "qi", "uri", "I", "c"]}}
{"id1": "2518655", "id2": "15445861", "code1": "    public static void main(String[] args) throws FileNotFoundException {\n        if (args.length < 2) throw new IllegalArgumentException();\n        String fnOut = args[args.length - 1];\n        PrintWriter writer = new PrintWriter(fnOut);\n        for (int i = 0; i < args.length - 1; i++) {\n            File fInput = new File(args[i]);\n            Scanner in = new Scanner(fInput);\n            while (in.hasNext()) {\n                writer.println(in.nextLine());\n            }\n        }\n        writer.close();\n    }\n", "code2": "    public static void copyFile(File srcFile, File destFile) throws IOException {\n        if (!(srcFile.exists() && srcFile.isFile())) throw new IllegalArgumentException(\"Source file doesn't exist: \" + srcFile.getAbsolutePath());\n        if (destFile.exists() && destFile.isDirectory()) throw new IllegalArgumentException(\"Destination file is directory: \" + destFile.getAbsolutePath());\n        FileInputStream in = new FileInputStream(srcFile);\n        FileOutputStream out = new FileOutputStream(destFile);\n        byte[] buffer = new byte[4096];\n        int no = 0;\n        try {\n            while ((no = in.read(buffer)) != -1) out.write(buffer, 0, no);\n        } finally {\n            in.close();\n            out.close();\n        }\n    }\n", "label": 1, "substitutes": {"fnOut": ["fnIn", " fnEx", "fnOUT", " fnOutput", "FNOutput", " fnFile", "fpOut", " fnIn", "fnOutput", "fpEx", "FNEx", "lsOutput", "fpIn", "lsOut", "fpOutput", "fpFile", "fnEx", "lsFile", "fnFile", "fpOUT", "FNOut", " fnOUT", "FNIn", "lsOUT"], "writer": ["r", "wire", "buffer", "worker", "entry", "key", "output", "socket", "fd", "write", "handler", "server", "Writer", "per", "ler", "writers", "usher", "a", "editor", "inner", "war", "word", "out", "work", "wr", "file", "director", "riter", "winner", "builder", "temp", "wa", "loader", "er", "w", "nw", "driver", "writ", "reader", "parser", "outer", "ws", "writing", "widget", "layer", "walker"], "i": ["ai", "ip", "m", "h", "p", "j", "n", "ie", "eni", "key", "s", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "ui", "strength", "li", "index", "ii", "io", "ori", "iu", "z", "ini", "bi", "part", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "type", "u", "b", "v", "ji", "oi", "mi", "di", "hi", "si", "chi", "qi", "uri", "I", "c"], "fInput": ["fileinput", "sfSource", "fileOutput", "fileFormat", "fFormat", "fSource", "fileInput", "sfInput", "sfOutput", " finput", "fOutput", "sfFormat", " fFormat", " fSource", "sfinput", "finput", "fileSource", " fOutput"], "in": ["ner", "pin", "n", "inn", "isin", "gin", "socket", "s", "init", "cin", "input", "version", "ln", "id", "sin", "din", "conn", "inas", "lin", "connection", "inner", "vin", "nin", "out", "line", "ini", "kin", "rin", "reading", "inside", "min", "f", "login", "data", "b", "ins", "bin", "In", "reader", "IN", "again", "scan", "win", "c", "inc"]}}
{"id1": "11484416", "id2": "19113613", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static void copy(File in, File out) throws IOException {\n        if (in.exists() && in != null && out != null) {\n            if (!out.exists()) {\n                if (in.isDirectory()) {\n                    out.mkdirs();\n                } else {\n                    out.createNewFile();\n                }\n            }\n            String source = in.isDirectory() ? \"directory\" : \"file\";\n            String target = out.isDirectory() ? \"directory\" : \"file\";\n            if (!source.equals(target)) {\n                throw new IOException(\"Can't duplicate \" + source + \" as \" + target);\n            } else {\n                if (source.equals(\"directory\")) {\n                    File[] files = in.listFiles();\n                    for (File file : files) {\n                        copy(file, new File(out, file.getName()));\n                    }\n                } else {\n                    FileChannel inCh = new FileInputStream(in).getChannel();\n                    FileChannel outCh = new FileOutputStream(out).getChannel();\n                    inCh.transferTo(0, inCh.size(), outCh);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "8046691", "id2": "5836744", "code1": "    private void retrieveFile(URL url, RSLink link) {\n        link.setStatus(RSLink.STATUS_DOWNLOADING);\n        HttpURLConnection httpConn = null;\n        DataOutputStream outs = null;\n        BufferedInputStream bins = null;\n        BufferedOutputStream bouts = null;\n        try {\n            String postData = URLEncoder.encode(\"mirror\", \"UTF-8\") + \"=\" + URLEncoder.encode(url.toString(), \"UTF-8\");\n            httpConn = (HttpURLConnection) url.openConnection();\n            httpConn.setRequestMethod(\"POST\");\n            httpConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n            httpConn.setRequestProperty(\"Content-Length\", \"\" + Integer.toString(postData.getBytes().length));\n            httpConn.setRequestProperty(\"Content-Language\", \"en-US\");\n            httpConn.setDoOutput(true);\n            httpConn.setDoInput(true);\n            outs = new DataOutputStream(httpConn.getOutputStream());\n            outs.writeBytes(postData);\n            outs.flush();\n            Pattern mimePattern = Pattern.compile(\".+/html.+\");\n            Matcher matcher = mimePattern.matcher(httpConn.getContentType());\n            if (matcher.find()) {\n                log(\"Can not download, maybe all RS slots are busy!\");\n                return;\n            }\n            link.setSize(httpConn.getContentLength());\n            bins = new BufferedInputStream(httpConn.getInputStream(), 4096);\n            bouts = new BufferedOutputStream(new FileOutputStream(link.getFile()), 4096);\n            link.setStatus(RSLink.STATUS_DOWNLOADING);\n            link.setDown(0);\n            byte[] byteBuffer = new byte[4096];\n            int count;\n            while ((count = bins.read(byteBuffer)) != -1) {\n                bouts.write(byteBuffer, 0, count);\n                link.setDown(link.getDown() + count);\n                if (!Main.start.get()) {\n                    link.setStatus(RSLink.STATUS_NOTHING);\n                    return;\n                }\n            }\n            link.setStatus(RSLink.STATUS_DONE);\n        } catch (IOException ex) {\n            log(\"I/O Exception!\");\n            link.setStatus(RSLink.STATUS_NOTHING);\n        } finally {\n            try {\n                if (outs != null) outs.close();\n                if (bouts != null) bouts.close();\n                if (bins != null) bins.close();\n            } catch (IOException ex) {\n                JOptionPane.showMessageDialog(null, \"Can not close some connections:\\n\" + ex.getMessage(), \"ERROR\", JOptionPane.ERROR_MESSAGE);\n            }\n            if (httpConn != null) httpConn.disconnect();\n        }\n    }\n", "code2": "    public int read(String name) {\n        status = STATUS_OK;\n        try {\n            name = name.trim();\n            if (name.indexOf(\"://\") > 0) {\n                URL url = new URL(name);\n                in = new BufferedInputStream(url.openStream());\n            } else {\n                in = new BufferedInputStream(new FileInputStream(name));\n            }\n            status = read(in);\n        } catch (IOException e) {\n            status = STATUS_OPEN_ERROR;\n        }\n        return status;\n    }\n", "label": 0, "substitutes": {"retrieveFile": ["retrievingfile", "retriveFile", "retireFile", "RetrievingUrl", "Retrievingfile", "retrievingFile", "retrievefile", "Retrievefile", "retriveFiles", "retrievingUrl", "retrieveUrl", "RetrievingFile", "retirefile", "RetrieveFile", "RetrieveFiles", "retrivefile", "retireFiles", "retrievingFiles", "retireUrl", "retriveUrl", "retrieveFiles", "RetrievingFiles", "RetrieveUrl"], "url": ["image", "buffer", "service", "email", "sl", "html", "stream", "src", "host", "socket", "object", "proxy", "feed", "user", "page", "server", "address", "loc", "connection", "http", "location", "URL", "resource", "path", "io", "ssl", "file", "Url", "channel", "base", "download", "gl", "loader", "log", "contact", "org", "ll", "l", "string", "ur", "uri", "source", "config", "www"], "link": ["image", "error", "sync", "entry", "comment", "links", "address", "open", "info", "http", "build", "post", "config", "base", "linked", "name", "uri", "Link", "feed", "load", "user", "bug", "parse", "route", "cache", "check", "loc", "tail", "path", "li", "message", "pack", "file", "set", "local", "skip", "l", "plugin", "lock", "auto", "service", "ink", "object", "slice", "lc", "low", "ref", "pull", "line", "download", "log", "remote", "add", "source", "layer", "match", "block", "LI", "or", "connection", "code", "location", "model", "inline", "data", "type", "loader", "task", "call", "style", "light", "list", "machine", "self"], "httpConn": ["userConn", "workconn", "transConnection", "baseConn", "serverconn", " httpConnection", "httpCan", "HttpConn", " httpConfig", "HttpConnect", "httpCmd", " httpconn", "urlConnect", " httpCan", "webLoc", "httpConf", "serverMC", "HttpConnection", "webConnection", "phpConnection", " httpLoc", "HttpMC", "workConnection", "HttpLoc", "urlCon", "httpsCan", "userConf", "perCon", "transConnect", "workCon", "httpMC", "httpconn", " httpCon", "serverConnect", "pubConnection", "httpConfig", "userConnect", "httpCur", "urlConnection", "baseConnection", "buildConnection", "buildCmd", "HttpConfig", "pubConn", "buildConn", "perConnection", "httpsCon", "httpConnection", "workConn", "phpCon", "buildconn", "buildCon", "urlConn", "httpsConf", "perConf", "perconn", "perConn", "baseCan", "transConn", "httpsConnect", " httpConf", "transCon", "serverConn", "phpCur", "serverConnection", "baseConf", " httpCur", "httpLoc", "httpsConn", " httpMC", "httpConnect", "pubCmd", "phpConn", "HttpCur", " httpCmd", "webConfig", "phpConnect", " httpConnect", "webConnect", "httpsConnection", "webconn", "pubCon", "perConnect", "httpCon", "userConnection", "webConn"], "outs": ["Out", "locks", "in", "timeout", "ups", "bytes", "qs", "steps", "lets", "files", "output", "socket", "limits", "boxes", "bs", "strings", "its", "overs", "ls", "ns", "events", "INS", "css", "aos", "cache", "lines", "conn", "gets", "cos", "ios", "reports", "services", "io", "results", "out", " out", "states", "abs", "bits", "opens", "sets", "data", "blocks", "pins", "works", "groups", "errors", "ins", "ops", "fits", "utils", "again", "runs", "ports", "rules", "ws", "OUT", "flows", "plugins"], "bins": ["pannels", "pints", "cbas", "bains", "sbkins", "pin", "bkins", "Bannels", "Bains", "Bouts", "wbins", "cbains", "sbains", " bkins", "wbouts", "Bkins", " bints", "wbains", "wbas", "Bints", "cbins", "bas", " bas", "sbouts", " bin", "Bins", "cbouts", "sbins", "bints", "pins", " bannels", "bin", "Bin", "bannels", " bains"], "bouts": ["bborders", "dbuss", "wbgets", "Bout", "bout", "wbins", "Bouts", "Buss", " bgets", "wbouts", "bboxes", "dbout", "bgets", " borders", "Borders", " bboxes", " buss", " bout", "dbouts", "bbins", "buss", "Bins", "borders", "Bboxes", "bbgets", "bbout", "bbouts", "dbboxes", "wbout"], "postData": ["ostBody", "readData", "POSTBytes", "formDATA", "ostdata", "POSTDATA", " postBody", "postBody", "ostDATA", "PostData", "objectDATA", "objectBytes", "postBytes", "readUrl", "PostUrl", "postString", "objectData", " postDATA", "POSTData", "formBody", "readdata", "formData", "ostData", "objectBody", "PostString", "postUrl", "POSTUrl", "readString", "Postdata", "POSTBody", "postDATA", "postdata", " postBytes", "POSTdata", "formdata", "POSTString"], "mimePattern": ["mimesModel", "mimesPattern", "MimesPattern", "MIMEModel", "mileModel", "mIMEModel", "Mimepattern", "mimeFilter", "mimepattern", "mimesString", "milePattern", "mimeString", "mimeModel", "MIMEPattern", "Mimespattern", "mIMEFilter", "MimePattern", "mengepattern", "MIMEpattern", "mimespattern", "MimesFilter", "mengeFilter", "mengePattern", "MimeFilter", "MimeString", "MimeModel", "MimesString", "mimesFilter", "mIMEString", "mengeString", "mIMEpattern", "milepattern", "mIMEPattern"], "matcher": ["patches", "patmatch", "earchers", "earmatch", "matchers", "matmatch", "patchers", "mather", "Matcher", "matches", "earcher", "Matmatch", " mather", "patche", "pather", " matchers", "Matches", "Matchers", "Matche", "earches", " matches", " matche", "patcher", "matche", "Mather"], "byteBuffer": ["ByteArray", "bitBuffer", "dataLength", "bitArray", "byteLength", "ByteHandler", "dataBuffer", "bitBuff", " byteQueue", "ByteLayer", "byteArray", "doubleBuffer", " byteArray", "doubleBuff", "byteHandler", " byteLength", "ByteLength", "ByteBuffer", "ByteBuff", "dataLayer", " byteBuff", " byteHandler", "dataBuff", "bitHandler", "doubleQueue", " byteLayer", "byteLayer", "doubleArray", "byteBuff", "byteQueue", "ByteQueue"], "count": ["ind", "match", "level", "size", "max", "n", "Count", "cond", "label", "key", "i", "old", "all", "e", "parent", "id", "limit", "core", "coll", "cache", "val", "child", "more", "group", "length", "code", "sum", "found", "low", "index", "weight", "num", "path", "pool", "now", "file", "build", "part", "len", "start", "min", "f", "col", "depth", "ch", "base", "type", "b", "keep", "offset", "number", "allow", "call", "name", "string", "list", "current", "c"]}}
{"id1": "6190356", "id2": "21182766", "code1": "    public static String hashPasswordForOldMD5(String password) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(password.getBytes(\"UTF-8\"));\n            byte messageDigest[] = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                String hex = Integer.toHexString(0xFF & messageDigest[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n            throw new IllegalStateException(nsae.getMessage());\n        } catch (UnsupportedEncodingException uee) {\n            throw new IllegalStateException(uee.getMessage());\n        }\n    }\n", "code2": "    public static Properties load(String propsName) {\n        Properties props = new Properties();\n        URL url = ClassLoader.getSystemResource(propsName);\n        try {\n            props.load(url.openStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return props;\n    }\n", "label": 0, "substitutes": {"hashPasswordForOldMD5": [" hashPasswordForOldmd512", " hashPasswordForOldmd4", " hashPasswordForNewM4", " hashPasswordForOldmd3", " hashPasswordForOldMC512", " hashPasswordForOldMC5", " hashPasswordForOldMD512", " hashPasswordForNewMD4", " hashPasswordForOldM4", " hashPasswordForOldM5", " hashPasswordForNewMD512", " hashPasswordForOldMD4", " hashPasswordForOldMD3", " hashPasswordForOldM512", " hashPasswordForNewMD5", " hashPasswordForNewMD3", " hashPasswordForOldmd5", " hashPasswordForNewM512", " hashPasswordForNewM5", " hashPasswordForOldMC3", " hashPasswordForOldMC4", " hashPasswordForNewM3", " hashPasswordForOldM3"], "password": ["account", "pad", "buffer", "words", "p", "crypt", "key", "pattern", "input", "sword", "phrase", "address", "result", "padding", "Password", "code", "content", "array", "path", "message", "word", "value", "wd", "pass", "wallet", "data", "token", "secret", "text", " passwords", "name", "auth", "string", "seed", " Password", "encrypted", "hash", "PASS", "username"], "md": ["km", "mm", "mac", "mo", "clean", "ind", "m", "Cmd", "dig", "grad", "pg", "managed", "pd", "metadata", "um", "cd", "ma", "od", "dc", "rm", "amd", "mb", "nm", "df", "wd", "gd", "mand", "bd", "f", "dm", "pm", "mt", "MD", "di", "mp", "mc", "hd", "mag", "mod", "d", "rpm", "vd", "am", "meta", "cmd", "dd", " MD", "vm", "hm"], "messageDigest": ["messageDester", " messageDigEST", "messageAddse", "messageDEST", "messageDest", "messagedigester", " messageModester", "messageDigester", "messageDse", "messagedigEST", " messageDigester", "MessageDigEST", "MessageModse", "MessageModEST", "messageAddester", "MessageDigest", "messageDigEST", " messageModEST", "MessageAddester", "messageModests", "MessageModester", "messageAddEST", "MessageAddse", "messagedigse", "MessageDigse", "messageAddest", "MessageModest", "messageDigests", " messageModests", "messageAddests", "messageDigse", "messagedigests", " messageDigests", " messageModest", "messageModse", "messageModEST", "messagedigest", "MessageAddEST", "MessageAddest", "messageModest", "MessageDigester", "messageModester"], "hexString": ["tempFile", " hexArray", "stringService", "octArray", "transformStr", "hashSection", " hexStr", "sumStr", "octStr", "tempFunction", "hexstring", "crossstring", "tempStr", "hexArray", " hexSection", " hexService", " hexFile", "hexFunction", "stringArray", "transformString", "hexSection", "crossStr", "hexFile", " hexFunction", "stringString", "sumString", "hashService", "transformArray", "hashString", "transformBuffer", " hexBuffer", "sumstring", "crossString", "hashArray", "hexBuffer", "stringSection", "hexStr", " hexstring", "sumFile", "hexService", "octBuffer", "tempString", "crossFunction", "tempstring", "octString"], "i": ["r", "ai", "ip", "m", "h", "p", "j", "n", "s", "multi", "fi", "ix", "slice", "e", "phi", "id", "ci", "t", "ui", "info", "length", "a", "index", "li", "ii", "io", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "v", "ji", "oi", "di", "l", "d", "si", "qi", "uri", "I", "c"], "hex": ["ip", "h", "batch", "hello", "alpha", "bit", "full", "host", "form", "pattern", "default", "character", "serial", "nexus", "ex", "sex", "cache", "json", "cookie", "hack", "result", "format", "http", "exp", "path", "zero", "orig", "rh", "buff", "pack", "digit", "raw", "lit", "str", "pex", "oct", "letter", "binary", "none", "null", "data", "temp", "rex", "char", "comp", "transform", "text", "he", "pixel", "string", "utf", "hash", " Hex", "cmp", "shift", "length"]}}
{"id1": "14650352", "id2": "1508161", "code1": "    boolean checkIfUserExists(String username) throws IOException {\n        try {\n            URL url = new URL(WS_URL + \"/user/\" + URLEncoder.encode(username, \"UTF-8\") + \"/profile.xml\");\n            HttpURLConnection conn = (HttpURLConnection) url.openConnection();\n            conn.connect();\n            InputStream is = conn.getInputStream();\n            is.close();\n            return true;\n        } catch (FileNotFoundException e) {\n            return false;\n        }\n    }\n", "code2": "    public void conMail(MailObject mail) throws NetworkException, ContentException {\n        HttpClient client = HttpConfig.newInstance();\n        String url = HttpConfig.bbsURL() + HttpConfig.BBS_MAIL_CON + mail.getId() + \"&\" + HttpConfig.BBS_MAIL_N_PARAM_NAME + \"=\" + mail.getNumber();\n        HttpGet get = new HttpGet(url);\n        try {\n            HttpResponse response = client.execute(get);\n            HttpEntity entity = response.getEntity();\n            if (HTTPUtil.isXmlContentType(response)) {\n                Document doc = XmlOperator.readDocument(entity.getContent());\n                BBSBodyParseHelper.parseMailContent(doc, mail);\n            } else {\n                String msg = BBSBodyParseHelper.parseFailMsg(entity);\n                throw new ContentException(msg);\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        } catch (IOException e) {\n            e.printStackTrace();\n            throw new NetworkException(e);\n        }\n    }\n", "label": 0, "substitutes": {"checkIfUserExists": ["checkIfuserexist", "checkIfUserExes", "checkIfUserListing", "checkIfUserexists", "checkIfuserexes", "checkIfUserLes", "checkIfuserExisting", "checkIfUserList", "checkIfuserExists", "checkIfUserContes", "checkIfUserexist", "checkIfUserContisting", "checkIfuserExes", "checkIfUserContist", "checkIfuserexisting", "checkIfUserexes", "checkIfUserLists", "checkIfUserExist", "checkIfUserexisting", "checkIfuserExist", "checkIfUserExisting", "checkIfUserContists", "checkIfuserexists"], "username": ["ername", "email", "profile", "key", "USER", "user", "title", "directory", "address", "home", "ame", "family", "path", "description", "staff", "uid", "uu", "login", "data", "u", "nick", "token", "users", "subject", "database", "text", "method", "role", "name", "auth", "me", "password", "string", "uri", "sudo", "mobile", "filename", "account"], "url": ["blog", "client", "sl", "host", "object", "feed", "impl", "user", "fl", "ls", "bb", "page", "server", "address", "loc", "connection", "http", "URL", "path", "resource", "aur", "ssl", "uc", "file", "build", "f", "Url", "api", "base", "channel", "log", "b", "org", "ll", "l", "browser", "string", "web", "ur", "uri", "www"], "conn": ["ai", "os", "connect", "Conn", "h", "p", "ctx", "n", "cp", "rc", "cn", "cs", "ls", "ns", "cli", "nt", "ci", "cf", "lc", "ann", "loc", "open", "dn", "connection", "nc", "http", "cos", "dc", "cur", "ssl", "con", "conf", "ch", "enc", "col", "close", "conv", "org", "rt", "ct", "co", "Connection", "act", "cb", "c"], "is": ["ai", "ip", "os", "in", "Is", "us", "bis", "iso", "isl", "isa", "i", "bs", "app", "its", "ls", "ens", "css", "isi", "ris", "IS", "ui", "info", "iss", "cos", "ios", "ori", "isc", "has", "iris", "ais", "abs", "fs", "serv", "api", "err", "it", "ins", "vs", "ss", "as", "ms", "act"]}}
{"id1": "11716816", "id2": "7122523", "code1": "    private void updateFile(File file) throws FileNotFoundException, IOException {\n        File destFile = new File(file.getPath().replace(URL_UNZIPPED_PREFIX + latestVersion, \"\"));\n        FileChannel in = null;\n        FileChannel out = null;\n        try {\n            if (!destFile.exists()) {\n                destFile.getParentFile().mkdirs();\n                destFile.createNewFile();\n            }\n            in = new FileInputStream(file).getChannel();\n            out = new FileOutputStream(destFile).getChannel();\n            in.transferTo(0, in.size(), out);\n        } finally {\n            if (out != null) out.close();\n            if (in != null) in.close();\n        }\n    }\n", "code2": "    public ActionForward execute(ActionMapping mapping, ActionForm form, HttpServletRequest request, HttpServletResponse response) throws Exception {\n        InstanciaDelegate delegate = RegistroManager.recuperarInstancia(request);\n        if (delegate == null) {\n            ActionErrors errors = new ActionErrors();\n            errors.add(null, new ActionError(\"errors.session\"));\n            saveErrors(request, errors);\n            return mapping.findForward(\"fail\");\n        }\n        AyudaPantalla ayudaPantalla = delegate.obtenerAyudaPantalla();\n        TraAyudaPantalla traAyudaPantalla = (TraAyudaPantalla) ayudaPantalla.getTraduccion();\n        String urlSonido = traAyudaPantalla.getUrlSonido();\n        if (urlSonido == null) {\n            return null;\n        }\n        URL url = new URL(urlSonido);\n        URLConnection urlConnection = url.openConnection();\n        urlConnection.connect();\n        String tipoMime = urlConnection.getContentType();\n        log.debug(\"Tipo Mime: \" + tipoMime);\n        Map audioOptions = new HashMap();\n        if (tipoMime.indexOf(\"audio\") != -1 || tipoMime.indexOf(\"asf\") != -1 || tipoMime.equals(\"unknown/unknown\")) {\n            audioOptions.put(\"id\", \"MediaPlayer\");\n            audioOptions.put(\"codeBase\", \"http://activex.microsoft.com/activex/controls/mplayer/en/nsmp2inf.cab#Version=6,4,7,1112\");\n            audioOptions.put(\"classId\", \"CLSID:22D6F312-B0F6-11D0-94AB-0080C74C7E95\");\n            audioOptions.put(\"mimeType\", \"application/x-mplayer2\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"http://www.microsoft.com/Windows/Downloads/Contents/Products/MediaPlayer/\");\n        } else if (tipoMime.indexOf(\"real\") != -1) {\n            audioOptions.put(\"id\", \"RVOCX\");\n            audioOptions.put(\"codeBase\", \"\");\n            audioOptions.put(\"classId\", \"clsid:CFCDAA03-8BE4-11cf-B84B-0020AFBBCCFA\");\n            audioOptions.put(\"mimeType\", \"audio/x-pn-realaudio-plugin\");\n            audioOptions.put(\"urlSonido\", urlSonido);\n            audioOptions.put(\"pluginSpage\", \"\");\n        }\n        request.setAttribute(\"audioOptions\", audioOptions);\n        log.debug(\"entra success\");\n        return mapping.findForward(\"success\");\n    }\n", "label": 0, "substitutes": {"updateFile": ["copyFile", "copyFolder", "upFolder", "upDirectory", "upFile", "importFolder", "updateDirectory", "updateFolder", "copyDirectory", "importBody", "upBody", "importFile", "copyBody", "updateBody", "importDirectory"], "file": ["get", "image", "db", "full", "files", "up", "class", "queue", "object", "socket", "load", "input", "future", "e", "parent", "handler", "File", "cache", "info", "connection", "content", "http", "path", "resource", "fp", "single", "io", "line", "FILE", "part", "dir", "f", "url", "this", "base", "model", "zip", "data", "type", "pe", "log", "b", "local", "name", "l", "lock", "current", "source", "filename"], "IOException": ["TimeoutProblem", "Downloadception", " IOProblem", "TimeoutException", "Timeoutception", "IOception", "DownloadException", "DownloadProblem", "IOProblem", " IOception"], "destFile": ["srcFiles", " destFull", " destPath", "destroyfile", "destroyTable", " destDir", "DestFile", "destroyDir", "sourceFiles", " destinationFull", "origTable", "destDir", "Destfile", "destFolder", "destfile", "destFiles", "flatfile", "sourceFolder", "sourceFile", "srcFile", "srcFolder", "DestPath", "DestFolder", " destfile", "origfile", " destinationFile", "destPath", " destTable", "origDir", "destFull", "DestDir", "destTable", "sourceDir", " destinationDir", "DestFiles", "flatDir", "origFile", "destroyFile", "flatFile", "flatFiles", " destFolder", "DestFull", " destFiles", " destinationFiles", "srcPath"], "in": ["r", "image", "client", "p", "pin", "sync", "inn", "gin", "isin", "i", "socket", "s", "init", "cin", "el", "input", "on", "id", "cf", "din", "conn", "ax", "connection", "a", "inner", "io", "pull", "nin", "con", "ini", "work", "inside", "min", "f", "this", "pass", "login", "err", "with", "b", "cl", "ins", "bin", "In", "l", "reader", "IN", "again", "as", "c", "lock", "re", "win", "source", "up", "ac", "inc"], "out": ["Out", "timeout", "client", "writer", "sync", "obj", "off", "n", "i", "output", "socket", "ou", "user", "ex", "option", "outside", "to", "conn", "cookie", "connection", "exp", "ext", "resource", "io", "nin", "at", "of", "url", "o", "no", "exec", "channel", "this", "pass", "lib", "err", "login", "b", "w", "net", "call", "name", "co", "bin", "In", "password", "OUT", "again", "point", "outs", "extra", "outer", "up", "c", "inc"]}}
{"id1": "5744493", "id2": "659316", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    public static void main(String[] argv) {\n        if (1 < argv.length) {\n            File[] sources = Source(argv[0]);\n            if (null != sources) {\n                for (File src : sources) {\n                    File[] targets = Target(src, argv);\n                    if (null != targets) {\n                        final long srclen = src.length();\n                        try {\n                            FileChannel source = new FileInputStream(src).getChannel();\n                            try {\n                                for (File tgt : targets) {\n                                    FileChannel target = new FileOutputStream(tgt).getChannel();\n                                    try {\n                                        source.transferTo(0L, srclen, target);\n                                    } finally {\n                                        target.close();\n                                    }\n                                    System.out.printf(\"Updated %s\\n\", tgt.getPath());\n                                    File[] deletes = Delete(src, tgt);\n                                    if (null != deletes) {\n                                        for (File del : deletes) {\n                                            if (SVN) {\n                                                if (SvnDelete(del)) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                            } else if (del.delete()) System.out.printf(\"Deleted %s\\n\", del.getPath()); else System.out.printf(\"Failed to delete %s\\n\", del.getPath());\n                                        }\n                                    }\n                                    if (SVN) SvnAdd(tgt);\n                                }\n                            } finally {\n                                source.close();\n                            }\n                        } catch (Exception exc) {\n                            exc.printStackTrace();\n                            System.exit(1);\n                        }\n                    }\n                }\n                System.exit(0);\n            } else {\n                System.err.printf(\"Source file(s) not found in '%s'\\n\", argv[0]);\n                System.exit(1);\n            }\n        } else {\n            usage();\n            System.exit(1);\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doFileCopy", " doFileWrite", " doFolderWrite", " dofileProxy", "newBlockCopy", " doFolderProxy", "newBlockWrite", " doBlockcopy", "newFileCopy", " doFilecopy", "newFilecopy", "newBlockProxy", "newFileWrite", " doFolderCopy", " doBlockWrite", " doFileProxy", " doBlockCopy", " dofileCopy", " dofileWrite", " doBlockProxy", "newFileProxy", " doFoldercopy", " dofilecopy", "newBlockcopy"], "in": ["image", "m", "buffer", "pin", "query", "inn", "isin", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "file", "part", "min", "url", "base", "login", "data", "err", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "buffer", "off", "output", "socket", "pre", "default", "user", "write", "copy", "ex", "page", "server", "cache", "conn", "source", "target", "connection", "ext", "resource", "io", "file", "part", "dot", "o", "prefix", "base", "exec", "temp", "b", "v", "name", "again", "string", "point", "outs", "external", "OUT"], "inChannel": [" inClient", "outStream", "inClient", "inputChannel", " inchannel", "inchannel", "INStream", "INChan", "outchannel", "outChan", "binSocket", "binChannel", " inChan", "InStream", "INSocket", "INChannel", "InChan", "outSocket", "inChan", "inputChan", "binChan", "binStream", "INClient", " inStream", "InChannel", "inSocket", " inSocket", "InSocket", "Inchannel", "INchannel", "outClient", "inputStream", "inputSocket", "inStream"], "outChannel": [" outBuffer", "outStream", " outchannel", "intChan", "inchannel", "OutChan", "outchannel", "outChan", "OutChannel", "outButton", "intChannel", "againSocket", " outButton", "againStream", " outChan", " outStream", "againChannel", "outSocket", "inChan", " outSocket", "intchannel", "inContainer", "inSocket", "outContainer", "OutBuffer", "inButton", "outBuffer", "intButton", "inBuffer", "OutStream", "OutContainer", " outContainer", "againChan", "inStream"], "maxCount": [" maxSize", " maxLength", "MaxSize", "MaxSum", "Maxcount", "maxSize", "blockcount", "maxLength", "MaxCount", "axcount", "maxSum", " maxcount", "axLength", "maxcount", "MaxLength", "axSize", "blockSum", "blockCount", "axCount", " maxSum", "blockSize"], "size": ["position", "bytes", "shape", "max", "ize", "p", "n", "capacity", "fee", "transfer", "sized", "limit", "address", "loc", "seek", "sum", "time", "send", "count", "available", "len", "start", "en", "min", "end", "unit", "mode", "scale", "data", "Size", "type", "range", "cap", "offset", "width", "volume", "name", "small", "speed", "empty", "shift", "flush", "SIZE", "length"], "pos": ["position", "os", "p", "obj", "off", "block", "i", "slice", "po", "id", "limit", "port", "address", "val", "open", "loc", "diff", "pointer", "cos", "index", "ref", "pose", "count", "POS", "part", "len", "start", "iter", "min", "o", "unit", "base", "pass", "no", "data", "rel", " position", "offset", "spec", "Pos", "point", "push", "slot", "pid", "neg", "pt", "length"]}}
{"id1": "14773780", "id2": "15500892", "code1": "    public void testImageInfo() throws MalformedURLException, IOException {\n        System.out.println(\"ImageInfo:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            ImageInfo ii = new ImageInfo();\n            ii.setInput(istream);\n            assertTrue(\"Not a supported image file format.\", ii.check());\n            int width = ii.getWidth();\n            int height = ii.getHeight();\n            System.out.println(width + \"x\" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"testImageInfo": [" checkMediaInfo", " checkAudioINFO", "testImageINFO", " checkimageINFO", "testMediaInfo", " checkAudioInfo", "testMediaINFO", " checkImageINFO", " checkimageInfo", " checkMediaINFO", " checkImageInfo"], "IOException": ["TimeoutProblem", "TimeoutError", " IOProblem", "IOError", "IOProblem", "TimeoutException", " IOError", "IPException", "IPError", "IPProblem"], "start": ["get", "error", "stage", "size", "left", "pos", "art", "pre", "use", "init", "load", "delay", "id", "check", "open", "from", "info", "diff", "Start", "time", "date", "step", "started", "end", "ish", "min", "st", "set", "scale", "offset", "style", "speed", "first", "shift", "source", "length"], "i": ["image", "ai", "ip", "uli", "m", "j", "p", "ie", "eni", "key", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "zi", "li", "index", "io", "iu", "ini", "bi", "x", "pi", "f", "xi", "ami", "ti", "k", "ri", "u", "y", "v", "ji", "oi", "mi", "di", "name", "hi", "d", "si", "yi", "qi", "I"], "url": ["image", "in", "sl", "full", "src", "feed", "ls", "bb", "id", "route", "album", "address", "http", "location", "URL", "path", "resource", "a", "hub", "fb", "ref", "img", "out", "file", "build", "f", "Url", "api", "base", "data", "err", "org", "name", "l", "href", "string", "uri", "source", "www"], "istream": ["istam", "istREAM", "intREAM", "istsstream", "irststream", "intam", "istsram", "istsREAM", "diststream", "istsam", "distream", "istram", "ISTream", "distram", "intream", "ISTam", "ISTstream", "irstream", "irstREAM", "intstream", "irstram", "distREAM", "istsream", "ISTREAM", "iststream"], "ii": ["image", "ai", "iq", "ice", "ie", "cci", "iso", "is", "sci", "init", "fi", "ix", "cli", "abi", "ci", "gi", "info", "ui", "inf", "mini", "iss", "zi", "iff", "li", "io", "II", "vi", "iu", "ori", "img", "ini", "fc", "bi", "pi", "agi", "xi", "ti", "ani", "ni", "ji", "oi", "inch", "di", "audi", "hi", "si", "qi", "iv", "uri", "iii"], "width": ["dim", "image", "fw", "large", "size", "shape", "ize", "left", "flow", "layout", "slice", "page", "port", "wid", "diff", "fb", "iff", "weight", "crop", "img", "z", "work", "lon", "wd", "fill", "x", "Width", "min", "en", "area", "platform", "scale", "data", "zip", "w", "gender", "name", "driver", "fx", "frame", "age", "px", "layer", "length"], "height": ["dim", "image", "pad", "ip", "h", "size", "shape", "max", "ady", "Height", "view", "layout", "rank", "deep", "ty", "th", "padding", "right", "crop", "direction", "img", "work", "z", "wd", "build", "angle", "x", "depth", "area", "inches", "y", "density", "w", "rows", "volume", "hd", "style", "stroke", "head", "window", "dy", "length"], "stop": ["next", "ip", "shape", "sort", "block", "output", "feed", "parent", "pop", "limit", "address", "run", "op", "hide", "sleep", "exit", "change", "step", "fill", "end", "trip", "Stop", "set", "rest", "norm", "keep", "put", "drop", "log", "wait", "number", "continue", "ops", "skip", "nat", " Stop", "speed", "place", "enable", "sign", "cut"]}}
{"id1": "4223002", "id2": "13414771", "code1": "    public String getPasswordMD5() {\n        try {\n            MessageDigest algorithm = MessageDigest.getInstance(\"MD5\");\n            algorithm.reset();\n            algorithm.update(password.getBytes());\n            byte messageDigest[] = algorithm.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < messageDigest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & messageDigest[i]));\n            }\n            return hexString.toString();\n        } catch (NoSuchAlgorithmException nsae) {\n        }\n        return null;\n    }\n", "code2": "    @Digester(forField = \"password\")\n    public static String encriptPassword(String passwd) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(passwd.getBytes());\n            BigInteger hash = new BigInteger(1, md.digest());\n            return hash.toString(16);\n        } catch (Exception e) {\n            return null;\n        }\n    }\n", "label": 1, "substitutes": {"getPasswordMD5": ["getPasswordMAC512", "getpasswordMD512", "getPasswordMac256", "getPasswordMD1", "getPasswordMAC256", "getpasswordMD1", "getpasswordSHA1", "getpasswordMD256", "getpasswordMD5", "getPasswordSHA5", "getPasswordMAC1", "getPasswordMac1", "getPasswordMac5", "getPasswordMD512", "getpasswordSHA256", "getPasswordMD256", "getPasswordMAC5", "getpasswordSHA5", "getPasswordSHA1", "getpasswordSHA512", "getPasswordMac512", "getPasswordSHA512", "getPasswordSHA256"], "algorithm": ["calgorith", "algebra", "algo", "aggo", "geest", "gem", " alm", "Alignment", "alger", "agignment", "fgorithm", "Algebra", "Alger", "fgo", "Algorithm", " algorith", " alignment", "Alest", " alger", "geger", " algo", "alm", " alphabet", "fgorith", "alrator", "Algorith", "aggorithm", "omalgo", "omalgorith", "Alrator", "omalgorithm", "calgo", "alphabet", "Alm", "calgorithm", "calgebra", "omalphabet", "alignment", "Alphabet", " alest", "agrator", "alest", "fgebra", "gegorithm", " alrator", "Algo", "algorith"], "messageDigest": ["messageMDester", " messageDigString", " messageDigEST", "messageDester", "messageDEST", "messageMDest", "messageDest", "phraseDigested", "messagedigester", "MessageDigested", "phrasedigester", "messageDigester", "messagedigEST", " messageDigester", "MessageDigEST", "messageDested", "messageDigString", "messageModested", "messagedigested", "MessageModEST", "messageMDString", "phraseDigest", "messagedigString", "messageDigEST", "MessageDigest", " messagedigest", " messagedigester", "MessageModester", "phrasedigEST", "messageDigested", "phrasedigest", "MessageModest", "messageMDEST", "phraseDigEST", "MessageModested", "phrasedigested", " messagedigString", "messageModEST", "messagedigest", " messagedigEST", "messageModString", "messageModest", "phraseDigester", "MessageDigester", "messageModester"], "hexString": ["byteStream", "checkStr", " hexArray", "textBuffer", " hexStream", "shortBuffer", "checkString", " hexStr", "checkFunction", "hexstring", " hexLine", "hashBuffer", "hexArray", "byteArray", "hexFunction", "shortString", "checkBuffer", "byteLine", " hexFunction", "hexLine", "textstring", "shortstring", "textLine", "hashFunction", "hashString", " hexBuffer", "textStream", "hashStr", "textArray", "byteString", "hexBuffer", "hexStream", "hexStr", "shortArray", " hexstring", "textString"], "i": ["r", "ai", "in", "m", "h", "p", "j", "n", "key", "s", "multi", "fi", "slice", "ix", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "ui", "info", "a", "zi", "li", "index", "ii", "io", "bi", "end", "x", "pi", "f", "o", "xi", "ti", "ri", "type", "u", "b", "v", "oi", "mi", "di", "volume", "l", "hi", "d", "si", "chi", "uri", "I", "c"]}}
{"id1": "19584877", "id2": "4686922", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void extractResourceToFile(String resourcePath, File dest) {\n        InputStream in = getClass().getResourceAsStream(resourcePath);\n        try {\n            FileOutputStream out = FileUtils.openOutputStream(dest);\n            try {\n                IOUtils.copy(in, out);\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "5436973", "id2": "22368133", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    public static void testMapSource(MapSource mapSource, EastNorthCoordinate coordinate) {\n        try {\n            System.out.println(\"Testing \" + mapSource.toString());\n            int zoom = mapSource.getMinZoom() + ((mapSource.getMaxZoom() - mapSource.getMinZoom()) / 2);\n            MapSpace mapSpace = mapSource.getMapSpace();\n            int tilex = mapSpace.cLonToX(coordinate.lon, zoom) / mapSpace.getTileSize();\n            int tiley = mapSpace.cLatToY(coordinate.lat, zoom) / mapSpace.getTileSize();\n            url = new URL(mapSource.getTileUrl(zoom, tilex, tiley));\n            System.out.println(\"Sample url: \" + url);\n            c = (HttpURLConnection) url.openConnection();\n            System.out.println(\"Connecting...\");\n            c.connect();\n            System.out.println(\"Connection established - response HTTP \" + c.getResponseCode());\n            if (c.getResponseCode() != 200) return;\n            String contentType = c.getContentType();\n            System.out.print(\"Image format          : \");\n            if (\"image/png\".equals(contentType)) System.out.println(\"png\"); else if (\"image/jpeg\".equals(contentType)) System.out.println(\"jpg\"); else System.out.println(\"unknown\");\n            String eTag = c.getHeaderField(\"ETag\");\n            boolean eTagSupported = (eTag != null);\n            if (eTagSupported) {\n                System.out.println(\"eTag                  : \" + eTag);\n                testIfNoneMatch();\n            } else System.out.println(\"eTag                  : -\");\n            long date = c.getDate();\n            if (date == 0) System.out.println(\"Date time             : -\"); else System.out.println(\"Date time             : \" + new Date(date));\n            long exp = c.getExpiration();\n            if (exp == 0) System.out.println(\"Expiration time       : -\"); else System.out.println(\"Expiration time       : \" + new Date(exp));\n            long modified = c.getLastModified();\n            if (modified == 0) System.out.println(\"Last modified time    : not set\"); else System.out.println(\"Last modified time    : \" + new Date(modified));\n            testIfModified();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        System.out.println(\"\\n\");\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStringCupid", "httpToPageStored", "httpToStringCored", "httpToStringStored", "httpToStringUupid", "httpToPageComp", "httpToStringCrict", "httpToStringstupid", "httpToStringstrict", "httpToStringstomp", "httpToStringStomp", "httpToStringStrict", "httpToPageCored", "httpToStringstored", "httpToPageCrict", "httpToPageCupid", "httpToPageStrict", "httpToStringUomp", "httpToPageStupid", "httpToPageStomp", "httpToStringComp", "httpToStringUrict", "httpToStringUored"], "url": ["request", "image", "domain", "service", "sl", "html", "host", "i", "feed", "version", "ls", "route", "page", "id", "server", "address", "connection", "location", "http", "URL", "resource", "path", "ssl", "file", "str", "f", "Url", "channel", "base", "api", "secret", "https", "name", "l", "string", "href", "uri", "source", "config", "www"], "IOException": ["Downloadception", "IOError", "ConfigurationError", "Configurationception", "IOception", " IOception", " IOError", "ConfigurationException", "DownloadException", "DownloadError"], "HttpException": ["Downloadception", "HTTPException", "httpException", "httpception", "DownloadException", "Httpception", "HTTPception"], "InterruptedException": ["InterSleepExit", " InterruptedExit", "InterIOExit", "InterIOExcept", "InterruptException", "InterIOError", " InterruptException", " InterruptExit", " InterruptExcept", "InterruptError", "InterSleepError", "InterIOException", "InterSleepExcept", "InterruptedError", " InterruptedError", "InterruptedExcept", " InterruptedExcept", "InterruptExit", " InterruptError", "InterSleepException", "InterruptedExit", "InterruptExcept"], "URISyntaxException": ["URISyntaceError", "URISyntaceException", "URISyntixception", "URISyntaxception", "URISlntaxException", "URISyntixError", "URISyntixException", "URISlntaxception", "URISlaxception", "URISyntntaxception", "URISyntntaxError", "URISyntaxError", "URISyntaceEx", "URISlaxError", "URISyntaceception", "URISlntaxError", "URISyntntaxEx", "URISlaxException", "URISyntntaxException", "URISlntaxEx", "URISyntixEx", "URISyntaxEx", "URISlaxEx"], "pageDump": [" pageDumps", "pageDsumper", "pageDash", "pagedumper", "pagedump", " pageBumping", "pageDsumps", " pageBumps", "pageFumps", "pagedumps", "pageDoumper", " pageDumping", "pageDoumping", " pageDumper", "pageLumps", " pageBumm", "pageFumper", "pageLump", "pageDsumm", "pageDumps", "pageLumping", " pageBump", "pageLumper", "pagedash", "pageBumper", " pageBumper", " pageDumm", "pageDoumps", "pageFump", "pageBumps", "pageDumping", "pageBash", " pageDash", "pageDoump", "pageDumper", "pageFash", "pageBumping", "pageBump", "pageBumm", " pageBash", "pageDoumm", "pageDumm", "pageDsump"], "httpget": ["httpGET", "urlrequest", "Httpget", "httpstart", "urlget", " httpgot", "hrget", "phstart", "phpfind", "Httpset", "hrgot", "hrstart", "phgot", "httpGet", "hrGet", "httpset", "phpstart", "httprequest", " httpfind", "HttpGet", " httprequest", "phget", "phpGET", "httstart", "httGET", "urlGet", " httpset", "httfind", "Httprequest", "httpgot", "phpget", "urlset", "httget", "phGet", "httpfind", " httpstart", " httpGET", " httpGet"], "response": ["request", "get", "success", "error", "received", "full", "output", "reply", "object", "relation", "e", "environment", "page", "server", "json", "result", "connection", "http", "message", "resource", "Response", "resp", "ception", "api", "onse", "data", "collection", "status", "application", "method", "document", "res", "body", "respond", "uri"], "entity": ["image", "error", "component", "service", "query", "element", "entry", "output", "object", "instance", "e", "environment", "page", "json", "server", "agent", "result", " Entity", "connection", "content", "resource", "Entity", "message", "xml", " entities", "translation", "Response", "resp", "unit", "security", "model", "data", "ent", "article", "collection", "ity", "document", "body", "event", "person"]}}
{"id1": "8164056", "id2": "23517481", "code1": "    private String encode(String str) {\n        StringBuffer buf = new StringBuffer();\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(str.getBytes());\n            byte bytes[] = md5.digest();\n            for (int i = 0; i < bytes.length; i++) {\n                String s = Integer.toHexString(bytes[i] & 0xff);\n                if (s.length() == 1) {\n                    buf.append(\"0\");\n                }\n                buf.append(s);\n            }\n        } catch (Exception ex) {\n        }\n        return buf.toString();\n    }\n", "code2": "    private String md5(String uri) throws ConnoteaRuntimeException {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(uri.getBytes());\n            byte[] bytes = messageDigest.digest();\n            StringBuffer stringBuffer = new StringBuffer();\n            for (byte b : bytes) {\n                String hex = Integer.toHexString(0xff & b);\n                if (hex.length() == 1) {\n                    stringBuffer.append('0');\n                }\n                stringBuffer.append(hex);\n            }\n            return stringBuffer.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new ConnoteaRuntimeException(e);\n        }\n    }\n", "label": 1, "substitutes": {"encode": ["encquote", "unquote", "enquote", "uncode", "Enquote", "Encod", "enccode", "enccod", "enode", "Enode", "encod", "unode", "uncod", "Encode"], "str": ["STR", "r", "in", "fr", "buffer", "p", "obj", "br", "sp", "ctr", "strings", "input", "e", "Str", "stri", "result", "code", "exp", "inner", "cur", "orig", "hr", "iter", "f", "rev", "st", "enc", "this", "data", "temp", "err", "div", "char", "er", "text", "arr", "string", "hex", "txt"], "buf": ["db", "bp", "buffer", "cas", "bu", "ctx", "bf", "br", "obj", "ff", "ab", "src", "fd", "queue", "tmp", "bb", "pkg", "cf", "Buffer", "sb", "coll", "result", "aux", "bc", "rb", "fb", "array", "af", "cur", "fp", "buff", "proc", "uc", "box", "pb", "Buff", "bh", "bd", "bag", "f", "binary", "wb", "vec", "conv", "data", "err", "b", "cv", "uf", "cb", "agg"], "md5": [" md512", "MD2", "md4", "dig512", " md2", "MD3", "MD5", "sha5", "MD11", "sha2", "md3", "md2", " md3", "dig11", " md4", "md11", "MD512", "md512", "dig5", " md11", "sha512", "dig4", "MD4", "sha3"], "bytes": ["items", "letters", "seq", "words", "bis", "steps", "files", "bs", "units", "cells", "sequence", "slice", "ls", "ns", "ips", "es", "lines", "objects", "boot", "quarters", "seconds", "content", "tes", "bps", "Bytes", "codes", "pieces", "ings", "classes", "bits", "pages", "binary", "data", "values", "b", "pins", "errors", " elements", "rows", "text", "bles", "vs", "body", "string", "parts", "rules", "outs", " strings"], "i": ["ai", "in", "m", "h", "p", "j", "n", "key", "multi", "slice", "e", "phi", "id", "mu", "ci", "gi", "abi", "t", "val", "ui", "info", "length", "inner", "index", "li", "ii", "io", "ori", "bi", "part", "x", "pi", "f", "o", "xi", "ti", "ri", "u", "b", "v", "ji", "oi", "di", "hi", "l", "d", "si", "chi", "qi", "uri", "I", "c"], "s": ["S", "os", "su", "in", "m", "h", "p", "sl", "service", "n", "cs", "strings", "its", "ls", "e", "ns", "ex", "t", "es", "sb", "sg", "a", "aws", "ds", "abs", "f", "o", "fs", "u", "b", "v", "spec", "hs", "secret", "l", "signed", "ss", "d", "string", "si", "js", "ws", "c"]}}
{"id1": "14567939", "id2": "5441579", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"baseHash": [" generateHash", " chainFile", " chainHash", "BaseSecret", "BaseFile", "Basehash", "basehash", "BaseHash", " generateSecret", " generatehash", " chainhash", " chainSecret", " generateFile", "baseSecret", "baseFile"], "name": ["image", "hello", "n", "key", "class", "host", "object", "user", "parent", "id", "address", "ame", "alias", "path", "resource", "word", "file", "part", "NAME", "prefix", "normal", "base", "definition", "data", "type", "secret", "Name", "names", "member", "style", "string", "named", "hash", "create", "account"], "password": ["account", "words", "crypt", "key", "profile", "pattern", "input", "attribute", "sword", "phrase", "source", "diff", "padding", "Password", "code", "path", "word", "value", "wd", "prefix", "device", "pass", "security", "wallet", "data", "paste", "token", "secret", "text", "auth", "string", "stroke", "seed", "hash", "priv", "PASS", "username"], "digest": ["mdr", " digested", "signest", "mdester", " digger", "digusher", "DigEST", "digger", "mdest", "diger", "Diger", "modested", "moder", "signger", "Digest", "Digger", " diger", "Digester", " digester", "signusher", "modest", "digester", "digEST", "decest", "mdEST", "modester", "Digr", "signer", "decester", "decEST", "Digusher", " digusher", "digested", "digr", "Digested", "decr", "signester"]}}
{"id1": "23008590", "id2": "10176678", "code1": "            public void run() {\n                URL url;\n                try {\n                    url = new URL(Config.UPDATE_SITE_URL);\n                    InputStream is = url.openStream();\n                    Writer writer = new StringWriter();\n                    char[] buffer = new char[1024];\n                    Reader reader = new BufferedReader(new InputStreamReader(is, \"UTF-8\"));\n                    int n;\n                    while ((n = reader.read(buffer)) != -1) {\n                        writer.write(buffer, 0, n);\n                    }\n                    String updatePage = writer.toString();\n                    is.close();\n                    writer.close();\n                    System.out.println(\"DOWNLOAD PAGE :\\n\" + updatePage);\n                    int pos1 = updatePage.indexOf(\"[ANA-CABV]\") + 10;\n                    int pos2 = updatePage.indexOf(\"[/ANA-CABV]\");\n                    int pos3 = updatePage.indexOf(\"[ANA-CABVURL]\") + 13;\n                    int pos4 = updatePage.indexOf(\"[/ANA-CABVURL]\");\n                    String currentVersion = updatePage.substring(pos1, pos2);\n                    currentVersionLabel.setText(currentVersionLabel.getText() + currentVersion);\n                    if (Double.valueOf(Config.VERSION) < Double.valueOf(currentVersion)) {\n                        downloadButton.setEnabled(true);\n                        label0.setText(mw.getLangMap().get(\"Update_Avalaible\"));\n                    } else label0.setText(mw.getLangMap().get(\"Update_NonAvalaible\"));\n                    downloadURL = updatePage.substring(pos3, pos4);\n                } catch (MalformedURLException e) {\n                    e.printStackTrace();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n", "code2": "    @Test\n    public void testLoadHttpGzipped() throws Exception {\n        String url = HTTP_GZIPPED;\n        LoadingInfo loadingInfo = Utils.openFileObject(fsManager.resolveFile(url));\n        InputStream contentInputStream = loadingInfo.getContentInputStream();\n        byte[] actual = IOUtils.toByteArray(contentInputStream);\n        byte[] expected = IOUtils.toByteArray(new GZIPInputStream(new URL(url).openStream()));\n        assertEquals(expected.length, actual.length);\n    }\n", "label": 0, "substitutes": {"run": ["process", " Run", "output", "load", "java", "init", "install", "server", "apply", "info", "submit", "report", "Run", "work", "build", "start", "exec", " deploy", "login", "update", "Main", "execute", "test", "running", "up", "launch"], "url": ["lr", "image", "r", "blog", "service", "sl", "i", "host", "feed", "proxy", "il", "id", "page", "server", "address", "bel", "loc", "http", "location", "URL", "resource", "path", "hub", "ssl", "keeper", "file", "str", "f", "Url", "api", "base", "update", "download", "loader", "article", "name", "l", "browser", "string", "web", "ur", "uri", "source", "config", "www"], "is": ["lis", "r", "os", "in", "ai", "ip", "Is", "iterator", "image", "bis", "ie", "stream", "src", "i", "s", "app", "was", "its", "il", "ls", "id", "es", "isi", "address", "ris", "IS", "info", "ui", "or", "iss", "http", "ios", "io", "has", "ir", "out", "ini", "ais", "iter", "fs", "api", "ri", "err", "it", "browser", "ar", "as", "uri", "iv"], "writer": ["r", "in", "wire", "ner", "creator", "worker", "key", "feed", "layer", "write", "ee", "parent", "page", "maker", "handler", "server", "Writer", "written", "ler", "writers", "editor", "war", "word", "out", "work", "wr", "file", "director", "riter", "winner", "letter", "null", "zip", "data", "builder", "temp", "wer", "player", "er", "w", "driver", "writ", "string", "parser", "ws", "journal", "writing", "widget", "source", "walker"], "buffer": ["position", "bytes", "batch", "block", "queue", "transfer", "feed", "character", "slice", "sequence", "page", "Buffer", "cache", "phrase", "address", "stack", "source", "result", "padding", "resource", "buff", "row", "uffer", "iter", "buf", "binary", "base", "data", "player", "b", "border", "char", "wave", "memory", "bin", "string", "counter", "seed", "vector", "read", "layer", "length"], "reader": ["r", "iterator", "in", "ner", "worker", "Reader", "stream", "rer", "i", "input", "e", "rx", "handler", "per", "ler", "dr", "editor", "io", "ir", "rr", "row", "reading", "rar", "iter", "f", "ri", "loader", "er", "oder", "parser", "ser", "read", "source", "bird"], "n": ["r", "ne", "m", "j", "p", "ner", "h", "nor", "pos", "i", "s", "na", "nn", "e", "ns", "nt", "sn", "ng", "t", "N", "dn", "nc", "not", "num", "nin", "z", "out", "count", "nr", "len", "en", "x", "f", "o", "no", "k", "u", "b", "y", "number", "l", "d", "nl", "nb", "c"], "updatePage": ["updatedVersion", "updateUrl", "updateFile", "currentpage", "UpdateUrl", " updateVersion", "downloadPage", "updateLine", "currentLine", " updatepage", "downloadUrl", "currentServer", "downloadpage", " updateUrl", "downloadVersion", "updatedFile", " updateServer", " updateSite", "workLine", "updateSite", " updateLine", "updatedServer", "updatedPage", "updatedpage", "updateVersion", "updatedLine", "UpdateFile", "Updatepage", "UpdateVersion", "downloadLine", "workSite", "updateServer", "UpdatePage", "updatepage", " updateFile", "currentSite", "updatedUrl", "currentUrl", "currentPage", "workPage"], "pos1": ["POS3", " posOne", "positionOne", "Pos1", "POS0", "position0", "Pos2", "position2", "position3", "POSOne", "Pos4", "Pos3", "POS1", "posOne", " pos0", "pos0", "position1", "position4"], "pos2": ["posSecond", "index3", "index5", "po22", "pos5", "POS4", "index4", "POS5", "po5", "pos22", "position2", "position3", "POS2", "index1", "po2", "POS22", "index22", "index2", "positionSecond", "indexSecond", "position1", "po4", " posSecond"], "pos3": ["Pos1", "position03", "pos03", "pose1", "Pos2", "position2", "position3", "pose2", " pos03", "Pos3", "pose3", "pos43", "position1", "Pos43", "position43", "Pos03", "pose43"], "pos4": ["index7", "pos04", "index3", "position7", "pose4", "pose1", "po1", "index4", " pos04", "position2", "position3", " pos7", "po04", "posefour", "pofour", "pos7", " posfour", "index2", "pose04", "posfour", "po4", "position4"], "currentVersion": [" currentName", "reportedUrl", " currentPage", "updatePackage", " currentRelease", "reportedVersion", "currentRelease", "initialPackage", "CurrentPatch", "CurrentUrl", "CurrentRelease", "updateRelease", "CurrentName", " currentPackage", "CurrentVersion", "currentName", "updateVer", "updateVersion", "reportedName", "currentPackage", "currentVer", "initialPage", " currentUrl", "initialVer", " currentPatch", "CurrentPackage", "CurrentVer", "currentPatch", "reportedPatch", "CurrentPage", "currentUrl", "initialVersion", "currentPage"], "downloadURL": ["updateLocation", "updateUrl", "updateURL", "installUrl", "downloadLocation", " downloadLocation", "installURL", " downloadUrl", "installLocation", "downloadUrl"]}}
{"id1": "21488868", "id2": "5035872", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "16388708", "id2": "12766394", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    public void testReadHelloWorldTxt() throws Exception {\n        final InputStream helloWorldIS = this.getClass().getClassLoader().getResourceAsStream(BASE_DIR + \"/HelloWorld.txt\");\n        FileUtils.forceMkdir(new File(this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver\"));\n        final String helloWorldPath = this.testDir.getAbsolutePath() + \"/org/settings4j/contentresolver/HelloWorld.txt\";\n        final FileOutputStream fileOutputStream = new FileOutputStream(new File(helloWorldPath));\n        IOUtils.copy(helloWorldIS, fileOutputStream);\n        IOUtils.closeQuietly(helloWorldIS);\n        IOUtils.closeQuietly(fileOutputStream);\n        LOG.info(\"helloWorldPath: \" + helloWorldPath);\n        final FSContentResolver contentResolver = new FSContentResolver();\n        contentResolver.setRootFolderPath(this.testDir.getAbsolutePath());\n        byte[] content = contentResolver.getContent(\"org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n        content = contentResolver.getContent(\"file:laksjdhalksdhfa\");\n        assertNull(content);\n        content = contentResolver.getContent(\"/org/settings4j/contentresolver/HelloWorld.txt\");\n        assertNotNull(content);\n        assertEquals(\"Hello World\", new String(content, \"UTF-8\"));\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "17083703", "id2": "160705", "code1": "    public void savaRolePerm(String roleid, Collection role_perm_collect) throws DAOException, SQLException {\n        ConnectionProvider cp = null;\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement pstmt = null;\n        PrivilegeFactory factory = PrivilegeFactory.getInstance();\n        Operation op = factory.createOperation();\n        try {\n            cp = ConnectionProviderFactory.getConnectionProvider(Constants.DATA_SOURCE);\n            conn = cp.getConnection();\n            try {\n                pstmt = conn.prepareStatement(DEL_ROLE_PERM);\n                pstmt.setString(1, roleid);\n                pstmt.executeUpdate();\n            } catch (Exception e) {\n            }\n            if ((role_perm_collect == null) || (role_perm_collect.size() == 0)) {\n                return;\n            } else {\n                conn.setAutoCommit(false);\n                pstmt = conn.prepareStatement(ADD_ROLE_PERM);\n                Iterator role_perm_ir = role_perm_collect.iterator();\n                while (role_perm_ir.hasNext()) {\n                    RolePermission rolePerm = (RolePermission) role_perm_ir.next();\n                    pstmt.setString(1, String.valueOf(rolePerm.getRoleid()));\n                    pstmt.setString(2, String.valueOf(rolePerm.getResourceid()));\n                    pstmt.setString(3, String.valueOf(rolePerm.getResopid()));\n                    pstmt.executeUpdate();\n                }\n                conn.commit();\n                conn.setAutoCommit(true);\n            }\n        } catch (Exception e) {\n            conn.rollback();\n            throw new DAOException();\n        } finally {\n            try {\n                if (conn != null) {\n                    conn.close();\n                }\n                if (pstmt != null) {\n                    pstmt.close();\n                }\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public static boolean downloadFile(String url, String destination) throws Exception {\n        BufferedInputStream bi = null;\n        BufferedOutputStream bo = null;\n        File destfile;\n        byte BUFFER[] = new byte[100];\n        java.net.URL fileurl;\n        URLConnection conn;\n        fileurl = new java.net.URL(url);\n        conn = fileurl.openConnection();\n        long fullsize = conn.getContentLength();\n        long onepercent = fullsize / 100;\n        MessageFrame.setTotalDownloadSize(fullsize);\n        bi = new BufferedInputStream(conn.getInputStream());\n        destfile = new File(destination);\n        if (!destfile.createNewFile()) {\n            destfile.delete();\n            destfile.createNewFile();\n        }\n        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n        int read = 0;\n        int sum = 0;\n        long i = 0;\n        while ((read = bi.read(BUFFER)) != -1) {\n            bo.write(BUFFER, 0, read);\n            sum += read;\n            i += read;\n            if (i > onepercent) {\n                i = 0;\n                MessageFrame.setDownloadProgress(sum);\n            }\n        }\n        bi.close();\n        bo.close();\n        MessageFrame.setDownloadProgress(fullsize);\n        return true;\n    }\n", "label": 0, "substitutes": {"savaRolePerm": ["sqlRolePerms", "sqlRolePERM", "sqlRolePermission", "sqlRolePerM", "sqlRolePerm", "sqlRoleperm", "sqlRolePERms", "sqlRolepermission", "sqlRolePERm", "sqlRoleperM", "sqlRolePERmission", "sqlRoleperms"], "roleid": ["roid", "roids", "teamname", "RoleId", "roId", "rolename", " rolename", "teamid", "resourceID", "teamID", " roleID", "resourceId", "teamId", "Roleids", "resourcename", " roleId", "Roleid", " roleids", "roinfo", "resourceid", "roleids", " roleinfo", "Roleinfo", "roleId", "roleID", "roleinfo"], "role_perm_collect": ["role_per_collection", "role_permfCollect", "role_per_cont", "role_perm_map", "role_perm_ignore", "role_per_map", "role_per_col", "role_perm_collection", "role_permamcollection", "role_permpcont", "role_permfcollect", "role_perm_col", "role_permpcollect", "role_perm_coll", "role_permamcollect", "role_permpcollection", "role_permpCollect", "role_perm__collect", "role_perm__collection", "role_permfcollection", "role_per_collect", "role_perm__map", "role_perm__ignore", "role_perm_set", "role_per_set", "role_permfcol", "role_perm_Collect", "role_permamignore", "role_per_coll", "role_perm__cont", "role_per_Collect", "role_perm_cont", "role_permpcol", "role_per_ignore", "role_permammap"], "cp": ["orp", "bp", "ca", "Conn", "p", "ph", "ctx", "pp", "cn", "cc", "cs", "pg", "gp", "pkg", "cr", "pd", "cf", "cd", "dc", "fp", "cm", "cop", "pool", "DC", "proc", "cdn", "ch", "tp", "CF", "jp", "pm", "cpp", "ct", "pc", "mp", "mc", "hp", "cmp", "CP", "priv", "cb", "c", "pr", "dp"], "conn": ["orp", "db", "error", "client", "ca", "connect", "Conn", "p", "ok", "sync", "ctx", "n", "oss", "cn", "cc", "pg", "ou", "cat", "cr", "po", "nt", "ci", "cf", "core", "coll", "server", "fail", "reg", "loc", "ann", "dn", "connection", "dc", "nc", "ssl", "con", "uc", "config", "util", "col", "ch", "enc", "oci", "exec", "sql", "close", "ac", "org", "ct", "pc", "co", "mc", "res", "Connection", "lock", "act", "cmp", "cb", "c", "pr", "ec"], "rs": ["os", "RS", "rl", "rc", "cs", "Rs", "xs", "ls", "ns", "rx", "ows", "RC", "ris", " Rs", "rm", " rows", "row", "ds", "mr", "rep", "rt", "eps", "rows", "res", "ss", "ps", "runs", "pr"], "pstmt": ["pctm", "pconstmb", "pstpo", " psthmt", "pconstma", "Pstmr", " pssmt", "pctmr", "pstmb", "pddr", "pvmn", "Pstmb", "pctmb", "pptmt", "pssmb", "pstml", "pstmd", "pctmt", "pptmp", "pftm", "pstmn", "pvmt", " postma", "Pctma", "postma", "pstst", "Pctmit", "pftnt", " pstml", "Pstst", "pStm", "pStmt", " postm", "psthpo", "pssdr", " psthm", "pssnt", "Pctst", "Pstwd", " pstnt", " pvmt", "pstm", "pptnt", "pctmc", "pfmb", "pfm", "Pctbm", "pftdt", " pstdr", "Pstm", "pngm", " pssnt", "psthmn", "Pstnt", "psthmb", "pstdr", "pstbm", "postnt", "pctwd", "pfmr", " pftmp", "postm", " pstmn", "pwdmt", "pStma", "Pstmt", "pctpo", "Pctmp", "pssmt", "pwdnt", "pctmd", "pscmc", "pstma", " pftmt", " pvmn", "pspmr", " pftm", "psthnt", "pfmt", "pstmr", "Pctmr", "pstmc", "pctbm", "psthdt", "Pctmc", "pctmn", "pdmb", "pscmb", "pfmit", " pstma", " psthmd", "pdnt", "pftmp", "pStnt", "postmb", "pngmb", "pctml", "pngmt", "Pctmt", "Pstmp", "pstdt", " postnt", "pattmt", "pctma", " pstmd", " pssdr", "pngmit", "pconstmt", "pattmd", "pattpo", "Pstbm", "Pctwd", " pstpo", "pctmit", "pctnt", "pStmb", "Pctdt", "pftmt", "Pctnt", " pssmb", "psthm", "psthml", "pStwd", " pvmb", " pstmp", "pvml", " pftnt", "pstmit", "pspmp", "pconstwd", "Pstma", "pstwd", "pctmp", "pstmp", "pctdt", "Pstmc", " postmt", " psthpo", "psthmd", "pstnt", "pspmt", " pstm", "pdmt", "psthmt", "Pctm", "pspm", "pscmt", "psthst", "Pstdt", "pvmb", "pfmp", "pattm", "Pstmit", "pctst", "pwdm", "pftst", "pscnt", " pstmb", "pctdr", " pvml", "postmt", "Pctmb", "postmc", "pptm", "pwdbm"], "factory": ["clier", "viller", "cactory", "ciller", "mlier", "miller", "mactory", "mixture", "fille", "FFactory", "filux", "vixture", "cixture", "Flux", "vactory", "fFactory", "fixture", "flier", "Factory", "familyille", "familyFactory", "flux", "familyactory", "fiille", "filler", "vlier", "fiFactory", "fiactory", "Fille", "familylux"], "op": [" OP", "Op", " org", " operator", " project", " ops", " Op", " opt", " ori", " cop", "Oper", "oper", "or", " auth", "oc", " http", "operation", " os", " operate", " co", "o", "Ops", " parent", "ops", " app", "Operation", " Operation", "OP"], "role_perm_ir": ["role_per_iter", "role_perm_iter", "role_priv_ir", "role_per_ir", "role_per_ior", "role_perm_ior", "role_perm_reader", "role_perm_IR", "role_priv_iter", "role_permidirt", "role_permqir", "role_perm_nir", "role_per_reader", "role_permqior", "role_permidire", "role_per_ire", "role_permqiter", "role_permiditer", "role_permqreader", "role_per_irt", "role_priv_IR", "role_priv_nir", "role_perm_irt", "role_perm_ire", "role_permidir"], "rolePerm": ["RoleAdr", "RolePermission", "rolePartM", "RolePerr", " rolePm", "rolePERM", "rolePmission", "rolPerm", "RoleAdm", "rolePERmission", "roleperms", "roleParms", "roleAdr", "rolElmission", " rolePp", "roleElms", "rolElM", " rolePmission", "rolePrivmission", "rolElm", "rolPerM", "rolePerms", "rolePerp", " rolePermission", "roleParmission", "rolePERr", "rolePm", "rolePrivr", "RolePartmission", "RolePartM", "RoleAdM", "roleAdm", "rolePrivms", "roleperm", "rolElms", " rolePerp", "rolePERms", " rolePerms", "RolePerM", "roleElmission", "roleElM", "roleParp", "RolePerm", "rolePrivM", "rolPermission", "roleParm", "roleAdM", "rolePartms", "rolePrivm", "roleElm", "rolPerms", "RolePartm", "rolePerM", "RolePerms", "RolePartms", "rolePartmission", "rolePms", "rolePp", "rolePerr", " rolePms", "rolePartm", "roleperp", "rolePERm", "rolePermission", "rolepermission"]}}
{"id1": "22708533", "id2": "21555906", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    public void actionPerformed(ActionEvent ae) {\n        if (ae.getSource() == jbutton) {\n            try {\n                String toservlet = \"http://localhost:8080/direto-project/arquivos/teste.odt\";\n                URL servleturl = new URL(toservlet);\n                URLConnection servletconnection = servleturl.openConnection();\n                servletconnection.setDoInput(true);\n                servletconnection.setDoOutput(true);\n                servletconnection.setUseCaches(false);\n                servletconnection.setDefaultUseCaches(false);\n                DataInputStream inputFromClient = new DataInputStream(servletconnection.getInputStream());\n                inputFromClient.readByte();\n                OutputStream fos = new FileOutputStream(\"/home/danillo/arquivo_carregado.odt\");\n                byte[] buf = new byte[1024];\n                int bytesread;\n                while ((bytesread = inputFromClient.read(buf)) > -1) {\n                    fos.write(buf, 0, bytesread);\n                }\n                inputFromClient.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": ["insertDocumentUsingFile", "insertDocumentToFile", "insertDocumentAsFile", "insertDocumentTourl", "insertDocumentToUrl", "insertDocumentUsingurl", "insertFileToURL", "insertDocumentAsurl", "insertDocumentFromFile", "insertFileFromUrl", "insertFileToUrl", "insertDocumentAsUrl", "insertDocumentFromURL", "insertDocumentUsingUrl", "insertFileToFile", "insertDocumentAsURL", "insertFileFromurl", "insertDocumentFromUrl", "insertDocumentFromurl", "insertFileFromURL", "insertDocumentUsingURL", "insertFileFromFile", "insertFileTourl"], "file": ["image", "db", "self", "stream", "files", "src", "class", "object", "use", "input", "id", "File", "address", "from", "path", "resource", "fp", "xml", "FILE", "dir", "f", "base", "data", "local", "document", "name", "framework", "frame", "string", "place", "uri", "source", "filename"], "target": ["next", "template", "large", "host", "output", "pattern", "object", "proxy", "reference", "parent", "office", "port", "server", "address", "to", "result", "pointer", "location", "path", "resource", "dest", "root", "base", "platform", "Target", "rel", "database", "tag", "document", "name", "site", "external", "remote", "project", "string", "source", "filename"], "is": ["lis", "get", "ai", "in", "ip", "Is", "mis", "service", "us", "bis", "ie", "iso", "isl", "oss", "isa", "src", "i", "cs", "s", "bs", "ois", "was", "its", "ls", "id", "ci", "css", "es", "isi", "address", "ris", "conn", "loc", "IS", "info", "or", "state", "iss", "http", "ios", "ori", "nis", "ir", "out", "iris", "ais", "abs", "x", "fs", "api", "serv", "zip", "series", "are", "it", "ops", "vs", "ss", "as", "js", "si", "ps", "ms", "web"], "os": ["auto", "us", "oos", "iso", "pos", "oss", "ose", "i", "bs", "s", "oid", "otes", "ol", "ors", "ens", "ros", "aos", "es", "conn", "ks", "los", "boot", "or", "obs", "cos", "ios", "ori", "http", "oses", "io", "ob", "ds", "oa", "nos", "OS", "ais", "osi", "ot", "o", "opens", "des", "ans", "oS", "oi", "so", "ops", "vs", "bos", "ss", "as", "ps", "Os", "outs", "oes"], "url": ["image", "ball", "blog", "client", "connect", "sl", "i", "socket", "use", "proxy", "user", "ls", "lc", "server", "conn", "open", "or", "http", "li", "URL", "path", "io", "resource", "ssl", "link", "f", "Url", "o", "lib", "base", "channel", "zip", "control", "b", "log", "ll", "l", "string", "web", "uri", "source", "config", "c"], "connection": ["job", "db", "client", "connect", "union", "creator", "cond", "i", "socket", "relation", "use", "proxy", "context", "lc", "ci", "directory", "handler", "server", "conn", "loc", "open", "or", "bc", "http", "response", "URL", "io", "out", "con", "connected", "channel", "control", "b", "database", "controller", " Connection", "document", "l", "ion", "Connection", "uri", "config", "c"]}}
{"id1": "20855053", "id2": "7166270", "code1": "    public void init(ServletContext context) throws ScratchException {\n        try {\n            log.debug(\"Attempting to load Controllers from file: \" + REGISTRY_FILENAME);\n            ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n            Enumeration<URL> urls = classLoader.getResources(REGISTRY_FILENAME);\n            while (urls.hasMoreElements()) {\n                URL url = urls.nextElement();\n                log.debug(\"Found: \" + url);\n                BufferedReader reader = new BufferedReader(new InputStreamReader(url.openStream()));\n                String className = null;\n                while ((className = reader.readLine()) != null) {\n                    className = className.trim();\n                    if (!\"\".equals(className) && !className.startsWith(\"#\")) {\n                        log.debug(\"Found class: \" + className);\n                        Class<?> clazz = classLoader.loadClass(className);\n                        addClass(clazz);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n            log.error(e);\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n            log.error(e);\n        }\n    }\n", "code2": "    protected String issueCommandToServer(String command, ChangeCapsule changeCapsule) throws IOException {\n        URLConnection urlConn = serverURL.openConnection();\n        urlConn.setDoInput(true);\n        urlConn.setDoOutput(true);\n        urlConn.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        OutputStreamWriter wr = new OutputStreamWriter(urlConn.getOutputStream());\n        String content = ApplyChangesServlet.PARAMETER_COMMAND + \"=\" + command;\n        content += \"&\" + ApplyChangesServlet.PARAMETER_CAPSULE + \"=\" + URLEncoder.encode(changeCapsule.toJSON(), \"UTF-8\");\n        wr.write(content);\n        wr.flush();\n        BufferedReader input = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));\n        StringBuffer response = new StringBuffer();\n        String str;\n        while (null != ((str = input.readLine()))) {\n            response.append(str);\n        }\n        wr.close();\n        input.close();\n        return response.toString();\n    }\n", "label": 1, "substitutes": {"init": ["process", "connect", "loading", "load", "app", "construct", "install", "parse", "handler", "Init", "check", "register", "info", "boot", "resource", "Initialized", "build", "start", "activate", "loader", "log", "test", "it", "strap", "setup", "create", "config", "launch"], "context": ["request", "sc", "component", "obj", "tx", "ctx", "ce", "cc", "app", "parent", "e", "ex", "cf", " contexts", "or", "bc", "http", "exc", "req", "vc", "cl", "pc", "processor", "cms", "Context", "config", "c", "ec"], "classLoader": ["ClassWriter", "logPath", "objectLoad", "resourcePath", "ClassLoading", "objectLoader", " classLoading", "ClassPath", " classWriter", "logloader", "classWriter", " classloader", " classReader", "logWriter", "ClassLoad", "classPath", "resourceLoading", "classReader", "classloader", "logLoader", "ClassLoader", "classLoading", " classPath", "objectReader", "Classloader", "objectloader", "classLoad", "ClassReader", "resourceloader", "resourceLoader", " classLoad"], "urls": ["urlps", "URLches", " urllines", "resourcelines", "httpions", "sls", "URLps", "resourceions", "URLs", " urlps", "webs", "URLions", "webches", "webls", "resourcels", "urlis", "resources", "slls", "slches", "webis", "urlls", "urlions", "URLlines", "https", "resourceps", "httplines", "URLis", "urllines", "httpls", "urlches", "URLls", "slis", " urlls"], "url": ["lr", "r", "job", "image", "ball", "buffer", "sl", "ul", "element", "entry", "rl", "full", "host", "class", "object", "feed", "user", "layer", "ls", "bb", "id", "page", "coll", "server", "address", "loc", "result", "connection", "found", "http", "URL", "resource", "li", "pull", "io", "path", "ssl", "file", "link", "f", "Url", "channel", "base", "err", "gl", "loader", "b", "rel", "org", "ll", "name", "l", "browser", "string", "uri", "source"], "reader": ["r", "iterator", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "feed", "ro", "input", "e", "rx", "handler", "server", "per", "or", "ler", "editor", "resource", "io", "keeper", "rr", "row", "reading", "file", "rar", "iter", "ri", "re", "loader", "er", "oder", "l", "upper", "parser", "read", "layer"], "className": ["stringType", " classDescription", "typeLine", "stringName", "lassType", "ClassPath", " classInfo", "Classname", "classString", "staticType", " classCode", "typeInfo", " classValue", "CLASSType", "classText", "stringInfo", "ClassLine", "clName", "urlName", "objectPath", "objectNumber", "clCode", "clInfo", " classString", "lassEl", " classNumber", "classLine", "urlname", " classPath", "caseDescription", "caseLine", "typeName", "clNumber", "staticname", "classDescription", "clString", "urlText", "lassBase", "classname", "clText", " classname", "classPath", " classType", "lassInfo", "classInfo", " classText", "objectname", "clBase", "staticEl", "CLASSName", "objectName", "classBase", "clname", "classType", "urlValue", "caseValue", "caseName", "typeType", "CLASSEl", "staticName", "objectString", "CLASSname", " classLine", "stringLine", "ClassString", "clValue", "classCode", "lassname", "classValue", "classEl", "lassCode", " classBase", "clPath", "lassName", "ClassValue", "classNumber", "ClassDescription", "ClassName"], "clazz": ["clclass", " cllass", "Clazz", "plade", "cluster", "class", " clclass", "clade", "Class", "glass", "gllass", "classazz", "classuster", "cllass", "pllass", "classlass", "glade", "classclass", "plazz", "glazz", "plass", "Cllass", "Clclass", "Clade", "Cluster", " cluster"]}}
{"id1": "5436973", "id2": "19549577", "code1": "    public String httpToStringStupid(String url) throws IllegalStateException, IOException, HttpException, InterruptedException, URISyntaxException {\n        String pageDump = null;\n        getParams().setParameter(ClientPNames.COOKIE_POLICY, org.apache.http.client.params.CookiePolicy.BROWSER_COMPATIBILITY);\n        getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpGet httpget = new HttpGet(url);\n        httpget.getParams().setParameter(HttpConnectionParams.SO_TIMEOUT, getPreferenceService().getSearchSocketTimeout());\n        HttpResponse response = execute(httpget);\n        HttpEntity entity = response.getEntity();\n        pageDump = IOUtils.toString(entity.getContent(), \"UTF-8\");\n        return pageDump;\n    }\n", "code2": "    protected InputStream callApiPost(String apiUrl, Map<String, List<String>> parameters, int expected) {\n        try {\n            URL url = new URL(apiUrl);\n            HttpURLConnection request = (HttpURLConnection) url.openConnection();\n            if (ApplicationConstants.CONNECT_TIMEOUT > -1) {\n                request.setConnectTimeout(ApplicationConstants.CONNECT_TIMEOUT);\n            }\n            if (ApplicationConstants.READ_TIMEOUT > -1) {\n                request.setReadTimeout(ApplicationConstants.READ_TIMEOUT);\n            }\n            for (String headerName : requestHeaders.keySet()) {\n                request.setRequestProperty(headerName, requestHeaders.get(headerName));\n            }\n            request.setRequestMethod(\"POST\");\n            request.setDoOutput(true);\n            PrintStream out = new PrintStream(new BufferedOutputStream(request.getOutputStream()));\n            out.print(getParametersString(parameters));\n            out.flush();\n            out.close();\n            request.connect();\n            if (request.getResponseCode() != expected) {\n                throw new BingMapsException(convertStreamToString(request.getErrorStream()));\n            } else {\n                return getWrappedInputStream(request.getInputStream(), GZIP_ENCODING.equalsIgnoreCase(request.getContentEncoding()));\n            }\n        } catch (IOException e) {\n            throw new BingMapsException(e);\n        }\n    }\n", "label": 0, "substitutes": {"httpToStringStupid": ["httpToStringCupid", "httpToPageStored", "httpToStringCored", "httpToStringStored", "httpToStringUupid", "httpToPageComp", "httpToStringCrict", "httpToStringstupid", "httpToStringstrict", "httpToStringstomp", "httpToStringStomp", "httpToStringStrict", "httpToPageCored", "httpToStringstored", "httpToPageCrict", "httpToPageCupid", "httpToPageStrict", "httpToStringUomp", "httpToPageStupid", "httpToPageStomp", "httpToStringComp", "httpToStringUrict", "httpToStringUored"], "url": ["request", "image", "domain", "service", "sl", "html", "host", "i", "feed", "version", "ls", "route", "page", "id", "server", "address", "connection", "location", "http", "URL", "resource", "path", "ssl", "file", "str", "f", "Url", "channel", "base", "api", "secret", "https", "name", "l", "string", "href", "uri", "source", "config", "www"], "IOException": ["Downloadception", "IOError", "ConfigurationError", "Configurationception", "IOception", " IOception", " IOError", "ConfigurationException", "DownloadException", "DownloadError"], "HttpException": ["Downloadception", "HTTPException", "httpException", "httpception", "DownloadException", "Httpception", "HTTPception"], "InterruptedException": ["InterSleepExit", " InterruptedExit", "InterIOExit", "InterIOExcept", "InterruptException", "InterIOError", " InterruptException", " InterruptExit", " InterruptExcept", "InterruptError", "InterSleepError", "InterIOException", "InterSleepExcept", "InterruptedError", " InterruptedError", "InterruptedExcept", " InterruptedExcept", "InterruptExit", " InterruptError", "InterSleepException", "InterruptedExit", "InterruptExcept"], "URISyntaxException": ["URISyntaceError", "URISyntaceException", "URISyntixception", "URISyntaxception", "URISlntaxException", "URISyntixError", "URISyntixException", "URISlntaxception", "URISlaxception", "URISyntntaxception", "URISyntntaxError", "URISyntaxError", "URISyntaceEx", "URISlaxError", "URISyntaceception", "URISlntaxError", "URISyntntaxEx", "URISlaxException", "URISyntntaxException", "URISlntaxEx", "URISyntixEx", "URISyntaxEx", "URISlaxEx"], "pageDump": [" pageDumps", "pageDsumper", "pageDash", "pagedumper", "pagedump", " pageBumping", "pageDsumps", " pageBumps", "pageFumps", "pagedumps", "pageDoumper", " pageDumping", "pageDoumping", " pageDumper", "pageLumps", " pageBumm", "pageFumper", "pageLump", "pageDsumm", "pageDumps", "pageLumping", " pageBump", "pageLumper", "pagedash", "pageBumper", " pageBumper", " pageDumm", "pageDoumps", "pageFump", "pageBumps", "pageDumping", "pageBash", " pageDash", "pageDoump", "pageDumper", "pageFash", "pageBumping", "pageBump", "pageBumm", " pageBash", "pageDoumm", "pageDumm", "pageDsump"], "httpget": ["httpGET", "urlrequest", "Httpget", "httpstart", "urlget", " httpgot", "hrget", "phstart", "phpfind", "Httpset", "hrgot", "hrstart", "phgot", "httpGet", "hrGet", "httpset", "phpstart", "httprequest", " httpfind", "HttpGet", " httprequest", "phget", "phpGET", "httstart", "httGET", "urlGet", " httpset", "httfind", "Httprequest", "httpgot", "phpget", "urlset", "httget", "phGet", "httpfind", " httpstart", " httpGET", " httpGet"], "response": ["request", "get", "success", "error", "received", "full", "output", "reply", "object", "relation", "e", "environment", "page", "server", "json", "result", "connection", "http", "message", "resource", "Response", "resp", "ception", "api", "onse", "data", "collection", "status", "application", "method", "document", "res", "body", "respond", "uri"], "entity": ["image", "error", "component", "service", "query", "element", "entry", "output", "object", "instance", "e", "environment", "page", "json", "server", "agent", "result", " Entity", "connection", "content", "resource", "Entity", "message", "xml", " entities", "translation", "Response", "resp", "unit", "security", "model", "data", "ent", "article", "collection", "ity", "document", "body", "event", "person"]}}
{"id1": "14773782", "id2": "22879400", "code1": "    public void testJPEGRaster() throws MalformedURLException, IOException {\n        System.out.println(\"JPEGCodec RasterImage:\");\n        long start = Calendar.getInstance().getTimeInMillis();\n        for (int i = 0; i < images.length; i++) {\n            String url = Constants.getDefaultURIMediaConnectorBasePath() + \"albums/hund/\" + images[i];\n            InputStream istream = (new URL(url)).openStream();\n            JPEGImageDecoder dec = JPEGCodec.createJPEGDecoder(istream);\n            Raster raster = dec.decodeAsRaster();\n            int width = raster.getWidth();\n            int height = raster.getHeight();\n            istream.close();\n            System.out.println(\"w: \" + width + \" - h: \" + height);\n        }\n        long stop = Calendar.getInstance().getTimeInMillis();\n        System.out.println(\"zeit: \" + (stop - start));\n    }\n", "code2": "    public static Properties loadAllProperties(String resourceName, ClassLoader classLoader) throws IOException {\n        Assert.notNull(resourceName, \"Resource name must not be null\");\n        ClassLoader clToUse = classLoader;\n        if (clToUse == null) {\n            clToUse = ClassUtils.getDefaultClassLoader();\n        }\n        Properties properties = new Properties();\n        Enumeration urls = clToUse.getResources(resourceName);\n        while (urls.hasMoreElements()) {\n            URL url = (URL) urls.nextElement();\n            InputStream is = null;\n            try {\n                URLConnection con = url.openConnection();\n                con.setUseCaches(false);\n                is = con.getInputStream();\n                properties.load(is);\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        }\n        return properties;\n    }\n", "label": 0, "substitutes": {"testJPEGRaster": [" testJPEGWatter", " testJPEGraster", " testJPEGRast", " testJPEGRotaster", " testJPEGWaster", " testJPPGrasters", " testJPEGratter", " testJPPGratter", " testJPEGRasters", " testJPEGWast", " testJPPGRasters", " testJPEGRatter", " testJPPGraster", " testJPPGRatter", " testJPEGRotatter", " testJPEGrast", " testJPPGRast", " testJPEGWasters", " testJPEGrasters", " testJPPGrast", " testJPEGRotasters", " testJPEGRotast", " testJPPGRaster"], "IOException": ["OSException", "OSError", "IOError", " IOError", "IOception", "IPception", "IPException", "IPError", " IOception", "OSception"], "start": ["get", "stage", "in", "size", "left", "pos", "art", "order", "pre", "use", "init", "load", "starting", "delay", "id", "from", "info", "diff", "sum", "Start", "time", "date", "step", "started", "end", "ish", "min", "f", "base", "set", "scale", "data", "offset", "style", "speed", "first", "shift", "source", "length"], "i": ["image", "ai", "ip", "m", "j", "p", "ie", "eni", "key", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "zi", "inner", "li", "index", "ii", "io", "iu", "ini", "uni", "bi", "x", "pi", "f", "xi", "ti", "ri", "u", "ni", "b", "v", "mi", "oi", "di", "hi", "l", "si", "yi", "qi", "I", "c"], "url": ["image", "in", "sl", "src", "feed", "ls", "id", "page", "album", "route", "address", "connection", "location", "http", "URL", "path", "resource", "hub", "ref", "fb", "img", "file", "config", "f", "Url", "channel", "base", "data", "download", "org", "name", "l", "href", "string", "web", "ur", "uri", "source", "filename", "www"], "istream": ["instagram", "istREAM", "istsound", "irstore", "istead", "istsrib", "ISTep", "stream", "isteream", "istsstream", "istagram", "istsore", "instead", "istrib", "isep", "istep", "isterib", "istsREAM", "ishREAM", "irstound", "isteep", "iststream", "istestream", "instep", "ISTream", "instream", "step", "stagram", "istore", "ishream", "ISTstream", "irstream", "irstREAM", "ishore", "istsep", "stead", "ISTrib", "istound", "ishound", "istsream", "isagram", "isream", "isead"], "dec": [" Dec", "r", "der", "next", "fr", "de", "dig", "Dec", "sec", "decl", "s", " DEC", "ode", "DEC", "valid", "deg", "code", "dc", "desc", "exp", "img", "out", "ra", "rec", "director", "dir", "rev", "enc", "doc", " decode", "des", "data", "div", "vec", "oder", "cam", "draw", "da", "neg", "func", "c", "inc", "ec"], "raster": ["aroder", "rascal", "erasters", "hap", "Rasters", "roder", "Rascal", "rasters", " rasters", "Ratter", "haster", "eroder", "ratter", " ratter", "arascal", "hatter", "Roder", "Raster", "rap", " rascal", "arasters", " rap", "eratter", " roder", "araster", "eraster", "Rap", "hasters"], "width": ["dim", "image", "fw", "h", "size", "shape", "p", "ize", "n", "left", "full", "flow", "layout", "write", "page", "weight", "z", "work", "value", "img", "wd", "lon", "x", "Width", "en", "f", "min", "area", "wb", "west", "scale", "wa", "density", "w", "gender", "wn", "frame", "age", "d", "style", "duration", "window", "widget", "length", "wm"], "height": ["dim", "pad", "h", "shape", "size", "max", "ady", "Height", "thin", "han", "deep", "th", "padding", "right", "rh", "crop", "work", "img", "build", "angle", "x", "depth", "inches", "k", "y", "v", "density", "w", "rows", "volume", "hd", "d", "stroke", "head", "window", "dy", "length"], "stop": ["pause", "shape", "sort", "save", "block", "summary", "output", "comment", "delay", "pop", "page", "limit", "check", "address", "clip", "zero", "sleep", "hide", "exit", "change", "step", "fill", "spot", "end", "snap", "trip", "Stop", "set", "rest", "b", "keep", "drop", "wait", "remove", "number", "hop", "skip", "ops", "speed", "roll", "sign", "cut"]}}
{"id1": "19944975", "id2": "19687456", "code1": "    public void writeConfiguration(Writer out) throws IOException {\n        if (myResource == null) {\n            out.append(\"# Unable to print configuration resource\\n\");\n        } else {\n            URL url = myResource.getUrl();\n            InputStream in = url.openStream();\n            if (in != null) {\n                try {\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(in);\n                }\n            } else {\n                out.append(\"# Unable to print configuration resource\\n\");\n            }\n        }\n    }\n", "code2": "    public void testReadPerMemberSixSmall() throws IOException {\n        GZIPMembersInputStream gzin = new GZIPMembersInputStream(new ByteArrayInputStream(sixsmall_gz));\n        gzin.setEofEachMember(true);\n        for (int i = 0; i < 3; i++) {\n            int count2 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 1-byte member count\", 1, count2);\n            gzin.nextMember();\n            int count3 = IOUtils.copy(gzin, new NullOutputStream());\n            assertEquals(\"wrong 5-byte member count\", 5, count3);\n            gzin.nextMember();\n        }\n        int countEnd = IOUtils.copy(gzin, new NullOutputStream());\n        assertEquals(\"wrong eof count\", 0, countEnd);\n    }\n", "label": 1, "substitutes": {"writeConfiguration": ["writeSection", "WriteSection", " writeReport", " writeConfig", "writeConfig", "WriteConfig", "WriteReport", "writeReport", "WriteConfiguration", "saveSection", "saveConfiguration", "saveConfig", " writeSection", "saveReport"], "out": ["Out", "plain", "client", "writer", "m", "obj", "sync", "key", "output", "object", "init", "scope", "user", "write", "parent", "ex", "server", "conn", "inas", "connection", "exp", "path", "resource", "report", "io", "ext", "inner", "xml", "pool", "line", "at", "file", "config", "prefix", "lib", "o", "base", "this", "exec", "temp", "err", "w", "name", "res", "password", "reader", "OUT", "string", "again", "list", "IN", "project", "outs", "window", "flush", "dump", "external", "filename", "c"], "url": ["r", "image", "service", "sl", "stream", "object", "feed", "page", "server", "address", "open", "conn", "connection", "http", "location", "URL", "resource", "path", "io", "ob", "xml", "ssl", "file", "f", "Url", "channel", "base", "api", "data", "b", "rel", "org", "ll", "l", "string", "web", "uri", "source", "config"], "in": ["r", "pin", "n", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "cin", "input", "copy", "id", "din", "conn", "inas", "lin", "a", "inner", "resource", "nin", "xml", "ssl", "rin", "ini", "kin", "file", "inside", "min", "f", "serv", "login", "data", "err", "ac", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "cms", "win", "source", "c", "inc"]}}
{"id1": "21326424", "id2": "13063241", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    public static void copyFile(File src, File dest) throws IOException {\n        FileInputStream fis = new FileInputStream(src);\n        FileOutputStream fos = new FileOutputStream(dest);\n        java.nio.channels.FileChannel channelSrc = fis.getChannel();\n        java.nio.channels.FileChannel channelDest = fos.getChannel();\n        channelSrc.transferTo(0, channelSrc.size(), channelDest);\n        fis.close();\n        fos.close();\n    }\n", "label": 0, "substitutes": {"delete": ["request", "get", "process", "de", "del", "save", "release", "reply", "load", "Delete", "complete", "replace", "info", "resource", "edit", "post", "set", "update", "clear", "execute", "drop", "remove", "lete", "stop", "list", "destroy", "create"], "id": ["request", "error", "ip", "in", "query", "i", "key", "oid", "version", "Id", "ID", "address", "info", "code", "ident", "path", "resource", "str", "end", "uid", "url", "sid", "nil", "model", "data", "type", "method", "ids", "name", "string", "variable", "and", "aid", "uri", "pid", "kid"], "response": ["request", "next", "image", "error", "success", "client", "service", "offer", "tree", "i", "output", "reply", "object", "relation", "proxy", "view", "user", "version", "instance", "reference", "route", "page", "handler", "server", "json", "example", "result", "http", "array", "resource", "message", "index", "Response", "description", "function", "value", "resp", "f", "ception", "api", "onse", "model", "data", "v", "collection", "status", "application", "site", "body", "respond", "uri"], "connection": ["request", "image", "position", "error", "timeout", "client", "connect", "writer", "union", "creator", "query", "entry", "relation", "socket", "proxy", "context", "character", "bug", "version", "section", "directory", "handler", "server", "cache", "conn", "or", "http", "inner", "resource", "index", "io", "translation", "manager", "function", "description", "connected", "url", "channel", "session", "builder", "log", "database", "collection", "application", "number", "document", "volume", "driver", "ion", "communication", "network", "Connection", "uri", "event", "config", "c", "condition"]}}
{"id1": "10936821", "id2": "21348951", "code1": "    @Override\n    public void doIt() {\n        try {\n            Shared.createBackup(\"articulo precio codigo_de_barras costo movimiento_inventario detalles_movimientos\");\n            if (mode.equals(\"FTP\")) {\n                FTPClient client = new FTPClient();\n                client.connect(Constants.ftpHost);\n                client.login(Constants.ftpUser, Constants.ftpPass);\n                client.changeDirectory(Constants.ftpDir);\n                File ff = new File(Constants.tmpDir + Constants.tmpFtpFileName);\n                client.download(\"GT99_A09.rar\", ff);\n                client.disconnect(false);\n                Shared.prepareMovements(ff);\n            } else if (mode.equals(\"File\")) {\n                JFileChooser jfc = new JFileChooser();\n                FileFilter f = new ExtensionFileFilter(\"Traslados de Total Pos\", \"rar\");\n                jfc.setFileFilter(f);\n                int selection = jfc.showOpenDialog(Shared.getMyMainWindows());\n                if (selection == JFileChooser.APPROVE_OPTION) {\n                    Shared.prepareMovements(jfc.getSelectedFile());\n                } else {\n                    return;\n                }\n            }\n            Shared.updateMovements();\n            if (Shared.isHadMovements()) {\n                MessageBox msg = new MessageBox(MessageBox.SGN_SUCCESS, \"Fue cargado el nuevo inventario satisfactoriamente!\");\n                msg.show(Shared.getMyMainWindows());\n            } else {\n                MessageBox msg = new MessageBox(MessageBox.SGN_WARNING, \"La tienda no tuvo ningun movimiento asociado.\");\n                msg.show(Shared.getMyMainWindows());\n            }\n        } catch (Exception ex) {\n            MessageBox msg = new MessageBox(MessageBox.SGN_DANGER, \"Ha ocurrido un error.\", ex);\n            msg.show(Shared.getMyMainWindows());\n        }\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 0, "substitutes": {"doIt": ["runIt", "DoSomething", " doit", "doInit", "DoInit", "doSomething", "Doit", "runit", "runInit", "DoIt", " doSomething", "runSomething", " doInit", "doit"], "client": ["i", "cell", "parent", "ci", "conn", "open", "http", "secure", "end", "grid", "api", "conv", "https", "request", "get", "clean", "ip", "connect", "p", "console", "cp", "user", "cache", "clip", "cm", "pool", "file", "close", "simple", "local", "net", "plugin", "and", "web", "bird", "API", "host", "class", "app", "pg", "cli", "port", "per", "ssl", "util", "url", "cl", "remote", "act", "ce", "socket", "help", "default", "server", "connection", "resource", "con", "cloud", "Client", "session", "contact", "force", "co", "call", "project", "config"], "ff": ["abb", "ph", "lf", "bf", "pp", "cp", "fd", "flow", "feed", "fi", "fl", "bb", "cf", "ft", "sf", "fe", "eph", "cd", "af", "fb", "iff", "ef", "fp", "mb", "buff", "ob", "df", "bd", "url", "buf", "eb", "FF", "uff", "uf", "cl", "eff", "fff", "cpp", "nd", "kk", "fx", "upp", "front", "back", "aff", "cb"], "jfc": ["jetxf", "dcf", "Jcf", "jbc", "Jxf", "jetFC", "Jbc", "jetpc", "jpc", " jpc", " jFC", "jfe", "lfc", "lcf", "fFC", "Jpc", " jcf", "fcf", "jcf", "fbc", "dpc", "JFC", "dfe", "jspc", "Jfc", "jsfe", "lFC", "jxf", "dfc", "jsfc", " jxf", "Jfe", " jbc", "jetfc", "lpc", "ffc", "jscf", "jFC"], "f": ["r", "m", "h", "p", "j", "lf", "g", "n", "i", "fd", "s", "orf", "e", "cf", "handler", "xf", "t", "fo", "sf", "fe", "info", "fb", "raf", "fp", "io", "df", "fc", "file", "rf", "fs", "b", "v", "w", "fac", "l", "d", "filter", "F", "self", "c"], "selection": [" selections", "position", "match", "sc", "selected", "sl", "SELECT", "entry", "ling", "delete", "management", "slice", "ses", "expression", "directory", "sb", "option", "loc", "info", "connection", "location", "desc", "index", "ssl", "which", "sel", " selecting", "url", "Se", "choice", "edition", " Selection", "election", "shell", "cl", "language", "lection", "si", "random", " selected", "slot", "qua", "select"], "msg": ["get", "db", "error", "generic", "m", "mess", "ck", "kg", "g", "html", "console", "help", "s", "view", "global", "dict", "bug", "cat", "pkg", "e", "mu", "ng", "md", "sg", "module", "game", "bg", "message", "mit", "cm", "Message", "img", "send", "conf", "file", "exc", "mail", "link", "mg", "doc", "dm", "err", "gl", "lang", "log", "live", "Msg", "bot", "comm", "plugin", "body", "og", "gm", "gs", "list", "ms", "cmd", "gen", "arg"]}}
{"id1": "19235551", "id2": "14502142", "code1": "    protected BufferedImage handleFCLAException() {\n        if (params.uri.startsWith(\"http://image11.fcla.edu/cgi\")) try {\n            params.uri = params.uri.substring(params.uri.indexOf(\"q1=\") + 3);\n            params.uri = params.uri.substring(0, params.uri.indexOf(\"&\"));\n            params.uri = \"http://image11.fcla.edu/m/map/thumb/\" + params.uri.substring(params.uri.length() - 3, params.uri.length() - 2) + \"/\" + params.uri.substring(params.uri.length() - 2, params.uri.length() - 1) + \"/\" + params.uri.substring(params.uri.length() - 1, params.uri.length()) + \"/\" + params.uri + \".jpg\";\n            URL url = new URL(params.uri);\n            URLConnection connection = url.openConnection();\n            return processNewUri(connection);\n        } catch (Exception e) {\n        }\n        return null;\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        if (!dest.exists()) {\n            dest.createNewFile();\n        }\n        FileChannel from = null;\n        FileChannel to = null;\n        try {\n            from = new FileInputStream(source).getChannel();\n            to = new FileOutputStream(dest).getChannel();\n            to.transferFrom(from, 0, from.size());\n        } finally {\n            if (from != null) {\n                from.close();\n            }\n            if (to != null) {\n                to.close();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"handleFCLAException": [" handlePCLException", " handleFCLA1", " handleFCMAception", " handlePCLAError", " handleFCMA1", " handleFCLAception", " handleFCAError", " handleFCLException", " handleFCLAError", " handleFCMAError", " handleFCLError", " handlePCLAException", " handlePCLAception", " handleFCL1", " handleFCLception", " handlePCLA1", " handleFCA1", " handleFCAception", " handleFCMAException", " handlePCLception", " handlePCL1", " handlePCLError", " handleFCAException"], "params": ["image", "video", "words", "styles", "types", "same", "master", "i", "s", "tags", "global", "features", "http", "images", "apps", "api", "base", "vs", "res", "phys", "rules", "request", "details", "parse", "css", "json", "cache", "es", "module", "media", "param", "posts", "resources", "changes", "spec", "database", "errors", "status", "ops", "settings", "plugin", "as", "parts", "external", "vm", "models", "files", "rs", "ls", "core", "ams", "result", "services", "manager", "Parameters", "relations", "series", "names", "ps", "photos", "source", "plugins", "points", "pos", "server", "results", "members", "options", "model", "data", "type", "temp", "pins", "eps", "site", "list", "config"], "uri": ["image", "detail", "query", "i", "theme", "gi", "archive", "address", "http", "description", "link", "course", "prefix", "api", "mode", "volume", "uin", "href", "folder", "doi", "distance", "domain", "iri", "tile", "component", "eni", "oid", "multi", "URI", "title", "future", "route", "origin", "module", "path", "response", "message", "io", "umi", "unit", "database", "mi", "plugin", "duration", "service", "git", "slice", "nexus", "id", "cli", "directory", "core", "picture", "metadata", "direction", "ini", "ri", "wiki", "remote", "verb", "source", "filename", "containing", "transfer", "nuclear", "sequence", "version", "server", "ui", "location", "ori", "resource", "uni", "pi", "binary", "type", "license", "force", "site", "general", "menu", "username"], "url": ["image", "client", "sl", "object", "proxy", "user", "id", "page", "server", "open", "loc", "conn", "source", "target", "http", "location", "URL", "resource", "path", "li", "ssl", "file", "director", "link", "Url", "channel", "base", "system", "control", "l", "browser", "plugin", "string", "web", "window", "orb", "layer", "config"], "connection": ["image", "db", "client", "connect", "service", "relation", "socket", "object", "i", "proxy", "context", "character", "section", "handler", "server", "conn", "open", "result", "http", "response", "resource", "io", "con", "connected", "close", "channel", "data", "control", "database", "application", "document", "body", "string", "ion", "communication", "Connection", "config", "c", "condition"]}}
{"id1": "7351534", "id2": "20920051", "code1": "    public static InputStream getStreamFromSystemIdentifier(String systemId, EntityResolver resolver) throws Exception {\n        InputSource source = null;\n        InputStream stream = null;\n        if (resolver != null) {\n            try {\n                source = resolver.resolveEntity(null, systemId);\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to resolve '\" + systemId + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (source != null) {\n            try {\n                stream = source.getByteStream();\n            } catch (Exception e) {\n                LogService.instance().log(LogService.ERROR, \"DocumentFactory: Unable to get bytestream from '\" + source.getSystemId() + \"'\");\n                LogService.instance().log(LogService.ERROR, e);\n            }\n        }\n        if (stream == null) {\n            URL url = new URL(systemId);\n            stream = url.openStream();\n        }\n        return stream;\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getStreamFromSystemIdentifier": ["getStreamFromsystemidentifier", "getStreamFromsystemIdentifier", "getStreamFromSystemIdentification", "getStreamFromSystemIdifier", "getStreamFromsystemidentification", "getStreamFromSystemidentifiers", "getStreamFromSystemidentification", "getStreamFromsystemidentifer", "getStreamFromsystemIdentification", "getStreamFromSystemIdification", "getStreamFromSystemidentifier", "getStreamFromSystemIdifiers", "getStreamFromsystemIdentifiers", "getStreamFromSystemidentifer", "getStreamFromsystemidentifiers", "getStreamFromSystemIdifer", "getStreamFromsystemIdentifer", "getStreamFromSystemIdentifer", "getStreamFromSystemIdentifiers"], "systemId": ["customid", "servicePath", "sysPath", "machineID", "systemPath", "systemName", "serviceId", "ystemId", "customName", "systemid", " systemID", "ystemName", " systemName", "securityName", "SystemID", "serviceid", " systemPath", "securityID", "securityid", "ystemID", "sysId", "machineid", "ystemid", " systemid", "serverId", "sysid", "SystemId", "securityId", "systemID", "serverID", "customID", "customId", "Systemid", "machineId", "serverid", "SystemName"], "resolver": ["presolve", "Resolver", "reolution", "resolve", "presolving", " resolution", "reolving", " resol", "reolve", "Resolving", "Resolve", "presolution", "reol", "resolving", "reolver", "presolver", " resolving", "resolution", "resol", " resolve", "Resolution", "Resol"], "source": ["position", "client", "component", "service", "size", "creator", "sl", "sync", "element", "large", "src", "i", "class", "ce", "object", "proxy", "scope", "slice", "context", "instance", "parse", "e", "parent", "slave", "id", "handler", "server", "from", "info", "result", "target", "connection", "container", "response", "resource", "path", "resources", "Source", "secure", "storage", "iter", "o", "channel", "null", "unit", "model", "session", "data", "type", "spec", "SOURCE", "text", "document", "entity", "name", "reader", "string", "remote", "seed", "uri", "ource", "ources"], "stream": ["image", "clean", "client", "buffer", "service", "sw", "sl", "flash", "src", "host", "form", "output", "view", "object", "load", "feed", "proxy", "input", "context", "instance", "parent", "handler", "port", "valid", "server", "child", "result", "or", "connection", "wh", "content", "path", "resource", "report", "message", "response", "pool", "row", "dest", "file", "channel", "wrapper", "model", "session", "zip", "data", "temp", "log", "trans", "live", "allow", "document", "Stream", "body", "string", "reader", "speed", "steam", "cont", "event", "read", "length"], "url": ["image", "client", "large", "service", "sl", "src", "host", "object", "feed", "proxy", "id", "page", "server", "address", "loc", "connection", "http", "location", "URL", "resource", "path", "ssl", "file", "link", "Url", "channel", "base", "zip", "data", "control", "gl", "loader", "l", "string", "web", "uri", "ource"]}}
{"id1": "11840277", "id2": "15737836", "code1": "    protected static void clearTables() throws SQLException {\n        Connection conn = null;\n        Statement stmt = null;\n        try {\n            conn = FidoDataSource.getConnection();\n            conn.setAutoCommit(false);\n            stmt = conn.createStatement();\n            ClearData.clearTables(stmt);\n            stmt.executeUpdate(\"delete from Objects\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (1, 'Money value')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (2, 'Date')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (3, 'Unix path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (4, 'Dos path')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (5, 'Time')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (6, 'IP address')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (7, 'Internet hostname')\");\n            stmt.executeUpdate(\"insert into Objects (ObjectId, Description) values (8, 'Number')\");\n            conn.commit();\n        } catch (SQLException e) {\n            if (conn != null) conn.rollback();\n            throw e;\n        } finally {\n            if (stmt != null) stmt.close();\n            if (conn != null) conn.close();\n        }\n    }\n", "code2": "    public void delete(Site site) throws Exception {\n        DBOperation dbo = null;\n        Connection connection = null;\n        PreparedStatement preparedStatement = null;\n        ResultSet resultSet = null;\n        try {\n            String chkSql = \"select id from t_ip_doc where channel_path=?\";\n            dbo = createDBOperation();\n            connection = dbo.getConnection();\n            connection.setAutoCommit(false);\n            String[] selfDefinePath = getSelfDefinePath(site.getPath(), \"1\", connection, preparedStatement, resultSet);\n            selfDefineDelete(selfDefinePath, connection, preparedStatement);\n            preparedStatement = connection.prepareStatement(chkSql);\n            preparedStatement.setString(1, site.getPath());\n            resultSet = preparedStatement.executeQuery();\n            if (resultSet.next()) {\n                throw new Exception(\"\u027e\ufffd\ufffd\u02a7\ufffd\u0723\ufffd\" + site.getName() + \"\ufffd\ufffd\ufffd\u047e\ufffd\ufffd\ufffd\ufffd\u0135\ufffd\ufffd\ufffd\ufffd\u06a3\ufffd\");\n            } else {\n                String sqlStr = \"delete from t_ip_site where site_path=?\";\n                dbo = createDBOperation();\n                connection = dbo.getConnection();\n                preparedStatement = connection.prepareStatement(sqlStr);\n                preparedStatement.setString(1, site.getPath());\n                preparedStatement.executeUpdate();\n            }\n            connection.commit();\n        } catch (SQLException ex) {\n            connection.rollback();\n            throw ex;\n        } finally {\n            close(resultSet, null, preparedStatement, connection, dbo);\n        }\n    }\n", "label": 1, "substitutes": {"clearTables": ["clearContaches", "cacheTableables", "cacheTations", "createTows", "clearTemows", "clearTaces", "createTaches", "cacheTings", "clearBings", "clearTableables", "clearTings", "createTables", "createStaches", "cacheTows", "clearBaces", "clearTows", "clearContables", "createTaces", "clearTableings", "clearTaches", "clearBations", "clearBaches", "clearStaces", "clearStows", "cacheTableations", "clearTations", "clearTemations", "clearBows", "cacheTableows", "createStaces", "createStables", "cacheTables", "clearTableows", "clearBables", "clearTemables", "clearTemings", "clearContaces", "cacheTableings", "createStows", "clearStables", "clearStaches", "clearTableations", "clearContows"], "conn": ["db", "ai", "error", "client", "connect", "ca", "Conn", "h", "p", "obj", "ctx", "n", "oss", "cond", "cp", "rc", "cn", "cc", "pg", "ou", "cat", "ns", "bb", "nt", "ci", "lc", "cf", "cache", "coll", "server", "ann", "loc", "open", "dn", "state", "connection", "nc", "dc", "path", "cm", "ob", "ssl", "con", "conf", "wd", "pub", "config", "oci", "ch", "enc", "sql", "exec", "col", "close", "session", "ac", "log", "org", "jc", "ct", "mt", "co", "di", "Connect", "mc", "sth", "Connection", "cmp", "act", "lock", "cb", "c"], "stmt": ["Stml", " stbm", "ldager", "playtor", "STmn", "Stap", "putml", "Stmc", "ssbm", "stmd", "ftbm", "STwd", " stgr", "sttor", "str", "actmt", " stmi", "est", "estmt", "dm", "ctmd", "stm", "Stnt", "ctmt", "stmm", " stml", "tm", "ftmn", "stswd", "dmt", "stmn", " stma", "putmm", "stql", "stwd", " stm", "stbm", " stmn", "stmi", "tmt", "STbm", "stma", "Stmd", "playmt", "stmc", "stMT", "strmt", "ldmt", "ctgr", "strMT", " stap", " str", "Stgr", "actnt", "STmt", "STlt", "STgr", "istmn", " stager", "putwt", "Stmt", "puttx", "Stmn", "ftmt", "stsprint", " stlt", "putma", "putap", "putmt", "strml", "actmi", "sswt", "dql", " stct", "Stm", "putbm", "stlt", " stwt", "ewd", "strlt", "stager", "Sttor", "ldma", "dr", "Stmm", "istmt", "ctm", "Stwt", " stmc", "stap", "playwt", "estwt", "STmd", "STst", "putm", "eprint", "ssmn", "stwt", "stnt", "Stct", "STprint", "stsst", "STmc", "tct", "istMT", "emt", "estmm", "putmn", "sttx", "tnt", "STMT", "stst", "playtx", "stml", "stprint", "Stlt", "actmn", "Sttx", "ldmn", "StMT", "ctr", "stgr", "Stmi", " stmd", " stql", "ssmt", "puttor", "estm", "putlt", "stct", "ftlt", "putager", " stnt", "putMT", "ctql", "istgr", "stsmt"]}}
{"id1": "4602568", "id2": "19251426", "code1": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "code2": "    private static void recurseFiles(File root, File file, ZipArchiveOutputStream zaos, boolean absolute) throws IOException {\n        if (file.isDirectory()) {\n            File[] files = file.listFiles();\n            for (File file2 : files) {\n                recurseFiles(root, file2, zaos, absolute);\n            }\n        } else if ((!file.getName().endsWith(\".zip\")) && (!file.getName().endsWith(\".ZIP\"))) {\n            String filename = null;\n            if (absolute) {\n                filename = file.getAbsolutePath().substring(root.getAbsolutePath().length());\n            } else {\n                filename = file.getName();\n            }\n            ZipArchiveEntry zae = new ZipArchiveEntry(filename);\n            zae.setSize(file.length());\n            zaos.putArchiveEntry(zae);\n            FileInputStream fis = new FileInputStream(file);\n            IOUtils.copy(fis, zaos);\n            zaos.closeArchiveEntry();\n        }\n    }\n", "label": 1, "substitutes": {"storeImage": ["storeVideo", "processVideo", " transferMedia", "storeIcon", " storeIcon", "storeMedia", "processIcon", " storeVideo", " transferImage", " transferIcon", "processImage", " transferVideo", "processMedia", " storeMedia"], "inStream": [" inVideo", " inSteam", " instream", "INStream", "inputVideo", "inCh", "INPath", "inVideo", "inputstream", "inReader", "INCh", "winSteam", "instream", "winReader", "winVideo", " inPath", "inputSteam", "inPath", "winStream", "inputReader", "inputCh", " inReader", " inCh", "inSteam", "INstream", "inputStream", "inputPath"], "fileName": [" fileNames", "imagePath", "httpPath", "httpName", "Filename", "resourceInfo", "imageName", "FilePart", "FileNames", "FILEname", " fileInfo", "fileNode", "FileName", "resourcename", " fileNode", "imagename", "FILENode", "fileInfo", "FilePath", "filePart", "httpPart", "FileInstance", " filePath", "FileInfo", "fileNames", "resourceName", "FILEPath", "fileInstance", "imageNames", " fileInstance", " filePart", "filePath", "FILEInfo", "FILEInstance", "httpname", "resourceNode", " filename", "FILEName", "filename"], "resize": [" resizes", "Resize", "resizer", " resized", "Resizes", " Resizes", "resized", " Resized", "resizes", "Resizer", " resizer", " Resize", "Resized", " Resizer"], "rightNow": ["RightToday", " rightAccount", "rightToday", " rightToday", "dayCurrent", "thirdCurrent", "rightNOW", "thirdNOW", "straightnow", " rightnow", "dayToday", "straightAccount", " rightThen", " rightCurrent", "RightNow", "rightThen", "rightAccount", "straightNow", "thirdThen", "RightCurrent", "thirdToday", " rightNOW", "RightNOW", "thirdNow", "RightAccount", "dayNow", "rightnow", "dayNOW", "rightCurrent", "straightToday", "thirdnow", "Rightnow"], "dayNamedFolderName": ["dayNamedfolderName", "dayNamedDirectorySize", "dayNamedAreaSize", "dayNamedFileName", "dayNamedFileInfo", "dayNamingFolderInfo", "dayNamedDirectoryPath", "dayNestedFolderName", "dayNamedFolderKey", "dayNamedDirName", "dayNestedDirectorySize", "dayNamedfoldername", "dayNamedDirKey", "dayNamedFolderPath", "dayNamedFilePath", "dayNamedFolderInfo", "dayNamedfolderPath", "dayNamedFolderSize", "dayNamingFolderName", "dayNamedfolderSize", "dayNnamedFolderName", "dayNestedFolderSize", "dayNamedAreaName", "dayNestedFoldername", "dayNnamedFolderPath", "dayNamedFileKey", "dayNamedFileSize", "dayNestedDirectoryname", "dayNamedDirSize", "dayNamedAreaname", "dayNamedDirectoryName", "dayNestedDirectoryPath", "dayNamingFolderSize", "dayNamingFolderKey", "dayNamedDirectoryname", "dayNamedFoldername", "dayNestedDirectoryName", "dayNestedFolderPath", "dayNamedfolderInfo", "dayNnamedFolderSize", "dayNamedDirInfo", "dayNamedAreaPath", "dayNnamedFolderInfo"], "uploadDirRoot": [" uploadDirroot", "uploadDirBase", "uploadFolderPath", "inputDirName", "inputDirRoot", "UploadDirroot", "UploadFolderRoot", "inputDirectoryName", "uploadBaseRoot", "uploaddirHome", "inputDirectoryRoot", "uploadBasePath", "uploadFileName", " uploadFileRoot", "uploadDirPath", "uploadDirHome", "uploadFolderroot", "uploadDbRoot", " uploadDirHome", "UploadDirBase", " uploadFileroot", "uploadFileroot", "uploadDirectoryPath", "uploadDbHome", "uploadBaseBase", "inputDirectoryHome", "uploadDirectoryRoot", "uploadFileRoot", "uploaddirRoot", "uploadFilePath", "inputDirHome", "UploadDirPath", "inputDirectoryPath", "uploaddirroot", "uploadDbPath", "uploadDirName", "uploadDirroot", "UploadFolderPath", "uploadFolderBase", "inputDirPath", "uploadFolderRoot", "uploadDirectoryName", "UploadFolderBase", "UploadFolderroot", "uploadDbName", "uploadDirectoryroot", "uploadDirectoryBase", "uploadBaseroot", " uploadFileHome", "uploadDirectoryHome", "UploadDirRoot", "uploadFileHome"], "file": ["image", "auto", "service", "p", "entry", "full", "files", "flow", "class", "object", "comment", "view", "user", "parent", "e", "page", "directory", "handler", "File", "rule", "home", "per", "child", "fe", "connection", "http", "path", "fp", "line", "out", "function", "work", "ile", "book", "part", "FILE", "dir", "f", "url", "lib", "unit", "base", "model", "zip", "pe", "log", "b", "local", "force", "document", "name", "folder", "up"], "extension": ["Extion", "EXTversion", "EXTdivision", "intion", "Extend", "ExtION", "EXTion", "intend", "EXTension", "xtension", "Extension", "extdivision", "xtion", "interion", "interversion", "xtION", "interension", "extion", "extION", "xtend", "extversion", "exversion", "intension", "intION", "exion", "interdivision", "exdivision", "exension", "extend"], "outFileName": ["inLineName", "inFilePath", "outLineLocation", " outFileAddress", "outfileName", "outFilePart", "outFullKey", "inLineInfo", "outPlaceAddress", "outDirPath", "outFieldAddress", "outfileLength", "outDirInfo", "outFileLocation", "outPlacePath", "outfileSize", "outPlaceName", "outfileLocation", "outFolderName", " outFileLine", "inFileLine", " outPlacePath", "outFolderAddress", "OutFileLength", "outLineSize", "outFileLength", "outPathPath", "outfileInfo", "OutDirLength", "outFileSize", " outFilename", "outFilename", "outFullPart", "OutFileInfo", "outFileLine", "inLinePath", "outLineKey", "outFileType", " outPlaceSize", "outLineInfo", "outFullName", "inFileName", "outLineName", "outPlaceSystem", "inFileInfo", "outPlaceType", " outPlaceAddress", " outPlaceName", "inFilePart", "outPathName", "outPathType", "outFieldName", "OutFilePath", "outFolderInfo", "inLinePart", "OutDirPath", " outFileSystem", "inFileKey", "outPlaceLocation", "outFullPath", "outDirKey", "outLineLine", " outPlaceSystem", " outPlaceLine", "outFileSystem", " outFileType", "outDirPart", "outPlaceLine", "outPlaceSize", "OutDirInfo", " outFilePath", "inLineLine", "outLineType", "outFileKey", "outFieldLine", "outLinePath", " outPlaceType", " outFileLocation", "outLinePart", "outDirLine", "outLinename", "outPathname", "outLineLength", " outPlacename", "outDirLength", "outPlacename", "outFileAddress", "outFileInfo", "outFolderPath", "inLineKey", " outFileSize", "OutFileName", "outfilePath", "outDirName", " outPlaceLocation", "outFolderLine", "outFolderSystem", "OutDirName", "outFieldSystem", "outFilePath"], "outPathAndName": ["outpathAndTime", "outPathAndPath", "outPathandNames", "outPathANDNames", "outPathOrname", "outpathAndPath", "outNameAndAddress", "outPathANDPath", "outPathOrNames", "outPathAndAddress", "outpathAndName", "outPathOrPath", "outpathAndNames", "outpathOrPath", "outPathandName", "outPathAndNames", "outPathANDTime", "outNameOrName", "outPathANDName", "outPathANDname", "outNameOrAddress", "outPathandPath", "outNameOrRam", "outPathAndRam", "outPathOrTime", "outPathANDAddress", "outPathANDRam", "outpathOrNames", "outPathAndname", "outNameAndRam", "outPathOrAddress", "outPathOrName", "outNameAndName", "outPathOrRam", "outNameAndPath", "outpathAndname", "outpathOrName", "outPathAndTime", "outNameOrPath"], "uploadedFile": ["uploadratedF", "uploadpedFiles", "UploadpedFile", "UploadedFolder", "uploadedFolder", "uploadpedFile", "uploadpedFolder", "uploadchedFile", "uploadedImage", "processedPath", "processedF", "UploadedImage", "uploadatedfile", "uploadenedFiles", "uploadatedFile", "uploadenedFile", "processchedfile", "UploadpedImage", "uploadpedfile", "UploadedFile", "uploadedFiles", "UploadedFiles", "uploadendedFile", "uploadratedfile", "uploadedPath", "uploadenedFolder", "uploadenedfile", "uploadedF", "uploadratedFile", "uploadededFiles", "uploadededImage", "processedFile", "uploadizedFull", "uploadizedImage", "uploadpedFull", "uploadedFull", "Uploadedfile", "UploadpedFolder", "uploadpedImage", "uploadendedPath", "uploadratedPath", "UploadedFull", "processedfile", "processchedF", "uploadchedF", "uploadizedFile", "UploadpedFull", "UploadpedFiles", "uploadedfile", "processchedFile", "uploadizedFiles", "uploadchedfile", "Uploadpedfile", "uploadatedFolder", "uploadededFile", "uploadededFull", "uploadendedfile", "uploadatedFiles", "uploadchedPath", "processchedPath", "uploadendedF"], "outStream": [" outBuffer", "tempFile", "Directory", "New", "s", "Copy", "tempBuffer", "format", "URL", "tempSteam", "Bytes", "_", " outFile", "Url", "url", "tempStream", "inSteam", "outSteam", "outFile", "outBuffer", "inFile", "inBuffer", " outSteam", "Type"]}}
{"id1": "15018553", "id2": "15904772", "code1": "    public static String encrypt(String text) throws NoSuchAlgorithmException {\n        MessageDigest md;\n        md = MessageDigest.getInstance(\"MD5\");\n        byte[] md5hash = new byte[32];\n        try {\n            md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        md5hash = md.digest();\n        return convertToHex(md5hash);\n    }\n", "code2": "    public static byte[] getSystemStateHash() {\n        MessageDigest sha1;\n        try {\n            sha1 = MessageDigest.getInstance(\"SHA1\");\n        } catch (Exception e) {\n            throw new Error(\"Error in RandomSeed, no sha1 hash\");\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        sha1.update((byte) Runtime.getRuntime().totalMemory());\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update(stackDump(new Throwable()));\n        try {\n            Properties props = System.getProperties();\n            Enumeration names = props.propertyNames();\n            while (names.hasMoreElements()) {\n                String name = (String) names.nextElement();\n                sha1.update(name.getBytes());\n                sha1.update(props.getProperty(name).getBytes());\n            }\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        try {\n            sha1.update(InetAddress.getLocalHost().toString().getBytes());\n        } catch (Throwable t) {\n            sha1.update(stackDump(t));\n        }\n        sha1.update((byte) System.currentTimeMillis());\n        Runtime.getRuntime().gc();\n        sha1.update((byte) Runtime.getRuntime().freeMemory());\n        sha1.update((byte) System.currentTimeMillis());\n        return sha1.digest();\n    }\n", "label": 1, "substitutes": {"encrypt": ["deccrypt", "encryption", "secrypt", "Encrypt", "Encryption", "enccrypt", "seccrypt", "secryption", "decrypt", "encipher", "Encipher", "decryption", "secipher", "decipher", "Enccrypt"], "text": ["font", "image", "buffer", "template", "bytes", " Text", "key", "output", "class", "object", "transfer", "pattern", "input", "Text", "sequence", "address", "code", "connection", "content", "path", "message", "TEXT", "ext", "word", "str", "binary", "letter", "data", "struct", "secret", "token", "test", "number", "contract", "method", "name", "password", "string", "seed", "source", "config", "length", "hex", "txt"], "md": ["mm", "mac", "mo", "db", "m", "Cmd", "dig", "mk", "pg", "ad", "pkg", "mn", "pd", "metadata", "ma", "od", "dr", "rm", "message", "mb", "cm", "amd", "gb", "df", "wd", "mand", "bd", "sm", "mg", "dm", "data", "pm", "mi", "sha", "em", "mt", "MD", "mp", "me", "mc", "mod", "mag", "hd", "d", "ld", "ms", "meta", "hash", "am", "cmp", "cmd", "dd", " MD", "hm"], "md5hash": ["md7hash", "md5sum", "MD5hash", "md6Hash", " md5block", "md256hash", "md5Hash", " md4hash", "md4Hash", "MD512key", "md25sum", "md2block", "MD5hex", "md256key", "md2hash", "md5key", "md5hex", "md512key", "md512hex", "md25log", "md7sum", "md6hex", "md25Hash", "md512hash", "md5block", "MD512hex", " md4log", "md4sum", "MD512hash", " md5log", "md6log", "md6sum", "md6key", "MD5key", "md6hash", "md256hex", "md5log", "md7block", " md4sum", " md4block", "md4hash", "md2sum", " md5sum", "md4log", " md5Hash", "md2Hash", "md7Hash", " md4Hash", "md25hash", "md4block"]}}
{"id1": "18504192", "id2": "17557289", "code1": "    static void copyFile(File in, File out) throws IOException {\n        FileChannel source = new FileInputStream(in).getChannel();\n        FileChannel destination = new FileOutputStream(out).getChannel();\n        source.transferTo(0, source.size(), destination);\n        source.close();\n        destination.close();\n    }\n", "code2": "    private static void copyFile(File source, File dest) throws IOException {\n        FileChannel srcChannel = new FileInputStream(source).getChannel();\n        FileChannel dstChannel = new FileOutputStream(dest).getChannel();\n        dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        srcChannel.close();\n        dstChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "in": ["image", "m", "buffer", "inn", "src", "i", "old", "input", "copy", "parent", "id", "info", "diff", "or", "inner", "index", "io", "ini", "at", "file", "part", "min", "url", "base", "login", "data", "ac", "b", "ins", "name", "bin", "In", "reader", "IN", "d", "again", "c", "inc"], "out": ["Out", "client", "writer", "p", "obj", "n", "output", "object", "copy", "ex", "cache", "conn", "target", "connection", "io", "dest", "file", "line", "part", "prefix", "o", "base", "exec", "data", "temp", "err", "b", "w", "call", "name", "password", "again", "string", "point", "outs", "external", "OUT", "c", "inc"], "source": ["get", "client", "clone", "component", "service", "size", "writer", "sl", "sync", "ie", "stream", "src", "i", "view", "use", "proxy", "scope", "input", "slice", "slave", "parent", "copy", "sin", "core", "server", "origin", "from", "target", "connection", "se", "ssl", "dest", "Source", "secure", "storage", "iter", "start", "channel", "unit", "null", "SOURCE", "settings", "reader", "project", "ource", "self", "ources"], "destination": ["Destinated", "declinated", "continated", "destinations", "dependinated", "declination", "Destinations", "declification", "contination", "Destinator", "dependination", "testinator", "Destification", " destinated", "dependification", "destinator", "destinated", " destinations", "contining", "destification", "destining", "testinations", " destinator", "testination", "Destination", "testinated", "continator", "Destining", " destining", "dependinator", "declinator"]}}
{"id1": "19584877", "id2": "21348951", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "        protected void processAddByURLSubmit(URL url, String invalidUrlMsg) {\n            if (!this.hasError()) {\n                try {\n                    StringWriter xmlSourceWriter = new StringWriter();\n                    IOUtils.copy(url.openStream(), xmlSourceWriter);\n                    processSubmittedDoap(xmlSourceWriter.toString());\n                } catch (FileNotFoundException e) {\n                    Session.get().error(invalidUrlMsg);\n                    logger.warn(\"Error processing URL: \" + invalidUrlMsg);\n                } catch (IOException e) {\n                    setResponsePage(new ErrorReportPage(new UserReportableException(\"Unable to add doap using RDF supplied\", DoapFormPage.class, e)));\n                    logger.warn(\"Error processing URL: \" + url + \"; \" + e.getMessage(), e);\n                }\n            }\n        }\n", "label": 1, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "22503685", "id2": "17996547", "code1": "    public static Collection<Tuple<String, ArrayList<String>>> readGeoParserResult(String recordContent, boolean getGazeteerIds) {\n        if (TESTING) {\n            HashSet<Tuple<String, ArrayList<String>>> ret = new HashSet<Tuple<String, ArrayList<String>>>();\n            ret.add(new Tuple<String, ArrayList<String>>(\"teste\", new ArrayList<String>()));\n            return ret;\n        }\n        int retries = 0;\n        while (retries < 3) {\n            try {\n                ArrayList<Tuple<String, ArrayList<String>>> ret = new ArrayList<Tuple<String, ArrayList<String>>>();\n                String reqPre = \"<?xml version=\\\"1.0\\\"?>\\r\\n\" + (getGazeteerIds ? \"<GetFeature\" : \"<GetParsing\") + \" xmlns=\\\"http://www.opengis.net/gp\\\" xmlns:wfs=\\\"http://www.opengis.net/wfs\\\"\" + \" xmlns:xsi=\\\"http://www.w3.org/2000/10/XMLSchema-instance\\\"\" + \" xsi:schemaLocation=\\\"http://www.opengis.net/gp ../gp/GetFeatureRequest.xsd http://www.opengis.net/wfs ../wfs/GetFeatureRequest.xsd\\\"\\r\\n\" + \" wfs:outputFormat=\\\"GML2\\\">\" + \"<wfs:Query wfs:TypeName=\\\"PlaceName\\\" />\" + \"<Resource mine=\\\"text/plain\\\">\" + \"<Contents></Contents>\" + \"</Resource>\" + (getGazeteerIds ? \"</GetFeature>\" : \"</GetParsing>\");\n                Document doc = DocumentHelper.parseText(reqPre);\n                doc.getRootElement().element(\"Resource\").element(\"Contents\").setText(recordContent);\n                URL url = new URL(geoParserBaseUrl + \"?request=\" + URLEncoder.encode(doc.asXML(), \"ISO8859-1\"));\n                InputStreamReader reader = new InputStreamReader(url.openStream(), \"UTF-8\");\n                BufferedReader buffered = new BufferedReader(reader);\n                StringBuffer sb = new StringBuffer();\n                String line;\n                while ((line = buffered.readLine()) != null) {\n                    sb.append(line);\n                }\n                Document d = DocumentHelper.parseText(sb.toString());\n                HashSet<String> places = new HashSet<String>();\n                for (Iterator<Element> it = d.getRootElement().element(\"EntryCollection\").elementIterator(\"PlaceName\"); it.hasNext(); ) {\n                    Element plcEl = it.next();\n                    String val = plcEl.elementTextTrim(\"TermName\");\n                    if (!val.equals(\"\") && !places.contains(val)) {\n                        places.add(val);\n                        String entryID = plcEl.attributeValue(\"entryID\");\n                        Tuple<String, ArrayList<String>> plc = new Tuple<String, ArrayList<String>>(val, new ArrayList<String>());\n                        for (Iterator<Element> it2 = d.getRootElement().element(\"EntryCollection\").elementIterator(\"GazetteerEntry\"); it2.hasNext(); ) {\n                            Element idEl = it2.next();\n                            if (idEl.attributeValue(\"entryID\").equals(entryID)) plc.getV2().add(idEl.attributeValue(\"id\"));\n                        }\n                        ret.add(plc);\n                    }\n                }\n                return ret;\n            } catch (Exception e) {\n                log.debug(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage(), e);\n                System.out.println(\"Erro ao pesquisar a lista de termos para o registo \" + recordContent + \"! \" + e.getMessage());\n                retries++;\n            }\n        }\n        System.out.println(\"Too many retries. Giving up.\");\n        return new HashSet<Tuple<String, ArrayList<String>>>();\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 0, "substitutes": {"readGeoParserResult": ["readGeoWalkerResult", "readGeoWalkerResults", "readGeoparserOutput", "readGeoparserReport", "readGeOParserResults", "readGeoParserResults", "readGeOParserReport", "readGeoparserResult", "readGeoparserResults", "readGeOReaderReport", "readGeoParserReport", "readGeoWalkerReport", "readGeOParserOutput", "readGeOReaderOutput", "readGeoReaderReport", "readGeOReaderResults", "readGeoParserOutput", "readGeoWalkerOutput", "readGeoReaderResults", "readGeOReaderResult", "readGeoReaderResult", "readGeoReaderOutput", "readGeOParserResult"], "recordContent": ["resourceContents", "RecordBody", "recordFile", "reportBody", "resourceText", "RecordText", "RecordMessage", "reportMessage", "RecordFile", "recordContents", "RecordContent", " recordContents", "reportContent", "recordBody", "resourceFile", " recordFile", "resourceContent", " recordText", "recordMessage", "recordText", "RecordContents", " recordBody", "reportText", " recordMessage"], "getGazeteerIds": ["getGazeteerConfigs", "getGazeteersIdes", "getGazeteerHostes", "getGazeteersLogxs", "getGazeteersIdings", "getGazeteerNeedes", "getGazeteersIdxs", "getGazeteerLogs", "getGazeteersIders", "getGazeteerIdxs", "getGazeteerIdls", "getGazeteerTextings", "getGazeteerTexts", "getGazeteerLogxs", "getGazeteerLogers", "getGazeteersLogers", "getGazeteerConfigxs", "getGazeteerConfigings", "getGazeteerIdes", "getGazeteerHostings", "getGazeteerLogls", "getGazeteerIders", "getGazeteerTextxs", "getGazeteerHosts", "getGazeteersLogls", "getGazeteerLogings", "getGazeteerNeeds", "getGazeteersIdls", "getGazeteersIds", "getGazeteerTextls", "getGazeteerHosters", "getGazeteerNeedings", "getGazeteerIdings", "getGazeteerNeeders", "getGazeteersLogings", "getGazeteerConfigls", "getGazeteersLoges", "getGazeteersLogs", "getGazeteerLoges"], "ret": ["get", "r", "att", "match", "obj", "bf", "g", "reply", "default", "opt", "dict", "RET", "ut", "ft", "nt", "t", "reg", "replace", "info", "group", "result", "array", "ext", "ref", "vet", "Result", "results", "out", "resp", "Return", "part", "rets", "len", "iter", "feat", "fun", "f", "str", "alt", "data", "rt", "ll", "Ret", "status", "arr", "res", "rg", "list", "det", "gt", "hash", "sys", "mem", "re", "usr", "arg", "repl"], "retries": ["tried", "retried", "altrying", " retrys", "Retries", " retry", "Retry", "Retrying", "trying", "trys", "RETried", "tries", "RETrying", "RETries", "retrying", "altrys", " retrying", "Retrys", "retry", "retrys", "altries", "altried", "RETrys"], "reqPre": ["reqpre", "refPre", "refPost", "requestPre", " requestPost", "requestPlan", "respPlan", " requestpre", "resppre", "refpre", "respPost", "requestPost", "refPlan", "reqPost", " reqpre", "respPre", "requestPref", " requestPref", " reqPost", "reqPlan", "requestpre", "reqPref", " reqPref", " requestPre"], "outputFormat": ["inputSettings", "reportType", "outputSettings", "outputVersion", "inputFormat", "reportVersion", "inputVersion", "OutputVersion", "inputType", "reportSettings", "reportFormat", "OutputType", "OutputFormat", "OutputSettings", "outputType"], "doc": ["db", "m", "h", "Document", "tx", "html", "msg", "pos", "git", "DOC", "bug", "parse", "e", "po", "page", "coll", "md", "home", "info", "result", "dr", "bc", "dc", "http", "desc", "docs", "response", "resource", "xml", "df", "date", "file", "part", "Doc", "str", "f", "api", "feature", "data", "div", "b", "text", "record", "document", "di", "mc", "style", "body", "project", "event", "up"], "url": ["request", "r", "buffer", "sl", "element", "html", "entry", "e", "id", "page", "server", "address", "info", "result", "connection", "http", "location", "response", "ref", "URL", "resource", "path", "ssl", "file", "str", "f", "Url", "api", "base", "channel", "data", "b", "org", "document", "name", "l", "browser", "string", "web", "uri", "orb", "source"], "reader": ["r", "buffer", "writer", "tx", "Reader", "stream", "rc", "feed", "input", "instance", "handler", "info", "or", "http", "resource", "io", "rr", " readers", " parser", "file", "iter", "data", "oder", "er", "parser", "uri", "read"]}}
{"id1": "5744493", "id2": "12055086", "code1": "    protected void onlyFileCopy(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            int maxCount = (1024 * 1024 * 64) - (1024 * 32);\n            long size = inChannel.size();\n            long pos = 0;\n            while (pos < size) {\n                pos += inChannel.transferTo(pos, maxCount, outChannel);\n            }\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"onlyFileCopy": [" doFileCopy", " doFileWrite", " doFolderWrite", " dofileProxy", "newBlockCopy", " doFolderProxy", "newBlockWrite", " doBlockcopy", "newFileCopy", " doFilecopy", "newFilecopy", "newBlockProxy", "newFileWrite", " doFolderCopy", " doBlockWrite", " doFileProxy", " doBlockCopy", " dofileCopy", " dofileWrite", " doBlockProxy", "newFileProxy", " doFoldercopy", " dofilecopy", "newBlockcopy"], "in": ["image", "m", "buffer", "pin", "query", "inn", "isin", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "file", "part", "min", "url", "base", "login", "data", "err", "b", "ins", "name", "bin", "In", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "buffer", "off", "output", "socket", "pre", "default", "user", "write", "copy", "ex", "page", "server", "cache", "conn", "source", "target", "connection", "ext", "resource", "io", "file", "part", "dot", "o", "prefix", "base", "exec", "temp", "b", "v", "name", "again", "string", "point", "outs", "external", "OUT"], "inChannel": [" inClient", "outStream", "inClient", "inputChannel", " inchannel", "inchannel", "INStream", "INChan", "outchannel", "outChan", "binSocket", "binChannel", " inChan", "InStream", "INSocket", "INChannel", "InChan", "outSocket", "inChan", "inputChan", "binChan", "binStream", "INClient", " inStream", "InChannel", "inSocket", " inSocket", "InSocket", "Inchannel", "INchannel", "outClient", "inputStream", "inputSocket", "inStream"], "outChannel": [" outBuffer", "outStream", " outchannel", "intChan", "inchannel", "OutChan", "outchannel", "outChan", "OutChannel", "outButton", "intChannel", "againSocket", " outButton", "againStream", " outChan", " outStream", "againChannel", "outSocket", "inChan", " outSocket", "intchannel", "inContainer", "inSocket", "outContainer", "OutBuffer", "inButton", "outBuffer", "intButton", "inBuffer", "OutStream", "OutContainer", " outContainer", "againChan", "inStream"], "maxCount": [" maxSize", " maxLength", "MaxSize", "MaxSum", "Maxcount", "maxSize", "blockcount", "maxLength", "MaxCount", "axcount", "maxSum", " maxcount", "axLength", "maxcount", "MaxLength", "axSize", "blockSum", "blockCount", "axCount", " maxSum", "blockSize"], "size": ["position", "bytes", "shape", "max", "ize", "p", "n", "capacity", "fee", "transfer", "sized", "limit", "address", "loc", "seek", "sum", "time", "send", "count", "available", "len", "start", "en", "min", "end", "unit", "mode", "scale", "data", "Size", "type", "range", "cap", "offset", "width", "volume", "name", "small", "speed", "empty", "shift", "flush", "SIZE", "length"], "pos": ["position", "os", "p", "obj", "off", "block", "i", "slice", "po", "id", "limit", "port", "address", "val", "open", "loc", "diff", "pointer", "cos", "index", "ref", "pose", "count", "POS", "part", "len", "start", "iter", "min", "o", "unit", "base", "pass", "no", "data", "rel", " position", "offset", "spec", "Pos", "point", "push", "slot", "pid", "neg", "pt", "length"]}}
{"id1": "20414923", "id2": "1141361", "code1": "    protected int deleteBitstreamInfo(int id, Connection conn) {\n        PreparedStatement stmt = null;\n        int numDeleted = 0;\n        try {\n            stmt = conn.prepareStatement(DELETE_BITSTREAM_INFO);\n            stmt.setInt(1, id);\n            numDeleted = stmt.executeUpdate();\n            if (numDeleted > 1) {\n                conn.rollback();\n                throw new IllegalStateException(\"Too many rows deleted! Number of rows deleted: \" + numDeleted + \" only one row should be deleted for bitstream id \" + id);\n            }\n        } catch (SQLException e) {\n            LOG.error(\"Problem deleting bitstream. \" + e.getMessage(), e);\n            throw new RuntimeException(\"Problem deleting bitstream. \" + e.getMessage(), e);\n        } finally {\n            cleanup(stmt);\n        }\n        return numDeleted;\n    }\n", "code2": "    @Override\n    public void makeRead(final String user, final long databaseID, final long time) throws SQLException {\n        final String query = \"insert into fs.read_post (post, user, read_date) values (?, ?, ?)\";\n        ensureConnection();\n        final PreparedStatement statement = m_connection.prepareStatement(query);\n        try {\n            statement.setLong(1, databaseID);\n            statement.setString(2, user);\n            statement.setTimestamp(3, new Timestamp(time));\n            final int count = statement.executeUpdate();\n            if (0 == count) {\n                throw new SQLException(\"Nothing updated.\");\n            }\n            m_connection.commit();\n        } catch (final SQLException e) {\n            m_connection.rollback();\n            throw e;\n        } finally {\n            statement.close();\n        }\n    }\n", "label": 1, "substitutes": {"deleteBitstreamInfo": ["deletebitStreamDetails", "deletebitstreamInfo", "deleteBitStreamInfo", "deleteBitsystemDetails", "deletebitstreamINFO", "deleteBitstoreInfo", "deleteBitStreaminfo", "deleteBitStreamINFO", "deletebitStreamInfo", "deletebitStreamINFO", "deleteBitsystemInfo", "deleteBitstoreINFO", "deletebitStreaminfo", "deletebitstreamDetails", "deleteBitstreamDetails", "deleteBitsysteminfo", "deleteBitstoreDetails", "deleteBitstoreinfo", "deleteBitstreamINFO", "deleteBitsystemINFO", "deleteBitStreamDetails", "deleteBitstreaminfo", "deletebitstreaminfo"], "id": ["error", "ip", "in", "db", "seq", "p", "one", "entry", "key", "i", "object", "vid", "oid", "ad", "parent", "Id", "mid", "ID", "address", "info", "did", "source", "code", "ident", "index", "num", "path", "ref", "ide", "count", "root", "part", "which", "start", "x", "uid", "url", "no", "sid", "data", "type", "offset", "status", "number", "ids", "name", "d", "like", "aid", "rid", "pid", "kid", "create"], "conn": ["db", "client", "connect", "ca", "Conn", "obj", "ctx", "sync", "stat", "cp", "rc", "cn", "cc", "pg", "cr", "mn", "nt", "ci", "cf", "coll", "server", "ann", "dn", "connection", "nc", "dc", "cm", "con", "col", "ch", "enc", "serv", "exec", "sql", "session", "jp", "rt", "ct", "co", "mc", "Connection", "act", "config", "c", "pr"], "stmt": [" stm", "shmd", "Stlt", "stmr", "Stmr", "Stm", "StMT", "stlt", " stdb", " stmn", "strst", " stpr", "strlt", "sttr", "Stmd", "shMT", "strpr", "stmd", "stst", " sttr", " stst", "stMT", "strmt", "strMT", " stmd", "Start", "strmd", "strdb", "strmn", "start", "shart", "Stst", "strm", "strmr", "shmt", "stpr", "stm", " start", "strtr", "Sttr", "Stmt", "stmn", "Stmn", "Stdb", " stlt", "stdb", " stmr", " stMT", "Stpr"], "numDeleted": ["numDelased", "NumDeigrated", "numDelleted", "numExashed", "Numdeigrated", "numdeased", "Numdeleted", "numExletes", "numdelected", " numDeashed", "numDelete", "numExoded", "numDeoded", "numDefoded", "numModashed", " numDelected", "numDuleted", "numUndued", "numNeletes", " numdeashed", "numdeashed", "numModleted", " numDeased", "numDeloded", "numNelete", "numdeleted", " numDelete", "numDefleted", " numdeased", "numDefased", "numDeigrated", "Numdeued", "numMododed", "numDeflected", "NumDeDelete", " numdeleted", "numDeased", "numDuDelete", "numdelete", "numNeleted", "numExleted", "numdeigrated", "numdeued", " numdeoded", "numDeletes", "numUndDelete", "numModletes", "numDeued", "NumdeDelete", "numDelected", "numDellected", "NumDeued", "numdeletes", "numUndleted", " numdelected", " numDeoded", " numDeletes", "numdeDelete", "NumDeleted", "numDeDelete", "numdeoded", " numdeletes", "numDeashed", "numDuigrated"]}}
{"id1": "1508930", "id2": "10547671", "code1": "    public String httpRequestByPOST(String url, int timeout, List<NameValuePair> params) {\n        String response = \"\";\n        try {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpPost httpPost = new HttpPost(url);\n            httpPost.setEntity(new UrlEncodedFormEntity(params, \"UTF-8\"));\n            HttpResponse serverResponse = httpClient.execute(httpPost);\n            StatusLine statusLine = serverResponse.getStatusLine();\n            if (statusLine.getStatusCode() < 400) {\n                InputStream inputStream = serverResponse.getEntity().getContent();\n                InputStreamReader inputReader = new InputStreamReader(inputStream);\n                BufferedReader bufferedReader = new BufferedReader(inputReader);\n                StringBuffer buffer = new StringBuffer();\n                String line;\n                while ((line = bufferedReader.readLine()) != null) {\n                    buffer.append(line);\n                }\n                response = buffer.toString();\n                inputStream.close();\n            } else {\n                this.lastErrorCode = String.valueOf(statusLine.getStatusCode());\n                this.lastErrorMessage = statusLine.getReasonPhrase();\n                return null;\n            }\n        } catch (IOException e) {\n            this.lastErrorCode = \"-1\";\n            this.lastErrorMessage = e.getLocalizedMessage();\n            return null;\n        }\n        return response;\n    }\n", "code2": "    private String retrieveTemplate() throws Exception {\n        if (cachedTemplate == null) {\n            final URL url = new URL(blogEditor.getBlogInfo().getBlogUrl());\n            final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            final StringBuilder result = new StringBuilder();\n            String line;\n            while ((line = in.readLine()) != null) {\n                result.append(line);\n            }\n            in.close();\n            cachedTemplate = result.toString();\n        }\n        return cachedTemplate;\n    }\n", "label": 1, "substitutes": {"httpRequestByPOST": ["httpRequestNoPut", "httpRequestWithPOST", "httpRequestAsGET", "httpRequestWithGET", "httpPostWithpost", "httpRequestNoGET", "httpRequestWithpost", "httpPostWithPut", "httpRequestNoPOST", "httpRequestByPut", "httpRequestAsPut", "httpRequestAsPOST", "httpPostBypost", "httpPostByPut", "httpRequestWithPut", "httpPostWithPOST", "httpRequestAspost", "httpPostByGET", "httpRequestNopost", "httpRequestBypost", "httpRequestByGET", "httpPostByPOST", "httpPostWithGET"], "url": ["request", "domain", "email", "html", "queue", "host", "route", "page", "id", "server", "json", "address", "connection", "http", "location", "URL", "resource", "path", "ssl", "date", "file", "str", "Url", "api", "base", "download", "name", "l", "string", "uri", "www", "username"], "timeout": ["blocking", "size", "max", "socket", "delay", "page", "limit", "cache", "cookie", "connection", "time", "URL", "resource", "sleep", "Timeout", "ssl", "out", "until", "token", "wait", "method", "password", "random", "duration", "length"], "params": ["request", "ip", "Par", "details", "words", "query", "attr", "Param", "server", "json", "properties", "ams", "http", "param", "services", "posts", "terms", "resources", "results", "ras", "apps", "options", "Parameters", "relations", "api", "data", "pins", "names", "settings", "password", "prop", "parts", "ps", "list", "source"], "response": ["request", "next", "image", "service", "tree", "full", "output", "reply", "object", "feed", "page", "server", "json", "example", "answer", "more", "result", "connection", "content", "array", "resource", "report", "message", "location", "reason", "Response", "value", "resp", "str", "api", "model", "data", "collection", "status", "application", "res", "site", "respond", "string", "uri"], "httpClient": ["HttpPost", " httpStore", "serverStore", "httpStore", "httpsClient", "httpServer", "HttpClient", "httpContract", "serverContract", "serverPost", "HttpContract", "HttpServer", "serverServer", "httpsContract", "httpsPost", "serverClient", "HttpStore", "httpsServer", " httpServer"], "httpPost": [" httppost", "HttpPost", "httpsPut", "HttpPut", "httpPOST", " httpPOST", "httpAdd", "HttpThread", "HttpDo", "Httppost", " httpThread", "httpRequest", " httpRequest", "htmlPost", "ttpThread", "httpPut", "HttpPOST", "httppost", "htmlDo", "HttpRequest", "httpThread", "httpDo", "httpsAdd", "ttpRequest", "ttpPost", "ttpDo", "httpsPOST", "httpsDo", "htmlPut", " httpAdd", "HttpAdd", "httpsPost", "httpspost", "htmlPOST", " httpDo"], "serverResponse": ["httpResp", "statusResponse", "httpStatus", " serverSession", "statusSession", "statusResp", "erverResp", "httpServer", "erverServer", "ServerClient", " serverResp", "serverResp", "httpSession", "erverClient", "ServerResponse", "statusStatus", "ServerServer", "serverServer", "serverStatus", "serverSession", "ServerResp", " serverStatus", "statusClient", "serverClient", " serverClient", "erverResponse", "httpResponse"], "statusLine": ["resourceLine", "syncLine", "responseEntity", "StatusPass", "httpLine", "progressLine", "statusNode", "syncEntity", "statusPage", "responseLin", "statusL", "statusFile", "StatusLink", "StatusNode", "StatusFile", "httpCode", "responseCode", "statusCode", "resourceL", "syncLin", "errorError", "errorCode", "StatusLine", "contentNode", "responseError", "errorLink", "progressLin", "StatusPage", "serverFile", "StatusCode", "StatusL", "syncCode", "errorLine", "contentFile", "contentLine", "contentPage", "statusError", "serverLine", "responseLine", "responseLink", "resourcePass", "resourceCode", "progressCode", "progressEntity", "serverPage", "statusLink", "statusEntity", "statusPass", "httpL", "httpPass", "StatusError", "serverNode", "statusLin"], "inputStream": ["tempContent", "InputBuffer", "Inputstream", "loadStream", " inputSteam", "tempStreamer", "pullBuffer", "inContent", "loadSteam", " inputStreamer", " inputstream", "InputSteam", " inputContent", "tempSteam", "pullReader", "inReader", "instream", "InputReader", "inputSteam", "InputStream", "inputBuffer", "inputContent", "inStream", "pullStream", "InputContent", "tempStream", "inSteam", "loadContent", "pullSteam", "inBuffer", "loadStreamer", "inputStreamer", "inputstream"], "inputReader": ["outputBuilder", "outputER", "outputStream", "outputStreamer", "readerReader", "requestBuffer", "regularReader", "readerStream", "regularStream", "outputReader", "requestStream", "readerStreamer", " inputBuilder", "inputER", "requestBuilder", "regularStreamer", "inputBuffer", "requestReader", "inputBuilder", " inputBuffer", "outputBuffer", "readerER", "inputStreamer", "regularER"], "bufferedReader": ["buffedStream", " buffaredRead", "buffererContainer", "buffaredRead", "bufferedRead", "bufferedStream", "BufferedWriter", "bufferingReader", "bufferingWriter", "BufferedReader", "bufferingStream", "buffaredContainer", "buffedWriter", "BufferedContainer", "buffedReader", " bufferedRead", "buffererStream", "buffererReader", "bufferingRead", " buffaredReader", "buffererWriter", "bufferedWriter", "buffaredStream", "BufferingStream", " buffaredStream", "bufferingContainer", "BufferedStream", "buffedRead", "bufferedContainer", "BufferingReader", " bufferedStream", "buffaredWriter", "BufferingContainer", " buffaredWriter", "BufferingWriter", " bufferedWriter", "buffaredReader"], "buffer": ["request", "pause", "image", "writer", "queue", "output", "surface", "feed", "bb", "copy", "slave", "page", "Buffer", "limit", "cache", "server", "sb", "source", "result", "array", "fb", "message", "resource", "audio", "buff", "ignore", "report", "ob", "out", "row", "translation", "uffer", "iter", "buf", "binary", "null", "base", "data", "builder", "type", "loader", "b", "bar", "wave", "document", "background", "reader", "string", "header", "loop", "layer"], "line": ["ip", "sl", "lf", "sync", "entry", "block", "i", "key", "cell", "object", "el", "comment", "character", "feed", "parse", "e", "page", "lc", "lines", "Line", "lin", "code", "content", "message", "row", "file", "str", "liner", "iter", "link", "end", "letter", "pass", "base", "unit", "inline", "data", "char", "LINE", "number", "text", "cl", "name", "l", "body", "string", "header", "le", "source", "column"], "lastErrorCode": [" lastErrorName", "lastHeaderMessage", "currentStatusCause", "currentStatusCode", "lastHttpCode", "lastStatusText", "lastErrorInfo", " lastHeaderName", "lastSuccessText", "currentStatusText", "currentStatusMessage", "lastErrorName", " lastHeaderInfo", " lastErrorInfo", "lastSuccessCause", "lastWarningCode", "lastStatusCause", "currentErrorMessage", "lastHeaderCode", "lastHeaderName", "lastStatusMessage", " lastHeaderMessage", "lastSuccessCode", "lastWarningName", "currentErrorCode", "lastHttpCause", "currentErrorCause", "lastWarningMessage", "lastStatusCode", "lastHttpMessage", "lastHeaderInfo", "currentErrorText", "lastErrorText", " lastHeaderCode", "lastStatusName", "lastWarningInfo", "lastStatusInfo", "lastHttpText", "lastErrorCause", "lastSuccessMessage"], "lastErrorMessage": ["lastHeaderMessage", "lastCodeException", "lastErrorSummary", " lastHeaderSummary", "lastHeaderSummary", " lastErrorDetails", "lastWarningSummary", "lastStatusStatus", " lastWarningStatus", "lastCodeSummary", "lastStatusDetails", "lastWarningDetails", "lastWarningCode", "lastHeaderCode", "lastCodeCode", " lastWarningDescription", "lastStatusMessage", "lastStatusDescription", " lastWarningMessage", "lastWarningException", " lastHeaderMessage", " lastHeaderException", "lastWarningStatus", " lastErrorDescription", "lastErrorException", "lastWarningMessage", "lastErrorDescription", "lastWarningDescription", "lastErrorStatus", " lastErrorException", " lastErrorStatus", " lastErrorSummary", " lastHeaderCode", "lastErrorDetails", "lastHeaderException", "lastCodeMessage", " lastWarningDetails"]}}
{"id1": "14390569", "id2": "20426057", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public static KeyStore createKeyStore(final URL url, final String password) throws KeyStoreException, NoSuchAlgorithmException, CertificateException, IOException {\n        if (url == null) throw new IllegalArgumentException(\"Keystore url may not be null\");\n        LOG.debug(\"Initializing key store\");\n        KeyStore keystore = null;\n        if (url.getFile().endsWith(\".p12\")) keystore = KeyStore.getInstance(\"pkcs12\"); else keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n        keystore.load(url.openStream(), password != null ? password.toCharArray() : null);\n        return keystore;\n    }\n", "label": 0, "substitutes": {"title": ["ppa", "image", "details", "size", "itles", "term", "alpha", "html", "msg", "label", "summary", "notes", "layout", "TIT", "theme", "version", "id", "section", "page", "phrase", "format", "filename", "content", "desc", "message", "resource", "description", "part", "url", "prefix", "Title", "data", "type", "license", "subject", "chapter", "text", "name", "body", "string", "header", "heading", " Title", "itle"], "imageURL": ["imgPath", "pictureURI", "imageURI", "imagePath", "imageurl", "pictureURL", "imgURL", "ImageURL", "pictureUrl", "mediaUrl", " imageURI", " imageurl", "pictureurl", "fileUrl", "ImagePath", "fileURI", "mediaURI", "imgURI", "imageUrl", "mediaURL", "filePath", "ImageUrl", "fileurl", " imageUrl", "ImageURI", "fileURL", "imgUrl"], "jd": [" jf", "zb", " jD", "zdo", "ajb", "Jdos", "jds", "ajdh", "ssdo", "qdo", "jackd", "jsd", "jsdo", "Je", "qd", " jdl", "jdl", "jdi", "jjdo", "ajdos", "argdl", "Jdom", "argdo", " je", " jdom", "jdo", "Jl", "ssD", "ajD", "argd", "qb", "jdos", "jjb", "zf", "ajdi", " jdi", "jf", "qdom", "jdd", "adjdos", "jjdh", "jobD", "ajf", "jackb", "Jd", "Jf", "adjb", "jobb", "Jds", "adjdo", "ze", "Jb", "jobd", "Jdo", "argf", "qdh", "ssdi", " jdo", "ajdo", "jsb", " jds", "je", "ajdl", "adjd", "jobdo", "jdh", "zl", "ssd", "jdom", "jackf", "jsdh", "zds", "zdd", "jackdd", "JD", "jD", "ajd", " jdh", "jjd", " jdd", "zd"], "jl": ["j", "lf", "label", "lb", "el", "jon", "kel", "bn", "uj", "syn", "igl", "Label", "il", "cli", "hl", "iji", "adj", "elly", "lv", "chal", "jj", "ja", "li", "bl", "lp", "oji", "dj", "fp", "NJ", "bj", "kn", "eb", "wl", "iol", "dl", "ji", "ll", "jc", "kl", "l", "vd", "elt", "nl", "ld", "kj", "lu", "JM", "zl"], "icon": ["ico", "image", "artist", "size", "ic", "note", "n", "label", "cn", "bn", "action", "on", "css", " image", " Icon", "picture", "core", "ann", "gn", "info", "ui", "alias", "eye", "content", "resource", "io", "img", "Icon", "fc", "uni", "icons", "png", "url", "pic", "token", "text", "plugin", "ion", "cha", "header", "iao", "uri"], "chooser": [" choose", " choressor", "joose", "Choer", "Chooser", "Chooder", "boose", "closer", "closen", "cler", "dialose", " choosen", "choressor", "dialosen", "Choosen", "choer", "close", " chooses", "dialoser", "chooses", "booser", "Chooses", "jooder", "Choose", "jooses", "boressor", "dialer", "clressor", "choose", " chooder", "boosen", "chooder", "choosen", "jooser"], "jp": [" cm", " pane", " je", " dj", "j", " np", " j", " pa", " mp", " tmp", " JM", " cp", " plugin", "Panel", " js", "ja", " pic", " dock", "bj", " ax", " robot", " sp", " bridge", "JP", "ji", " bar", " gp", " obj", " app"], "jb": ["qsb", " jf", "qb", " jcb", " jbb", "ajsb", " jsb", "ajb", "jf", "djd", "jsbb", "djcb", "ajf", "jsd", "jbb", "djbb", "jsb", "jcb", "qf", "jscb", "ajcb", "djb", "qcb"], "e": ["in", "de", " fe", "ctx", "ie", "ce", "ee", "t", "a", "E", " E", " Event", "exc", "x", "ev", "f", "ception", " ate", "pe", "v", "je", "et", "ae", "te", "event", "c", "ec"], "returnVal": [" returnval", "replyValue", "returnval", "returnVAL", " returnNum", " returnValue", "replyVal", "resultval", "ReturnValue", "resultValue", "returnValue", "Returnval", "resultNum", "returnNum", "ReturnVAL", "replyVAL", "ReturnNum", " returnVAL", "resultVal", "replyval", "ReturnVal"], "file": ["image", "comment", "parent", "info", "http", "build", "die", "letter", "base", "name", "body", "folder", "get", "db", "full", "load", "user", "parse", "future", "page", "File", "rule", "home", "module", "path", "message", "io", "single", "pool", "ban", "FILE", "part", "unit", "b", "local", "live", "l", "lock", "auto", "files", "object", "use", "directory", "core", "picture", "show", "work", "line", "out", "function", "ile", "dir", "url", "lib", "pe", "log", "play", "filename", "buffer", "queue", "il", "po", "handler", "fp", "book", "f", "binary", "model", "zip", "data", "type", "force", "document"], "fileName": ["imagePath", "singleInfo", "Filename", "resourceInfo", "imageName", "resourcePath", "binaryUrl", "FileType", "binaryPath", "fileType", " fileType", "singlePath", " fileInfo", "singleName", "FileName", "binaryName", "resourcename", "imagename", "imageInfo", "fileUrl", "fileInfo", "FilePath", "FileInfo", " filePath", " fileUrl", "resourceName", "imageUrl", "filePath", "singleType", " filename", "singlename", "filename"], "ext": ["ace", "p", "xt", "obj", "sec", "xp", "class", "eng", "version", "ension", "ex", "t", "phrase", "Ext", "ax", "format", "alg", "fb", "exp", "path", "orig", "desc", "word", "qt", "EXT", "feat", "f", " Ext", "ch", "enc", "lib", "oct", "abc", "type", "pe", "v", "ct", "name", " extension", "extra", "txt"], "i": ["ai", "ip", "m", "j", "p", "bis", "is", "multi", "phi", "id", "cli", "gi", "ci", "ui", "info", "mini", "a", "li", "ii", "io", "iu", "z", "ini", "bi", "pi", "o", "xi", "ment", "api", "ti", "ri", "u", "ni", "b", "y", "v", "mi", "di", "ion", "si", "uri", "I", "c"], "doIt": ["diIT", " doIts", "odoWhich", "hoYou", "odoIt", "DOIT", "doNot", "poYou", "skipit", "skipIts", "skipIT", "doIT", "hoit", "addIT", " doIT", " doNot", "hoIT", "diit", " doit", "doIts", "addIt", "poIT", "doYou", "DOIt", "diIts", "odoit", "DOit", "poIt", "odoIT", "DOWhich", " doYou", "hoIt", "doWhich", "poit", "skipIt", "diIt", " doWhich", "addNot", "addit", "odoNot", "doit"], "src": ["r", "sc", "us", "sl", "attr", "ctx", "sync", "upload", "stream", "ff", "rc", "socket", "tmp", "impl", "fi", "input", "rs", "slice", "bb", "rx", "sn", "RC", "sb", "loc", "Dest", "target", "bc", "rb", "cos", "path", "desc", "inst", "pull", "cur", "gb", "img", "ssl", "cdn", "sup", "fc", "dist", "secure", "uc", "storage", "sel", "url", "buf", "st", "conv", "rest", "sq", "b", "rel", "split", "sub", "sth", "gz", "cmp", "ource", "source", "cb", "ources"], "dest": [" Dest", "output", "comb", "uv", "std", "tmp", "ctr", "route", "home", "Dest", "loc", "target", "dc", "desc", "inst", "dep", "exit", "later", "img", "proc", "wd", "sup", "cdn", "dist", "gd", "uc", "dir", "die", "st", "wb", "rest", "trans", "done", "di", "prop", "destroy", "usr", "cont", "dev", "gen", "dat", "source", "config"]}}
{"id1": "62362", "id2": "20310134", "code1": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public static void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"convert": ["oconvert", "Convert", "unvert", "unverted", "subversion", "oconverted", "CONversion", "converting", "subverted", "subverting", "unception", "unversion", " deconverted", " deconvert", "conversion", "subvert", "CONverting", "CONception", "Converted", "CONverted", " deconverting", "conception", " deconversion", "oconverting", "CONvert", "oconversion", "Conception", "Conversion", "Converting", "converted"], "src": ["video", "feat", "stage", "sc", "component", "obj", "upload", "ctx", "attr", "stream", "rl", "rc", "tmp", "load", "s", "impl", "input", "slice", "sit", "sn", "sin", "RC", "sb", "cb", "scene", "Dest", "loc", "code", "rb", "ource", "inst", "path", "ref", "fp", "resource", "ssl", "img", "proc", "gb", "fn", "file", "Source", "supp", "config", "storage", "secure", "sel", "dist", "url", "buf", "st", "prot", "req", "download", "spec", "cpp", "SourceFile", "name", "reader", "string", "href", "sth", "sys", "uri", "gz", "cmp", "back", "source", "filename", "username"], "dest": ["obj", "class", "tmp", "std", "home", "Dest", "target", "dc", "path", "orig", "disk", "img", "fn", "dist", "dir", "lib", "null", "temp", "test", "di", "bin", " destination", " dst", "cont", "dat", "source", "txt"], "in": ["r", "pin", "n", "inn", "stream", "isin", "i", "is", "input", "ex", "din", "t", "val", "inas", "inf", "a", "io", "ini", "file", "f", "pass", "doc", "login", "data", "err", "ins", "bin", "In", "d", "IN", "reader", "as", "ps", "win", "source", "up", "inc"], "p": ["r", "bp", "m", "h", "j", "P", "pp", "g", "pa", "cp", "i", "pre", "s", "pg", "e", "po", "pd", "t", "py", "per", "lp", "fp", "op", "cop", "pb", "part", "pi", "f", "tp", "o", "pe", "jp", "b", "v", "pm", "wp", "pc", "l", "d", "ps", "parser", "np", "c", "pr", "sp"], "ds": ["os", "ups", "words", "sync", "ipes", "styles", "cs", "s", "bs", "xs", "dds", "DS", "gd", "icks", "dm", "dl", "hs", "ins", "vs", "da", "dat", " DS", "tests", "dates", "dp", "db", "dos", "nas", "cons", "ths", "lines", "docs", "posts", "tools", "dist", "ays", "ans", " sd", "utils", "ss", "d", "parts", "js", "ded", "ts", "qs", "models", "rs", "ls", "pd", "ges", "ks", "obs", "services", "lp", "groups", "ys", " props", "ps", "ld", "dd", "uds", "Ds", "plugins", "vals", "sts", "ils", "points", "scripts", "ns", "els", "dc", "ads", "ants", "dt", "df", " ps", "des", "data", "eps", "di", "amps", "gs", "sys"], "format": ["template", "host", "form", "pattern", "class", "layout", "sche", "fd", "version", "handler", "t", "Format", "filename", "path", "fp", "magic", "function", "ant", "at", "file", "fn", "part", "feat", "f", "url", "letter", "prefix", "unit", "api", "model", "scale", "data", "type", "struct", "spec", "tag", "atter", "record", "language", "nat", "name", "table", "frame", "style", "plugin", "string", "parser", "filter", "act", "source", "config"], "hasPixelData": ["hasByteSize", "showsPixeldata", "hasPixeldata", "showsPixelStyle", "hasBytedata", "hasByteStyle", "hasPictureData", "hasByteData", "hasPixelStyle", "haspixelData", "showsByteDATA", "hasPictureSize", " hasPixelSize", " hasPixeldata", "hasByteDATA", "showsByteStyle", "showsBytedata", "hasPixelDATA", "showsByteData", "haspixeldata", "haspixelSize", "hasPicturedata", "showsPixelDATA", "showsPixelData", "hasPixelSize"], "inflate": ["invenode", "infolate", "inadequate", "infface", "inadequATE", "insvenode", "insflate", "Inflace", "inflation", "infloation", "inflATE", "inffation", "infloate", "inflace", "insvenating", "infloated", "infloace", "invenATE", "inffate", "inflode", "Inflate", "inFlate", "InFlate", "inFlated", "insflATE", "invenating", "Inflated", "infolating", "invenate", "inFlace", "inflated", "insflating", "infolode", "insvenate", "inadequode", "inffated", "InFlated", "insvenATE", "Inflation", "insflode", "InFlace", "inflating", "inFlation", "inadequating", "infolATE", "InFlation"], "pxlen": ["axln", "fxln", "axlon", "mxsize", "pgl", "xpcount", "pplen", "pngcount", "camlen", "pxpos", "pxlon", "xplength", "pclin", "fxl", "pgden", "axlin", "pxcount", "pngsize", "pxLen", "fxpos", "mxlength", "pgLen", "campos", "fxdata", "pxl", "fxden", "ppl", "mxpos", "pnglength", "mxln", "axlen", "pxdata", "txlin", "xpsize", "txlon", "ppden", "pglen", "pnglen", "mxlen", "pxln", "fxLen", "mxcount", "xplen", "mxdata", "txln", "camln", "pcln", "pxden", "camdata", "fxlen", "pclon", "pclen", "txlen", "pxlength", "pxlin", "pxsize", "ppLen"], "out": ["Out", "pad", "error", "obj", "query", "up", "output", "user", "copy", "parent", "cli", "page", "server", "cache", "conn", "group", "state", "io", "line", "work", "step", "post", "store", "lib", "session", "re", "err", "log", "v", "inter", "co", "again", "list", "point", "sys", "outs", "lock", "gen", "dump", "OUT"]}}
{"id1": "1769771", "id2": "5061606", "code1": "    private void copyFile(File in, File out) throws IOException {\n        FileChannel inChannel = new FileInputStream(in).getChannel();\n        FileChannel outChannel = new FileOutputStream(out).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } catch (IOException e) {\n            throw e;\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyChannel", "copyFiles", "copyfile", "transferChannel", "transferFile", " copyChannel", "transferFiles", "CopyChannel", "CopyFile", "Copyfile"], "in": ["image", "m", "pin", "query", "inn", "i", "input", "id", "ex", "diff", "lin", "inner", "index", "io", "work", "file", "min", "f", "url", "base", "login", "data", "ins", "name", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "config", "c", "inc"], "out": ["Out", "plain", "image", "writer", "p", "off", "n", "up", "output", "default", "user", "write", "ex", "server", "cache", "conn", "target", "ext", "resource", "io", "file", "x", "dot", "o", "prefix", "base", "exec", "b", "v", "w", "call", "name", "again", "string", "point", "outs", "extra", "external", "OUT", "c"], "inChannel": [" inClient", "inClient", "insClient", "insStream", "outStream", "binClient", " inchannel", "inchannel", "inputChannel", "INStream", "INChan", "outchannel", "outChan", "binChannel", " inChan", "InClient", "InStream", "winchannel", "inputchannel", "binchannel", "INChannel", "InChan", "inputChan", "inChan", "binChan", " inStream", "InChannel", "winChannel", "winStream", "Inchannel", "insChan", "INchannel", "winChan", "insChannel", "outClient", "inputStream", "binStream", "inStream"], "outChannel": ["inputController", "outStream", " outchannel", "inputChannel", " outCh", "inchannel", "nChannel", "OutChan", "outchannel", "outChan", "outputController", "outCh", "inCh", "OutChannel", "outController", "outputChan", "outputStream", "OutConnection", "outputchannel", "nChan", "inputchannel", "outputCh", " outChan", "outputChannel", "nStream", " outConnection", " outStream", "inputChan", "inChan", "outConnection", " outManager", "inConnection", "nManager", "outManager", "inManager", "Outchannel", "inController", "inStream"]}}
{"id1": "18891988", "id2": "13333160", "code1": "    public static String getFile(String serviceName, String wsdlLocation, String endpoint) throws AxisFault {\n        mLog.debug(\"Downloading WSDL file from: \" + wsdlLocation);\n        mLog.debug(\"Received endpoint: \" + endpoint);\n        String fileLocation = null;\n        try {\n            String tempDir = System.getProperty(\"java.io.tmpdir\");\n            URL url = new URL(wsdlLocation);\n            String WSDLFile = tempDir + File.separator + serviceName + \".wsdl\";\n            String tmpWSDLFile = WSDLFile + \".tmp\";\n            File inputFile = new File(WSDLFile);\n            File tmpFile = new File(tmpWSDLFile);\n            if (!inputFile.exists() || inputFile.length() == 0) {\n                mLog.debug(\"Downloading the WSDL\");\n                inputFile.createNewFile();\n                InputStream in = url.openStream();\n                FileOutputStream out = new FileOutputStream(inputFile);\n                URLConnection con = url.openConnection();\n                int fileLength = con.getContentLength();\n                ReadableByteChannel channelIn = Channels.newChannel(in);\n                FileChannel channelOut = out.getChannel();\n                channelOut.transferFrom(channelIn, 0, fileLength);\n                channelIn.close();\n                channelOut.close();\n                out.flush();\n                out.close();\n                in.close();\n                Document tmpDocument = XMLUtils.newDocument(new FileInputStream(inputFile));\n                NodeList nl1 = tmpDocument.getElementsByTagName(\"wsdlsoap:address\");\n                for (int i = 0; i < nl1.getLength(); i++) {\n                    Node node1 = nl1.item(i);\n                    if (node1.getNodeName().equals(\"wsdlsoap:address\")) {\n                        ((Element) node1).setAttribute(\"location\", endpoint);\n                    }\n                }\n                FileOutputStream tmpOut = new FileOutputStream(tmpFile);\n                XMLUtils.DocumentToStream(tmpDocument, tmpOut);\n                tmpOut.flush();\n                tmpOut.close();\n                boolean retVal = inputFile.delete();\n                if (retVal) {\n                    retVal = tmpFile.renameTo(new File(WSDLFile));\n                }\n                mLog.debug(\"Return Value: \" + retVal);\n            } else {\n                mLog.debug(\"The WSDL is already at the ServiceProvider\");\n            }\n            fileLocation = WSDLFile;\n        } catch (MalformedURLException mx) {\n            mLog.error(\"MalformedURLException: \" + mx.getMessage() + \", cause: \" + mx.getCause().getMessage());\n            throw new AxisFault(mx.getMessage(), mx.getCause());\n        } catch (IOException ix) {\n            mLog.error(\"IOException: \" + ix.getMessage() + \", cause: \" + ix.getCause().getMessage());\n            throw new AxisFault(ix.getMessage(), ix.getCause());\n        } catch (ParserConfigurationException px) {\n            mLog.error(\"ParserConfigurationException: \" + px.getMessage() + \", cause: \" + px.getCause().getMessage());\n            throw new AxisFault(px.getMessage(), px.getCause());\n        } catch (SAXException sx) {\n            mLog.error(\"SAXException: \" + sx.getMessage() + \", cause: \" + sx.getCause().getMessage());\n            throw new AxisFault(sx.getMessage(), sx.getCause());\n        }\n        return fileLocation;\n    }\n", "code2": "    private void run(Reader xmlIn, OutputStream out) throws IOException, SAXException {\n        Document dom = null;\n        try {\n            DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();\n            f.setNamespaceAware(false);\n            f.setCoalescing(true);\n            f.setIgnoringComments(true);\n            f.setValidating(false);\n            DocumentBuilder b = f.newDocumentBuilder();\n            dom = b.parse(new InputSource(xmlIn));\n        } catch (ParserConfigurationException err) {\n            throw new IOException(err);\n        }\n        Element root = dom.getDocumentElement();\n        if (root == null) throw new SAXException(\"Not root in document\");\n        Attr att = root.getAttributeNode(\"label\");\n        if (att == null) root.setAttribute(\"label\", \"Wikipedia\");\n        Menu menu = parseMenu(root);\n        menu.id = \"menuWikipedia\";\n        ZipOutputStream zout = new ZipOutputStream(out);\n        String content = ResourceUtils.getContent(XUL4Wikipedia.class, \"chrome.manifest\");\n        addEntry(zout, \"chrome.manifest\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"install.rdf\");\n        addEntry(zout, \"install.rdf\", content);\n        content = ResourceUtils.getContent(XUL4Wikipedia.class, \"library.js\");\n        addDir(zout, \"chrome/\");\n        addDir(zout, \"chrome/content/\");\n        addDir(zout, \"chrome/skin/\");\n        String signal = \"/*INSERT_CMD_HERE*/\";\n        int n = content.indexOf(signal);\n        if (n == -1) throw new RuntimeException(\"where is \" + signal + \" ??\");\n        ZipEntry entry = new ZipEntry(\"chrome/content/library.js\");\n        zout.putNextEntry(entry);\n        PrintWriter pout = new PrintWriter(zout);\n        pout.write(content.substring(0, n));\n        menu.toJS(pout);\n        pout.write(content.substring(n + signal.length()));\n        pout.flush();\n        zout.closeEntry();\n        entry = new ZipEntry(\"chrome/content/menu.xul\");\n        zout.putNextEntry(entry);\n        pout = new PrintWriter(zout);\n        pout.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n        pout.println(\"<overlay id=\\\"xul4wikipedia\\\" xmlns=\\\"\" + XUL.NS + \"\\\">\");\n        pout.println(\"<script src=\\\"library.js\\\"/>\");\n        pout.println(\"<popup id=\\\"contentAreaContextMenu\\\">\");\n        pout.println(\"<menuseparator/>\");\n        menu.toXUL(pout);\n        pout.println(\"</popup>\");\n        pout.println(\"</overlay>\");\n        pout.flush();\n        zout.closeEntry();\n        InputStream png = XUL4Wikipedia.class.getResourceAsStream(\"32px-Wikipedia-logo.png\");\n        if (png == null) throw new IOException(\"Cannot get icon\");\n        entry = new ZipEntry(\"chrome/skin/wikipedia.png\");\n        zout.putNextEntry(entry);\n        IOUtils.copyTo(png, zout);\n        zout.closeEntry();\n        zout.finish();\n        zout.flush();\n    }\n", "label": 1, "substitutes": {"getFile": ["getfile", "loadFile", "loadString", "Getfile", "GetFilename", "GetString", "downloadFilename", "loadFilename", "downloadString", "getString", "getFilename", "loadfile", "downloadFile", "GetFile", "downloadfile"], "serviceName": ["servicePath", "projectName", "packagename", "serviceType", "projectPath", "packageName", "ServiceName", " servicePath", " servicename", "packagePath", " serviceType", "packageUrl", "serviceUrl", "Servicename", "ServicePath", "servicename", "ServiceUrl", " serviceUrl", "projectUrl", "ServiceType", "projectType"], "wsdlLocation": ["wsDLFile", "wllAddress", "wslpFolder", "wsllUrl", "wslLocation", "wsllLocation", "wsslLocation", "wsdlFolder", "wllFolder", "wslFile", "awslFile", "wsllFolder", "wdlDirectory", "wsDLUrl", "wddlFolder", "wsdlDirectory", "wslpFile", "wslpDirectory", "awslLocation", "wsslFolder", "wssdAddress", "wdlAddress", "awslDirectory", "wsdlUrl", "wsllFile", "wddlFile", "wslUrl", "wsDLLocation", "wssdFolder", "wdlFile", "awsdlLocation", "awslUrl", "wddlDirectory", "wllLocation", "wslFolder", "wsdlFile", "wsslFile", "wsDLDirectory", "wsllDirectory", "awsdlDirectory", "wsllAddress", "wsdlAddress", "wddlLocation", "wssdFile", "wslpLocation", "wdlFolder", "wdlLocation", "wssdLocation", "wllFile", "awsdlUrl", "wsslAddress", "awsdlFile", "wslDirectory"], "endpoint": ["endsocol", " endpointer", "ENDpoint", "endocol", "endination", "EndPoint", "enPoint", "endsword", "startaddress", " endPoint", "startpoint", "Endpoint", "endpointer", "endpo", " endpo", " endaddress", "enaddress", "enpointer", "Endocol", " endocol", "Endpo", "Endpoints", " endword", "enpoints", "enination", "ENDpoints", "Endination", "Endword", "ENDination", "endspo", "ENDPoint", "endPoint", "endaddress", "endword", "endpoints", "startPoint", "enpoint", "startpointer", "endspoint"], "fileLocation": ["fileUrl", "FILEDirectory", " fileDirectory", "fileDirectory", "fileURI", "FILEUrl", "FileLocation", "FileUrl", " fileURI", "FileDirectory", "FILEURI", " fileUrl", "FileURI", "FILELocation"], "tempDir": [" temporaryDir", "tmpVer", " tempVer", "TempDir", " temporaryPath", "tempdir", "tmpDir", "tempVer", "Tempdir", "tmpDirectory", "tmpPath", " temporaryDirectory", "tempPath", " tempdir", " tempPath", " tempDirectory", "tmpdir", "TempDirectory", "TempPath", "tempDirectory", " temporaryVer"], "url": ["image", "client", "service", "sl", "ul", "stream", "host", "socket", "el", "fl", "ls", "server", "coll", "address", "conn", "open", "connection", "http", "URL", "path", "pull", "io", "ssl", "file", "f", "Url", "channel", "base", "download", "contact", "log", "ll", "l", "string", "web", "ur", "uri", "source", "config", "www"], "WSDLFile": ["WINDELFolder", "WSDDLPath", "WSDDLSourceFile", "WDDLSourceFile", "WDDlFile", "WINDLPath", "WDDLBase", "WSDLFolder", "WSDDLFolder", "WSDLLFolder", "WDDlSourceFile", "WSDELFolder", "WSDLSourceFile", "WINDLFile", "WSDDLFiles", "WDDLPath", "WSDLLPath", "WDDlfile", "WSDlSourceFile", "WSDLfile", "WSDlFile", "WINDLFiles", "WSDDLfile", "WSDlBase", "WINDLFolder", "WSDLPath", "WINDELFiles", "WSDLLFiles", "WDDlFolder", "WDDlBase", "WSDELFiles", "WSDLFiles", "WSDELFile", "WDDLFile", "WDDLFolder", "WSDLLSourceFile", "WSDlfile", "WDDLfile", "WSDDLBase", "WDDlPath", "WSDLLBase", "WSDLLfile", "WSDLBase", "WSDLLFile", "WINDELFile", "WSDlFolder", "WSDELPath", "WSDDLFile", "WSDlPath", "WINDELPath"], "tmpWSDLFile": ["tmpWDDLFolder", "tmpWDDlFile", "tmpWSDLFiles", "tmpWDDLFiles", "tmpWSDlUrl", "tmpWSDlFile", "tmpWSDELUrl", "tmpWSDELFile", "tmpWDDlFiles", "tmpWDDlUrl", "tmpWSDlFolder", "tmpWDDELFiles", "tmpWSDLLUrl", "tmpWDDELLocation", "tmpWDDLLocation", "tmpWSDlLocation", "tmpWSDLFolder", "tmpWSDLLocation", "tmpWSDDLFile", "tmpWSDDLLocation", "tmpWSDLLFiles", "tmpWSDlFiles", "tmpWDDLFile", "tmpWSDELFiles", "tmpWSDLLFolder", "tmpWSDLLFile", "tmpWSDELLocation", "tmpWDDlFolder", "tmpWSDELFolder", "tmpWSDDLUrl", "tmpWDDELFile", "tmpWSDDLFiles", "tmpWDDLUrl", "tmpWDDELUrl", "tmpWSDLUrl"], "inputFile": ["InputFile", " inputPage", "tempFile", "tempBase", " inputBase", " inputFactory", "InputBuffer", " inputPlace", "tempPage", "outputFile", "InputFiles", "outputDir", " inputfile", "inputUrl", "InputUrl", "tempBuffer", " inputStream", "inputBase", "Inputfile", "InputDir", "inputPlace", "requestStream", "requestFile", " inputFiles", "inputFactory", "tempfile", "outputFiles", "tempUrl", "InputStream", "InputFactory", "InputPage", "inputBuffer", "InputBase", "InputPlace", "inPage", " inputBuffer", " inputUrl", "inputfile", "inDir", "inputFiles", "infile", " inputDir", "inputDir", "inFile", "inputPage", "tempFactory", "tempPlace", "requestFiles", "outputfile", "inputStream", "requestfile"], "tmpFile": ["tempFile", "uploadStream", "TempFiles", "uploadFiles", "tempPage", " tmpPage", "tmpPage", "uploadFile", " tmpDirectory", " tmpFiles", "tmpFiles", "TempPage", "TempFile", "tmpDirectory", "tempFiles", "inputDocument", "uploadDocument", "tempStream", "tempDirectory", "inputFiles", "tempDocument", "inputStream", "tmpStream", "TempDirectory"], "in": ["r", "image", "client", "m", "p", "pin", "inn", "gin", "is", "socket", "init", "impl", "input", "on", "id", "din", "conn", "lin", "connection", "inner", "ssl", "file", "f", "login", "data", "ins", "bin", "In", "l", "reader", "IN", "again", "lock", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "timeout", "client", "writer", "sync", "output", "socket", "input", "copy", "on", "parent", "server", "cache", "conn", "to", "group", "connection", "inner", "io", "line", "file", "conf", "part", "ch", "o", "channel", "conv", "err", "can", "log", "net", "co", "name", "bin", "In", "again", "OUT", "IN", "outs", "outer", "source", "up", "c", "inc"], "con": ["plain", "client", "connect", "Conn", "sync", "gin", "socket", "cn", "rc", "thin", "CON", "com", "conn", "open", "ran", "connection", "nc", "bc", "inner", "cm", "ssl", "uc", "fc", "rec", "conf", "Con", "kin", "ctrl", "en", "ch", "close", "channel", "conv", "can", "ins", "co", "un", "IN", "win", "c", "inc"], "fileLength": ["fileSize", "contentSize", "FileLength", " fileWidth", "channelWidth", "contentLen", "FileSize", "channelLen", "filelength", "fileLen", "FileLen", "FileWidth", " filelength", "channelLength", "channelSize", "contentlength", " fileSize", "fileWidth", " fileLen", "Filelength", "contentLength"], "channelIn": ["channelin", " channelConn", "ChannelIn", " channelin", "Channelin", "connectionIn", "channelConn", "connectionOut", "connectionin", "characterIN", "resourceIN", "connectionConn", "characterIn", "resourcein", "channelIN", "resourceOut", "ChannelIN", "ChannelConn", " channelIN", "resourceIn", "characterin", "characterOut", "ChannelOut"], "channelOut": ["connectionOutside", "ChannelOutput", "ChannelIn", "channelOutside", " channelOutput", "channelOUT", "connectionIn", "chanIn", "connectionOut", "canIn", "connectionOutput", "chanout", "chanOutside", "ChannelOutside", " channelout", "canOutside", "canOUT", "chanOUT", "Channelout", "channelout", "connectionout", "chanOut", "channelOutput", "canOut", "ChannelOUT", "ChannelOut"], "tmpDocument": ["tempContent", "tempFile", "tmNode", "newFile", "tmFile", "tempdocument", "tmdocument", " tmpNode", "tempNode", " tmpContent", "tmpDoc", "tmpdocument", "tmpContent", "tempDoc", "newDocument", "tmpNode", "mpFile", " tmpdocument", "newContent", " tmpDoc", "mpNode", "tempDocument", "newdocument", "tmDocument", "mpDoc", "mpDocument"], "nl1": ["arl1", "jlone", "nn2", "nn0", "arl5", "nl5", "jl5", "klFirst", "ln11", "kl1", "nn6", "nn1", "arlFirst", "NL0", "NL6", "NL11", "klone", "NL1", "jlFirst", "ln6", "nl2", "nn11", "ln1", "jl1", "dl0", "dl1", "nlFirst", "nl11", "nl0", "NL2", "kl5", "ln2", "arlone", "nlone", "dl2", "nl6"], "i": ["ai", "ip", "uli", "m", "j", "p", "ie", "n", "eni", "multi", "fi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "index", "li", "ii", "io", "iu", "z", "ini", "bi", "part", "pi", "f", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "d", "si", "yi", "chi", "qi", "uri", "I"], "node1": ["layerOne", "node91", "layer2", "node0", " node0", "nodeone", "Node1", "packageOne", "Node0", "layer91", "n0", " nodeone", "Node91", "shape91", "shapeOne", "layer1", "n1", "nOne", "packageone", "NodeOne", " nodeOne", "shapeone", " node91", "Node2", "nodeOne", "package91", "shape1", "node2", "package1", "n2", " node2"], "tmpOut": ["tempFile", "ptyOutput", "vmout", "cacheOUT", "txtOut", "vmOUT", "txtWriter", "tempout", "txtOutput", " tmpOutput", "cacheOut", "tmpIn", " tmpIn", "tempWriter", "tmpWriter", "tempOutput", "tmpOutput", "txtout", "cacheFile", "tmpout", "tmpOUT", "ptyIn", "tempIn", "ptyOut", " tmpWriter", "vmOut", "tempOut", "cacheIn", "tempOUT", " tmpout", "ptyout", " tmpOUT", "vmIn"], "retVal": [" retObj", "valRet", "RETval", "RETVal", "retval", "retObj", "RETObj", " retval", "valval", "retRet", "valObj", " retRet", "valVal", "RETRet"]}}
{"id1": "17724879", "id2": "18370075", "code1": "    public byte[] getDigest(OMAttribute attribute, String digestAlgorithm) throws OMException {\n        byte[] digest = new byte[0];\n        if (!(attribute.getLocalName().equals(\"xmlns\") || attribute.getLocalName().startsWith(\"xmlns:\"))) try {\n            MessageDigest md = MessageDigest.getInstance(digestAlgorithm);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update((byte) 2);\n            md.update(getExpandedName(attribute).getBytes(\"UnicodeBigUnmarked\"));\n            md.update((byte) 0);\n            md.update((byte) 0);\n            md.update(attribute.getAttributeValue().getBytes(\"UnicodeBigUnmarked\"));\n            digest = md.digest();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OMException(e);\n        } catch (UnsupportedEncodingException e) {\n            throw new OMException(e);\n        }\n        return digest;\n    }\n", "code2": "    public static byte[] createPasswordDigest(String password, byte[] salt) throws Exception {\n        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n        md.update(salt);\n        md.update(password.getBytes(\"UTF8\"));\n        byte[] digest = md.digest();\n        return digest;\n    }\n", "label": 1, "substitutes": {"getDigest": ["createDigest", "createdigHash", "createdigest", "getMDHash", "createDigests", "getMDest", "createDigHash", "getMDester", "getdigHash", "getSignest", "getMDests", "getDigester", "getdigest", "getdigester", "createdigests", "createdigester", "createDigester", "getDigests", "getDigHash", "getSignester", "getSignests", "getSignHash", "getdigests"], "attribute": ["att", "image", "client", "component", "attr", "element", "argument", "entry", "class", "object", "character", "instance", "reference", "layer", "route", "directory", "expression", "metadata", "ribute", "address", "Attribute", "property", "connection", "ident", "resource", "audio", "message", "pair", "operation", "manager", "value", "function", "prefix", "feature", "api", "set", "definition", "data", "type", "subject", "application", "document", "name", "node", "individual", "entity", "plugin", "variable", "uri", "event", "device", "config", "username"], "digestAlgorithm": ["digestalgebra", "digestalgorith", "digestALgo", "digestElger", "digestElgo", "digestALgebra", "digestALgorithm", "digESTAlger", "digestAlgebra", "digESTAlg", "digesterAlgebra", "digestElg", "digestalgorithm", "digestalger", "digestAlgo", "digesterAlgorith", "digestElgorithm", "digESTAlgo", "digestALgorith", "digestAlgorith", "digesterAlgorithm", "digESTAlgorithm", "digestAlger", "digestAlg", "digesterAlgo", "digestalgo", "digestalg"], "digest": [" digested", "Diguration", "Digtest", "signest", "labester", "longEST", "multiplest", "DigEST", "multiplEST", "signgest", "digger", "diggest", "labEST", " digtest", "longest", " digEST", "dger", "bigester", "Digest", "signger", " diguration", "biggest", "multiplester", "dgest", "labtest", "Digester", " digester", "dest", "digester", "multipluration", "digEST", "digtest", "bigger", "labest", "longested", "digested", "bigest", "diguration", "dester", "longester", "Digested", "signester"], "md": ["mm", "mac", "der", "mo", "sd", "m", "db", "kg", "my", "mad", "app", "ad", "po", "mn", "pd", "ht", "ng", "metadata", "arm", "mid", "id", "ui", "um", "module", "cd", "ma", "od", "rm", "editor", "mb", "amd", "nm", "cm", "df", "manager", "wd", "own", "ds", "bd", "mr", "sm", "doc", "dm", "pm", "mi", "nd", "mt", "MD", "mp", "di", "mc", "hd", "mag", "plugin", "d", "ml", "mod", "ld", "ms", "meta", "cmd", "dev", "dd", " MD", "cb"]}}
{"id1": "2521141", "id2": "4468255", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static void copy(File from, File to) {\n        boolean result;\n        if (from.isDirectory()) {\n            File[] subFiles = from.listFiles();\n            for (int i = 0; i < subFiles.length; i++) {\n                File newDir = new File(to, subFiles[i].getName());\n                result = false;\n                if (subFiles[i].isDirectory()) {\n                    if (newDir.exists()) result = true; else result = newDir.mkdirs();\n                } else if (subFiles[i].isFile()) {\n                    try {\n                        result = newDir.createNewFile();\n                    } catch (IOException e) {\n                        log.error(\"unable to create new file: \" + newDir, e);\n                        result = false;\n                    }\n                }\n                if (result) copy(subFiles[i], newDir);\n            }\n        } else if (from.isFile()) {\n            FileInputStream in = null;\n            FileOutputStream out = null;\n            try {\n                in = new FileInputStream(from);\n                out = new FileOutputStream(to);\n                int fileLength = (int) from.length();\n                char charBuff[] = new char[fileLength];\n                int len;\n                int oneChar;\n                while ((oneChar = in.read()) != -1) {\n                    out.write(oneChar);\n                }\n            } catch (FileNotFoundException e) {\n                log.error(\"File not found!\", e);\n            } catch (IOException e) {\n                log.error(\"Unable to read from file!\", e);\n            } finally {\n                try {\n                    if (in != null) in.close();\n                    if (out != null) out.close();\n                } catch (IOException e1) {\n                    log.error(\"Error closing file reader/writer\", e1);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"copy": ["get", "image", "clone", "sync", "upload", "ize", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "directory", "archive", " cp", "ame", "open", "source", "diff", "share", "rm", "clip", "cop", "ignore", "change", "file", "ge", "link", "update", "zip", "download", "create", "type", "pe", "paste", "attach", "dump", "opy", "config", "move"], "from_name": ["from_names", "from__name", " from_names", "from_memory", "to_path", "from_key", "fromFfilename", "fromFname", "source_filename", "fromMname", "source_memory", "from_filename", "to_filename", "source_name", " from_Name", "from__path", "fromFpath", "from__memory", "from_path", "fromMnames", "fromFmemory", "fromMfile", "source_path", " from_key", "from_Name", "from__filename"], "to_name": ["toamname", "toamhome", "to_home", "toampath", "to_path", " to_Name", "to_Name", " to_path", "from_path", "from_filename", "toamfile", "to_filename", " to_home"], "from_file": ["fromappfunction", "from_directory", " from__auto", "from__name", "from_brain", "from___filename", "from_resource", "from_source", "from___file", " from__filename", " from__file", " from_directory", "source_filename", "source_directory", "fromCfile", "remote_lane", "from__files", " from_filename", " from__name", "from__directory", "from__resource", "fromCname", "remote_function", "from_function", "from_filename", "from___name", "from_lane", "remote_log", "fromCbrain", "source_brain", " from_folder", "source_name", " from_auto", "source_files", "remote_file", " from_files", "fromapplane", "from_auto", "from_log", " from_source", "from_files", "fromCfilename", "fromappfile", "from__file", "from_folder", "fromapplog", "source_resource", "from__filename", "from__auto", "source_file", "from___auto"], "to_file": ["to64use", "to_model", "tojfile", "intojfile", "eto___remote", "intojfunction", "into_use", "to__dir", "eto_remote", "from_model", "to64name", "to_remote", "to_binary", "source_filename", "to_server", "to67load", "eto_file", "intojname", "intojuse", "to___remote", "tojuse", " to_class", "into_function", "to67dir", " to_queue", "to__name", "to_filename", "from_bar", "source_server", "to_queue", "to_dir", "to67name", "eto___name", "toJstream", "to__load", "to64file", " to_model", "to64function", "into_file", "toJfile", "to___name", "to_class", "tojfunction", "source_files", "eto_name", "from_dir", "to67file", " to_filename", "to_stream", "to___file", "from_files", "from_stream", "from_load", "to_function", "toJbar", "eto___file", " to_files", "to_files", "to_load", "to_use", "tojname", "into_name", "to_bar", "toJname", "from_binary", "to__file", "source_file"], "parent": ["size", "author", "old", "global", "complete", "address", "target", "content", "container", "Parent", "root", "api", "test", "search", "name", "string", "folder", "am", "uri", "ip", "client", "p", "full", "pa", "user", "page", "patch", "rule", "cache", "home", "loc", "path", "pool", "file", "part", "unit", "div", "any", "ac", "inc", "ppa", "tree", "host", "id", "directory", "port", "per", "child", "out", "manager", "function", "url", "null", "memory", "remote", "point", "source", "term", "mother", "par", "owner", "po", "handler", "server", "or", "connection", "fat", "location", "resource", "session", "type", "temp", "parents", "current"], "dir": ["r", "db", "in", "entry", "block", "def", "class", "object", "user", "global", "dict", "cat", "dec", "id", "directory", "coll", "cache", "home", "per", "md", " directory", "loc", "group", "module", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "io", "exp", "ir", "out", "manager", "wd", "file", "root", "director", "part", "build", "iter", "f", "url", "die", "doc", "data", "div", "rel", "keep", "Dir", "name", "di", "d", "folder", "tr", "lock", "dev", "nav", "dis"], "from": ["when", "get", "auto", "From", "fr", "client", "component", "flo", "left", "one", "entry", "stream", "form", "ce", "view", "feed", "context", "ou", "parse", "e", "cr", "cf", "cache", "server", "address", "per", "fe", "conn", "or", "connection", "http", "low", "io", "se", "cor", "cm", "ra", "con", "file", "find", "part", "who", "start", "link", "url", "ch", "this", "api", "base", "normal", "with", "pe", "range", "can", "so", "name", "bean", "by", "without", "two", "empty", "add", "source", "self", "vol"], "to": ["auto", "db", "su", "client", "that", "flo", "size", "too", "sync", "one", "output", "socket", "proxy", "write", "on", "po", "tto", "office", "To", "t", "server", "per", "conn", "thro", "target", "or", "connection", "fat", "http", "TO", "fb", "ver", "io", "top", "op", "see", "not", "out", "value", "dest", "file", "storage", "store", "pi", "o", "until", "api", "base", "will", "session", "type", "with", "token", "via", "so", "co", "by", "as", "two", "about"], "buffer": ["position", "writer", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "slice", "reference", "bb", "page", "Buffer", "server", "address", "source", "padding", "message", "resource", "buff", "row", "uffer", "iter", "url", "buf", "binary", "channel", "null", "data", "b", "border", "number", "wave", "document", "total", "memory", "reader", "variable", "header", "seed", "duration", "window", "read", "flush", "layer", "length"], "bytes_read": ["gets___pass", "bytesXbefore", "gets___allow", "byte_current", "byte_load", " bytes_en", "bytes___reads", "bytes_en", "gets_allow", "byteslexread", " bytes_found", "bytes___allow", " bytes_write", "bytes_found", "bytesXload", "bytes_reads", "bytesXread", "byte_before", "bytes_allow", "bytes_pass", "bytes_load", "bytesXcurrent", "bytes_write", "bytes_before", "bytes___read", "gets___read", "gets_reads", "gets___reads", "bytes___pass", "gets_pass", "bytes_current", "byteslexload", "byte_read", "gets_read", "byteslexbefore", "byteslexcurrent"]}}
{"id1": "5035872", "id2": "6036012", "code1": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "code2": "    public byte[] getClassBytes(String className, ClassLoader classLoader) {\n        URLClassLoader cl = new URLClassLoader(urls, classLoader);\n        String resource = className.replace('.', '/') + \".class\";\n        InputStream is = null;\n        try {\n            URL url = cl.getResource(resource);\n            if (url == null) {\n                throw new RuntimeException(\"Class Resource not found for \" + resource);\n            }\n            is = url.openStream();\n            byte[] classBytes = InputStreamTransform.readBytes(is);\n            return classBytes;\n        } catch (IOException e) {\n            throw new RuntimeException(\"IOException reading bytes for \" + className, e);\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(\"Error closing InputStream for \" + className, e);\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "src": ["image", "in", "sc", "sl", "upload", "obj", "stream", "files", "rc", "s", "sit", "input", "slice", "ls", "copy", "sin", "sb", "conn", "loc", "rb", "http", "path", "resource", "inst", "img", "dest", "file", "root", "dist", "config", "storage", "sel", "url", "st", "this", "data", "download", "b", "uri", "iv", "source", "filename"], "dst": ["Dcr", "addest", " dsts", "dsts", " dcr", "dds", "fdds", "ddest", "dbds", "Dsts", "fdput", " ddest", "fdot", "Ddest", "dbput", "Dst", "dot", "tdst", "dput", "adst", "tdds", "dbot", "tdot", "adcr", "adsts", "fdst", "dbst", "dcr", "tdput"], "inChannel": ["InContext", "againCamera", "outStream", "inputChannel", " inchannel", " inContext", "inchannel", "INStream", "innerChan", "INChan", "outchannel", "outChan", "loginCamera", "binChannel", "againChan", "outMessage", " inChan", "inMessage", "inCamera", "incChan", "againStream", "InStream", "incCamera", "inputchannel", "inputConnection", "innerStream", "incChannel", "binchannel", "INChannel", " inConnection", "InChan", "incStream", "inputChan", "inChan", "outConnection", "binChan", " inMessage", "loginChan", "againChannel", " inStream", "inConnection", "InChannel", "loginChannel", "binConnection", "Inchannel", "innerConnection", "INchannel", "INConnection", "loginStream", "innerChannel", "outContext", "inputStream", "inputMessage", "inContext", "binStream", "inStream"], "outChannel": ["againGate", "outGate", "outStream", " outchannel", "inputChannel", "inchannel", " outGate", "againConnection", "outchannel", "OutChan", "outChan", " outQueue", "OutChannel", "outputChan", "outputStream", "outWriter", " outWriter", "offChan", "inQueue", "inWriter", "outputchannel", "againchannel", "againStream", "inputchannel", " outChan", "outputChannel", " outConnection", " outStream", "Outchannel", "againChannel", "inputChan", "inChan", "outConnection", "outQueue", "againQueue", "inConnection", "offContext", "offChannel", " outContext", "inGate", "offWriter", "outContext", "inputStream", "OutStream", "inContext", "againChan", "inStream"], "result": ["r", "success", "compl", "match", "error", "card", "default", "comment", "use", "future", "valid", "cache", "complete", "diff", "or", "found", "array", "response", "successful", "Result", "ret", "results", "work", "function", "cash", "ault", "f", "pass", "cup", "err", "data", "false", "done", "test", "status", "continue", "res", "true", "math", "ure", "folder", "event", "current", "func", "length"]}}
{"id1": "23672408", "id2": "2511579", "code1": "    private void copyIconFiles(UmlClass clazz) {\n        if (clazz.hasAnnotation(\"icon16\")) {\n            String i16 = clazz.annotationValue(\"icon16\");\n            String fileType = \".png\";\n            if (i16.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i16.endsWith(\".gif\")) fileType = \".gif\";\n            String desti16 = output_dir + \"/../resources/images/\" + clazz.getName() + \"16\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i16).getChannel();\n                FileChannel dst = new FileOutputStream(desti16).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n        if (clazz.hasAnnotation(\"icon32\")) {\n            String i32 = clazz.annotationValue(\"icon32\");\n            String fileType = \".png\";\n            if (i32.endsWith(\".jpg\")) fileType = \".jpg\";\n            if (i32.endsWith(\".gif\")) fileType = \".gif\";\n            String desti32 = output_dir + \"/../resources/images/\" + clazz.getName() + \"32\" + fileType;\n            try {\n                FileChannel src = new FileInputStream(i32).getChannel();\n                FileChannel dst = new FileOutputStream(desti32).getChannel();\n                dst.transferFrom(src, 0, src.size());\n                src.close();\n                dst.close();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n    }\n", "code2": "    private void extractZipFile(String filename, JTextPane progressText) throws IOException {\n        String destinationname = \"\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(filename));\n        while ((zipentry = zipinputstream.getNextEntry()) != null) {\n            String entryName = zipentry.getName();\n            if (progressText != null) {\n                progressText.setText(\"extracting \" + entryName);\n            }\n            int n;\n            FileOutputStream fileoutputstream;\n            if (zipentry.isDirectory()) {\n                (new File(destinationname + entryName)).mkdir();\n                continue;\n            }\n            fileoutputstream = new FileOutputStream(destinationname + entryName);\n            while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n            fileoutputstream.close();\n            zipinputstream.closeEntry();\n        }\n        if (progressText != null) {\n            progressText.setText(\"Files extracted\");\n        }\n        zipinputstream.close();\n    }\n", "label": 1, "substitutes": {"copyIconFiles": ["copyFileImages", "copyiconTypes", "copyiconImages", "copyIconImages", "copyImageTypes", "copyIconFile", "copyImageFiles", "copyiconFile", "copyFileFiles", " copyiconImages", "copyFileFile", " copyIconFile", " copyIconTypes", " copyiconFiles", "copyImageImages", "copyIconTypes", "copyFileTypes", "copyImageFile", "copyiconFiles", " copyiconTypes", " copyiconFile", " copyIconImages"], "clazz": ["llasso", "flazz", "clclass", "claz", "Clazz", " cllass", "hellasso", "CLaz", "Clab", "cluster", " classo", "slazz", "clab", "Closs", " clance", "sllass", "hellazz", " clclass", "clod", "glod", "flaz", " clunk", "cllass", "slance", "pllass", "Claz", "hellasse", "closer", "hellance", "glaz", "sloss", "llaz", "plazz", "closs", "hellosed", "classo", " clab", "llclass", "glazz", "clobe", "CLazz", " closs", "clunk", "Cllass", " classe", "llasse", "llazz", "glance", "hellobe", "sluster", "clance", "llobe", "llab", "slod", "Clclass", "slaz", "fluster", " clobe", " closer", "plclass", " closed", "Cluster", "ploser", "Clunk", "helllass", "slosed", "flunk", " cluster", "CLod", "CLance", "classe", "closed", "Closer", " claz"], "i16": ["ini16", "ii17", "l16", "io15", "io2016", "I14", "si24", "ii15", "ii16", "l15", "ai16", "pi24", "int16", "ini15", "i15", "I16", "int24", "i64", "io16", "ini2016", "l24", "pi16", "si64", "ini17", "si14", "i14", "ii14", "ii2016", "si15", "i2016", "ai14", "pi15", "io24", "ini14", "pi64", "I17", "int2016", "ai15", "int15", "ai2016", "ii24", "i17", "si16", "si2016", "l64", "I15", "i24"], "fileType": ["playTy", " fileStyle", "FileType", "feedInfo", "fileFile", " fileTime", "feedtype", " fileInfo", "imageType", "iconKey", "singleStyle", "fileSpread", "fileStyle", "filePath", "fileTime", "FileStyle", "fileUnit", "feedPath", "wordAuth", "FileUnit", "lettertype", " fileAuth", " fileLike", "documentBlock", "feedType", "singleTime", "iconPath", "documenttype", " fileKey", " fileUnit", "filePatch", "documentState", " fileBlock", "messagePatch", "playSpread", " filetype", "iconLength", "iconStyle", "singleFile", "transferTy", " fileTy", "transferFamily", "wordLength", "imageFamily", "letterTy", "fileBlock", "feedLocation", " fileLength", "imageUnit", "messagePath", "imageKey", "imageStyle", "wordTy", "filetype", "documentType", "messagetype", "feedPatch", "fileAuth", "letterState", "transferSpread", "fileState", "wordType", " filePath", " fileLocation", " fileState", "transferType", "letterBlock", "FileFamily", " fileFile", "FileLike", "imagePath", "iconType", "fileFamily", "FileLocation", "feedLike", "fileLength", "letterFamily", "fileLocation", "fileLike", " filePatch", "playType", "imageFile", "letterSpread", "imageTime", "fileInfo", " fileFamily", "fileKey", "iconAuth", "letterType", "FileInfo", "playFamily", "messageType", "fileTy", "singleType", "iconTy"], "desti16": ["desturi16", "combi64", "desti64", "destI16", "destini15", "targetI16", "combi32", "destabi15", "targetI016", "destsi64", "desti2016", "destsi15", "destI2016", "combi16", "destf2016", "destI016", "destf15", "desti016", "destabi16", "destabi016", "destf016", "destsi32", "destabi2016", "desturi15", "targetI2016", "combini16", "targeti15", "destini16", "combini15", "desti15", "destini64", "targetI15", "desturi32", "destI15", "destini32", "combini32", "destsi16", "desturi64", "targeti016", "targeti16", "targeti2016", "destf16", "combi15", "combini64"], "src": ["image", "video", "sync", "ctx", "attr", "upload", "grad", "support", "rc", "bs", "s", "target", "http", "desc", "proc", "root", "secure", "config", "sel", "buf", "st", "conv", "sq", "cv", "https", "front", "usr", "uri", "iv", "ser", "cmp", "back", "cb", "r", "sl", "console", "rl", "view", "uv", "load", "input", "scene", "loc", "rb", "inst", "dest", "cdn", "file", "dist", "sr", "b", "scenes", "thumbnails", "ource", "in", "stream", "output", "pkg", "cur", "pull", "gb", "ssl", "bh", "url", "req", "lib", "null", "download", "gl", "source", "filename", "sc", "socket", "default", "tmp", "ug", "coll", "rss", "hub", "resource", "crop", "img", "uc", "ctrl", "data", "sys", "gz", "func", "rob"], "dst": ["idsc", " dste", "dedost", "nrest", "deddr", "ldost", "dST", "rdsc", "adost", " dput", " dsl", "idst", " dest", "dsc", "dsst", "ldct", "idbl", " drd", " dsts", "sdbl", "idrd", "dct", "nsts", "Dsts", " drest", " ddest", "dsdr", "dest", "dbl", "Dste", "adbl", "adct", "adst", "Dct", "ldst", "sddest", "idest", "sdsl", "dste", " dbl", "dost", "drest", "Drest", "ddest", "dedst", "rdst", "dsl", "nste", "Dbl", "dput", "drsc", "sdest", "sdst", "ddr", "sdrd", "Dost", "dedput", "Ddr", "drst", "ldbl", "dsts", "Dput", "drput", " dST", "sdsc", "Dst", "drd", "dsost", "dsput", "rdput", " dsc", "nst", "iddest", "idsl", "rdST", "drST"], "i32": ["ri33", "i42", "i22", "I30", "in32", "I42", "si22", "iu33", "qi33", "ui30", "I35", "ini22", "iu15", " i33", "ri32", "i15", " i34", "in33", "I32", "si35", " i35", "i30", "i33", "ini35", "ri35", "I31", "qi15", " i30", "in15", "i34", "ini33", "ini32", "qi34", " i42", "I33", "i31", " i22", "ri42", "ui32", "ui31", "qi32", "i35", "I34", " i31", "in34", "iu34", "ui34", "si32", "si33", "iu32"], "desti32": ["destabi22", "destsi22", "targeti32", "destin33", "destii28", "desti28", "targeti34", "targeti28", " desti15", "targeti33", "destabi15", "destabi32", "desti33", " destsi15", "desti34", "destsi15", "destin32", "destabi16", "destiu34", "destsi32", "targetiu32", "destin28", "destic22", "destiu33", "destin34", "desti22", " destsi16", " desti22", "destii33", "desti15", "destii32", "destii34", "destiu28", "targetiu34", "targetiu33", "destiu32", "targetiu28", "destic16", " destsi32", "destsi16", " destsi22", "destic15", "destic32"]}}
{"id1": "6742637", "id2": "15472181", "code1": "    private static List<Properties> findExtensions() {\n        URL url = null;\n        try {\n            List<Properties> extensions = new ArrayList<Properties>();\n            Enumeration<URL> res = ExtensionHelper.class.getClassLoader().getResources(\"logdistiller.properties\");\n            while (res.hasMoreElements()) {\n                url = res.nextElement();\n                Properties prop = new Properties();\n                prop.load(url.openStream());\n                extensions.add(prop);\n            }\n            return extensions;\n        } catch (IOException ioe) {\n            String msg = (url == null) ? \"unable to list resources logdistiller.properties\" : \"unable to load resource \" + url.toExternalForm();\n            throw new RuntimeException(msg, ioe);\n        }\n    }\n", "code2": "    private InputStream getInputStream(String item) {\n        InputStream is = null;\n        URLConnection urlc = null;\n        try {\n            URL url = new URL(item);\n            urlc = url.openConnection();\n            is = urlc.getInputStream();\n            current_source = url.getProtocol() + \"://\" + url.getHost() + \":\" + url.getPort() + url.getFile();\n        } catch (Exception ee) {\n            System.err.println(ee);\n        }\n        int i = 0;\n        udp_port = -1;\n        udp_baddress = null;\n        while (urlc != null) {\n            String s = urlc.getHeaderField(i);\n            String t = urlc.getHeaderFieldKey(i);\n            if (s == null) {\n                break;\n            }\n            i++;\n            if (\"udp-port\".equals(t)) {\n                try {\n                    udp_port = Integer.parseInt(s);\n                } catch (Exception e) {\n                }\n            } else if (\"udp-broadcast-address\".equals(t)) {\n                udp_baddress = s;\n            }\n        }\n        return is;\n    }\n", "label": 0, "substitutes": {"findExtensions": ["findAppensions", "findExtends", "getextension", "findextension", "findAppension", "getextensions", "findExtension", "getExtends", "findextensions", "findDistension", "findDistensions", "findAppends", "getExtension", "findDistends", "findextends", "getExtensions", "getextends"], "url": ["lr", "r", "image", "fr", "buffer", "service", "sl", "ul", "element", "html", "entry", "rl", "src", "rc", "load", "feed", "impl", "bug", "ls", "bb", "il", "id", "page", "server", "coll", "address", "bel", "loc", "result", "ver", "connection", "http", "location", "URL", "resource", "path", "io", "pull", "ssl", "file", "link", "f", "Url", "ch", "api", "base", "zip", "data", "err", "gl", "log", "rel", "org", "cl", "name", "l", "remote", "web", "ur", "uri", "re", "source", "config"], "extensions": ["xtensions", "intends", "exensions", "Extencies", "exras", "xtps", "exencies", "appensions", "appencies", "extps", "Extras", "fension", "extras", "xtension", "Extension", "intps", "appras", "intensions", "fensions", "extension", "fends", "exends", "extencies", "fps", "intension", "exps", "Extensions", "xtends", "appension", "exension"], "res": ["request", "vals", "r", "os", "gr", "ress", "fr", "details", "RS", "is", "rc", "Rs", "RE", "rs", "RES", "pres", "ex", "ros", "es", "ris", "result", "ver", "rss", "http", "vers", "response", "resource", "ras", "rh", "results", "rr", "raw", "out", "ret", "resp", "rez", "hr", "mr", "rev", "req", "ch", "rest", "err", "rex", "rem", "rows", "ries", "Res", "resolution", "js", "ps", "rus", "re"], "prop": ["j", "p", "term", "obj", "attr", "pos", "cp", "def", "class", "key", "tmp", "app", "opt", "properties", "option", "val", "info", "result", "property", "fb", "exp", "ext", "resource", "ref", "op", "fp", "proc", "lit", "Prop", "pb", "part", "feat", "f", "api", "base", "feature", "data", "b", "comp", "pac", "mp", "style", "pro", "project", "ps", "point", "priv", "config", "pr"], "msg": ["gr", "error", "db", "m", "kg", "bf", "g", "s", "ug", "title", "mn", "mid", "urg", "loc", "info", "sg", "format", "bg", "reason", "message", "ext", "mb", "ko", "eg", "str", "req", "mg", "err", "log", "printf", "Msg", "tag", "status", "text", "mt", "cfg", "me", "comm", "mag", "rag", "string", "og", "gs", "gm", "ms", "cmd", "agg"]}}
{"id1": "17999474", "id2": "6501291", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    public static void extractFile(String input, String output) throws ZipException, IOException {\n        FileReader reader = new FileReader(input);\n        InputStream in = reader.getInputStream();\n        OutputStream out = new FileOutputStream(new File(output));\n        byte[] buf = new byte[512];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        reader.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtDir", "getTempAsPlace", "getTempAsFile", "getZipAtfile", "getTempAsDir", "getZipAsfile", "getZipasPlace", "getZipAsPlace", "getZipAtFile", "getZipasFile", "getZipasDir", "getZipAsDir", "getZipasfile", "getZipAtPlace", "getTempAsfile"], "digOb": [" digObject", "dimObject", " digObj", " digob", "signObject", "ditOb", "dimObj", "signob", "Digob", "signOb", "dimOl", "ditob", "DigOl", "signObj", "digob", " digOl", "signOB", "ditObject", "digObj", "DigObject", "DigOb", "digOl", "dimOb", "DigObj", "ditOB", "digOB", "digObject", " digOB"], "folderName": ["folderPath", "Foldername", "FolderDir", "foldername", "packagename", "foldPath", " folderPath", "FolderInfo", "packageName", "folderInfo", "foldname", "packagePath", "packageDir", "fileInfo", "folderDir", "foldName", " folderDir", "FolderName", "fileName", " foldername", "FolderPath", "filePath", "foldInfo", "filename"], "tmpFolder": [" temporaryManager", "tempDir", "tmpfolder", " tmpDir", "mpDir", "tempfolder", " tmpfolder", "mpfolder", "tmpManager", " tmpManager", " tmpDirectory", "tmpDir", "tempFolder", " temporaryFolder", " temporaryfolder", "mpDirectory", "tmpDirectory", " temporaryDirectory", "tempDirectory", "tempManager", "mpFolder"], "zip": ["job", "ip", "ress", "p", "sl", "upload", "ie", "flow", "ce", "tmp", "proxy", "feed", "slice", "install", "copy", "pkg", "ze", "cf", "archive", "json", "py", "Zip", " ZIP", "clip", "io", "cop", "zone", "pack", "ignore", "z", "xml", "fp", "file", "ulp", "lex", "bag", "f", "url", "lib", " zipper", "temp", "download", "flat", "wrap", "seed", "folder", "gz", "lock", "jar", "source", "ipped", "pipe"], "out": ["Out", "plain", "os", "in", "client", "writer", "obj", "sync", "upload", "flow", "output", "is", "object", "socket", "user", "write", "copy", "parent", "cli", "page", "ex", "cache", "conn", "child", "info", "result", "connection", "a", "path", "io", "z", "line", "file", "box", "f", "url", "o", "null", "base", "this", "temp", "err", "download", "log", "loader", "again", "outs", "gz", "gen", "flush", "source", "OUT"]}}
{"id1": "6890417", "id2": "20190303", "code1": "    public static void main(String[] args) throws IOException {\n        PostParameter a1 = new PostParameter(\"v\", Utils.encode(\"1.0\"));\n        PostParameter a2 = new PostParameter(\"api_key\", Utils.encode(RenRenConstant.apiKey));\n        PostParameter a3 = new PostParameter(\"method\", Utils.encode(\"feed.publishTemplatizedAction\"));\n        PostParameter a4 = new PostParameter(\"call_id\", System.nanoTime());\n        PostParameter a5 = new PostParameter(\"session_key\", Utils.encode(\"5.b2ca405eef80b4da1f68d0df64e471be.86400.1298372400-350727914\"));\n        PostParameter a8 = new PostParameter(\"format\", Utils.encode(\"JSON\"));\n        PostParameter a9 = new PostParameter(\"template_id\", Utils.encode(\"1\"));\n        PostParameter a10 = new PostParameter(\"title_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        PostParameter a11 = new PostParameter(\"body_data\", Utils.encode(\"\\\"conteng\\\":\\\"xkt\\\"\"));\n        RenRenPostParameters ps = new RenRenPostParameters(Utils.encode(RenRenConstant.secret));\n        ps.addParameter(a1);\n        ps.addParameter(a2);\n        ps.addParameter(a3);\n        ps.addParameter(a4);\n        ps.addParameter(a5);\n        ps.addParameter(a8);\n        ps.addParameter(a9);\n        ps.addParameter(a10);\n        ps.addParameter(a11);\n        System.out.println(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        URL url = new URL(RenRenConstant.apiUrl + \"?\" + ps.generateUrl());\n        HttpURLConnection request = (HttpURLConnection) url.openConnection();\n        request.setDoOutput(true);\n        request.setRequestMethod(\"POST\");\n        System.out.println(\"Sending request...\");\n        request.connect();\n        System.out.println(\"Response: \" + request.getResponseCode() + \" \" + request.getResponseMessage());\n        BufferedReader reader = new BufferedReader(new InputStreamReader(request.getInputStream()));\n        String b = null;\n        while ((b = reader.readLine()) != null) {\n            System.out.println(b);\n        }\n    }\n", "code2": "    @Test\n    public void test01_ok_failed_500_no_logo() throws Exception {\n        DefaultHttpClient client = new DefaultHttpClient();\n        try {\n            HttpPost post = new HttpPost(xlsURL);\n            HttpResponse response = client.execute(post);\n            assertEquals(\"failed code for \", 500, response.getStatusLine().getStatusCode());\n        } finally {\n            client.getConnectionManager().shutdown();\n        }\n    }\n", "label": 0, "substitutes": {"a1": ["ga1", "an3", "a01", "alpha01", " a01", "an1", "alpha2", "ga0", "alpha1", "A01", "A3", "alpha0", "an01", "A2", "a0", "an2", "ga01", "ga2", "A1", " a0"], "a2": ["p4", "p1", "A4", "n5", "n4", "p5", "A2", "A8", "p2", "A1", "n2", "A5", "n8"], "a3": ["la33", "alpha5", "an3", " a23", "ga5", "alpha3", "la23", "ga9", "alpha9", "alpha2", "ga3", "a33", "la3", " a33", "an23", "a23", "ga2", "an33"], "a4": ["as5", "A9", "ma8", "A4", "pa8", "ma10", "pa4", "pa10", "ga4", "A2", "ma4", "as4", "as2", "ga10", "ga8", "A5", "as9"], "a5": ["n6", "alpha5", " a7", "a6", "p7", "alpha4", "A4", " a6", "alpha6", "n5", "n7", "a7", "p5", "alpha8", "p6", "A8", "p2", "n2", "A6", "A5"], "a8": [" a7", "a6", "alpha11", "A11", "A6", "alpha4", "A4", "alpha6", " a6", "an7", "b7", "an10", "b8", "a7", "an8", "alpha8", "an6", "b11", "A8", "b10", "b6", "b4"], "a9": ["A9", "alpha7", " a7", "p7", "alpha11", "A11", "alpha9", "alpha10", "alpha09", "a7", "p09", "p10", "alpha8", "A8", "p9", " a09", "A7", "a09"], "a10": ["as8", "a12", "A9", "as09", "A10", "alpha9", "A09", "alpha10", "an10", " a12", "alpha12", "as10", "b09", "b8", "b9", "an8", "an12", "alpha8", "A8", "b10", "an9", "a09", "as9"], "a11": ["a12", "A18", "am10", " a7", "A10", "a18", "alpha11", "A11", "alpha18", " a13", "am7", " a12", "alpha12", "a7", "A13", "alpha8", "am11", "A8", " a18", "A7", "A12", "am13", "a13"], "ps": ["ppa", "os", "ups", "details", "ils", "p", "PS", "points", "ipes", "pp", "qs", "pos", "pa", "files", "is", "cs", "s", "proxy", "rs", "ls", "pes", "ns", "ips", "ases", "pres", "es", "py", "properties", "lines", "per", "gets", "ks", "ams", "cases", "pers", "params", "aps", "ras", "posts", "ples", "ons", "ds", "changes", "ts", "pi", "pass", "alls", "pe", "jp", "hes", "eps", "ins", "ops", "vs", "Ps", "settings", "res", "als", "ss", "pse", "as", "js", "ports", "pps", "gs", "parts", "ms", "rules", "ws", "tests", "pr"], "url": ["image", "client", "buffer", "service", "sl", "object", "proxy", "fl", "user", "bug", "ls", "page", "server", "address", "connection", "http", "URL", "response", "ssl", "file", "build", "cloud", "f", "Url", "base", "download", "control", "contact", "log", "gl", "ll", "document", "l", "browser", "string", "web", "twitter", "uri", "config", "www"], "request": ["next", "r", "client", "buffer", "connect", "rate", "p", "access", "upload", "hello", "worker", "reply", "transfer", "use", "user", "server", "complete", "per", "open", "child", "info", "result", "connection", "http", "response", "resource", "report", "pull", "post", "req", "this", "rest", "session", "builder", "temp", "pe", "method", "call", "Request", "external", "remote", "respond", "web", "push", "re", "create"]}}
{"id1": "9081749", "id2": "1097147", "code1": "    private static String encrypt(String password, String encryptType) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(encryptType);\n            md.update(password.getBytes());\n            byte[] hash = md.digest();\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < hash.length; i++) {\n                if ((0xff & hash[i]) < 0x10) {\n                    hexString.append(\"0\" + Integer.toHexString((0xFF & hash[i])));\n                } else {\n                    hexString.append(Integer.toHexString(0xFF & hash[i]));\n                }\n            }\n            password = hexString.toString();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return password.toUpperCase();\n    }\n", "code2": "    public static String getMessageDigest(String[] inputs) {\n        if (inputs.length == 0) return null;\n        try {\n            MessageDigest sha = MessageDigest.getInstance(\"SHA-1\");\n            for (String input : inputs) sha.update(input.getBytes());\n            byte[] hash = sha.digest();\n            String CPass = \"\";\n            int h = 0;\n            String s = \"\";\n            for (int i = 0; i < 20; i++) {\n                h = hash[i];\n                if (h < 0) h += 256;\n                s = Integer.toHexString(h);\n                if (s.length() < 2) CPass = CPass.concat(\"0\");\n                CPass = CPass.concat(s);\n            }\n            CPass = CPass.toUpperCase();\n            return CPass;\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e.getMessage());\n        }\n    }\n", "label": 1, "substitutes": {"encrypt": ["deccrypt", "encryption", "escipher", "escryption", "escrypt", "Encrypt", "Encryption", "enccrypt", "esccrypt", "decrypt", "encipher", "Encipher", "decryption", "decipher", "Enccrypt"], "password": ["image", "pad", "account", "buffer", "email", "words", "crypt", "key", "pattern", "user", "parent", "css", "sword", "picture", "cache", "mask", "phrase", "address", "padding", "Password", "strip", "array", "message", "weight", "params", "word", "description", "value", "wd", "root", "prefix", "this", "pass", "null", "wallet", "data", "token", "secret", "database", "text", " passwords", "name", "auth", "python", "string", "project", "seed", "parser", "command", "encrypted", "PASS", "username"], "encryptType": ["encriptTyp", "encruptType", "encertKey", "encryptiontype", "ecipherClass", "encipherClass", "encriptType", "encPTClass", "acryptType", "ecryptKey", "encPTType", "encrupttype", "enciphertype", "encriptTypes", "encPTKey", "encrypttype", "encryptionTyp", "ecrypttype", "encipherKey", "encryptionTypes", "acryptionTypes", "encryptionType", "encruptTyp", "ecryptType", "acrypttype", "encertClass", "encryptTyp", "encryptClass", "encripttype", "acryptTyp", "ecipherType", "encerttype", "encPTtype", "encruptTypes", "encryptTypes", "acryptiontype", "acryptTypes", "ecryptClass", "ecipherKey", "eciphertype", "acryptionType", "acryptionTyp", "encertType", "encryptKey", "encipherType"], "md": ["mm", "mac", "mo", "der", "m", "Cmd", "dig", "grad", "mad", "pd", "metadata", "um", "cd", "od", "rm", "amd", "nm", "mb", "df", "dh", "mand", "bd", "gd", "f", "dm", "pm", "mt", "MD", "di", "mp", "mc", "hd", "rpm", "mag", "d", "vd", "mod", "cmd", "dd", " MD", "hed", "hm"], "hash": ["mac", "image", "ha", "error", "h", "query", "flash", "html", "ash", "full", "block", "key", "bit", "print", "bug", "version", "id", "chip", "cache", "check", "sh", "diff", "handle", "code", "sum", "array", "ver", "index", "message", "hard", "digit", "value", "count", "Hash", "fill", "build", "str", "ashes", "len", "how", "part", "url", "dot", "throw", "base", "data", "her", "log", "char", "sha", "number", "search", "memory", "style", "body", "header", "filter", "kh", "hed", "hex"], "hexString": ["alphFile", "hashstring", " hexArray", "alphString", "blackstring", "pixelBuffer", " hexSet", "squareArray", "squareField", "hexstring", " hexLine", "hexField", "hashFile", "hexArray", " hexFile", "zipString", "pixelstring", "squareString", "rawArray", "rawstring", "hexSet", "hexFile", "alphLine", "zipField", " hexField", "hexLine", "blackLine", "rawFile", "zipSet", "squareSet", "pixelFile", "zipArray", "rawString", "alphstring", "hashString", "rawBuffer", " hexBuffer", "blackFile", "hashArray", "pixelString", "hexBuffer", " hexstring", "blackString"], "i": ["r", "ai", "ip", "h", "p", "j", "n", "ie", "off", "s", "multi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "length", "li", "index", "ii", "io", "ini", "count", "bi", "end", "x", "pi", "f", "start", "o", "xi", "ti", "data", "temp", "u", "ri", "b", "v", "ji", "oi", "it", "di", "l", "si", "qi", "uri", "I", "c"]}}
{"id1": "160739", "id2": "755203", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"createOutputStream": [" createIOSteam", "createInputSteam", "createInputFile", " createByteSteam", " createInputReader", " createByteStream", "createOutputSteam", " createInputSteam", " createOutputFile", "createInputStream", " createIOFile", " createOutputReader", "createInputReader", "createOutputReader", " createInputFile", " createIOStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputStream", " createIOReader", " createByteReader"], "inFile": ["outStream", "insStream", "sourcefile", "sourceFiles", "insFiles", "incFile", "outFiles", "insfile", "sourceStream", "sourceFile", "outfile", "incStream", "incfile", "inputfile", "incFiles", "infile", "inputFiles", "inputFile", "inputStream", "inFiles", "insFile", "inStream"], "outFile": ["workFile", "outStream", "targetDirectory", "targetStream", "workfile", "workingFile", " outfile", "workingfile", "targetfile", "inputTime", " outStream", "outfile", "outTime", "inTime", "workTime", "outDir", "inputfile", "inDir", "infile", "inputFile", "workDir", "inputDir", " outDirectory", "workingDirectory", "workingStream", "targetFile", "outDirectory"], "k_blockSize": ["k_lockSize", "k_bitSize", "k_blocksLen", "k_byteSize", "k_blocksLength", "k_lineCount", "k_BlockSize", "k_lockLength", "k_blocksSize", "k_byteInfo", "k_blockLength", "k_blockCount", "k_BlockCount", "k_lineSize", "k_byteLen", "k_BlockLength", "k_lockCount", "k_blockCode", "k_blocksCount", "k_BlockCode", "k_lockCode", "k_byteCount", "k_blockLen", "k_blockInfo", "k_byteLength", "k_lockLen", "k_bitCount", "k_bitInfo", "k_lineInfo", "k_byteCode"], "byteCount": [" bytecount", "ByteSize", "flushLength", "flushCount", "characterLen", "flushcount", "byteLength", "bytecount", "byteSize", "characterSize", " byteSum", " byteLen", "ByteSum", "flushSize", "blockLength", "Bytecount", " byteLength", "byteSum", "ByteLength", "characterLength", "ByteCount", "characterCount", "blockSum", "ByteLen", "blockCount", "byteLen", " byteSize", "blockSize"], "buf": ["font", "la", "buffer", "cas", "bytes", "seq", "batch", "bf", "ctx", "queue", "src", "fd", "rc", "brace", "tmp", "feed", "Buffer", "alloc", "loc", "result", "rb", "fb", "buff", "img", "exc", "Buff", "bag", "len", "feat", "bh", "config", "base", "vec", "data", "append", "b", "cv", "cap", "uf", "border", "ucc", "background", "cmd", "flush", "cb"], "ofp": ["OFnp", "oft", "Ofc", "Oft", "ofl", "OFt", "Ofp", "OFc", "oftp", "fort", "OFtp", "ofnp", "ofc", "Ofl", "Oftp", "afl", "afc", "Ofnp", "afp", "afnp", "OFp", "forc", "fortp", "forp", "OFl"], "zos": ["os", "nox", "rons", "zb", "bs", "lins", "zn", "iffs", "zi", "oses", "zer", "forge", "bos", "robe", "outs", "webkit", "za", "iframe", "dylib", "inos", "uz", "ses", "ros", "css", "bitcoin", "ZI", "jas", "nz", "soon", "osi", "zen", "oS", "zers", "ozo", "ops", "utils", "js", "ws", "oda", "ls", "abi", "core", "zy", "zona", "zx", "obs", "cos", "tz", "z", "zyk", "rez", "zar", "ogl", "enos", "zes", "cfg", "kos", "zl", "zag", "zin", "lol", "zon", "owicz", "los", "liquid", "packs", "bes", "modules", "budget", "ZA", "zo", "zig", "zip", "zik", "fits", "obb", "hz", "ossus", "gz", "zh"], "osw": ["issw", "bwo", "eswd", "esow", "esw", "osssw", "ossow", "lswo", "ossw", "esfw", "isw", "isd", "esd", "oswd", "lsw", "oshell", "osfw", "esy", "isnow", "lsws", "bsx", "osy", " osww", "ishell", "bsws", "esww", "osswd", "isy", "bsw", "esnow", "oswo", "essw", "lsx", "bx", "ossd", "osx", " osfw", "ossy", "eshell", "ossnow", "iswd", "osow", "osshell", "osd", "bws", "bswo", "osws", " osow", "osww", "ossfw", "osnow", "ossww"], "bw": [" baw", "fw", "fr", "lbwh", " bz", "abwe", "ow", "bbew", "Bwa", "fwa", "lx", "Bw", "bwd", "abW", "lbwa", "lsw", " bew", "ebw", "abw", "ebW", "bew", "ebwe", "lbz", "ebwd", "fbW", "bsw", "bwu", "bbwh", "fbwe", "lbr", "bbwa", "bbws", "lbsw", "bx", "Bew", "fsw", "lw", "bz", "bwh", "bbaw", " bwu", "bwa", "Bws", "bbwu", "lwa", "bbw", "baw", "bws", "fx", "lbws", " bwa", "fwh", "owu", "owa", " bwh", "bW", "abwd", "lbw", "oaw", " bws", "bbz", "fbwd", "bwe", "fbw", "lbx"], "zot": ["zerot", "Zit", "Zita", " zor", "zita", "Zott", "azita", " zori", "jit", "azit", "azot", "jori", "Zot", "zott", "jot", "Zor", "azott", "zerit", "zerita", "ziot", "azor", "zori", "zeros", "zerori", "zerott", "Ziot", "zor", " ziot", "jos", "aziot"], "ifp": ["Ifi", "ipc", "ipl", " ifb", " ifc", " ifi", "IFc", "ipb", "ipp", " ifl", "ifl", "IFf", "IFl", "iff", "ifc", "IFp", "IFi", " iff", "Iff", "Ifc", "ifb", "Ifp", "IFb", "ifi"], "zis": ["jis", "xis", "zenIS", "xits", "Zis", "ziss", "xais", "zenib", "jits", "zenis", "zeip", " zais", "jit", "zipiss", " zits", "Zip", "zIS", "zais", "jisi", " zisi", "xit", "zipis", " zib", "Ziss", "zip", " zIS", "xisi", "xIS", "zeits", "zits", "zipits", "xib", "zenais", "zeiss", "zisi", "zipip", "Zits", "zeis", "zib"], "isr": ["ISrc", "ISpr", "risr", "ISr", "risrc", "irrc", "ISrs", "ISsr", "isrc", "risrb", "isrb", "isssr", "iscr", "irpr", "rispr", "irr", " isrs", "ispr", "irrb", "ISrb", "isrs", " iscr", "isscr", "IScr", "issrs", "issr", " issr"], "br": ["lr", "r", "gr", "rib", "fr", "bp", "obi", "HR", "ctr", "rs", " dr", "cro", " BR", "bc", "rb", "bl", "ber", "ob", "Br", "bro", "img", "ibl", "shr", "str", "bh", "hr", "sr", " Br", "mr", "ch", "div", "err", "b", "bar", "BR", "obl", "kr", "ibr", "bsp", "arr", "yr", "browser", "body", "ocr", " fr", "tr", "sp"], "zit": ["zeitter", "zeit", "zitter", "zipitter", " zip", "zita", "jic", " zite", "jits", "zeith", "jip", "jit", "zipIT", "zipith", " zits", "jite", "zi", "xit", "jita", "zenits", "zenit", " zi", "zenith", "xi", "zipite", "zip", "xic", "zipita", "zeita", "zite", "ji", "zeits", "zits", "zipits", "zIT", "xith", " zith", "jIT", "zeIT", "zipit", "zipip", "zith", " zic", "zenitter", "zic", "jith"]}}
{"id1": "7372311", "id2": "18613870", "code1": "    private void generateDeviceUUID() {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.update(deviceType.getBytes());\n            md5.update(internalId.getBytes());\n            md5.update(bindAddress.getHostName().getBytes());\n            StringBuffer hexString = new StringBuffer();\n            byte[] digest = md5.digest();\n            for (int i = 0; i < digest.length; i++) {\n                hexString.append(Integer.toHexString(0xFF & digest[i]));\n            }\n            uuid = hexString.toString().toUpperCase();\n        } catch (Exception ex) {\n            RuntimeException runTimeEx = new RuntimeException(\"Unexpected error during MD5 hash creation, check your JRE\");\n            runTimeEx.initCause(ex);\n            throw runTimeEx;\n        }\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 0, "substitutes": {"generateDeviceUUID": ["generateDeviceUuid", "generateDeviceSUUID", "generatedeviceUMD", "generateDeviceUID", "generatedeviceUUID", "generateDeviceSUID", "generatedeviceUID", "generateDeviceCuid", "generateDeviceSUMD", "generateDeviceUMD", "generatedeviceUuid", "generateDeviceCUID", "generateDeviceCID", "generateDeviceSUuid", "generateDeviceCMD"], "md5": ["mand3", " md95", " md512", " MD5", "MD2", " MD3", "md4", "md95", "mem55", "MD55", "mand5", "MD3", "MD5", "mand2", "mand95", "md3", " md55", "md2", " md3", " md75", " MD512", " MD75", "md55", " md4", "MD95", " MD2", "mem3", "MD512", "md512", "mand4", "mem4", "MD4", "md75", " md2", "mem5", "MD75"], "hexString": ["pexArray", " hexArray", "octArray", "formBuffer", " hexStr", "stringList", "octStr", "hexstring", "formString", "hashList", "pexBuffer", "hashFile", "hexArray", " hexFile", "formstring", "stringFile", "stringArray", "hexFile", "stringString", "pexString", "dumpString", "hashString", " hexBuffer", "hashArray", " hexList", "dumpBuffer", "pexstring", "hexBuffer", "hexList", "hexStr", "dumpStr", " hexstring", "octBuffer", "formArray", "dumpArray", "octString"], "digest": ["digense", " digested", "signest", "sumested", "Digense", "signests", "indexests", "codEST", "feedense", "DigEST", "mdest", " digests", "indexester", "digests", "digse", "mdse", " digEST", "mdests", "signse", "sumests", "Digest", "feedested", "codests", "Digester", " digester", "Digests", "digester", "digEST", "sumse", " digense", "indexEST", "indexest", "codester", "mdested", "feedest", "feedester", "digested", "signested", "Digested", "codest", "sumest"], "i": ["r", "ai", "m", "j", "p", "h", "s", "multi", "fi", "slice", "e", "phi", "id", "mu", "ci", "gi", "t", "ui", "length", "zi", "index", "li", "ii", "io", "count", "at", "bi", "end", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "b", "v", "oi", "di", "l", "d", "si", "qi", "uri", "shift", "I", "c"], "uuid": ["suid", "suuid", "suID", "uuID", "uuuid", "euid", "uuids", "uID", "euuid", "uid", "euids", "suids", "uids", "euID"], "runTimeEx": ["runtimeExcept", " runtimeExcept", "RunTimeObj", "runTimesException", "runTimesExcept", "RunTimesExc", "runetimeEx", "RunTimesExcept", "runSizeObj", "RunTimesOut", "runTimeObj", "runTimesExc", "runetimeExcept", "runTypeExc", "runTimeExcept", "runTimesOut", "runtimeExc", "runContextExcept", "runtimeOut", "runTimeOut", " runtimeEx", "RunTimeExcept", "RunTimeOut", "runTimeExc", "runtimeEx", "runSizeExcept", "RunTimesEx", "RunTimesException", "runTimesObj", "runContextObj", " runTimeExcept", "runTypeEx", " runTimeException", "runSizeException", "runTypeException", "runContextException", "runSizeEx", "RunTimesObj", "runTypeOut", " runtimeException", "runTimesEx", "runTimeException", "RunTimeEx", "runContextEx", "RunTimeExc", "RunTimeException", "runetimeException", "runtimeException"]}}
{"id1": "21181542", "id2": "12236729", "code1": "    public boolean deleteRoleType(int id, int namespaceId, boolean removeReferencesInRoleTypes, DTSPermission permit) throws SQLException, PermissionException, DTSValidationException {\n        checkPermission(permit, String.valueOf(namespaceId));\n        boolean exist = isRoleTypeUsed(namespaceId, id);\n        if (exist) {\n            throw new DTSValidationException(ApelMsgHandler.getInstance().getMsg(\"DTS-0034\"));\n        }\n        if (!removeReferencesInRoleTypes) {\n            StringBuffer msgBuf = new StringBuffer();\n            DTSTransferObject[] objects = fetchRightIdentityReferences(namespaceId, id);\n            if (objects.length > 0) {\n                msgBuf.append(\"Role Type is Right Identity in one or more Role Types.\");\n            }\n            objects = fetchParentReferences(namespaceId, id);\n            if (objects.length > 0) {\n                if (msgBuf.length() > 0) {\n                    msgBuf.append(\"\\n\");\n                }\n                msgBuf.append(\"Role Type is Parent of one or more Role Types.\");\n            }\n            if (msgBuf.length() > 0) {\n                throw new DTSValidationException(msgBuf.toString());\n            }\n        }\n        String sqlRightId = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_RIGHT_IDENTITY_REF\");\n        String sqlParent = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE_PARENT_REF\");\n        String sql = getDAO().getStatement(ROLE_TYPE_TABLE_KEY, \"DELETE\");\n        PreparedStatement pstmt = null;\n        boolean success = false;\n        long typeGid = getGID(namespaceId, id);\n        conn.setAutoCommit(false);\n        int defaultLevel = conn.getTransactionIsolation();\n        conn.setTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);\n        try {\n            pstmt = conn.prepareStatement(sqlRightId);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sqlParent);\n            pstmt.setLong(1, typeGid);\n            pstmt.executeUpdate();\n            pstmt.close();\n            pstmt = conn.prepareStatement(sql);\n            pstmt.setLong(1, typeGid);\n            int count = pstmt.executeUpdate();\n            success = (count == 1);\n            conn.commit();\n        } catch (SQLException e) {\n            conn.rollback();\n            throw e;\n        } finally {\n            conn.setTransactionIsolation(defaultLevel);\n            conn.setAutoCommit(true);\n            closeStatement(pstmt);\n        }\n        return success;\n    }\n", "code2": "        private void copy(File inputFile, File outputFile) throws Exception {\n            FileReader in = new FileReader(inputFile);\n            FileWriter out = new FileWriter(outputFile);\n            int c;\n            while ((c = in.read()) != -1) out.write(c);\n            in.close();\n            out.close();\n        }\n", "label": 0, "substitutes": {"deleteRoleType": ["deleteRoleTyp", "deleteResourceTypes", " deleteroleTypes", " deleteRoleTyp", "deleteFunctionType", " deleteRoletype", " deleteRoleTypes", "deleteResourceType", "deleteFunctionTyp", "deleteroleTyp", "deleteResourceTyp", "deleteRoleTypes", "deleteroletype", "deleteFunctionTypes", "deleteroleTypes", " deleteroleType", "deleteResourcetype", "deleteroleType", " deleteroletype", " deleteroleTyp", "deleteFunctiontype", "deleteRoletype"], "id": ["request", "error", "in", "ip", "i", "key", "is", "object", "vid", "oid", "view", "version", "parent", "Id", "section", "mid", "ID", "address", "info", "code", "connection", "ident", "index", "path", "edit", "part", "start", "end", "uid", "url", "f", "sid", "model", "data", "type", "it", "ids", "name", "string", "like", "aid", "rid", "uri", "lock", "pid", "kid", "source", "length"], "namespaceId": ["asentityName", "asentityID", "nspaceId", "namesenceId", "namesentityName", "NamespacedId", "namesaceContext", "namespacedid", "namesaneType", "memberspaceid", "nsaceId", "nspaceID", "namesenceType", "memberspaceId", "namesentityId", "namespacedType", "worksspaceKey", "namesetName", "namesaceInfo", "workspaceid", "namespacesPath", "namespacesName", "workspacesId", "namesspaceInfo", "namespaceInfo", "namesetInfo", "namesspaceKey", "namesetid", "namespacesType", "NamespacedName", "namespaceName", "nsaceInfo", "aspaceID", "NamespacedType", "aspaceId", "namespacePath", "workspaceInfo", "worksspaceId", "namesplaceid", "namespaceid", "namesplaceID", "namesenceContext", "workspacePath", "namespacedPath", "Namespacedid", "membersetId", "namesaceID", "namesaceId", "namesplaceId", "membersetid", "namesaceid", "NamespaceId", "workspacesType", "namespacesID", "namespacedInfo", "nspaceid", "workspaceType", "nsaceid", "workspaceId", "namespacesKey", "worksspaceInfo", "namesentityID", "namesaneId", "namesaneName", "namespacedName", "asentityId", "namespacesContext", "namesentityInfo", "namesaceType", "namespaceKey", "namespacesid", "namesspaceId", "membersetName", "membersetType", "aspaceName", "worksspacePath", "namespaceID", "aspaceInfo", "namesetId", "namesaneid", "namesetID", "namesspacePath", "memberspaceName", "workspacesid", "workspacesContext", "namespacedId", "nsaceID", "Namespaceid", "namespacedKey", "asentityInfo", "nspaceInfo", "NamespaceName", "namesplaceInfo", "namespacesId", "namespaceContext", "namespaceType", "workspaceContext", "workspaceKey", "NamespaceType", "namesenceid", "memberspaceType", "namespacesInfo", "namesetType"], "removeReferencesInRoleTypes": ["removeReferencesedInroletypes", "removeReferencesInRoletypes", "removeReferencesedInroleNames", "removeReferencesedInRoleNames", "removeReferencesFromroleRelations", "removeReferencesedInroleType", "removeReferencesInServiceTypes", "removeReferencesInroleNames", "removeReferencesInServiceNames", "removeReferencesInroleRelations", "removeReferencesInRoleNames", "removeReferencesInRuletypes", "removeReferencesedInRoletypes", "removeReferencesFromroleNames", "removeReferencesInRuleRelations", "removeReferencesInRuleTypes", "removeReferencesFromroleType", "removeReferencesInServiceRelations", "removeReferencesedInRoleTypes", "removeReferencesFromRoleType", "removeReferencesInroletypes", "removeReferencesInRuleType", "removeReferencesFromRoleRelations", "removeReferencesInRuleNames", "removeReferencesedInRoleType", "removeReferencesInRoleType", "removeReferencesFromroleTypes", "removeReferencesFromRoleTypes", "removeReferencesInRoleRelations", "removeReferencesInServiceType", "removeReferencesedInroleTypes", "removeReferencesInroleTypes", "removeReferencesInroleType", "removeReferencesFromRoleNames"], "permit": ["PERmission", "permits", "PerMIT", "permissions", "PERMIT", "perMIT", "Permit", "Permits", "recmit", "PERmit", "permmission", " perit", "permmit", " permits", "permission", "Permissions", "recmission", " permission", "recit", "permmissions", "Perit", "Permission", "permMIT", "PERmissions", "perit", "recmits"], "exist": ["match", "stick", "support", "same", "form", "delete", "write", "purpose", "include", "fail", "check", "apply", "register", "diff", "ident", "index", "icate", "destruct", "fill", "edit", "start", "update", "existent", "except", "know", "keep", "existing", "continue", "draw", "existence", "front", "list", "present", "destroy", "cmp", "cont", "add", "create", "inc", "ist"], "msgBuf": [" msgLundle", "msgCbuf", "msgFBob", "msgFBuf", "msgLUF", "messageAuff", "msgAUF", "msgEBbox", " msgBbuff", " msgFraf", "messageBuf", "messageFbox", "messageAuf", "msgPluff", "messageFuff", "msgDBbuf", "messageBbox", "msgLuf", "msgEBuff", " msgFbuff", "msgAbox", "messageBbuf", "msgFraf", "msgAaf", " msgFuf", "msgBob", "msgBaf", "msgFundle", "messageBuff", "msgFbuf", "msgBUF", " msgLuff", "messageFUF", "messageAUF", "msgEBuf", "msgLob", "msgFuff", "msgAuf", "msgBundle", "messageBUF", "msgBbuf", "msgPlaf", "messageFuf", "msgCuf", "msgFbox", "msgDaf", "msgDBuf", "msgAraf", "msgAbuf", "msgBraf", "messageBob", " msgBbuf", "msgFaf", "msgFUF", "msgFBUF", " msgBaf", "msgLundle", "msgLuff", "msgDuf", " msgFaf", " msgFbuf", "msgPluf", "msgDBuff", "msgEBbuf", "msgFob", "msgAuff", "msgAob", " msgBraf", "msgBbuff", "msgDbuf", "msgFBuff", "msgPlundle", " msgLuf", "msgFbuff", "msgCob", "msgBbox", "messageFbuf", " msgBuff", "msgDBUF", " msgFuff", "msgCuff", "messageAbuf", "msgFuf", " msgBundle", " msgLaf", "msgBuff", "msgLaf", "msgDuff", "msgAbuff", "messageFob"], "objects": ["items", "locks", "os", "cats", "children", "obj", "points", "models", "people", "files", "types", "notes", "object", "boxes", "phones", "products", "cells", "archives", "projects", "links", "features", "properties", "lines", "keys", "ks", "obs", "owners", "jobs", "images", "resources", "results", "frames", "apps", "roots", "members", "kids", "oids", "classes", "relations", "actions", "articles", "agents", "values", "pins", "groups", "blocks", "organisms", "users", "parents", "ins", "bugs", "ops", "ids", "names", "parts", "pps", "archs", "plugins"], "sqlRightId": ["sqlRid", "sqlRightRef", "SQLRestid", "sqlLeftid", "SQLRightID", "sqlRId", "SQLRightid", "sqlrightid", " sqlrightType", "SQLRestID", "sqlLeftType", "sqlRestID", "sqlRestRef", " sqlrightid", "sqlRightID", "sqlRRef", "sqlRightPoint", "sqlRestid", "sqlrightType", "sqlLeftId", "SQLRightRef", " sqlRightPoint", "sqlRestId", " sqlrightId", " sqlRightType", "SQLRightId", "sqlLeftPoint", "sqlrightId", "sqlRightType", " sqlRightid", " sqlrightPoint", "sqlRID", "SQLRestRef", "SQLRestId", "sqlRightid", "sqlrightPoint"], "sqlParent": [" sqlparent", "suParents", "suRoot", "suParent", "sqlRoot", "sqlparent", "qlRoot", "qlParent", " sqlRoot", "qlParents", " sqlParents", "suparent", "sqlParents", "qlparent"], "sql": [" session", "where", "db", "error", "sl", "msg", " db", " params", "delete", "s", " SQL", " msg", "SQL", "conn", "replace", "acl", "operation", "description", "link", "url", "update", "session", "log", "dl", "ql", " url", "select", "repl"], "pstmt": ["New", "pctm", " pndbl", "Security", "s", "pctmr", "pstmb", "pmtmb", "pstmd", "pctmb", "pctmt", "pstrtr", "pStm", " psttr", "this", "pStmt", "Pctct", "pstatmr", " pStmt", "Pstct", "postmr", "pstrct", "pfmd", " pstnt", "pstm", "All", "pstatmt", " pStm", "Pstmd", "The", "pstrmt", "pndmb", "postnt", "Delete", " pndmb", "pfct", "pstrm", "pstbl", "Pstmt", "pmtbl", "pmtmt", "psttr", "pctmd", " pstmr", " pSttr", "Pctmd", "pfmt", "pstmr", " postmr", "delete", "pctct", "pSttr", "pndbl", "pftr", " pstbl", "Psttr", "postct", "pndct", "pstatct", "Pctmt", "Error", " postnt", " postct", "pctbl", "pctnt", "add", " pndct", "pcttr", "pstatnt", "pStct", "pndmt", " postmt", "pstct", "pmtct", "pstnt", "_", " pstm", "pmtmd", "pmttr", " pStct", "Pcttr", " pndmt", " pstmb", "postmt", " pstct"], "typeGid": ["typeGVID", "typeGoid", "TypeGmin", "TypeCmin", "typeGVid", "typeGUoid", "typeWname", "typeWid", "TypeCname", "typeGUid", "linkGname", "typeWmin", "TypeCID", "TypeGname", "linkGVoid", "linkGID", "typeAccid", "typegid", "linkGid", "typeGUID", "typeGUname", "typeAccmin", "typegname", "linkGoid", "linkGVid", "TypeGid", "typeAccID", "typeGname", "typegID", "typegoid", "typeGmin", "typeCID", "typeAccname", "typeCname", "linkGVname", "TypeCid", "typeGVname", "typeWID", "TypeGID", "linkGVID", "typeCmin", "typeGID", "typeGVoid", "typeCid"], "defaultLevel": ["configCl", "DefaultMode", "DefaultCl", "DefaultDepth", "defaultMode", " defaultCl", " defaultMode", " defaultDepth", "configMode", "DefaultLevel", "configLevel", "defaultDepth", "configDepth", "defaultCl"], "success": ["error", "match", "progress", "accept", "batch", "serial", "fail", "complete", "reg", "replace", "result", "Success", "failed", "submit", "response", "successful", "message", "results", "resp", "successfully", "warning", "data", "test", "status", "continue", "roll", "launch"]}}
{"id1": "160739", "id2": "16673769", "code1": "    public BufferedWriter createOutputStream(String inFile, String outFile) throws IOException {\n        int k_blockSize = 1024;\n        int byteCount;\n        char[] buf = new char[k_blockSize];\n        File ofp = new File(outFile);\n        ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(ofp));\n        zos.setMethod(ZipOutputStream.DEFLATED);\n        OutputStreamWriter osw = new OutputStreamWriter(zos, \"ISO-8859-1\");\n        BufferedWriter bw = new BufferedWriter(osw);\n        ZipEntry zot = null;\n        File ifp = new File(inFile);\n        ZipInputStream zis = new ZipInputStream(new FileInputStream(ifp));\n        InputStreamReader isr = new InputStreamReader(zis, \"ISO-8859-1\");\n        BufferedReader br = new BufferedReader(isr);\n        ZipEntry zit = null;\n        while ((zit = zis.getNextEntry()) != null) {\n            if (zit.getName().equals(\"content.xml\")) {\n                continue;\n            }\n            zot = new ZipEntry(zit.getName());\n            zos.putNextEntry(zot);\n            while ((byteCount = br.read(buf, 0, k_blockSize)) >= 0) bw.write(buf, 0, byteCount);\n            bw.flush();\n            zos.closeEntry();\n        }\n        zos.putNextEntry(new ZipEntry(\"content.xml\"));\n        bw.flush();\n        osw = new OutputStreamWriter(zos, \"UTF8\");\n        bw = new BufferedWriter(osw);\n        return bw;\n    }\n", "code2": "    @Override\n    public void Start() {\n        try {\n            Enumeration<URL> resources = Configurator.class.getClassLoader().getResources(IOCContainer.GetApplicationName() + \".config\");\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                if (Logger.logger.isDebugEnabled()) {\n                    Logger.logger.debug(\"Loading '\" + url + \"'\");\n                }\n                JSONValue configFileContents = JSONValue.Decode(url.openStream(), url.toString());\n                if (configFileContents instanceof JSONObjectValue) {\n                    for (Configurable configurable : IOCContainer.LookupAll(Configurable.class)) {\n                        JSONValue jsonData = ((JSONObjectValue) configFileContents).GetProperty(configurable.GetConfigSectionName());\n                        if (jsonData != null) {\n                            if (Logger.logger.isDebugEnabled()) {\n                                Logger.logger.debug(\"Configurging \" + configurable.getClass() + \" with '\" + jsonData.Encode());\n                            }\n                            try {\n                                configurable.Configure(jsonData);\n                            } catch (Throwable th1) {\n                                Logger.logger.error(\"Caught throwable while configuring \" + configurable.getClass() + \":\" + th1.getMessage() + \". IGNORED.\", th1);\n                                Logger.logger.error(\"[Continued]. Config Data was:\" + jsonData.Encode());\n                            }\n                        }\n                    }\n                } else {\n                    Logger.logger.error(\"'\" + url + \"' does not contain a json object. Skipping and looking for other applciation.config files in classpath ...\");\n                }\n            }\n        } catch (Throwable th) {\n            throw new RuntimeException(\"Exception while attempting to load application.config:'\" + th.getMessage() + \"'\", th);\n        }\n    }\n", "label": 0, "substitutes": {"createOutputStream": [" createIOSteam", "createInputSteam", "createInputFile", " createByteSteam", " createInputReader", " createByteStream", "createOutputSteam", " createInputSteam", " createOutputFile", "createInputStream", " createIOFile", " createOutputReader", "createInputReader", "createOutputReader", " createInputFile", " createIOStream", " createOutputSteam", " createByteFile", "createOutputFile", " createInputStream", " createIOReader", " createByteReader"], "inFile": ["outStream", "insStream", "sourcefile", "sourceFiles", "insFiles", "incFile", "outFiles", "insfile", "sourceStream", "sourceFile", "outfile", "incStream", "incfile", "inputfile", "incFiles", "infile", "inputFiles", "inputFile", "inputStream", "inFiles", "insFile", "inStream"], "outFile": ["workFile", "outStream", "targetDirectory", "targetStream", "workfile", "workingFile", " outfile", "workingfile", "targetfile", "inputTime", " outStream", "outfile", "outTime", "inTime", "workTime", "outDir", "inputfile", "inDir", "infile", "inputFile", "workDir", "inputDir", " outDirectory", "workingDirectory", "workingStream", "targetFile", "outDirectory"], "k_blockSize": ["k_lockSize", "k_bitSize", "k_blocksLen", "k_byteSize", "k_blocksLength", "k_lineCount", "k_BlockSize", "k_lockLength", "k_blocksSize", "k_byteInfo", "k_blockLength", "k_blockCount", "k_BlockCount", "k_lineSize", "k_byteLen", "k_BlockLength", "k_lockCount", "k_blockCode", "k_blocksCount", "k_BlockCode", "k_lockCode", "k_byteCount", "k_blockLen", "k_blockInfo", "k_byteLength", "k_lockLen", "k_bitCount", "k_bitInfo", "k_lineInfo", "k_byteCode"], "byteCount": [" bytecount", "ByteSize", "flushLength", "flushCount", "characterLen", "flushcount", "byteLength", "bytecount", "byteSize", "characterSize", " byteSum", " byteLen", "ByteSum", "flushSize", "blockLength", "Bytecount", " byteLength", "byteSum", "ByteLength", "characterLength", "ByteCount", "characterCount", "blockSum", "ByteLen", "blockCount", "byteLen", " byteSize", "blockSize"], "buf": ["font", "la", "buffer", "cas", "bytes", "seq", "batch", "bf", "ctx", "queue", "src", "fd", "rc", "brace", "tmp", "feed", "Buffer", "alloc", "loc", "result", "rb", "fb", "buff", "img", "exc", "Buff", "bag", "len", "feat", "bh", "config", "base", "vec", "data", "append", "b", "cv", "cap", "uf", "border", "ucc", "background", "cmd", "flush", "cb"], "ofp": ["OFnp", "oft", "Ofc", "Oft", "ofl", "OFt", "Ofp", "OFc", "oftp", "fort", "OFtp", "ofnp", "ofc", "Ofl", "Oftp", "afl", "afc", "Ofnp", "afp", "afnp", "OFp", "forc", "fortp", "forp", "OFl"], "zos": ["os", "nox", "rons", "zb", "bs", "lins", "zn", "iffs", "zi", "oses", "zer", "forge", "bos", "robe", "outs", "webkit", "za", "iframe", "dylib", "inos", "uz", "ses", "ros", "css", "bitcoin", "ZI", "jas", "nz", "soon", "osi", "zen", "oS", "zers", "ozo", "ops", "utils", "js", "ws", "oda", "ls", "abi", "core", "zy", "zona", "zx", "obs", "cos", "tz", "z", "zyk", "rez", "zar", "ogl", "enos", "zes", "cfg", "kos", "zl", "zag", "zin", "lol", "zon", "owicz", "los", "liquid", "packs", "bes", "modules", "budget", "ZA", "zo", "zig", "zip", "zik", "fits", "obb", "hz", "ossus", "gz", "zh"], "osw": ["issw", "bwo", "eswd", "esow", "esw", "osssw", "ossow", "lswo", "ossw", "esfw", "isw", "isd", "esd", "oswd", "lsw", "oshell", "osfw", "esy", "isnow", "lsws", "bsx", "osy", " osww", "ishell", "bsws", "esww", "osswd", "isy", "bsw", "esnow", "oswo", "essw", "lsx", "bx", "ossd", "osx", " osfw", "ossy", "eshell", "ossnow", "iswd", "osow", "osshell", "osd", "bws", "bswo", "osws", " osow", "osww", "ossfw", "osnow", "ossww"], "bw": [" baw", "fw", "fr", "lbwh", " bz", "abwe", "ow", "bbew", "Bwa", "fwa", "lx", "Bw", "bwd", "abW", "lbwa", "lsw", " bew", "ebw", "abw", "ebW", "bew", "ebwe", "lbz", "ebwd", "fbW", "bsw", "bwu", "bbwh", "fbwe", "lbr", "bbwa", "bbws", "lbsw", "bx", "Bew", "fsw", "lw", "bz", "bwh", "bbaw", " bwu", "bwa", "Bws", "bbwu", "lwa", "bbw", "baw", "bws", "fx", "lbws", " bwa", "fwh", "owu", "owa", " bwh", "bW", "abwd", "lbw", "oaw", " bws", "bbz", "fbwd", "bwe", "fbw", "lbx"], "zot": ["zerot", "Zit", "Zita", " zor", "zita", "Zott", "azita", " zori", "jit", "azit", "azot", "jori", "Zot", "zott", "jot", "Zor", "azott", "zerit", "zerita", "ziot", "azor", "zori", "zeros", "zerori", "zerott", "Ziot", "zor", " ziot", "jos", "aziot"], "ifp": ["Ifi", "ipc", "ipl", " ifb", " ifc", " ifi", "IFc", "ipb", "ipp", " ifl", "ifl", "IFf", "IFl", "iff", "ifc", "IFp", "IFi", " iff", "Iff", "Ifc", "ifb", "Ifp", "IFb", "ifi"], "zis": ["jis", "xis", "zenIS", "xits", "Zis", "ziss", "xais", "zenib", "jits", "zenis", "zeip", " zais", "jit", "zipiss", " zits", "Zip", "zIS", "zais", "jisi", " zisi", "xit", "zipis", " zib", "Ziss", "zip", " zIS", "xisi", "xIS", "zeits", "zits", "zipits", "xib", "zenais", "zeiss", "zisi", "zipip", "Zits", "zeis", "zib"], "isr": ["ISrc", "ISpr", "risr", "ISr", "risrc", "irrc", "ISrs", "ISsr", "isrc", "risrb", "isrb", "isssr", "iscr", "irpr", "rispr", "irr", " isrs", "ispr", "irrb", "ISrb", "isrs", " iscr", "isscr", "IScr", "issrs", "issr", " issr"], "br": ["lr", "r", "gr", "rib", "fr", "bp", "obi", "HR", "ctr", "rs", " dr", "cro", " BR", "bc", "rb", "bl", "ber", "ob", "Br", "bro", "img", "ibl", "shr", "str", "bh", "hr", "sr", " Br", "mr", "ch", "div", "err", "b", "bar", "BR", "obl", "kr", "ibr", "bsp", "arr", "yr", "browser", "body", "ocr", " fr", "tr", "sp"], "zit": ["zeitter", "zeit", "zitter", "zipitter", " zip", "zita", "jic", " zite", "jits", "zeith", "jip", "jit", "zipIT", "zipith", " zits", "jite", "zi", "xit", "jita", "zenits", "zenit", " zi", "zenith", "xi", "zipite", "zip", "xic", "zipita", "zeita", "zite", "ji", "zeits", "zits", "zipits", "zIT", "xith", " zith", "jIT", "zeIT", "zipit", "zipip", "zith", " zic", "zenitter", "zic", "jith"]}}
{"id1": "7981642", "id2": "5049453", "code1": "    @Override\n    public void update(String mail, String email, String pwd, String firstname, String lastname) throws NamingException, NoSuchAlgorithmException, UnsupportedEncodingException {\n        jndiManagerConnection connection = new jndiManagerConnection();\n        Attributes attrs = new BasicAttributes();\n        attrs.put(\"sn\", lastname);\n        attrs.put(\"givenName\", firstname);\n        attrs.put(\"cn\", firstname + \" \" + lastname);\n        if (!pwd.isEmpty()) {\n            MessageDigest sha = MessageDigest.getInstance(\"md5\");\n            sha.reset();\n            sha.update(pwd.getBytes(\"utf-8\"));\n            byte[] digest = sha.digest();\n            String hash = Base64.encodeBase64String(digest);\n            attrs.put(\"userPassword\", \"{MD5}\" + hash);\n        }\n        DirContext ctx = connection.getLDAPDirContext();\n        ctx.modifyAttributes(\"mail=\" + mail + \",\" + dn, DirContext.REPLACE_ATTRIBUTE, attrs);\n        if (!mail.equals(email)) {\n            String newName = \"mail=\" + email + \",\" + dn;\n            String oldName = \"mail=\" + mail + \",\" + dn;\n            ctx.rename(oldName, newName);\n        }\n    }\n", "code2": "    private BingResponse queryBing(BingRequest request) throws BingException {\n        try {\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Searching through bing...\");\n            }\n            String query = request.getQuery();\n            query = URLEncoder.encode(query, \"UTF-8\");\n            URL url = new URL(\"http://api.bing.net/json.aspx?\" + \"AppId=\" + request.getAppId() + \"&Query=\" + query + \"&Sources=\" + request.getType().toString());\n            URLConnection connection = null;\n            if (useProxy) {\n                if (proxyType == null) {\n                    throw new BingException(\"Please set a proxy first before trying to connect through a proxy\", new Throwable());\n                }\n                connection = ProxyWrapper.getURLConnection(url.toString(), proxyType.toString(), proxyHost, proxyPort);\n            } else {\n                connection = new URL(url.toString()).openConnection();\n            }\n            String line;\n            StringBuilder builder = new StringBuilder();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));\n            while ((line = reader.readLine()) != null) {\n                builder.append(line);\n            }\n            String response = builder.toString();\n            ResponseParser parser = new ResponseParser();\n            parser.getError(response);\n            return parser.getResults(response);\n        } catch (MalformedURLException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        } catch (IOException e) {\n            logger.error(e);\n            throw new ConnectionException(\"Could not connect to host\", e);\n        }\n    }\n", "label": 0, "substitutes": {"update": ["h", "save", "up", "key", "delete", "init", "user", "Update", "write", "copy", "address", "check", "register", "replace", "apply", "updated", "sum", "UPDATE", "change", "send", "edit", "build", "post", "end", "url", "exec", "set", "login", "data", "u", "append", "put", "text", "auth", "password", "and", "setup", "insert", "push", "add", "sign", "create", "config"], "mail": ["Email", "gmail", "ip", "m", "hello", "fax", "msg", "html", "ul", "label", "host", "phone", "old", "view", "proxy", "user", "id", "office", "server", "address", "md", "group", "dial", "message", "xml", "date", "value", "file", "dir", "ge", "url", "alt", "login", "model", "zip", "contact", "local", "text", "name", "company", "mails", "password", "string", "front", "folder", "uri", "lock", "gal", "Mail", "source", "who", "username"], "email": ["Email", "gmail", "ip", "eu", "ail", "note", "n", "fax", "element", "hello", "old", "class", "phone", "cn", "el", "host", "enter", "id", "office", "online", "archive", "server", "address", "md", "home", "inet", "info", "dn", "li", "message", "xml", "line", "description", "wd", "cdn", "file", "dir", "en", "url", "alt", "login", "zip", "model", "nick", "log", "text", "name", "mails", "password", "folder", "addr", "uri", "Mail", "username"], "pwd": [" pws", "ppwd", "hwa", " pwa", "Pwt", "Ppass", "ppass", "cpws", "ppwh", "hwd", "Pwa", " pwt", "pppass", " ppassword", "cpWD", "Pwd", "hWD", "pws", "pppassword", "Pwh", "Pws", "pwt", " ppass", " pwh", "pwa", "cpwd", "hpass", " pWD", "Ppassword", "pWD", "pwh", "cpwt", "PWD", "ppassword"], "firstname": ["lastnames", "lastuser", "lastkey", "newname", "caseemail", " firstemail", "caseName", " firstName", "newnames", " firstuser", " firstpass", "lastName", "firstpass", "firstuser", "lastpass", "casename", "firstkey", " firstkey", " firstnames", "casepass", "hostkey", "firstnames", "firstName", "hostname", "hostemail", "newuser", "firstemail", "lastemail", "hostName"], "lastname": [" lastn", "lastnames", "fullName", "fullday", "lastn", "lastday", "secondkey", "secondName", "firstday", "fulln", "lastName", "firstkey", "firstn", " lastday", " lastkey", " lastaddress", " lastName", "firstnames", "firstName", "secondaddress", "firstaddress", "fullnames", "secondname", "fullname", "lastkey", " lastnames", "lastaddress"], "connection": ["db", "sc", "client", "connect", "ca", "Conn", "h", "m", "creator", "relation", "cc", "object", "management", "context", "lc", "cf", "handler", "directory", "server", "conn", "bc", "nc", "graph", "index", "response", "pool", "manager", "con", "function", "connected", "this", "session", "system", "b", "database", "application", " Connection", "document", "di", "ion", "communication", "Connection", "config", "c", "condition"], "attrs": ["attributes", "Attars", " attRS", "atRS", "attr", " attr", "atps", "addributes", "atributes", "addRs", "atacts", "Attrs", "addRS", "addks", "matrs", "attps", "attks", "attRS", " attRs", "attars", " attars", "matps", "Attras", "Attr", "Attps", "addps", "atars", "matars", "attacts", "atrs", "matributes", " attks", "Attributes", " attps", " attributes", "addras", "atr", "attras", "attRs", "atks", "addars", "addr", "atras", "addrs", "Attacts", "AttRs", " attacts"], "sha": ["ha", "mac", "mm", "la", "ca", "h", " SHA", "lambda", "alpha", "asha", "pa", "sche", "ga", "eta", "pg", "ya", "sa", "md", "sh", "alias", "ma", "sum", "va", "a", "acl", "ema", "SHA", "pi", "sm", "base", "ami", "HA", "wa", "ka", "volume", "hi", "shi", "password", "si", "ua", "meta", "da", "na"], "digest": [" digested", "mdester", "tagester", "modests", "DigEST", "mdgest", "mdest", "digcode", " digests", "Digcode", "diggest", "Diged", "digests", "modEST", " digEST", "Digest", "tagested", "Digester", " digester", "modest", "Digests", "digester", " digcode", "digEST", "moded", " diggest", "mdested", "tagest", "diged", " diged", "digested", "Diggest", "Digested", "tagcode"], "hash": ["mac", "ha", "image", "match", "h", "dig", "ag", "html", "ash", "block", "key", "user", "version", "json", "sh", "code", "sum", "array", "message", "rh", "raw", "value", "Hash", "cover", "build", "bh", "url", "enc", "base", "her", "secret", "auth", "bin", "password", "body", "kh", "hed", "hex"], "ctx": ["fw", "sc", "client", "ca", "cas", "ck", "tx", "cci", "cp", "rc", "cc", "cn", "cs", "context", "cr", "pkg", "lc", "cf", "ci", "cb", "conn", "loc", "cu", "bc", " cx", "cca", "cm", "xc", " c", "qa", "tc", " rc", "ctrl", "hw", "conv", "vc", "sq", "jp", "cv", " conn", "cl", "ct", "pc", "anc", "mc", " cs", " context", "cmp", "Context", "config", "c"], "newName": ["NewAddress", "oldname", "NewName", " newEmail", "oldEmail", "NewEmail", "newname", " newAddress", "oldAddress", " newname", "newEmail", "Newname", "newAddress"], "oldName": ["oldPath", "OldAddress", "origPath", "oldHome", " oldname", "OldName", "origEmail", "newHome", " oldPath", "oldEmail", "oldAddress", "newEmail", "origname", "newAddress", "oldname", "OldPath", " oldHome", " oldEmail", "OldHome", "OldEmail", " oldAddress", "Oldname", "origName"]}}
{"id1": "12085127", "id2": "15362793", "code1": "    public final void navigate(final URL url) {\n        try {\n            EncogLogging.log(EncogLogging.LEVEL_INFO, \"Navigating to page:\" + url);\n            final URLConnection connection = url.openConnection();\n            final InputStream is = connection.getInputStream();\n            navigate(url, is);\n            is.close();\n        } catch (final IOException e) {\n            EncogLogging.log(EncogLogging.LEVEL_ERROR, e);\n            throw new BrowseError(e);\n        }\n    }\n", "code2": "    public static String ReadURL(URL url, boolean textonly) {\n        try {\n            URLConnection uconn = url.openConnection();\n            Object ucont = uconn.getContent();\n            if (ucont instanceof InputStream) return ReadInputStream((java.io.InputStream) ucont, textonly); else return \"\" + ucont;\n        } catch (java.io.IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"navigate": ["ivigation", "navigating", " Navigate", " Navigation", "Navig", "Navigation", "avigating", "ajigating", "avigate", "ajig", "ivigate", "avigated", "Navigated", " Navig", "ajigate", "ivigating", "Navigate", "navig", " Navigating", "ivigated", "Navigating", "avigation", "navigation", "navigated", "ajigation"], "url": ["image", "job", "r", "blog", "position", "client", "fr", "service", "sl", "obj", "element", "html", "entry", "host", "i", "object", "feed", "user", "bug", "e", "route", "page", "id", "server", "rule", "address", "http", "location", "URL", "resource", "ssl", "file", "build", "str", "link", "f", "Url", "api", "base", "gl", "org", "article", "ll", "l", "plugin", "follow", "web", "uri", "c", "source", "config", "www", "account"], "connection": ["position", "client", "connect", "ie", "i", "socket", "proxy", "context", "character", "page", "ci", "cf", "lc", "coll", "server", "handler", "conn", "loc", "open", "or", "bc", "http", "response", "resource", "io", "con", "which", "link", "connected", "channel", "unit", "wrapper", "session", "b", "database", "application", "l", "communication", "Connection", "uri", "c", "condition"], "is": ["lis", "ai", "ip", "os", "mis", "Is", "in", "ils", "us", "bis", "iso", "isl", "isa", "i", "bs", "cs", "s", "its", "was", "ib", "il", "ci", "isi", "es", "ris", "isu", "gets", "IS", "ui", "info", "iss", "ios", "isc", "ii", "io", "ir", "iris", "ais", "abs", "fs", "serv", "api", "im", "ins", "ops", "as"]}}
{"id1": "13852596", "id2": "7468819", "code1": "    public void execute() {\n        try {\n            if (methods == null) {\n                return;\n            }\n            List<Resource> resources = new ArrayList<Resource>();\n            for (Iterator<Resource> i = classFiles.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                if (!classFile.getName().equals(CALLSTACK_FILE)) {\n                    try {\n                        InputStream inputStream = classFile.getInputStream();\n                        ClassReader reader = new ClassReader(inputStream);\n                        reader.accept(new MethodAnalyzer(), 0);\n                        resources.add(classFile);\n                        oldSize += classFile.getSize();\n                    } catch (IllegalStateException e) {\n                    }\n                }\n            }\n            for (Iterator<Resource> i = resources.iterator(); i.hasNext(); ) {\n                final Resource classFile = i.next();\n                try {\n                    InputStream inputStream = classFile.getInputStream();\n                    ClassReader reader = new ClassReader(inputStream);\n                    ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n                    if (!classFile.getName().startsWith(CALLSTACK_FILE.substring(0, CALLSTACK_FILE.indexOf('.')))) {\n                        reader.accept(new MethodInjector(writer), 0);\n                        byte[] b = writer.toByteArray();\n                        inputStream.close();\n                        OutputStream outputStream = classFile.getOutputStream();\n                        outputStream.write(b);\n                        outputStream.close();\n                        injectedClasses++;\n                    }\n                } catch (IllegalStateException e) {\n                }\n                newSize += classFile.getSize();\n            }\n            File classFile = new File(classFiles.getDir(), CALLSTACK_FILE);\n            if (!classFile.exists()) {\n                throw new BuildException(\"Missing net.yura.mobile.logging.CallStack class\");\n            }\n            InputStream inputStream = new FileInputStream(classFile);\n            ClassReader reader = new ClassReader(inputStream);\n            ClassWriter writer = new ClassWriter(reader, ClassWriter.COMPUTE_MAXS);\n            try {\n                reader.accept(new PushMethodGenerator(writer), 0);\n            } finally {\n                inputStream.close();\n            }\n            byte[] b = writer.toByteArray();\n            inputStream.close();\n            OutputStream outputStream = new FileOutputStream(classFile);\n            outputStream.write(b);\n            outputStream.close();\n            log(injectedClasses + \" classes injected\");\n            log((injectedMethods * 100) / Math.max(1, totalMethods) + \"% of methods injected\");\n            log((100 - ((oldSize * 100) / newSize)) + \"% code size increase\");\n        } catch (IOException e) {\n            log(e, 0);\n        }\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"execute": ["process", "all", "transfer", "load", "install", "parse", "copy", "server", "run", " invoke", "apply", "register", "Exec", "evaluate", "handle", "code", "submit", "report", "start", " perform", "exec", "test", "call", "invoke", "ute", "create"], "resources": ["items", "locks", "flows", "scripts", "models", "files", "types", "strings", "Resources", "cells", "archives", "events", "maps", "workers", "projects", "chains", "features", "objects", "stores", "writers", "issues", "resource", "reports", "services", "images", "params", "results", "apps", "roots", "ions", "classes", "relations", "pages", "series", "works", "rates", "users", "groups", "rings", "ids", "stars", "thumbnails", "rules", "plugins"], "i": ["ai", "ip", "wei", "iri", "j", "h", "ic", "p", "ie", "eni", "is", "s", "multi", "e", "phi", "abi", "mu", "ci", "gi", "id", "isi", "cli", "ui", "info", "ori", "li", "ii", "io", "vi", "iu", "ir", "esi", "ini", "we", "bi", "pi", "f", "o", "xi", "ami", "ti", "k", "ri", "u", "ani", "v", "oi", "di", "l", "hi", "si", "qi", "uri", "I"], "classFile": ["serviceFile", "objectfile", "staticFile", "ruleFiles", "sessionFiles", "CLASSFiles", "basefile", "fileFile", "CLASSImage", "sessionFile", "customFile", "ClassPath", "connectionFile", "ClassEntry", "classClass", "classPage", "connectionStream", "finalFile", " classFiles", "customFiles", "baseFile", "lassClass", "sessionEntry", "ClassDirectory", "sessionFactory", "ClassDir", "ruleLine", "connectionFiles", "finalfile", " classFILE", "ClassFilename", "ClassLine", "classFiles", " classStream", "CLASSDirectory", "classesFiles", "classesfile", "CLASSPage", "ClassFactory", " classEntry", "Classfile", "packEntry", "serviceLine", "classFactory", "ClassGlobal", "ClassImage", "serviceFILE", "finalFILE", "lassFile", "classGlobal", "classLine", "classEntry", " classPage", " classPath", "ClassFile", "CLASSfile", "objectDir", "fileDirectory", "packFILE", "classDir", "staticfile", "ClassPage", " classGlobal", " classDir", "lassGlobal", "classesFile", "ruleFile", "classFilename", "objectFiles", "sessionfile", "classLoader", "classesPath", "ClassFiles", " classFilename", "classDirectory", "packfile", "CLASSEntry", "objectFile", " classfile", "classPath", "CLASSLoader", "fileLoader", "ClassStream", "classStream", " classFactory", "baseUrl", "fileFiles", "sessionFILE", "staticFILE", "classUrl", "CLASSFILE", "baseFILE", "servicefile", "CLASSUrl", "fileLine", "finalUrl", "CLASSLine", "staticLine", " classLine", "filefile", " classClass", "classImage", "CLASSFile", "classfile", "ClassFILE", "customFILE", "classFILE", " classLoader", "customEntry", "packFile", "lassFiles", "fileImage", "connectionfile", "ClassClass", "ruleFilename"], "inputStream": ["outputContext", "InputFile", "rawSteam", "uploadStream", "initStreamer", "initSteam", "importSteam", "inputSw", "activeStream", "outputstream", "activeStreamer", "inputContext", "childContext", "outputFile", "Inputstream", "initstream", " inputSteam", "uploadSw", "rawStream", "uploadFile", "outputStreamer", "initStream", "activeSteam", " inputStreamer", "importstream", "importStreamer", " inputstream", "InputSteam", "importStream", "outputReader", "outputSteam", "InputSw", "rawStreamer", "rawFile", "InputStreamer", " inputFile", "inputSteam", "childstream", "InputStream", " inputContext", "childStream", "inputReader", "binarySteam", " inputReader", "binaryFile", "inputFile", "binaryStreamer", "binaryStream", "outputSw", "uploadstream", "childReader", "activestream", "inputStreamer", "inputstream"], "reader": ["request", "client", "buffer", "ner", "worker", "sync", "Reader", "entry", "stream", "rer", "author", "key", "rc", "context", "input", "owner", "layer", "reflect", "ee", "ger", "rx", "copy", "handler", "server", "Writer", "per", "ler", "or", "dr", "writers", "http", "inner", "editor", "resource", "report", "io", "war", "rr", "manager", "keeper", "row", "reading", "book", "director", "rar", "riter", "iter", "wrapper", "builder", "ri", "re", "loader", "system", "er", "oder", "arser", "driver", "parser", "seed", "draft", "read", "shared", "source", "right"], "oldSize": ["OldSize", "prevSc", "prevLength", " oldSc", "prevSize", "OldSc", " oldName", " oldLength", "OldLength", "oldName", "OldName", "oldLength", "oldSc", "prevName"], "writer": ["r", "wire", "buffer", "service", "ner", "creator", "worker", "Reader", "element", "author", "object", "write", "ee", "e", "maker", "handler", "Writer", "written", "child", "ler", "format", "writers", "dc", "inner", "editor", "war", "resource", "io", "word", "index", "report", "manager", "row", "wr", "director", "riter", "rw", "iter", "winner", "engine", "wrapper", "builder", "data", "wer", "loader", "her", "player", "er", "token", "oder", "w", "document", "driver", "writ", "string", "parser", "draft", "read", "writing", "widget", "walker"], "b": ["r", "db", "buffer", "m", "h", "p", "g", "br", "ab", "lb", "object", "emb", "bb", "e", "boot", "rb", "fb", "a", "be", "ob", "pb", "B", "bd", "f", "eb", "binary", "null", "base", "abc", "k", "u", "bar", "ba", "w", "l", "bin", "d", "orb", "c"], "outputStream": ["inputView", "outStream", "outputstream", "outStreamer", "protectedStream", "OutputStream", "dataStreamer", "OutputStreamer", " outputstream", " outputSteam", "outputStreamer", "outstream", "inputStreamer", "outputSteam", "dataSteam", "inputContainer", "protectedstream", "OutputView", "inputSteam", "dataStream", " outputView", " outputStreamer", "Outputstream", "protectedStreamer", "OutputSteam", "outSteam", "dataContainer", "protectedSteam", " outputContainer", "outputView", "outputContainer", "inputstream"], "injectedClasses": ["injectedclassies", "injectedWrities", "injectedClassies", "injectionclassites", "injectedProjectites", "injectionclassies", "injectionClassies", "injectedProjecties", "injectionclasses", "injectedclasses", "injectionClassites", "injectionClasses", "injectionclasss", "injectedclasss", "injectedProjects", "injectionClasss", "injectedWrites", "injectedClasss", "injectedWritites", "injectedProjectes", "injectedClassites", "injectedclassites", "injectedWrits"], "newSize": ["newFontSize", " newStorage", "finalSize", "NewLength", "NewStorage", "NewSize", "NewFontSize", " newFontSize", "newLength", "finalStorage", "finalLength", "newStorage", "finalFontSize", " newLength"]}}
{"id1": "15510198", "id2": "3945236", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public static void hash(String... plainTexts) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            for (String plainText : plainTexts) md.update(plainText.getBytes());\n            byte b[] = md.digest();\n            int i;\n            StringBuffer buf = new StringBuffer(\"\");\n            for (int offset = 0; offset < b.length; offset++) {\n                i = b[offset];\n                if (i < 0) i += 256;\n                if (i < 16) buf.append(\"0\");\n                buf.append(Integer.toHexString(i));\n            }\n            String str = buf.toString();\n            System.out.println(\"result: \" + buf.toString());\n            System.out.println(\"result: \" + buf.toString().substring(8, 24));\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n    }\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "newParser", "constructReader", "buildHandler", "newReader", "makeParser", "makeReader", "constructWriter", "makeWriter", "constructHandler", "buildWriter", "makeHandler", "newHandler", "newWriter", "buildReader"], "url": ["image", "service", "obj", "sl", "host", "class", "object", "proxy", "bug", "page", "www", "server", "address", "open", "loc", "http", "location", "path", "resource", "URL", "io", "ssl", "file", "str", "link", "Url", "this", "null", "base", "channel", "data", "loader", " URL", "name", "l", "uri", "source", "config", "c"], "ParserException": ["IOError", " IOExc", "IOExc", "IOException", "SSLExc", " IOException", "SSLException", "ParserError", " IOError", "ParserExc", "SSLError"], "parser": ["writer", "p", "worker", "master", "class", "object", "instance", "parse", "parent", "slave", "Parser", "handler", "pd", "server", "cache", "ler", "result", "http", "php", "fp", "se", "library", "xml", "pool", "angler", "manager", "pard", "root", "x", "this", "null", "api", "data", "pe", "jp", "type", "builder", "loader", "er", "test", "jack", "pc", "arser", "processor", "plugin", "reader", "style", "seed", "au", "config", "fruit"], "connection": ["image", "position", "db", "client", "connect", "service", "j", "class", "relation", "object", "socket", "context", "character", "proxy", "instance", "reference", "section", "lc", "directory", "handler", "server", "conn", "loc", "open", "bc", "http", "pointer", "response", "resource", "message", "io", "con", "function", "link", "connected", "this", "channel", "session", "database", "collection", "application", " Connection", "document", "reader", "ion", "communication", "Connection", "uri", "event", "config", "c", "condition"]}}
{"id1": "21363911", "id2": "17193692", "code1": "    public void testTransactions() throws Exception {\n        con = TestUtil.openDB();\n        Statement st;\n        ResultSet rs;\n        con.setAutoCommit(false);\n        assertTrue(!con.getAutoCommit());\n        con.setAutoCommit(true);\n        assertTrue(con.getAutoCommit());\n        st = con.createStatement();\n        st.executeUpdate(\"insert into test_a (imagename,image,id) values ('comttest',1234,5678)\");\n        con.setAutoCommit(false);\n        st.executeUpdate(\"update test_a set image=9876 where id=5678\");\n        con.commit();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        st.executeUpdate(\"update test_a set image=1111 where id=5678\");\n        con.rollback();\n        rs = st.executeQuery(\"select image from test_a where id=5678\");\n        assertTrue(rs.next());\n        assertEquals(9876, rs.getInt(1));\n        rs.close();\n        TestUtil.closeDB(con);\n    }\n", "code2": "    public void execUpdate(String sqlStmts[]) throws SQLException {\n        if (conn == null || conn.isClosed()) throw new SQLException(\"The connection has not been established yet.\");\n        if (sqlStmts == null || sqlStmts.length == 0) throw new SQLException(\"SQL-statement is null.\");\n        conn.setAutoCommit(false);\n        try {\n            for (int i = 0; i < sqlStmts.length; i++) {\n                stmt = conn.createStatement();\n                stmt.executeUpdate(sqlStmts[i]);\n                logger.debug(sqlStmts[i]);\n                stmt.close();\n            }\n            conn.commit();\n        } catch (SQLException ex) {\n            conn.rollback();\n            throw ex;\n        }\n    }\n", "label": 1, "substitutes": {"testTransactions": ["testtransacts", "testTransact", "testtransact", "testTacts", " testTransacts", "testTransactionact", "testTaction", "testTransactionactions", "testtransaction", "testTransactionaction", "testTactions", "testTact", "testTransactionacts", " testtransactions", "testTransacts", "testtransactions", "testTransaction", " testtransact", " testtransaction", " testTransaction", " testTransact", " testtransacts"], "con": ["db", "an", "client", "connect", "ca", "ain", "sync", "ctx", "cond", "rc", "cn", "cc", "common", "cons", "cr", "CON", "po", "cf", "core", "com", "cache", "coll", "run", "const", "conn", "ran", "connection", "ver", "ec", "bc", "cm", "conf", "xc", "fc", "crit", "Con", "pub", "uc", "en", "min", "ctrl", "col", "don", "enc", "close", "exec", "sql", "conv", "x", "ac", "can", "log", "cl", "contract", "pc", "ct", "co", "fac", "un", "ocon", "mc", "custom", "pen", "act", "win", "pl", "create", "c", "pr", "condition"], "st": ["ST", "r", "sts", "db", "sc", "fr", "la", "ck", "sw", "sl", "tx", "sync", "St", "rd", "src", "ste", "rc", "s", "std", "cr", "sa", "sn", "ut", "ist", "t", "sb", "const", "sh", "fe", "ks", "inst", "bl", "se", "td", "sy", "sta", "str", "en", "est", "set", "rest", "pe", "put", "cl", "mt", "pc", "ct", "co", "l", "ost", "ss", "d", "ld", "sth", "ust", "act", "pl", "pt", "c", "pr", "sp"], "rs": ["r", "rys", "details", "sw", "yrs", "RS", "tx", "arms", "qs", "rd", "rl", "src", "rc", "cs", "s", "Rs", "bs", "xs", "ls", "cr", "ns", "rx", "ows", "ros", "maps", "ges", "ris", "lines", "ks", "dr", "vers", "rss", "pers", "ras", "results", "rr", "ra", "row", "ds", "str", "changes", "hr", "sr", "mr", "ts", "ars", "ans", "rt", "errors", "hs", "kr", "rows", "ins", "ys", "co", "vs", "acks", "res", "ss", "ums", "ps", "rors", "runs", "ws", " RS", "pr", "repl"]}}
{"id1": "2017833", "id2": "5441579", "code1": "    public static String hash(String text) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n        byte[] sha1hash = new byte[40];\n        md.update(text.getBytes(\"iso-8859-1\"), 0, text.length());\n        sha1hash = md.digest();\n        return SHA1.convertToHex(sha1hash);\n    }\n", "code2": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "label": 1, "substitutes": {"hash": ["get", "h", "html", "ash", "block", "crypt", "print", "parse", "check", "replace", "format", "sum", "message", "Hash", "build", "str", "base", "set", "update", "transform", "sha", "number", "string", "add", "dump", "create", "hex"], "text": ["image", "font", "buffer", "template", "bytes", " Text", "key", "class", "output", "object", "pattern", "context", "input", "Text", "version", "code", "format", "content", "path", "message", "TEXT", "ext", "word", "editor", "translation", "out", "value", "EXT", "str", "url", "letter", "binary", "data", " TEXT", "struct", "secret", "token", "test", "number", "contract", "name", "password", "string", "source", "length", "hex", "txt"], "UnsupportedEncodingException": ["UnsupportedEncgorithmException", "UnsupportedencodedWarning", "UnsupportedEncodingWarning", "UnsupportedEncodedception", "UnsupportedEncodingception", "Unsupportedencodedception", "UnsupportedEncodedException", "UnsupportedEncasingception", "UnsupportedEncgorithmception", "Unsupportedencodingception", "UnsupportedencodingWarning", "UnsupportedEncasingException", "UnsupportedEncodedWarning", "UnsupportedEncgorithmWarning", "UnsupportedencodingException", "UnsupportedEncasingWarning", "UnsupportedencodedException"], "md": ["mm", "mac", "mo", "ind", "m", "dig", "bf", "mad", "ad", "metadata", "um", "ma", "od", "bm", "rm", "message", "amd", "mb", "nm", "wd", "ds", "gd", "mand", "bd", "f", "mg", "dm", "pm", "sha", "mt", "MD", "mp", "mc", "mod", "mag", "hd", "d", "vd", "ld", "ms", "meta", "am", "cmd", "dd", " MD", "hm"], "sha1hash": ["sha4hash", "ha2hash", "ha1hex", "sha4hex", "ha2hex", "sha3sum", "ha2match", "sha2match", "sha5Hash", "SHA1hex", "sha4Hash", "sha1h", "sha2hash", "sha5hex", "sha1Hash", "SHA2hash", "SHA2h", "ha1sum", "sha3hex", "SHA1hash", "shaonehex", "sha1match", "sha4sum", "sha5hash", "sha256Hash", "shaonesum", "sha5sum", "SHA2Hash", "sha2h", "sha5h", "SHA1sum", "sha2hex", "ha1hash", "SHA1Hash", "sha256hash", "sha3match", "sha2sum", "shaonematch", "sha2Hash", "sha256sum", "SHA1h", "shaonehash", "SHA2sum", "sha1sum", "sha1hex", "sha3hash", "ha2sum", "sha256h", "ha1match"]}}
{"id1": "21998571", "id2": "10391753", "code1": "    private String readTwitterFead() {\n        StringBuilder builder = new StringBuilder();\n        HttpClient client = new DefaultHttpClient();\n        HttpGet httpGet = new HttpGet(\"http://twitter.com/statuses/user_timeline/vogella.json\");\n        try {\n            HttpResponse response = client.execute(httpGet);\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n            if (statusCode == 200) {\n                HttpEntity entity = response.getEntity();\n                InputStream content = entity.getContent();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(content));\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    builder.append(line);\n                }\n            } else {\n                Log.e(AndroidJsonTestingActivity.class.getName(), \"Failed to download file\");\n            }\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return builder.toString();\n    }\n", "code2": "    public static String encrypt(String text) {\n        char[] toEncrypt = text.toCharArray();\n        StringBuffer hexString = new StringBuffer();\n        try {\n            MessageDigest dig = MessageDigest.getInstance(\"MD5\");\n            dig.reset();\n            String pw = \"\";\n            for (int i = 0; i < toEncrypt.length; i++) {\n                pw += toEncrypt[i];\n            }\n            dig.update(pw.getBytes());\n            byte[] digest = dig.digest();\n            int digestLength = digest.length;\n            for (int i = 0; i < digestLength; i++) {\n                hexString.append(hexDigit(digest[i]));\n            }\n        } catch (java.security.NoSuchAlgorithmException ae) {\n            ae.printStackTrace();\n        }\n        return hexString.toString();\n    }\n", "label": 0, "substitutes": {"readTwitterFead": ["downloadTwitterFleee", "downloadTwitterJrequency", "downloadTwitterFee", "downloadTwitterFees", "downloadFacebookJee", "downloadFacebookJrequency", "downloadTwitterJead", "downloadTwitterFFrequency", "downloadTwitterFleees", "downloadFacebookFees", "downloadTwitterFlerequency", "downloadFacebookFrequency", "downloadTwitterFleead", "downloadTwitterFFees", "downloadTwitterJee", "downloadFacebookFead", "downloadFacebookFee", "downloadTwitterFrequency", "downloadTwitterFFee", "downloadFacebookJead", "downloadTwitterFead", "downloadTwitterFFead", "downloadTwitterJees", "downloadFacebookJees"], "builder": ["r", "image", "db", "buffer", "writer", "worker", "block", "entry", "object", "trace", "instance", "sb", "server", "address", "sf", "result", "board", "builders", "http", "array", "message", "editor", "container", "keeper", "row", "we", "build", "building", "iter", "store", "f", "url", "letter", "null", "base", "wrapper", "loader", "b", "er", "oder", "runner", "database", "atter", "built", "driver", "bean", "upper", "string", "parser", "Builder", "holder", "layer"], "client": ["request", "get", "connect", "service", "google", "queue", "i", "ce", "class", "socket", "host", "app", "proxy", "cli", "handler", "server", "per", "conn", "connection", "http", "resource", "io", "con", "tc", "cloud", "Client", "url", "api", "channel", "session", "contact", "https", "application", "force", "method", "bird", "plugin", "project", "config", "c"], "httpGet": ["httpget", "urlget", " httpSend", "HttpPut", "ttpSplit", "HTTPget", "httpFind", "HttpDo", "HTTPFind", "HttpSplit", " httpDo", "httpSplit", "httpPut", " httpget", " httpSplit", " httpFind", "httpSend", "HttpGet", "urlFind", "httpDo", "HTTPSend", "urlGet", "ttpDo", "ttpPut", " httpPut", "urlSend", "HTTPGet", "ttpGet"], "response": ["request", "error", "success", "writer", "service", "stream", "received", "full", "output", "reply", "object", "page", "handler", "server", "json", "result", "connection", "http", "message", "resource", "successful", "report", "Response", "resp", "ception", "api", "onse", "session", "data", "collection", "status", "application", "wave", "document", "body", "respond", "event"], "statusLine": ["StatusEntry", "statusEntry", "httpLine", "statResponse", "statusResponse", "statLine", "httpStatus", " statusResponse", "httpEntry", "responseEntry", " statusEntry", "responseCode", "statCode", "StatusStatus", "StatusLine", "statusStatus", "contentEntry", "contentLine", "responseLine", "statEntry", "statusBlock", "httpBlock", "contentStatus", "contentBlock", "StatusBlock", "responseResponse"], "statusCode": ["statusCount", "contentCode", "statusType", "contentType", "stateType", " statusCount", "stateCode", "stateStatus", "StatusStatus", "contentCount", " statusType", "StatusType", "StatusLine", " statusStatus", "StatusCount", "StatusCode", "statusStatus", "contentLine"], "entity": ["writer", "element", "entry", "stream", "object", "el", "e", "page", "json", "coll", "server", "agent", "result", "code", "media", "http", "resource", "Entity", "connection", "xml", "file", "enc", "model", "data", "type", "er", "ent", "article", "activity", "status", "collection", "application", "document", "et", "body", "event", "person", "source"], "content": ["image", "writer", "buffer", "entry", "stream", "Content", "output", "object", "load", "feed", "input", "layer", "page", "handler", "json", "server", "conn", "child", "result", "media", "pointer", "resource", "message", "xml", "raw", "file", "channel", "data", "loader", "activity", "status", "collection", "text", "driver", "body", "cont", "read", "source"], "reader": ["r", "in", "writer", "buffer", "ner", "worker", "Reader", "stream", "rer", "i", "input", "handler", "server", "per", "ler", "or", "editor", "resource", "io", "rr", "row", "reading", "rar", "iter", "data", "ri", "loader", "er", "oder", "parser", "ser", "read", "bird"], "line": ["r", "ip", "buffer", "sl", "lf", "sync", "one", "entry", "block", "i", "key", "cell", "object", "comment", "feed", "character", "sheet", "write", "e", "id", "page", "lc", "lines", "Line", "lin", "code", "connection", "message", "row", "file", "str", "liner", "iter", "link", "part", "url", "letter", "end", "pass", "base", "inline", "data", "pe", "char", "LINE", "text", "name", "l", "style", "string", "body", "le", "point", "source"]}}
{"id1": "255765", "id2": "5061606", "code1": "    private static void main(String[] args) {\n        try {\n            File f = new File(\"test.txt\");\n            if (f.exists()) {\n                throw new IOException(f + \" already exists.  I don't want to overwrite it.\");\n            }\n            StraightStreamReader in;\n            char[] cbuf = new char[0x1000];\n            int read;\n            int totRead;\n            FileOutputStream out = new FileOutputStream(f);\n            for (int i = 0x00; i < 0x100; i++) {\n                out.write(i);\n            }\n            out.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            for (int i = 0x00; i < 0x100; i++) {\n                read = in.read();\n                if (read != i) {\n                    System.err.println(\"Error: \" + i + \" read as \" + read);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = in.read(cbuf);\n            if (totRead != 0x100) {\n                System.err.println(\"Simple buffered read did not read the full amount: 0x\" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 0x100 - totRead)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            in = new StraightStreamReader(new FileInputStream(f));\n            totRead = 0;\n            while (totRead <= 0x100 && (read = in.read(cbuf, totRead + 0x123, 7)) > 0) {\n                totRead += read;\n            }\n            if (totRead != 0x100) {\n                System.err.println(\"Not enough read. Bytes read: \" + Integer.toHexString(totRead));\n            }\n            for (int i = 0x00; i < totRead; i++) {\n                if (cbuf[i + 0x123] != i) {\n                    System.err.println(\"Error: 0x\" + i + \" read as 0x\" + cbuf[i + 0x123]);\n                }\n            }\n            in.close();\n            f.delete();\n        } catch (IOException x) {\n            System.err.println(x.getMessage());\n        }\n    }\n", "code2": "    protected void createSettingsIfNecessary() throws IOException {\n        OutputStream out = null;\n        try {\n            final File fSettings = SettingsUtils.getSettingsFile();\n            if (!fSettings.exists()) {\n                fSettings.createNewFile();\n                final Path src = new Path(\"mvn/settings.xml\");\n                final InputStream in = FileLocator.openStream(getBundle(), src, false);\n                out = new FileOutputStream(SettingsUtils.getSettings(), true);\n                IOUtils.copy(in, out);\n            } else {\n                Logger.getLog().info(\"File settings.xml already exists at \" + fSettings);\n            }\n        } finally {\n            if (out != null) {\n                out.flush();\n                out.close();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"f": ["r", "fr", "m", "self", "h", "p", "j", "lf", "bf", "g", "n", "fa", "ff", "fd", "form", "s", "feed", "fi", "fen", "e", "cf", "fo", "t", "fm", "sf", "fe", "inf", "a", "path", "ref", "fp", "io", "df", "function", "fn", "fc", "file", "fold", "fun", "of", "x", "rf", "fs", "this", "flat", "b", "v", "w", "name", "fx", "l", "d", "folder", "tf", "F", "filename", "c"], "in": ["image", "g", "inn", "ex", "fe", "a", "rin", "str", "v", "w", "ins", "In", "reader", "win", "r", "get", "p", "pin", "isin", "gin", "gen", "is", "input", "diff", "inner", "vin", "nin", "part", "err", "b", "l", "d", "again", "lock", "ac", "inc", "m", "ic", "fa", "init", "din", "t", "lin", "ssl", "ini", "min", "pass", "serv", "it", "IN", "source", "up", "c", "n", "socket", "cin", "thin", "or", "connection", "con", "rec", "exec", "login", "session", "data", "with", "token", "bin", "config"], "cbuf": ["bux", "cfuff", "rbuc", "rbbuf", "cfur", "bcur", "zbutf", "bcux", "fbuf", "bbuff", "cfuc", "cbur", "cfuf", "cfbuf", "bcul", "CBuf", "fbbuf", "bcault", "rbault", "bcuf", "cbull", "bbull", "cbuc", "cbbuf", "CBuc", "rbull", "cbault", "bcurs", "bcull", "bbuf", "buff", "CBuff", "cbuff", "cbux", "fbuc", "dbur", "rbutf", "zbuf", "rburs", "cbuu", "cburs", "buf", "dbuc", "ebuf", "bcuc", "rbul", "zbuff", "ebutf", "cbutf", "dbuff", "rbuu", "dbuf", "ebuu", "cbul", "CBul", "fbuff", "zbuu", "bburs", "rbux", "bcuff", "bault", "rbuff", "ebuff", "rbuf"], "read": ["error", "size", "sync", "g", "Read", "cel", "key", "old", "rc", "used", "ak", "open", "last", "seek", "only", "report", "raw", "change", "reading", "build", "end", "x", "iter", "en", "update", "re", "know", "er", "w", "allow", "text", "draw", "name", "reader", "create", "length", "get", "ind", "r", "connect", "ok", "full", "view", "feed", "load", "input", "parse", " write", "check", "val", "index", "num", "io", "sleep", "find", "lex", "close", "ack", "skip", "ing", "d", "repeat", "inc", " reading", " Read", "level", "ize", "stream", "bit", "ink", "q", "use", "print", "id", "valid", "run", "child", "work", "count", "start", "pass", "k", "pe", "log", "y", "put", "each", "wait", "it", "ride", "un", "insert", "add", "play", "buffer", "ed", " READ", "socket", "write", "reads", "want", "READ", "orig", "se", "readable", "send", "fill", "oct", "data", "type", "bind", "record", "call", "loop", "config", "select", "hex"], "totRead": ["tottUse", "totUse", "TottGet", "tntWrite", "tatLoad", "octotLength", "totReader", "ntottWrite", "towAccept", "TotWrite", "totalLoad", "tochReader", "totoFind", "totaLoad", "toyRead", "TotaRead", "towLength", "TottConnect", "octotRead", "tobyFind", "dottReader", " totWrite", "totalWrite", "totoRead", "ntottRead", "TotSearch", "tottReading", "tetReading", "nottLoad", "tottLength", "totaDraw", "totiBuild", "tottedGet", "TotReader", "tetRead", "tntRead", "totoLength", "totalBuild", "totConnect", "totGet", "nottWrite", "totAccept", "totingConnect", "tollWrite", "tottAccept", "TotRead", "tobyLoad", "tottDraw", "tottLoad", "totiWrite", "tottFind", "tottConnect", "tottedRead", "tochWrite", "totiRead", "ntottLoad", "notWrite", "totingRead", "tottBuild", "tottReader", "tazonLoad", "towReading", "dottRead", "TottLoad", "dottLoad", "tottWrite", "tetLoad", "totLength", "TotConnect", "TotReading", "totBuild", " totBuild", "totingSearch", "tcotLoad", "totClose", "ntotWrite", "tobyRead", "totiLink", "tcotClose", "dotReader", "totaReading", "totalRead", "intottLoad", "octotoLength", "tatWrite", "dottReading", "TottWrite", "tottSearch", "TottRead", "totFollow", "intotRead", "totaBuild", "dottUse", "totSearch", "dotReading", "totDraw", "TotaLoad", "octotWrite", "towRead", "ntotLoad", "notRead", " totalBuild", "totoLoad", "totLink", "totalAccept", "octotoRead", " totalWrite", "tottFollow", "ntotReader", "TotaWrite", " totalLink", "totoUse", "TotaDraw", "tollReading", "tazonBuild", "TotGet", "totLoad", "tazonRead", "toyLoad", "tollRead", "intottRead", "totaWrite", "intottClose", "octotoReading", "intotLoad", "notLoad", "totReading", "intotBuild", "dotLoad", "tochLoad", "tazonClose", "totalLink", " totLink", "tntReader", " totalRead", "tottedFollow", "octotoWrite", "tottedWrite", "intotClose", "TotDraw", "nottAccept", "totaRead", "tollLoad", "tetWrite", "tntLoad", "tatReader", "tatRead", "tobyUse", "towWrite", "dottFind", "totoSearch", "dotFind", "ntottReader", "totFind", "tottClose", "tochRead", "totoReading", "totaReader", "TottReading", "totingWrite", "intottBuild", "dottWrite", "dotRead", "totingGet", "tottRead", "toyWrite", "notAccept", "TotLoad", "tottGet", "TotFollow", "TottFollow", "nottRead", "totoConnect", "TottSearch", "octotReading", "dotUse", "totaLink", "ntotRead", "totWrite", "totoWrite", "towLoad", "totingFollow", "TottReader", "tcotRead", "toyDraw", "tcotBuild", "dotWrite"], "out": ["Out", "r", "client", "writer", "h", "p", "obj", "sync", "n", "g", "off", "output", "socket", "s", "init", "parent", "ex", "t", "conn", "plus", "connection", "a", "exp", "ext", "io", "fn", "conf", "file", "part", "x", "o", "exec", "ac", "err", "b", "v", "w", "net", "bin", "l", "In", "d", "again", "OUT", "outs", "outer", "up", "c", "inc"], "i": ["j", "g", "my", "ik", "key", "ci", "gi", "info", "zi", "ei", "x", "api", "u", "v", "name", "yi", "uri", "I", "length", "r", "ind", "ip", "p", "one", "eni", "is", "multi", "fi", "ix", "input", "phi", "li", "index", "io", "iu", "bi", "ti", "b", "mi", "l", "d", "si", "ai", "m", "ic", "q", "init", "slice", "e", "id", "abi", "z", "ini", "start", "o", "xi", "k", "ri", "y", "ji", "oi", "it", "hi", "chi", "source", "c", "buffer", "h", "ie", "ui", "ori", "ii", "pi", "data", "ni", "di", "me", "qi", "current"]}}
{"id1": "12454178", "id2": "20920051", "code1": "    @Override\n    public void alterar(Disciplina t) throws Exception {\n        PreparedStatement stmt = null;\n        String sql = \"UPDATE disciplina SET nm_disciplina = ?, cod_disciplina = ? WHERE id_disciplina = ?\";\n        try {\n            stmt = conexao.prepareStatement(sql);\n            stmt.setString(1, t.getNomeDisciplina());\n            stmt.setString(2, t.getCodDisciplina());\n            stmt.setInt(3, t.getIdDisciplina());\n            stmt.executeUpdate();\n            conexao.commit();\n            int id_disciplina = t.getIdDisciplina();\n            excluirTopico(t.getIdDisciplina());\n            for (Topico item : t.getTopicos()) {\n                criarTopico(item, id_disciplina);\n            }\n        } catch (SQLException e) {\n            conexao.rollback();\n            throw e;\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"alterar": [" cryar", " creAr", " cryAr", " celebra", " crearan", " crear", " celebrar", " celebraran", " celebrAr", " cultivAr", " cultivar", " crya", " cultiva", " crea", " cultivaran", " cryaran"], "t": ["att", "in", "the", "T", "template", "m", "p", "xt", "n", "tree", "tool", "i", "you", "s", "tower", "tw", "e", "nt", "ut", "to", "tt", "bolt", "let", "target", "dt", "unt", "ta", "tools", "ant", "at", "qt", "tc", " mt", "x", "f", "ot", "o", "tp", "st", "this", "ti", "type", "u", "flat", "rt", "v", "trans", "y", "it", "tm", "l", "table", "et", "d", "wt", "te", "tf", "det", "tr", "pt", "c", "ts"], "stmt": ["stbm", "Stv", "putmt", "stau", "stmr", "Strm", "putmd", " stbm", "Stau", " stct", "formv", " stdb", " stmn", "formmm", "formmt", "formrm", "tmt", "stgr", "swmt", "Stmd", " stau", "istdb", "stmd", "tmr", "strmt", "strau", "istmt", "Stbm", "smr", " stmd", "Stmm", "ustmd", "ctgr", "spt", "smt", "Stmb", "ustau", " strm", " stgr", "Stgr", "stv", "putau", "strdb", "strmn", "swau", "ustmt", "ctct", "strm", "stct", "ustnt", " stpt", " stv", " stmm", " stnt", "stmm", "ctmt", " stmb", "istmn", "ctmb", "stnt", "tpt", "Stmt", "stmn", "swbm", "Stct", "istau", "stmb", "sdb", "swmd", "stdb", " stmr", "stpt", "tdb", "putnt"], "sql": ["where", "db", "job", "details", "sl", "query", "lambda", "stat", "QL", "q", "s", "ls", "statement", " SQL", "limit", "sol", "SQL", "expression", "conn", "result", "params", "plan", "url", "serv", "base", "zip", "sq", "log", "printf", "dl", "database", "shell", "mt", "ql", "string", "seed", "setup", "insert", "lock", "cmd", "up", "pr"], "id_disciplina": ["id_disciplineINA", "id_disciplissa", "id_distciplana", "id_Disciplina", "id_disciplineana", "id_disguina", "id_distciino", "id_disciplini", "id_disciplineina", "id_discomplino", "id_distciplINA", "id_distciini", "id_disciplana", "id_discomplinea", "id_disciana", "id_distrequINA", "id_discomplina", "id_Disciplissa", "id_disrequini", "id_Disciplineina", "id_distciplina", "id_distciana", "id_disciplino", "id_disciina", "id_disguinea", "id_Disciplinea", "id_disciini", "id_distciina", "id_Disciplini", "id_distciplino", "id_disciplineissa", "id_disciplineini", "id_Disciplineinea", "id_disciplineino", "id_disguissa", "id_disciino", "id_disrequINA", "id_disciINA", "id_disciplinea", "id_distrequini", "id_disciplineinea", "id_Disciplineini", "id_discomplissa", "id_disciinea", "id_disrequina", "id_distciplini", "id_disrequinea", "id_disciplINA", "id_distciplinea", "id_distrequinea", "id_discomplana", "id_disguini", "id_distrequina", "id_Disciplineissa", "id_discomplini"], "item": ["items", "request", "r", "ip", "m", "service", "p", "entry", "queue", "q", "i", "order", "object", "action", "instance", "e", "parent", "id", "page", "seller", "server", "info", "or", "result", "container", "index", "at", "edit", "url", "o", "unit", "area", "Item", "data", "type", "pe", "bar", "v", "er", "article", "it", "other", "hop", "name", "site", "reader", "event", "source"]}}
{"id1": "14878593", "id2": "4164833", "code1": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"hyperlinkUpdate": [" hyperLinkUpdated", "hyperlinkEvent", "hyperLinkStyle", " hyperlinkStyle", "hyperimageStyle", "hyperlinkUpdated", "hyperflowStyle", "hyperLinkUpdated", "hyperlinkStyle", " hyperLinkStyle", "hyperflowUpdated", "hyperimageEvent", "hyperimageUpdate", "hyperimageUpdated", " hyperlinkUpdated", " hyperLinkUpdate", "hyperLinkEvent", "hyperflowEvent", " hyperlinkEvent", "hyperflowUpdate", "hyperLinkUpdate", " hyperLinkEvent"], "e": [" event", "m", "de", "ed", "p", "g", "ie", "element", "entry", "ce", "el", "eve", "ee", "enter", "events", "handler", "environment", "es", "t", "a", "message", "esi", "change", "E", "exc", "x", "ev", "f", "o", "this", "exec", "data", "type", "u", "v", "er", "it", "Event", "ae", "event", "ea", "c", "ec"], "url": ["image", "absolute", "video", "buffer", "large", "email", "service", "sl", "element", "host", "object", "view", "layer", "page", "server", "address", "connection", "filename", "http", "location", "URL", "resource", "path", "io", "ssl", "file", "secure", "link", "f", "Url", "channel", "base", "data", "download", "log", "text", "l", "browser", "plugin", "string", "uri", "event", "source", "config"], "stream": ["video", "image", "client", "buffer", "sw", "sl", "flash", "upload", "src", "output", "form", "view", "feed", "input", "handler", "port", "per", "or", "oper", "http", "response", "path", "resource", "io", "pool", "ssl", "out", "raw", "thread", "file", "f", "engine", "channel", "wrapper", "data", "temp", "loader", "log", "trans", "transform", "driver", "Stream", "reader", "string", "draft", "read", "source"], "writer": ["r", "buffer", "words", "service", "worker", "entry", "WR", "author", "key", "output", "write", "office", "handler", "Writer", "written", "wrote", "format", "writers", "inner", "io", "word", "xml", "riter", "rw", "storage", "letter", "this", "null", "engine", "unit", "channel", "data", "temp", "builder", "player", "w", "text", "document", "driver", "writ", "reader", "string", "draft", "writing", "widget", "source"], "editor": ["font", "auto", "video", "button", "ner", "creator", "term", "attr", "ie", "html", "Editor", "author", "order", "layout", "object", "comment", "owner", "title", "parent", "office", "archive", "server", "open", "ui", "info", "content", "fb", "edited", "io", "ob", "translation", "manager", "edit", "director", "cover", "part", "riter", "options", "area", "this", "api", "o", "builder", "player", "oder", "er", "article", "text", "document", "paper", "settings", "driver", "browser", "flower", "plugin", "reader", "external", "parser", "journal", "widget", "layer", "config"], "name": ["image", "large", "size", "one", "n", "full", "label", "key", "object", "comment", "action", "default", "title", "version", "id", "office", "address", "ame", "home", "info", "alias", "connection", "path", "time", "word", "value", "file", "part", "NAME", "prefix", "letter", "none", "base", "no", "null", "data", "type", "Name", "number", "names", "anc", "style", "string", "named", "uri", "source", "filename", "username"], "dialog": ["locOG", "videoog", "llogue", "fbot", "fogged", "palog", "lOG", "demogg", "locog", "navect", "flogs", "collOG", "flOG", "dialoc", "videoogged", "dialogue", "plogue", "flogue", "videoogg", "navoc", "demogged", "locob", "flog", "collog", "paloc", "plOG", "chobox", "dialOG", "fog", "chooc", "dialect", "plob", "llOG", "dialbot", "plog", "fogg", "videobot", "choog", "palbox", "log", "collogs", "dialogs", "choect", "dialogged", "llogs", "locogue", "demog", "navbox", "dialob", "logue", "dembot", "navog", "lob", "collogue", "palect", "dialogg", "llog", "dialbox"]}}
{"id1": "18358467", "id2": "9347451", "code1": "    public DocumentSummary parseDocument(URL url) throws IOException, DocumentHandlerException {\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n            POIOLE2TextExtractor extractor = createExtractor(inputStream);\n            SummaryInformation info = extractor.getSummaryInformation();\n            DocumentSummary docSummary = new DocumentSummary();\n            docSummary.authors = DocSummaryPOIFSReaderListener.getAuthors(info);\n            docSummary.contentReader = new StringReader(extractor.getText());\n            docSummary.creationDate = info.getCreateDateTime();\n            docSummary.keywords = new ArrayList();\n            docSummary.keywords.add(info.getKeywords());\n            docSummary.modificationDate = new Date(info.getEditTime());\n            docSummary.title = info.getTitle();\n            return docSummary;\n        } catch (IOException e) {\n            if (e.getMessage().startsWith(\"Unable to read entire header\")) {\n                throw new DocumentHandlerException(\"Couldn't process document\", e);\n            } else {\n                throw e;\n            }\n        } finally {\n            if (inputStream != null) {\n                inputStream.close();\n            }\n        }\n    }\n", "code2": "    public void writeData(String name, int items, int mzmin, int mzmax, long tstart, long tdelta, int[] peaks) {\n        PrintWriter file = getWriter(name + \".txt\");\n        file.print(\"Filename\\t\");\n        file.print(\"Date\\t\");\n        file.print(\"Acquisition #\\t\");\n        file.print(\"\ufffdm Diameter\\t\");\n        for (int i = mzmin; i <= mzmax; i++) file.print(i + \"\\t\");\n        file.println();\n        int nothing = 0;\n        String fileLoc = \"C:/abcd/\" + name + \".txt\\t\";\n        Date tempDate;\n        for (int i = 0; i < items; i++) {\n            tempDate = new Date(tstart);\n            tstart += tdelta;\n            file.print(fileLoc);\n            file.print(dateFormat.format(tempDate) + \"\\t\");\n            file.print(i + 1 + \"\\t\");\n            double t = (double) (i) / 10;\n            file.print(t + \"\\t\");\n            boolean peaked = false;\n            for (int k = mzmin; k <= mzmax; k++) {\n                for (int j = 0; j < peaks.length && !peaked; j++) {\n                    if (k == peaks[j]) {\n                        file.print(peakVals[j % peakVals.length] + \"\\t\");\n                        peaked = true;\n                    }\n                }\n                if (!peaked) {\n                    if (k == mzmax) file.print(nothing); else file.print(nothing + \"\\t\");\n                }\n                peaked = false;\n            }\n            file.println();\n        }\n        try {\n            Scanner test = new Scanner(f);\n            while (test.hasNext()) {\n                System.out.println(test.nextLine());\n            }\n            System.out.println(\"test\");\n        } catch (Exception e) {\n        }\n        file.close();\n    }\n", "label": 0, "substitutes": {"parseDocument": ["loadComment", "parserDoc", "parserDocument", "parserComment", "parseDoc", " parseDoc", "loadContent", " parseComment", "parseComment", "loadDoc", "parserContent", " parseContent", "loadDocument", "parseContent"], "url": ["image", "buffer", "service", "sl", "stream", "feed", "input", "user", "id", "page", "server", "address", "open", "connection", "http", "location", "URL", "resource", "path", "ref", "ssl", "date", "file", "str", "f", "Url", "base", "data", "gl", "loader", "text", "document", "name", "l", "browser", "string", "uri", "source"], "DocumentHandlerException": ["DocumentHandleException", "DocumentIOException", "DocumentParserException", "DocumentManagerWarning", "DocumentHandlerception", "DocumentIOception", "documentHandlerception", "DocumentHandception", "DocumentHandWarning", " DocumentHandlerProblem", " DocumentHandlerError", "DocumentHandlerError", "DocumentHandleProblem", " DocumentHandleError", "DocumentIOError", "DocumentHandlerProblem", "documentIOException", "documentIOError", "DocumentParserception", "documentIOception", "DocumentHandleWarning", " DocumentHandleException", "documentHandlerError", "documentHandlerException", " DocumentHandleWarning", "DocumentParserError", "DocumentManagerProblem", " DocumentHandleProblem", "DocumentManagerException", "DocumentHandProblem", "DocumentManagerError", "DocumentHandleError", " DocumentHandlerWarning", "DocumentHandlerWarning", "DocumentHandError", "DocumentHandException"], "inputStream": ["upStreamer", " inputForm", "inputChannel", "outputstream", "Inputstream", " inputSteam", "InputChannel", "tempstream", "outputStream", "outputStreamer", "upStream", "requeststream", "tempSt", "outputSt", "inputForm", "inputStreamer", "InputSteam", " inputstream", "outputReader", "outputChannel", "outputSteam", "requestStream", "tempSteam", "inputSt", "instream", "outputForm", "InputReader", "inputSteam", "inChannel", "InputStream", "requestStreamer", "upSteam", "inputReader", "InputForm", "inStream", " inputReader", " inputSt", "tempStream", "inSteam", "upstream", "requestSteam", "inputstream"], "extractor": ["Extraction", "Extract", "exraction", "exract", " extceptor", "xtor", "extract", "xtension", " extraction", "Extension", "extor", " extract", "intceptor", "exractor", "Extceptor", "intor", "extceptor", "Extractor", "intraction", "intract", "intractor", "Extor", "extraction", "extension", "xtractor", "intension", "xtract", " extension", "exension"], "info": ["auto", "information", "error", "fw", "job", "details", "ie", "iso", "off", "full", "i", "is", "init", "fi", "bug", "used", "abi", "id", "gi", "handler", "fo", "metadata", "py", "isu", "ui", "inf", "or", "result", "source", "diff", "af", "alias", "li", "ii", "io", "Info", "inner", "http", "raf", "now", "available", "pi", "f", "api", "base", "ami", "data", "type", "admin", "di", "hi", "by", "frame", "string", "si", "list", "parser", "usa", "tf", "about", "extra", "afi", "INFO", "config", "txt"], "docSummary": ["htmlJournal", "documentsummary", "DocSummary", "docStatus", "documentDetails", "dcDetailed", " docComment", "docDescription", " docDetails", "documentDetailed", "docsummary", "newsSummary", "metaSum", "htmlDescription", "mmResult", "docInfo", " docsummary", "documentJournal", "htmlsummary", "metasummary", "contentDetails", "mdSum", "contentSum", "pageInfo", "DocResult", "DocSum", " docResult", "metaSummary", " docStatus", "documentSum", "docData", "pageData", "dcDetails", "dcSummary", "mdsummary", "DocData", "documentInfo", "pageSum", "documentResult", "contentSummary", "docDetailed", "mmDescription", "docJournal", "docMember", "newsComment", "metaDetails", "DocDescription", "mdMember", "documentSummary", " docSum", "newsJournal", "documentStatus", "metaMember", "documentDescription", " docJournal", "documentComment", "htmlSummary", " docMember", "newsSum", "dcSum", "docResult", "mdSummary", "metaDescription", " docData", "mmSummary", "documentMember", " docDescription", "docComment", "pageSummary", "docSum", "mmsummary", "DocInfo", "docDetails", "contentStatus", " docDetailed", " docInfo"], "authors": ["letters", "people", "author", "types", "sections", "tags", "username", "headers", "comments", "writers", "owners", "docs", "editor", "terms", "members", "tools", "relations", "pages", "articles", "agents", "values", "users", "drivers", "names", "versions", "books", "plugins"], "contentReader": ["outputSource", "resourceSource", "resourceWriter", "contentWriter", "ContentFile", "ContentSource", "ContentReader", "resourceReader", "resourceFile", "outputFile", "contentSource", "contentFile", "outputReader", "outputWriter", "ContentWriter"], "creationDate": ["birthDate", "createdDate", "creationTime", "createData", "birthDay", "birthTime", "createdData", "createDate", "creationData", "createdDay", "createDay", "createdTime", "creationDay", "birthData", "createTime"], "keywords": ["signwords", "byWords", "byword", "signnotes", "characterword", "characterWords", "searchwords", "characternotes", "searchnotes", "keynames", "bywords", "typeWords", "keynotes", "typewords", "signWords", "searchword", "signnames", "keyword", "characterwords", "typeword", "typenames", "searchWords", "keyWords", "signword", "bynames"], "modificationDate": ["modisationAmount", "authorationYear", "modifyAmount", "modificationAmount", "authorificationAmount", "modationTime", "modisationDate", "modisationTime", "modationYear", "modificationTime", "authorificationYear", "modationAmount", "authorationTime", "authorationDate", "modifyTime", "authorificationDate", "modifyYear", "authorificationTime", "authorationAmount", "modificationYear", "modisationYear", "modationDate", "modifyDate"], "title": ["position", "details", "template", "term", "label", "author", "summary", "version", "comments", "page", "metadata", "format", "content", "resource", "translation", "description", "prefix", "Title", "data", "type", "license", "status", "text", "name", "body", "meta", "source", "filename"]}}
{"id1": "14567939", "id2": "13152325", "code1": "    private static byte[] baseHash(String name, String password) {\n        try {\n            MessageDigest digest = MessageDigest.getInstance(\"MD5\");\n            digest.reset();\n            digest.update(name.toLowerCase().getBytes());\n            digest.update(password.getBytes());\n            return digest.digest();\n        } catch (NoSuchAlgorithmException ex) {\n            d(\"MD5 algorithm not found!\");\n            throw new RuntimeException(\"MD5 algorithm not found! Unable to authenticate\");\n        }\n    }\n", "code2": "    public void loadExistingAntlibs(ClassLoader classLoader) {\n        URL antlibUrl;\n        URI antlibUri;\n        try {\n            Enumeration<URL> resources = classLoader == null ? ClassLoader.getSystemResources(antLibsResource) : classLoader.getResources(antLibsResource);\n            while (resources.hasMoreElements()) {\n                URL url = resources.nextElement();\n                InputStream stream = url.openStream();\n                BufferedReader reader = new BufferedReader(new InputStreamReader(stream, \"UTF-8\"));\n                for (String line = reader.readLine(); line != null; line = reader.readLine()) {\n                    String pkg = line.trim();\n                    URI uri = URI.create(\"antlib:\" + pkg);\n                    URI resource2antlib = URI.create(antLibsResource2root + pkg.replace('.', '/') + (pkg.isEmpty() ? \"\" : \"/\") + \"antlib.xml\");\n                    antlibUri = NetUtils.resolve(url.toURI(), resource2antlib);\n                    try {\n                        antlibUrl = antlibUri.toURL();\n                    } catch (IllegalArgumentException e) {\n                        System.err.println(\"base uri: \" + url);\n                        System.err.println(\"relativepath: \" + resource2antlib);\n                        System.err.println(\"target uri: \" + antlibUri);\n                        throw new RuntimeException(antlibUri.toString(), e);\n                    }\n                    loadAntLib(antlibUrl, uri);\n                }\n                reader.close();\n                stream.close();\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } catch (URISyntaxException e) {\n            throw new RuntimeException(e);\n        }\n    }\n", "label": 0, "substitutes": {"baseHash": [" generateHash", " chainFile", " chainHash", "BaseSecret", "BaseFile", "Basehash", "basehash", "BaseHash", " generateSecret", " generatehash", " chainhash", " chainSecret", " generateFile", "baseSecret", "baseFile"], "name": ["image", "hello", "n", "key", "class", "host", "object", "user", "parent", "id", "address", "ame", "alias", "path", "resource", "word", "file", "part", "NAME", "prefix", "normal", "base", "definition", "data", "type", "secret", "Name", "names", "member", "style", "string", "named", "hash", "create", "account"], "password": ["account", "words", "crypt", "key", "profile", "pattern", "input", "attribute", "sword", "phrase", "source", "diff", "padding", "Password", "code", "path", "word", "value", "wd", "prefix", "device", "pass", "security", "wallet", "data", "paste", "token", "secret", "text", "auth", "string", "stroke", "seed", "hash", "priv", "PASS", "username"], "digest": ["mdr", " digested", "signest", "mdester", " digger", "digusher", "DigEST", "digger", "mdest", "diger", "Diger", "modested", "moder", "signger", "Digest", "Digger", " diger", "Digester", " digester", "signusher", "modest", "digester", "digEST", "decest", "mdEST", "modester", "Digr", "signer", "decester", "decEST", "Digusher", " digusher", "digested", "digr", "Digested", "decr", "signester"]}}
{"id1": "1443205", "id2": "14865947", "code1": "    private void redirect(TargetApp app, HttpServletRequest request, HttpServletResponse response) throws IOException {\n        URL url = new URL(app.getUrl() + request.getRequestURI());\n        s_log.debug(\"Redirecting to \" + url);\n        URLConnection urlConnection = url.openConnection();\n        Map<String, List<String>> fields = urlConnection.getHeaderFields();\n        for (String key : fields.keySet()) {\n            StringBuffer values = new StringBuffer();\n            boolean comma = false;\n            for (String value : fields.get(key)) {\n                if (comma) {\n                    values.append(\", \");\n                }\n                values.append(value);\n                comma = true;\n            }\n            if (key != null) {\n                response.setHeader(key, values.toString());\n            } else {\n                response.setStatus(Integer.parseInt(values.toString().split(\" \")[1]));\n            }\n        }\n        InputStream in = urlConnection.getInputStream();\n        try {\n            ServletOutputStream out = response.getOutputStream();\n            byte[] buff = new byte[1024];\n            int len;\n            while ((len = in.read(buff)) != -1) {\n                out.write(buff, 0, len);\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public Object execute(ExecutionEvent event) throws ExecutionException {\n        try {\n            Shell shell = PlatformUI.getWorkbench().getActiveWorkbenchWindow().getShell();\n            QuizTreeView view = (QuizTreeView) PlatformUI.getWorkbench().getActiveWorkbenchWindow().getActivePage().showView(\"org.rcpquizengine.views.quizzes\");\n            Folder rootFolder = view.getRootFolder();\n            if (rootFolder.isEncrypted()) {\n                PasswordDialog dialog = new PasswordDialog(shell);\n                if (dialog.open() == Window.OK) {\n                    String password = dialog.getPassword();\n                    if (!password.equals(\"\")) {\n                        String md5 = \"\";\n                        MessageDigest md = MessageDigest.getInstance(\"MD5\");\n                        md.update(password.getBytes());\n                        md5 = new BigInteger(md.digest()).toString();\n                        if (rootFolder.getMd5Digest().equals(md5)) {\n                            rootFolder.setMd5Digest(\"\");\n                            rootFolder.setEncrypted(false);\n                            MessageDialog.openInformation(shell, \"Quiz bank unlocked\", \"The current quiz bank has been unlocked\");\n                        } else {\n                            MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Incorrect password\");\n                        }\n                        password = \"\";\n                        md5 = \"\";\n                    }\n                }\n            } else {\n                MessageDialog.openError(shell, \"Error unlocking quiz bank\", \"Quiz bank already unlocked\");\n            }\n        } catch (PartInitException e) {\n            e.printStackTrace();\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "label": 0, "substitutes": {"redirect": ["rewirection", "Redirection", " Redirection", "redicate", " Redrict", " Redirect", " Redicate", "rewirect", "redirection", "Redicate", "rewrict", "Redrict", "redrict", "rewicate", "Redirect"], "app": ["db", "ip", "ace", "client", "service", "pp", "host", "form", "context", "instance", "install", "page", "server", "http", "container", "App", "resource", "apps", "build", "config", "api", "base", "model", "APP", "session", "application", "admin", "framework", "auth", "browser", "plugin", "project", "web", "Application", "self"], "request": ["position", "client", "self", "buffer", "query", "queue", "view", "object", "input", "user", "instance", "version", "page", "server", "complete", "child", "info", "result", "connection", "resource", "message", "report", "xml", "rec", "req", "model", "session", "data", "application", "requ", "record", "method", "Request", "remote", "web", "event", "create", "config"], "response": ["image", "error", "success", "client", "service", "full", "fire", "host", "output", "reply", "view", "object", "feed", "proxy", "respons", "page", "server", "cache", "json", "result", "connection", "http", "resource", "report", "message", "index", "pool", "Response", "description", "function", "resp", "req", "serv", "onse", "model", "session", "collection", "status", "application", "wave", "document", "res", "site", "body", "respond", "uri", "re"], "url": ["image", "db", "client", "service", "sl", "host", "object", "proxy", "impl", "bb", "ls", "page", "server", "address", "bel", "loc", "connection", "http", "location", "resource", "URL", "path", "ssl", "file", "link", "f", "Url", "api", "base", "zip", "log", "b", "ll", "l", "web", "uri", "config", "www"], "urlConnection": ["webconnection", "httpConnection", "urlClosure", "URLconnection", " urlConnect", "urlconnection", "sslConnection", "stringClosure", "urlConn", "controlConnect", "controlConstruction", "httpClosure", "controlConnection", "stringConnection", "httpConn", "urlConstruction", "urlConnect", "urlClient", "stringClient", "httpClient", "webConnect", " urlClosure", "sslconnection", "URLConnect", " urlconnection", "webConnection", " urlConn", "sslConstruction", "URLConnection", "sslConnect", " urlConstruction", "controlconnection", "stringConn", " urlClient"], "fields": ["balls", "locks", "details", "guards", "styles", "qs", "models", "files", "types", "players", "phones", "loads", "limits", "strings", "cells", "headers", "forces", "ips", "events", "maps", "comments", "features", "properties", "lines", "keys", "objects", "holders", "owners", "services", "frames", "members", "states", "classes", "relations", "checks", "data", "forms", "groups", "lists", "users", "views", "drivers", "rows", "ids", "ums", "pps", "rules", "field", "flows", "plugins"], "key": ["KEY", "ip", "match", "ace", "service", "query", "element", "alpha", "entry", "label", "q", "pattern", "default", "order", "i", "host", "title", "version", "id", "section", "patch", "cy", "rule", "cookie", "val", "check", "keys", "property", "code", "foo", "index", "path", "reason", "word", "row", "step", "count", "date", "part", "link", "prefix", "col", "feature", "base", "money", "zip", "k", "data", "type", "letter", "tax", "name", "string", "header", "variable", "point", "field", "Key", "uri", "source", "length"], "values": ["items", "vals", "blocks", "bytes", "words", "files", "boxes", "limits", "s", "bs", "strings", "cells", "headers", "its", "events", "maps", "es", "properties", "lines", "gets", "keys", "objects", "ks", "Values", "services", "params", "codes", "results", "frames", "roots", "states", "options", "changes", "pages", "ones", "data", "ends", "v", "lists", "errors", "groups", "forms", "rows", "ins", "views", "ops", "vs", "settings", "als", "versions", "ps", "ports", "rules", "iv"], "value": ["service", "element", "entry", "default", "object", "comment", "version", "reference", "write", "attribute", "option", "val", "property", "format", "message", "resource", "end", "letter", "null", "data", "VALUE", "v", "language", "search", "name", "member", "style", "variable", "string", "item", "field", "current", "Value", "source"], "comma": ["commas", " comment", "compada", "coma", "comment", "compma", "cyma", "Combo", "uca", "omma", "compmas", "ombo", "compa", "conenta", "Coma", "ompa", "Comma", "cyenta", "lamma", "lampa", "ucbo", "COMada", "ucma", "comntax", "conpa", " comada", "cyntax", "Compa", "ucpa", "combo", "compment", "COMment", "COMmas", "comada", "conma", "cypa", "COMma", " commas", "conntax", "lamenta", "lamntax", "oma", "comenta"], "in": ["r", "client", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "input", "id", "ex", "din", "lin", "a", "inner", "nin", "con", "ini", "file", "inside", "min", "f", "serv", "login", "data", "ac", "err", "b", "ins", "bin", "In", "reader", "IN", "again", "as", "read", "win", "c", "inc"], "out": ["Out", "sync", "obj", "off", "output", "user", "copy", "ex", "conn", "sum", "exp", "ext", "io", "inner", "exit", "raw", "down", "o", "serv", "exec", "data", "err", "b", "w", "ins", "net", "bin", "res", "again", "OUT", "outs", "extra", "up", "inc"], "buff": ["fab", "pad", "buffer", "ph", "batch", "bf", "pp", "cond", "cp", "ff", "cell", "comb", "feed", "load", "qq", "bb", "sb", "fe", "boot", "grab", "rb", "fb", "bl", "mb", "ob", "pack", "gb", "now", "Buff", "bag", "f", "buf", "ch", "uff", "data", "b", "char", "uf", "text", "cod", "lock", "cmd", "flush", "back", "cb", "length", "txt"], "len": ["ind", "fin", "db", "size", "lf", "n", "pos", "off", "all", "pre", "el", "fl", "lim", "ln", "id", "limit", "coll", "val", "lin", "ler", "li", "num", "line", "Len", "count", "str", "en", "end", "min", "rev", "iter", "data", "type", "err", "cap", "l", "bin", "le", "read", "length"]}}
{"id1": "5977352", "id2": "18696387", "code1": "    public static void copyFile(File src, File dest, int bufSize, boolean force) throws IOException {\n        if (dest.exists()) if (force) dest.delete(); else throw new IOException(\"Cannot overwrite existing file: \" + dest.getName());\n        byte[] buffer = new byte[bufSize];\n        int read = 0;\n        InputStream in = null;\n        OutputStream out = null;\n        try {\n            in = new FileInputStream(src);\n            out = new FileOutputStream(dest);\n            while (true) {\n                read = in.read(buffer);\n                if (read == -1) break;\n                out.write(buffer, 0, read);\n            }\n        } finally {\n            if (in != null) try {\n                in.close();\n            } finally {\n                if (out != null) out.close();\n            }\n        }\n    }\n", "code2": "    public Converter(String input, String output) {\n        try {\n            FileInputStream fis = new FileInputStream(new File(input));\n            BufferedReader in = new BufferedReader(new InputStreamReader(fis, \"SJIS\"));\n            FileOutputStream fos = new FileOutputStream(new File(output));\n            BufferedWriter out = new BufferedWriter(new OutputStreamWriter(fos, \"UTF8\"));\n            int len = 80;\n            char buf[] = new char[len];\n            int numRead;\n            while ((numRead = in.read(buf, 0, len)) != -1) out.write(buf, 0, numRead);\n            out.close();\n            in.close();\n        } catch (IOException e) {\n            System.out.println(\"An I/O Exception Occurred: \" + e);\n        }\n    }\n", "label": 1, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "CopyDir", "transferfile", "transferDir", "copyFiles", "copyfile", "transferFiles", "transferFile", "copyDir", " copyDir", "CopyFile", "Copyfile"], "src": ["sc", "obj", "sl", "stream", "files", "rc", "view", "s", "proxy", "tmp", "input", "slice", "sb", "conn", "loc", "rb", "path", "resource", "inst", "fp", "gb", "img", "proc", "file", "dist", "config", "sel", "url", "buf", "this", "data", "loader", "b", "ins", "uri", "ource", "source", "filename"], "dest": ["de", " Dest", "obj", "cp", "output", "delete", "master", "tmp", "opt", "class", "thin", "parent", "route", "cache", "home", "Dest", "target", "dc", "desc", "path", "dep", "orig", "later", "img", "cdn", "file", "dist", "part", "store", "dir", "url", "die", "st", "wb", "this", "null", "rest", "zip", "temp", "trans", "done", "name", "table", " destination", "d", "project", "folder", "destroy", "cont", "source", "config", "txt"], "bufSize": ["bufferLen", " buf2", "queueLen", "buffer2", "ufLen", "bufferSize", "queueSize", " bufsize", "bufLen", "buf2", " bufLen", "buffersize", "queuesize", "uf2", "bufsize", "ufSize", "ufsize"], "force": ["auto", "urse", "require", "p", "sync", "rc", "delete", "use", "load", "forces", "write", "parent", "route", "id", "deep", "apply", "replace", "dirty", "hard", "only", "pull", "file", "count", "store", "f", "no", "base", "forcing", "ride", "Force", "forced", "remote", "front", "like", "place", "push", "flush", "source", "ist"], "buffer": ["request", "bytes", "batch", "queue", "transfer", "feed", "load", "slice", "reference", "write", "limit", "Buffer", "cache", "address", "result", "padding", "fb", "zero", "buff", "raw", "value", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "append", "b", "border", "offset", "split", "memory", "bin", "reader", "seed", "flush", "source", "length"], "read": ["get", "ind", "ip", "next", "connect", "level", "size", "ed", "sync", "n", "Read", "block", "current", "i", "view", "use", "feed", "load", "input", "ad", "write", "parse", "copy", " write", "id", "reads", "run", "check", "open", "seek", "index", "READ", "io", "show", "sleep", "se", "work", "raw", "count", "reading", "send", "fill", "lex", "len", "start", "iter", "build", "find", "close", "end", "pass", "exec", "k", "data", "b", "wait", "allow", "text", "ride", "skip", "d", "reader", "play", "add", "create", "length", "select"], "in": ["r", "image", "m", "pin", "n", "inn", "gin", "isin", "i", "socket", "init", "cin", "input", "thin", "id", "ex", "sin", "din", "conn", "connection", "a", "inner", "pull", "nin", "con", "ini", "kin", "rin", "part", "inside", "min", "f", "url", "lib", "pass", "base", "serv", "login", "ac", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "plain", "client", "writer", "max", "sync", "obj", "off", "n", "one", "i", "output", "socket", "key", "app", "init", "ou", "user", "write", "id", "ex", "cache", "home", "conn", "connection", "exp", "ext", "inner", "io", "nin", "at", "line", "part", "url", "o", "no", "exec", "this", "lib", "err", "with", "b", "can", "w", "net", "call", "name", "co", "bin", "by", "OUT", "again", "outs", "outer", "source", "up", "ac", "inc"]}}
{"id1": "21063400", "id2": "3024992", "code1": "    private void doImageProcess(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        response.setContentType(\"image/\" + type + \"\");\n        Point imgSize = null;\n        if (width > 0 || height > 0) {\n            imgSize = new Point(width, height);\n        }\n        if (fmt != null && imageFormats.containsKey(fmt)) {\n            imgSize = imageFormats.get(fmt);\n        }\n        InputStream imageInputStream = inputStream != null ? inputStream : imageUrl.openStream();\n        if (imageInputStream == null) {\n            throw new RuntimeException(\"File \" + imageUrl + \" does not exist!\");\n        }\n        if (imgSize == null) {\n            IOUtils.copy(imageInputStream, response.getOutputStream());\n        } else {\n            byte[] imageBytes = getImageBytes(type, imgSize, imageInputStream);\n            response.setContentLength(imageBytes.length);\n            response.getOutputStream().write(imageBytes);\n        }\n        response.getOutputStream().flush();\n        response.getOutputStream().close();\n    }\n", "code2": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "label": 1, "substitutes": {"doImageProcess": ["doThumbnailFile", "doimageprocess", " doimageProcess", " doimageprocess", "doFileFile", "doimageProcess", " doImageprocess", "doImageFile", "doThumbnailProcess", " doimageFile", "doFileprocess", "doimageFile", "doFileProcess", "doImageprocess", "doThumbnailprocess", " doImageFile"], "request": ["image", "client", "writer", "query", "stream", "object", "input", "instance", "server", "result", "path", "report", "message", "resource", "xml", "url", "req", "model", "data", "type", "application", "method", "name", "Request", "reader", "header", "config"], "response": ["next", "image", "error", "success", "video", "client", "writer", "service", "full", " Response", "queue", "host", "output", "reply", "view", "object", "feed", "default", "version", "page", "server", "json", "complete", "cache", "example", "more", "result", "connection", "http", "location", "message", "report", "resource", "index", "pool", "results", "Response", "out", "description", "resp", "ception", "api", "onse", "model", "session", "collection", "status", "application", "wave", "document", "site", "body", "respond"], "imgSize": [" imgLength", "imgLen", "imgLength", "largeSize", "imageLength", "imageName", "hrType", "augLen", "imgWidth", "imgHeight", "imgsize", " imgWidth", "bgFamily", "augWidth", "dimsize", "imageSize", "imagesize", "bgLen", " imgsize", "imgScale", "imgC", "largeType", "ifName", "imgFamily", "imageLen", "dimLength", "imagType", "imgName", "refHeight", "imsize", "bgLength", "dimSize", " imgLen", "imagC", "refsize", "imSize", "imgType", "augFamily", "hrsize", "refSize", "imHeight", " imgFamily", "bgScale", "bgWidth", " imgScale", "imagsize", "bgSize", "largesize", "augSize", "largeC", "imLength", "ifLen", "dimHeight", "hrSize", " imgName", "hrC", "ifsize", "imagSize", "refLength", "imageScale", "ifSize"], "imageInputStream": ["photoInputStream", "imageStreamStream", "imageOutputStream", "imageFileStream", "imageUploadSteam", "imageContentStream", "imageStreamSteam", "fileInputString", "imageOutputView", "pictureInputSteam", "imageUploadFile", "imageInLength", "photoReadFile", "fileReadLength", "imageOutputSteam", "imageInputFile", "imageReadLength", "imageContentView", "fileInputLength", "imageUploadView", "imageInputView", "pictureInputstream", "imageInputSteam", "imageReadStream", "imageFileLength", "pictureInputStream", "imageContentSteam", "imageInString", "imageOutputstream", "pictureInputFile", " imageInputFile", "photoReadSteam", "fileInputstream", "fileReadStream", "imageStreamstream", "imageUploadstream", "imageContentFile", "imageStreamFile", "pictureUploadstream", "photoReadstream", "fileReadstream", " imageOutputSteam", "imageReadString", "imageInputLength", "pictureUploadSteam", "imageFilestream", "imageOutputFile", "imageFileString", "pictureUploadFile", "imageInputString", "photoInputstream", "photoInputFile", "fileInputStream", "imageInStream", "photoInputSteam", "fileReadString", " imageOutputView", "pictureUploadStream", "imageReadFile", " imageOutputStream", "imageUploadStream", " imageInputView", "imageInputstream", "photoReadStream", " imageInputSteam", "imageInstream", "imageReadstream", " imageOutputFile", "imageReadSteam"], "imageBytes": [" imageData", "fileBlocks", " imageBuffer", "imageByte", "imgbytes", "pictureData", "audiobytes", "pictureBytes", "imgData", "Imagebytes", "viewbytes", " imageByte", "ImageBytes", "imgBuffer", "imageBuffer", "viewBytes", "audioBuffer", "imageData", "pictureBlocks", "picturebytes", "viewData", " imageUrl", "filebytes", "ImageData", "audioByte", "fileBytes", " imagebytes", "audioBytes", "imageUrl", "imgBytes", "fileData", "imageBlocks", "ImageBlocks", "imagebytes", "imgByte", "viewUrl", "imgUrl"]}}
{"id1": "14783950", "id2": "2324868", "code1": "    public static void compressWithZip(Vector fileList, String zipFileName) throws IOException {\n        if (fileList == null || fileList.size() == 0) return;\n        FileOutputStream fos = new FileOutputStream(zipFileName);\n        ZipOutputStream zos = new ZipOutputStream(fos);\n        Iterator iter = fileList.iterator();\n        while (iter.hasNext()) {\n            String fileName = (String) iter.next();\n            int ind = Math.max(fileName.lastIndexOf('/'), fileName.lastIndexOf('\\\\'));\n            String shortName = \"unknown\";\n            if (ind < fileName.length() - 1) shortName = fileName.substring(ind + 1);\n            zos.putNextEntry(new ZipEntry(shortName));\n            FileInputStream fis = new FileInputStream(fileName);\n            byte[] buf = new byte[10000];\n            int bytesRead;\n            while ((bytesRead = fis.read(buf)) > 0) zos.write(buf, 0, bytesRead);\n            fis.close();\n            zos.closeEntry();\n        }\n        zos.close();\n    }\n", "code2": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "label": 1, "substitutes": {"compressWithZip": ["compressUsingZip", "compressedWithSax", "compressedUsingSax", "compresswithSax", "compressedUsingJar", "compressedWithZip", "compressUsingSax", "compressedUsingZip", "compressUsingJar", "compresswithZip", "compresswithJar", "compressedWithJar", "compressInZip", "compressInJar", "compressInSax", "compressWithJar", "compressWithSax"], "fileList": ["filelist", "fileChain", " fileChain", "FileList", "wordName", "inputList", " fileCollection", "zipName", " fileStream", "fileEx", "stringList", "ziplist", "fileString", "stringName", "Filelist", "FileStream", " filelist", "stringChain", "FileSet", "FileName", "wordList", "modelEx", "modelStream", "fileStream", "fileCollection", "zipSet", "zipList", "inputEx", "modelCollection", "stringlist", "FileString", " fileString", "fileSet", "FileChain", "inputCollection", " fileSet", "inputStream", "modelList", "wordStream", " fileEx", "wordString"], "zipFileName": ["zipDirname", "archiveDirDir", "archiveDirPath", "archiveFileDir", "zipFullNames", "zipDirPath", "zipDirNames", "zipFileDir", "folderFileName", "archiveFileName", "archiveFilePath", "zipFullname", "zipFullName", "folderFileNames", "archiveDirName", "zipDirDir", "zipGlobalNames", "zipFullDir", "folderFilename", "zipFilename", "folderGlobalNames", "zipGlobalPath", "zipPackagePath", "folderFilePath", "folderGlobalName", "folderGlobalPath", "zipPackageDir", "folderGlobalname", "zipFileNames", "zipDirName", "zipGlobalname", "zipGlobalName", "zipPackageName", "zipFilePath", "zipFullPath"], "fos": ["Faos", "afoS", "FoS", "flos", "faos", "infis", "fosh", "Fos", "infos", "flosh", "flis", "infoS", "afos", "infaos", "afaos", "afis", " fosh", "foS", "Fis", "Fosh"], "zos": ["os", "iframe", "onz", "inos", "LOS", "bis", "dos", "zag", "zz", "zb", "uz", "fi", "lol", "lins", "ses", "abi", "zon", "ros", "css", "es", "zan", "spin", "ZI", "zy", "seconds", "zx", "tz", "zi", "cos", "packs", "oses", "bes", "jas", "jobs", "closure", "z", "nz", "budget", "rez", "bag", "osi", "ZA", "zo", "zar", "zen", "phi", "zip", "chini", "zes", "zers", "zik", "ozo", "zer", "zzy", "fits", "bos", "obb", "loop", "gz", "outs", "kos", "webkit", "zl"], "iter": ["former", "next", "Iterator", "iterator", "ip", "liter", "fr", "ner", "sort", "cher", "inse", "ie", "Iter", "i", "is", "order", "el", "chain", "slice", "parse", "e", "enter", "ener", "coll", "loc", "oper", "http", "inner", "index", "ite", "gener", "ir", "iner", "file", "end", "f", "ator", "set", "iz", "err", "keep", "inter", "er", "test", "it", "itter", "fer", "ter", "upper", "finder", "list", "outer", "ser", "walker", "inc", "izer"], "fileName": ["pageName", "fullName", "fPart", "fileLine", "Filename", " fileFull", "FileType", "fullOpen", "currentData", "FileLine", "fileString", "currentname", "FilePart", "filenameFull", "fileType", " fileType", " fileInfo", "localName", "FileName", "filenameInfo", "FileData", "currentName", " fileLine", "filenameName", "fileFull", "localname", " fileData", "fileUrl", "fname", "fullPath", " fileOpen", "simplePath", "filePart", "fileInfo", "FilePath", "fName", "fLine", "FileInfo", " filePath", "FileString", "localPart", " fileString", "FileFull", "pagename", "pageString", "pageType", " fileUrl", "simpleName", "fileOpen", "fileData", "filePath", "localPath", "FileUrl", "filenamename", " filename", " filePart", "simpleOpen", "currentUrl", "filename"], "ind": ["rib", "in", "fr", "j", "wind", "inn", "pos", "cond", "i", "ord", "ix", "ad", "id", "ci", "mid", "val", "loc", "index", "ii", "pull", "z", "IND", "count", "Ind", "len", "start", "x", "dir", "end", "mind", "div", "vert", "pend", "bind", "nd", "eff", "d", "ld", "ded", "pt", "length", "inc"], "shortName": ["smallPath", "shortLine", "fullName", "smallName", "smallPart", " shortname", "ShortName", "shortString", "longName", "shortname", "fullPath", "longPath", "ShortPart", "fullLine", "smallname", "shortPath", "shortPart", "fullString", "ShortString", " shortPath", "fullname", "ShortPath", "Shortname", "longPart", " shortLine", "longLine", " shortString", "longname"], "fis": ["Fs", "cfris", "gis", "fios", "gris", "cfos", "pis", " fs", " fris", "gios", "pris", "cfiss", "Fos", "afiss", " fiss", " fisa", "afos", "cfis", "fs", "afis", "gisa", "fris", " fios", "fiss", "cfs", "pisa", "pios", "fisa", "afris", "Fis", "Fiss"], "buf": ["bp", "buffer", "la", "bu", "bytes", "batch", "seq", "bf", "br", "queue", "ff", "fd", "rc", "lb", "tmp", "lim", "bb", "loc", "grab", "bc", "rb", "fb", "bl", "cur", "buff", "uc", "box", "pb", "Buff", "bag", "bh", "bd", "feat", "wb", "vec", "data", "b", "cv", "v", "uf", "ba", "done", "bin", "cb"], "bytesRead": ["bytesWrite", "secondsRead", "bytesLength", " bytesNeed", "bitsSkip", " bytesSkip", "tesLoad", "bitsRead", "bitsUse", "flowsLength", " bytesLength", "wordsLength", "bytesLoad", " bytesLoad", "flowsRead", "flowsWrite", "tesSkip", "bytesSkip", "secondsWrite", "bitsWrite", " bytesUse", "tesRead", "secondsLength", "flowsNeed", "bytesUse", "bitsLoad", "bytesNeed", " bytesWrite", "wordsUse", "tesWrite", "wordsWrite", "wordsRead", "bitsLength", "secondsNeed"]}}
{"id1": "18793482", "id2": "16621503", "code1": "    public void modifyApplicationMessage(String locale, String messageName, String messageValue) {\n        Properties properties = new Properties();\n        try {\n            String i18nPath = ServerUtil.removelastResourceURL(ConfigurationServiceImpl.class.getResource(\"/es/ua/tranube/prototype/main/client/TranubeConstants_en.properties\").getPath()).toString();\n            File englishFile = new File(i18nPath + \"TranubeConstants_en.properties\");\n            if (!englishFile.exists()) throw new Exception(\"English file not found\");\n            String propertiesFilePath = i18nPath + \"TranubeConstants_\" + locale + \".properties\";\n            File file = new File(propertiesFilePath);\n            if (!file.exists()) {\n                FileReader in = new FileReader(englishFile);\n                FileWriter out = new FileWriter(file);\n                int c;\n                while ((c = in.read()) != -1) out.write(c);\n                in.close();\n                out.close();\n            }\n            InputStream is = ConfigurationServiceImpl.class.getResourceAsStream(\"/es/ua/tranube/prototype/main/client/TranubeConstants_\" + locale + \".properties\");\n            BufferedReader breader = new BufferedReader(new InputStreamReader(is));\n            String line = null;\n            StringBuilder strBuilder = new StringBuilder();\n            boolean found = false;\n            while ((line = breader.readLine()) != null) {\n                if (line.startsWith(\"#\")) strBuilder.append(line).append(\"\\n\"); else {\n                    String[] pieces = line.split(\"=\");\n                    if (pieces.length == 2) {\n                        if (pieces[0].trim().equals(messageName)) {\n                            strBuilder.append(pieces[0].trim() + \" = \" + messageValue + \"\\n\");\n                            found = true;\n                        } else strBuilder.append(line).append(\"\\n\");\n                    } else strBuilder.append(line).append(\"\\n\");\n                }\n            }\n            if (!found) strBuilder.append(messageName).append(\" = \").append(messageValue).append(\"\\n\");\n            breader.close();\n            is.close();\n            FileWriter writer = new FileWriter(file);\n            writer.write(strBuilder.toString());\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n", "code2": "    public static ArrayList<String> loadURLToStrings(URL url, int maxLines, String userAgent, int timeout) throws IOException {\n        URLConnection connection = url.openConnection();\n        if (userAgent != null && userAgent.trim().length() > 0) {\n            connection.setRequestProperty(\"User-Agent\", userAgent);\n        } else {\n            connection.setRequestProperty(\"User-Agent\", \"Mozilla/5.0 (compatible; astrominer/1.0;)\");\n        }\n        if (timeout > 0) {\n            connection.setConnectTimeout(timeout);\n        }\n        connection.connect();\n        return loadURLToStrings(connection, maxLines);\n    }\n", "label": 0, "substitutes": {"modifyApplicationMessage": ["modifyApplicationmessage", "modifyApplicationMsg", "modifiedApplicationmessage", "modifyapplicationContent", "modifyExternalmessage", "modifyAppContent", "modifyapplicationMessage", "modifyExternalMsg", "modifiedapplicationmessage", "modifiedApplicationContent", "modifyAppMsg", "modifyApplicationContent", "modifiedapplicationMessage", "modifyapplicationmessage", "modifiedApplicationMsg", "modifyExternalMessage", "modifiedapplicationMsg", "modifyapplicationMsg", "modifyAppmessage", "modifiedApplicationMessage", "modifyExternalContent", "modifyAppMessage", "modifiedapplicationContent"], "locale": ["locationales", " locator", "locationALE", "Locales", "placeame", "placeales", "LocALE", "placeale", "localales", "locationue", "localue", "locator", "locue", "localale", "Locame", "Locue", "localALE", "locame", "locationale", "locales", "locALE", " locame", "placeALE", "Locator", "Locale", "localame", " locales", "localator"], "messageName": ["MessageValue", "phraseName", "msgName", "reasonname", "reasonValue", "phraseKey", " messageKey", "msgType", "msgValue", "Messagename", "reasonName", "reasonType", "phraseType", "MessageKey", "MessageType", "messageKey", " messagename", "messagename", "MessageName", "msgKey", " messageType", "messageType", "phraseValue"], "messageValue": ["MessageValue", "msgName", "msgVal", "responseName", "MessageVal", "msgType", "msgValue", "responseValue", "responseType", " messageVal", "MessageType", "MessageName", " messageType", "messageType", "responseVal", "messageVal"], "properties": ["stats", "perties", "obj", "tmp", "ips", "metadata", "json", "py", "property", "params", "xml", "resources", "conf", "pb", "options", "api", "data", "Property", "ops", "settings", "prop", " props", "pro", "ps", "Pro", " Properties", "config", "txt"], "i18nPath": ["i18nsLocation", "i18nsStr", "i16nsPath", "i18fCorp", "i32nUrl", "i11fUrl", "i18npath", "i32nPath", "i18onFile", "i16nStr", "i18onPath", "i18ninPath", "i18onUrl", "i11fCorp", "i16nsPart", "i18fPath", "i16npath", "i18nsPath", "i11fpath", "i32nLocation", "i18ninFile", "i18nStr", "i18ninUrl", "i18neCorp", "i18nsFile", "i18fpath", "i18onLocation", "i32ninFile", "i18bPath", "i18nLocation", "i11nUrl", "i18nsCorp", "i32nFile", "i11npath", "i18fUrl", "i18nsUrl", "i18naStr", "i16nPath", "i18nepath", "i18nCorp", "i16nPart", "i11nPath", "i18nePath", "i18naPath", "i32ninLocation", "i18nsPart", "i18neUrl", "i11fPath", "i18bPart", "i18bStr", "i16nsStr", "i18nspath", "i18napath", "i18nUrl", "i32ninUrl", "i18nFile", "i32ninPath", "i16nspath", "i18bpath", "i18nPart", "i18naPart", "i18ninLocation", "i11nCorp"], "englishFile": ["exampleFile", "englishFolder", "propertiesFile", "EnglishFiles", "languageJar", "examplePath", "languagePath", " englishPath", "EnglishFolder", "languagefile", "languageFiles", "ianaJar", "ianaPath", "languageFile", "EnglishPath", "englishDir", "propertiesfile", "EnglishFile", "englishFiles", "Englishfile", "propertiesFolder", " englishFiles", " englishJar", "englishfile", " englishfile", "ianaDir", "examplefile", "exampleFolder", "propertiesPath", "englishJar", "ianaFile", "englishPath", " englishDir", "languageDir"], "propertiesFilePath": ["propertiesfileURL", "propertiesDirUrl", "propertiesSourceFileName", "propertiesFilesName", "propertiesFileURL", "pertiesFileName", "propertiesDirpath", "propertiesFileUrl", "pertiesFilePath", "propertiesSourceFilepath", "pertiesFilepath", "propertiesfilePath", "propertiesFilesPath", "pertiesDirUrl", "pertiesfileName", "pertiesDirpath", "propertiesFilesUrl", "pertiesfilepath", "pertiesFileUrl", "pertiesFileURL", "propertiesFilespath", "propertiesfilepath", "propertiesDirPath", "propertiesfileUrl", "propertiesfileName", "propertiesFileName", "propertiesFilepath", "pertiesDirName", "propertiesDirName", "pertiesDirPath", "pertiesfileURL", "propertiesFilesURL", "propertiesSourceFileURL", "pertiesfilePath", "propertiesSourceFilePath"], "file": ["parent", "fe", "format", "content", "http", "word", "letter", "die", "base", "text", "name", "reader", "string", "folder", "p", "one", "full", "future", "page", "File", "module", "media", "php", "path", "message", "single", "FILE", "part", "unit", "b", "language", "l", "lock", "stream", "files", "class", "object", "use", "directory", "child", "show", "function", "ile", "url", "pe", "log", "it", "play", "source", "up", "filename", "buffer", "h", "socket", "handler", "or", "property", "connection", "resource", "fp", "book", "f", "binary", "model", "zip", "data", "application", "force", "entity", "le", "field"], "in": ["r", "image", "p", "pin", "ic", "n", "inn", "isin", "gin", "i", "s", "init", "cin", "input", "sin", "din", "plus", "lin", "or", "inner", "io", "nin", "con", "rin", "kin", "ini", "into", "inside", "f", "login", "ri", "err", "b", "er", "it", "ins", "bin", "In", "l", "reader", "d", "IN", "again", "win", "inc"], "out": ["Out", "r", "image", "plain", "error", "p", "sync", "one", "n", "full", "up", "i", "output", "socket", "s", "ou", "write", "cli", "ex", "home", "to", "inner", "ext", "exp", "io", "word", "work", "part", "end", "f", "o", "lib", "exec", "builder", "err", "b", "v", "w", "net", "co", "bin", "by", "again", "string", "and", "outs", "outer", "OUT", "inc"], "c": ["r", "C", "sc", "h", "size", "ice", "p", "n", "i", "ce", "rc", "cc", "character", "dec", "cr", "cy", "ci", "cf", "lc", "t", "cu", "code", "bc", "a", "pointer", "dc", "cur", "con", "xc", "uc", "esc", "x", "f", "col", "ch", "enc", "o", "abc", "k", "ac", "b", "arc", "v", "char", "w", "cl", "ct", "pc", "l", "d", "cont", "ec"], "is": ["get", "os", "Is", "us", "bis", "iso", "stream", "isa", "i", "s", "its", "ib", "id", "es", "ris", "isu", "IS", "ui", "info", "iss", "ios", "has", "ir", "str", "ais", "iter", "serv", "api", "ri", "does", "are", "it", "ins", "res", "as", "si", "ps", "re"], "breader": ["breadr", "breaditer", " cakeler", "brewiter", " Breader", " breadler", "breadler", "brewer", "breadER", " cakeers", "breaders", "feedamer", " breaders", "breadamer", "feediter", "feeder", "webamer", "weber", "feedr", " Breadler", " Breaders", "brewr", " BreadER", "webiter", "webr", "brewamer", " cakeER", " cakeer", " breadER"], "line": ["next", "error", "ip", "lo", "side", "lf", "one", "sl", "sync", "block", "entry", "key", "cell", "comment", "feed", "el", "character", "parse", "write", "section", "page", "lc", "lined", "rule", "phrase", "lines", "Line", "lin", "code", "strip", "band", "response", "message", "li", "day", "word", "row", "value", "str", "end", "part", "link", "liner", "url", "letter", "no", "pass", "base", "definition", "inline", "model", "data", "log", "split", "status", "LINE", "text", "name", "l", "frame", "style", "body", "string", "header", "nl", "le", "plugin", "item", "look"], "strBuilder": ["stringbuilder", " strBuilding", "strBuilding", "strBuild", "StrBuilding", "brBuilder", "brBuffer", "stringBuild", " strbuilder", " strBuffer", "StrBlock", "StrBuffer", "strBlock", "brBlock", "stringBuilding", "brbuilder", "stringBuilder", "stringBuffer", "StrBuilder", "brBuild", "strBuffer", " strBuild", "Strbuilder", "brBuilding", "StrBuild", " strBlock", "strbuilder"], "pieces": ["items", "vals", "letters", "cards", "bytes", "words", "pots", "styles", "steps", "files", "phones", "boxes", "sections", "strings", "cells", "ips", "features", "lines", "keys", "objects", "marks", "circle", "seconds", "cuts", "services", "packs", "apps", "tips", "places", "bits", "planes", "tops", "nets", "pages", "pins", "values", "blocks", "groups", "rings", "split", "lists", "forms", "ops", "names", "bones", "piece", "parts", "flows"], "found": ["made", "expected", "loaded", "left", "printed", "lost", "fall", "full", "all", "old", "defined", "created", "fl", "used", "sent", "Found", "required", " Found", "valid", "val", "updated", "result", "failed", "not", "successful", "identified", "based", "count", "find", "fixed", "filled", "successfully", "f", "still", "letter", "normal", "null", "confirmed", "broken", "matched", "missing", "err", "temp", "finding", "got", "search", "built", "l", "changed", "true", "given", "first"]}}
{"id1": "14324112", "id2": "4973095", "code1": "    protected void innerProcess(CrawlURI curi) throws InterruptedException {\n        if (!curi.isHttpTransaction()) {\n            return;\n        }\n        if (!TextUtils.matches(\"^text.*$\", curi.getContentType())) {\n            return;\n        }\n        long maxsize = DEFAULT_MAX_SIZE_BYTES.longValue();\n        try {\n            maxsize = ((Long) getAttribute(curi, ATTR_MAX_SIZE_BYTES)).longValue();\n        } catch (AttributeNotFoundException e) {\n            logger.severe(\"Missing max-size-bytes attribute when processing \" + curi.getURIString());\n        }\n        if (maxsize < curi.getContentSize() && maxsize > -1) {\n            return;\n        }\n        String regexpr = \"\";\n        try {\n            regexpr = (String) getAttribute(curi, ATTR_STRIP_REG_EXPR);\n        } catch (AttributeNotFoundException e2) {\n            logger.severe(\"Missing strip-reg-exp when processing \" + curi.getURIString());\n            return;\n        }\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getHttpRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.addLocalizedError(this.getName(), e, \"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage());\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            digest = MessageDigest.getInstance(\"SHA1\");\n        } catch (NoSuchAlgorithmException e1) {\n            e1.printStackTrace();\n            return;\n        }\n        digest.reset();\n        String s = null;\n        if (regexpr.length() == 0) {\n            s = cs.toString();\n        } else {\n            Matcher m = TextUtils.getMatcher(regexpr, cs);\n            s = m.replaceAll(\" \");\n        }\n        digest.update(s.getBytes());\n        byte[] newDigestValue = digest.digest();\n        if (logger.isLoggable(Level.FINEST)) {\n            logger.finest(\"Recalculated content digest for \" + curi.getURIString() + \" old: \" + Base32.encode((byte[]) curi.getContentDigest()) + \", new: \" + Base32.encode(newDigestValue));\n        }\n        curi.setContentDigest(newDigestValue);\n    }\n", "code2": "    public Wget2(URL url, File f) throws IOException {\n        System.out.println(\"bajando: \" + url);\n        if (f == null) {\n            by = new ByteArrayOutputStream();\n        } else {\n            by = new FileOutputStream(f);\n        }\n        URLConnection uc = url.openConnection();\n        if (uc instanceof HttpURLConnection) {\n            leerHttp((HttpURLConnection) uc);\n        } else {\n            throw new IOException(\"solo se pueden descargar url http\");\n        }\n    }\n", "label": 0, "substitutes": {"innerProcess": [" outerprocess", " innerAccept", "middleprocess", " outerProcess", "innerAccept", "middleProcess", " innerprocess", "middleMethod", " outerAccept", " outerMethod", "middleAccept", " innerMethod", "innerprocess", "innerMethod"], "curi": ["funi", "cdu", "numi", "biri", " cri", "ucURI", "fcri", " cuni", "cui", "fcumi", "luni", "requuni", "ctURI", "nri", "ciri", "cacheui", "bdirectory", "ctiri", "cuni", "cURI", "lcri", "fui", "fri", "fcuri", "lciri", "cdirectory", "firi", "cuid", "CURI", "ldirectory", "ucuni", "Cui", "cri", "cachedu", "Cdu", "liri", "uciri", "cturi", "lURI", "lcouri", " cdirectory", "buri", "cacheURI", " couri", " cURI", "fcURI", "Couri", " ciri", "Curi", "requumi", "bURI", "cumi", "lcui", "requiri", "luri", "ctuid", " cumi", "ucuri", "requuri", " cuid", "nuri", " cdu", "Ciri", "couri", "lcURI", "luid", "furi", "nURI", "fURI", "lumi", " cui", "lcuri", "lri", "cacheuri", "Cri"], "maxsize": ["lastsize", " maxSize", "MaxSize", " maxscale", "totalscale", "maxaddress", " maxaddress", "maxSize", "minsize", " maxSIZE", "MAXname", "defaultize", "lastSize", "Maxize", "MAXsize", "defaultSize", "Maxsize", "minSize", "totalize", "MAXSize", "maxname", "maxize", "axSize", "defaultsize", "MAXSIZE", "MaxSIZE", "maxscale", "Maxscale", " maxize", "maxSIZE", "axize", "axsize", "minaddress", "totalSize", "totalsize", "Maxname", " maxname", "lastaddress"], "regexpr": ["rexpl", "requps", "rerePR", "egexps", "pereexpr", "requpr", "equPr", "resexpr", "rerexPr", "rexpp", "refplexpr", "reqpt", "reuxpl", "rexPr", "replexpp", "pegexexpr", "refplexPr", "equps", "replaypt", "replexpr", "rentaxpr", "reuxpr", "egexpect", "rexpr", "REqr", "reqr", "REgexor", "replexPr", "pegexpr", "refgexpp", "refplexpl", "replaypr", "regexps", "REgexr", "equpr", "regexPr", "rereexpr", "resexpect", "resexps", "regexor", "perePR", "reuxPr", "rerexpr", "regexexpr", "rerePr", "replayor", "rerexps", "rerexpect", "perePr", "refgexpr", "egexPr", "perepr", "REqpt", "replayr", "replexPR", "refplexpp", "egexpr", "requpect", "regexpect", "reqor", "REqpr", "regexpt", "regexpl", "REqor", "replexexpr", "regexr", "REgexpt", "regexPR", "replexpl", "refgexPr", "refgexpl", "rerepr", "regexpp", "requPr", "equpect", "resexPr", "rentaxPr", "reqpr", "pegexPr", "rentaxPR", "reuxpp", "REgexpr", "pegexPR", "rentaxexpr"], "cs": ["sc", "ca", "cas", "cus", "ctx", "sync", "qs", "ences", "cp", "ce", "cc", "bs", "cn", "cells", "rs", "ls", "ns", "cr", "cons", "lc", "ci", "cf", "css", "GC", "coll", "cache", "CS", "ks", "cos", "ras", "cm", "ches", "ds", "str", "cks", "tc", "wcs", "ch", "fs", "spec", "ces", "cl", "ins", "pc", "acts", "acks", "mc", "ics", "TS", "js", "ps", "acs", "gs", "ms", "Cs", "cms", "c", "ts", "ec"], "digest": ["signest", "shaEST", "digusher", "DigEST", "shaest", "returnester", "signEST", "diggest", "diger", "Diger", " digEST", "Digest", "returnest", " diger", "returnEST", "Digester", " digester", "signusher", "digester", "shaer", "returngest", "digEST", "Digher", " diggest", "digher", "Digusher", " digusher", "Diggest", "shaher", "signester", " digher"], "s": ["r", "S", "su", "details", "h", "p", "sl", "sync", "g", "n", "i", "summary", "strings", "cells", "ls", "ns", "t", "sb", "lines", "services", "params", "single", "states", "str", "f", "o", "sets", "session", "u", "b", "v", "groups", "w", "l", "ss", "d", "string", "js", "ps", "si", "ms", "sv", "ws", "c"], "m": ["mm", "mo", "r", "mac", "h", "p", "n", "g", "i", "t", "M", "arm", "fm", "um", "bm", "rm", "nm", "cm", "f", "ym", "sm", "imm", "dm", "b", "im", "v", "pm", "mi", "text", "tm", "l", "mc", "d", "gm", "ms", "am", "machine", "wm"]}}
{"id1": "22057083", "id2": "22410173", "code1": "    private void Connect() throws NpsException {\n        try {\n            client = new FTPClient();\n            client.connect(host.hostname, host.remoteport);\n            int reply = client.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(reply)) {\n                client.disconnect();\n                client = null;\n                com.microfly.util.DefaultLog.error_noexception(\"FTP Server:\" + host.hostname + \"refused connection.\");\n                return;\n            }\n            client.login(host.uname, host.upasswd);\n            client.enterLocalPassiveMode();\n            client.setFileType(FTPClient.BINARY_FILE_TYPE);\n            client.changeWorkingDirectory(host.remotedir);\n        } catch (Exception e) {\n            com.microfly.util.DefaultLog.error(e);\n        }\n    }\n", "code2": "    public static void copyFile(File source, File dest) throws IOException {\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            in.transferTo(0, in.size(), out);\n        } catch (FileNotFoundException fnfe) {\n            Log.debug(fnfe);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"Connect": ["Build", "New", "connect", "Conn", " Close", "Close", "Setup", "Host", "Init", "Sync", "Socket", "Construct", "Fail", "Login", "Run", "Open", "connected", "Client", "Subscribe", "Load", " Connection", "Create", "Config", "Remote", "Connection", "Connector", "Process", "Dial"], "client": ["request", "get", "clean", "ace", "connect", "service", "console", "cp", "host", "ce", "cell", "socket", "cn", "proxy", "cc", "default", "user", "parent", "cli", "ci", "core", "port", "server", "cache", "handler", "per", "conn", "open", "child", "connection", "code", "http", "resource", "cm", "pool", "ssl", "manager", "con", "secure", "cloud", "end", "util", "Client", "close", "grid", "lib", "api", "channel", "session", "local", "cl", "force", "pc", "call", "name", "co", "plugin", "friend", "remote", "project", "cod", "command", "config", "c"], "reply": ["request", "next", "error", "echo", " replies", "buffer", "ping", "ply", "sync", "query", "comment", "rc", "Reply", "address", "replace", "answer", "info", "result", "state", "connection", " response", "code", "response", "reason", "message", "ret", "send", "resp", "part", "post", "link", "prefix", "err", "status", "bot", "continue", "call", "respond", "related", "read", "dy", "repl"]}}
{"id1": "12066447", "id2": "23273706", "code1": "    protected void truncate(final File file) {\n        LogLog.debug(\"Compression of file: \" + file.getAbsolutePath() + \" started.\");\n        if (FileUtils.isFileOlder(file, ManagementFactory.getRuntimeMXBean().getStartTime())) {\n            final File backupRoot = new File(this.getBackupDir());\n            if (!backupRoot.exists() && !backupRoot.mkdirs()) {\n                throw new AppenderInitializationError(\"Can't create backup dir for backup storage\");\n            }\n            SimpleDateFormat df;\n            try {\n                df = new SimpleDateFormat(this.getBackupDateFormat());\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Invalid date formate for backup files: \" + this.getBackupDateFormat(), e);\n            }\n            final String date = df.format(new Date(file.lastModified()));\n            final File zipFile = new File(backupRoot, file.getName() + \".\" + date + \".zip\");\n            ZipOutputStream zos = null;\n            FileInputStream fis = null;\n            try {\n                zos = new ZipOutputStream(new FileOutputStream(zipFile));\n                final ZipEntry entry = new ZipEntry(file.getName());\n                entry.setMethod(ZipEntry.DEFLATED);\n                entry.setCrc(FileUtils.checksumCRC32(file));\n                zos.putNextEntry(entry);\n                fis = FileUtils.openInputStream(file);\n                final byte[] buffer = new byte[1024];\n                int readed;\n                while ((readed = fis.read(buffer)) != -1) {\n                    zos.write(buffer, 0, readed);\n                }\n            } catch (final Exception e) {\n                throw new AppenderInitializationError(\"Can't create zip file\", e);\n            } finally {\n                if (zos != null) {\n                    try {\n                        zos.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zip file\", e);\n                    }\n                }\n                if (fis != null) {\n                    try {\n                        fis.close();\n                    } catch (final IOException e) {\n                        LogLog.warn(\"Can't close zipped file\", e);\n                    }\n                }\n            }\n            if (!file.delete()) {\n                throw new AppenderInitializationError(\"Can't delete old log file \" + file.getAbsolutePath());\n            }\n        }\n    }\n", "code2": "    public String[][] getProjectTreeData() {\n        String[][] treeData = null;\n        String filename = dms_home + FS + \"temp\" + FS + username + \"adminprojects.xml\";\n        String urlString = dms_url + \"/servlet/com.ufnasoft.dms.server.ServerGetAdminProjects\";\n        try {\n            String urldata = urlString + \"?username=\" + URLEncoder.encode(username, \"UTF-8\") + \"&key=\" + URLEncoder.encode(key, \"UTF-8\") + \"&filename=\" + URLEncoder.encode(username, \"UTF-8\") + \"adminprojects.xml\";\n            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\n            factory.setValidating(false);\n            DocumentBuilder parser = factory.newDocumentBuilder();\n            URL u = new URL(urldata);\n            DataInputStream is = new DataInputStream(u.openStream());\n            FileOutputStream os = new FileOutputStream(filename);\n            int iBufSize = is.available();\n            byte inBuf[] = new byte[20000 * 1024];\n            int iNumRead;\n            while ((iNumRead = is.read(inBuf, 0, iBufSize)) > 0) os.write(inBuf, 0, iNumRead);\n            os.close();\n            is.close();\n            File f = new File(filename);\n            InputStream inputstream = new FileInputStream(f);\n            Document document = parser.parse(inputstream);\n            NodeList nodelist = document.getElementsByTagName(\"proj\");\n            int num = nodelist.getLength();\n            treeData = new String[num][3];\n            for (int i = 0; i < num; i++) {\n                treeData[i][0] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"pid\"));\n                treeData[i][1] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"ppid\"));\n                treeData[i][2] = new String(DOMUtil.getSimpleElementText((Element) nodelist.item(i), \"p\"));\n            }\n        } catch (MalformedURLException ex) {\n            System.out.println(ex);\n        } catch (ParserConfigurationException ex) {\n            System.out.println(ex);\n        } catch (NullPointerException e) {\n        } catch (Exception ex) {\n            System.out.println(ex);\n        }\n        return treeData;\n    }\n", "label": 1, "substitutes": {"truncate": ["tratenator", "trunational", "trrenate", "trunator", "trunate", "truncation", "autuncational", "autuncation", "tratenational", "autatenation", "autuncator", "truncator", "tratenation", "autatenator", "tratenate", "autuncate", "autatenational", "autatenate", "trrenator", "truncational", "trrenation", "trrenational", "trunation"], "file": ["get", "image", "db", "one", "stream", "full", "files", "queue", "class", "object", "future", "e", "parent", "page", "directory", "handler", "archive", "File", "cache", "address", "per", "plus", "info", "or", "format", "connection", "http", "path", "resource", "fp", "single", "io", "time", " File", "out", "function", "FILE", "ile", "line", "f", "url", "binary", "this", "base", "model", "zip", "data", "type", "log", "local", "it", "document", "name", "l", "body", "string", "folder", "uri", "current", "source", "filename"], "backupRoot": ["backupsPath", "backUproot", "backupsRoot", "backdownRoot", "backuproot", "backdownroot", "Backbackroot", "backupDirectory", "backUpDir", "backflowroot", "backureDirectory", "frontdownroot", "backflowDir", "frontdownFolder", "frontupDir", "BackureRoot", "backbackroot", "backbaseDirectory", "backupDir", "BackdownRoot", "BackureDirectory", "frontuproot", "backupHome", "backbackDir", "backupFile", "Backuproot", "BackupHome", "backUpFolder", "backflowRoot", "backbaseRoot", "backbackFile", "backUpRoot", "BackupRoot", "backureDir", "BackupDirectory", "backdownDir", "backdownHome", "backbaseroot", "backureRoot", "backbackHome", "backdownFolder", "backupsDir", "backdownDirectory", "backbasePath", "BackupPath", "backureHome", "backflowFile", "frontupFolder", "backdownFile", "frontdownRoot", "BackbackRoot", "frontupRoot", "frontdownDir", "backupsFolder", "BackdownDirectory", "backbackDirectory", "BackdownPath", "backupsroot", "backupPath", "BackbackFile", "backupFolder", "BackureDir", "BackbackDir", "backdownPath", "Backdownroot", "BackupFile", "backupsDirectory", "backbackRoot", "BackupDir", "BackureHome"], "df": ["db", "pdf", "fr", "de", "bf", "def", "flow", "fd", "dict", "cf", "pd", "xf", "md", "sf", "fe", "dn", "format", "dc", "fb", "af", "deb", "fp", "dt", "io", "raf", " def", "fn", "fc", "ds", "f", "fs", "CF", "dm", "data", "dl", "DF", "di", "d", "tf", "da", "dq", "dd", "func", "dp"], "date": ["db", "stage", "atom", "m", "j", "sync", "fee", "form", "output", "pre", "use", "created", "input", "year", "version", "bug", "valid", "rule", "complete", "open", "diff", "updated", "module", "format", "code", "time", "day", "D", " Date", "dt", "message", "modified", "work", "dat", "out", "value", "str", "ale", "days", "x", "min", "ge", "url", "update", "data", "type", "pe", "log", "tag", "ate", "dose", "name", "custom", "d", "string", "age", "style", "Date", "re", "back", "create", "dates"], "zipFile": ["zfile", "zFiles", "ressModel", "ZipFiles", "ZipEntry", " zipFiles", "sqlfile", "zipfile", "ZipFile", "zFile", "sqlModel", "Zipfile", "zEntry", "ressfile", "zipEntry", " zipfile", "ressFile", "zipFiles", "zModel", "zipModel", "zSection", "ressSection", "zipSection", "sqlSection", "sqlFile", " zipEntry"], "zos": ["os", "ils", "dylib", "inos", "nox", "dos", "zag", "zb", "proxy", "uz", "ls", "lins", "ses", "han", "ros", "zon", "css", "iffs", "zan", "address", "zn", "bitcoin", "zy", "los", "zona", "zx", "tz", "liquid", "zi", "cos", "zero", "bes", "jas", "hess", "exit", "ssl", "z", "nz", "closure", "budget", "rez", "osi", "ZA", "zo", "cash", "zar", "zen", "zip", "eros", "chini", "zes", "her", "las", "zik", "ozo", "zer", " sands", "fits", "ops", "settings", "forge", "bos", "zzy", "obb", "robe", "js", "gz", "outs", "zh", "kos", "webkit", "asio", "zl"], "fis": ["lis", "flisp", "rafis", " fiz", "viz", " fias", " fos", "vis", "bis", "infias", "flris", "bisl", "Fisl", " fisl", "fiz", "fias", "infis", " fris", "flias", "rafris", "Fos", "rafiss", "infils", "flis", "fliss", "rafias", "infiss", " fiss", "fisp", "infits", "biss", "flids", "lids", "fids", "vits", "fris", " fils", "fisl", "infids", "fiss", "Fias", "lias", "fits", " fits", "fils", "liss", "bos", " fisp", "fos", "Fris", "infiz", "Fis", "vils", "Fisp", "Fiss"], "entry": ["next", "r", "image", "auto", "the", "ace", "de", "card", "obj", "term", "ie", "element", "cel", "key", "cell", "comment", "feed", "e", "lc", "ry", "archive", "server", "address", "per", "info", "ui", "or", "array", "exp", "index", "se", "z", "row", "ge", "zo", "letter", "zip", "data", "her", "offset", "it", "record", "ries", "so", "Entry", "style", "reader", "ion", " Entry", "si", "and", "uri", "extra", "add", "event"], "buffer": ["position", "pad", "writer", "bytes", "shape", "batch", "FFER", "queue", "transfer", "comment", "feed", "slice", "sequence", "reference", "bb", "page", "Buffer", "cache", "server", "address", "result", "padding", "beta", "buff", "row", "uffer", "available", "iter", "buf", "binary", "channel", "device", "null", "data", "b", "border", "number", "wave", "memory", "reader", "header", "seed", "vector", "flush", "layer", "length"], "readed": ["readered", "readED", "intended", "bootable", " ReadED", "inputned", " readended", " readered", "readized", "inted", "bootED", " readED", " readable", "readable", "inputled", " Readered", "readned", " Readed", " readized", "inputED", "bootered", " readned", "textended", " Readable", " Readled", " Readned", "texted", "readended", "intED", "textized", " readled", "booted", "textED", "intized", "inputed", "readled"]}}
{"id1": "3024992", "id2": "14317425", "code1": "    @Test\n    public void testCopy_readerToWriter_nullIn() throws Exception {\n        ByteArrayOutputStream baout = new ByteArrayOutputStream();\n        OutputStream out = new YellOnFlushAndCloseOutputStreamTest(baout, true, true);\n        Writer writer = new OutputStreamWriter(baout, \"US-ASCII\");\n        try {\n            IOUtils.copy((Reader) null, writer);\n            fail();\n        } catch (NullPointerException ex) {\n        }\n    }\n", "code2": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "label": 1, "substitutes": {"testCopy_readerToWriter_nullIn": ["testCopy_readerToWriter2nullIn", "testCopy_readerToWriter2Nulls", "testCopy_readerToWriter2NullIn", "testCopy_readerToWriter_writers", "testCopy_readerToWriter_null_", "testCopy_readerToWriter_stdin", "testCopy_readerToWriter_Nulls", "testCopy_readerToWriter_Null_", "testCopy_readerToWriter2nullin", "testCopy_readerToWriter_nullin", "testCopy_readerToWriter_writerin", "testCopy_readerToWriter_writer_", "testCopy_readerToWriter2Nullin", "testCopy_readerToWriter_NullIn", "testCopy_readerToWriter_writerIn", "testCopy_readerToWriter_std_", "testCopy_readerToWriter2null_", "testCopy_readerToWriter2nulls", "testCopy_readerToWriter_Nullin", "testCopy_readerToWriter_stdIn", "testCopy_readerToWriter2Null_", "testCopy_readerToWriter_stds", "testCopy_readerToWriter_nulls"], "baout": ["Baash", "aeOUT", "BAin", "bonin", "baouts", "BaOut", "BAout", "BAouter", " bain", "bain", "aeouter", " baOut", "Bain", "baOUT", "baash", "bonash", "Baio", "baio", "BAio", "BaOUT", "BAOut", "Baout", "BAouts", "baouter", "Baouter", "bonout", "bonio", "aeout", " baouts", "baOut", "Baouts", "BAOUT", "aeOut", "BAash"], "out": ["Out", "r", "in", "buffer", "flow", "output", "class", "s", "write", "copy", "Writer", "array", "io", "line", "file", "Output", "null", "err", "er", "test", "reader", "outs", "outer", "OUT", "able"], "writer": ["r", "in", "buffer", "worker", "entry", "output", "class", "write", "copy", "ee", "Writer", "pointer", "writers", "io", "work", "file", "riter", "x", "rw", "letter", "null", "unit", "data", "temp", "wer", "builder", "her", "player", "er", "wa", "w", "driver", "writ", "reader", "outer", "writing", "source", "RW"]}}
{"id1": "841724", "id2": "13783549", "code1": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"readAndRewrite": ["readandrewrites", "readAndRewwrite", "readAndSwwrite", "readAndrewrites", "readAndRebrite", "readAndRebrap", "readAndRebrites", "readandrewrap", "readandRewwrite", "readAndSwrites", "readandRewrites", "readAndRewrap", "readAndrewrap", "readAndrewwrite", "readAndrewrite", "readAndRebwrite", "readAndSwrite", "readandrewrite", "readandRewrap", "readandrewwrite", "readAndSwrap", "readAndRewrites", "readandRewrite"], "inFile": ["Infile", " inFilename", "loginFiles", "inSourceFile", "loginFile", "loginFilename", "oldFiles", "loginfile", "outFilename", "outFiles", "inFilename", "oldFile", "outfile", "outSourceFile", "InSourceFile", " infile", " inFiles", "InFiles", "oldfile", "inputfile", "infile", "inputFiles", "inputFilename", "inputFile", "oldFilename", "InFile", "inFiles", " inSourceFile"], "outFile": ["processFILE", "newFile", "newDir", "OutDir", "outStream", "outputFILE", "processPlace", "outputFile", "processFile", "outputFilename", "offPlace", "Outfile", " outDir", " outfile", "offFilename", "newfile", "thisfile", "outFILE", " outStream", "outfile", "processFilename", "exFile", "thisFILE", "outPlace", "thisFilename", "newStream", "offFILE", "OutFile", "outDir", "offFile", "outputPlace", "exfile", "exFilename", "thisFile", "exFILE", "outputfile", "OutStream", "outFilename"], "iis": [" iris", " iIs", "Iis", "iiis", "ciIs", "iiIS", "iniIs", "iIs", "iiIs", "iniIS", "ciris", "ciais", " iIS", "iiiss", "ciis", "iniris", "iris", "iniiss", " iiss", "Iais", "iIS", "iiss", "iniis", " iais", "Iiss", "iais", "ciiss", "ciIS", "iiris", "IIS"], "dcmParser": ["dpmPlugin", "dCMparser", "dmPlugin", "dmoduleParser", " dcmparser", "dpmarser", " dpmarser", "fcmParser", "dmmParser", " dcmPar", "dcmPar", "dpmparser", "dmcarser", "dpmJar", "dCMHandler", " dcmReader", "dmodulePlugin", "dkmHelper", " dpmPolicy", "DcmParser", "DcmJar", "dmoduleReader", "dbmParser", "dpmPar", "fpmParser", " dpmHelper", " dcmLanguage", "dcmLoader", "dkmParser", "fcmHandler", "dbmPolicy", "dcmarser", "dhemInstallation", "dhemReader", " dpmLanguage", "DcmReader", "DcmInstallation", "dcrPlugin", "dmmLoader", "dcmPlugin", "dpmInstallation", "dcrReader", " dcmJar", "fpmHandler", " dcrPlugin", "dcrJar", "dpmReader", "dbmPlugin", " dpmParser", "dmcPar", "dmcJar", " dcmHelper", "dcrParser", "dmLoader", "dcmparser", "dmissionReader", "dpmLoader", "dhemParser", "dmmparser", "dmissionLanguage", "fcmReader", "dcrLoader", " dpmJar", "dCMLoader", " dpmReader", " dpmPar", "dmoduleJar", "dmissionPlugin", " dcrReader", " dcmarser", "dCMReader", "dpmLanguage", "fpmparser", "dcmInstallation", "dmmPlugin", "dcmLanguage", "dpmHelper", "dcrPar", " dpmparser", "dkmPolicy", " dpmPlugin", "dkmPlugin", "dmissionParser", "fpmReader", "dCMParser", " dcrParser", "dmoduleparser", "dmReader", "dbmHelper", "dhemJar", " dpmLoader", "dCMPlugin", "dmParser", "dcmHelper", "dcmReader", "dcmPolicy", "dpmHandler", "dcrarser", " dcmPlugin", " dcmLoader", "dmcParser", "dcmHandler", " dcrLoader", "dpmParser", "dcmJar", "fcmparser", " dcmPolicy", "dpmPolicy"], "ds": ["vals", "db", "os", "ils", "details", "points", "tx", "sync", "qs", "src", "is", "Db", "bs", "s", "dd", "cs", "asi", "rs", "xs", "ls", "ns", "nas", "pd", "ros", "dds", "conn", "DS", "ks", "dr", "iss", "ads", "dc", "tes", "services", "ants", "ras", "dt", "df", "cdn", "gd", "ts", "icks", "ays", "des", "data", "session", "eps", "drivers", "ins", "ys", "di", "vs", "utils", "amps", "ss", "d", "js", "ps", "gs", "ld", "parts", "sys", "da", "Os", "ws", "dat", "uds", "Ds"], "pdReader": ["dsLoader", "ddReader", "hdRead", "dsWriter", "pdRead", "pdreader", "pdStream", "pbReader", "hdLoader", "ddRunner", "pcReader", "hdReader", "dsreader", "xdWriter", "pbLoader", "pcLoader", "xdReader", "xdRead", "pbStream", "pdLoader", "pbRunner", "ddLoader", "hdRunner", "pcWriter", "xdreader", "pdRunner", "ddStream", "dsRead", "hdStream", "pcRead", "hdWriter", "dsReader", "hdreader"], "out": ["Out", "image", "sync", "flow", "key", "s", "parent", "ex", "conn", "to", "word", "at", "director", "store", "base", "builder", "oder", "w", "name", "outs", "OUT", "db", "client", "full", "user", "page", "cache", "diff", "array", "inner", "io", "file", "part", "down", "dot", "err", "over", "net", "again", "as", "lock", "external", "inc", "auto", "in", "writer", "output", "order", "object", "copy", "cli", "child", "result", "ext", "ssl", "line", "manager", "url", "lib", "o", "null", "pass", "doc", "password", "point", "outer", "dev", "layer", "up", "device", "term", "obj", "default", "write", "group", "code", "connection", "exp", "later", "img", "exec", "login", "session", "data", "temp", "model", "with", "her", "co", "list", " in", "sys", "gen"], "dcmEncParam": ["dcmDecParameter", "dcmArchParameter", "dcmArchArg", "dcmEncPar", "dcmSecParam", "dcmArchParam", "dcmElPar", "dcmSecPar", "dcmEnPart", "dcmElParameter", "dcmEncType", "dcmEncParameter", "dcmEstParam", "dcmEncArg", "dcmDecPar", "dcmEstParameter", "dcmEnArg", "dcmEstType", "dcmElParam", "dcmElType", "dcmDecPart", "dcmDecParam", "dcmSecType", "dcmEnType", "dcmEstPar", "dcmSecPart", "dcmEnPar", "dcmDecArg", "dcmDecType", "dcmEncPart", "dcmEnParameter", "dcmEnParam"], "pdWriter": ["ddWrite", "ddReader", "ddOutput", "dpWrite", "dsWriter", "PDWriting", "pdOutput", "hdWrite", "PDWrite", "dpReader", "dpWriting", "dsWrite", "hdReader", "PDReader", "htReader", "dsOutput", "PDWriter", "pdWrite", "pdWriting", "htWriting", "ddWriter", "htWrite", "htWriter", "hdWriter", "dsReader", "dpWriter", "hdOutput"]}}
{"id1": "7087108", "id2": "8917658", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {\n        String path = request.getPathTranslated().substring(0, request.getPathTranslated().length() - request.getPathInfo().length()) + request.getServletPath() + request.getPathInfo();\n        File file = new File(path);\n        if (file.exists()) {\n            FileInputStream in = new FileInputStream(file);\n            IOUtils.copyLarge(in, response.getOutputStream());\n            in.close();\n        }\n    }\n", "code2": "    public static void copyAll(URL url, Writer out) {\n        Reader in = null;\n        try {\n            in = new InputStreamReader(new BufferedInputStream(url.openStream()));\n            copyAll(in, out);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            close(in);\n        }\n    }\n", "label": 0, "substitutes": {"doGet": ["processDownload", "processGET", "doGET", " doGET", " doPut", "doPut", "doDownload", "didGET", "didPut", "processGet", "processPut", "didGet", " doDownload", "didDownload"], "request": ["error", "client", "buffer", "self", "query", "host", "view", "object", "use", "context", "user", "input", "instance", "version", "parent", "route", "server", "json", "complete", "child", "info", "result", "target", "connection", "http", "resource", "report", "message", "xml", "url", "req", "forward", "this", "model", "data", "type", "builder", "subject", "application", "method", "name", "Request", "external", "reader", "project", "string", "web", "QUEST", "uri", "event", "current", "create", "config", "condition"], "response": ["image", "client", "writer", "service", "output", "reply", "view", "object", "version", "reference", "page", "server", "json", "cache", "example", "result", "connection", "content", "http", "resource", "message", "report", "results", "Response", "out", "resp", "model", "collection", "status", "application", "wave", "method", "document", "site", "remote", "respond", "body"], "path": ["image", "PATH", "p", "key", "output", "pattern", "object", "route", "id", "directory", "cache", "info", "format", "Path", "location", "content", "http", "message", "resource", "index", "out", "value", "config", "dir", "url", "base", "data", "text", "method", "name", "ath", "string", "filter", "point", "folder", "uri", "filename"], "file": ["image", "h", "full", "files", "up", "class", "socket", "object", "use", "feed", "route", "directory", "handler", "File", "rule", "fe", "info", "to", "child", "connection", "http", "resource", "fp", "out", "function", "FILE", "work", "part", "dir", "f", "url", "lib", "base", "zip", "data", "pe", "b", "log", "local", "it", "name", "l", "le", "folder", "uri", "lock", "source", "filename"], "in": ["r", "pin", "inn", "stream", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "copy", "thin", "id", "din", "ax", "lin", "inner", "resource", "nin", "out", "ini", "con", "kin", "rin", "f", "binary", "serv", "login", "data", "ac", "b", "it", "ins", "bin", "In", "reader", "IN", "as", "win", "source", "c", "inc"]}}
{"id1": "23035537", "id2": "22801734", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "    private static void setup() throws Exception {\n        String path = Webcam.class.getProtectionDomain().getCodeSource().getLocation().getFile();\n        File jarFile = new File(URLDecoder.decode(path, \"UTF-8\") + \"/Hanasu.jar\");\n        if (!jarFile.exists()) jarFile = new File(\"/home/marc/Virtual Machine/Hanasu.jar\");\n        File f = File.createTempFile(\"tempabca\", \"bdfafad\");\n        f.delete();\n        f.mkdir();\n        String parent = f.getAbsolutePath() + \"/\";\n        byte[] buf = new byte[1024];\n        ZipInputStream zipinputstream = null;\n        ZipEntry zipentry;\n        zipinputstream = new ZipInputStream(new FileInputStream(jarFile));\n        zipentry = zipinputstream.getNextEntry();\n        while (zipentry != null) {\n            String entryName = zipentry.getName();\n            if (entryName.startsWith(\"native\")) {\n                int n;\n                FileOutputStream fileoutputstream;\n                File newFile = new File(parent + entryName);\n                if (zipentry.isDirectory()) {\n                    newFile.mkdirs();\n                    zipentry = zipinputstream.getNextEntry();\n                    continue;\n                }\n                fileoutputstream = new FileOutputStream(newFile);\n                while ((n = zipinputstream.read(buf, 0, 1024)) > -1) fileoutputstream.write(buf, 0, n);\n                fileoutputstream.close();\n                zipinputstream.closeEntry();\n            }\n            zipentry = zipinputstream.getNextEntry();\n        }\n        zipinputstream.close();\n        String arch = \"\";\n        boolean x64 = false;\n        for (String key : keys) {\n            String property = System.getProperty(key);\n            if (property != null) {\n                x64 = (property.indexOf(\"64\") >= 0);\n            }\n        }\n        if (JPTrayIcon.isUnix()) {\n            if (x64) arch = \"linux-amd64\"; else arch = \"linux-x86\";\n        }\n        if (JPTrayIcon.isWindows()) {\n            System.out.println(\"Arch: \" + System.getProperty(\"sun.arch.data.model\"));\n            if (x64 && !System.getProperty(\"sun.arch.data.model\").equals(\"32\")) arch = \"win64-amd64\"; else arch = \"win32-x86\";\n        }\n        if (JPTrayIcon.isMac()) arch = \"macosx-universal\";\n        System.out.println(\"Using native/\" + arch + \"/\");\n        addLibraryPath(parent + \"native/\" + arch + \"/\");\n    }\n", "label": 0, "substitutes": {"getContent": ["readContent", "getContents", "readcontent", "createContents", "createcontent", "readContents", "getBody", "createContent", "getcontent", "createBody", "postcontent", "postBody", "readBody", "postContents", "postContent"], "userId": ["messageName", " userName", "userPath", " userOr", " userID", "USERName", "UserID", "userID", "userOr", "UserName", "USEROr", "USERId", " userPath", "UserPath", "USERPath", "UserId", "UserOr", "messageId", "messageID", "userName"], "latestMsgId": ["lastMessageId", " latestMsgTime", "latestChanId", "lastMsgid", " latestmsgTime", "latestUserId", "latestmsgID", "latestmsgId", " latestmsgId", "latestMsgTime", "latestChanID", "latestUserID", "latestMessageId", "latestChanid", "latestChanTime", "latestMessageTime", " latestMsgID", "lastMessageID", "latestMessageid", "latestMessageID", "latestmsgTime", "latestUserid", " latestMsgid", " latestmsgID", "latestMsgID", "lastMsgId", "lastMessageid", "latestMsgid", "latestmsgid", " latestmsgid", "lastMsgID"], "targetUrl": ["TargetURL", "sourcePage", " targeturl", "Targeturl", "targetURL", " targetURL", " targetUr", " targetPage", "targetUr", "targeturl", "TargetPage", "sourceurl", "sourceURL", "TargetUr", "sourceUr", "TargetUrl", "targetPage", "sourceUrl"], "url": ["image", "r", "client", "sl", "stream", "i", "host", "feed", "user", "id", "page", "server", "address", "connection", "http", "location", "URL", "path", "resource", "ssl", "file", "link", "f", "Url", "api", "base", "channel", "data", "download", "b", "l", "browser", "string", "uri", "window", "source", "www"], "in": ["get", "r", "image", "m", "query", "inn", "stream", "isin", "gin", "i", "is", "socket", "s", "load", "input", "arin", "din", "inas", "ax", "a", "inner", "resource", "nin", "xml", "out", "ini", "raw", "kin", "file", "pass", "serv", "login", "data", "err", "b", "ins", "record", "wave", "bin", "In", "reader", "string", "IN", "as", "again", "source", "inc"], "list": ["la", "detail", "batch", "tx", "tree", "entry", "all", "queue", "i", "view", "chain", "sequence", "dict", "parse", "LIST", "parent", "section", "lc", "cli", "id", "coll", "server", "json", "info", "group", "result", "listed", "array", "li", "lp", "pool", "xml", "set", "data", "live", "test", "collection", "cl", "lists", "language", "record", "document", "table", "l", "string", "item", "join"], "parser": ["writer", "p", "paragraph", "worker", "class", "parse", "parent", "Parser", "handler", "json", "per", "info", "ler", "rss", "a", "php", "http", "lp", "xml", "director", "util", "api", "data", "system", "builder", "player", "loader", "er", "collection", "jack", "language", "arser", "document", "processor", "plugin", "reader", "command", "layer"], "dao": ["adao", "Dosa", " daos", " dala", "adosa", "adaos", "idao", "idaba", " daba", "Dao", "dala", "daos", "Daos", "idaos", "daba", "datao", "adala", "datosa", "idosa", " dosa", "dataos", "datala", "dosa", "Daba"]}}
{"id1": "8087001", "id2": "21999120", "code1": "    public static String generateStackHashKey() {\n        Exception e = null;\n        try {\n            throw new Exception();\n        } catch (Exception ex) {\n            e = ex;\n        }\n        MessageDigest digest;\n        try {\n            digest = java.security.MessageDigest.getInstance(\"MD5\");\n            digest.update(getStackTrace(e).getBytes());\n            byte[] hash = digest.digest();\n            String rtn = Base64.encode(new String(hash));\n            if (keys.contains(rtn)) {\n                return generatedIterStackHashKey(rtn);\n            }\n            keys.add(rtn);\n            return rtn;\n        } catch (NoSuchAlgorithmException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n", "code2": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "label": 1, "substitutes": {"generateStackHashKey": ["generatestackhashkey", "generatestackHashKey", "generatestackHashString", "generateStackhashKey", "generateStackHeaderString", "generateStackHashkey", "generateStackHeaderKey", "generateStackHashString", "generatestackhashKeys", "generatestackHashKeys", "generateStackHashKeys", "generatestackhashString", "generateStackhashKeys", "generateStackHeaderKeys", "generateStackhashString", "generateStackHeaderkey", "generatestackHashkey", "generateStackhashkey", "generatestackhashKey"], "e": ["r", "error", "ace", "m", "h", "p", "ed", "oe", "n", "ie", "element", "el", "ee", "enter", "ex", "ze", "t", "es", "Exception", "fe", "ef", "a", "se", "esi", "E", "exc", "x", "ev", "f", "ception", "en", "this", "est", "o", "exec", "err", "pe", "b", "er", "ele", "he", "me", "et", "d", "body", "ae", "event", "ea", "c", "ec"], "digest": [" digested", " Digator", "mdester", "digature", "digate", " digenge", " Digest", "logge", "digusher", "mdenge", "mdusher", "mdest", "digenge", "logher", "digator", "diger", "Digator", "Diger", "mder", "Digest", "Signature", "logest", " digge", "Digge", "Signester", "logester", " digator", " diger", "decate", "Digester", " digester", " digher", "digge", "decature", "digester", "mdature", "Signest", "mdate", "decest", "Digher", "mdested", "Digenge", "digher", "decester", "Digusher", "digested", " digusher", "Signate", "Digested", " Digester", " Digested"], "hash": ["mac", "image", "ha", "h", "dig", "ph", "ash", "key", "history", "sh", "result", "code", "sum", "array", "message", "rh", "value", "Hash", "build", "ashes", "bh", "f", "dot", "base", "data", "her", "b", "v", "sha", "text", "total", "body", "string", "header", "kh", "hed", "hex"], "rtn": ["latn", "rtN", "retn", "RTnin", "rtnn", "RTN", "rtb", "gtn", "rdn", "ntn", "rtnin", "retN", "RTns", "txn", "rdns", "vrns", "ortne", "txc", "ntpn", "latne", "rtc", "RTb", "RTn", "latns", "RTpn", "gtb", "gtN", "rdb", "RTnn", "ntb", "retb", "vrn", "RTc", "ortnn", "vrnn", "ntN", "retns", "rtns", "gtpn", "latN", "ntnin", "RTne", "rtpn", "vrN", "txN", "rtne", "ortn", "txnin", "ntc", "rdN", "vrne", "ortN"]}}
{"id1": "14758866", "id2": "2199604", "code1": "    public synchronized InputStream getResourceAsStream(String name) {\n        InputStream inputStream = null;\n        BufferedInputStream in = null;\n        BufferedOutputStream out = null;\n        try {\n            URL url = getResource(name);\n            String remoteName = url.toExternalForm();\n            String localName = (String) cacheHashtable.get(remoteName);\n            if (localName != null) {\n                System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                return new FileInputStream(localName);\n            }\n            String host = url.getHost();\n            String prot = url.getProtocol();\n            int port = url.getPort();\n            File cacheFile = new File(cacheDir, prot + File.separator + host + File.separator + \"port\" + (port == -1 ? \"\" : Integer.toString(port)) + File.separator + name);\n            cacheFile = new File(cacheFile.getCanonicalPath());\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"Comparing \\\"\" + localName + \"\\\"...\");\n            URLConnection urlConnection = url.openConnection();\n            if (cacheFile.exists()) {\n                urlConnection.setIfModifiedSince(cacheFile.lastModified());\n            }\n            if (urlConnection instanceof HttpURLConnection) {\n                HttpURLConnection httpURLConnection = (HttpURLConnection) urlConnection;\n                httpURLConnection.setFollowRedirects(true);\n                httpURLConnection.setRequestMethod(\"GET\");\n                int responseCode = httpURLConnection.getResponseCode();\n                System.out.println(httpURLConnection.getResponseMessage() + \", \" + httpURLConnection.getContentLength() + \" bytes\" + \", \" + new Date(httpURLConnection.getDate()) + \", \" + new Date(httpURLConnection.getLastModified()));\n                if (responseCode != HttpURLConnection.HTTP_OK) {\n                    return null;\n                }\n            }\n            inputStream = urlConnection.getInputStream();\n            if (inputStream == null) return null;\n            if (cacheFile.exists()) {\n                long lastModified = urlConnection.getLastModified();\n                if ((lastModified > 0) && (lastModified < cacheFile.lastModified())) {\n                    inputStream.close();\n                    cacheHashtable.put(remoteName, localName);\n                    System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n                    return new FileInputStream(cacheFile);\n                }\n            }\n            File parentFile = new File(cacheFile.getParent());\n            parentFile.mkdirs();\n            localName = cacheFile.getCanonicalPath();\n            System.out.println(\"CACHING \\\"\" + localName + \"\\\"...\");\n            in = new BufferedInputStream(inputStream);\n            out = new BufferedOutputStream(new FileOutputStream(cacheFile));\n            int i;\n            while ((i = in.read()) > -1) out.write(i);\n            out.close();\n            in.close();\n            cacheHashtable.put(remoteName, localName);\n            System.out.println(\"Retrieving \\\"\" + localName + \"\\\"...\");\n            return new FileInputStream(localName);\n        } catch (Exception ex) {\n            try {\n                inputStream.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                in.close();\n            } catch (Exception ex1) {\n            }\n            try {\n                out.close();\n            } catch (Exception ex1) {\n            }\n            ex.printStackTrace();\n            return null;\n        }\n    }\n", "code2": "    private static void unzipEntry(ZipFile zipfile, ZipEntry entry, File outputDir) throws IOException {\n        if (entry.isDirectory()) {\n            createDir(new File(outputDir, entry.getName()));\n            return;\n        }\n        File outputFile = new File(outputDir, entry.getName());\n        if (!outputFile.getParentFile().exists()) {\n            createDir(outputFile.getParentFile());\n        }\n        BufferedInputStream inputStream = new BufferedInputStream(zipfile.getInputStream(entry));\n        BufferedOutputStream outputStream = new BufferedOutputStream(new FileOutputStream(outputFile));\n        try {\n            IOUtils.copy(inputStream, outputStream);\n        } finally {\n            outputStream.close();\n            inputStream.close();\n        }\n    }\n", "label": 1, "substitutes": {"getResourceAsStream": ["getResourceToString", "getResourcesasFile", "getResourceasFile", "getResourceToStream", "getResourceAsString", "getResourceasSteam", "getResourcesasStream", "getResourceASStream", "getResourceToFile", "getResourceasString", "getResourceASSteam", "getResourceASFile", "getResourceasStream", "getResourcesAsSteam", "getResourceToSteam", "getResourcesasSteam", "getResourceAsSteam", "getResourceASString", "getResourcesAsStream", "getResourcesasString", "getResourceAsFile", "getResourcesAsFile", "getResourcesAsString"], "name": ["domain", "ip", "size", "full", "key", "object", "version", "parent", "id", "cache", "address", "ame", "info", "alias", "connection", "location", "path", "resource", "time", "word", "file", "part", "str", "NAME", "config", "prefix", "base", "data", "type", "Name", "names", "memory", "remote", "string", "named", "hash", "uri", "source", "filename", "username"], "inputStream": ["inputBody", "inputChannel", "Inputstream", " inputSteam", "InputChannel", "pullConnection", "InputBody", "pullChannel", "cacheFeed", " inputConnection", "InputSteam", " inputstream", " inputFeed", "inputConnection", "inputSteam", "cachestream", "InputStream", "currentBody", "cacheSteam", "currentstream", " inputChannel", "pullStream", "InputFeed", " inputBody", "currentSteam", "currentStream", "cacheStream", "InputConnection", "pullSteam", "inputFeed", "inputstream"], "in": ["Out", "r", "image", "m", "buffer", "src", "socket", "input", "din", "inner", "path", "rec", "exec", "re", "data", "err", "log", "ins", "bin", "In", "reader", "IN", "read", "source", "c"], "out": ["Out", "error", "r", "client", "buffer", "writer", "obj", "query", "msg", "up", "key", "output", "object", "pre", "user", "copy", "ger", "cli", "page", "ex", "println", "server", "cache", "conn", "group", "state", "ref", "params", "io", "pool", "line", "proc", "file", "raw", "part", "debug", "data", "err", "temp", "log", "bar", "inter", "bin", "list", "point", "sys", "outs", "lock", "cmd", "gen", "flush", "dump", "outer", "OUT", "window"], "url": ["r", "image", "client", "service", "sl", "left", "stream", "full", "socket", "object", "feed", "user", "route", "page", "server", "cache", "address", "coll", "open", "loc", "bel", "result", "connection", "http", "location", "URL", "resource", "path", "pull", "ob", "li", "ssl", "file", "f", "Url", "api", "base", "update", "data", "download", "gl", "log", "b", "rel", "org", "https", "l", "browser", "remote", "string", "web", "ur", "uri", "event", "source", "config"], "remoteName": ["fullName", " remotePath", "remoteKey", "RemoteUrl", "fullKey", "remoteUrl", "localKey", "fullPath", " remoteKey", "localUrl", " remoteUrl", "remotename", "RemotePath", " remotename", "RemoteName", "remotePath", "localPath", "Remotename", "fullname", "RemoteKey"], "localName": ["globalString", "localString", "globalFile", "remoteFile", " localFile", "globalName", "remoteKey", "remoteUrl", "localKey", "LocalName", " localKey", "localname", "Localname", "locString", "locPath", "globalname", "LocalPath", "localUrl", "LocalKey", " localString", "globalPath", " localname", " localPath", "remotename", "locname", "remotePath", "locUrl", "localPath", " localUrl", "remoteString", "localFile", "globalKey", "locName"], "host": ["domain", "localhost", "ip", "arch", "h", "service", "src", "proxy", "Host", "server", "address", "home", "conn", "loc", "target", "format", "hard", "http", "path", "dir", "prefix", "type", "database", "hop", "driver", "remote", "string", "header", "addr", "head", "uri", "config", "username"], "prot": ["att", "client", "pos", "stat", "rot", "cert", "def", " protocols", "pattern", " plat", "lat", "cli", "ht", "conn", "family", "Prot", "ios", "ref", "ocol", "ssl", "proc", "part", "config", " proto", "col", "prefix", "serv", "api", "channel", "conv", "platform", "pass", "rel", "nat", "password", "prop", "pro", " protocol", "addr", "afi", "pt", "txt"], "port": ["position", "ip", "timeout", "service", "p", "size", "priority", "Port", "phone", "ort", "proxy", "slice", "version", "future", "select", "patch", "limit", "server", "address", "target", "time", "path", "index", "direction", "value", "file", "f", "pi", "pass", "rest", "type", "number", "allow", "width", "hop", "password", "project", "string", "ports", "point", "uri", "PORT", "pid", "length", "pr"], "cacheFile": ["remotefile", "tempFile", " cachePlace", "sessionDir", "cachePlace", "CacheDirectory", "tempDir", " cacheMessage", "localFiles", " cachefile", "cacheFiles", "CacheFile", "outputFile", "cacheConnection", "cacheLine", "remoteFile", "sessionFiles", "baseMessage", "basefile", "sessionUrl", "remoteLine", "CacheDir", "sessionFile", "acheFile", " cacheUrl", "proxyFile", "cacheDirectory", "remoteUrl", "localfile", "storagePlace", "proxyDir", "CacheUrl", "acheFiles", "localDir", "Cachefile", "tempfile", "proxyfile", "outputMessage", " cacheLine", " cacheFiles", "fakeLine", "fakeUrl", "storageFile", " cacheConnection", "proxyHandle", "achePlace", " cacheHandle", "baseFile", "cacheMessage", "outputConnection", " cacheDir", "cacheDir", "CacheFiles", "fakeFile", "cachefile", "localDirectory", "baseConnection", "cacheHandle", "storageFiles", "fakefile", "localFile", "cacheUrl", "outputfile", "tempHandle", " cacheDirectory"], "urlConnection": ["urlCommand", "webconnection", "slConnection", "httpConnection", "URLconnection", "urlCon", " urlChannel", "urlPart", " urlConnect", "fileConnection", "urlconnection", "downloadEntry", "sslFile", "sslConnection", "cacheConnection", "urlConn", "downloadFile", "cacheConnect", "urlEntry", "URLCon", " urlEntry", "httpconnection", "downloadconnection", "httpCode", "slCommand", "httpPool", "cacheConn", "httpConn", "fileConnect", " urlPool", "urlConnect", " urlCommand", " urlFile", "urlFile", "filePart", "urlCode", "webCon", "sslResponse", "webConnect", "sslConn", "downloadConnection", "slChannel", "sslconnection", "URLConnect", "urlChannel", " urlconnection", "fileConn", "sslEntry", "cachePool", "webConnection", "httpChannel", "URLResponse", "urlPool", " urlConn", "slCode", "URLConnection", "httpCon", "sslConnect", "URLConn", " urlPart", "URLPart", "httpResponse", "urlResponse", "httpConnect", "httpCommand", " urlCode"], "httpURLConnection": ["httpREStatement", "httpSLConnect", "cacheURLConnection", "urlUrlconnection", "httpURTransaction", "httpSLCode", "cacheUrlConnection", "httpSLConnection", "httpURFunction", " httpURLconnection", "httpRLConnect", "httpURLNode", " httpHTTPFunction", "upperRConnection", "httpDateConstruction", "httpUrlConnect", " httpURLQuery", "currentURLCode", "httpURLClient", "httpDOMConnection", "httpRLconnection", "httpREConn", "httpCLConnect", "httpURNode", "httpURLConnect", "httpMCode", "httpCLConnection", "httpREClient", "cacheURLClient", "httpURLOperation", "httpMconnection", " httpURLFunction", "httpUrlConnection", " httpLLconnection", " httpHTTPOperation", "httpDateConnection", "httpLLConn", "shortSLconnection", "shortURLConnect", "httpUrlClient", "httpLLconnection", " httpUrlconnection", "httpDOMconnection", "httpURLConnector", "httpWSNode", "httpSLconnection", "shortURLConnection", "httpMLFunction", "httpBLQuery", "httpBLConnection", "httpRConnection", " httpLLConstruction", "cacheUrlConnector", "httpHTTPFunction", "httpFormConnect", "upperURLconnection", "shortSLConnection", "urlURLStatement", "upperURLTransaction", "currentURLConnect", " httpURLConstruction", "httpUrlStatement", " httpURLOperation", "httpDateConn", "cacheURLConnect", "httpWSConnection", "httpURLConn", "upperRTransaction", "httpURLConstruction", "httpURLFunction", "httpDOMConnect", "httpURQuery", "urlURLConnection", "httpURLconnection", "httpRconnection", "httpHTTPConnection", "upperRNode", "httpCLClient", "urlUrlConnection", "httpMConnect", "httpFormConnection", " httpLLConn", " httpURLConnect", "httpurlClient", "upperRconnection", "httpUROperation", "httpFormconnection", "httpURLQuery", "httpRNode", " httpHTTPConnection", "shortSLConnect", "httpURConnection", " httpLLConnection", "httpRLConnection", " httpUrlConnection", "httpurlStatement", "httpDOMFunction", "httpREconnection", "cacheUrlClient", "urlURLconnection", "httpHTTPOperation", "cacheUrlConnect", "shortURLconnection", "httpURLStatement", "httpMLConnect", "httpWSconnection", "httpREConstruction", "httpURLCode", "httpLLConnection", "httpURconnection", " httpUrlConnect", "httpRLConnector", "httpRTransaction", "httpUrlconnection", "httpWSTransaction", "urlURLClient", "httpMLconnection", "httpBLFunction", "httpMConnection", "upperURLNode", "httpLLConstruction", "urlUrlClient", "httpUrlConnector", "upperURLConnection", "httpREConnection", "httpurlconnection", "httpDateconnection", "currentURLconnection", "httpMLConnection", "httpRLClient", "httpCLConnector", "httpUrlFunction", " httpHTTPQuery", "cacheURLConnector", "httpBLOperation", "httpHTTPQuery", "urlUrlStatement", "httpurlConnection", "httpURLTransaction", " httpUrlFunction", "currentURLConnection", " httpURLConn"], "responseCode": ["statusCount", "ResponseStatus", "statusType", "ResponseCode", "responseMessage", "ResponseType", " responseMessage", "statusCode", "statusMessage", " responseStatus", "responseType", "replyMessage", "ResponseMessage", "ResponseCount", "replyCount", "statusStatus", "responseStatus", " responseType", "replyCode", "responseCount", "replyType"], "lastModified": ["New", "lastMinified", "nextMODied", " lastMODified", "lastEded", "s", "lastMinined", "lastMinIFIED", "lastmodified", "nextModification", "nextModified", "lastmodIFIED", "this", " lastModied", "lastModIFIED", "nextModied", "nextModed", " lastMODIFIED", "nextMODified", "lastMODified", "nextMODed", "lastMinied", "lastModined", "lastModification", "lastEdification", "lastmodied", "lastMODIFIED", "lastMODed", "lastmodification", " lastModIFIED", "nextMODification", "nextMODIFIED", "lastModed", "lastEdIFIED", " lastMODined", "lastMODined", "lastMODied", "_", "lastEdified", "lastMODification", " lastMODied", "lastModied", " lastModined", "lastmoded", "nextModIFIED"]}}
{"id1": "9371421", "id2": "18631594", "code1": "    public static String eventHash(String eventstr) {\n        try {\n            if (md == null) {\n                md = MessageDigest.getInstance(\"MD5\");\n            }\n            md.update(eventstr.getBytes(\"utf-8\"));\n            byte[] theDigest = md.digest();\n            return new BASE64Encoder().encode(theDigest);\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        } catch (UnsupportedEncodingException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n", "code2": "    public static synchronized String getMD5_Base64(String input) {\n        MessageDigest msgDigest = null;\n        try {\n            msgDigest = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(\"System doesn't support MD5 algorithm.\");\n        }\n        try {\n            msgDigest.update(input.getBytes(\"UTF-8\"));\n        } catch (java.io.UnsupportedEncodingException ex) {\n            throw new IllegalStateException(\"System doesn't support your  EncodingException.\");\n        }\n        byte[] rawData = msgDigest.digest();\n        byte[] encoded = Base64.encode(rawData);\n        String retValue = new String(encoded);\n        return retValue;\n    }\n", "label": 1, "substitutes": {"eventHash": [" eventKey", " eventhash", "messagehash", " eventDig", "eventDig", "eventhash", "byteKey", "byteDig", "messageKey", "messageHash", "bytehash", "byteHash", "eventKey", "messageDig"], "eventstr": ["eventsource", "eventdict", " eventstring", " eventStr", " eventdict", "errorStr", "exstr", "exstring", "eventstring", "errorstr", "exdict", "Eventsource", "Eventstring", "exStr", " eventsource", "errorstring", "eventStr", "EventStr", "Eventstr", "Eventdict", "errorsource"], "md": ["mm", "mac", "mo", "m", "dig", "key", "map", "ad", "id", "mu", "mn", "ng", "metadata", "ma", "dr", "od", "amd", "cm", "mb", "wd", "dh", "mand", "bd", "ke", "sm", "doc", "dm", "mg", "data", "pm", "sha", "em", "mt", "MD", "mp", "di", "mc", "mod", "mag", "hd", "d", "rpm", "vd", "ld", "ms", "meta", "hash", "cmd", "mem", "dd", " MD", "hm"], "theDigest": ["theSignhest", "theDighest", "theHashester", " theDighest", " theSignEST", "ThedigEST", "theSignester", "thedigester", "theDigester", "Thedigester", " theSignhest", "thedighest", "theSignEST", "theHashEST", " theSignest", "TheDigEST", "TheDigest", " theSignester", "theHashest", " theDigester", "TheDigester", "theDigEST", "thedigest", "theSignest", "thedigEST", "Thedigest", " theDigEST"]}}
{"id1": "13122204", "id2": "20920051", "code1": "    public static void unzipModel(String filename, String tempdir) throws EDITSException {\n        try {\n            BufferedOutputStream dest = null;\n            FileInputStream fis = new FileInputStream(filename);\n            int BUFFER = 2048;\n            ZipInputStream zis = new ZipInputStream(new BufferedInputStream(fis));\n            ZipEntry entry;\n            while ((entry = zis.getNextEntry()) != null) {\n                int count;\n                byte data[] = new byte[BUFFER];\n                FileOutputStream fos = new FileOutputStream(tempdir + entry.getName());\n                dest = new BufferedOutputStream(fos, BUFFER);\n                while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n                dest.flush();\n                dest.close();\n            }\n            zis.close();\n        } catch (Exception e) {\n            throw new EDITSException(\"Can not expand model in \\\"\" + tempdir + \"\\\" because:\\n\" + e.getMessage());\n        }\n    }\n", "code2": "    public static void copyTo(File source, File dest) {\n        if (source.isHidden()) ; else if (source.isDirectory()) {\n            File temp = new File(dest.getPath() + \"/\" + source.getName());\n            temp.mkdir();\n            for (File sel : source.listFiles()) copyTo(sel, temp);\n        } else {\n            try {\n                File tempDest = new File(dest.getPath() + \"/\" + source.getName());\n                tempDest.createNewFile();\n                FileChannel sourceCh = new FileInputStream(source).getChannel();\n                FileChannel destCh = new FileOutputStream(tempDest).getChannel();\n                sourceCh.transferTo(0, sourceCh.size(), destCh);\n                sourceCh.close();\n                destCh.close();\n            } catch (IOException ex) {\n                Logger.getLogger(EditorUtil.class.getName()).log(Level.SEVERE, null, ex);\n            }\n        }\n    }\n", "label": 1, "substitutes": {"unzipModel": ["UnzipProject", "unzipProject", "UnzipFile", "unpackmodel", "Unarchivemodel", "unarchiveFile", "unpatchmodel", "unarchivemodel", "unpackModel", "unpackFile", "unzipFile", "UnarchiveModel", "unpackProject", "UnzipModel", "unpatchModel", "unarchiveProject", "unzipmodel", "UnarchiveProject", "unpatchFile", "UnarchiveFile", "unarchiveModel", "Unzipmodel", "unpatchProject"], "filename": ["Filename", "txt", "bf", "files", "src", "fd", "title", "il", "directory", "File", "loc", "module", "location", "path", "fp", "fn", "FILE", "file", "f", "url", "nil", "model", "download", "fil", "database", "kl", "SourceFile", "fits", "name", "l", "string", "utf", "jet", "folder", "uri", "source", "username"], "tempdir": [" temppath", "TempDIR", "tempDir", "tempath", "tempdirectory", "tmpfolder", "Tempfolder", "tempfolder", "TempDir", " tempfolder", "tmpDir", "temDir", "tmppath", "temdirectory", "tempDIR", "temdir", "Tempdir", "tmpDIR", "Tempdirectory", "temppath", " tempdirectory", "tmpdir", "tmpdirectory", "temfolder", " tempDir", " tempDIR"], "dest": ["de", " Dest", "obj", "sync", "walk", "src", "output", "transfer", "delete", "tmp", "comb", "opt", "std", "default", "tar", "nt", "handler", "home", "Dest", "ui", "loc", "target", "result", "dc", "desc", "inner", "exit", "later", "proc", "cdn", "file", "sup", "dist", "store", "dir", "die", "st", "wb", "zip", "rest", "temp", "flat", "session", "log", "builder", "trans", "done", "test", "transform", "export", "di", "prop", "folder", "usr", "cont", "gen", "dat", "source", "walker", "txt"], "fis": ["lis", "fileiss", "fbis", "fsisa", "fid", "fi", "flbis", "fsiss", "flis", "fsis", "fliss", "li", "filebis", " fiss", "fileis", "fileid", "fsbis", "lid", "fiss", "fileisa", " fid", "liss", "filei", "fisa", "flisa", " fi"], "BUFFER": ["BUUCK", "TAFFER", "BUVER", "BOFER", "SAUCK", "UPVEN", " BUFIX", "SAFFER", "CUVEN", " BUVER", "TAVER", "UPFFER", "CUFF", " BUFER", "BUFF", " BUPER", "BOFIX", "BUVEN", "MAFFER", " BUFF", "BOFFER", "CUPER", " BUUCK", "SAVER", "SAPER", "MAFER", "BUFER", "BUFIX", "CUVER", "CUFFER", "UPFF", "BUPER", "MAFIX", "TAPER", "MAPER", " BUVEN", "UPVER", "TAUCK", "BOPER", "CUUCK"], "zis": ["xiss", "jists", "jis", "xis", " ziss", "zos", " zos", " zisa", "zipins", "Zis", "zipas", "zin", "ziss", "dii", "yIS", "xists", " zins", "zii", "Zisa", "yin", " zas", " zii", "zIS", "zins", "zi", "zas", "zisa", "xos", "zipisa", "zipis", "xbis", "dis", "Zins", " zists", " zi", "xi", "zipIS", "zists", " zIS", "yis", "zipin", "ji", "zbis", "yisa", "Zas", " zin", "xii", "diss", " zbis", "dbis", "jos"], "entry": ["next", "image", "iterator", "ace", "match", "la", "de", "element", "ie", "way", "cel", "ce", "rc", "feed", "ou", "cat", "e", "enter", "id", "nt", "ry", "archive", "lc", "valid", "server", "info", "module", "result", "or", "connection", "ident", "li", "inner", "se", "pack", "line", "row", "file", "part", "end", "ge", "porter", "zip", "pe", "her", "spec", "ent", "record", "ries", "je", "name", "Entry", "reader", "si", "source", "inc", "jo"], "count": ["ind", "next", "in", "buffer", "writer", "size", "max", "pos", "cond", "Count", "key", "current", "i", "use", "feed", "write", "e", "id", "limit", "core", "coll", "cache", "val", "last", "code", "sum", "low", "time", "index", "weight", "_", "line", "file", "part", "len", "start", "end", "iter", "f", "base", "type", "b", "log", "number", "allow", "name", "counter", "list", "add", "read", "c", "length"], "data": ["next", "image", "la", "buffer", "bytes", "size", "batch", "alpha", "pos", "block", "load", "feed", "input", "write", "id", "info", "result", "format", "media", "content", "array", "message", "zero", "index", "a", "pack", "raw", "value", "str", "len", "start", "base", "number", "record", "name", "reader", "DATA", "d", "body", "shift", "read", "dat", "length"], "fos": [" foes", "xoes", "bis", " foos", "foes", "fOS", "afOS", "xops", "bOS", "foos", "xos", " fops", "afos", "dfoes", "afis", "dfoos", "dfos", "bops", "afops", "xoos", "fops", "bos", " fOS", "dfops"]}}
{"id1": "1371265", "id2": "23677147", "code1": "    public void update(String channelPath, String dataField, String fatherDocId) {\n        String sqlInitial = \"select uri from t_ip_doc_res where doc_id = '\" + fatherDocId + \"' and type=\" + \" '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        String sqlsortURL = \"update t_ip_doc_res set uri = ? where doc_id = '\" + fatherDocId + \"' \" + \" and type = '\" + ces.platform.infoplat.core.DocResource.DOC_MAGAZINE_TYPE + \"' \";\n        Connection conn = null;\n        ResultSet rs = null;\n        PreparedStatement ps = null;\n        try {\n            dbo = (ERDBOperation) createDBOperation();\n            String url = \"\";\n            boolean flag = true;\n            StringTokenizer st = null;\n            conn = dbo.getConnection();\n            conn.setAutoCommit(false);\n            ps = conn.prepareStatement(sqlInitial);\n            rs = ps.executeQuery();\n            if (rs.next()) url = rs.getString(1);\n            if (!url.equals(\"\")) {\n                st = new StringTokenizer(url, \",\");\n                String sortDocId = \"\";\n                while (st.hasMoreTokens()) {\n                    if (flag) {\n                        sortDocId = \"'\" + st.nextToken() + \"'\";\n                        flag = false;\n                    } else {\n                        sortDocId = sortDocId + \",\" + \"'\" + st.nextToken() + \"'\";\n                    }\n                }\n                String sqlsort = \"select id from t_ip_doc where id in (\" + sortDocId + \") order by \" + dataField;\n                ps = conn.prepareStatement(sqlsort);\n                rs = ps.executeQuery();\n                String sortURL = \"\";\n                boolean sortflag = true;\n                while (rs.next()) {\n                    if (sortflag) {\n                        sortURL = rs.getString(1);\n                        sortflag = false;\n                    } else {\n                        sortURL = sortURL + \",\" + rs.getString(1);\n                    }\n                }\n                ps = conn.prepareStatement(sqlsortURL);\n                ps.setString(1, sortURL);\n                ps.executeUpdate();\n            }\n            conn.commit();\n        } catch (Exception e) {\n            e.printStackTrace();\n            try {\n                conn.rollback();\n            } catch (SQLException e1) {\n                e1.printStackTrace();\n            }\n        } finally {\n            close(rs, null, ps, conn, dbo);\n        }\n    }\n", "code2": "\tpublic static void Sample1(String myField, String condition1, String condition2) throws SQLException {\n\t\tConnection connection = DriverManager.getConnection(\"jdbc:postgresql://localhost/test\", \"user\", \"password\");\n\t\tconnection.setAutoCommit(false);\n\t\t\n\t\tPreparedStatement ps = connection.prepareStatement(\"UPDATE myTable SET myField = ? WHERE myOtherField1 = ? AND myOtherField2 = ?\");\n\t\tps.setString(1, myField);\n\t\tps.setString(2, condition1);\n\t\tps.setString(3, condition2);\n\t\t\n\t\t// If more than 10 entries change, panic and rollback\n\t\tint numChanged = ps.executeUpdate();\n\t\tif(numChanged > 10) {\n\t\t\tconnection.rollback();\n\t\t} else {\n\t\t\tconnection.commit();\n\t\t}\n\t\t\n\t\tps.close();\n\t\tconnection.close();\n\t}\n", "label": 1, "substitutes": {"update": ["request", "save", "query", "delete", "Update", "write", "json", "run", "apply", "replace", "info", "updated", "UPDATE", "index", "report", "resource", "edit", "post", "set", "data", "append", "table", "insert", "add", "create", "select"], "channelPath": [" channelObject", "downloadpath", "fileObject", "fileMap", "downloadPath", "resourceObject", "filePath", "resourcepath", "resourcePath", "downloadObject", "downloadMap", "resourceMap", " channelMap", "filepath", " channelpath"], "dataField": ["alphaArea", " datafield", "responseFIELD", "responseTerm", " dataFIELD", "datafield", "resourceTerm", " dataTerm", "DataTerm", "alphaTerm", "alphaField", "DataArea", "dataFIELD", "DataField", "resourceFIELD", "DataTable", " dataTable", " dataArea", "responseField", "dataArea", "dataTerm", "resourceField", "alphaTable", "resourcefield", "responsefield", "dataTable"], "fatherDocId": ["fatherWriterid", "fatherPoID", "fatherDocName", "motherDocumentName", "fatherWriterInfo", "motherDocumentPath", "fatherFileInfo", "fatherWriterId", "motherDocumentInfo", "motherDocName", "fatherDocumentInfo", "fatherDocInfo", "fatherDocumentId", "fatherDocid", "fatherPoName", "fatherFilePath", "fatherDocumentPath", "fatherDocumentid", "fatherFileName", "fatherWriterID", "fatherDocID", "motherDocid", "motherDocumentId", "motherDocumentID", "fatherDocumentID", "fatherdocInfo", "motherDocId", "motherDocInfo", "fatherFileid", "motherDocID", "fatherPoid", "fatherdocName", "fatherdocId", "motherDocumentid", "motherDocPath", "fatherFileID", "fatherdocPath", "fatherFileId", "fatherDocPath", "fatherPoId", "fatherDocumentName", "fatherWriterName"], "sqlInitial": ["SQLInitialized", "queryInitial", "queryFinal", "sqlFinal", "SQLinitial", " sqlInitialized", " sqlInit", "qlInitialized", " sqlinitial", "queryInit", "qlInit", "qlInitial", "SQLInit", "SQLFinal", "SQLInitial", "sqlinitial", "sqlInit", "qlinitial", "qlFinal", "sqlInitialized", "queryinitial"], "sqlsortURL": ["sqLSorturl", "sqlsendUrl", "sqlsORTUrl", "sqlssortURI", "sqlsORTURL", "sqLSORTUrl", "sqlssortURL", "sqlsaltURL", "sqllaltURL", "sqLSORTURL", "sqllortSSL", "sqLSortUrl", "sqLSortURL", "sqlsORTURI", "sqllaltURI", "sqlsourceURI", "sqlsaltURI", "sqlssortUrl", "sqllaltUrl", "sqLSortURI", "sqllaltSSL", "sqlsourceURL", "sqlsaltUrl", "sqllortURL", "sqlsourceSSL", "sqlsourceurl", "sqlsortURI", "sqllortURI", "sqlsendURI", "sqLSORTurl", "sqlssorturl", "sqLSORTURI", "sqlsendSSL", "sqlsORTurl", "sqlsortUrl", "sqlsourceUrl", "sqlsendURL", "sqlsaltSSL", "sqlsortSSL", "sqllortUrl", "sqlsorturl"], "conn": ["orp", "db", "client", "connect", "ca", "Conn", "p", "sync", "ctx", "n", "oss", "apt", "cp", "rc", "cn", "cc", "pg", "cs", "syn", "cat", "cr", "nt", "ci", "ens", "ht", "coll", "core", "reg", "ann", "dn", "connection", "dc", "nc", " con", "con", "conf", "ds", "pub", "en", "oci", "ch", "enc", "sql", "col", "session", "rt", "ct", "pc", "net", "co", "Connect", "mc", "res", "Connection", "lock", "act", "pt", "c", "pr"], "rs": ["r", "rys", "sc", "arch", "RS", "PS", "qs", "rd", "rl", "src", "rc", "cs", "Rs", "s", "bs", "its", "xs", "asts", "cr", "ns", "rx", "ows", "ros", "maps", "ges", "ris", "lines", "ks", "DS", "sels", "vers", "rss", "rb", "obs", "pers", "ras", "results", "rr", "ra", "ds", "hr", "sr", "mr", "ts", "icks", "rep", "ars", "ans", "rt", "hs", "rows", "ins", "ys", "vs", "acks", "ues", "res", "rg", "runs", "rors", "ms", "ocr", "ats", "pr", "repl"], "ps": ["os", "ups", "p", "RS", "PS", "pp", "pos", "pa", "cs", "s", "Rs", "pg", "bs", "pre", "syn", "ns", "LS", "ips", "po", "pres", "ros", "ens", "ks", "DS", "pers", "ras", "aps", "posts", "ons", "ples", "con", "ds", "pex", "ts", "pass", "fs", "pe", "jp", "ans", "ars", "pm", "eps", "ins", "pc", "ys", "co", "vs", "Ps", "res", "amps", "ss", "pse", "gs", "pps", "ms", "ports", "ws", "pl", "pt", "pr", "sp"], "dbo": ["Dbi", " dbc", " dpo", "mdBo", "ldbo", "bpo", "bbi", "ldba", "Dpo", " dBo", "bbo", "dbi", "dpo", "dbc", "ldbc", "ldBo", "dBo", "mdbo", " dbi", "mdbc", "DBo", "mdba", "dba", "Dbo", " dba", "bBo"], "url": ["request", "r", "image", "blog", "fr", "email", "sl", "html", "rl", "src", "host", "q", "view", "feed", "fl", "layer", "id", "route", "page", "hl", "rule", "server", "address", "loc", "http", "location", "URL", "path", "resource", "response", "ssl", "date", "file", "str", "f", "Url", "data", "download", "rel", "ll", "force", "text", "language", "name", "l", "href", "string", "nl", "ur", "uri", "source", "filename", "www", "username"], "st": ["ST", "r", "sts", "sc", "fr", "la", "sw", "p", "sl", "ast", "St", "rd", "src", "ste", "s", "std", "cr", "sn", "Str", "ft", "ist", "t", "sb", "stress", "stack", "stri", "sh", "const", "th", "bl", "ut", "inst", "sta", "str", "start", "x", "est", "rest", "pe", "rt", "nd", "cl", "stop", "l", "ost", "ss", "string", "ld", "sth", "ust", "pt", "pr", "sp"], "sortDocId": ["sortDOCID", " sortDocumentid", "updateDocumentId", "sortDepid", "sortDepName", " sortDocid", "sortFileID", "sortFileInfo", "sortPageid", "sortDepInfo", "sortdocId", "sortDepID", "sortFileId", "sortDocName", " sortDocPath", " sortDocName", " sortDocumentID", "sortDepId", " sortFileID", " sortDocID", "sortDOCid", "updateDocId", " sortFileInfo", "sortPageId", "updateDocInfo", "sortDocumentName", "sortDocumentid", "updateDocumentid", "updateDocumentInfo", "sortDocInfo", "sortWriterID", " sortFileId", " sortDocumentId", "sortWriterid", "sortDocumentInfo", "updateDocID", "sortdocInfo", "sortFileid", "updateDocumentID", "sortdocid", "sortPageName", "sortdocPath", " sortFilePath", "sortFilePath", "sortDocPath", "updateDocid", " sortDocInfo", "sortWriterId", "sortDocumentPath", "sortDOCName", "sortdocID", "sortDocid", "sortDocumentID", "sortdocName", "sortDocumentId", "sortDocID", "sortWriterName", " sortDocumentName", "sortPageID", "sortDOCId"], "flag": ["blog", "ind", "match", "sync", "ag", "flags", "bit", "key", "use", "kind", "fl", "bug", "cat", "id", "child", " Flag", "format", "only", "ext", "FLAG", "standard", "bool", "ret", "debug", "count", "file", "fun", "part", "store", "str", "start", "binary", "inline", "data", "lag", "char", "offset", "wait", "status", "tag", "force", "star", "prop", "string", "leaf", "field", "arg", "func", "Flag", "agg"], "sqlsort": ["sqsORT", "sqlesORT", " sqlssort", "sqlsorted", " sqlsorts", "sqlsorts", "sqlesorter", "sqLSorter", "sqlesorts", "sqLSsort", " sqLSorts", " sqlsORT", " sqlsorter", "sqssort", " sqlesort", "sqlsorter", " sqlesorter", "sqllorter", "sqllORT", "sqlsORT", "sqsort", " sqLSORT", "sqllorted", "sqLSORT", "sqlssort", "sqllort", "sqlessort", " sqlsorted", "sqLSort", " sqLSort", "sqLSorted", " sqlesorted", "sqsorts", "sqlesort", " sqlesORT", "sqlesorted", "sqLSorts", " sqLSsort"], "sortURL": ["SortUR", " sortURI", "ortSSL", "Sorturl", " sortUrl", "altUrl", "SortURL", " sorturl", "sortSSL", " sortID", "searchURL", "updateURI", "sortUrl", "searchUrl", " sortSSL", "editurl", "altUR", "editUrl", "searchID", "ortUR", "updateSSL", "sortURI", "ortID", "sortID", "ortURI", "editUR", "sortUR", "searchUR", "sorturl", "SortUrl", "ortUrl", "updateURL", "searchURI", "altSSL", " sortUR", "editURL", "ortURL", "altURL", "updateUR"], "sortflag": ["ortflag", "sortlike", "filterflag", "sortFLAG", "ortfeed", "sorttype", "considerfeed", "Sortflag", "ortflags", " sortFLAG", "addresslike", "orttype", " sorttype", "considerflags", "considerlike", " sortFlag", "addressflags", "SortFLAG", "ortFLAG", "sortFlag", "ortlike", "addressfeed", "filterFLAG", "filtertype", "sortfeed", "ortFlag", "sortflags", "addressflag", "SortFlag", "considerflag"]}}
{"id1": "6159896", "id2": "9956095", "code1": "    public static String md5(String str) {\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - start\");\n        }\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            md.update(str.getBytes());\n            byte[] b = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < b.length; i++) {\n                int v = (int) b[i];\n                v = v < 0 ? 0x100 + v : v;\n                String cc = Integer.toHexString(v);\n                if (cc.length() == 1) sb.append('0');\n                sb.append(cc);\n            }\n            String returnString = sb.toString();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"md5(String) - end\");\n            }\n            return returnString;\n        } catch (Exception e) {\n            logger.warn(\"md5(String) - exception ignored\", e);\n        }\n        if (logger.isDebugEnabled()) {\n            logger.debug(\"md5(String) - end\");\n        }\n        return \"\";\n    }\n", "code2": "    public void exportNotesToServer() {\n        boolean uploaded = true;\n        try {\n            File f = new File(UserSettings.getInstance().getNotesFile());\n            FileInputStream fis = new FileInputStream(f);\n            String urlString = protocol + \"://\" + UserSettings.getInstance().getServerAddress() + UserSettings.getInstance().getServerDir() + f.getName();\n            setDefaultAuthenticator();\n            URL url = new URL(urlString);\n            HttpURLConnection urlc = (HttpURLConnection) url.openConnection();\n            urlc.setDoOutput(true);\n            urlc.setRequestMethod(\"PUT\");\n            OutputStream os = urlc.getOutputStream();\n            int nextByte = fis.read();\n            while (nextByte != -1) {\n                os.write(nextByte);\n                nextByte = fis.read();\n            }\n            fis.close();\n            os.close();\n            if (urlc.getResponseCode() != HttpURLConnection.HTTP_CREATED && urlc.getResponseCode() != HttpURLConnection.HTTP_NO_CONTENT) {\n                uploaded = false;\n            }\n        } catch (SSLHandshakeException e) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.sslcertificateerror\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n            uploaded = false;\n        } catch (Exception e) {\n            uploaded = false;\n        }\n        if (uploaded) {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"info.notesfileuploaded\"), I18N.getInstance().getString(\"info.title\"), JOptionPane.INFORMATION_MESSAGE);\n        } else {\n            JOptionPane.showMessageDialog(null, I18N.getInstance().getString(\"error.notesfilenotuploaded\"), I18N.getInstance().getString(\"error.title\"), JOptionPane.ERROR_MESSAGE);\n        }\n    }\n", "label": 0, "substitutes": {"md5": ["sha5", "sha2", " md4", "MD2", "sha7", "md4", "md2", "md7", "sha4", "MD7", "MD4", " md2", " md7", "MD5"], "str": ["STR", "r", "in", "fr", "buffer", "m", "bytes", "obj", "br", "msg", "sp", "s", "strings", "input", "e", "Str", "stri", "result", "dr", "code", "exp", "hr", "f", "url", "st", "this", "doc", "data", "char", "spec", "text", "star", "arr", "name", "style", "string", "tr", "source", "self", "txt"], "md": ["mac", "mm", "db", "m", "Cmd", "de", "amp", "bf", "git", "pkg", "pd", "cd", "bm", "rm", "amd", "cm", "mb", "nm", "gb", "df", "wd", "dh", "mand", "bd", "gd", "mail", "f", "sm", "mg", "dm", "pm", "sha", "MD", "di", "mp", "cfg", "mc", "hd", "mag", "rpm", "d", "gm", "vd", "ld", "cmd", "mem", "dd", " MD", "vm", "hm"], "b": ["db", "abb", "buffer", "bytes", "p", "bf", "g", "br", "bis", "ab", "lb", "bs", "s", "bt", "emb", "ib", "bb", "e", "rb", "fb", "bl", "a", "mb", "ob", "buff", "gb", "pb", "bd", "B", "reb", "f", "binary", "buf", "wb", "base", "u", "ba", "l", "d", "body", "nb", "cb", "c"], "sb": ["lr", "db", "sc", "bp", "buffer", "abb", "sl", "bf", "src", "lb", "bs", "s", "tmp", "SB", "sk", "zb", "bt", "ib", "bb", "sa", "usb", "ls", "sf", "sg", "bc", "rb", "fb", "bg", "kb", "bps", "lp", "mb", "ob", "cca", "gb", "bj", "pb", "ub", "bh", "bd", "B", "acc", "buf", "wb", "BB", "sq", "bsp", "xb", "obb", "ss", "si", "nb", "lab", "sv", "orb", "cb", "sp"], "i": ["ai", "in", "ip", "h", "p", "j", "n", "g", "ie", "key", "s", "multi", "fi", "ix", "e", "phi", "id", "abi", "ci", "gi", "t", "val", "ui", "a", "index", "li", "ii", "io", "vi", "z", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "u", "y", "oi", "it", "di", "l", "si", "qi", "uri", "I", "c"], "v": ["r", "m", "j", "p", "h", "n", "g", "vt", "q", "s", "uv", "nv", "e", "t", "val", "lv", "ver", "va", "ve", "vi", "vp", "vv", "tv", "value", "av", "cover", "x", "ev", "f", "o", " vi", "conv", "vc", "k", "u", "cv", "ov", "qv", "vg", "vs", "l", "vd", "d", "sv", "iv", "V", "c", "vol"], "cc": ["C", "sc", "ca", "ck", "cci", "cel", "ce", "rc", "cs", "CC", "cn", "lc", "cf", "ci", "coll", "lv", "cu", "bc", "code", "dc", "cca", "uc", "fc", " c", "esc", "tc", "sup", " ecc", "acc", "ch", "enc", "vc", "cv", "ucc", "cl", "ct", "co", " CC", "cmp", "cb", "c", "inc", "ec"], "returnString": ["resultstring", " returnstring", "resultStr", "Returnstring", "resultArray", "ReturnString", "returnLine", "returnArray", " returnLine", "ReturnLine", "resultLine", "ReturnArray", "returnStr", " returnStr", "returnstring", "resultString", "ReturnStr", " returnArray"]}}
{"id1": "5138455", "id2": "11933797", "code1": "    public static int save(byte[] bytes, File outputFile) throws IOException {\n        InputStream in = new ByteArrayInputStream(bytes);\n        outputFile.getParentFile().mkdirs();\n        OutputStream out = new FileOutputStream(outputFile);\n        try {\n            return IOUtils.copy(in, out);\n        } finally {\n            IOUtils.closeQuietly(in);\n            IOUtils.closeQuietly(out);\n            try {\n                out.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n            try {\n                in.close();\n            } catch (IOException ioe) {\n                ioe.getMessage();\n            }\n        }\n    }\n", "code2": "    public static void CopyFile(String in, String out) throws Exception {\n        FileChannel sourceChannel = new FileInputStream(new File(in)).getChannel();\n        FileChannel destinationChannel = new FileOutputStream(new File(out)).getChannel();\n        sourceChannel.transferTo(0, sourceChannel.size(), destinationChannel);\n        sourceChannel.close();\n        destinationChannel.close();\n    }\n", "label": 1, "substitutes": {"save": ["process", "clone", "upload", "Save", "files", "output", "transfer", "Copy", "load", "parse", "write", "copy", "run", "apply", "pack", "xml", "file", "post", "store", "zip", "download", "append", "put", "split", "dump", "create"], "bytes": ["vals", "os", "buffer", "words", "files", "bs", "s", "slice", "its", "ls", "ips", "es", "address", "lines", "objects", "boot", "pointer", "rb", "tes", "bps", "services", "Bytes", "gb", "frames", "resources", "codes", "bits", "binary", "buf", "zip", "data", "blocks", "values", "pins", "parts", "outs"], "outputFile": ["outputDirectory", "targetDir", "OutputDirectory", "referencePath", "referencefile", "OutputF", "outputPath", "outputDir", "inputF", " outputF", " outputJar", "targetfile", "OutputFiles", " outputDirectory", "responsefile", "outputF", " outputfile", "outputFiles", "outputJar", "OutputFile", "referenceDir", "inputDirectory", "inputfile", "referenceFile", " outputDir", "inputFile", "inputFiles", "responseDir", "inputDir", " outputPath", " outputFiles", "responseJar", "outputfile", "targetFile", "targetJar", "inputPath", "responseFile"], "in": ["r", "image", "m", "pin", "n", "inn", "isin", "i", "is", "s", "init", "cin", "input", "copy", "id", "sin", "din", "inas", "conn", "info", "connection", "a", "inner", "nin", "ssl", "ini", "con", "work", "file", "rin", "part", "inside", "f", "url", "pass", "base", "exec", "login", "data", "err", "b", "token", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "error", "client", "writer", "sync", "obj", "n", "i", "output", "socket", "object", "init", "user", "write", "copy", "parent", "ex", "cache", "server", "outside", "conn", "connection", "a", "exp", "ext", "inner", "io", "op", "at", "file", "post", "x", "f", "o", "this", "exec", "null", "err", "temp", "b", "w", "call", "bin", "In", "again", "OUT", "as", "outs", "outer", "up", "inc"]}}
{"id1": "3375718", "id2": "8011262", "code1": "    public void importarHistoricoDeCotacoesDoDolar(Andamento pAndamento) throws FileNotFoundException, SQLException, Exception {\n        pAndamento.delimitarIntervaloDeVariacao(0, 49);\n        WSValorSerieVO[] cotacoesPendentesDoDolar = obterCotacoesPendentesDoDolar(pAndamento);\n        pAndamento.delimitarIntervaloDeVariacao(50, 100);\n        if (cotacoesPendentesDoDolar != null && cotacoesPendentesDoDolar.length > 0) {\n            String sql = \"INSERT INTO tmp_TB_COTACAO_DOLAR(DATA, PRECO) VALUES(:DATA, :PRECO)\";\n            OraclePreparedStatement stmtDestino = (OraclePreparedStatement) conDestino.prepareStatement(sql);\n            stmtDestino.setExecuteBatch(COMANDOS_POR_LOTE);\n            int quantidadeDeRegistrosASeremImportados = cotacoesPendentesDoDolar.length;\n            try {\n                int quantidadeDeRegistrosImportados = 0;\n                int numeroDoRegistro = 0;\n                for (WSValorSerieVO cotacaoPendenteDoDolar : cotacoesPendentesDoDolar) {\n                    ++numeroDoRegistro;\n                    stmtDestino.clearParameters();\n                    int ano = cotacaoPendenteDoDolar.getAno(), mes = cotacaoPendenteDoDolar.getMes() - 1, dia = cotacaoPendenteDoDolar.getDia();\n                    Calendar calendario = Calendar.getInstance();\n                    calendario.clear();\n                    calendario.set(ano, mes, dia);\n                    java.sql.Date vDATA = new java.sql.Date(calendario.getTimeInMillis());\n                    BigDecimal vPRECO = cotacaoPendenteDoDolar.getValor();\n                    stmtDestino.setDateAtName(\"DATA\", vDATA);\n                    stmtDestino.setBigDecimalAtName(\"PRECO\", vPRECO);\n                    int contagemDasInsercoes = stmtDestino.executeUpdate();\n                    quantidadeDeRegistrosImportados++;\n                    double percentualCompleto = (double) quantidadeDeRegistrosImportados / quantidadeDeRegistrosASeremImportados * 100;\n                    pAndamento.setPercentualCompleto((int) percentualCompleto);\n                }\n                conDestino.commit();\n            } catch (Exception ex) {\n                conDestino.rollback();\n                throw ex;\n            } finally {\n                if (stmtDestino != null && (!stmtDestino.isClosed())) {\n                    stmtDestino.close();\n                }\n            }\n        }\n        pAndamento.setPercentualCompleto(100);\n    }\n", "code2": "    private void uploadFile() {\n        String end = \"\\r\\n\";\n        String twoHyphens = \"--\";\n        String boundary = \"*****\";\n        try {\n            URL url = new URL(actionUrl);\n            HttpURLConnection con = (HttpURLConnection) url.openConnection();\n            con.setDoInput(true);\n            con.setDoOutput(true);\n            con.setUseCaches(false);\n            con.setRequestMethod(\"POST\");\n            con.setRequestProperty(\"Connection\", \"Keep-Alive\");\n            con.setRequestProperty(\"Charset\", \"UTF-8\");\n            con.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\" + boundary);\n            DataOutputStream ds = new DataOutputStream(con.getOutputStream());\n            ds.writeBytes(twoHyphens + boundary + end);\n            ds.writeBytes(\"Content-Disposition: form-data; \" + \"name=\\\"file1\\\";filename=\\\"\" + newName + \"\\\"\" + end);\n            ds.writeBytes(end);\n            FileInputStream fStream = new FileInputStream(uploadFile);\n            int bufferSize = 1024;\n            byte[] buffer = new byte[bufferSize];\n            int length = -1;\n            while ((length = fStream.read(buffer)) != -1) {\n                ds.write(buffer, 0, length);\n            }\n            ds.writeBytes(end);\n            ds.writeBytes(twoHyphens + boundary + twoHyphens + end);\n            fStream.close();\n            ds.flush();\n            InputStream is = con.getInputStream();\n            int ch;\n            StringBuffer b = new StringBuffer();\n            while ((ch = is.read()) != -1) {\n                b.append((char) ch);\n            }\n            showDialog(b.toString().trim());\n            ds.close();\n        } catch (Exception e) {\n            showDialog(\"\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"importarHistoricoDeCotacoesDoDolar": [" importarHistoricoDeCotacoesDomDi", " importarHistoricoDeCotacosDoDi", " importarHistoricoDeCotacoesdod", " importarHistoricoDeCotacoesDoD", " importarHistoricoDeCotacoesDODi", " importarHistoricoDeCotacoesDODo", " importarHistoricoDeCotacosDODi", " importarHistoricoDeCotacosDoDo", " importarHistoricoDeCotacosDOd", " importarHistoricoDeCotacoesDoDo", " importarHistoricoDeCotacosDODo", " importarHistoricoDeCotacoesDoDi", " importarHistoricoDeCotacoesDomD", " importarHistoricoDeCotacoesdoD", " importarHistoricoDeCotacoesDOD", " importarHistoricoDeCotacoesDOd", " importarHistoricoDeCotacoesdoDo", " importarHistoricoDeCotacosDod", " importarHistoricoDeCotacoesDomd", " importarHistoricoDeCotacoesDod", " importarHistoricoDeCotacoesDomDo", " importarHistoricoDeCotacosDoD", " importarHistoricoDeCotacosDOD", " importarHistoricoDeCotacoesdoDi"], "pAndamento": ["pButmentor", "pButementano", " pAndamente", "pButmente", "pNotamentor", "pAndamentor", "pAndeye", "pAndagementO", "pAndemento", "pButamentor", "pNotamenti", "pAndiationO", "pAndimente", "pAndeyi", "pAndagemento", "pAndmento", "pAndmentor", " pAndmente", " pAnditecto", "pAndamentano", " pANDamento", "pButementi", "pButemento", " pAndimentado", "pButmento", "pAndiationor", " pANDitectO", " pANDitecto", " pAnditectO", " pAndimente", "pAndimentor", "pAndimenti", "pButamentano", "pButamento", "pNotamentO", "pAndeyano", " pAnditecte", "pAndmente", "pNotimentor", " pAndmentado", "pButmenti", "pButamente", "pAndamenti", "pAndemente", "pNotimento", "pButemente", "pAndagementor", "pAndagementi", "pAndementi", "pAndeyo", "pAndimentO", "pAndimento", " pANDamentado", "pNotimentO", "pAndimentano", "pButamenti", " pANDamente", " pANDitectado", "pAndmenti", "pAndamente", " pAndimentO", " pAndmento", " pAndamentado", " pAndimento", " pAndamentO", " pAndmentO", "pNotamento", "pAndiationo", "pNotimenti", " pANDamentO", " pAnditectado", "pAndamentO", "pAndementano", " pANDitecte", "pAndagemente", "pAndiationi"], "cotacoesPendentesDoDolar": ["cotacoesPendentesDoDiSolar", "cotacoesPendentesDoDoolic", "cotacoesPendentesDoPolar", "cotacoesPendentesDODolo", "cotacoesPendentesDodollar", "cotacoesPendentesDoDSolar", "cotacoesPendentesDoVollar", "cotacoesPendentesDoPolic", "cotacoesPendentesdoDocal", "cotacoesPendentesDODolar", "cotacoesPendentesDoSollar", "cotacoesPendentesDoDoollar", "cotacoesPendentesDoDolate", "cotacoesPendentesDodocal", "cotacoesPendentesDoFSolar", "cotacoesPendentesdoDiocal", "cotacoesPendentesdoDiolar", "cotacoesPendentesdoDolar", "cotacoesPendentesDoDollar", "cotacoesPendentesDodolo", "cotacoesPendentesDoPollar", "cotacoesPendentesDoDiolo", "cotacoesPendentesDOdolar", "cotacoesPendentesDODSolar", "cotacoesPendentesDoSolar", "cotacoesPendentesDoDiolate", "cotacoesPendentesdoDolo", "cotacoesPendentesDodolar", "cotacoesPendentesDodolate", "cotacoesPendentesdoDolate", "cotacoesPendentesDoDiocal", "cotacoesPendentesDoVSolar", "cotacoesPendentesdoSSolar", "cotacoesPendentesDOdolo", "cotacoesPendentesDoDiolar", "cotacoesPendentesDoTolar", "cotacoesPendentesDODollar", "cotacoesPendentesDODiollar", "cotacoesPendentesdodollar", "cotacoesPendentesDoFocal", "cotacoesPendentesDoDoolo", "cotacoesPendentesDoFollar", "cotacoesPendentesDoDocal", "cotacoesPendentesDoVolate", "cotacoesPendentesDODiolar", "cotacoesPendentesDoTollar", "cotacoesPendentesDoDoSolar", "cotacoesPendentesDoDolo", "cotacoesPendentesDOdollar", "cotacoesPendentesDoSSolar", "cotacoesPendentesDodSolar", "cotacoesPendentesDoVolar", "cotacoesPendentesDODolic", "cotacoesPendentesdodSolar", "cotacoesPendentesDoDoolar", "cotacoesPendentesDoDiolic", "cotacoesPendentesDoPolo", "cotacoesPendentesdoDiSolar", "cotacoesPendentesdoDiollar", "cotacoesPendentesdoDSolar", "cotacoesPendentesdoDollar", "cotacoesPendentesDODiolic", "cotacoesPendentesDOdSolar", "cotacoesPendentesdoSolar", "cotacoesPendentesDoTSolar", "cotacoesPendentesDODiolo", "cotacoesPendentesDoSolo", "cotacoesPendentesdodolate", "cotacoesPendentesDoTolo", "cotacoesPendentesdoSollar", "cotacoesPendentesdodolar", "cotacoesPendentesdoSolo", "cotacoesPendentesDoDiollar", "cotacoesPendentesDoFolar", "cotacoesPendentesDoDolic"], "sql": ["where", "db", "su", "fr", "expr", "details", "orm", "query", "sl", "models", "html", "rl", "QL", "types", "object", "s", "pg", "comment", "el", "il", "ls", "serial", "statement", " SQL", "sol", "expression", "SQL", "es", "json", "sg", "pr", "http", "aws", "params", "fp", "ssl", "csv", "str", "storage", "util", "api", "base", "zip", "model", "data", "sq", "lang", "log", "b", "local", "dl", "database", "shell", "spec", "values", "mt", "software", "utils", "l", "ql", "math", "string", "nl", "general", "seed", "parser", "insert", "spr", "lock", "dd", "select", "repl"], "stmtDestino": ["stmbDestINO", "stordestaco", "stptdestino", "stctOrdination", "stmtStino", "stmdestINO", "stmtStINO", "stmtRestino", "stptDestro", "storDestinos", "stmtDistro", "stmtRestro", "stmtDestination", "stmtStorno", "stptDestino", "stmtStining", "stmtRestorno", "stmdestinos", "stptDestINO", "stptDestinos", "stctOrdining", "stmtOrdino", "stmtStini", "stmDestinos", "stordestino", "stmtdestino", "stmbRestINO", "stmtdestINO", "stordestinos", "stmDestino", "stctDestining", "stmtDestin", "stmbDestorno", "stmtStination", "stmtCombaco", "stmtOrdination", "stmtOrdin", "stctDestination", "stmtDestining", "stmtOrdining", "storDestino", "stctDestin", "stmbRestino", "stmtDestinos", "stmtDistinos", "stmtDestaco", "stmtDocination", "stmtDocino", "stmtCombinos", "stmtdestinos", "stmtdestini", "stctDestino", "stmtDistaco", "stptdestINO", "stmdestro", "stmtDocining", "stmtStin", "stmtDestINO", "stmtDistini", "stmtRestini", "storDestaco", "stmtRestINO", "storDestini", "stordestini", "stmDestINO", "stptdestro", "stmtRestinos", "stctOrdino", "stctOrdin", "stmtDestorno", "stmtDistino", "stmtCombini", "stmDestro", "stmbRestorno", "stmtDistINO", "stmtDocin", "stmtCombino", "stmtdestro", "stmtDestro", "stmtdestaco", "stptdestinos", "stmbDestini", "stmbRestini", "stmtDestini", "stmbDestino", "stmdestino", "stmtdestorno"], "quantidadeDeRegistrosASeremImportados": ["quantidadeDeRegistrosSeremsImportado", "quantidadeDeRegistrosSeremsPortada", "quantidadeDeRegistrosSeremImportadas", "quantidadeDeRegistrosSeremImportada", "quantidadeDeRegistrosSeremimportada", "quantidadeDeRegistrosSeremImportado", "quantidadeDeRegistrosSeremImportados", "quantidadeDeRegistrosSeremortado", "quantidadeDeRegistrosSeremsImportadas", "quantidadeDeRegistrosSeremsImportada", "quantidadeDeRegistrosSeremsPortadas", "quantidadeDeRegistrosSeremortados", "quantidadeDeRegistrosSeremortada", "quantidadeDeRegistrosSeremimportados", "quantidadeDeRegistrosSeremPortados", "quantidadeDeRegistrosSeremimportadas", "quantidadeDeRegistrosSeremsPortado", "quantidadeDeRegistrosSeremPortadas", "quantidadeDeRegistrosSeremPortada", "quantidadeDeRegistrosSeremortadas", "quantidadeDeRegistrosSeremsImportados", "quantidadeDeRegistrosSeremsPortados", "quantidadeDeRegistrosSeremPortado", "quantidadeDeRegistrosSeremimportado"], "quantidadeDeRegistrosImportados": ["quantidadeDeRegistrosOperos", "quantidadeDeRegistronsOperos", "quantidadeDeRegistronsImportants", "quantidadeDeRegistrosOperants", "quantidadeDeRegistrosInstadas", "quantidadeDeRegistrosImadas", "quantidadeDeRegistrosOperadas", "quantidadeDeRegistrosInstados", "quantidadeDeRegistronsOperadas", "quantidadeDeRegistrosImados", "quantidadeDeRegistronsOperados", "quantidadeDeRegistronsImportadas", "quantidadeDeRegistrosImportos", "quantidadeDeRegistrosImants", "quantidadeDeRegistronsImportos", "quantidadeDeRegistrosImportadas", "quantidadeDeRegistronsOperants", "quantidadeDeRegistrosImos", "quantidadeDeRegistronsImportados", "quantidadeDeRegistrosOperados", "quantidadeDeRegistrosImportants", "quantidadeDeRegistrosInstants", "quantidadeDeRegistrosInstos"], "numeroDoRegistro": ["numeroDoregastron", "numeroDoRegistsros", "numeroDoRegistsrar", "numeroDoRegestrar", "numeroDoregastro", "numeroDoRegostron", "numeroDoRegostro", "numeroDoRegistron", "numeroDoTagistsrob", "numeroDoTagistrob", "numeroDoRegistrob", "numeroDoregistron", "numeroDoRegistros", "numeroDoTagistro", "numeroDoRegastr", "numeroDoRegestrob", "numeroDoRegisterros", "numeroDoRegistr", "numeroDoRegestron", "numeroDoRegostros", "numeroDoRegastro", "numeroDoTagistros", "numeroDoTagistsros", "numeroDoTagistsro", "numeroDoRegistrar", "numeroDoregastr", "numeroDoRegestr", "numeroDoregastros", "numeroDoregistros", "numeroDoRegastron", "numeroDoRegisterrar", "numeroDoRegastros", "numeroDoRegestro", "numeroDoRegisterro", "numeroDoRegistsro", "numeroDoregistr", "numeroDoRegostr", "numeroDoRegisterrob", "numeroDoRegestros", "numeroDoregistro", "numeroDoRegistsrob", "numeroDoTagistrar", "numeroDoTagistsrar"], "cotacaoPendenteDoDolar": ["cotacaoPendenteDoDublic", "cotacaoPendenteDoMolan", "cotacaoPendenteDodollar", "cotacaoPendenteDoMollar", "cotacaoPendenteDoSIR", "cotacaoPendentePiDolan", "cotacaoPendenteDoSollar", "cotacaoPendenteDodolar", "cotacaoPendenteDoPolic", "cotacaoPendenteDodolan", "cotacaoPendenteDODolo", "cotacaoPendenteDoDolic", "cotacaoPendenteDoISolar", "cotacaoPendenteMoSollar", "cotacaoPendenteMoDolo", "cotacaoPendenteDoMolar", "cotacaoPendenteDoTIR", "cotacaoPendenteMoSolo", "cotacaoPendentePiDolic", "cotacaoPendenteDOSolo", "cotacaoPendenteDodiscal", "cotacaoPendenteDoSSolar", "cotacaoPendenteDoDSolar", "cotacaoPendenteDoDolan", "cotacaoPendenteDoLollar", "cotacaoPendenteDoTollar", "cotacaoPendentePiDollar", "cotacaoPendentePidollar", "cotacaoPendenteDoCSolar", "cotacaoPendenteMoDIR", "cotacaoPendenteDoSiscal", "cotacaoPendentePidolan", "cotacaoPendenteDODolar", "cotacaoPendenteDoPSolar", "cotacaoPendenteDoPolar", "cotacaoPendenteDoTolar", "cotacaoPendenteDoIolo", "cotacaoPendenteDoColar", "cotacaoPendenteDoTolan", "cotacaoPendenteDODublic", "cotacaoPendentePidolar", "cotacaoPendenteDoLiscal", "cotacaoPendenteDodolic", "cotacaoPendenteDoSublic", "cotacaoPendenteMoSSolar", "cotacaoPendenteDOSSolar", "cotacaoPendenteDoMolic", "cotacaoPendenteDoLolar", "cotacaoPendenteMoDiscal", "cotacaoPendenteDoPublic", "cotacaoPendenteDoLolo", "cotacaoPendenteDoSolo", "cotacaoPendenteDoIublic", "cotacaoPendenteDoPolo", "cotacaoPendenteMoSolar", "cotacaoPendenteDoDollar", "cotacaoPendenteDOSolar", "cotacaoPendenteDoSolar", "cotacaoPendenteMoSiscal", "cotacaoPendenteDodolo", "cotacaoPendenteDoIolar", "cotacaoPendenteMoSIR", "cotacaoPendenteDoCIR", "cotacaoPendenteDoCollar", "cotacaoPendenteDoSolic", "cotacaoPendenteDoDiscal", "cotacaoPendenteMoSolic", "cotacaoPendenteDoDolo", "cotacaoPendentePidolic", "cotacaoPendenteMoDolar", "cotacaoPendenteDODSolar", "cotacaoPendenteDoTSolar", "cotacaoPendentePiDolar", "cotacaoPendenteMoDolic", "cotacaoPendenteMoDSolar", "cotacaoPendenteDoDIR", "cotacaoPendenteMoDollar", "cotacaoPendenteDOSublic", "cotacaoPendenteDoPollar", "cotacaoPendenteDoTolic"], "ano": ["auto", "iana", "lo", "anto", "amo", "alia", "iso", "ao", "ane", "oda", "aldo", "uno", "ato", "oni", "office", "oshi", "illo", "ana", "asio", "lio", "ardo", "rio", "ania", "erno", "amia", "osa", "ko", "ado", "antis", "oa", "zo", "ilo", "anos", "uto", "mi", "rano", "ono", "aro", "umo", "ara", "obo", "aho", "ago"], "mes": ["lis", "mis", "mie", "la", "les", "phis", "nas", "mins", "ls", "ses", "ens", "es", "ME", "los", "ails", "ma", "MS", "ems", "mus", "nis", "nos", "lia", "mr", "mer", "mos", "mx", "mers", "des", "pins", "mot", "ims", "las", "mor", "mi", "sem", "me", "mc", "mails", "ums", "ae", "nes", "ms", "Ms", "mol"], "dia": ["ndica", "dica", " dria", " d\u00eda", " dias", "ndia", "nd\u00eda", "dsIA", "Dias", "Dia", "DIA", "ndias", "dsria", " dica", " dIA", "dria", "D\u00eda", "dIA", "dsia", "dias", "dsica", "Dria", "Dica", "d\u00eda"], "calendario": ["calendazon", "calmentario", "palenasio", "calenierra", "calendingaro", " recalendado", "palendar", "Calendedario", "caladiry", "calendedarius", "calendingillo", "calendarius", "calenario", "calENDarius", "caladarius", "caladasio", "calENDierra", "calendar", " recalentario", "Calendario", "calmentri", " recalendri", "Caladiry", "calendaro", "calendedillo", "calpendario", " recalendazon", "calenar", "calandierra", "calentazon", "calendingri", "calentario", "calendiry", "calENDillo", "calendingado", " recalentado", "calendierra", "calendedario", "Calendasio", "calentiry", "calendingarius", "calentri", "palenierra", "Calendaro", "calpendarius", "caladario", "palendasio", " recalentazon", "Calendedarius", "Calendiry", "Caladario", "calentado", "calmentazon", "calmentado", "calendingario", "calandar", "calpendasio", " recalentri", "calendingazon", "calendasio", "Calendedaro", "calendillo", "Calendillo", "calentasio", "calENDasio", "calpendiry", "calENDar", "calendedaro", "calentarius", "Caladarius", "palendario", "palenario", "calendri", "calandasio", " recalendario", "palendierra", "calenasio", "palenar", "calandario", "Calendedillo", "calendado", "calENDario", "calENDaro", "Caladasio", "Calendarius"], "vDATA": ["VATA", "hDATA", " vATA", "Vdata", "VData", "vData", " vdata", "VDEF", "jData", "vdata", "jATA", "hdata", "vATA", "jDEF", "jDATA", "vDEF", "VDATA", "hData", "hATA", " vData", " vDEF"], "vPRECO": ["vPCON", "fPRECO", "vPACo", "vPCO", "vPACON", "vPACO", "fPreCON", "vPDO", "fPRECo", "fPREDO", "vPREDO", "vPreCO", "fPRECON", "vPRECON", "fPreCO", "vPRECo", "vPADO", "vPreDO", "fPreDO", "vPreCo", "vPCo", "vPreCON", "fPreCo"]}}
{"id1": "2808955", "id2": "8490710", "code1": "    @Override\n    public EntrySet read(EntrySet set) throws ReadFailedException {\n        if (!SourceCache.contains(url)) {\n            SSL.certify(url);\n            try {\n                super.setParser(Parser.detectParser(url.openStream()));\n                final PipedInputStream in = new PipedInputStream();\n                final PipedOutputStream forParser = new PipedOutputStream(in);\n                new Thread(new Runnable() {\n\n                    public void run() {\n                        try {\n                            OutputStream out = SourceCache.startCaching(url);\n                            InputStream is = url.openStream();\n                            byte[] buffer = new byte[100000];\n                            while (true) {\n                                int amountRead = is.read(buffer);\n                                if (amountRead == -1) {\n                                    break;\n                                }\n                                forParser.write(buffer, 0, amountRead);\n                                out.write(buffer, 0, amountRead);\n                            }\n                            forParser.close();\n                            out.close();\n                            SourceCache.finish(url);\n                        } catch (IOException e) {\n                            e.printStackTrace();\n                        }\n                    }\n                }).start();\n                super.setIos(in);\n            } catch (Exception e) {\n                throw new ReadFailedException(e);\n            }\n            return super.read(set);\n        } else {\n            try {\n                return SourceCache.get(url).read(set);\n            } catch (IOException e) {\n                throw new ReadFailedException(e);\n            }\n        }\n    }\n", "code2": "    public void actualizar() throws SQLException, ClassNotFoundException, Exception {\n        Connection conn = null;\n        PreparedStatement ms = null;\n        registroActualizado = false;\n        try {\n            conn = ToolsBD.getConn();\n            conn.setAutoCommit(false);\n            Date fechaSystem = new Date();\n            DateFormat aaaammdd = new SimpleDateFormat(\"yyyyMMdd\");\n            int fzafsis = Integer.parseInt(aaaammdd.format(fechaSystem));\n            DateFormat hhmmss = new SimpleDateFormat(\"HHmmss\");\n            DateFormat sss = new SimpleDateFormat(\"S\");\n            String ss = sss.format(fechaSystem);\n            if (ss.length() > 2) {\n                ss = ss.substring(0, 2);\n            }\n            int fzahsis = Integer.parseInt(hhmmss.format(fechaSystem) + ss);\n            ms = conn.prepareStatement(SENTENCIA_UPDATE);\n            ms.setString(1, descartadoEntrada);\n            ms.setString(2, usuarioEntrada);\n            ms.setString(3, motivosDescarteEntrada);\n            ms.setInt(4, Integer.parseInt(anoOficio));\n            ms.setInt(5, Integer.parseInt(oficinaOficio));\n            ms.setInt(6, Integer.parseInt(numeroOficio));\n            ms.setInt(7, anoEntrada != null ? Integer.parseInt(anoEntrada) : 0);\n            ms.setInt(8, oficinaEntrada != null ? Integer.parseInt(oficinaEntrada) : 0);\n            ms.setInt(9, numeroEntrada != null ? Integer.parseInt(numeroEntrada) : 0);\n            int afectados = ms.executeUpdate();\n            if (afectados > 0) {\n                registroActualizado = true;\n            } else {\n                registroActualizado = false;\n            }\n            conn.commit();\n        } catch (Exception ex) {\n            System.out.println(\"Error inesperat, no s'ha desat el registre: \" + ex.getMessage());\n            ex.printStackTrace();\n            registroActualizado = false;\n            errores.put(\"\", \"Error inesperat, no s'ha desat el registre\" + \": \" + ex.getClass() + \"->\" + ex.getMessage());\n            try {\n                if (conn != null) conn.rollback();\n            } catch (SQLException sqle) {\n                throw new RemoteException(\"S'ha produ\u00eft un error i no s'han pogut tornar enrere els canvis efectuats\", sqle);\n            }\n            throw new RemoteException(\"Error inesperat, no s'ha modifcat el registre\", ex);\n        } finally {\n            ToolsBD.closeConn(conn, ms, null);\n        }\n    }\n", "label": 0, "substitutes": {"read": ["request", "get", "process", "next", "ping", "query", "ic", "Read", "block", "stream", "current", "socket", "view", "print", "load", "feed", "input", "write", "parse", "copy", "ry", "reads", "es", "run", "check", "open", "content", "http", "index", "resource", "READ", "readable", "work", "send", "reading", "find", "fill", "build", "start", "iter", "close", "exec", "update", "data", "wait", "search", "skip", "reader", "play", "weak", "scan", "add", "create", "select"], "set": ["get", "size", "sync", "entry", "src", "object", "use", "init", "load", "context", "parse", "id", "ut", "server", "cache", "rule", "or", "state", "SET", "resource", "ssl", "send", "end", "store", "start", "url", "sets", "base", "update", "session", "type", "reset", "spec", "test", "name", "settings", "site", "et", "seed", "setup", "setting", "source", "config"], "in": ["image", "client", "p", "pin", "ic", "inn", "gin", "src", "i", "socket", "init", "input", "on", "id", "spin", "cache", "inner", "resource", "io", "pull", "ssl", "ini", "con", "file", "min", "f", "url", "login", "data", "it", "ins", "bin", "In", "reader", "IN", "again", "win", "source", "inc"], "forParser": ["withFile", "ForFile", " forJar", "withparser", "forparser", "ForParser", "ForReader", " forFile", "forJar", "foreparser", "foreParser", "forReader", "foreReader", "ForListener", "forMaster", "foreMaster", "ofListener", "forListener", "ofReader", "withJar", "ForJar", " forListener", "ForMaster", "ofJar", "forFile", "withParser", "Forparser", " forReader", " forMaster", " forparser", "ofParser"], "out": ["Out", "os", "image", "client", "writer", "sync", "i", "output", "socket", "init", "app", "copy", "parent", "cli", "ex", "page", "cache", "conn", "to", "http", "inner", "ext", "io", "ssl", "file", "url", "o", "null", "exec", "err", "log", "can", "net", "co", "bin", "again", "OUT", "outs", "outer", "source", "up", "inc"], "is": ["lis", "os", "ai", "ip", "Is", "us", "bis", "isl", "isin", "isa", "i", "bs", "s", "ois", "its", "was", "ib", "id", "ci", "sin", "isi", "ris", "IS", "ui", "or", "iss", "ios", "has", "ir", "iris", "ais", "url", "fs", "api", "ri", "does", "are", "im", "ins", "vs", "as", "ps"], "buffer": ["size", "batch", "bytes", "queue", "transfer", "feed", "slice", "sequence", "layer", "reference", "slave", "delay", "page", "Buffer", "limit", "cache", "server", "address", "phrase", "info", "padding", "buff", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "border", "offset", "memory", "bin", "reader", "counter", "seed", "uri", "repeat", "source", "length"], "amountRead": ["numberLoad", "amountBuild", "poolLoad", " amountReader", "lengthHandle", "weightLoad", " amountStart", " numberHandle", "enoughReader", "weightBuild", "poolWrite", "AmountHandle", "AmountWrite", "amountWrite", "enoughRead", " numberLoad", "amountHandle", "enoughStart", "AmountRead", "amountLoad", " numberRead", "numberRead", "AmountLoad", "AmountStart", "lengthLoad", "lengthWrite", "poolRead", "amountStart", "numberReader", " numberWrite", "AmountReader", " amountBuild", "poolReader", "numberWrite", "AmountBuild", "weightRead", "lengthRead", "weightReader", "amountReader", " amountWrite", " amountLoad", "enoughWrite"]}}
{"id1": "9479502", "id2": "8024375", "code1": "    private File unpackZIP(URL url, String dirName) {\n        try {\n            URLConnection connection = url.openConnection();\n            if (connection instanceof JarURLConnection) {\n                File destDir = new File(getExtensionsDirectory() + EGEConstants.fS + dirName);\n                destDir.mkdirs();\n                EGEIOUtils.unzipFile(((JarURLConnection) connection).getJarFile(), destDir);\n                return destDir;\n            }\n        } catch (IOException e) {\n            LOGGER.error(\"Could not unzip jar file.\", e);\n        }\n        return null;\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 0, "substitutes": {"unpackZIP": ["unzipZipIP", "unpackZSSL", "unpackZipIP", "unpackZOP", "unzipZipOP", "unzipZSSL", "unpackZipOP", "unpackZipSSL", "unpackDRipped", "unpackDROP", "unzipZIP", "unpackDRSSL", "unpackDRIP", "unpackGIP", "unpackGipped", "unzipZipSSL", "unpackZipipped", "unpackGSSL", "unpackGOP", "unzipZipped", "unpackZipped", "unzipZOP", "unzipZipipped"], "url": ["image", "client", "service", "sl", "socket", "object", "proxy", "user", "bug", "page", "server", "address", "conn", "loc", "open", "or", "http", "location", "URL", "resource", "li", "io", "ssl", "file", "link", "Url", "base", "zip", "download", "loader", "l", "string", "uri", "jar", "source", "config"], "dirName": ["dirPath", "fileNAME", "dirNAME", "directoryname", "directoryName", "directoryNames", " dirPath", " dirDir", "dirname", "dirNames", "tierName", "tierPath", "tierDir", " dirNAME", "dirDir", "fileDir", " dirname", "directoryPath", "fileNames", "fileName", "tierNAME", "filePath", " dirNames", "filename"], "connection": ["image", "db", "position", "client", "connect", "j", "service", "relation", "socket", "context", "lc", "directory", "handler", "server", "conn", "loc", "open", "bc", "http", "response", "URL", "resource", "io", "manager", "con", "function", "connected", "channel", "serv", "session", "b", "database", "application", " Connection", "text", "document", "l", "ion", "communication", "Connection", "uri", "event", "source", "config", "c"], "destDir": ["targetDir", " destdir", "targetFolder", "targetDirectory", "DestFile", "destDirectory", "destFolder", " destFile", "destdir", "DestDirectory", "tmpDir", "tmpFolder", "destFile", "DestFolder", "tmpDirectory", "DestDir", " destDirectory", "tmpFile", "targetdir", "Destdir", "targetFile", " destFolder", "tmpdir"]}}
{"id1": "2521141", "id2": "17630906", "code1": "    public static void copy(String from_name, String to_name) throws IOException {\n        File from_file = new File(from_name);\n        File to_file = new File(to_name);\n        if (!from_file.exists()) abort(\"FileCopy: no such source file: \" + from_name);\n        if (!from_file.isFile()) abort(\"FileCopy: can't copy directory: \" + from_name);\n        if (!from_file.canRead()) abort(\"FileCopy: source file is unreadable: \" + from_name);\n        if (to_file.isDirectory()) to_file = new File(to_file, from_file.getName());\n        if (to_file.exists()) {\n            if (!to_file.canWrite()) abort(\"FileCopy: destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = to_file.getParent();\n            if (parent == null) parent = System.getProperty(\"user.dir\");\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"FileCopy: destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"FileCopy: destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"FileCopy: destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(from_file);\n            to = new FileOutputStream(to_file);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) {\n                to.write(buffer, 0, bytes_read);\n            }\n        } finally {\n            if (from != null) {\n                try {\n                    from.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (to != null) {\n                try {\n                    to.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n", "code2": "    public static int[] sortAscending(float input[]) {\n        int[] order = new int[input.length];\n        for (int i = 0; i < order.length; i++) order[i] = i;\n        for (int i = input.length; --i >= 0; ) {\n            for (int j = 0; j < i; j++) {\n                if (input[j] > input[j + 1]) {\n                    float mem = input[j];\n                    input[j] = input[j + 1];\n                    input[j + 1] = mem;\n                    int id = order[j];\n                    order[j] = order[j + 1];\n                    order[j + 1] = id;\n                }\n            }\n        }\n        return order;\n    }\n", "label": 0, "substitutes": {"copy": ["get", "image", "clone", "sync", "upload", "ize", "cp", "transfer", "delete", "Copy", "load", "write", "cat", "directory", "archive", " cp", "ame", "open", "source", "diff", "share", "rm", "clip", "cop", "ignore", "change", "file", "ge", "link", "update", "zip", "download", "create", "type", "pe", "paste", "attach", "dump", "opy", "config", "move"], "from_name": ["from_names", "from__name", " from_names", "from_memory", "to_path", "from_key", "fromFfilename", "fromFname", "source_filename", "fromMname", "source_memory", "from_filename", "to_filename", "source_name", " from_Name", "from__path", "fromFpath", "from__memory", "from_path", "fromMnames", "fromFmemory", "fromMfile", "source_path", " from_key", "from_Name", "from__filename"], "to_name": ["toamname", "toamhome", "to_home", "toampath", "to_path", " to_Name", "to_Name", " to_path", "from_path", "from_filename", "toamfile", "to_filename", " to_home"], "from_file": ["fromappfunction", "from_directory", " from__auto", "from__name", "from_brain", "from___filename", "from_resource", "from_source", "from___file", " from__filename", " from__file", " from_directory", "source_filename", "source_directory", "fromCfile", "remote_lane", "from__files", " from_filename", " from__name", "from__directory", "from__resource", "fromCname", "remote_function", "from_function", "from_filename", "from___name", "from_lane", "remote_log", "fromCbrain", "source_brain", " from_folder", "source_name", " from_auto", "source_files", "remote_file", " from_files", "fromapplane", "from_auto", "from_log", " from_source", "from_files", "fromCfilename", "fromappfile", "from__file", "from_folder", "fromapplog", "source_resource", "from__filename", "from__auto", "source_file", "from___auto"], "to_file": ["to64use", "to_model", "tojfile", "intojfile", "eto___remote", "intojfunction", "into_use", "to__dir", "eto_remote", "from_model", "to64name", "to_remote", "to_binary", "source_filename", "to_server", "to67load", "eto_file", "intojname", "intojuse", "to___remote", "tojuse", " to_class", "into_function", "to67dir", " to_queue", "to__name", "to_filename", "from_bar", "source_server", "to_queue", "to_dir", "to67name", "eto___name", "toJstream", "to__load", "to64file", " to_model", "to64function", "into_file", "toJfile", "to___name", "to_class", "tojfunction", "source_files", "eto_name", "from_dir", "to67file", " to_filename", "to_stream", "to___file", "from_files", "from_stream", "from_load", "to_function", "toJbar", "eto___file", " to_files", "to_files", "to_load", "to_use", "tojname", "into_name", "to_bar", "toJname", "from_binary", "to__file", "source_file"], "parent": ["size", "author", "old", "global", "complete", "address", "target", "content", "container", "Parent", "root", "api", "test", "search", "name", "string", "folder", "am", "uri", "ip", "client", "p", "full", "pa", "user", "page", "patch", "rule", "cache", "home", "loc", "path", "pool", "file", "part", "unit", "div", "any", "ac", "inc", "ppa", "tree", "host", "id", "directory", "port", "per", "child", "out", "manager", "function", "url", "null", "memory", "remote", "point", "source", "term", "mother", "par", "owner", "po", "handler", "server", "or", "connection", "fat", "location", "resource", "session", "type", "temp", "parents", "current"], "dir": ["r", "db", "in", "entry", "block", "def", "class", "object", "user", "global", "dict", "cat", "dec", "id", "directory", "coll", "cache", "home", "per", "md", " directory", "loc", "group", "module", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "io", "exp", "ir", "out", "manager", "wd", "file", "root", "director", "part", "build", "iter", "f", "url", "die", "doc", "data", "div", "rel", "keep", "Dir", "name", "di", "d", "folder", "tr", "lock", "dev", "nav", "dis"], "from": ["when", "get", "auto", "From", "fr", "client", "component", "flo", "left", "one", "entry", "stream", "form", "ce", "view", "feed", "context", "ou", "parse", "e", "cr", "cf", "cache", "server", "address", "per", "fe", "conn", "or", "connection", "http", "low", "io", "se", "cor", "cm", "ra", "con", "file", "find", "part", "who", "start", "link", "url", "ch", "this", "api", "base", "normal", "with", "pe", "range", "can", "so", "name", "bean", "by", "without", "two", "empty", "add", "source", "self", "vol"], "to": ["auto", "db", "su", "client", "that", "flo", "size", "too", "sync", "one", "output", "socket", "proxy", "write", "on", "po", "tto", "office", "To", "t", "server", "per", "conn", "thro", "target", "or", "connection", "fat", "http", "TO", "fb", "ver", "io", "top", "op", "see", "not", "out", "value", "dest", "file", "storage", "store", "pi", "o", "until", "api", "base", "will", "session", "type", "with", "token", "via", "so", "co", "by", "as", "two", "about"], "buffer": ["position", "writer", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "slice", "reference", "bb", "page", "Buffer", "server", "address", "source", "padding", "message", "resource", "buff", "row", "uffer", "iter", "url", "buf", "binary", "channel", "null", "data", "b", "border", "number", "wave", "document", "total", "memory", "reader", "variable", "header", "seed", "duration", "window", "read", "flush", "layer", "length"], "bytes_read": ["gets___pass", "bytesXbefore", "gets___allow", "byte_current", "byte_load", " bytes_en", "bytes___reads", "bytes_en", "gets_allow", "byteslexread", " bytes_found", "bytes___allow", " bytes_write", "bytes_found", "bytesXload", "bytes_reads", "bytesXread", "byte_before", "bytes_allow", "bytes_pass", "bytes_load", "bytesXcurrent", "bytes_write", "bytes_before", "bytes___read", "gets___read", "gets_reads", "gets___reads", "bytes___pass", "gets_pass", "bytes_current", "byteslexload", "byte_read", "gets_read", "byteslexbefore", "byteslexcurrent"]}}
{"id1": "18374478", "id2": "17729554", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public boolean clonarFichero(FileInputStream rutaFicheroOrigen, String rutaFicheroDestino) {\n        System.out.println(\"\");\n        boolean estado = false;\n        try {\n            FileOutputStream salida = new FileOutputStream(rutaFicheroDestino);\n            FileChannel canalOrigen = rutaFicheroOrigen.getChannel();\n            FileChannel canalDestino = salida.getChannel();\n            canalOrigen.transferTo(0, canalOrigen.size(), canalDestino);\n            rutaFicheroOrigen.close();\n            salida.close();\n            estado = true;\n        } catch (IOException e) {\n            System.out.println(\"No se encontro el archivo\");\n            e.printStackTrace();\n            estado = false;\n        }\n        return estado;\n    }\n", "label": 0, "substitutes": {"updateUser": ["createUsers", "updateRole", "editUsers", " updateMember", "addUsers", "addUser", "deleteRole", "updateuser", "editUser", "deleteUsers", "updatedWord", "updateUsers", "deletePassword", " updateAccount", "createRole", "adduser", "deleteMember", "UpdateUsers", "deleteUser", "editRole", "updatedUsers", "updatePassword", " updateUsers", "updatedUser", "updateMember", "addWord", "updateduser", "editAccount", "deleteWord", "UpdatePassword", "deleteuser", " updateWord", "updateWord", "UpdateWord", " updatePassword", "createAccount", " updateRole", "updateAccount", "UpdateRole", "createUser", "UpdateUser", "Updateuser", "UpdateMember", " updateuser"], "user": ["job", "account", "match", "client", "self", "app", "p", "creator", "User", "full", "author", "profile", "you", "object", "use", "view", "USER", "ro", "character", "instance", "version", "bug", "used", "parent", "page", "rule", "server", "per", "group", "module", "result", "connection", "ver", "content", "response", "resource", "message", "pool", "manager", "row", "str", "post", "this", "null", "model", "session", "data", "update", "system", "contact", "log", "users", "record", "name", "auth", "me", "site", "member", "plugin", "project", "string", "custom", "current", "person", "config", "username"], "conn": ["ha", "db", "pt", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "oss", "cond", "cp", "host", "rc", "cn", "cc", "pg", "el", "socket", "ou", "cat", "cr", "cli", "nt", "ci", "core", "coll", "cache", "server", "cb", "ann", "loc", "reg", "connection", "nc", "dc", "ob", "cm", "pool", "con", "conf", "uc", "part", "pub", "util", "col", "ch", "enc", "serv", "exec", "sql", "url", "close", "ac", "api", "log", "org", "ct", "pc", "co", "mc", "sth", "Connection", "lock", "act", "config", "c", "pr", "ec"], "autoCommit": ["autoDebmit", " autoDebitting", "autoCommits", "autoBlIT", "autoRebit", "automaticCommit", "autoComend", "autoCommite", "autoComIT", "autoDebend", " autoCommite", "automaticCommmit", "autoComite", " autoCommitting", "autoDebits", "autoAbit", "autoBlend", "automaticDebmit", " autoComite", " autoDebmit", "autoCommend", " autoCommmit", "autoDebit", "autoCommmit", "autoCit", "autoCmit", "autoRebite", "autoCommited", " autoComits", "autoComit", "autoDebitting", "autoDebIT", " autoCommits", "autoAbmit", " autoCommited", "autoCommitting", "autoComits", "autoCommIT", "autoBlmit", "automaticCommend", "autoDebited", "autoDebite", "automaticDebend", "autoCited", " autoComit", "automaticCommIT", "automaticDebIT", " autoDebited", "autoBlit", "autoAbitting", " autoDebit", "autoCitting", "autoRebits", "automaticDebit", "autoAbited"], "deleteRoles": ["deleteGrols", "deleteRooles", "deleteNols", "insertRoases", "deleteColes", "deleteRodes", "deleteSlases", "deleteRole", "insertRases", "deleteCodes", "delLole", "insertRooles", "deleteGroles", "deleteRoases", "insertRoules", "deleteLole", "deleteDoots", "deleteDases", "deleteNoles", "delLases", "deleteRoole", "delRodes", "delLodes", "insertRules", "destroyRols", "delRoles", "deleteCole", "deleteRoots", "deleteSloles", "deleteLoles", "destroyNoots", "destroyNols", "deleteNoots", "deleteRsole", "deleteNils", "deleteRsases", "deleteRases", "deleteRils", "deleteRsoles", "deleteCases", "deleteSlodes", "deleteDils", "deleteSlole", "destroyRils", "deleteRules", "deleteDole", "insertRole", "delRole", "deleteGroots", "destroyNoles", "destroyRoles", "deleteRoules", "deleteLases", "deleteDoles", "deleteDols", "deleteRsules", "delLoles", "deleteGrils", "destroyNils", "insertRoole", "deleteRols", "delRases", "destroyRoots", "deleteLodes", "deleteDules"], "insertRoles": ["insertGows", "insertSloots", "updateRols", "insertRsules", "copyRules", "copyGules", "insertRanges", " insertRules", "deleteSloles", "insertRows", "insertShole", "deleteRanges", "deleteSlodes", "insertLows", "deleteSloots", "insertRoots", "insertGules", "insertSloles", "copyRows", "insertLols", " insertShole", "insertGoots", "deleteRodes", " insertShodes", "insertSoles", "updateLoles", "insertRodes", " insertRole", "deleteRoots", "insertSlanges", "copyGoots", "updateLles", "insertSodes", "insertRsanges", "insertLules", "updateLols", "insertShodes", "insertRsows", "insertLles", "insertRles", "insertShules", "copyRoots", "insertGoles", "insertRules", "updateRles", "copyGoles", "insertRsoles", "copyRoles", "insertRsles", "insertSole", "deleteSlanges", "insertSules", "insertRols", " insertRodes", "insertLoots", "updateLules", "updateRules", "copyGows", "insertSholes", "insertSlodes", "insertRsodes", " insertShules", " insertSholes", "updateRoles", "insertLoles", "insertRole", "insertRsoots", "insertRsols"], "role": ["error", "de", "service", "Role", "one", "entry", "rl", "label", "tool", "key", "relation", "profile", "guard", "ro", "repl", "roller", "ole", "rol", "slave", "route", "rule", "val", "to", "group", "alias", "or", "module", "resource", "zone", "function", "row", "link", "base", "type", "range", "shadow", "tag", "force", "l", "member", "string", "le", "username"]}}
{"id1": "3558512", "id2": "8150996", "code1": "    public void serialize(OutputStream out) throws IOException, BadIMSCPException {\n        ensureParsed();\n        ZipFilePackageParser parser = utils.getIMSCPParserFactory().createParser();\n        parser.setContentPackage(cp);\n        if (on_disk != null) on_disk.delete();\n        on_disk = createTemporaryFile();\n        parser.serialize(on_disk);\n        InputStream in = new FileInputStream(on_disk);\n        IOUtils.copy(in, out);\n    }\n", "code2": "    private static boolean copyFile(File in, File out) {\n        boolean ok = true;\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(in);\n            os = new FileOutputStream(out);\n            byte[] buffer = new byte[0xFFFF];\n            for (int len; (len = is.read(buffer)) != -1; ) os.write(buffer, 0, len);\n        } catch (IOException e) {\n            System.err.println(e);\n            ok = false;\n        } finally {\n            if (is != null) {\n                try {\n                    is.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n            if (os != null) {\n                try {\n                    os.close();\n                } catch (IOException e) {\n                    System.err.println(e);\n                }\n            }\n        }\n        return ok;\n    }\n", "label": 1, "substitutes": {"serialize": ["serialization", "serialized", "Serialze", "Serialization", "finalify", " serialization", " serialze", "normalized", "finalized", "erializable", " serializable", "normalize", "serializable", "erialize", "normalze", "Serializable", "erialization", "Serialize", "Serialized", "Serialify", "serialify", "erialze", "serialze", "normalify", "finalze", "finalize"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "up", "i", "output", "copy", "parent", "ex", "page", "archive", "cache", "server", "conn", "filename", "content", "a", "report", "io", "pool", "raw", "file", "png", "o", "exec", "data", "temp", "err", "loader", "w", "name", "bin", "string", "outs", "gen", "dump", "source", "OUT"], "parser": ["writer", "p", "worker", "upload", "pp", "cp", "master", "class", "instance", "parse", "pkg", "copy", "pillar", "Parser", "handler", "parent", "server", "cache", "per", "tt", "php", "lp", "xml", "manager", "file", "rar", "base", "wrapper", "system", "pe", "builder", "loader", "er", "test", "arser", "processor", "ss", "reader", "as", "plugin", "seed", "up", "txt"], "on_disk": ["on_storage", "onbootlock", "off_demand", "onJdisk", "onjdrive", "onJdrive", "off_lock", "onbootdisk", "onnetdemand", "onJdemand", "onbookdrive", "on_lock", "off_file", "off_drive", "onnetdrive", "onbookdisk", "onJlock", "onbootstorage", "onnetspace", "off_disk", "on_demand", "off_delete", "off_storage", "onnetfile", "onnetdisk", "on_drive", "onjspace", "onjfile", "on_file", "onjdisk", "off_space", "on_delete", "onbootdrive", "on_space", "onbookdelete"], "in": ["r", "pin", "inn", "stream", "i", "socket", "input", "copy", "thin", "din", "conn", "inas", "info", "ax", "lin", "connection", "inner", "ini", "con", "rin", "file", "kin", "min", "f", "o", "pass", "login", "data", "ac", "ins", "bin", "In", "reader", "IN", "again", "as", "win", "source", "c", "inc"]}}
{"id1": "21488868", "id2": "22442270", "code1": "    public static boolean encodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.ENCODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "            @Override\n            public void handledRun() throws Throwable {\n                try {\n                    URL url = new URL(ONLINE_CLIENT_DATA + \"gamedata.xml\");\n                    BufferedReader br = new BufferedReader(new InputStreamReader(url.openStream()));\n                    int lastversion = 0;\n                    String readHeader1 = br.readLine();\n                    String readHeader2 = br.readLine();\n                    String[] parts = readHeader2.split(\" \");\n                    lastversion = new Integer(parts[1]);\n                    GameDatabase.loadVersion();\n                    if (GameDatabase.version < lastversion) {\n                        Logger.log(LogTypes.LOG, \"Downloading new gamedata\");\n                        BufferedOutputStream bo = null;\n                        File destfile = new File(GameDatabase.dataFilePath);\n                        if (!destfile.createNewFile()) {\n                            destfile.delete();\n                            destfile.createNewFile();\n                        }\n                        bo = new BufferedOutputStream(new FileOutputStream(destfile));\n                        bo.write((readHeader1 + \"\\n\").getBytes());\n                        bo.write((readHeader2 + \"\\n\").getBytes());\n                        int readedbyte;\n                        while ((readedbyte = br.read()) != -1) {\n                            bo.write(readedbyte);\n                        }\n                        bo.flush();\n                        try {\n                            br.close();\n                            bo.close();\n                        } catch (Exception ex) {\n                            Logger.log(ex);\n                        }\n                    }\n                } catch (java.net.UnknownHostException unknownHost) {\n                    Logger.log(\"Sourceforge is down, cannot update gamedata\");\n                } catch (Exception e) {\n                    JOptionPane.showMessageDialog(FrameOrganizer.getClientFrame(), \"The gamedata is outdated, but Coopnet couldn't update it!\", \"Gamedata outdated\", JOptionPane.INFORMATION_MESSAGE);\n                    throw e;\n                } finally {\n                    GameDatabase.loadVersion();\n                    GameDatabase.load(\"\", GameDatabase.dataFilePath);\n                    GameDatabase.detectGames();\n                }\n            }\n", "label": 0, "substitutes": {"encodeFileToFile": ["encodeString2Stream", "encodeFileFromStream", "encodeFile2Stream", "encodeFileToString", "encodeFileToStream", "encodeFiletoFiles", "encodeFileFromString", "encodeFile2String", "encodeStringToFiles", "encodeStringToString", "encodeStringToStream", "encodeFiletoFile", "encodeFileToFiles", "encodeFiletoString", "encodeString2Files", "encodeString2File", "encodeFile2File", "encodeString2String", "encodeFile2Files", "encodeFileFromFile", "encodeFileFromFiles", "encodeStringToFile", "encodeFiletoStream"], "infile": ["infilename", "Infile", "inputfiles", "outfp", "inputfilename", " infp", "Infilename", "outfiles", "outfilename", "infp", "infiles", " infiles", "inputfile", "Infiles", "inputFile", "outFile", "inFile", "inputfp", " infilename", "InFile"], "outfile": ["infilename", "newfolder", "newFile", " outfilename", "newname", "Outfile", "outfp", "newfile", "outputfilename", "outputfolder", "outfolder", " outname", "Outfolder", "outfilename", " outFile", "infp", "infolder", "outname", "OutFile", "Outname", " outfolder", "outFile", "outputfile", "outputfp", " outfp"], "in": ["r", "image", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "a", "inner", "vin", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "base", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "on", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "work", "file", "line", "post", "o", "no", "exec", "base", "lib", "session", "err", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "source", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "fb", "buff", "raw", "value", "count", "uffer", "len", "iter", "url", "buf", "binary", "null", "base", "data", "type", "b", "border", "offset", "split", "wave", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "input", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "close", "end", "pass", "exec", "wait", "allow", "ride", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "respons", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "content", "failed", "response", "message", "successful", "path", "results", "modified", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "6009527", "id2": "12039034", "code1": "    private void doFinishLoadAttachment(long attachmentId) {\n        if (attachmentId != mLoadAttachmentId) {\n            return;\n        }\n        Attachment attachment = Attachment.restoreAttachmentWithId(MessageView.this, attachmentId);\n        Uri attachmentUri = AttachmentProvider.getAttachmentUri(mAccountId, attachment.mId);\n        Uri contentUri = AttachmentProvider.resolveAttachmentIdToContentUri(getContentResolver(), attachmentUri);\n        if (mLoadAttachmentSave) {\n            try {\n                File file = createUniqueFile(Environment.getExternalStorageDirectory(), attachment.mFileName);\n                InputStream in = getContentResolver().openInputStream(contentUri);\n                OutputStream out = new FileOutputStream(file);\n                IOUtils.copy(in, out);\n                out.flush();\n                out.close();\n                in.close();\n                Toast.makeText(MessageView.this, String.format(getString(R.string.message_view_status_attachment_saved), file.getName()), Toast.LENGTH_LONG).show();\n                new MediaScannerNotifier(this, file, mHandler);\n            } catch (IOException ioe) {\n                Toast.makeText(MessageView.this, getString(R.string.message_view_status_attachment_not_saved), Toast.LENGTH_LONG).show();\n            }\n        } else {\n            try {\n                Intent intent = new Intent(Intent.ACTION_VIEW);\n                intent.setData(contentUri);\n                intent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);\n                startActivity(intent);\n            } catch (ActivityNotFoundException e) {\n                mHandler.attachmentViewError();\n            }\n        }\n    }\n", "code2": "    public static ArrayList<RoleName> importRoles(String urlString) {\n        ArrayList<RoleName> results = new ArrayList<RoleName>();\n        try {\n            URL url = new URL(urlString);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            StringBuffer buff = new StringBuffer();\n            String line;\n            while ((line = in.readLine()) != null) {\n                buff.append(line);\n                if (line.equals(\"</RoleName>\")) {\n                    RoleName name = ProfileParser.parseRoleName(buff.toString());\n                    results.add(name);\n                    buff = new StringBuffer();\n                } else {\n                    buff.append(NL);\n                }\n            }\n        } catch (MalformedURLException e) {\n        } catch (IOException e) {\n        } catch (ParsingException e) {\n        }\n        return results;\n    }\n", "label": 0, "substitutes": {"doFinishLoadAttachment": ["doFinishLoadInstment", "doFinishloadAttments", "doFinishLoadInstortion", "doFinishloadAttachortion", "doFinishLoadInstachment", "doFinishLoadAttachortion", "doFinishloadAttachachment", "doFinishLoadAssment", "doFinishLoadAssachment", "doFinishLoadInstments", "doFinishloadAttachment", "doFinishLoadAssments", "doFinishLoadAttachachment", "doFinishLoadAttment", "doFinishLoadAttments", "doFinishloadAttment", "doFinishloadAttachments", "doFinishLoadAttachments", "doFinishloadAttortion", "doFinishLoadAttortion", "doFinishLoadAssortion"], "attachmentId": ["attentionPath", "attimageInfo", "adachmentPath", "adociationPath", "AttachmentID", "attlementId", "attimagePath", "ttociationID", "attociationID", "attlementType", "attentionType", "attimageID", "attociationPath", "adachmentInfo", "attociationInfo", "attociationId", "attentionID", "adachmentID", "adociationInfo", "ttociationId", "attachmentType", "adociationID", "ttachmentId", "attlementid", "attachmentPath", "AttachmentType", "attplementationid", "ttachmentID", "attachmentID", "attentionInfo", "attentionId", "attentionid", "attachmentid", "ttachmentid", "attociationid", "attplementationID", "attachmentInfo", "AttachmentId", "attplementationId", "Attachmentid", "adociationId", "attimageId", "attlementID", "ttociationid", "adachmentId"], "attachment": ["appachment", "attachached", "instention", "assached", "attruction", "attociation", "attention", "instachment", "attached", " adaptment", " adaptachment", " attention", "assment", "instruction", "attment", "adention", " attociation", "attachruction", " adaptociation", " attment", "adached", "appention", "appment", "association", "assention", "attachachment", "adment", "attachention", "appruction", "adachment", " adaptention", "instment", "assachment"], "attachmentUri": ["attachmentIURI", "attachmentARI", "attachmentCuURI", "attachmentAuri", "attachmentSuuri", "attachedUti", "attachmentAti", "attachmentUURI", "attachmentEti", "attmentUri", "attachmentUti", "attachmentIuri", "attachmentSuURI", "attmentIri", "attachmentURI", "attmentIris", "attachedAti", "attachedAuri", "attachmentSuri", "attachmentCuris", "attachmentCuri", "attmentUURI", "attachmentIris", "attachmentUuri", "attachedUri", "attmentUris", "attachmentCuuri", "attachedARI", "attachmentEuri", "attmentUuri", "attachmentUris", "attachmentEri", "attachmentERI", "attachmentAri", "attachedUuri", "attachmentSuti", "attmentIURI", "attachmentSuRI", "attachedAri", "attachmentIri", "attmentIuri", "attachedURI", "attachmentSuris"], "contentUri": ["contentIi", "resourceUi", " contentUdi", " contentUris", "contentCdi", "resourceIRI", "contentSuris", "contentCRI", "contentUsri", "contentIri", "contentURris", "resourceUri", "contentCri", "resourceIris", "contentCuri", "contentSudi", "contentUuri", "contentFileris", "contentFileuri", "contentUsris", "contentUdi", " contentSuri", "resourceIi", "contentUsdi", "contentURri", "resourceIri", "contentUi", "contentUsRI", " contentSuRI", "resourceUuri", "contentCris", "resourceURI", "contentFileRI", " contentURI", "contentSuRI", "contentURuri", "resourceUris", "contentUsuri", " contentSudi", "contentIris", "contentUris", " contentSuris", "contentSuri", "contentIuri", "contentCi", "contentURi", "contentIRI", "contentFileri", "resourceIuri", "contentURI"], "file": ["get", "image", "auto", "buffer", "upload", "stream", "files", "up", "output", "socket", "object", "use", "view", "load", "input", "copy", "ger", "handler", "picture", "File", "cache", "child", "to", "connection", "content", "path", "resource", "fp", "io", "single", "line", "work", "FILE", "book", "f", "url", "letter", "this", "unit", "base", "binary", "zip", "model", "data", "pe", "create", "b", "local", "log", "via", "name", "entity", "reader", "le", "folder", "uri", "source", "filename", "able"], "in": ["r", "image", "m", "pin", "sync", "inn", "gin", "i", "socket", "s", "init", "input", "e", "copy", "id", "cli", "din", "conn", "or", "connection", "a", "inner", "io", "pull", "nin", "ini", "con", "f", "url", "binary", "this", "o", "login", "data", "err", "ac", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "source", "up", "c", "inc"], "out": ["Out", "image", "client", "writer", "sync", "one", "i", "output", "socket", "view", "s", "init", "copy", "on", "cli", "page", "ex", "cache", "to", "conn", "connection", "inner", "ext", "resource", "io", "nin", "line", "o", "this", "null", "base", "exec", "data", "err", "b", "log", "net", "bin", "In", "by", "again", "OUT", "IN", "outs", "outer", "lock", "source", "up", "inc"], "intent": ["request", "category", "animate", "anim", "intention", "term", "ctx", "element", "entry", "concept", "impact", "ink", "focus", "object", "action", "context", "Activity", "init", "eng", "vent", "agent", "android", "content", "inst", "response", "xml", "ant", "feat", "acc", "enc", "this", "feature", "activate", "ents", "spirit", "ani", "contact", " Intent", "ent", "activity", "it", "text", "language", "advert", "document", "activation", "anc", "entity", "event", "act", "effect"]}}
{"id1": "7764011", "id2": "10436471", "code1": "    public void readScalarpvviewerDocument(URL url) {\n        try {\n            String xmlData = \"\";\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String line = \"\";\n            boolean cont = true;\n            while (cont) {\n                line = in.readLine();\n                if (line == null) {\n                    break;\n                }\n                line = line.trim();\n                if (line.length() > 0 && line.charAt(0) != '%') {\n                    xmlData = xmlData + line + System.getProperty(\"line.separator\");\n                }\n                if (line.length() > 1 && line.charAt(0) == '%' && line.charAt(1) == '=') {\n                    cont = false;\n                }\n            }\n            XmlDataAdaptor readAdp = null;\n            readAdp = XmlDataAdaptor.adaptorForString(xmlData, false);\n            if (readAdp != null) {\n                XmlDataAdaptor scalarpvviewerData_Adaptor = readAdp.childAdaptor(dataRootName);\n                if (scalarpvviewerData_Adaptor != null) {\n                    cleanUp();\n                    setTitle(scalarpvviewerData_Adaptor.stringValue(\"title\"));\n                    XmlDataAdaptor params_font = scalarpvviewerData_Adaptor.childAdaptor(\"font\");\n                    int font_size = params_font.intValue(\"size\");\n                    int style = params_font.intValue(\"style\");\n                    String font_Family = params_font.stringValue(\"name\");\n                    globalFont = new Font(font_Family, style, font_size);\n                    fontSize_PrefPanel_Spinner.setValue(new Integer(font_size));\n                    setFontForAll(globalFont);\n                    XmlDataAdaptor params_pts = scalarpvviewerData_Adaptor.childAdaptor(\"Panels_titles\");\n                    viewValuesPanel.setTitle(params_pts.stringValue(\"values_panel_title\"));\n                    viewChartsPanel.setTitle(params_pts.stringValue(\"charts_panel_title\"));\n                    XmlDataAdaptor params_data = scalarpvviewerData_Adaptor.childAdaptor(\"PARAMETERS\");\n                    if (params_data != null) {\n                        viewValuesPanel.setLastMemorizingTime(params_data.stringValue(\"lastMemorizingTime\"));\n                    } else {\n                        viewValuesPanel.setLastMemorizingTime(\"No Info. See time of file modification.\");\n                    }\n                    XmlDataAdaptor params_uc = scalarpvviewerData_Adaptor.childAdaptor(\"UpdateController\");\n                    double updateTime = params_uc.doubleValue(\"updateTime\");\n                    updatingController.setUpdateTime(updateTime);\n                    double chartUpdateTime = params_uc.doubleValue(\"ChartUpdateTime\");\n                    viewChartsPanel.setTimeStep(chartUpdateTime);\n                    viewValuesPanel.listenModeOn(params_uc.booleanValue(\"listenToEPICS\"));\n                    viewChartsPanel.recordOn(params_uc.booleanValue(\"recordChartFromEPICS\"));\n                    java.util.Iterator<XmlDataAdaptor> pvIt = scalarpvviewerData_Adaptor.childAdaptorIterator(\"ScalarPV\");\n                    while (pvIt.hasNext()) {\n                        XmlDataAdaptor pvDA = pvIt.next();\n                        String pvName = pvDA.stringValue(\"pvName\");\n                        double refVal = pvDA.doubleValue(\"referenceValue\");\n                        double val = 0.;\n                        if (pvDA.hasAttribute(\"value\")) {\n                            val = pvDA.doubleValue(\"value\");\n                        }\n                        spvs.addScalarPV(pvName, refVal);\n                        ScalarPV spv = spvs.getScalarPV(spvs.getSize() - 1);\n                        spv.setValue(val);\n                        spv.showValueChart(pvDA.booleanValue(\"showValueChart\"));\n                        spv.showRefChart(pvDA.booleanValue(\"showRefChart\"));\n                        spv.showDifChart(pvDA.booleanValue(\"showDifChart\"));\n                        spv.showDif(pvDA.booleanValue(\"showDif\"));\n                        spv.showValue(pvDA.booleanValue(\"showValue\"));\n                        spv.showRef(pvDA.booleanValue(\"showRef\"));\n                    }\n                }\n            }\n            spvs.readChart(in);\n            in.close();\n            updatingController.setStop(false);\n            viewValuesPanel.updateGraph();\n            viewChartsPanel.updateGraph();\n        } catch (IOException exception) {\n            messageTextLocal.setText(null);\n            messageTextLocal.setText(\"Fatal error. Something wrong with input file. Stop.\");\n        }\n    }\n", "code2": "    @Override\n    public Cal3dModel loadModel(URL url, String skin) throws IOException, IncorrectFormatException, ParsingErrorException {\n        boolean baseURLWasNull = setBaseURLFromModelURL(url);\n        Cal3dModel model = new Cal3dModel(getFlags());\n        loadCal3dModel(getBaseURL(), url.toExternalForm(), new InputStreamReader(url.openStream()), model);\n        if (baseURLWasNull) {\n            popBaseURL();\n        }\n        return (model);\n    }\n", "label": 0, "substitutes": {"readScalarpvviewerDocument": ["readScalarpvViewersDocument", "readScalarpvviewersDocument", "readScalarpvviewersString", "readScalarpvViewerDocument", "readScalarpvviewedDocument", "readScalarpvviewedString", "readScalarpvviewedData", "readScalarpvViewersdocument", "readScalarpvvieweString", "readScalarpvviewerData", "readScalarpvviewerdocument", "readScalarpvViewersData", "readScalarpvvieweDocument", "readScalarpvViewerString", "readScalarpvviewerString", "readScalarpvvieweddocument", "readScalarpvViewersString", "readScalarpvViewerData", "readScalarpvvieweData", "readScalarpvviewedocument", "readScalarpvviewersData", "readScalarpvviewersdocument", "readScalarpvViewerdocument"], "url": ["image", "job", "buffer", "service", "sl", "entry", "stream", "host", "object", "input", "user", "page", "server", "address", "bel", "connection", "http", "location", "URL", "resource", "path", "io", "xml", "ssl", "file", "config", "link", "Url", "base", "data", "name", "l", "reader", "string", "href", "remote", "uri", "source", "filename"], "xmlData": ["xmlPart", "mlDATA", "parseText", "mlContent", "wsdata", "mlCode", "xfDATA", "rssData", " xmlContent", "textDATA", " xmlDATA", "xmlDATA", "xmlText", "textContent", "phpContent", " xmlPart", " xmldata", "phpDATA", "xmlCode", "xfContent", "xmlString", "phpData", "xmlContent", "rssdata", "parsedata", "wsString", "xfData", "mlText", "mldata", "wsDATA", "textData", "parseData", "textPart", " xmlCode", "xfText", "xmldata", "wsData", "phpPart", "rssString", "rssDATA", " xmlString", " xmlText", "mlData", "parseCode"], "in": ["r", "buffer", "m", "h", "inn", "stream", "i", "socket", "s", "input", "din", "lin", "connection", "a", "inner", "nin", "ssl", "out", "ini", "rec", "file", "kin", "con", "min", "f", "this", "serv", "doc", "login", "data", "b", "ins", "l", "In", "bin", "reader", "IN", "again", "win", "source", "c", "inc"], "line": ["error", "lf", "sync", "entry", "cell", "comment", "chain", "section", "content", "word", "value", "str", "link", "end", "letter", "no", "base", "range", "ine", "text", "name", "string", "non", "ip", "sl", "one", "character", "user", "parse", "page", "rule", "lines", "strip", "message", "single", "file", "part", "unit", "edge", "l", "plugin", "job", "auto", "object", "el", "e", "on", "lc", "phrase", "Line", "lin", "row", "pass", "pe", "log", "split", "cl", "nl", "point", "item", "c", "block", "write", "code", "none", "inline", "data", "LINE", "le"], "cont": ["clean", "match", "progress", "contin", "left", "full", "cond", "mult", "collect", "form", "cell", "comb", "ctr", "multi", "feed", " cond", "expl", "parent", "sect", "lc", " CONT", "com", "circ", "coll", "const", "complete", "ci", "result", "content", "ident", "ext", "cor", "out", "count", "dest", "Cont", "resp", "str", "ont", "feat", "acc", "close", "rest", "err", "keep", "char", "ent", "comp", "text", "continue", "contract", " Cont", "cart", "ct", " cur", "prev", " continuous", "det", "tr", "CONT"], "readAdp": [" readAds", "readAxp", " readAbr", "readAdc", "readPromp", " readAblp", "readAds", "loadAdpi", "loadAdb", "readADb", " readadP", "readAxpi", "ReadAxpi", "readADs", "readAblp", "readEdpi", "readAxps", "readPromb", " readAdlp", "loadADb", "readADpi", "readAbp", "readADlp", "readAbpi", "readEllr", "ReadAxc", "loadAdlp", "readEdc", "readAdP", "ReadAxps", "ReadAxp", "readElllp", "readads", "ReadAdps", "readEdp", "readAdb", "ReadAdp", " readAbpi", "readadc", "readadpi", "readPromlp", "readEllpi", " readAbp", "readPrompi", " readads", "readadp", " readAdr", "loadADpi", "readadP", "loadADlp", "loadAdp", "readAbb", "readEllp", "ReadAdpi", "readadps", "ReadAdc", "readAdps", " readAdP", "readAdpi", " readadpi", "readAbr", "readAxs", "readEdps", "readAxP", "readADp", " readadp", "loadADp", "readAdr", " readAdpi", "readADr", "readADP", "readAdlp", "readAxc"], "scalarpvviewerData_Adaptor": ["scalarpvviewerDataLocalAdaptor", "scalarpvviewerData_Selectator", "scalarpvviewerData_adaptive", "scalarpvviewerData_Collector", "scalarpvviewerData_Creative", "scalarpvviewerData_Creatutor", "scalarpvviewerData_CollectOR", "scalarpvviewerData_Collectractor", "scalarpvviewerDataerAdaptor", "scalarpvviewerData_adaptOR", "scalarpvviewerData_Creatator", "scalarpvviewerData_Connector", "scalarpvviewerData_Creator", "scalarpvviewerDataeradaptor", "scalarpvviewerData_Adaptutor", "scalarpvviewerData_Selecter", "scalarpvviewerData_Uploador", "scalarpvviewerData_Connectors", "scalarpvviewerData_Connectutor", "scalarpvviewerData_adapter", "scalarpvviewerData_Adaptive", "scalarpvviewerData_Creater", "scalarpvviewerData_Connecter", "scalarpvviewerData_Selectors", "scalarpvviewerDataLocaladaptors", "scalarpvviewerDataLocaladaptor", "scalarpvviewerDataerAdaptractor", "scalarpvviewerDataeradaptractor", "scalarpvviewerData_adaptutor", "scalarpvviewerDataLocaladaptator", "scalarpvviewerData_adaptors", "scalarpvviewerDataerAdaptutor", "scalarpvviewerDataLocalAdaptator", "scalarpvviewerData_Uploadive", "scalarpvviewerDataLocalAdaptors", "scalarpvviewerDataerAdaptors", "scalarpvviewerDataeradapter", "scalarpvviewerDataLocalAdaptOR", "scalarpvviewerData_Adaptator", "scalarpvviewerData_ConnectOR", "scalarpvviewerData_Creators", "scalarpvviewerData_Collectutor", "scalarpvviewerDataerAdapter", "scalarpvviewerDataeradaptutor", "scalarpvviewerData_Collectors", "scalarpvviewerDataeradaptors", "scalarpvviewerData_Connectator", "scalarpvviewerData_Uploadors", "scalarpvviewerData_adaptractor", "scalarpvviewerDataLocaladaptOR", "scalarpvviewerData_Adapter", "scalarpvviewerData_Collectator", "scalarpvviewerDataeradaptator", "scalarpvviewerDataerAdaptator", "scalarpvviewerData_adaptator", "scalarpvviewerData_Selector", "scalarpvviewerData_adaptor", "scalarpvviewerData_Adaptors", "scalarpvviewerData_Adaptractor", "scalarpvviewerData_AdaptOR", "scalarpvviewerData_Uploadator"], "params_font": ["ams_theme", "paramsingpen", "pins_password", " params_layout", "ams_pen", "ams_font", " params_shadow", "ams_chart", "params_fat", "pins_text", "paramsingfont", "params_Font", "params_pen", "params_text", "pins_fat", "params_layout", "pins_font", "paramsingfat", "ams_fat", "params_theme", "paramsinglarge", "params_shadow", "params_password", "params_chart", "ams_large", "params_large", " params_Font"], "font_size": ["font\u00b7handle", "fontBlocktype", "text_align", " font_handle", "text_Size", "font_align", "font_Size", " font_number", "fontBlockSize", "font\u00b7number", "fontBlocksize", "font_number", " font_scale", "text_size", "fontBlockalign", " font_Size", "font_handle", "text_type", "font_scale", "font_type", "font\u00b7size"], "style": ["position", "font", "pad", "level", "size", "shape", " Style", "styles", "profile", "class", "pattern", "order", "layout", "theme", "estyle", "height", "thin", "css", "family", " size", "padding", "format", "grade", "weight", "count", "depth", "letter", "scale", "type", "shadow", "offset", "margin", "color", "force", "Style", "width", "name", "length"], "font_Family": ["fontNameFamily", "fontingfamily", "fontNameStyle", " font_fam", "font_family", "font_Style", "style_Style", "fontNamefamily", "fontingStyle", "font_fam", " font_Format", "font_Format", "style_family", "fontingFamily", "style_Family", " font_family"], "globalFont": ["GlobalFont", "parentText", "generalFontSize", " globalFontSize", "parentFont", " globalText", "Globalfont", "GlobalFontSize", "GlobalText", "localFont", "parentfont", "parentFontSize", "generalFont", "globalText", " globalfont", "generalText", "globalfont", "localText", "globalFontSize", "localFontSize"], "params_pts": ["params_rts", "params_fontn", "params_PTm", "params_ptss", "params_fonts", "params_PTn", "params_ptm", "params_ctm", "params_tds", "params__ptm", "params_pta", "params_PTa", "params_PTs", "params_ptp", "params_rtn", "params_epts", "params_eptn", "params_tde", "params__cts", "params_eptss", "params_PTe", "params_ctn", "params__pts", "params_fontp", "params_eptp", "params__ctm", "params_PTp", "params_tda", "params_cts", "params_ptn", "params_pte", "params_erte", "params_rtm", "params__ptn", "params_fontss", "params_PTss", "params_erts", "params_erta", "params__ctn"], "params_data": ["paramsname", "Parametersname", "Parameters\n", " paramsname", "paramname", "param\n", " params\n", "params\n"]}}
{"id1": "15262411", "id2": "19322941", "code1": "    String fetch_pls(String pls) {\n        InputStream pstream = null;\n        if (pls.startsWith(\"http://\")) {\n            try {\n                URL url = null;\n                if (running_as_applet) {\n                    url = new URL(getCodeBase(), pls);\n                } else {\n                    url = new URL(pls);\n                }\n                URLConnection urlc = url.openConnection();\n                pstream = urlc.getInputStream();\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        if (pstream == null && !running_as_applet) {\n            try {\n                pstream = new FileInputStream(System.getProperty(\"user.dir\") + System.getProperty(\"file.separator\") + pls);\n            } catch (Exception ee) {\n                System.err.println(ee);\n                return null;\n            }\n        }\n        String line = null;\n        while (true) {\n            try {\n                line = readline(pstream);\n            } catch (Exception e) {\n            }\n            if (line == null) {\n                break;\n            }\n            if (line.startsWith(\"File1=\")) {\n                byte[] foo = line.getBytes();\n                int i = 6;\n                for (; i < foo.length; i++) {\n                    if (foo[i] == 0x0d) {\n                        break;\n                    }\n                }\n                return line.substring(6, i);\n            }\n        }\n        return null;\n    }\n", "code2": "    @Test\n    public void test_lookupResourceType_FullSearch_TwoWordsInMiddle() throws Exception {\n        URL url = new URL(baseUrl + \"/lookupResourceType/armor+plates\");\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n        connection.setRequestMethod(\"GET\");\n        connection.setRequestProperty(\"Accept\", \"application/json\");\n        assertThat(connection.getResponseCode(), equalTo(200));\n        assertThat(getResponse(connection), equalTo(\"[{\\\"itemTypeID\\\":25605,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Armor Plates\\\",\\\"icon\\\":\\\"69_09\\\"},{\\\"itemTypeID\\\":25624,\\\"itemCategoryID\\\":4,\\\"name\\\":\\\"Intact Armor Plates\\\",\\\"icon\\\":\\\"69_10\\\"}]\"));\n        assertThat(connection.getHeaderField(\"Content-Type\"), equalTo(\"application/json; charset=utf-8\"));\n    }\n", "label": 0, "substitutes": {"fetch_pls": ["fetch_pullp", "fetch_pulls", "fetch_pulla", "fetch_Plss", "fetch_plp", "fetch_pla", "fetch_Plp", "fetch_plss", "fetch_Pls", "fetch_pullss", "fetch_Pla"], "pls": [" Pls", "splS", " Plgs", "PLS", "plS", "replS", "plss", "splss", "bls", "PLss", "spls", "ylses", "plses", " plp", "ptS", "plts", " pli", "plf", "replss", "pli", "Pls", " plss", "pts", "yls", "bli", " plgs", "Plf", "ylp", "ylts", "repls", "plgs", "blgs", "Plses", "PLs", "plp", "splses", "splb", "splf", "splts", "ptss", " plS", "Plp", "plb", " plb", "replb", " Pli", "ylf", " plts", "splp"], "pstream": ["pengine", " pfeed", " prow", "tstream", "psengine", "psStream", "psw", "tbody", "Pchannel", "pschannel", "PStream", "fchannel", "spsw", "Pstream", "tchannel", "ipstream", "frow", "fstream", "ipstring", "Pengine", "ppsource", "ipsource", "ppfeed", "psstream", "spStream", "psource", " punk", "ipfeed", "Psw", "ppstream", " pbody", "fengine", "pstring", "spstream", "ppath", "tsource", "perbody", " ppath", "pchannel", "parpath", " pStream", "ppstring", " pstring", "pStream", "perchannel", " psource", "punk", "parrow", "fstring", "fpath", "perstream", "parstream", "Punk", " pchannel", "prow", "persource", "fStream", " psw", "parstring", "spunk", "pfeed", "pbody"], "url": ["image", "blog", "client", "service", "sl", "ul", "rl", "host", "feed", "impl", "fl", "bug", "ls", "page", "www", "server", "coll", "address", "bel", "conn", "loc", "open", "connection", "http", "hub", "URL", "path", "resource", "pull", "ob", "ssl", "file", "build", "link", "f", "Url", "api", "base", "control", "gl", "b", "log", "org", "rel", "ll", "l", "string", "web", "ur", "uri", "source", "c"], "urlc": ["webf", " urlconn", " urlp", "webc", "bbf", "urln", "webn", "Urlc", "bbci", "urlf", "webci", "URLconn", "bbn", "Urll", "Urlconn", " urln", "URLp", "URLc", "URLl", "Urlp", "urlp", " urlci", " urll", "urlci", "urll", "urlconn", " urlf", "bbc"], "line": ["next", "error", "lo", "sl", "lf", "one", "sync", "entry", "block", "key", "cell", "object", "comment", "el", "load", "parse", "write", "e", "page", "lc", "rule", "home", "val", "lines", "Line", "lin", "code", "strip", "response", "message", "day", "word", "value", "row", "file", "end", "link", "no", "pass", "base", "definition", "inline", "data", "pe", "log", "b", "ine", "LINE", "text", "co", "name", "l", "frame", "style", "body", "string", "header", "nl", "le", "lock", "look", "source"], "foo": ["la", "flo", "hello", "pos", "key", "little", "bug", "bo", "page", "office", "po", "py", "nice", "oo", "fe", "info", "que", "stuff", "home", "goo", "dirty", "fb", "code", "day", "something", "value", "date", "file", "qa", "oa", "fun", "f", "buf", "prefix", "data", "type", "xxxx", "bar", "token", "done", "name", "company", "string", "header", "front", "floor", "field"], "i": ["ai", "in", "ip", "ki", "j", "p", "eni", "is", "multi", "fi", "ix", "e", "id", "abi", "ci", "mu", "gi", "limit", "ui", "info", "index", "li", "ii", "io", "vi", "ini", "bi", "start", "x", "pi", "f", "end", "o", "xi", "ti", "k", "ri", "u", "ni", "b", "v", "oi", "mi", "di", "hi", "l", "d", "si", "qi", "uri", "I", "c"]}}
{"id1": "5441579", "id2": "8024375", "code1": "    public static String createPseudoUUID() {\n        try {\n            MessageDigest messageDigest = MessageDigest.getInstance(\"MD5\");\n            messageDigest.update(new UID().toString().getBytes());\n            try {\n                String localHost = InetAddress.getLocalHost().toString();\n                messageDigest.update(localHost.getBytes());\n            } catch (UnknownHostException e) {\n                throw new OXFException(e);\n            }\n            byte[] digestBytes = messageDigest.digest();\n            StringBuffer sb = new StringBuffer();\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 0)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 4)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 6)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 8)));\n            sb.append('-');\n            sb.append(toHexString(NumberUtils.readShortBigEndian(digestBytes, 10)));\n            sb.append(toHexString(NumberUtils.readIntBigEndian(digestBytes, 12)));\n            return sb.toString();\n        } catch (NoSuchAlgorithmException e) {\n            throw new OXFException(e);\n        }\n    }\n", "code2": "    private void getRandomGUID(boolean secure) {\n        MessageDigest md5 = null;\n        StringBuffer sbValueBeforeMD5 = new StringBuffer();\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            System.out.println(\"Error: \" + e);\n        }\n        try {\n            long time = System.currentTimeMillis();\n            long rand = 0;\n            if (secure) {\n                rand = mySecureRand.nextLong();\n            } else {\n                rand = myRand.nextLong();\n            }\n            sbValueBeforeMD5.append(s_id);\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(time));\n            sbValueBeforeMD5.append(\":\");\n            sbValueBeforeMD5.append(Long.toString(rand));\n            valueBeforeMD5 = sbValueBeforeMD5.toString();\n            md5.update(valueBeforeMD5.getBytes());\n            byte[] array = md5.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int j = 0; j < array.length; ++j) {\n                int b = array[j] & 0xFF;\n                if (b < 0x10) sb.append('0');\n                sb.append(Integer.toHexString(b));\n            }\n            valueAfterMD5 = sb.toString();\n        } catch (Exception e) {\n            System.out.println(\"Error:\" + e);\n        }\n    }\n", "label": 1, "substitutes": {"createPseudoUUID": [" createPseudoPUID", " createPseudoUuid", " createPseudoPMD", " createPseoUUID", " createPseudoPUD", " createPseudoUUUID", " createPseudoUUuid", " createPseudoPuid", " createPseudoUUD", " createPseoUUD", " createPseudoUUUD", " createPseoUuid", " createPseoUMD", " createPseudoUMD", " createPseudoUUMD"], "messageDigest": ["messageDiger", "messageDesigner", "messageSigner", "messageSignusher", "MessageDigusher", "messageSignener", "messageBuildester", " messageDest", "MessageDigener", "messageSignest", "messagedigse", "messageBuildest", "mailDigester", "messagedigest", "MessageDigester", "messageDester", "messageDest", "messageSignester", "MessageDigested", "messageDesignusher", "messageDigester", "messagedigEST", "MessageDigEST", " messageDiger", "messageDesignester", "messagedigusher", "messagedigested", "messageDigEST", "messageDigse", " messageDester", "maildigEST", " messageDer", "messageDesignEST", "mailDigEST", "messagediger", "messagedigester", "maildiger", "messagedigener", "MessageSignester", "MessageDigest", "MessageSignEST", "maildigester", "messageDigested", "mailDigest", "MessageSignusher", "MessageDigse", " messageDesting", "mailDiger", " messageDigesting", "messageDigener", "messageSignested", "messageDesignest", "messageDesting", "messageDigesting", "messageSignesting", " messageDigester", "messageDigusher", "messageBuilder", "MessageSignest", "maildigest", "messageDer", "messageBuildesting", "messageSignEST", "messageSignse"], "localHost": ["localhost", "LocalDomain", "remoteHost", "remotehost", "foreignAddress", "foreignDomain", "localDomain", " localAddress", "foreignPort", "remotePort", "LocalAddress", "LocalHost", " localhost", "localPort", " localPort", "LocalPort", "foreignHost", "remoteAddress", "Localhost", "localAddress", " localDomain"], "digestBytes": [" digengeBytes", "digesterBlocks", "digenseBytes", " digestParts", "digenseWords", "digESTBitcoin", "digesterBitcoin", "DigestByte", "digesterTokens", "digenseParts", "digestsBytes", " digesterParts", "digesterPoints", "digestParts", "digastBytes", "digestbytes", " digesterBlocks", "digESTBytes", "digestGb", "digensebytes", " digastbytes", " digestTokens", "digeterBytes", " digengeByte", "DigestPoints", "digestByte", "digesterWords", "DigestBytes", " digestByte", "digengeByte", "DigesterByte", "digastTokens", "DigestBitcoin", "digengeBitcoin", "digengeBytes", "digestBlocks", "digesterbytes", " digastByte", "digestedBytes", "DigestFiles", "digastbytes", "digesterByte", "digesterGb", "digsePages", "digendbytes", "digenseBitcoin", "digseBitcoin", "digesterParts", " digestbytes", "digestWords", "digestedBitcoin", "DigesterPoints", "digenseBlocks", "digseTokens", " digestPages", " digesterBytes", "digestampBytes", " digengePages", "digestedbytes", " digengeBitcoin", "digestPoints", "digestedByte", " digesterbytes", "digESTPoints", "digestFiles", "Digesterbytes", "digestedPages", "DigesterWords", "digESTbytes", " digastBytes", "digestedBlocks", "DigesterFiles", "digesterBytes", "digseByte", "DigestGb", "Digestbytes", "DigestWords", "digestampWords", "digeterFiles", "DigesterBitcoin", "digestampBitcoin", "digsebytes", "digestTokens", "digendBytes", "digeterGb", "digendBitcoin", "digestPages", "digestampbytes", "digestsPoints", " digastTokens", "digeterByte", "digestedParts", "digastByte", "digestBitcoin", "digestsByte", "digseBytes", " digestBitcoin", "digesterFiles", "DigesterBytes", "DigesterGb", "digESTByte", " digestBlocks", "digengePages"], "sb": ["lr", "db", "su", "abb", "bp", "buffer", "ai", "obj", "bf", "sl", "sp", "src", "lb", "bs", "s", "bt", "SB", "nn", "ib", "bb", "ls", "usb", "sa", "lc", "abi", "sf", "fe", "sg", "vm", "conn", "bc", "rb", "fb", "bg", "kb", "bm", "lp", "bl", "ob", "gb", "ssl", "sym", "bj", "Bs", "pb", "bi", "bh", "sr", "eb", "url", "buf", "binary", "wb", " SB", "BB", "b", "ba", "shell", "xb", "ss", "si", "nb", "nl", "sth", "sv", "ws", "cb", "txt"]}}
{"id1": "8135072", "id2": "17996547", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "label": 1, "substitutes": {"setImg": ["setImgm", "setImageg", "getImagevg", "getImagegs", "setImagegs", "setAmg", "getImageg", "getImgs", "setIMgs", "getImvg", "getImgm", "setIMgm", "setAmvg", "setImagevg", "getImagegm", "setImgs", "setImagegm", "setAmgs", "setAmgm", "setImvg", "setIMg", "getImg", "setIMvg"], "jFileChooser1": ["jFileCloserOne", "jFileChooser3", "jFileChooseone", "jFileChoose2", "jFileCloser3", "jFileChooserone", "jFileChoosing3", "jFileChoosing2", "jFileChoiser2", "jFileChoosen1", "jFileChoouter1", "jFileChooserOne", "jFileChoosen3", "jFileChoosingL", "jFileChooseL", "jFileChoitcher2", "jFileClose2", "jFileChoitcher3", "jFileClose01", "jFileChoosing1", "jFileChoose3", "jFileChoicker3", "jFileCloserL", "jFileChoickerOne", "jFileCloser1", "jFileChoouter2", "jFileChoosingOne", "jFileChoosen2", "jFileChoosen01", "jFileChoicker1", "jFileChoitcher1", "jFileChoitcherone", "jFileChoiser3", "jFileChoiser1", "jFileCloseOne", "jFileChoickerL", "jFileChoose01", "jFileCloser2", "jFileChooser01", "jFileChoosenone", "jFileCloser01", "jFileChooseOne", "jFileChooserL", "jFileChoouter3", "jFileChoose1", "jFileChooser2", "jFileChoouter01", "jFileChoiserOne", "jFileClose3", "jFileClose1", "jFileCloseL"], "separator": ["terminate", "seator", "separated", "generating", "separate", "separinator", "locating", "decigator", "escapate", "generate", "locoder", " separators", " separate", "escapators", "separner", " separner", "escapigator", "escapator", "locator", "location", "separoder", "variated", "seoder", "peration", "decators", "decate", "variation", "locate", "separigator", " separar", "separation", "generator", " separinator", "terminator", " separoder", "seate", "locinator", " separated", " separigator", "seinator", "perner", "separar", "separating", "variator", "terminar", "terminner", "perar", "perate", "variate", "generation", "decator", " separation", " separating", "perated", "perator", "separators"], "dirImg": ["dirImagesg", " dirImgs", " dirImimg", "dirImgb", "dirimg", "dirIMgd", "dirImvg", "dirIMgb", "directoryImgs", "folderImgs", "dirSeg", "dirImgs", "dirImgd", "directoryImagesg", "dirAnimgd", "dirSevg", "dirIMimg", "dirSegs", "folderImvg", " dirImgd", "dirAmog", "directoryImageg", "directoryImagegs", "dirUrg", "dirImog", "homeIMg", "dirImagegb", "directoryImgb", "homeImvg", "dirImsg", "directoryImg", "dirImagegs", "dirAnimvg", "dirimsg", "dirAnimm", "dirUrimg", "dirIMvg", "dirAmgs", "dirImimg", "folderImg", "dirUrgd", "folderImog", "dirAmg", "homeIMm", "dirIMgs", "dirIMm", "dirimgb", "dirAmvg", "dirImm", "dirImageg", "dirimgs", "homeIMvg", "dirSeog", "dirAnimg", "homeIMgd", "dirUrgs", "dirIMsg", "dirIMg", "directoryImagegb", "homeImm", "homeImg", "directoryImsg", "homeImgd"], "index": ["ind", "position", "match", "level", "size", "pos", "key", "i", "default", "action", "slice", "id", "page", "section", "address", "loc", "diff", "num", "path", "weight", "line", "value", "part", "len", "end", "x", "active", "axis", "type", "offset", "number", "Index", "name", "string", "point", "field", "length", "inc", "condition"], "imgName": [" imgType", "imgname", "imagePath", " imgPath", "iconType", "imgPart", "imageName", "iconPath", "iconName", " imgname", "imageType", "iconname", "ngPart", "imagename", "ngName", "imgType", " imgPart", "ngPath", "ngname", "imagePart", "imgPath"], "newPath": ["newFile", "NewPath", "oldPath", "NewFile", "workingName", "NewLocation", "Newpath", " newLocation", "nextFile", "nextLocation", "workingFile", "nextpath", "newpath", "oldpath", "newName", " newUrl", " newName", "workingpath", "nextPath", "oldFile", "nextUrl", "NewName", "workingPath", " newFile", " newpath", "newLocation", "newUrl", "NewUrl", "oldLocation"], "inputFile": ["InputFile", " inputPage", "InputFolder", "outputPath", "viewFile", "InputDirectory", " inputFolder", "InputFiles", " inputDirectory", "inputFolder", " inputStream", "InputDir", " inputFiles", "viewFolder", " inputPath", "outputFiles", "InputStream", "InputPage", "inPath", "inputDirectory", "viewDirectory", "inDir", "viewPath", "inputFiles", "InputPath", " inputDir", "inFile", "inputDir", "inputPage", "inputStream", "inputPath", "outputPage", "inStream"], "outputFile": ["outputDirectory", " outputFolder", "OutputDirectory", "targetFolder", "writefile", "outputPath", "writeFile", "outputDir", "targetPath", "outputStream", "inputFolder", "OutputFiles", " outputStream", " outputDirectory", "outputFolder", " outputfile", "outputFiles", "targetFiles", "OutputFile", "OutputPath", "inputDirectory", "inputfile", "writeStream", " outputDir", "inputFiles", "writeDir", " outputPath", "inputDir", " outputFiles", "targetFile", "outputfile", "inputStream", "inputPath"], "in": ["r", "h", "pin", "n", "inn", "fa", "isin", "i", "is", "socket", "init", "cin", "input", "id", "ex", "sin", "din", "conn", "plus", "diff", "lin", "connection", "a", "inner", "io", "nin", "ini", "into", "part", "inside", "f", "o", "login", "err", "ins", "bin", "In", "l", "reader", "IN", "as", "again", "lock", "win", "source", "up", "inc"], "out": ["Out", "plain", "error", "client", "writer", "sync", "off", "i", "output", "socket", "copy", "ex", "cache", "conn", "to", "plus", "inner", "io", "line", "file", "part", "down", "o", "lib", "exec", "err", "ins", "other", "net", "co", "name", "bin", "OUT", "again", "IN", "point", "outs", "outer", "up", "inc"], "c": ["r", "C", "sc", "m", "p", "ic", "n", "cp", "i", "ce", "rc", "cc", "character", "dec", "e", "cr", "cy", "ci", "lc", "t", "cu", "code", "nc", "bc", "pointer", "dc", "cm", "xc", "uc", "esc", "x", "f", "col", "cent", "o", "enc", "ch", "abc", "k", "ac", "b", "arc", "v", "cl", "ct", "pc", "l", "d", "ec"], "bckImg": ["bccImf", "bckIngl", "bckIngs", "bckInf", "bckImgl", "bccPg", "bckimg", "bccPgl", "bckimf", "bckImf", "bckPgs", "bckPg", "bckPgl", "bccPf", "bckPf", "bckimgs", "bckimgl", "bckImgs", "bccImg", "bccImgs", "bccImgl", "bckIng", "bccPgs"]}}
{"id1": "7044153", "id2": "13439950", "code1": "    private static void sendExceptionToServer(String server, Throwable ex, String config, String prob) {\n        try {\n            StringBuilder dataSB = new StringBuilder();\n            dataSB.append(URLEncoder.encode(\"secret\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(\"badsecurity\", \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"version\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(BuildInfo.revisionNumber, \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"os\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"os.name\") + \" \" + System.getProperty(\"os.version\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"user\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(System.getProperty(\"user.name\"), \"UTF-8\"));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"msg\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(ex.getMessage(), \"UTF-8\"));\n            ByteArrayOutputStream trace = new ByteArrayOutputStream();\n            ex.printStackTrace(new PrintStream(trace));\n            dataSB.append('&');\n            dataSB.append(URLEncoder.encode(\"trace\", \"UTF-8\"));\n            dataSB.append('=');\n            dataSB.append(URLEncoder.encode(trace.toString(), \"UTF-8\"));\n            if (config != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"config\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(config, \"UTF-8\"));\n            }\n            if (prob != null) {\n                dataSB.append('&');\n                dataSB.append(URLEncoder.encode(\"problem\", \"UTF-8\"));\n                dataSB.append('=');\n                dataSB.append(URLEncoder.encode(prob, \"UTF-8\"));\n            }\n            URL url = new URL(errorServerURL);\n            URLConnection conn = url.openConnection();\n            conn.setDoOutput(true);\n            OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n            wr.write(dataSB.toString());\n            wr.flush();\n            BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n            String response = null;\n            String line = null;\n            while ((line = rd.readLine()) != null) {\n                if (response == null) response = line; else System.out.println(line);\n            }\n            wr.close();\n            rd.close();\n            if (response.equals(\"success\")) System.out.println(\"Exception sent to maRla development team\"); else System.out.println(\"Unable to send exception to development team: \" + response);\n        } catch (IOException ex2) {\n            System.out.println(\"Unable to send exception to development team: \" + ex2.getMessage());\n        }\n    }\n", "code2": "    public String readRemoteFile() throws IOException {\n        String response = \"\";\n        boolean eof = false;\n        URL url = new URL(StaticData.remoteFile);\n        InputStream is = url.openStream();\n        BufferedReader br = new BufferedReader(new InputStreamReader(is));\n        String s;\n        s = br.readLine();\n        response = s;\n        while (!eof) {\n            try {\n                s = br.readLine();\n                if (s == null) {\n                    eof = true;\n                    br.close();\n                } else response += s;\n            } catch (EOFException eo) {\n                eof = true;\n            } catch (IOException e) {\n                System.out.println(\"IO Error : \" + e.getMessage());\n            }\n        }\n        return response;\n    }\n", "label": 1, "substitutes": {"sendExceptionToServer": ["sendExceptionAsService", "sendExceptionToHost", "sendExceptionWithServer", "sendErrortoHost", "sendExceptionAsServer", "sendErrorToServer", "sendExceptiontoserver", "sendExceptionAsHost", "sendErrortoServer", "sendExceptionWithserver", "sendExceptionWithService", "sendExceptionToService", "sendExceptionToserver", "sendExceptiontoServer", "sendErrorToHost", "sendExceptionAsserver", "sendExceptiontoService", "sendExceptiontoHost", "sendExceptionWithHost", "sendErrorToserver", "sendErrortoserver", "sendErrorToService", "sendErrortoService"], "server": ["domain", "db", "ip", "client", "service", "email", "host", "proxy", " host", "erver", "port", "json", "address", "http", "ssl", "conf", "root", "prefix", "serv", "base", "null", "test", "Server", "header", "addr", "ser"], "ex": ["error", "su", "ace", "obj", "tx", "full", "def", "Exc", "class", "e", "sex", "nex", "Exception", "fail", "example", " exc", "ax", "aux", "exp", "ext", "exit", "con", "Ex", "exc", "pex", "str", "lex", "x", "ception", "throw", "none", "exec", "base", "err", "except", "rex", "log", "temp", "cl", "status", "acer", "export", "res", "rupt", "event", "re", "EX", "hex"], "config": ["client", "service", "console", "rc", "app", "etc", "bug", "json", "address", "connection", "ext", "proc", "conf", "Conf", "file", "options", "base", "log", "Configuration", "text", "cfg", "settings", "Config", "cmd", "cb"], "prob": ["peb", "pebs", "Probs", "proj", "Proj", "probs", "Probe", "probe", " proj", " probe", "Prob", "pej", " probs", "pebe"], "dataSB": ["fileSL", "loadsb", "eventSB", "fullLB", "dataFB", " dataEB", "responseBL", "cacheSB", "offLB", "postSB", "noSL", "pLB", "errorPB", "dataRB", "DataLB", "uiSB", "execLB", "postLB", "datOB", "errorLB", "Datasb", "loadBB", "workSB", "codesb", "dataHL", "cacheBL", "uiLB", "dataBL", "offsb", "defaultLB", "dataOB", "offSB", "controlSB", "execBB", "errorBB", "codeHL", "contentsb", "responseLB", "codeMB", "responseSB", "codeFB", "codeEl", "dataBB", "DataMB", "DataOB", "dataSL", "dataLB", "errorSL", "fullBB", "execsb", "execSB", "execBL", " dataEl", "innerSL", "pSB", "DataSL", "eventBB", "ifSB", "postsb", "eventSL", "fullSB", "offSL", "controlBL", "controlLB", " dataPB", "errorsb", "codeSB", "ifSL", "strSB", "codeLB", "fileLB", "filesb", "loadSB", "noSB", "dataEB", "datLB", "noLB", " dataRB", "workPB", "ifLB", "contentLB", "dataBs", " dataFB", "contentOB", " datasb", "strLB", "defaultSB", " dataSL", "datasb", "dataEl", " dataBs", "controlsb", "strSL", "workSL", "postSL", "datSB", "loadLB", "innerLB", "offBB", " dataBL", "eventLB", "DataFB", "codeBs", "ifsb", "datBB", "DataBL", " dataOB", "innerSB", " dataBB", "psb", "fileSB", "defaultBB", " dataMB", "dataMB", "defaultsb", "pBs", "cacheLB", "DataSB", "innersb", "codeRB", "controlBB", "DataBB", "dataPB", "codeBB", "DataRB", "errorEB", "codeEB", "errorOB", "responseBB", " dataLB", "fullBL", "errorSB", "cachesb", "nosb", "DataHL", "workBB", "uiEl", " dataHL", "contentSB", "strsb"], "trace": ["r", " debug", "error", "ace", "fake", "buffer", "details", "tx", "profile", "flow", "ctr", "bug", "e", " tracing", "t", "cache", "stack", "address", "info", "span", "result", "strip", "array", "report", "message", "xml", "ray", "tri", "out", "debug", " traced", "cover", "trip", "scale", "data", "err", "temp", "ptr", "log", "shadow", "type", "trans", "test", "runner", "atter", "bean", " traces", "race", "track", "string", "tr"]}}
{"id1": "4778473", "id2": "15822137", "code1": "    private void loadProperties() {\n        if (properties == null) {\n            properties = new Properties();\n            try {\n                URL url = getClass().getResource(propsFile);\n                properties.load(url.openStream());\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n            }\n        }\n    }\n", "code2": "    public TableDirectory(RandomAccessFile raf) throws IOException {\n        version = raf.readInt();\n        numTables = raf.readShort();\n        searchRange = raf.readShort();\n        entrySelector = raf.readShort();\n        rangeShift = raf.readShort();\n        entries = new DirectoryEntry[numTables];\n        for (int i = 0; i < numTables; i++) {\n            entries[i] = new DirectoryEntry(raf);\n        }\n        boolean modified = true;\n        while (modified) {\n            modified = false;\n            for (int i = 0; i < numTables - 1; i++) {\n                if (entries[i].getOffset() > entries[i + 1].getOffset()) {\n                    DirectoryEntry temp = entries[i];\n                    entries[i] = entries[i + 1];\n                    entries[i + 1] = temp;\n                    modified = true;\n                }\n            }\n        }\n    }\n", "label": 0, "substitutes": {"loadProperties": ["loadProps", "loadPropertyps", "loadProproperties", "loadPperties", "getprops", "getProproperty", "loadPropertyperties", "getproperties", "loadProproperty", "loadPropertyproperty", "loadPproperties", "loadproproperty", "loadproperties", "loadproproperties", "getProps", "getProproperties", "getproproperty", "loadPps", "loadprops", "getProperties", "getproproperties", "loadPproperty", "loadPropertyproperties"], "properties": ["os", "perties", "details", "ils", "obj", "styles", "types", "notes", "limits", "fixes", "object", "prototype", "ls", "ips", "events", "features", "address", "gets", "lines", "objects", "info", "property", "reports", "posts", "params", "resources", "results", "pb", "options", "values", "groups", "bugs", "fps", "settings", "utils", "table", "style", "prop", "pro", "parts", "ps", "ports", "pps", "beans", "rules", "tests", "plugins"], "url": ["r", "image", "in", "client", "buffer", "sl", "element", "entry", "i", "class", "object", "user", "instance", "ls", "page", "server", "bel", "address", "connection", "http", "URL", "resource", "path", "not", "xml", "file", "f", "Url", "api", "base", "channel", "data", "gl", "loader", "b", "org", "article", "name", "l", "reader", "string", "uri", "event", "source"]}}
{"id1": "1485383", "id2": "18164929", "code1": "    private void runGetAppListing() {\n        DataStorage.clearAppListings();\n        GenericUrl url = new GoogleUrl(EnterpriseMarketplaceUrl.generateAppListingUrl() + DataStorage.getVendorProfile().vendorId);\n        AppListingList appListingList;\n        try {\n            HttpRequest request = requestFactory.buildGetRequest(url);\n            request.addParser(jsonHttpParser);\n            request.readTimeout = readTimeout;\n            HttpResponse response = request.execute();\n            appListingList = response.parseAs(AppListingList.class);\n            if (appListingList != null && appListingList.appListings != null) {\n                operationStatus = true;\n                DataStorage.setAppListings(appListingList.appListings);\n            }\n            response.getContent().close();\n        } catch (IOException e) {\n            AppsMarketplacePluginLog.logError(e);\n        }\n    }\n", "code2": "    public static boolean isCodebaseDownloadable(Properties p) {\n        class CodebaseData {\n\n            String file;\n\n            boolean success = true;\n        }\n        String codebase = p.getProperty(\"java.rmi.server.codebase\", null);\n        if (null == codebase) {\n            if (logger.isDebugEnabled()) logger.debug(\"java.rmi.server.codebase = null (return false)\");\n            return false;\n        }\n        try {\n            URL cbUrl = new URL(codebase);\n            String protocol = cbUrl.getProtocol();\n            String filename = cbUrl.getFile();\n            if (logger.isDebugEnabled()) {\n                logger.debug(\"Verifying java.rmi.server.codebase setting(s)...\");\n                logger.debug(\"Codebase = \" + cbUrl.toString());\n            }\n            if (protocol.equals(\"http\")) {\n                if (filename.indexOf(\"http\") == -1) {\n                    try {\n                        int size = cbUrl.openConnection().getContentLength();\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : OK\");\n                        return true;\n                    } catch (IOException e) {\n                        if (logger.isDebugEnabled()) logger.debug(\"Checking \" + cbUrl + \" : FAIL\");\n                        return false;\n                    } finally {\n                        if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    }\n                } else {\n                    ArrayList files = new ArrayList();\n                    StringTokenizer st = new StringTokenizer(codebase);\n                    URL url = null;\n                    String part = null;\n                    CodebaseData data = null;\n                    while (st.hasMoreTokens()) {\n                        part = st.nextToken();\n                        url = new URL(part);\n                        data = new CodebaseData();\n                        try {\n                            int len = url.openConnection().getContentLength();\n                            if (len == -1) {\n                                data.success = false;\n                                data.file = part;\n                            } else {\n                                data.file = part;\n                            }\n                        } catch (IOException e) {\n                            data.success = false;\n                        }\n                        files.add(data);\n                    }\n                    String wrong = null;\n                    CodebaseData codebaseData = null;\n                    boolean allOK = true;\n                    int errorFiles = 0;\n                    for (int i = 0; i < files.size(); i++) {\n                        codebaseData = (CodebaseData) files.get(i);\n                        if (!codebaseData.success) {\n                            wrong += \" \" + codebaseData.file;\n                            ++errorFiles;\n                            allOK = false;\n                        }\n                        if (logger.isDebugEnabled()) logger.debug((i + 1) + \". Checking \" + codebaseData.file + \" : \" + (codebaseData.success ? \"OK\" : \"FAIL\"));\n                    }\n                    if (errorFiles == 0) {\n                        if (logger.isDebugEnabled()) logger.debug(\"All entries can be downloaded successfully!\");\n                    } else {\n                        logger.error(errorFiles + \" of \" + files.size() + \" entries can *not* be downloaded successfully!\");\n                    }\n                    if (logger.isDebugEnabled()) logger.debug(\"Verifying java.rmi.server.codebase setting(s)... Done!\");\n                    if (allOK) {\n                        return true;\n                    } else {\n                        return false;\n                    }\n                }\n            } else if (protocol.equalsIgnoreCase(\"file\")) {\n                if (logger.isDebugEnabled()) logger.debug(\"'file' protocol not supported for JSF\");\n            }\n        } catch (MalformedURLException e) {\n            logger.debug(e.getMessage());\n            return false;\n        }\n        return false;\n    }\n", "label": 0, "substitutes": {"runGetAppListing": ["runGetApplicationlistInfo", "runGetApplicationListling", "runGetApplicationListing", "runGetAppListInfo", "runGetApplisting", "runGetAppSearchInfo", "runGetApplistInfo", "runGetApplicationListInfo", "runGetAppSupportInfo", "runGetApplistling", "runGetApplicationListings", "runGetApplicationlistling", "runGetAppSearching", "runGetAppSearchling", "runGetAppSearchings", "runGetApplicationlistings", "runGetAppSupportling", "runGetAppSupporting", "runGetApplicationlisting", "runGetAppListling", "runGetApplistings", "runGetAppSupportings", "runGetAppListings"], "url": ["image", "client", "buffer", "service", "i", "host", "proxy", "feed", "e", "route", "page", "json", "server", "address", "result", "connection", "http", "location", "URL", "resource", "path", "ssl", "build", "file", "f", "Url", "api", "base", "channel", "data", "builder", "download", "b", "l", "string", "href", "uri", "re", "source", "config"], "appListingList": ["appListingType", "appListingingGroup", "appListininglist", "appListitingData", "appListillingLibrary", "appListingLayer", "appHoldinglist", "appListingInfo", "appListningResult", "appLingList", "appListiningList", "appListningList", "appListINGL", "appListinglist", "appListingResult", "appPoolinglist", "appListingsLayer", "appListingingLibrary", "appListingMap", "appPoolingList", "appListillinglist", "appListdingList", "appListingingList", "appPooliningGroup", "appHoldingType", "appListitingResult", "appListitingEx", "appListdingLayer", "appListitinglist", "appPoolingGroup", "applistningResult", "appListitingLibrary", "appListinginglist", "appLeningList", "appListningData", "applistingResult", "appStingEx", "appPooliningList", "appListitingList", "appListninglist", "appListingData", "appListingEx", "appListdingEx", "appListingsList", "appListdingL", "appLingEx", "appStINGL", "appListeningInfo", "applistningList", "appHoldingingList", "appListgingEx", "applistingData", "appListINGEx", "appListillingType", "appListingLibrary", "appLingInfo", "appListINGLayer", "appStINGList", "appHoldingingType", "appListingsL", "appHoldingLibrary", "appListingsInfo", "appListitingType", "appHoldingingLibrary", "appListingL", "appListningEx", "appListiningGroup", "appListgingInfo", "applistingEx", "appStingList", "appHoldinginglist", "appListillingList", "appLeningMap", "appListingsEx", "applistningEx", "appListingsMap", "appListningGroup", "appLeningEx", "appListingsResult", "appLeningInfo", "applistningData", "appStingL", "applistingList", "appListINGList", "appStINGEx", "appListgingList", "appListingsData", "appStINGLayer", "appListeningEx", "appListingGroup", "appHoldingList", "appListingingType", "appListgingMap", "appListeningList", "appStingLayer", "appListeningMap", "appLingMap", "appPoolininglist"], "request": ["get", "job", "r", "next", "client", "buffer", "writer", "service", "rate", "query", "hello", "queue", "q", "transfer", "object", "use", "proxy", "input", "user", "parse", "e", "page", "json", "server", "address", "complete", "child", "result", "http", "resource", "report", "message", "xml", "build", "post", "req", "trip", "callback", "builder", "application", "method", "call", "have", "Request", "remote", "project", "command", "push", "uri", "re", "create", "condition"], "readTimeout": ["writeTime", "writeSocket", "readertimeout", " readtimeout", "readingAttempt", "writeTimeout", "readingtimeout", "readingTimeout", "readtimeout", "readingSocket", "readTime", " readSocket", " readTime", "readerTime", "readSocket", "readAttempt", "writeAttempt", "readerAttempt", "readingTime", "readerTimeout", "writetimeout"], "response": ["next", "image", "success", "error", "client", "writer", "stream", "received", "full", "output", "reply", "object", "feed", "version", "e", "page", "json", "server", "result", "connection", "http", "array", "resource", "report", "message", "Response", "resp", "api", "onse", "data", "status", "application", "wave", "document", "res", "site", "body", "respond", "generation", "re"]}}
{"id1": "23035537", "id2": "4461350", "code1": "    public boolean getContent(String userId, String latestMsgId) {\n        try {\n            String targetUrl = \"http://api.fanfou.com/statuses/user_timeline.xml?id=\" + userId + \"&since_id=\" + latestMsgId;\n            URL url = new URL(targetUrl);\n            InputStream in = url.openStream();\n            ArrayList<MessageObj> list;\n            if (in != null) {\n                MessageListDOMParser parser = new MessageListDOMParser();\n                list = (ArrayList<MessageObj>) parser.parseXML(in);\n                TransactionDAO dao = new TransactionDAO();\n                dao.insert(list);\n            }\n            return true;\n        } catch (Exception e) {\n            e.printStackTrace();\n            return false;\n        }\n    }\n", "code2": "        private boolean doCSVImport(String tableName, final boolean hasHeader) {\n            StringBuffer sql = new StringBuffer();\n            sql.append(\"INSERT INTO \");\n            sql.append(tableName + \"(\");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"\" + colNames.get(i) + \",\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\") VALUES( \");\n            for (int i = 0; i < colNames.size(); i++) {\n                sql.append(\"?,\");\n            }\n            sql.setLength(sql.length() - 1);\n            sql.append(\")\");\n            Connection conn = null;\n            int lineNumber = 0;\n            int colNumber = 0;\n            String line[] = null;\n            try {\n                conn = DBExplorer.getConnection(false);\n                conn.setAutoCommit(false);\n                PreparedStatement pstmt = conn.prepareStatement(sql.toString());\n                for (; lineNumber < csvData.size(); lineNumber++) {\n                    if (hasHeader && lineNumber == 0) continue;\n                    dlg.UpdateProgressBar(lineNumber);\n                    if (cancel) {\n                        break;\n                    }\n                    line = (String[]) csvData.get(lineNumber);\n                    pstmt.clearParameters();\n                    for (colNumber = 0; colNumber < colTypes.size(); colNumber++) {\n                        if (line[colNumber].equals(\"\") && colNullAllowed.get(colNumber).toString().equals(\"true\")) {\n                            pstmt.setNull(colNumber + 1, Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        } else {\n                            pstmt.setObject(colNumber + 1, line[colNumber], Integer.parseInt(colTypeInt.get(colNumber).toString()));\n                        }\n                    }\n                    pstmt.executeUpdate();\n                }\n                if (cancel) conn.rollback(); else conn.commit();\n                conn.setAutoCommit(true);\n                conn.close();\n                conn = null;\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        if (!cancel) {\n                            dlg.showMessage(title, \"Imported \" + maxsize + \" rows successfully.\");\n                            statusLabel.setText(\"Import complete.\");\n                        } else {\n                            dlg.UpdateProgressBar(0);\n                            statusLabel.setText(\"Import aborted.\");\n                        }\n                    }\n                });\n                return true;\n            } catch (final Exception e) {\n                if (conn != null) try {\n                    conn.rollback();\n                } catch (SQLException e1) {\n                    e1.printStackTrace();\n                }\n                dialog.getDisplay().asyncExec(new Runnable() {\n\n                    public void run() {\n                        statusLabel.setText(\"Import failed\");\n                        dlg.showError(title, e.getMessage());\n                        dlg.UpdateProgressBar(0);\n                    }\n                });\n                return false;\n            } finally {\n                if (conn != null) try {\n                    conn.close();\n                } catch (SQLException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n", "label": 0, "substitutes": {"getContent": ["readContent", "getContents", "readcontent", "createContents", "createcontent", "readContents", "getBody", "createContent", "getcontent", "createBody", "postcontent", "postBody", "readBody", "postContents", "postContent"], "userId": ["messageName", " userName", "userPath", " userOr", " userID", "USERName", "UserID", "userID", "userOr", "UserName", "USEROr", "USERId", " userPath", "UserPath", "USERPath", "UserId", "UserOr", "messageId", "messageID", "userName"], "latestMsgId": ["lastMessageId", " latestMsgTime", "latestChanId", "lastMsgid", " latestmsgTime", "latestUserId", "latestmsgID", "latestmsgId", " latestmsgId", "latestMsgTime", "latestChanID", "latestUserID", "latestMessageId", "latestChanid", "latestChanTime", "latestMessageTime", " latestMsgID", "lastMessageID", "latestMessageid", "latestMessageID", "latestmsgTime", "latestUserid", " latestMsgid", " latestmsgID", "latestMsgID", "lastMsgId", "lastMessageid", "latestMsgid", "latestmsgid", " latestmsgid", "lastMsgID"], "targetUrl": ["TargetURL", "sourcePage", " targeturl", "Targeturl", "targetURL", " targetURL", " targetUr", " targetPage", "targetUr", "targeturl", "TargetPage", "sourceurl", "sourceURL", "TargetUr", "sourceUr", "TargetUrl", "targetPage", "sourceUrl"], "url": ["image", "r", "client", "sl", "stream", "i", "host", "feed", "user", "id", "page", "server", "address", "connection", "http", "location", "URL", "path", "resource", "ssl", "file", "link", "f", "Url", "api", "base", "channel", "data", "download", "b", "l", "browser", "string", "uri", "window", "source", "www"], "in": ["get", "r", "image", "m", "query", "inn", "stream", "isin", "gin", "i", "is", "socket", "s", "load", "input", "arin", "din", "inas", "ax", "a", "inner", "resource", "nin", "xml", "out", "ini", "raw", "kin", "file", "pass", "serv", "login", "data", "err", "b", "ins", "record", "wave", "bin", "In", "reader", "string", "IN", "as", "again", "source", "inc"], "list": ["la", "detail", "batch", "tx", "tree", "entry", "all", "queue", "i", "view", "chain", "sequence", "dict", "parse", "LIST", "parent", "section", "lc", "cli", "id", "coll", "server", "json", "info", "group", "result", "listed", "array", "li", "lp", "pool", "xml", "set", "data", "live", "test", "collection", "cl", "lists", "language", "record", "document", "table", "l", "string", "item", "join"], "parser": ["writer", "p", "paragraph", "worker", "class", "parse", "parent", "Parser", "handler", "json", "per", "info", "ler", "rss", "a", "php", "http", "lp", "xml", "director", "util", "api", "data", "system", "builder", "player", "loader", "er", "collection", "jack", "language", "arser", "document", "processor", "plugin", "reader", "command", "layer"], "dao": ["adao", "Dosa", " daos", " dala", "adosa", "adaos", "idao", "idaba", " daba", "Dao", "dala", "daos", "Daos", "idaos", "daba", "datao", "adala", "datosa", "idosa", " dosa", "dataos", "datala", "dosa", "Daba"]}}
{"id1": "21488518", "id2": "13666876", "code1": "    @Override\n    public Resource createNew(String name, InputStream in, Long length, String contentType) throws IOException {\n        File dest = new File(this.realFile, name);\n        if (allowedClient) {\n            if (\".request\".equals(name) || \".tokens\".equals(name)) {\n                FileOutputStream out = null;\n                try {\n                    out = new FileOutputStream(dest);\n                    IOUtils.copy(in, out);\n                } finally {\n                    IOUtils.closeQuietly(out);\n                }\n                if (\".request\".equals(name)) {\n                    File request = new File(realFile.getAbsolutePath() + \"/\" + name);\n                    RequestManager.manageRequest(request, null, true);\n                    return new OverEncryptedFriendsFile(factory, folderPath + \"/.response\", allowedClient);\n                }\n                return new OverEncryptedFriendsFile(factory, folderPath + \"/\" + name, allowedClient);\n            } else {\n                return null;\n            }\n        } else {\n            LOGGER.error(\"User isn't owner of this folder\");\n            return null;\n        }\n    }\n", "code2": "    @Override\n    public String transformSingleFile(X3DEditorSupport.X3dEditor xed) {\n        Node[] node = xed.getActivatedNodes();\n        X3DDataObject dob = (X3DDataObject) xed.getX3dEditorSupport().getDataObject();\n        FileObject mySrc = dob.getPrimaryFile();\n        File mySrcF = FileUtil.toFile(mySrc);\n        File myOutF = new File(mySrcF.getParentFile(), mySrc.getName() + \".x3dv.gz\");\n        TransformListener co = TransformListener.getInstance();\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_starting\"));\n        co.message(NbBundle.getMessage(getClass(), \"Saving_as_\") + myOutF.getAbsolutePath());\n        co.moveToFront();\n        co.setNode(node[0]);\n        try {\n            String x3dvFile = ExportClassicVRMLAction.instance.transformSingleFile(xed);\n            FileInputStream fis = new FileInputStream(new File(x3dvFile));\n            GZIPOutputStream gzos = new GZIPOutputStream(new FileOutputStream(myOutF));\n            byte[] buf = new byte[4096];\n            int ret;\n            while ((ret = fis.read(buf)) > 0) gzos.write(buf, 0, ret);\n            gzos.close();\n        } catch (Exception ex) {\n            co.message(NbBundle.getMessage(getClass(), \"Exception:__\") + ex.getLocalizedMessage());\n            return null;\n        }\n        co.message(NbBundle.getMessage(getClass(), \"Gzip_compression_complete\"));\n        return myOutF.getAbsolutePath();\n    }\n", "label": 1, "substitutes": {"createNew": ["openResource", "createCopy", "openNew", "newNew", "openOpen", "createResource", "resourceCopy", "resourceResource", "newOpen", "newResource", "newCopy", "resourceNew", "openCopy", "resourceOpen", "createOpen"], "name": ["image", "client", "self", "large", "size", "one", "n", "full", "key", "class", "old", "label", "comment", "default", "common", "ix", "title", "parent", "e", "id", "office", "directory", "on", "address", "ame", "ui", "alias", "connection", "code", "content", "time", "path", "resource", "ext", "word", "value", "file", "part", "NAME", "end", "x", "url", "prefix", "no", "none", "base", "model", "data", "type", "missing", "Name", "number", "search", "names", "anc", "member", "style", "string", "ename", "named", "folder", "non", "current", "filename", "username"], "in": ["image", "buffer", "size", "src", "i", "init", "input", "slice", "thin", "id", "din", "plus", "diff", "connection", "inner", "resource", "ini", "raw", "file", "work", "con", "len", "pass", "exec", "login", "data", "ins", "record", "bin", "In", "reader", "IN", "read", "win", "source", "up", "inc"], "length": ["timeout", "buffer", "level", "size", "bytes", "load", "sequence", "ength", "id", "limit", "padding", "Length", "content", "path", "time", "line", "count", "len", "url", "type", "offset", "number", "width", "password", "body", "duration", "filename"], "contentType": ["ContentLength", "contentPath", "resourceLength", " contenttype", "resourceType", "contenttype", " contentLength", "ContentType", "resourcePath", "Contenttype", "contentLength", "resourcetype", " contentPath", "ContentPath"], "dest": ["de", "tx", "upload", "src", "output", "tmp", "comb", "opt", "parent", "thin", "route", "home", "Dest", "target", "result", "dc", "desc", "orig", "later", "img", "conf", "sup", "cdn", "dist", "store", "dir", "trip", "wb", "zip", "temp", "flat", "trans", "done", "transform", " destination", "d", "prop", "folder", "destroy", "gz", "cont", "tif", "source", "config", "txt"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "up", "output", "socket", "object", "view", "copy", "parent", "ex", "page", "cache", "server", "conn", "result", "connection", "exp", "path", "resource", "ext", "io", "pool", "img", "line", "file", "f", "url", "o", "null", "this", "exec", "zip", "channel", "data", "temp", "err", "log", "bin", "password", "again", "outs", "lock", "cmd", "gz", "flush", "source", "OUT"], "request": ["get", "job", "client", "buffer", "rate", "access", "query", "upload", "rer", "transfer", "object", "use", "user", "input", "instance", "reference", "route", "directory", "complete", "open", "child", "ext", "report", "resource", "path", "response", "xml", "quest", "store", "url", "req", "forward", "base", "type", "pe", "wheel", "call", "Request", "friend", "remote", "project", "QUEST", "respect", "re", "external", "config", "claim"]}}
{"id1": "22268798", "id2": "15645004", "code1": "    @Override\n    public Content getContent(Object principal, ContentPath path, Version version, Map<String, Object> properties) throws ContentException {\n        String uniqueName = path.getBaseName();\n        URL url = buildURL(uniqueName);\n        URLContent content = new URLContent(url, this.getName(), uniqueName);\n        content.setUniqueName(uniqueName);\n        content.setReadable(true);\n        content.setWritable(writable);\n        content.setExists(true);\n        try {\n            URLConnection connection = url.openConnection();\n            String mimeType = connection.getContentType();\n            content.setMimeType(mimeType);\n            content.setWritable(true);\n        } catch (IOException ex) {\n            throw new ContentException(\"unable to obtain mime type of \" + url, ex);\n        }\n        return content;\n    }\n", "code2": "    private void unzip(File filename) throws ZipException, IOException {\n        ZipInputStream in = new ZipInputStream(new BufferedInputStream(new FileInputStream(filename)));\n        ZipEntry entry = null;\n        boolean first_entry = true;\n        while ((entry = in.getNextEntry()) != null) {\n            if (first_entry) {\n                if (!entry.isDirectory()) {\n                    File subdir = new File(dir + File.separator + filename.getName().substring(0, filename.getName().length() - SUFFIX_ZIP.length()));\n                    if (!subdir.exists()) {\n                        subdir.mkdir();\n                        dir = subdir;\n                    }\n                }\n                first_entry = false;\n            }\n            if (entry.isDirectory()) {\n                FileUtils.forceMkdir(new File(dir + File.separator + entry.getName()));\n            } else {\n                File outfile = new File(dir + File.separator + entry.getName());\n                File outdir = new File(outfile.getAbsolutePath().substring(0, outfile.getAbsolutePath().length() - outfile.getName().length()));\n                if (!outdir.exists()) FileUtils.forceMkdir(outdir);\n                FileOutputStream fo = new FileOutputStream(outfile);\n                BufferedOutputStream bos = new BufferedOutputStream(fo, BUFFER);\n                int read;\n                byte data[] = new byte[BUFFER];\n                while ((read = in.read(data, 0, BUFFER)) != -1) {\n                    read_position++;\n                    bos.write(data, 0, read);\n                }\n                bos.flush();\n                bos.close();\n            }\n        }\n        in.close();\n    }\n", "label": 0, "substitutes": {"getContent": ["buildContent", "loadcontent", "getContents", "buildContents", "createResource", "loadResource", "getResource", "createcontent", "loadContents", "loadContent", "createContent", "getcontent", "buildResource", "buildcontent", "createContents"], "principal": ["Princinceter", "Princunctential", "prunctipal", "prercential", "Princincipal", "pricipipal", "Princincential", "Princunctipal", "pricipificate", "prerceter", "prunctential", "prercipal", "Princincificate", "pruncteter", "prercificate", "princeter", "pricipeter", "prunctificate", "Princuncteter", "pricipential", "princential", "Princunctificate", "princificate"], "path": ["request", "next", "client", "PATH", "class", "pattern", "object", "context", "user", "instance", "parent", "info", "property", "format", "Path", "location", "resource", "pointer", "file", "root", "part", "link", "prefix", "api", "data", "loader", "text", "method", "name", "node", "ath", "project", "prop", "string", "uri", "source"], "version": ["level", " versions", "release", "object", "Version", "parent", "json", "server", "val", "target", "ver", "format", "resource", "out", "date", "value", "VERSION", "str", "depth", "model", "v", "node", "versions", "project", "string", "vision", "current"], "properties": ["items", "perties", "details", "types", "ips", "metadata", "features", "address", "json", "objects", "state", "property", "params", "resources", "results", "options", "classes", "data", "values", "Property", "settings", "prop", "pro", "ps", "Pro", "fields", "plugins"], "uniqueName": ["baseName", "blockName", "blockPath", "uniqueKey", " uniqueKey", "blockKey", "UniqueName", "UniqueTime", "basePath", "basename", "UniqueKey", "stringName", "stringname", "uniqueTime", "blockType", " uniqueTime", "uniqueType", "uniquename", "stringKey", "UniquePath", "UniqueType", " uniquename", "fileName", "baseKey", "stringPath", " uniqueType", " uniquePath", "filePath", "fileTime", "uniquePath", "Uniquename", "filename"], "url": ["image", "position", "error", "client", "sl", "html", "host", "object", "el", "proxy", "feed", "user", "layer", "bb", "parent", "ls", "page", "server", "coll", "address", "conn", "loc", "open", "found", "location", "http", "URL", "resource", "ob", "ssl", "file", "build", "link", "f", "Url", "this", "channel", "base", "download", "log", "ll", "name", "l", "string", "web", "uri", "source", "www"], "content": ["image", "client", "ca", "creator", "location", "full", "Content", "host", "output", "ce", "object", "comment", "load", "proxy", "default", "user", "common", "instance", "layer", "parent", "copy", "section", "page", "cf", "core", "handler", "server", "const", "address", "coll", "conn", "child", "source", "lc", "cache", "result", "complete", "media", "container", "response", "resource", "message", "code", "ext", "cm", "change", "file", "key", "cover", "this", "wrapper", "model", "update", "ac", "temp", "data", "document", "node", "remote", "reader", "cont", "current", "create", "config", "c", "condition"], "connection": ["image", "position", "client", "connect", "creator", "relation", "object", "proxy", "context", "character", "section", "directory", "handler", "coll", "server", "conn", "loc", "open", "http", "response", "resource", "container", "io", "pool", "con", "connected", "channel", "session", "data", "control", "database", "application", "number", "reader", "string", "communication", "Connection", "uri", "config", "c"], "mimeType": ["metyInfo", "MIMEtype", "mimesName", "MimePath", "mimetype", "mimesType", "mIMEType", "MimeName", "mimesPath", "mmimetype", "mimeName", "mimePath", "mmivetype", "mmimeInfo", "mmiveType", "miveInfo", "mivetype", "mangtype", "mmiveInfo", "mmimeType", "Mimetype", "MIMEPath", "miveType", "mangType", "MimeType", "mIMEName", "metytype", "mimeInfo", "mimestype", "mangPath", "mIMEtype", "MIMEType", "mIMEPath", "MIMEName", "metyType", "mangName", "mIMEInfo"]}}
{"id1": "18374478", "id2": "20663364", "code1": "    public void updateUser(final User user) throws IOException {\n        try {\n            Connection conn = null;\n            boolean autoCommit = false;\n            try {\n                conn = pool.getConnection();\n                autoCommit = conn.getAutoCommit();\n                conn.setAutoCommit(false);\n                final PreparedStatement updateUser = conn.prepareStatement(\"update users set mainRoleId=? where userId=?\");\n                updateUser.setInt(1, user.getMainRole().getId());\n                updateUser.setString(2, user.getUserId());\n                updateUser.executeUpdate();\n                final PreparedStatement deleteRoles = conn.prepareStatement(\"delete from userRoles where userId=?\");\n                deleteRoles.setString(1, user.getUserId());\n                deleteRoles.executeUpdate();\n                final PreparedStatement insertRoles = conn.prepareStatement(\"insert into userRoles (userId, roleId) values (?,?)\");\n                for (final Role role : user.getRoles()) {\n                    insertRoles.setString(1, user.getUserId());\n                    insertRoles.setInt(2, role.getId());\n                    insertRoles.executeUpdate();\n                }\n                conn.commit();\n            } catch (Throwable t) {\n                if (conn != null) conn.rollback();\n                throw new SQLException(t.toString());\n            } finally {\n                if (conn != null) {\n                    conn.setAutoCommit(autoCommit);\n                    conn.close();\n                }\n            }\n        } catch (final SQLException sqle) {\n            log.log(Level.SEVERE, sqle.toString(), sqle);\n            throw new IOException(sqle.toString());\n        }\n    }\n", "code2": "    public void testPreparedStatement0009() throws Exception {\n        Statement stmt = con.createStatement();\n        stmt.executeUpdate(\"create table #t0009 \" + \"  (i  integer  not null,      \" + \"   s  char(10) not null)      \");\n        con.setAutoCommit(false);\n        PreparedStatement pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        int rowsToAdd = 8;\n        final String theString = \"abcdefghijklmnopqrstuvwxyz\";\n        int count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        pstmt.close();\n        assertEquals(count, rowsToAdd);\n        con.rollback();\n        ResultSet rs = stmt.executeQuery(\"select s, i from #t0009\");\n        assertNotNull(rs);\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, 0);\n        con.commit();\n        pstmt = con.prepareStatement(\"insert into #t0009 values (?, ?)\");\n        rowsToAdd = 6;\n        count = 0;\n        for (int i = 1; i <= rowsToAdd; i++) {\n            pstmt.setInt(1, i);\n            pstmt.setString(2, theString.substring(0, i));\n            count += pstmt.executeUpdate();\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        pstmt.close();\n        rs = stmt.executeQuery(\"select s, i from #t0009\");\n        count = 0;\n        while (rs.next()) {\n            count++;\n            assertEquals(rs.getString(1).trim().length(), rs.getInt(2));\n        }\n        assertEquals(count, rowsToAdd);\n        con.commit();\n        stmt.close();\n        con.setAutoCommit(true);\n    }\n", "label": 1, "substitutes": {"updateUser": ["createUsers", "updateRole", "editUsers", " updateMember", "addUsers", "addUser", "deleteRole", "updateuser", "editUser", "deleteUsers", "updatedWord", "updateUsers", "deletePassword", " updateAccount", "createRole", "adduser", "deleteMember", "UpdateUsers", "deleteUser", "editRole", "updatedUsers", "updatePassword", " updateUsers", "updatedUser", "updateMember", "addWord", "updateduser", "editAccount", "deleteWord", "UpdatePassword", "deleteuser", " updateWord", "updateWord", "UpdateWord", " updatePassword", "createAccount", " updateRole", "updateAccount", "UpdateRole", "createUser", "UpdateUser", "Updateuser", "UpdateMember", " updateuser"], "user": ["job", "account", "match", "client", "self", "app", "p", "creator", "User", "full", "author", "profile", "you", "object", "use", "view", "USER", "ro", "character", "instance", "version", "bug", "used", "parent", "page", "rule", "server", "per", "group", "module", "result", "connection", "ver", "content", "response", "resource", "message", "pool", "manager", "row", "str", "post", "this", "null", "model", "session", "data", "update", "system", "contact", "log", "users", "record", "name", "auth", "me", "site", "member", "plugin", "project", "string", "custom", "current", "person", "config", "username"], "conn": ["ha", "db", "pt", "client", "connect", "ca", "Conn", "h", "sync", "ctx", "n", "oss", "cond", "cp", "host", "rc", "cn", "cc", "pg", "el", "socket", "ou", "cat", "cr", "cli", "nt", "ci", "core", "coll", "cache", "server", "cb", "ann", "loc", "reg", "connection", "nc", "dc", "ob", "cm", "pool", "con", "conf", "uc", "part", "pub", "util", "col", "ch", "enc", "serv", "exec", "sql", "url", "close", "ac", "api", "log", "org", "ct", "pc", "co", "mc", "sth", "Connection", "lock", "act", "config", "c", "pr", "ec"], "autoCommit": ["autoDebmit", " autoDebitting", "autoCommits", "autoBlIT", "autoRebit", "automaticCommit", "autoComend", "autoCommite", "autoComIT", "autoDebend", " autoCommite", "automaticCommmit", "autoComite", " autoCommitting", "autoDebits", "autoAbit", "autoBlend", "automaticDebmit", " autoComite", " autoDebmit", "autoCommend", " autoCommmit", "autoDebit", "autoCommmit", "autoCit", "autoCmit", "autoRebite", "autoCommited", " autoComits", "autoComit", "autoDebitting", "autoDebIT", " autoCommits", "autoAbmit", " autoCommited", "autoCommitting", "autoComits", "autoCommIT", "autoBlmit", "automaticCommend", "autoDebited", "autoDebite", "automaticDebend", "autoCited", " autoComit", "automaticCommIT", "automaticDebIT", " autoDebited", "autoBlit", "autoAbitting", " autoDebit", "autoCitting", "autoRebits", "automaticDebit", "autoAbited"], "deleteRoles": ["deleteGrols", "deleteRooles", "deleteNols", "insertRoases", "deleteColes", "deleteRodes", "deleteSlases", "deleteRole", "insertRases", "deleteCodes", "delLole", "insertRooles", "deleteGroles", "deleteRoases", "insertRoules", "deleteLole", "deleteDoots", "deleteDases", "deleteNoles", "delLases", "deleteRoole", "delRodes", "delLodes", "insertRules", "destroyRols", "delRoles", "deleteCole", "deleteRoots", "deleteSloles", "deleteLoles", "destroyNoots", "destroyNols", "deleteNoots", "deleteRsole", "deleteNils", "deleteRsases", "deleteRases", "deleteRils", "deleteRsoles", "deleteCases", "deleteSlodes", "deleteDils", "deleteSlole", "destroyRils", "deleteRules", "deleteDole", "insertRole", "delRole", "deleteGroots", "destroyNoles", "destroyRoles", "deleteRoules", "deleteLases", "deleteDoles", "deleteDols", "deleteRsules", "delLoles", "deleteGrils", "destroyNils", "insertRoole", "deleteRols", "delRases", "destroyRoots", "deleteLodes", "deleteDules"], "insertRoles": ["insertGows", "insertSloots", "updateRols", "insertRsules", "copyRules", "copyGules", "insertRanges", " insertRules", "deleteSloles", "insertRows", "insertShole", "deleteRanges", "deleteSlodes", "insertLows", "deleteSloots", "insertRoots", "insertGules", "insertSloles", "copyRows", "insertLols", " insertShole", "insertGoots", "deleteRodes", " insertShodes", "insertSoles", "updateLoles", "insertRodes", " insertRole", "deleteRoots", "insertSlanges", "copyGoots", "updateLles", "insertSodes", "insertRsanges", "insertLules", "updateLols", "insertShodes", "insertRsows", "insertLles", "insertRles", "insertShules", "copyRoots", "insertGoles", "insertRules", "updateRles", "copyGoles", "insertRsoles", "copyRoles", "insertRsles", "insertSole", "deleteSlanges", "insertSules", "insertRols", " insertRodes", "insertLoots", "updateLules", "updateRules", "copyGows", "insertSholes", "insertSlodes", "insertRsodes", " insertShules", " insertSholes", "updateRoles", "insertLoles", "insertRole", "insertRsoots", "insertRsols"], "role": ["error", "de", "service", "Role", "one", "entry", "rl", "label", "tool", "key", "relation", "profile", "guard", "ro", "repl", "roller", "ole", "rol", "slave", "route", "rule", "val", "to", "group", "alias", "or", "module", "resource", "zone", "function", "row", "link", "base", "type", "range", "shadow", "tag", "force", "l", "member", "string", "le", "username"]}}
{"id1": "3958807", "id2": "8490297", "code1": "        private void loadBinaryStream(String streamName, InputStream streamToLoad, long sz, HttpServletRequest req, HttpServletResponse resp) throws IOException {\n            resp.setContentType(getContentType(req, streamName));\n            resp.setHeader(\"Content-Disposition\", \"inline;filename=\" + streamName);\n            resp.setContentLength((int) sz);\n            OutputStream out = resp.getOutputStream();\n            BufferedOutputStream bos = new BufferedOutputStream(out, 2048);\n            try {\n                IOUtils.copy(streamToLoad, bos);\n            } finally {\n                IOUtils.closeQuietly(streamToLoad);\n                IOUtils.closeQuietly(bos);\n            }\n            getCargo().put(GWT_ENTRY_POINT_PAGE_PARAM, null);\n        }\n", "code2": "    public static void copyFile(File src, File dst) throws IOException {\n        try {\n            InputStream in = new FileInputStream(src);\n            OutputStream out = new FileOutputStream(dst);\n            byte[] buf = new byte[TEMP_FILE_BUFFER_SIZE];\n            int len;\n            while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n            in.close();\n            out.close();\n        } catch (FileNotFoundException e1) {\n            MLUtil.runtimeError(e1, src.toString());\n        } catch (IOException e2) {\n            MLUtil.runtimeError(e2, src.toString());\n        }\n    }\n", "label": 1, "substitutes": {"loadBinaryStream": ["loadBbinaryInput", "loadFinaryInput", "loadFbinaryFile", "loadBbinaryFile", "loadBinaryInput", "loadFbinaryInput", "loadBInputInput", "loadBatchInput", "loadBinaryFile", "loadBbinaryStream", "loadFinaryFile", "loadBatchStream", "loadFinaryContent", "loadBInputFile", "loadFbinaryContent", "loadBatchFile", "loadBInputStream", "loadBinaryContent", "loadBbinaryContent", "loadFbinaryStream", "loadFinaryStream", "loadBInputContent", "loadBatchContent"], "streamName": [" streamPath", "streamKey", "resourcePath", "channelKey", "channelName", "fileType", "StreamPath", "streamname", " streamType", "resourcename", "streamType", "resourceType", "fileKey", "fileName", "resourceName", "StreamName", "filePath", " streamname", "channelPath", " streamKey", "streamPath", "Streamname", "filename"], "streamToLoad": ["objectTORead", "objectToUpload", "streamTOUse", "streamWillAdd", "streamtoRead", "streamWithAdd", "streamtoAdd", " streamtoAdd", "streamWillUpload", "streamtoUse", "streamToUse", " streamtoRead", "streamWillRead", " streamToUse", "streamWithLoad", " streamtoLoad", "streamTOLoad", "objectToRead", "channelToload", "channeltoLoad", "streamToRead", "channelToAdd", "streamtoload", "channeltoload", "objectTOUpload", " streamToAdd", "channelToLoad", "streamTOAdd", "streamWillUse", "objectTOUse", "streamWillLoad", "streamtoUpload", "streamWithUse", "streamToload", "streamToUpload", " streamtoUse", "streamWithRead", "streamTOload", "streamTOUpload", "objectToUse", "objectTOLoad", "streamToAdd", "objectToLoad", " streamToRead", "channeltoAdd", "streamtoLoad", "streamTORead"], "sz": ["ssz", " szi", "szes", " szip", "sszes", "wszip", "psz", "szip", "sze", "psze", "siz", "ssiz", "wszi", "szi", " sze", "imsze", "ssze", "wsz", "imsiz", " szes", "pszip", "imsz", "wsze", "pszi", " siz", "imszes"], "req": ["request", "r", "fr", "client", "progress", "require", "ok", "obj", "ctx", "src", "q", "def", "input", "pkg", "rx", "conn", "http", "rss", "response", "report", "ref", "rh", "rr", "proc", "Resp", "rec", "qt", "rw", "f", "serv", "exec", "err", "download", "requ", "sem", "inv", "Request", "res", "respond", "wx", "cb"], "resp": ["request", "client", "obj", "ctx", "html", "output", "reply", "par", "bb", "e", "page", "circ", "server", "conn", "esp", "http", "rss", "response", "ref", "report", "rh", "rup", "fp", "ret", "df", "Response", "Resp", "rec", "proc", "rev", "serv", "exec", "rep", "zip", "wb", "api", "err", "jp", "download", "rem", "rel", "wp", "comm", "res", "remote", "respond", "prev", "wx", "body", "cook", "cmp", "re", "sp"], "out": ["Out", "auto", "os", "in", "buffer", "p", "i", "output", "object", "s", "tmp", "default", "copy", "aos", "cache", "conn", "boot", "response", "io", "op", "pool", "img", "fn", "buf", "o", "null", "serv", "base", "zip", "binary", "data", "exec", "b", "log", "co", "ops", "bin", "res", "again", "outs", "gz", "ws", "OUT"], "bos": ["os", "lo", "mis", "flo", "zos", "oos", "bis", "oops", "bs", "zb", "bott", "bb", "lol", "bo", "abi", "ros", "cro", "aos", "bare", "los", "boot", "bc", "obs", "ubis", "ios", "bps", "bes", "ob", "osa", "bro", "ko", "bas", "bi", "bh", "biz", "osi", "zo", "pins", "las", "bot", "fits", "bin", "obb", "obos", "obo", "rob"]}}
{"id1": "23611215", "id2": "7468819", "code1": "    public String uploadFile(String url, int port, String uname, String upass, InputStream input) {\n        String serverPath = config.getServerPath() + DateUtil.getSysmonth();\n        FTPClient ftp = new FTPClient();\n        try {\n            int replyCode;\n            ftp.connect(url, port);\n            ftp.login(uname, upass);\n            replyCode = ftp.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                ftp.disconnect();\n                return config.getServerPath();\n            }\n            if (!ftp.changeWorkingDirectory(serverPath)) {\n                ftp.makeDirectory(DateUtil.getSysmonth());\n                ftp.changeWorkingDirectory(serverPath);\n            }\n            ftp.storeFile(getFileName(), input);\n            input.close();\n            ftp.logout();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return serverPath;\n    }\n", "code2": "        public void run() {\n            try {\n                HttpURLConnection con = (HttpURLConnection) url.openConnection();\n                con.setRequestMethod(\"GET\");\n                con.setDoInput(true);\n                byte[] encodedPassword = (username + \":\" + password).getBytes();\n                BASE64Encoder encoder = new BASE64Encoder();\n                con.setRequestProperty(\"Authorization\", \"Basic \" + encoder.encode(encodedPassword));\n                InputStream is = con.getInputStream();\n                BufferedReader rd = new BufferedReader(new InputStreamReader(is));\n                String line;\n                StringBuffer response = new StringBuffer();\n                while ((line = rd.readLine()) != null) {\n                    response.append(line);\n                    response.append('\\n');\n                    lastIteraction = System.currentTimeMillis();\n                }\n                rd.close();\n                is.close();\n                con.disconnect();\n                result = response.toString();\n                finish = true;\n            } catch (Throwable e) {\n                this.e = e;\n            }\n        }\n", "label": 0, "substitutes": {"uploadFile": ["UploadFile", "addFiles", "uploadfile", " uploadfile", " uploadUrl", "Uploadfile", "addfile", "uploadFiles", "uploadUrl", "addUrl", "UploadUrl", "addFile", "UploadFiles", " uploadFiles"], "url": ["domain", "job", "blog", "email", "sl", "rl", "queue", "host", "key", "feed", "user", "id", "server", "address", "loc", "state", "connection", "http", "URL", "path", "resource", "ssl", "file", "f", "Url", "channel", "base", "log", "ll", "name", "l", "string", "ur", "uri", "source", "config", "username"], "port": ["position", "ip", "service", "p", "pos", "host", "Port", "phone", "ort", "key", "proxy", "parent", "page", "limit", "server", "address", "path", "pool", "file", "end", "pi", "type", "offset", "nat", "project", "ports", "point", "pod", "month", "PORT", "pid", "pt", "length"], "uname": ["unename", "enamer", "nonename", "funename", " unename", "nonAME", "unaamel", "nonaming", "unaming", "enename", "noname", "unamer", "enAME", "nonamer", "unaaming", "funame", " unaming", "unamel", "funAME", "funamer", "ename", " unamel", "unaame", "nonamel", "unaename", "unAME"], "upass": ["upsASS", "wpass", " upASS", "upsAss", "ispAss", "upAss", " upasses", "wpasses", "upsass", "upsasses", "upASS", "wpASS", "upasses", "ispasses", "uppass", "uppasses", "ispASS", "uppAss", "wpAss", "ispass", " upAss", "uppASS"], "input": ["request", "image", "get", "in", "error", "client", "buffer", "progress", "upload", "stream", "i", "output", "form", "object", "instance", "cache", "json", "info", "inf", "media", "submit", "path", "audio", "io", "pull", "xml", "ssl", "resource", "raw", "out", "file", "storage", "exec", "session", "data", "Input", "text", "reader", "event", "source", "config", "inc"], "serverPath": ["erverLocation", "clientUrl", "erverCode", " serverUrl", "erverUrl", "ServerUrl", "serUrl", "erverCry", "serverRoot", "browserCry", " serverCode", "basePath", "serPath", "serName", "ServerPath", "browserPath", "browserRoot", " serverCry", "browserCase", "ServerDirectory", "basepath", "ServerName", "baseCode", "serpath", "serverLocation", "serverName", "baseLocation", "serverCode", "clientDirectory", "serverCry", "clientName", "serverCase", "erverName", "Serverpath", " serverName", "erverpath", "erverRoot", " serverLocation", "serverDirectory", " serverRoot", "serverpath", " serverpath", "erverCase", "serverUrl", "clientPath", "erverDirectory", "erverPath", " serverCase"], "ftp": ["ftpool", "ffcp", "fxper", "antcp", "FTp", "bfpage", "afcp", "aftcp", "bfp", "ftper", "ufop", "ufp", " ftap", "fttp", " ftpi", "ftf", "ttp", "ftjp", "ftcp", "ctpi", "fxpc", "ctp", "ffp", "htl", "lfp", "FTf", "ff", "webpi", "webcp", "ftop", "ftnp", "flg", "bftp", "fxpi", "aftpool", "webtp", "dftp", "dfpc", "bfpc", " ftpy", "ufpo", "fjp", "ftb", "dfpage", "afp", "ftg", "antsp", "affp", "antp", "afffp", "aftnp", " ftpool", "aftpo", " ftnp", "ttpc", "fxp", "ftl", "nttp", "afttp", "ftfp", "ntp", "fftp", "ntnp", "flp", "ctcp", "antb", "aftp", "affpy", "ftpo", "flap", "ftpage", " ftpage", "FTcp", " ftf", "ffg", "lffp", "htpc", "ttpi", "ftsp", " ftper", "htp", " ftfp", " ftb", "ntpool", " ftpc", "ffpo", "lftp", "afsp", "cttp", "ftpi", "ttper", " ftcp", " ftl", " fttp", "fcp", "ftpc", "afb", "dfp", "ufcp", "fp", "ftap", "webp", "ffop", "ftpy", " ftjp", "ffap", "afftp", "htb", "ctsp", "ctb", " ftg", "ctl", "fltp", "aftop", "lfpy", "FTjp", "ctpc"], "replyCode": ["replyCod", " replyLine", "ReplyC", " replyCod", "replyLine", " responseCod", "replyC", "ReplyCount", " replyC", "answerCode", "responseCode", "responseType", "responseC", "answerStatus", "ReplyType", "ReplyCod", "replyCount", "ReplyLine", "responseStatus", " replyStatus", " responseType", " replyCount", "answerType", " responseCode", "responseCount", "replyStatus", "ReplyCode", "replyType", " responseLine", "answerCount", " replyType"]}}
{"id1": "16621499", "id2": "20724937", "code1": "    public static byte[] loadURLToBuffer(URL url) throws IOException {\n        byte[] buf = new byte[4096];\n        byte[] data = null;\n        byte[] temp = null;\n        int iCount = 0;\n        int iTotal = 0;\n        BufferedInputStream in = new BufferedInputStream(url.openStream(), 20480);\n        while ((iCount = in.read(buf, 0, buf.length)) != -1) {\n            if (iTotal == 0) {\n                data = new byte[iCount];\n                System.arraycopy(buf, 0, data, 0, iCount);\n                iTotal = iCount;\n            } else {\n                temp = new byte[iCount + iTotal];\n                System.arraycopy(data, 0, temp, 0, iTotal);\n                System.arraycopy(buf, 0, temp, iTotal, iCount);\n                data = temp;\n                iTotal = iTotal + iCount;\n            }\n        }\n        in.close();\n        return data;\n    }\n", "code2": "    public static TopicMap getTopicMap(URL url) {\n        String baseURI = url.toString();\n        InputStream inputStream = null;\n        try {\n            inputStream = url.openStream();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return getTopicMap(inputStream, baseURI);\n    }\n", "label": 0, "substitutes": {"loadURLToBuffer": ["loadURLTObuffer", "loadUrlAsbuffer", "loadUrlToBuffer", "loadURLTobuffer", "loadURLAsBuffer", "loadURLTobuf", "loadUrlAsBuff", "loadUrlToBuff", "loadUrlAsbuf", "loadUrlTobuffer", "loadURLTObuf", "loadURLAsBuff", "loadURLTOBuff", "loadUrlTobuf", "loadURL2Buff", "loadURL2buf", "loadURLAsbuf", "loadURLToBuff", "loadURLAsbuffer", "loadURLTOBuffer", "loadURL2Buffer", "loadUrlAsBuffer", "loadURL2buffer"], "url": ["job", "fr", "buffer", "service", "sl", "obj", "html", "stream", "queue", "object", "el", "user", "il", "page", "server", "address", "connection", "http", "URL", "resource", "path", "ssl", "out", "file", "str", "config", "f", "Url", "base", "gl", "loader", "b", "rel", "org", "name", "l", "string", "uri", "source", "filename"], "buf": ["db", "pad", "la", "buffer", "bu", "seq", "batch", "bytes", "ctx", "bf", "br", "queue", "ff", "fd", "src", "ab", "tmp", "func", "context", "input", "bb", "cat", "abi", "Buffer", "port", "coll", "loc", "aux", "bc", "rb", "fb", "array", "desc", "band", "fp", "buff", "count", "uc", "tc", "bag", "bd", "iter", "bh", "Buff", "wb", "append", "cv", "uf", "done", "wave", "front", "cb", "txt"], "data": ["next", "pad", "bu", "size", "i", "parent", "info", "bc", "content", "beta", "a", "zero", "raw", "str", "api", "base", "wa", "text", "body", "reader", "da", "dat", "db", "bytes", "p", "batch", "load", "input", "cache", "val", "media", "array", "index", "buff", "part", "area", "div", "done", "meta", "alpha", "output", "init", "slice", "cat", "limit", "valid", "result", "count", "total", "memory", "ata", "source", "la", "buffer", "pos", "default", "tmp", "ui", "orig", "results", "f", "type", "di", "DATA", "ada", "extra", "empty", "config"], "temp": ["fake", "pt", "shared", "buffer", "template", "p", "size", "pos", "cel", "full", "i", "key", "output", "pre", "tmp", "init", "input", "parent", "thin", "Temp", "cache", "valid", "json", "diff", "padding", "mini", "content", "path", "index", "buff", "count", "dest", "tc", "iter", "tem", "stable", "prefix", "alt", "unit", "base", "zip", "null", "flat", "wa", "local", "partial", "offset", "test", "done", "total", "wrap", "body", "extra", "empty", "current", "dat", "source", "config", "length", "txt"], "iCount": ["iniCount", "iMax", "inicount", "iType", "piTotal", "iSize", " iType", "piCommon", " iMin", "siLength", "oiCount", "multiSize", "siCount", "pMax", "iiLength", "piType", "jTotal", "oiTotal", "IStart", "piCount", "xiType", "ricount", "sicount", " iCast", "riCast", "piSize", "multiTotal", "IMax", "xiCount", "ICount", "riCount", "iCommon", " iCommon", "oiCommon", "riTotal", "piStart", " iSize", "iLength", "multiCount", " iMax", "xiLength", "pCount", "ITotal", "iiType", " iLength", "siTotal", "ILength", "iStart", "iiCount", "iMin", "iiMin", "jCount", "piLength", "pStart", "pTotal", "IMin", "IType", "jcount", "oiType", "iCast", "xiTotal", " iStart", "siStart", "iniTotal", " icount", "iniCast", "icount", "jLength", "multiLength"], "iTotal": ["siLength", "pType", "uriTotal", " iComplete", "iRest", "piBasic", "xiBasic", "multiMax", " iGlobal", "iLength", "pCount", "ITotal", "uritotal", "iiZero", "iiPercent", "xiTotal", "uriCommon", "iiBasic", "multiLength", "iComplete", "iGlobal", "iType", "piTotal", "oiCount", " iLast", "multiTotal", "IMax", "xiCount", "multiCount", "iiTotal", "iiCount", "piLength", "pTotal", "piGlobal", " iPercent", "itotal", "uLast", " iType", "iiMax", "pMax", "iPercent", "oitotal", " iRest", "piRest", "oiTotal", " iZero", "piCount", "iLast", " iCommon", "oiCommon", "siZero", " iMax", "iiLast", "ILength", "iBasic", "uTotal", "uCount", "iMax", " iBasic", "siLast", "iiLength", "pLength", "IPercent", "iCommon", "piComplete", "iiComplete", "xiLength", " iLength", "siTotal", " itotal", "iiGlobal", "uType", "iiRest", "pLast", "iZero", "uriCount"], "in": ["r", "client", "buffer", "fr", "h", "la", "inn", "stream", "gin", "i", "is", "s", "init", "impl", "input", "ex", "din", "or", "inner", "io", "nin", "ssl", "out", "con", "ini", "at", "min", "f", "ilo", "exec", "login", "err", "ac", "b", "ins", "fac", "l", "In", "bin", "again", "IN", "as", "reader", "win", "source", "c", "inc"]}}
{"id1": "646016", "id2": "23402240", "code1": "    public void elimina(Cliente cli) throws errorSQL, errorConexionBD {\n        System.out.println(\"GestorCliente.elimina()\");\n        int id = cli.getId();\n        String sql;\n        Statement stmt = null;\n        try {\n            gd.begin();\n            sql = \"DELETE FROM cliente WHERE cod_cliente =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt = gd.getConexion().createStatement();\n            stmt.executeUpdate(sql);\n            System.out.println(\"executeUpdate\");\n            sql = \"DELETE FROM persona WHERE id =\" + id;\n            System.out.println(\"Ejecutando: \" + sql);\n            stmt.executeUpdate(sql);\n            gd.commit();\n            System.out.println(\"commit\");\n            stmt.close();\n        } catch (SQLException e) {\n            gd.rollback();\n            throw new errorSQL(e.toString());\n        } catch (errorConexionBD e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        } catch (errorSQL e) {\n            System.err.println(\"Error en GestorCliente.elimina(): \" + e);\n        }\n    }\n", "code2": "    public boolean actualizarNdivisiones(int idTorneo, int nDivisiones) {\n        int intResult = 0;\n        String sql = \"UPDATE torneo\" + \" SET  numeroDivisiones=\" + nDivisiones + \" WHERE idTorneo=\" + idTorneo;\n        try {\n            connection = conexionBD.getConnection();\n            connection.setAutoCommit(false);\n            ps = connection.prepareStatement(sql);\n            intResult = ps.executeUpdate();\n            connection.commit();\n        } catch (SQLException ex) {\n            ex.printStackTrace();\n            try {\n                connection.rollback();\n            } catch (SQLException exe) {\n                exe.printStackTrace();\n            }\n        } finally {\n            conexionBD.close(ps);\n            conexionBD.close(connection);\n        }\n        return (intResult > 0);\n    }\n", "label": 1, "substitutes": {"elimina": [" elrimita", "elimita", " elrimina", "elimini", "elrimini", "elrimina", "elimalina", "elrimita", "elimalita", "elimerina", " elrimada", "elimalada", "elimerini", " elimini", "elimerita", " elimada", "elrimada", "elimalini", " elimita", " elrimini", "elimerada", "elimada"], "cli": ["API", "CL", "client", "lo", "ctx", "cci", "i", "sci", "lc", "ci", "gi", "server", "conn", "ui", "cu", "connection", "cgi", "li", "gui", "gd", "osi", "ctrl", "util", "uci", "oci", "Client", "api", "xi", "dl", "colo", "GUI", "di", "l", "hi", "cfg", "lu", "ctl", "uri", "cmd", "c"], "id": ["db", "ip", "in", "client", "error", "h", "p", "email", "entry", "q", "key", "i", "vid", "oid", "version", "Id", "server", "mid", "ID", "val", "md", "address", "info", "code", "connection", "ident", "index", "num", "path", "resource", "value", "start", "en", "x", "uid", "f", "url", "active", "sid", "model", "login", "zip", "type", "database", "status", "it", "admin", "name", "ids", "ql", "style", "d", "like", "aid", "patient", "pid", "kid"], "sql": ["job", "db", "generic", "su", "os", "lua", "details", "query", "script", "sl", "msg", "html", "rl", "sync", "i", "layout", "comment", "install", "ln", "ls", "il", " SQL", "sol", "lc", "SQL", "sb", "sex", "statement", "sf", "sg", "lv", "result", "liquid", "params", "cop", "ssl", "function", "str", "util", "url", "no", "null", "base", "zip", "data", "err", "type", "lang", "log", "sq", "dl", "eps", "shell", "status", "ll", "live", "name", "auth", "l", "ql", "sal", "string", "js", "nl", "seed", "general", "sys", "sv", "cmd", "repl"], "stmt": [" stm", "fmp", "stdd", "putmt", "stdr", "estmd", "Stm", " stdr", "StMT", " stdb", " stmn", "instm", "estsql", "shtr", "sttr", "instdd", "Stmd", "shmn", "sthdr", "estmb", "fm", "shnt", "stmd", " sttr", "stmp", "stMT", " stdd", "Stmm", "sthm", "sthmt", " stmd", "instdr", "Stmp", "fMT", "putmb", "putsql", "instmt", "estmt", "putpt", "estnt", "stm", "shmt", " stmm", " stnt", " stpt", "stmm", " stmb", "fmt", " stsql", "stnt", "Stmt", "estmn", "stmn", "stsql", "Stdb", "esttr", "stmb", " stmp", "estmm", "estpt", "stdb", "estdb", "stpt", "sthdd", " stMT"]}}
{"id1": "14047629", "id2": "4602568", "code1": "    protected ExternalDecoder(InputStream source, Process process) {\n        super(source);\n        this.process = process;\n        this.processStdOut = process.getInputStream();\n        this.processStdIn = process.getOutputStream();\n        new Thread() {\n\n            @Override\n            public void run() {\n                try {\n                    IOUtils.copy(getSource(), processStdIn);\n                    System.err.println(\"Copy done.\");\n                    close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                    IOUtils.closeQuietly(ExternalDecoder.this);\n                }\n            }\n        }.start();\n    }\n", "code2": "    public String storeImage(InputStream inStream, String fileName, boolean resize) throws Exception {\n        Calendar rightNow = Calendar.getInstance();\n        String dayNamedFolderName = \"\" + rightNow.get(Calendar.YEAR) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.MONTH) + 1) + StringUtil.getPaddedIntWithZeros(2, rightNow.get(Calendar.DATE));\n        String uploadDirRoot = props.getProperty(\"uploaded.files.root\");\n        File file = new File(uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName);\n        if (!file.exists()) file.mkdirs();\n        String extension = FilenameUtils.getExtension(fileName);\n        String outFileName;\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEORIGINALFILENAME, \"true\"))) {\n            outFileName = StringUtil.removeSpecChars(StringUtil.unaccent(FilenameUtils.getBaseName(fileName)));\n        } else {\n            outFileName = StringUtil.hash(fileName + Long.toString(System.currentTimeMillis()));\n        }\n        if (Boolean.parseBoolean(props.getPropertiesInstance().getProperty(IFConsts.USEEXTENSION, \"true\"))) {\n            outFileName = outFileName + DOT + extension;\n        }\n        String outPathAndName = uploadDirRoot + System.getProperty(\"file.separator\") + dayNamedFolderName + System.getProperty(\"file.separator\") + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        File uploadedFile = new File(outPathAndName);\n        _logger.info(\"uploadedFile.getAbsolutePath() = {}\", uploadedFile.getAbsolutePath());\n        uploadedFile.createNewFile();\n        OutputStream outStream = new FileOutputStream(outPathAndName);\n        IOUtils.copyLarge(inStream, outStream);\n        IOUtils.closeQuietly(inStream);\n        outStream.close();\n        if (resize) {\n            writeResizedImage(outPathAndName, extension, \"imgSize_xs\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_s\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_m\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_l\");\n            writeResizedImage(outPathAndName, extension, \"imgSize_xl\");\n        }\n        String retVal = dayNamedFolderName + \"/\" + props.getProperty(\"uploaded.files.prefix\") + outFileName;\n        return retVal;\n    }\n", "label": 1, "substitutes": {"source": ["request", "image", "in", "buffer", "service", "stream", "src", "cp", "class", "transfer", "object", "load", "proxy", "input", "parse", "parent", "server", "info", "target", "result", "connection", "content", "inner", "path", "resource", "fp", "proc", "out", "file", "Source", "exec", "session", "loader", "SOURCE", "comp", "status", "text", "document", "processor", "reader", "remote", "project", "ource", "config", "ources"], "process": ["job", "image", "the", "progress", "p", "script", "worker", "console", "cess", "machine", "display", "master", "class", "output", "use", "app", "object", "parent", "copy", "port", "run", "open", "program", "target", "result", "share", "path", "resource", "index", "proc", "thread", "work", "file", "post", "exec", "session", "system", "press", "task", "status", "processing", "method", "call", "document", "node", "processor", "python", "project", "parser", "command", "loop", "pid", "Process", "pipe"], "processStdOut": ["processSTdinOut", "processSTdOut", "processStdinOUT", "processSttOUT", "processSttOutput", "processSTdinObj", "processSTdinOutput", "processStdinObj", "processStdinOut", "processSttObj", "processStDOut", "processSTdinOUT", "processStdinOutput", "processSTdOutput", "processStDOUT", "processSTdOUT", "processStDOutput", "processStDObj", "processStdOUT", "processStdObj", "processSttOut", "processSTdObj", "processStdOutput"], "processStdIn": ["processStbin", "processSttIns", "processStsIns", "processStdin", "processStrdIns", "processSttInput", "processStdInput", "processStsIn", "processSttin", "processStsInput", "processStdIN", "processStrtIn", "processSttIN", "processStdinOut", "processStdinIn", "processStbIns", "processStbIN", "processSttIn", "processStsin", "processStrtInput", "processStdIns", "processStrdIn", "processStbInput", "processStrdin", "processStbIn", "processStdinIN", "processStdinin", "processStbOut", "processStrtIns", "processSttOut", "processStrdInput", "processStrtin"]}}
{"id1": "22708533", "id2": "2936678", "code1": "    public static void insertDocumentToURL(String file, String target) throws IOException {\n        InputStream is = null;\n        OutputStream os = null;\n        try {\n            is = new FileInputStream(file);\n            final URL url = new URL(target);\n            final URLConnection connection = url.openConnection();\n            os = connection.getOutputStream();\n            TestTools.copyStream(is, os);\n        } finally {\n            if (is != null) {\n                is.close();\n            }\n            if (os != null) {\n                os.close();\n            }\n        }\n    }\n", "code2": "    public static String getUniqueKey() {\n        String digest = \"\";\n        try {\n            final MessageDigest md = MessageDigest.getInstance(\"MD5\");\n            final String timeVal = \"\" + (System.currentTimeMillis() + 1);\n            String localHost = \"\";\n            try {\n                localHost = InetAddress.getLocalHost().toString();\n            } catch (UnknownHostException e) {\n                println(\"Warn: getUniqueKey(), Error trying to get localhost\" + e.getMessage());\n            }\n            final String randVal = \"\" + new Random().nextInt();\n            final String val = timeVal + localHost + randVal;\n            md.reset();\n            md.update(val.getBytes());\n            digest = toHexString(md.digest());\n        } catch (NoSuchAlgorithmException e) {\n            println(\"Warn: getUniqueKey() \" + e);\n        }\n        return digest;\n    }\n", "label": 0, "substitutes": {"insertDocumentToURL": ["insertDocumentUsingFile", "insertDocumentToFile", "insertDocumentAsFile", "insertDocumentTourl", "insertDocumentToUrl", "insertDocumentUsingurl", "insertFileToURL", "insertDocumentAsurl", "insertDocumentFromFile", "insertFileFromUrl", "insertFileToUrl", "insertDocumentAsUrl", "insertDocumentFromURL", "insertDocumentUsingUrl", "insertFileToFile", "insertDocumentAsURL", "insertFileFromurl", "insertDocumentFromUrl", "insertDocumentFromurl", "insertFileFromURL", "insertDocumentUsingURL", "insertFileFromFile", "insertFileTourl"], "file": ["image", "db", "self", "stream", "files", "src", "class", "object", "use", "input", "id", "File", "address", "from", "path", "resource", "fp", "xml", "FILE", "dir", "f", "base", "data", "local", "document", "name", "framework", "frame", "string", "place", "uri", "source", "filename"], "target": ["next", "template", "large", "host", "output", "pattern", "object", "proxy", "reference", "parent", "office", "port", "server", "address", "to", "result", "pointer", "location", "path", "resource", "dest", "root", "base", "platform", "Target", "rel", "database", "tag", "document", "name", "site", "external", "remote", "project", "string", "source", "filename"], "is": ["lis", "get", "ai", "in", "ip", "Is", "mis", "service", "us", "bis", "ie", "iso", "isl", "oss", "isa", "src", "i", "cs", "s", "bs", "ois", "was", "its", "ls", "id", "ci", "css", "es", "isi", "address", "ris", "conn", "loc", "IS", "info", "or", "state", "iss", "http", "ios", "ori", "nis", "ir", "out", "iris", "ais", "abs", "x", "fs", "api", "serv", "zip", "series", "are", "it", "ops", "vs", "ss", "as", "js", "si", "ps", "ms", "web"], "os": ["auto", "us", "oos", "iso", "pos", "oss", "ose", "i", "bs", "s", "oid", "otes", "ol", "ors", "ens", "ros", "aos", "es", "conn", "ks", "los", "boot", "or", "obs", "cos", "ios", "ori", "http", "oses", "io", "ob", "ds", "oa", "nos", "OS", "ais", "osi", "ot", "o", "opens", "des", "ans", "oS", "oi", "so", "ops", "vs", "bos", "ss", "as", "ps", "Os", "outs", "oes"], "url": ["image", "ball", "blog", "client", "connect", "sl", "i", "socket", "use", "proxy", "user", "ls", "lc", "server", "conn", "open", "or", "http", "li", "URL", "path", "io", "resource", "ssl", "link", "f", "Url", "o", "lib", "base", "channel", "zip", "control", "b", "log", "ll", "l", "string", "web", "uri", "source", "config", "c"], "connection": ["job", "db", "client", "connect", "union", "creator", "cond", "i", "socket", "relation", "use", "proxy", "context", "lc", "ci", "directory", "handler", "server", "conn", "loc", "open", "or", "bc", "http", "response", "URL", "io", "out", "con", "connected", "channel", "control", "b", "database", "controller", " Connection", "document", "l", "ion", "Connection", "uri", "config", "c"]}}
{"id1": "15241397", "id2": "21491791", "code1": "    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        String rewrittenQueryString = URLDecoder.decode(request.getRequestURI(), \"UTF-8\").replaceFirst(\"^.*?\\\\/(id:.*)\\\\/.*?$\", \"$1\");\n        logger.debug(\"rewrittenQueryString: \" + rewrittenQueryString);\n        URL rewrittenUrl = new URL(fedoraUrl + rewrittenQueryString);\n        logger.debug(\"rewrittenUrl: \" + rewrittenUrl.getProtocol() + \"://\" + rewrittenUrl.getHost() + \":\" + rewrittenUrl.getPort() + rewrittenUrl.getFile());\n        HttpURLConnection httpURLConnection = (HttpURLConnection) rewrittenUrl.openConnection();\n        HttpURLConnection.setFollowRedirects(false);\n        httpURLConnection.connect();\n        response.setStatus(httpURLConnection.getResponseCode());\n        logger.debug(\"[status=\" + httpURLConnection.getResponseCode() + \"]\");\n        logger.debug(\"[headers]\");\n        for (Entry<String, List<String>> header : httpURLConnection.getHeaderFields().entrySet()) {\n            if (header.getKey() != null) {\n                for (String value : header.getValue()) {\n                    if (value != null) {\n                        logger.debug(header.getKey() + \": \" + value);\n                        if (!header.getKey().equals(\"Server\") && !header.getKey().equals(\"Transfer-Encoding\")) {\n                            response.addHeader(header.getKey(), value);\n                        }\n                    }\n                }\n            }\n        }\n        logger.debug(\"[/headers]\");\n        InputStream inputStream = httpURLConnection.getInputStream();\n        OutputStream outputStream = response.getOutputStream();\n        IOUtils.copy(inputStream, outputStream);\n    }\n", "code2": "    public void run(String[] args) throws Throwable {\n        FileInputStream input = new FileInputStream(args[0]);\n        FileOutputStream output = new FileOutputStream(args[0] + \".out\");\n        Reader reader = $(Reader.class, $declass(input));\n        Writer writer = $(Writer.class, $declass(output));\n        Pump pump;\n        if (args.length > 1 && \"diag\".equals(args[1])) {\n            pump = $(new Reader() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public int read(byte[] buffer, int off, int len) throws Exception {\n                    Integer rd = (Integer) $next();\n                    if (rd > 0) {\n                        counter += rd;\n                    }\n                    return 0;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Read from input \" + counter + \" bytes.\");\n                }\n            }, reader, writer, new Writer() {\n\n                int counter;\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void write(byte[] buffer, int off, int len) throws Exception {\n                    counter += len;\n                }\n\n                @ToContext(mode = InvocationMode.sideEffect)\n                public void close() throws Exception {\n                    System.out.println(\"Written to output \" + counter + \" bytes.\");\n                }\n            });\n        } else {\n            pump = $(reader, writer);\n        }\n        pump.pump();\n    }\n", "label": 1, "substitutes": {"doGet": ["doGET", " doGET", " doPut", "doget", " doget", "doPut", "handlePut", "didGET", "didPut", "handleGet", "handleGET", "didget", "didGet", "handleget"], "request": ["image", "client", "buffer", "query", "received", "queue", "object", "context", "input", "user", "instance", "server", "complete", "info", "result", "connection", "http", "message", "resource", "report", "xml", "url", "req", "data", "type", "er", "subject", "application", "method", "document", "Request", "reader", "web", "QUEST", "uri", "event", "initial"], "response": ["next", "image", "error", "client", "writer", "full", "queue", "host", "output", "reply", "view", "object", "version", "parent", "page", "server", "json", "result", "connection", "resource", "report", "message", "pool", "results", "esi", "Response", "out", "function", "resp", "onse", "model", "session", "data", "collection", "status", "application", "wave", "other", "document", "site", "body", "respond", "generation"], "rewrittenQueryString": ["rewwrittenRequestText", "rewrittenqueryService", "rewrittenQueryArray", "rewrittenqueryLine", "rewrittenQuestionArray", "rewrittenQuestionLine", "rewwrittenRequestArray", "rewrittenPageString", "rewrittenQuestionString", "rewwrittenQueryService", "rewwrittenRequestList", "rewwrittenQueryArray", "rewrittenRequestStr", "rewrittenQueryStr", "rewrittenUrlString", "rewrittenRequestString", "rewwrittenQueryList", "rewwrittenRequestStr", "rewrittenRequestArray", "rewrittenQueryService", "rewwrittenRequestString", "rewrittenUrlLine", "rewrittenUrlText", "rewrittenUrlService", "rewrittenRequestLine", "rewrittenQueryList", "rewrittenPageList", "rewwrittenQueryString", "rewrittenQuestionList", "rewrittenqueryText", "rewrittenRequestService", "rewwrittenQueryStr", "rewwrittenRequestLine", "rewwrittenQueryText", "rewrittenQueryLine", "rewrittenQuestionText", "rewwrittenRequestService", "rewrittenPageArray", "rewrittenPageLine", "rewwrittenQueryLine", "rewrittenRequestList", "rewrittenQueryText", "rewrittenRequestText", "rewrittenqueryString", "rewrittenQuestionStr", "rewrittenqueryStr"], "rewrittenUrl": ["rewcraftedURL", "rewwrittenUr", "rewrapedFile", "RewrittenLocation", "rewriteURL", "rewwrittenText", "rewatchedUrl", "RewrittenServer", "rewardedLanguage", "RewrittenText", "RewrittenURL", "rewmatchedUrl", "rewwrittenJar", "rewardedUrl", "rewrapedURL", "rewilledInt", "rewwrittenFile", "RewrittenJar", "rewrittenurl", "rewedUr", "rewrittenLanguage", "rewwrittenLanguage", "RewwrittenFile", "rewmatchedurl", "rewmatchedFile", "rewrittenInt", "RewwrittenText", "rewedFile", "rewriteServer", "rewrittenJar", "RewwrittenInt", "Rewwrittenurl", "rewardedLocation", "rewardedURL", "rewrittenServer", "rewrittenFile", "RewwrittenServer", "rewatchedServer", "rewriteUrl", "rewwrittenLocation", "rewardedFile", "rerittenUrl", "rewardedInt", "rewilledURL", "RewwrittenLocation", "rewrittenUr", "rewodedUrl", "rewatchedText", "rerittenFile", "rewcraftedUr", "rewodedURL", "rewwrittenURL", "RewwrittenUrl", "RewrittenUrl", "rewedURL", "RewrittenInt", "RewwrittenUr", "rewrapedUr", "rewardedJar", "Rewrittenurl", "rewriteText", "rerittenLanguage", "rewwrittenInt", "rewrittenText", "rewwrittenUrl", "rewatchedURL", "rewcraftedLocation", "rewedUrl", "rewmatchedURL", "rewwrittenServer", "rewilledUrl", "rewilledJar", "rewodedLanguage", "RewrittenFile", "rewcraftedUrl", "rerittenUr", "rewrittenURL", "rewedurl", "rewardedUr", "rewodedFile", "rewrapedUrl", "rewwrittenurl", "rewrittenLocation", "RewwrittenJar", "RewwrittenURL", "RewrittenUr", "rerittenURL"], "httpURLConnection": ["httpChannelService", "webSSLClient", "httpPathconnection", "httpCLCode", "httpURLFlow", "httpURIConn", " httpURLconnection", " httpURLCode", " httpURConn", "httpUrlConnect", "httpurlConn", "httpURLClient", "HttpURLService", "httpURIConnection", "apacheURLConnect", "webURLContext", "httpSSLClient", "httpSSLContext", "httpELConnect", "httpSSLConnection", "httpChannelconnection", "httpURLConnect", "httpCLConnection", "httpWebConn", " httpStreamconnection", "httpELConn", " httpUrlConn", "httpUrlConnection", "webSSLContext", "apacheGEConnect", "httpGEConnect", "apacheGEConnection", "httpWebConnection", "httpUrlClient", " httpStreamCurrent", "httpurlCurrent", "httpURConnect", "httpURLCurrent", "httpurlCode", "httpELConnection", "httpStreamCurrent", "httpSSLConn", "httpChannelConnect", "httpGEFlow", "httpURService", "httpWebConnect", "httpURLConn", "httpURIFlow", "httpURIconnection", "httpGEConnection", "apacheGEFlow", " httpStreamSession", "httpPathCurrent", "webURLClient", "httpURLconnection", "HttpChannelConnection", "httpPathConnection", "webURLConnection", " httpUrlCode", "apacheURLConnection", "HttpURLConnection", " httpURLConnect", "httpURLContext", "httpChannelConnection", "httpStreamConnection", "httpURConn", "HttpChannelService", "httpURConnection", " httpUrlConnection", "HttpURLconnection", " httpURConnect", "httpURIConnect", "httpurlConnect", "httpUrlCode", "httpURLCode", "httpGEconnection", "apacheURLconnection", "httpURLSession", "httpUrlContext", "httpURconnection", "httpURIContext", "httpURLService", "apacheURLFlow", " httpStreamConnection", "webURLConn", "httpUrlconnection", "httpCLConn", "webSSLConn", "HttpURLConnect", "httpUrlConn", "httpURIClient", "HttpChannelconnection", "httpurlSession", " httpURLSession", "httpPathSession", "httpurlconnection", "HttpChannelConnect", "webSSLConnection", "httpUrlService", "httpStreamSession", "httpStreamconnection", " httpURLCurrent", "httpurlConnection", "httpurlFlow", " httpURLConn", " httpURConnection", "apacheGEconnection"], "header": ["next", "error", "match", "writer", "buffer", "component", "entry", "block", "author", "queue", "key", "master", "default", "comment", "character", "consumer", "headers", "version", "reference", "after", "section", "attribute", "handler", "server", "rule", "metadata", "info", "group", "result", "dr", "index", "message", "pair", "line", "date", "function", "cover", "director", "part", "iter", "second", "channel", "feature", "definition", "data", "player", "her", "er", "token", "document", "driver", "ter", "member", "string", "list", "filter", "bridge", "head", "Header", "outer", "event", "hash", "field", "back", "layer", "column", "item"], "value": ["get", "hello", "element", "entry", "label", "key", "current", "object", "comment", "default", "version", "parent", "expression", "office", "gi", "server", "valid", "option", "val", "json", "child", "info", "property", "format", "media", "content", "message", "description", "now", "function", "attribute", "end", "letter", "set", "model", "data", "type", "VALUE", "values", "v", "text", "language", "document", "name", "password", "string", "variable", "item", "field", "sv", "V", "Value"], "inputStream": ["pullstream", "inputChannel", "outputstream", "resourceChannel", "Inputstream", "InputChannel", "resourceSteam", "outputStreamer", "pullStreamer", "InputSteam", "outputChannel", "outputSteam", "InputStreamer", "inputSteam", "InputStream", "pullStream", "resourcestream", "resourceStream", "pullSteam", "inputStreamer", "inputstream"], "outputStream": ["outputstream", "OutputStream", "outputFile", " outputChannel", "externalSteam", "externalStreamer", "OutputStreamer", " outputSteam", "outputStreamer", "responseStream", "outputChannel", "responseSteam", "outputSteam", "responseChannel", "inputSteam", "externalStream", "OutputFile", " outputFile", "Outputstream", "OutputChannel", "OutputSteam", "externalstream", "inputStreamer", "responseFile", "inputstream"]}}
{"id1": "10759917", "id2": "12146394", "code1": "    public void delete(String name) throws FidoDatabaseException, CannotDeleteSystemLinkException, ClassLinkTypeNotFoundException {\n        try {\n            Connection conn = null;\n            Statement stmt = null;\n            try {\n                conn = fido.util.FidoDataSource.getConnection();\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                if (isSystemLink(stmt, name) == true) throw new CannotDeleteSystemLinkException(name);\n                AdjectivePrepositionTable prepTable = new AdjectivePrepositionTable();\n                prepTable.deleteLinkType(stmt, name);\n                ObjectLinkTable objectLinkTable = new ObjectLinkTable();\n                objectLinkTable.deleteLinkType(stmt, name);\n                String sql = \"delete from ClassLinkTypes where LinkName = '\" + name + \"'\";\n                stmt.executeUpdate(sql);\n                conn.commit();\n            } catch (SQLException e) {\n                if (conn != null) conn.rollback();\n                throw e;\n            } finally {\n                if (stmt != null) stmt.close();\n                if (conn != null) conn.close();\n            }\n        } catch (SQLException e) {\n            throw new FidoDatabaseException(e);\n        }\n    }\n", "code2": "    public static String md5Crypt(final byte[] key, final byte[] salt) throws NoSuchAlgorithmException {\n        if (key == null || key.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'key' cannot be null or an empty array.\");\n        }\n        if (salt == null || salt.length == 0) {\n            throw new IllegalArgumentException(\"Argument 'salt' cannot be null or an empty array.\");\n        }\n        final MessageDigest _md = MessageDigest.getInstance(\"MD5\");\n        _md.update(key);\n        _md.update(MAGIC.getBytes());\n        _md.update(salt);\n        final MessageDigest md2 = MessageDigest.getInstance(\"MD5\");\n        md2.update(key);\n        md2.update(salt);\n        md2.update(key);\n        byte[] abyFinal = md2.digest();\n        for (int n = key.length; n > 0; n -= 16) {\n            _md.update(abyFinal, 0, n > 16 ? 16 : n);\n        }\n        abyFinal = new byte[] { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n        for (int j = 0, i = key.length; i != 0; i >>>= 1) {\n            if ((i & 1) == 1) _md.update(abyFinal, j, 1); else _md.update(key, j, 1);\n        }\n        final StringBuilder sbPasswd = new StringBuilder();\n        sbPasswd.append(MAGIC);\n        sbPasswd.append(new String(salt));\n        sbPasswd.append('$');\n        abyFinal = _md.digest();\n        for (int n = 0; n < 1000; n++) {\n            final MessageDigest md3 = MessageDigest.getInstance(\"MD5\");\n            if ((n & 1) != 0) {\n                md3.update(key);\n            } else {\n                md3.update(abyFinal);\n            }\n            if ((n % 3) != 0) {\n                md3.update(salt);\n            }\n            if ((n % 7) != 0) {\n                md3.update(key);\n            }\n            if ((n & 1) != 0) {\n                md3.update(abyFinal);\n            } else {\n                md3.update(key);\n            }\n            abyFinal = md3.digest();\n        }\n        int[] anFinal = new int[] { (abyFinal[0] & 0x7f) | (abyFinal[0] & 0x80), (abyFinal[1] & 0x7f) | (abyFinal[1] & 0x80), (abyFinal[2] & 0x7f) | (abyFinal[2] & 0x80), (abyFinal[3] & 0x7f) | (abyFinal[3] & 0x80), (abyFinal[4] & 0x7f) | (abyFinal[4] & 0x80), (abyFinal[5] & 0x7f) | (abyFinal[5] & 0x80), (abyFinal[6] & 0x7f) | (abyFinal[6] & 0x80), (abyFinal[7] & 0x7f) | (abyFinal[7] & 0x80), (abyFinal[8] & 0x7f) | (abyFinal[8] & 0x80), (abyFinal[9] & 0x7f) | (abyFinal[9] & 0x80), (abyFinal[10] & 0x7f) | (abyFinal[10] & 0x80), (abyFinal[11] & 0x7f) | (abyFinal[11] & 0x80), (abyFinal[12] & 0x7f) | (abyFinal[12] & 0x80), (abyFinal[13] & 0x7f) | (abyFinal[13] & 0x80), (abyFinal[14] & 0x7f) | (abyFinal[14] & 0x80), (abyFinal[15] & 0x7f) | (abyFinal[15] & 0x80) };\n        to64(sbPasswd, anFinal[0] << 16 | anFinal[6] << 8 | anFinal[12], 4);\n        to64(sbPasswd, anFinal[1] << 16 | anFinal[7] << 8 | anFinal[13], 4);\n        to64(sbPasswd, anFinal[2] << 16 | anFinal[8] << 8 | anFinal[14], 4);\n        to64(sbPasswd, anFinal[3] << 16 | anFinal[9] << 8 | anFinal[15], 4);\n        to64(sbPasswd, anFinal[4] << 16 | anFinal[10] << 8 | anFinal[5], 4);\n        to64(sbPasswd, anFinal[11], 2);\n        return sbPasswd.toString();\n    }\n", "label": 0, "substitutes": {"delete": ["get", " deletion", "de", "del", "save", "sync", " Delete", " deleting", "load", "write", "id", "Delete", "register", "connection", "post", "link", "exec", "update", "execute", "drop", "database", "remove", " destroy", "destroy", "flush", "dump", "create"], "name": ["client", "size", "one", "n", "label", "key", "class", "old", "object", "comment", "action", "default", "version", "e", "parent", "id", "on", "address", "ame", "info", "alias", "code", "time", "path", "resource", "word", "value", "now", "part", "NAME", "link", "space", "url", "prefix", "no", "null", "none", "pass", "model", "active", "data", "type", "missing", "definition", "base", "false", "database", "Name", "names", "table", "true", "style", "string", "named", "like", "create", "filename"], "CannotDeleteSystemLinkException": ["CannotDeleteSysLinkError", "CannotDeleteSystemLinkError", "CannotDeleteSystemLinkception", "CannotDeleteSystemReferenceEx", "CannotDeleteSystemRelException", "CannotDeleteSystemLinkEx", "CannotDeleteSystemRelception", "CannotDeleteSystemReferenceError", "CannotDeleteSystemRelError", "CannotDeleteSystemLinksApplication", "CannotDeleteClassLinkInformation", "CannotDeleteSysLinkException", "CannotDeleteSystemLinkInformation", "CannotDeleteSystemRelEx", "CannotDeleteSystemlinkApplication", "CannotDeleteSysLinkEx", "CannotDeleteSystemLinkApplication", "CannotDeleteSystemLinksInformation", "CannotDeleteClassLinkException", "CannotDeleteSystemLinksException", "CannotDeleteClassLinkApplication", "CannotDeleteSystemlinkException", "CannotDeleteSysLinkception", "CannotDeleteSystemReferenceception", "CannotDeleteSystemLinksception", "CannotDeleteSystemlinkception", "CannotDeleteSystemReferenceException", "CannotDeleteClassLinkception", "CannotDeleteSystemlinkInformation"], "ClassLinkTypeNotFoundException": ["ClassLinkTypeNotfoundError", "ClassLinkTypeNotSourceError", "ClassLinkTypeNotFoundError", "ClassLinkTypeNotSourceException", "ClassLinkTypeNotfoundException", "ClassLinkTypeNotSourceRequest", "ClassLinkTypeNotfoundRequest", "ClassLinkTypeNotFoundRequest"], "conn": ["orp", "db", "error", "client", "connect", "ca", "Conn", "h", "p", "query", "ctx", "n", "oss", "sync", "cond", "cp", "cn", "cc", "pg", "ou", "cat", "ns", "bb", "cli", "nt", "ci", "po", "core", "cache", "coll", "server", "cb", "loc", "ann", "open", "dn", "lc", "connection", "nc", "dc", "ver", "cur", "cm", "ob", "ssl", "con", "conf", "uc", "pub", "util", "close", "ch", "enc", "serv", "exec", "oci", "session", "ac", "rt", "org", "ct", "pc", "co", "mc", "Connection", "lock", "act", "config", "c", "pr", "ec"], "stmt": [" stm", "stdd", "strnt", "rdmt", "STsql", "istmd", "Stm", "Stdt", "stlt", "estsql", " stdb", "sthdb", " stmn", "strlt", "Stmd", "playnt", "rddd", "STdd", "stdt", "playmt", "strmb", "stmd", "stmp", "strmt", "Stmm", "strdd", " stmd", "ctm", "sthmt", "istmt", "Stmp", " stdd", "strmd", "estlt", "Stmb", "strsql", "strob", "stob", "STmt", "strmm", "strmp", "rdmd", "strm", "STlt", "sthmd", "estmt", "playmd", " stob", "ctmd", "stm", "istnt", " stmm", "istdt", " stnt", "ctmt", "stmm", "Stnt", " stmb", "estdd", " stsql", "ctmb", "stnt", "Stmt", "sthmn", "stsql", "stmn", "Stmn", "playdt", "Stdb", "stmb", " stmp", "stdb", "rdsql", "Stob"], "prepTable": ["supable", "PrepType", " preptable", "parTable", "preptable", " prepable", "parCol", "suptable", "parType", "supTable", "inittable", "prepable", "partable", "Preptable", "PrepTable", "prepType", "initType", " prepType", " prepCol", "supType", "Prepable", "initCol", "initTable", "prepCol"], "objectLinkTable": ["objLinkStore", "objlinkType", "objectlinkChain", "objectlinkType", "objlinkChain", "objectSyncStore", "objectlinkSource", "objectTypeFile", "ObjectLinkTable", "ObjectLineTable", "objectLinkChain", "ObjectLineTab", "ObjectLinkFile", "objectSyncChain", "objectLinkFile", "ObjectLinkSource", "objectLineSource", "objectRelTable", "objectLinkSource", "objLinkType", "objlinkTable", "objectTypeTab", "objectTypeTable", "objectRelChain", "objectTypeSource", "objectLineFile", "objectlinkFile", "objectlinkTab", "objLinkTable", "objectRelType", "ObjectLinkTab", "objlinkStore", "objLinkChain", "objectlinkStore", "ObjectLineSource", "objectLineTab", "objectRelStore", "objectSyncTable", "objectLinkStore", "objectLineTable", "ObjectLineFile", "objectlinkTable", "objectLinkTab", "objectSyncType", "objectLinkType"], "sql": ["db", "su", "term", "query", "sl", "summary", "s", "comment", "ls", "id", "statement", " SQL", "expression", "SQL", "sb", "sg", "sf", "result", "pr", "params", "ssl", "csv", "description", "function", "str", "url", "update", "zip", "sq", "log", "spec", "dl", "shell", "ql", "string", "general", "insert", "sv", "cmd", "join", "select"]}}
{"id1": "13946197", "id2": "13783549", "code1": "    public String transformByMD5(String password) throws XSServiceException {\n        MessageDigest md5;\n        byte[] output;\n        StringBuffer bufferPass;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            logger.warn(\"DataAccessException thrown while getting MD5 algorithm:\" + e.getMessage(), e);\n            throw new XSServiceException(\"Database error while saving user\");\n        }\n        md5.reset();\n        md5.update(password.getBytes());\n        output = md5.digest();\n        bufferPass = new StringBuffer();\n        for (byte b : output) {\n            bufferPass.append(Integer.toHexString(0xff & b).length() == 1 ? \"0\" + Integer.toHexString(0xff & b) : Integer.toHexString(0xff & b));\n        }\n        return bufferPass.toString();\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 0, "substitutes": {"transformByMD5": [" transformWithMDSecret", " transformByM3", " transformWithMD3", " transformByMD3", " transformByM5", " transformByM4", " transformWithMD4", " transformWithM3", " transformBymd5", " transformByMDSecret", " transformByMC4", " transformByMC3", " transformByMD4", " transformByMCSecret", " transformBymd3", " transformByMC5", " transformByMSecret", " transformWithMSecret", " transformBymd4", " transformWithM5", " transformBymdSecret", " transformWithMD5", " transformWithM4"], "password": ["account", "email", "p", "crypt", "pattern", "object", "user", "attribute", "sword", "phrase", "address", "padding", "Password", "connection", "path", "message", "resource", "params", "word", "PASS", "wd", "config", "prefix", "device", "channel", "wallet", "login", "data", "token", "database", "secret", " passwords", "text", "name", "auth", "string", " Password", "hash", "source", "filename", "username"], "md5": ["mand3", "mand45", " mdok", "mddown", " md512", " MD5", "MD2", "amd512", "md4", "mandse", " MD3", " mdfive", "md45", " MD45", "mdql", "amd3", "mand5", "MD3", "MD5", " MD4", "MDse", "mand2", "mdok", "mdfive", "amd5", "md2", "md3", " md55", "mdse", " mddown", "MDql", "MDfive", " md3", " MD55", "materialfive", "md55", " md4", " mdse", "materialql", "MD512", "md512", "MDdown", "amd2", "mand4", "material2", " MDdown", " MDok", "MDok", "material5", "mand55", " md45", " md2", " mdql"], "output": ["image", "foo", "buffer", "generated", "console", "full", "display", "queue", "character", "input", "sequence", "reference", "write", "page", "complete", "address", "written", "result", "property", "format", "beta", "target", "reason", "message", "response", "resource", "word", "array", "exit", "out", "hidden", "Output", "letter", "unit", "prefix", "dot", "data", "o", "secret", "offset", "text", "width", "document", "style", "string", "generation", "outer", "config"], "bufferPass": [" bufferPush", "bufComp", "bufferComp", " bufferPack", "bufCopy", "bufferpass", "BufferPass", "ufferScan", " bufferFeed", " bufferLine", "bufPush", "ufferPack", " bufferScan", "bufferFeed", "BufferFeed", "bufScan", " bufferCopy", "bufpass", "BufferLink", " bufferLink", "bufLink", "bufPack", "ufferPush", "Bufferpass", "bufLine", "bufferScan", "bufferLink", "ufferCopy", "ufferFeed", "bufferCopy", "BufferComp", " bufferpass", "bufferPush", "ufferPass", " bufferComp", "bufferLine", "ufferLine", "bufFeed", "bufferPack", "bufPass"], "b": ["r", "db", "abb", "buffer", "h", "p", "bytes", "obj", "n", "br", "bf", "i", "ab", "lb", "bs", "s", "bb", "e", "sb", "t", "rb", "a", "fb", "bl", "be", "ob", "line", "bi", "B", "x", "f", "eb", "binary", "url", "wb", "base", "null", "k", "u", "y", "v", "ba", "w", "l", " eb", "d", "body", " a", "orb", "cb", "c"]}}
{"id1": "15896098", "id2": "14820302", "code1": "    public String getSHA256Checksum(String source) {\n        String checksum = \"\";\n        try {\n            MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n            md.update(source.getBytes());\n            byte[] byteData = md.digest();\n            StringBuffer sb = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                sb.append(Integer.toString((byteData[i] & 0xff) + 0x100, 16).substring(1));\n            }\n            System.out.println(\"Hex format : \" + sb.toString());\n            StringBuffer hexString = new StringBuffer();\n            for (int i = 0; i < byteData.length; i++) {\n                String hex = Integer.toHexString(0xff & byteData[i]);\n                if (hex.length() == 1) {\n                    hexString.append('0');\n                }\n                hexString.append(hex);\n            }\n            checksum = hexString.toString();\n        } catch (NoSuchAlgorithmException ex) {\n            Logger.getLogger(CMessageDigestFile.class.getName()).log(Level.SEVERE, null, ex);\n        }\n        return checksum;\n    }\n", "code2": "    protected void innerProcess(ProcessorURI curi) throws InterruptedException {\n        Pattern regexpr = curi.get(this, STRIP_REG_EXPR);\n        ReplayCharSequence cs = null;\n        try {\n            cs = curi.getRecorder().getReplayCharSequence();\n        } catch (Exception e) {\n            curi.getNonFatalFailures().add(e);\n            logger.warning(\"Failed get of replay char sequence \" + curi.toString() + \" \" + e.getMessage() + \" \" + Thread.currentThread().getName());\n            return;\n        }\n        MessageDigest digest = null;\n        try {\n            try {\n                digest = MessageDigest.getInstance(SHA1);\n            } catch (NoSuchAlgorithmException e1) {\n                e1.printStackTrace();\n                return;\n            }\n            digest.reset();\n            String s = null;\n            if (regexpr != null) {\n                s = cs.toString();\n            } else {\n                Matcher m = regexpr.matcher(cs);\n                s = m.replaceAll(\" \");\n            }\n            digest.update(s.getBytes());\n            byte[] newDigestValue = digest.digest();\n            curi.setContentDigest(SHA1, newDigestValue);\n        } finally {\n            if (cs != null) {\n                try {\n                    cs.close();\n                } catch (IOException ioe) {\n                    logger.warning(TextUtils.exceptionToString(\"Failed close of ReplayCharSequence.\", ioe));\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"getSHA256Checksum": ["getSHA256Checsum", "getSHA256Checsumber", "getSHA256Chechecksums", "getSHA256Chcksam", "getSHA256Checksam", "getSHA256Chchecksam", "getSHA256Chchecksums", "getSHA256Chcksums", "getSHA256Checsam", "getSHA256Checksums", "getSHA256Cheicksam", "getSHA256Chechecksum", "getSHA256Chechecksam", "getSHA256Cheicksums", "getSHA256Chcksum", "getSHA256Chchecksum", "getSHA256Cheicksum", "getSHA256Chchecksumber", "getSHA256Chcksumber", "getSHA256Checsums", "getSHA256Chechecksumber", "getSHA256Cheicksumber", "getSHA256Checksumber"], "source": ["buffer", "service", "size", "src", "output", "object", "input", "slice", "cache", "from", "result", "target", "format", "connection", "content", "code", "path", "message", "resource", "fp", "dest", "file", "Source", "url", "base", "data", "SOURCE", "text", "reader", "string", "seed", "uri", "ource", "config", "length", "ources"], "checksum": ["checksums", "cssum", "check256", "checkum", "hssum", "hsam", " checksums", "checksam", "cksums", " checkssum", " checksumption", " checksam", "hexumption", "hexet", "checksup", "checkssum", " checkset", "hexum", "checks256", "cksum", "checkup", "cksam", "checksumption", "ckset", "hexsum", " checksup", "cksumption", "ckssum", " checks256", "csup", "checkset", "csum", "hsum", "cs256", "hsums"], "md": ["mm", "mac", "mo", "ind", "m", "Cmd", "dig", "bf", "grad", "MB", "pd", "metadata", "M", "um", "od", "rm", "mb", "cm", "amd", "nm", "df", "wd", "dh", "mand", "bd", "gd", "f", "sm", "dm", "pm", "mt", "MD", "mp", "mc", "hd", "vd", "mag", "d", "rpm", "ms", "am", "hash", "cmd", "dd", " MD", "vm", "hm"], "byteData": ["ByteArray", "ByteSize", "connectionDATA", "byteInfo", "byteText", "ipDATA", "characterData", "ipArray", "connectionSize", "ByteDATA", " bytedata", "wordInfo", "wordBytes", "ByteData", "byteList", "ipNumber", "byteSize", "bitList", "ByteInfo", "byteArray", "bitText", " byteArray", "numberdata", "ByteBytes", "characterArray", "bitData", "bytedata", "pixelData", " byteNumber", "wordData", " byteBytes", "wordArray", "numberDATA", " byteString", " byteDATA", "numberData", " byteText", " byteInfo", "numberString", "byteNumber", "pixelString", "connectionArray", "byteString", "characterList", "bitDATA", "bitNumber", "pixeldata", "pixelDATA", "characterText", " byteList", "connectionData", "ipData", " byteSize", "byteBytes", "byteDATA", "bitArray"], "sb": ["db", "abb", "bp", "buffer", "bf", "src", "ab", "lb", "bs", "bt", "SB", "bb", "ls", "usb", "sf", "sg", "bc", "rb", "bm", "fb", "kb", "bg", "mb", "ob", "buff", "gb", "pb", "ub", "bh", "bd", "eb", "buf", "binary", "wb", " SB", "BB", "sq", "b", "bsp", "xb", " eb", "si", "nb", "sv", "ws", "cb"], "i": ["r", "ai", "ip", "in", "j", "p", "h", "n", "ie", "key", "is", "q", "multi", "ix", "slice", "e", "phi", "id", "abi", "ci", "gi", "ui", "info", "li", "index", "ii", "io", "ori", "iu", "ini", "bi", "x", "pi", "f", "o", "xi", "ti", "k", "ri", "data", "u", "ni", "b", "y", "v", "ji", "w", "oi", "it", "mi", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"], "hexString": ["formService", " hexArray", "shortBuffer", "charStr", "checkString", " hexStr", "hexstring", "formString", "checkService", "hexArray", " hexService", " hexFile", "hexCode", "charBuffer", "formstring", "shortString", "rawArray", "rawService", "rawstring", "crossBuffer", "charString", "crossStr", "hexFile", "checkCode", "crossFile", "exFile", "checkArray", "shortStr", "rawString", "hashService", "charArray", "exStr", " hexCode", "hashString", "exBuffer", " hexBuffer", "hashCode", "crossString", "hashArray", "exString", "hexBuffer", "hexStr", "shortArray", " hexstring", "hexService", "formArray"], "hex": ["ip", "sync", "alpha", "bit", "form", "character", "serial", "nexus", "id", "ex", "sex", "cookie", "sum", "format", "wh", "exp", "num", "http", "rh", "buff", "pack", "digit", "closure", "cross", "raw", "lit", "str", "pex", "oct", "letter", "null", "none", "zip", "data", "temp", "rex", "char", "comp", "transform", "color", "text", "pixel", "bin", "coord", "string", "utf", "hash", "cmp", "shift", "length"]}}
{"id1": "17996547", "id2": "11334468", "code1": "    public static File copyFile(File fileToCopy, File copiedFile) {\n        BufferedInputStream in = null;\n        BufferedOutputStream outWriter = null;\n        if (!copiedFile.exists()) {\n            try {\n                copiedFile.createNewFile();\n            } catch (IOException e1) {\n                e1.printStackTrace();\n                return null;\n            }\n        }\n        try {\n            in = new BufferedInputStream(new FileInputStream(fileToCopy), 4096);\n            outWriter = new BufferedOutputStream(new FileOutputStream(copiedFile), 4096);\n            int c;\n            while ((c = in.read()) != -1) outWriter.write(c);\n            in.close();\n            outWriter.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n            return null;\n        } catch (IOException e) {\n            e.printStackTrace();\n            return null;\n        }\n        return copiedFile;\n    }\n", "code2": "    public final int wordFrequency(String word) {\n        String replWebQuery = webQuery.replaceFirst(\"WORDREPLACE\", word);\n        try {\n            URL url = new URL(replWebQuery);\n            String content = url.toString();\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String inputLine;\n            while ((inputLine = in.readLine()) != null) {\n                if (inputLine.matches(nrResultsPattern)) {\n                    int fr = matchedLine(inputLine);\n                    if (fr >= 0) {\n                        return fr;\n                    }\n                }\n            }\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return 0;\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "opyfile", "copFiles", "opyFile", " copySourceFile", "copyFiles", "copyfile", "copfile", "copFile", "opySourceFile", "opyFiles", "copSourceFile"], "fileToCopy": ["fileWillCreate", "FileToCopy", "FileWillCreate", "filePleaseCopy", "fileToCop", "FiletoCreate", "FiletoCopy", "fileWillSample", "FileWillDelete", "filetoCreate", "FileToWrite", "filetoCopy", "fileToWrite", "fileSyncCreate", "FileWillCopy", "filetoSample", "FiletoWrite", "fileSyncCop", "fileToDelete", "filePleaseCreate", "FiletoCop", "fileToCreate", "filetoCop", "FileToSample", "fileSyncCopy", "FileToCop", "filetoWrite", "FileToDelete", "fileTOWrite", "FileToCreate", "fileWillDelete", "filetoDelete", "fileTOCop", "fileSyncWrite", "FileWillSample", "fileToSample", "filePleaseDelete", "filePleaseSample", "fileTOCreate", "fileWillCopy", "fileTOCopy"], "copiedFile": ["coppedPage", "copyingDirectory", "coiedFile", "copiedFolder", "copyingFile", "copiedHeader", "CopiedFiles", "CopcedFile", "copppedUrl", "CopedFiles", "copieFile", " copiedfile", "CopiedDir", "coppedFrame", "copcedF", "coiedFrame", "copiedUnit", "copcedDirectory", "copieF", "copppedFrame", " copieFile", "coippedDir", " copieF", "copotedDirectory", "copodedfile", "copedFiles", "CopcedPage", " copiefile", "copixedUrl", "copippedFile", "copedPage", "coippedDirectory", "copppedFile", "copiedDirectory", " copieFolder", "coippedFile", "coppedUnit", "copcedfile", "copiedDir", "copicedHeader", "copixedFrame", "copotedDir", "copcedFolder", "copcedPage", "copiedFrame", "coiedUnit", "copicedFile", "copixedUnit", "CopedDir", "copippedPlace", "copippedDirectory", "coippedPlace", "copriedFrame", "coiedDirectory", "coiedUrl", "CopiedHeader", "copippedFiles", "copotedFile", "copriedUnit", "copiedUrl", "copotedPlace", "copppedUnit", "copicedDirectory", "copippedPage", "CopiedFile", "CopedFile", "copodedFile", "coiedPlace", "copyingHeader", "coiedDir", "copedDirectory", "copicedPage", "copippedDir", "copedDir", "coppedUrl", "copriedUrl", "copiedfile", "copiedPage", "CopiedPage", "copieFolder", "copiedPlace", "CopcedHeader", "copyingPage", "CopedPage", "copedFile", "coppedFiles", "copiedFiles", "CopiedDirectory", " copiedFolder", "copedPlace", " copiedF", "copodedFolder", "copriedFile", "copiefile", "copcedHeader", "copiedF", "coppedFile", "copodedF", "copcedFile", "CopcedDirectory", "coppedDir", "copixedFile"], "in": ["r", "image", "m", "pin", "inn", "fa", "gin", "isin", "i", "zin", "socket", "s", "init", "cin", "impl", "input", "e", "copy", "din", "conn", "lin", "connection", "cgi", "a", "inner", "vin", "nin", "ssl", "out", "con", "ini", "into", "inside", "url", "login", "ac", "err", "b", "oin", "it", "ins", "pc", "bin", "In", "reader", "IN", "as", "again", "lock", "win", "source", "inc"], "outWriter": ["OutWs", " outBuffer", "outWs", "newWrite", "outStream", "outReader", "outWalker", "newWriter", "inWrite", "againBuffer", "outputStream", "newReader", " outWrite", "outWrite", "inWriter", "againStream", "againFile", "outputWrite", "outputReader", "outputWriter", "inReader", " outStream", "outputWs", " outWs", " outFile", "againWrite", "newStream", "OutFile", "againWriter", "OutWalker", " outReader", "OutWrite", "outputWalker", "OutBuffer", "outFile", "outBuffer", "againWalker", "OutReader", " outWalker", "OutStream", "OutWriter", "inStream"], "c": ["r", "C", "sc", "m", "p", "n", "cp", "i", "ce", "rc", "cc", "cell", "character", "dec", "e", "cr", "cy", "ci", "lc", "cf", "t", "cu", "code", "bc", "pointer", "dc", "oc", "cm", "xc", "esc", "x", "f", "col", "ch", "o", "enc", "k", "ac", "u", "b", "arc", "char", "cl", "ct", "pc", "l", "d", "ec"]}}
{"id1": "2324868", "id2": "12783713", "code1": "            @Override\n            public void actionPerformed(ActionEvent e) {\n                try {\n                    Pattern delim = Pattern.compile(\"[ ]\");\n                    BufferedReader r = new BufferedReader(new InputStreamReader(new GZIPInputStream(new FileInputStream(\"/home/lindenb/jeter.txt.gz\"))));\n                    String line = null;\n                    URL url = new URL(\"http://eutils.ncbi.nlm.nih.gov/entrez/eutils/efetch.fcgi\");\n                    URLConnection conn = url.openConnection();\n                    conn.setDoOutput(true);\n                    OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());\n                    wr.write(\"db=snp&retmode=xml\");\n                    while ((line = r.readLine()) != null) {\n                        String tokens[] = delim.split(line, 2);\n                        if (!tokens[0].startsWith(\"rs\")) continue;\n                        wr.write(\"&id=\" + tokens[0].substring(2).trim());\n                    }\n                    wr.flush();\n                    r.close();\n                    InputStream in = conn.getInputStream();\n                    IOUtils.copyTo(in, System.err);\n                    in.close();\n                    wr.close();\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n", "code2": "    @Override\n    public void sendErrorMessage(String message) throws EntriesException, StatementNotExecutedException, NotConnectedException, MessagingException {\n        if (query == null) {\n            throw new NotConnectedException();\n        }\n        ArrayList<String> recipients = query.getUserManager().getTecMail();\n        Mail mail = new Mail(recipients);\n        try {\n            ZipOutputStream zos = new ZipOutputStream(new FileOutputStream(\"log/ossobooklog.zip\"));\n            FileInputStream fis = new FileInputStream(\"log/ossobook.log\");\n            ZipEntry entry = new ZipEntry(\"ossobook.log\");\n            zos.putNextEntry(entry);\n            byte[] buffer = new byte[8192];\n            int read = 0;\n            while ((read = fis.read(buffer, 0, 1024)) != -1) {\n                zos.write(buffer, 0, read);\n            }\n            zos.closeEntry();\n            fis.close();\n            zos.close();\n            mail.sendErrorMessage(message, new File(\"log/ossobooklog.zip\"), getUserName());\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n", "label": 1, "substitutes": {"actionPerformed": ["actionExecressed", "actionCalled", "actionOccressed", " actionExecressed", " actionExecuted", "actionOccalled", " actionPeruted", "actionPeruted", " actionExecalled", "actionCuted", "actionPeralled", "actionPerressed", "actionOccuted", "actionCformed", "actionExecformed", "actionExecuted", "actionOccformed", " actionPerressed", " actionPeralled", " actionExecformed", "actionExecalled", "actionCressed"], "e": ["an", "de", "ctx", "g", "q", "ee", "events", "t", "es", "a", "se", "E", "exc", "x", "ev", "f", "ception", "type", "v", "name", "me", "et", "ae", "te", "event", "self", "c", "ec"], "delim": ["selm", "selim", "delem", "flim", "elem", "Delem", "delimmer", "flimmer", "flcm", "elim", "Delimmer", "Delam", "Delim", "elm", " delam", "delm", " delimmer", " delcm", "Delm", "delam", "selem", "delcm", "selam", "Delcm", "flam", "elam"], "r": ["lr", "fr", "writer", "p", "n", "br", "rl", "i", "rc", "rs", "rx", "cr", "dr", "ru", "rb", "adr", "rss", "rh", "ir", "rr", "rar", "nr", "hr", "sr", "rw", "f", "iter", "err", "rt", "er", "w", "kr", "l", "res", "ar", "reader", "tr", "R", "ws", "re", "c", "pr"], "line": ["fin", "job", "lf", "one", "sl", "entry", "rl", "block", "key", "cell", "comment", "feed", "el", "id", "page", "lc", "rule", "lines", "val", "Line", "lin", "code", "response", "time", "word", "value", "row", "file", "str", "end", "link", "sel", "col", "no", "pass", "inline", "data", "pe", "log", "split", "LINE", "number", "text", "cl", "name", "l", "style", "reader", "string", "header", "nl", "le", "look", "re", "source"], "url": ["lr", "blog", "fr", "client", "sl", "rl", "host", "fl", "ls", "server", "loc", "connection", "http", "URL", "resource", "path", "pull", "ob", "ssl", "file", "link", "sr", "f", "Url", "base", "err", "log", "org", "l", "string", "nl", "web", "ur", "uri", "jar", "www"], "conn": ["db", "gr", "client", "connect", "Conn", "p", "sync", "ctx", "n", "cp", "rc", "cn", "socket", "cr", "nt", "cf", "coll", "loc", "open", "ann", "connection", "dc", "http", "nc", "cur", "fp", "io", "cm", "ssl", "out", "con", "pub", "ctrl", "f", "ch", "enc", "api", "sql", "conv", "err", "rt", "w", "cl", "ct", "co", "rn", "l", "Connection", "lock", "cb", "c", "pr"], "wr": ["fw", "gr", "fr", "writer", "wal", "WR", "Wr", "rs", "write", "cr", "rx", "ew", "Writer", "dr", "rb", "wh", "rss", "war", "rh", "rr", "out", "shr", "wd", "nr", "hr", "riter", "rw", "sr", "wy", "mr", "rar", "wb", "wer", "err", "wl", "wa", "rt", "w", "kr", "nw", "wave", "vr", "res", "wrap", "wx", "wt", "wk", "RW", "pr", "wm"], "tokens": ["tkoks", "targets", "pargens", "torkicks", "taken", "Takicks", "tkicks", "pokens", "tOKens", "toyen", "tokenets", "tOKets", "itokenens", "itokets", "takets", "tOKelines", "Tokoks", "tokos", "toyens", "itokos", "itokens", "poken", "tokenos", "pargelines", "itokenos", "targelines", "tokenens", "toyets", "takens", "tOKen", "takelines", "Taken", "Takens", "itoken", "torkoks", "tokoks", "Tokens", "Takoks", "tokelines", "takos", "targens", "token", "tokicks", "targen", "tken", "itokenets", "pargets", "tkens", "pargen", "tokenen", "pokets", "toyos", "tokets", "pokelines", "itokenen", "takoks", "Token", "torken", "takicks", "torkens", "Tokicks"], "in": ["pin", "ic", "n", "inn", "ina", "gin", "isin", "i", "is", "zin", "init", "cin", "input", "ln", "tin", "thin", "arin", "din", "sin", "inas", "lin", "inner", "vin", "io", "pull", "nin", "ini", "out", "con", "rin", "kin", "str", "min", "data", "err", "oin", "it", "ins", "bin", "In", "reader", "IN", "again", "win", "inc"]}}
{"id1": "19549489", "id2": "88047", "code1": "    public static void copy(File sourceFile, File destinationFile) throws IOException {\n        FileChannel sourceFileChannel = (new FileInputStream(sourceFile)).getChannel();\n        FileChannel destinationFileChannel = (new FileOutputStream(destinationFile)).getChannel();\n        sourceFileChannel.transferTo(0, sourceFile.length(), destinationFileChannel);\n        sourceFileChannel.close();\n        destinationFileChannel.close();\n    }\n", "code2": "    private static void readAndRewrite(File inFile, File outFile) throws IOException {\n        ImageInputStream iis = ImageIO.createImageInputStream(new BufferedInputStream(new FileInputStream(inFile)));\n        DcmParser dcmParser = DcmParserFactory.getInstance().newDcmParser(iis);\n        Dataset ds = DcmObjectFactory.getInstance().newDataset();\n        dcmParser.setDcmHandler(ds.getDcmHandler());\n        dcmParser.parseDcmFile(null, Tags.PixelData);\n        PixelDataReader pdReader = pdFact.newReader(ds, iis, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        System.out.println(\"reading \" + inFile + \"...\");\n        pdReader.readPixelData(false);\n        ImageOutputStream out = ImageIO.createImageOutputStream(new BufferedOutputStream(new FileOutputStream(outFile)));\n        DcmEncodeParam dcmEncParam = DcmEncodeParam.IVR_LE;\n        ds.writeDataset(out, dcmEncParam);\n        ds.writeHeader(out, dcmEncParam, Tags.PixelData, dcmParser.getReadVR(), dcmParser.getReadLength());\n        System.out.println(\"writing \" + outFile + \"...\");\n        PixelDataWriter pdWriter = pdFact.newWriter(pdReader.getPixelDataArray(), false, ds, out, dcmParser.getDcmDecodeParam().byteOrder, dcmParser.getReadVR());\n        pdWriter.writePixelData();\n        out.flush();\n        out.close();\n        System.out.println(\"done!\");\n    }\n", "label": 1, "substitutes": {"copy": ["clone", "p", "sync", "upload", "Transfer", "all", "transfer", "delete", "Copy", " move", "write", "Cop", " transfer", " copied", "cop", "io", " copying", "file", "zip", "download", "create", "paste", "split", " Copy", " copies", "source", "move"], "sourceFile": ["servicefile", "serviceFile", "sourceFILE", "resourcefile", "searchfile", "siteFiles", "Sourcefile", "sourcefile", " sourceDirectory", "searchFile", "serviceFilename", "serviceFiles", "SourceFILE", " sourcefile", "siteFile", " sourceFilename", " sourceFiles", "resourceFile", " sourceFILE", "resourceFiles", "sourceDirectory", "SourceDirectory", "SourceFile", "siteFILE", "SourceFiles", "searchFilename", "siteDirectory", "searchFiles", "sourceFilename", "resourceDirectory", "sourceFiles"], "destinationFile": ["destinationDirectory", "destinatedFile", "DestinationDir", "Destinatorfile", "DestinatorFile", "destinatedFiles", "destinatorFile", "destinatedImage", "Destinationfile", "destationFiles", "distinatedImage", "destinatorDir", "DestinatorDir", "DestinatorFiles", "distinatedDirectory", "distinationFile", "destationFile", "destinatorDirectory", "destinatorImage", "destinationfile", "destationfile", "destinatedDir", "destationDirectory", "destinationDir", "destinatorfile", "destinationImage", "destinatorFiles", "destinationFiles", "destationDir", "distinatedFile", "DestinationFiles", "distinationImage", "distinationDirectory", "destationImage", "destinatedfile", "DestinationFile", "distinatedFiles", "destinatedDirectory", "distinationFiles"], "sourceFileChannel": ["ourceStreamStream", "targetLibraryChan", " sourceFileService", "targetFileChannel", "sourceStreamService", "sourceDirectorySocket", "sourceDirchannel", "sourceFileSocket", "sourceDirChan", "sourceFilesContext", "sourceFileClient", "sourceLineChan", "sourceFileContext", "sourceFileConnection", "sourceFilechannel", "sourceDirStream", "ourceFileChannel", " sourceFileConnection", "sourceLibraryChan", "sourceLineSocket", "sourceStreamStream", "sourceFunctionContext", "sourceLibraryClient", "sourceStreamchannel", "sourceStreamChan", " sourceFilesConnection", " sourceFileContext", "sourceDirectoryClient", "ourceStreamChan", "sourceFileService", "sourceStreamChannel", "sourceFunctionChannel", "ourceFileChan", "sourceLineClient", "sourceDirectoryChannel", "sourceLibrarySocket", " sourceFilesChannel", "sourceLibraryChannel", "targetFileClient", "sourceStreamContext", "sourceLineChannel", " sourceFilesService", "targetFileChan", "targetLibraryClient", " sourceFilesContext", "sourceStreamConnection", "targetLibraryChannel", "sourceFileChan", "ourceFileStream", "ourceStreamChannel", "targetFileSocket", "sourceDirChannel", "sourceLinechannel", "sourceLineStream", "sourceFilesChannel", "sourceDirectoryChan", "ourceStreamchannel", "sourceFunctionConnection", "sourceFilesService", "ourceFilechannel", "sourceFilesConnection", "sourceFileStream", "targetLibrarySocket", "sourceFunctionService"], "destinationFileChannel": ["destinationFilesClient", "destinatorFileService", "destinationFilesChan", "destinationDirectoryChannel", "destinatorFilesClient", "destinationLineService", "destinationFileConnection", "destinationFileService", "destinationFilesService", "destinationIOChannel", "destinatorFileClient", "destinationLineChannel", "destinationFileClient", "destinationLineChan", "destinationFileHandler", "destinationLineConnection", "destinationFilesHandler", "destinationDirectoryClient", "destinationDirectoryChan", "destinatorFileConnection", "destinationDirectoryConnection", "destinatorFilesChannel", "destinatorFilesConnection", "destinationFilesChannel", "destinatorFilesService", "destinationFilesConnection", "destinationFileChan", "destinatorFileCache", "destinationDirectoryHandler", "destinationDirectoryService", "destinationLineHandler", "destinatorFilesCache", "destinatorFileHandler", "destinatorFilesChan", "destinationFilesCache", "destinationFileCache", "destinationDirectoryCache", "destinatorFileChan", "destinationLineClient", "destinationIOService", "destinationIOCache", "destinatorFileChannel", "destinationIOClient", "destinatorFilesHandler"]}}
{"id1": "17716716", "id2": "4750967", "code1": "    public static String plainToMD(LoggerCollection loggerCol, String input) {\n        byte[] byteHash = null;\n        MessageDigest md = null;\n        StringBuilder md5result = new StringBuilder();\n        try {\n            md = MessageDigest.getInstance(\"MD5\");\n            md.reset();\n            md.update(input.getBytes());\n            byteHash = md.digest();\n            for (int i = 0; i < byteHash.length; i++) {\n                md5result.append(Integer.toHexString(0xFF & byteHash[i]));\n            }\n        } catch (NoSuchAlgorithmException ex) {\n            loggerCol.logException(CLASSDEBUG, \"de.searchworkorange.lib.misc.hash.MD5Hash\", Level.FATAL, ex);\n        }\n        return (md5result.toString());\n    }\n", "code2": "    public void patch() throws IOException {\n        if (mods.isEmpty()) {\n            return;\n        }\n        IOUtils.copy(new FileInputStream(Paths.getMinecraftJarPath()), new FileOutputStream(new File(Paths.getMinecraftBackupPath())));\n        JarFile mcjar = new JarFile(Paths.getMinecraftJarPath());\n    }\n", "label": 0, "substitutes": {"plainToMD": [" string2String", " string2DER", " stringtoString", " stringtoMD", " stringTODER", " stringtoDER", " stringTOString", " input2DER", " string2Hash", " stringtoHash", " stringToDER", " inputToMD", " stringTOMD", " stringToMD", " inputToDER", " input2String", " stringTOHash", " stringToString", " string2MD", " inputToHash", " stringToHash", " inputToString", " input2Hash", " input2MD"], "loggerCol": ["progingCollection", "loggeDr", "progingColumn", "progingCol", "progerCollection", "logorerColumn", "loggingCor", "loggerCor", "pluggingCol", "loggercol", "progercol", "loggeecol", "pluggingCor", "loggerColumn", "loglerColumn", "loggeeCol", "loggingCollection", "pluggercol", "loggerDr", "loggingcol", "loggingColumn", "loglerCollection", "logorercol", "loglerCol", "loggerCollection", "loggeCol", "loglercol", "logorerCollection", "loggingDr", "loggeeCor", "progingcol", "pluggerDr", "loggeCor", "loggecol", "loggingCol", "pluggingDr", "pluggerCor", "logorerCol", "pluggingcol", "loggeeDr", "pluggerCol", "progerCol", "progerColumn"], "input": ["request", "image", "in", "buffer", "alpha", "output", "form", "context", "dict", "instance", "plus", "inf", "state", "format", "connection", "container", "path", "audio", "xml", "ssl", "raw", "file", "str", "url", "null", "base", "model", "data", "temp", "Input", "text", "password", "reader", "string", "list", "IN", "empty", "cmd", "source", "config"], "byteHash": ["ByteBlock", "bitArray", "wordhash", "blockHash", " bytehash", "bitSum", "blockhash", "bitBlock", " byteSum", "byteArray", "ByteSum", "stringArray", "bytesArray", " byteArray", " byteBlock", "wordHash", "byteSum", "blockBlock", "byteshash", "byteSalt", "wordArray", "bitHash", "bytesHash", "stringSalt", "byteBlock", "stringHash", "bytehash", " byteSalt", "blockSum", "bithash", "stringhash", "Bytehash", "ByteHash", "wordSum", "bytesSalt"], "md": ["mm", "mac", "mo", "m", "Cmd", "dig", "ph", "msg", "cc", "ad", "pkg", "mn", "mu", "pd", "metadata", "um", "ma", "cd", "dr", "rm", "amd", "cm", "mb", "nm", "df", "dh", "mand", "bd", "f", "sm", "mg", "dm", "doc", "pm", "Msg", "mt", "MD", "di", "mp", "mc", "mod", "mag", "rpm", "d", "ms", "am", "meta", "hash", "cmd", "dd", " MD", "hm"], "md5result": ["md25result", "md4runner", "mddowndata", " md5package", "md25data", "md4result", "md305results", "md512results", "md512result", "md25Result", " md5report", "md6Result", "md7Result", "md6data", " md305runner", " md5results", " md5data", "md5response", " md25data", "md53results", "md305result", "md53runner", "md6package", "md5package", "md6results", "md6report", "md5report", "md7result", "md512report", " md7results", "md6result", "md5results", "md25package", " md25result", "md5Result", " md25package", "md5runner", " md5response", "md53response", " md7Result", "mddownpackage", "md305runner", " md305result", "mddownresult", "md7report", "md4results", " md25Result", "md305response", " md305results", " md5Result", " md7result", " md7report", "md512Result", " md305response", " md5runner", "md7results", "md5data", "mddownResult", "md4response", "md53result"], "i": ["r", "ai", "h", "p", "j", "n", "key", "s", "multi", "fi", "e", "id", "mu", "ci", "gi", "ui", "length", "zi", "li", "index", "ii", "io", "z", "bi", "x", "pi", "f", "o", "xi", "ti", "ri", "u", "b", "v", "ji", "oi", "di", "l", "hi", "d", "si", "qi", "uri", "I", "c"]}}
{"id1": "20306677", "id2": "20128728", "code1": "    public int update(BusinessObject o) throws DAOException {\n        int update = 0;\n        Bill bill = (Bill) o;\n        try {\n            PreparedStatement pst = connection.prepareStatement(XMLGetQuery.getQuery(\"UPDATE_BILL\"));\n            pst.setInt(1, bill.getId());\n            update = pst.executeUpdate();\n            if (update <= 0) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows <= 0\");\n            } else if (update > 1) {\n                connection.rollback();\n                throw new DAOException(\"Number of rows > 1\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            Log.write(e.getMessage());\n            throw new DAOException(\"A SQLException has occured\");\n        } catch (NullPointerException npe) {\n            Log.write(npe.getMessage());\n            throw new DAOException(\"Connection null\");\n        }\n        return update;\n    }\n", "code2": "    void copyFile(File src, File dst) throws IOException {\n        FileChannel inChannel = new FileInputStream(src).getChannel();\n        FileChannel outChannel = new FileOutputStream(dst).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) inChannel.close();\n            if (outChannel != null) outChannel.close();\n        }\n    }\n", "label": 0, "substitutes": {"update": ["next", "size", "query", "save", "sync", "address", "replace", "more", "UPDATE", "change", "value", "edit", "build", "end", "range", "width", "draw", "create", "get", "full", "view", "load", "feed", "bug", "future", "patch", "json", "check", "diff", "updated", "index", "response", "find", "unit", "append", "database", "offset", "status", "two", "lock", "event", "latest", "inc", "where", "ul", "delete", "object", "use", "Update", "id", "core", "run", "apply", "plus", "result", "grade", "row", "put", "insert", "add", "up", "version", "write", "property", "connection", "ite", "resource", "date", "fill", "data", "other", "current"], "o": ["mo", "O", "os", "OO", "obj", "oe", "n", "ow", "one", "p", "ao", "i", "object", "s", "oid", "ou", " object", "e", "ol", "po", "office", "bo", "ingo", "t", "oo", "or", "Obj", "od", " bo", "out", "oa", "ilo", "f", "b", " O", "article", "bot", "oro", "vo"], "bill": ["db", "service", "batch", "note", "fee", "flow", "order", "object", "user", "fl", "bug", "nn", "ee", "bel", "conn", " contract", "business", "foo", "Bill", "bl", "report", "pool", "ban", "book", "f", "unit", "base", "mill", "charge", "b", "bar", "log", "number", "contract", "company", "bean", "project", "roll", "BILL", "bird", "account"], "pst": [" psts", " psth", "psts", "lpsp", "lpst", "psp", "lpct", "Psp", "Psc", "jpst", "ppct", "nsts", "pct", "nct", "jpsth", "ppsp", "lpsts", "ppst", "jpsts", "Pst", "presc", "ppsc", "jpct", "nsp", "Pct", "Psth", "presp", "prect", "nst", "prest", " pct", "Psts", "psc", "psth"]}}
{"id1": "21999120", "id2": "18693224", "code1": "    public String encrypt(String password) throws Exception {\n        MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n        md5.update(password.getBytes());\n        BigInteger hash = new BigInteger(1, md5.digest());\n        String hashword = hash.toString(16);\n        return hashword;\n    }\n", "code2": "    public void runDynusT(final boolean cleanUp) {\n        final String[] exeFiles = new String[] { \"DynusT.exe\", \"DLL_ramp.dll\", \"Ramp_Meter_Fixed_CDLL.dll\", \"Ramp_Meter_Feedback_CDLL.dll\", \"Ramp_Meter_Feedback_FDLL.dll\", \"libifcoremd.dll\", \"libmmd.dll\", \"Ramp_Meter_Fixed_FDLL.dll\", \"libiomp5md.dll\" };\n        final String[] modelFiles = new String[] { \"network.dat\", \"scenario.dat\", \"control.dat\", \"ramp.dat\", \"incident.dat\", \"movement.dat\", \"vms.dat\", \"origin.dat\", \"destination.dat\", \"StopCap4Way.dat\", \"StopCap2Way.dat\", \"YieldCap.dat\", \"WorkZone.dat\", \"GradeLengthPCE.dat\", \"leftcap.dat\", \"system.dat\", \"output_option.dat\", \"bg_demand_adjust.dat\", \"xy.dat\", \"TrafficFlowModel.dat\", \"parameter.dat\" };\n        log.info(\"Creating iteration-directory...\");\n        File iterDir = new File(this.tmpDir);\n        if (!iterDir.exists()) {\n            iterDir.mkdir();\n        }\n        log.info(\"Copying application files to iteration-directory...\");\n        for (String filename : exeFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.dynusTDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        log.info(\"Copying model files to iteration-directory...\");\n        for (String filename : modelFiles) {\n            log.info(\"  Copying \" + filename);\n            IOUtils.copyFile(new File(this.modelDir + \"/\" + filename), new File(this.tmpDir + \"/\" + filename));\n        }\n        for (File f : new File(this.modelDir).listFiles()) {\n            if (f.getName().toLowerCase(Locale.ROOT).endsWith(\".dws\")) {\n                log.info(\"  Copying \" + f.getName());\n                IOUtils.copyFile(f, new File(this.tmpDir + \"/\" + f.getName()));\n            }\n        }\n        String logfileName = this.tmpDir + \"/dynus-t.log\";\n        String cmd = this.tmpDir + \"/DynusT.exe\";\n        log.info(\"running command: \" + cmd + \" in directory \" + this.tmpDir);\n        int timeout = 7200;\n        int exitcode = ExeRunner.run(cmd, logfileName, timeout, this.tmpDir);\n        if (exitcode != 0) {\n            throw new RuntimeException(\"There was a problem running Dynus-T. exit code: \" + exitcode);\n        }\n        if (cleanUp) {\n            for (String filename : exeFiles) {\n                log.info(\"  Deleting \" + filename);\n                new File(this.tmpDir + \"/\" + filename).delete();\n            }\n        }\n    }\n", "label": 0, "substitutes": {"encrypt": ["encryption", "crypted", "Encrypt", "Encryption", "cryption", "decrypt", "encipher", "crypt", "encrypted", "Encipher", "decrypted", "decryption", "decipher", "Encrypted", "cipher"], "password": ["account", "buffer", "p", "crypt", "key", "pattern", "input", "attribute", "sword", "phrase", "address", "padding", "Password", "content", "path", "message", "word", "wd", "prefix", "enc", "pass", "security", "data", "secret", "token", "number", " passwords", "text", "name", "auth", "string", "seed", " Password", "PASS", "username"], "md5": ["hash5", " md512", " MD5", " MD53", "hash512", "MD2", "md4", " MD4", "MD5", "MD8", "md8", " mdless", "md2", " MD512", " md4", " md53", "hash2", " MD2", "MD512", "md512", " md8", "MD53", "mdless", "MDless", " MD8", "hashless", "md53", "MD4", " md2"], "hash": ["mac", "image", "h", "html", "ash", "key", "output", "square", "object", "version", "cache", "check", "sh", "result", "handle", "sum", "array", "message", "num", "value", "count", "Hash", "fill", "cover", "build", "dot", "update", "her", "log", "sha", "number", "auth", "string", "kh", "sign", "hed", "length", "hex"], "hashword": ["hashkey", " hashWord", "Hashword", "sumkey", "hashWord", "hashwords", "hashbyte", "trustbyte", "ashWord", "sumWord", "sumwords", "ashword", "trustword", " hashbyte", "hashpassword", " hashwords", " hashkey", "sumword", "trustWord", "Hashkey", "trustpassword", " hashpassword", "ashpassword", "ashbyte", "Hashwords", "HashWord"]}}
{"id1": "6470716", "id2": "4164833", "code1": "    public static void main(String[] args) throws Exception {\n        String st = \"http://www.kmzlinks.com/redirect.asp?id=113&file=HeartShapedIsland.kmz\";\n        URL url = new URL(st);\n        InputStream fis = null;\n        if (\"file\".equals(url.getProtocol())) fis = new FileInputStream(url.getFile()); else if (\"http\".equals(url.getProtocol())) fis = url.openStream();\n        ZipInputStream zis = new ZipInputStream(fis);\n        ZipEntry entry;\n        while ((entry = zis.getNextEntry()) != null) {\n            System.out.println(\"Extracting: \" + entry);\n            int count;\n            byte data[] = new byte[BUFFER];\n            FileOutputStream fos = new FileOutputStream(entry.getName());\n            BufferedOutputStream dest = new BufferedOutputStream(fos, BUFFER);\n            while ((count = zis.read(data, 0, BUFFER)) != -1) dest.write(data, 0, count);\n            dest.flush();\n            dest.close();\n        }\n        zis.close();\n    }\n", "code2": "    public static void buildDeb(File debFile, File controlFile, File dataFile) throws IOException {\n        long now = new Date().getTime() / 1000;\n        OutputStream deb = new FileOutputStream(debFile);\n        deb.write(\"!<arch>\\n\".getBytes());\n        startFileEntry(deb, DEBIAN_BINARY_NAME, now, DEBIAN_BINARY_CONTENT.length());\n        deb.write(DEBIAN_BINARY_CONTENT.getBytes());\n        endFileEntry(deb, DEBIAN_BINARY_CONTENT.length());\n        startFileEntry(deb, CONTROL_NAME, now, controlFile.length());\n        FileInputStream control = new FileInputStream(controlFile);\n        byte[] buffer = new byte[1024];\n        while (true) {\n            int read = control.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        control.close();\n        endFileEntry(deb, controlFile.length());\n        startFileEntry(deb, DATA_NAME, now, dataFile.length());\n        FileInputStream data = new FileInputStream(dataFile);\n        while (true) {\n            int read = data.read(buffer);\n            if (read == -1) break;\n            deb.write(buffer, 0, read);\n        }\n        data.close();\n        endFileEntry(deb, dataFile.length());\n        deb.close();\n    }\n", "label": 1, "substitutes": {"st": ["ST", "r", "sts", "stage", "sc", "fr", "ast", "St", "src", "class", "ste", "s", "std", "id", "Str", "ft", "t", "sb", "stress", "const", "sf", "fe", "tt", "code", "inst", "sta", "str", "start", "f", "est", "rest", "struct", "put", "cl", "ct", "ost", "d", "string", "ld", "sth", "ust", "pt", "www", "ist"], "url": ["blog", "image", "fr", "sl", "ul", "html", "stream", "tool", "host", "feed", "impl", "fl", "user", "bug", "ls", "bb", "id", "page", "server", "coll", "bel", "address", "open", "loc", "or", "connection", "http", "hub", "URL", "path", "ob", "ssl", "file", "build", "link", "f", "Url", "base", "zip", "err", "gl", "download", "log", "b", "org", "ll", "cl", "l", "string", "web", "ur", "uri", "pl", "source", "www"], "fis": ["lis", "fips", "fIS", "FIS", "bis", "flris", "zris", "flos", "zips", "lris", "fi", " fips", " fris", "FIs", "fIs", "Fos", "Fips", "flis", "zIS", "fliss", "afiss", " fiss", "biss", "afos", "bi", "afis", "flIs", "fli", "fris", " fils", "lils", "fiss", "bos", " fIS", "liss", "fils", "afIs", "Fris", "Fis", "Fiss", "flils", " fi"], "zis": ["zenois", "zeIS", " ziss", "qiss", "Zais", "ezIS", " zisa", "Zis", "zips", "qbis", "zipisi", "qis", "ziss", "ezisa", "zenis", "ezis", "zois", "zeisa", " zais", "zipiss", " zits", "zipbis", "zIS", "zais", " zisi", "zi", "zipi", "zisa", "ezips", "zipis", "zeips", "Ziss", " zois", " zips", " zi", "zenisi", " zIS", "zbis", "zits", "zipits", "zipais", "zisi", "zenais", "qi", "Zits", "zeis", " zbis", "zipois"], "entry": ["next", "r", "image", "in", "ace", "match", "la", "de", "country", "auto", "fr", "obj", "ie", "element", "sec", "cel", "key", "cell", "object", "comment", "feed", "rc", "sea", "parse", "e", "enter", "cat", "nt", "ry", "lc", "archive", "address", "info", "result", "or", "dc", "ident", "li", "index", "exp", "inner", "se", "line", "row", "file", "part", "ge", "zip", "session", "pe", "spec", "ent", "record", "ries", "je", "Entry", "reader", "si", "extra", "inc"], "count": ["ind", "buffer", "size", "max", "Count", "i", "current", "use", "load", "feed", "default", "write", "parent", "id", "limit", "cache", "check", "val", "child", "more", "code", "sum", "index", "_", "line", "file", "part", "len", "start", "en", "end", "depth", "base", "type", "log", "offset", "number", "allow", "skip", "name", "counter", "list", "add", "read", "c", "length"], "data": ["image", "error", "buffer", "bytes", "p", "size", "batch", "alpha", "block", "i", "load", "feed", "input", "cache", "info", "result", "code", "content", "a", "message", "zero", "results", "raw", "value", "str", "len", "start", "area", "buf", "number", "text", "body", "string", "d", "DATA", "reader", "empty", "read", "shift", "dat", "length"], "fos": ["efosi", "flnos", "efoses", "zos", "fOS", "fros", "flos", "fosh", "Fos", "zol", "foses", "flol", "fnos", "efosh", "froses", "zOS", "znos", "dfoses", "dfosi", "frosh", "Fol", "dfos", "dfosh", "Fnos", "flOS", "efos", "FOS", "fosi", "frosi", "fol"], "dest": ["writer", "de", "sync", "flash", "stream", "src", "output", "default", "tmp", "comb", "std", "slice", "const", "home", "Dest", "loc", "result", "target", "dc", "wh", "sum", "desc", "inner", "exit", "later", "img", "out", "cdn", "sup", "dist", "end", "die", "wb", "zip", "des", "rest", "temp", "trans", "done", "transform", "test", "south", "di", "coord", "style", "prop", "outer", "cont", "dev", "dat", "source", "txt"]}}
{"id1": "17111859", "id2": "23467091", "code1": "    private String getHash(String string) {\n        Monitor hashTime = JamonMonitorLogger.getTimeMonitor(Cache.class, \"HashTime\").start();\n        MessageDigest md5 = null;\n        try {\n            md5 = MessageDigest.getInstance(\"MD5\");\n        } catch (NoSuchAlgorithmException e) {\n            e.printStackTrace();\n        }\n        md5.reset();\n        md5.update(string.getBytes());\n        byte[] result = md5.digest();\n        StringBuffer hexString = new StringBuffer();\n        for (int i = 0; i < result.length; i++) {\n            hexString.append(Integer.toHexString(0xFF & result[i]));\n        }\n        String str = hexString.toString();\n        hashTime.stop();\n        return str;\n    }\n", "code2": "    public void listen() {\n        String url = \"http://\" + host + \":\" + LISTEN_PORT;\n        HttpURLConnection conn = null;\n        while (true) {\n            try {\n                conn = (HttpURLConnection) (new URL(url).openConnection());\n            } catch (Exception e) {\n                error(\"Could not connect to \" + url + \".\", e);\n                return;\n            }\n            BufferedInputStream in = null;\n            try {\n                conn.connect();\n                in = new BufferedInputStream(conn.getInputStream(), LISTEN_BUFFER);\n                event(\"Connected to stream at \" + url + \".\");\n            } catch (Exception e) {\n                error(\"Could not get stream from \" + url + \".\", e);\n                return;\n            }\n            try {\n                byte[] data = new byte[LISTEN_BUFFER];\n                for (int i = 0; i < delay; i++) {\n                    in.read(data);\n                }\n            } catch (Exception e) {\n                error(\"Stream unexpectedly quit from \" + url + \".\", e);\n                return;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"getHash": ["GetSalt", "GetHTML", " gethash", "Gethash", "buildSalt", " getSalt", " getHTML", "getHTML", "buildHTML", "gethash", "getSalt", "buildHash", "GetHash", "buildhash"], "string": ["STR", "in", "buffer", "p", "object", "s", "strings", "input", "slice", "sequence", "reference", "version", "section", "cache", "server", "address", "format", "array", "content", "time", "message", "resource", "word", "value", "file", "prefix", "this", "null", "data", "database", "number", "text", "name", "ring", "password", "hash", "duration", "uri", "source", "filename"], "hashTime": ["hashTrack", "hashCheck", "versionFunction", "hashtime", " hashCheck", "hexTime", "Hashtime", "HashTime", "HashFunction", "hexTimer", " hashFunction", "HashTrack", "HashTimer", "versionTime", "hashFunction", "hexTrack", "hashTimer", "versionTimer", " hashtime", " hashTrack", "HashCheck", "hexCheck", "versiontime", " hashTimer"], "md5": ["mdkey", "hash5", "MDkey", "mddown", " md512", "MD2", "hash53", " mdol", "dig512", "mdql", "mand5", "MD3", "MD5", "mad2", "sha5", "md6", "mand2", "mdb", "sha2", "digse", "mdse", "md2", " mddown", "md3", "digql", "mand25", " md3", "dig6", "madse", "digb", "mad5", "mad3", " mdkey", "shab", " md53", "sha6", "MDol", "maddown", "dig2", "hash2", " mdse", "digdown", "mdol", "dig5", "md512", "MD53", "dig25", "mad512", "madkey", " mdb", "mandql", "md53", "hashol", " md25", " md2", " md6", " mdql", "md25"], "result": ["expected", "r", "error", "success", "match", "buffer", "card", "entry", "default", "comment", "character", "dict", "section", "page", "json", "valid", "diff", "format", "found", "array", "response", "message", "Result", "word", "results", "digit", "work", "function", "value", "product", "part", "prefix", "feature", "data", "err", "range", "test", "number", "search", "res", "list", "hash", "uri", "current", "source", "length", "hex"], "hexString": ["rexstring", "hashstring", " hexArray", "rexString", "rexArray", " hexStr", "exstring", "hexstring", "tempArray", "hashBuffer", "hexArray", "tempBuffer", "rawArray", "rawstring", "packstring", "exArray", "rexStr", "rawString", "hashString", " hexBuffer", "rawBuffer", "exBuffer", "packStr", "hashArray", "exString", "hexBuffer", "packArray", "hexStr", "packString", " hexstring", "tempString", "tempstring"], "i": ["ai", "ip", "in", "m", "h", "p", "j", "s", "multi", "fi", "slice", "ix", "e", "phi", "id", "abi", "ci", "gi", "ui", "length", "code", "a", "zi", "li", "index", "ii", "io", "bi", "start", "x", "pi", "f", "end", "o", "xi", "ti", "k", "ri", "data", "u", "b", "v", "oi", "di", "l", "d", "si", "qi", "uri", "I", "c"], "str": ["STR", "r", "fr", "buffer", "p", "sl", "obj", "br", "entry", "key", "output", "s", "input", "e", "id", "Str", "t", "val", "code", "out", "x", "sr", "f", "url", "st", "enc", "pass", "data", "err", "char", "text", "name", "res", "tr", "uri", "source", "c", "pr", "sp"]}}
{"id1": "9275622", "id2": "9954926", "code1": "    private boolean copyFile(File _file1, File _file2) {\n        FileInputStream fis;\n        FileOutputStream fos;\n        try {\n            fis = new FileInputStream(_file1);\n            fos = new FileOutputStream(_file2);\n            FileChannel canalFuente = fis.getChannel();\n            canalFuente.transferTo(0, canalFuente.size(), fos.getChannel());\n            fis.close();\n            fos.close();\n            return true;\n        } catch (FileNotFoundException e) {\n        } catch (IOException e) {\n        }\n        return false;\n    }\n", "code2": "    private void simulate() throws Exception {\n        BufferedWriter out = null;\n        out = new BufferedWriter(new FileWriter(outFile));\n        out.write(\"#Thread\\tReputation\\tAction\\n\");\n        out.flush();\n        System.out.println(\"Simulate...\");\n        File file = new File(trsDemoSimulationfile);\n        ObtainUserReputation obtainUserReputationRequest = new ObtainUserReputation();\n        ObtainUserReputationResponse obtainUserReputationResponse;\n        RateUser rateUserRequest;\n        RateUserResponse rateUserResponse;\n        FileInputStream fis = new FileInputStream(file);\n        BufferedReader br = new BufferedReader(new InputStreamReader(fis));\n        String call = br.readLine();\n        while (call != null) {\n            rateUserRequest = generateRateUserRequest(call);\n            try {\n                rateUserResponse = trsPort.rateUser(rateUserRequest);\n                System.out.println(\"----------------R A T I N G-------------------\");\n                System.out.println(\"VBE: \" + rateUserRequest.getVbeId());\n                System.out.println(\"VO: \" + rateUserRequest.getVoId());\n                System.out.println(\"USER: \" + rateUserRequest.getUserId());\n                System.out.println(\"SERVICE: \" + rateUserRequest.getServiceId());\n                System.out.println(\"ACTION: \" + rateUserRequest.getActionId());\n                System.out.println(\"OUTCOME: \" + rateUserResponse.isOutcome());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the rateUser should be true: MESSAGE=\" + rateUserResponse.getMessage(), true, rateUserResponse.isOutcome());\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(null);\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            obtainUserReputationRequest.setIoi(null);\n            obtainUserReputationRequest.setServiceId(null);\n            obtainUserReputationRequest.setUserId(rateUserRequest.getUserId());\n            obtainUserReputationRequest.setVbeId(rateUserRequest.getVbeId());\n            obtainUserReputationRequest.setVoId(rateUserRequest.getVoId());\n            try {\n                obtainUserReputationResponse = trsPort.obtainUserReputation(obtainUserReputationRequest);\n                System.out.println(\"-----------R E P U T A T I O N----------------\");\n                System.out.println(\"VBE: \" + obtainUserReputationRequest.getVbeId());\n                System.out.println(\"VO: \" + obtainUserReputationRequest.getVoId());\n                System.out.println(\"USER: \" + obtainUserReputationRequest.getUserId());\n                System.out.println(\"SERVICE: \" + obtainUserReputationRequest.getServiceId());\n                System.out.println(\"IOI: \" + obtainUserReputationRequest.getIoi());\n                System.out.println(\"REPUTATION: \" + obtainUserReputationResponse.getReputation());\n                System.out.println(\"----------------------------------------------\");\n                assertEquals(\"The outcome field of the obtainUserReputation should be true: MESSAGE=\" + obtainUserReputationResponse.getMessage(), true, obtainUserReputationResponse.isOutcome());\n                assertEquals(0.0, obtainUserReputationResponse.getReputation(), 1.0);\n            } catch (RemoteException e) {\n                fail(e.getMessage());\n            }\n            call = br.readLine();\n        }\n        fis.close();\n        br.close();\n        out.flush();\n        out.close();\n    }\n", "label": 1, "substitutes": {"copyFile": [" copyFiles", " copyfile", " copyFolder", "transferfile", "copyFolder", "transferFolder", "copyFiles", "copyfile", "moveFolder", "transferFile", "moveFiles", "transferFiles", "moveFile", "movefile"], "_file1": ["_fileOne", "_file0", "_files1", "_zipone", "_mail2", "_resourceFirst", "_mail1", "_resourceone", "_File0", "_zipOne", "_fOne", "_File01", "_resource1", "_fone", "_fileone", "_files2", "_fileFirst", "_files01", "_mail0", "_mail01", "_files0", "_file01", "_File1", "_zipFirst", "_resourceOne", "_f1", "_fFirst", "_File2", "_zip1"], "_file2": ["jfile5", "jfile2", " _file3", "jmodelsecond", "_playTwo", "_play4", "_fileTwo", " _files4", "_play2", " _filesTwo", "_play5", "_model1", "_playsecond", "_play3", " _fileTwo", "jfilesecond", "_play1", "_files4", "jmodel2", "_filesTwo", " _files3", "_File5", "_filesecond", "jmodel5", "_files2", "_file5", "_model5", " _files2", " _file4", "_File1", "_file3", "_Filesecond", "jfile1", "_modelsecond", "_model2", "_file4", "_File2", "_files3", "jmodel1"], "fis": ["afais", "cfris", "cfos", "lfiss", "fi", " fas", "infis", " fris", "cfiss", "Fos", "infos", "infils", " fi", "afiss", "infiss", " fiss", "lfi", "cfis", "afis", "Fas", "lfis", "lfais", " fils", "fris", "Fils", " fais", "fiss", "fils", "fas", "Fris", "fais", "afi", "Fis", "cfas", "Fiss"], "fos": ["lis", "Faos", "infros", "Fros", "gus", "feus", "loes", "infus", "pos", "fOS", "foes", "gis", "fros", "fios", "flos", " foos", "pis", "infoos", "faos", "Fus", "fo", "Fos", "infos", "foses", "flis", "Foses", "los", "info", "foos", "infaos", "feoses", "floes", " fus", "goses", " faos", "feis", "Fo", " fo", " fios", "poes", "Fios", "gos", "infios", "flOS", "lOS", " fros", "pOS", "Foos", "fus", "feos", "Fis"], "canalFuente": ["canalBuente", "canalFuestro", "canalBuento", "canalCraencia", "canalBuze", "canaledBuje", "canallBuence", "canalBuencia", "canalFUestro", "canalsBuento", "canalFuencia", "canalFuze", "canallBuze", "canalFuento", "canallBuente", "canallFuencia", "canalKuente", "canaledFuente", "canaledFuje", "canalKuze", "canalCraence", "canalBuestro", "canaledBuente", "canalBuje", "canalFUze", "canaledFuze", "canalsFuento", "canalFuence", "canalsBuence", "canalFuje", "canalFUente", "canalSuente", "canalKuence", "canallFuze", "canallFuence", "canalCraente", "canalsBuente", "canalFUencia", "canallBuencia", "canalCraento", "canaledBuze", "canalFUence", "canalsFuence", "canalsFuencia", "canalBuence", "canalSuze", "canaledBuestro", "canalsBuencia", "canalsFuente", "canallFuente", "canaledFuestro", "canalKuento", "canalSuestro", "canalKuencia", "canalFUje", "canalSuje"]}}
{"id1": "1180878", "id2": "14878593", "code1": "    public static byte[] fetchURLData(String url, String proxyHost, int proxyPort) throws IOException {\n        HttpURLConnection con = null;\n        InputStream is = null;\n        try {\n            URL u = new URL(url);\n            if (url.startsWith(\"file://\")) {\n                is = new BufferedInputStream(u.openStream());\n            } else {\n                Proxy proxy;\n                if (proxyHost != null) {\n                    proxy = new Proxy(Type.HTTP, new InetSocketAddress(proxyHost, proxyPort));\n                } else {\n                    proxy = Proxy.NO_PROXY;\n                }\n                con = (HttpURLConnection) u.openConnection(proxy);\n                con.addRequestProperty(\"User-Agent\", \"Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.6 (KHTML, like Gecko) Chrome/20.0.1092.0 Safari/536.6\");\n                con.addRequestProperty(\"Accept-Charset\", \"UTF-8\");\n                con.addRequestProperty(\"Accept-Language\", \"en-US,en\");\n                con.addRequestProperty(\"Accept\", \"text/html,image/*\");\n                con.setDoInput(true);\n                con.setDoOutput(false);\n                con.connect();\n                is = new BufferedInputStream(con.getInputStream());\n            }\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            IOUtils.copy(is, baos);\n            return baos.toByteArray();\n        } finally {\n            IOUtils.closeQuietly(is);\n            if (con != null) {\n                con.disconnect();\n            }\n        }\n    }\n", "code2": "    public void hyperlinkUpdate(HyperlinkEvent e) {\n        if (e.getEventType() == EventType.ACTIVATED) {\n            try {\n                URL url = e.getURL();\n                InputStream stream = url.openStream();\n                try {\n                    StringWriter writer = new StringWriter();\n                    IOUtils.copy(stream, writer, \"UTF-8\");\n                    JEditorPane editor = new JEditorPane(\"text/plain\", writer.toString());\n                    editor.setEditable(false);\n                    editor.setBackground(Color.WHITE);\n                    editor.setCaretPosition(0);\n                    editor.setPreferredSize(new Dimension(600, 400));\n                    String name = url.toString();\n                    name = name.substring(name.lastIndexOf('/') + 1);\n                    JDialog dialog = new JDialog(this, \"\u5185\u5bb9\u89e3\u6790: \" + name);\n                    dialog.add(new JScrollPane(editor));\n                    dialog.pack();\n                    dialog.setVisible(true);\n                } finally {\n                    stream.close();\n                }\n            } catch (IOException exception) {\n                exception.printStackTrace();\n            }\n        }\n    }\n", "label": 1, "substitutes": {"fetchURLData": ["fetchUrlData", "frieveURLdata", "fetchHTTPData", "fetchUrlDATA", "fetchJSONData", "frieveUrldata", "fetchUrldata", "fetchURLdata", "fetchHTTPDATA", "fetchJSONDATA", "frieveUrlData", "fetchHTTPdata", "frieveUrlDATA", "fetchJSONdata", "frieveURLData", "fetchURLDATA", "frieveURLDATA"], "url": ["image", "sl", "html", "src", "host", "view", "el", "feed", "fl", "user", "ls", "page", "server", "address", "loc", "connection", "http", "location", "URL", "path", "resource", "xml", "ssl", "file", "f", "Url", "api", "base", "data", "download", "gl", "text", "name", "l", "string", "href", "ur", "uri", "source", "filename", "www", "username"], "proxyHost": ["ProxyHost", "baseDomain", "cacheHost", "proxyDomain", "cacheAddress", "proxyPath", "ProxyPort", " proxyhost", " proxyServer", "remoteHost", "ProxyDomain", "baseAddress", "ProxyPath", "proxyHead", "serverPath", "baseHost", "serverHost", "proxyAddress", "baseHead", "cachehost", "cachePort", "proxyhost", "serverServer", "serverAddress", "remoteAddress", "ProxyServer", " proxyAddress", "remoteHead", "Proxyhost", " proxyPath", "ProxyHead", "remoteDomain", "proxyServer", "ProxyAddress"], "proxyPort": ["ProxyHost", "cacheHost", "cacheAddress", "cacheport", "ProxyPort", "httpAddress", " proxyServer", "httpHost", "httpServer", "Proxyport", "proxyAddress", " proxyport", "httpPort", "cachePort", "proxyport", "ProxyServer", " proxyAddress", "proxyServer", "ProxyAddress"], "con": ["an", "cas", "sync", "go", "rc", "ci", "cone", "conn", "open", "bc", "ver", "http", "change", "fun", "pub", "en", "x", "conv", "re", "ocon", "win", "connect", "ca", "pin", "cp", "cc", "cn", "common", "cons", "cache", "ran", "cm", "conf", "fc", "xc", "part", "Con", "close", "can", "pc", "sub", "pen", "ac", "inc", "ec", "ai", "fa", "pre", "ls", "on", "CON", "cf", "canon", "run", "per", "cur", "out", "min", "ch", "cl", "fac", "un", "mc", "remote", "act", "c", "fan", "n", "socket", "syn", "fl", "cr", "com", "connection", "uc", "rec", "ctrl", "f", "don", "exec", "login", "co", "gen", "func"], "is": ["lis", "get", "os", "ai", "in", "mis", "Is", "us", "p", "bis", "ie", "oss", "iso", "isl", "isa", "isin", "i", "cs", "s", "bs", "its", "was", "ib", "il", "id", "ci", "es", "isi", "ris", "isu", "conn", "IS", "info", "or", "state", "iss", "cos", "ios", "isc", "ori", "has", "ir", "out", "iris", "ais", "abs", "fs", "api", "serv", "ri", "does", "are", "can", "im", "it", "ops", "vs", "ar", "ics", "as", "js", "ps", "si", "cms", "ws", "act", "sp"], "u": ["hu", "os", "su", "client", "m", "h", "us", "p", "ul", "yu", "tu", "i", "q", "ue", "uv", "ou", "user", "nu", "U", "ut", "conn", "ui", "cu", "ru", "http", "io", "iu", "uc", "file", "f", "uci", "o", "api", "b", "v", "l", "un", "fu", "lu", "ur", "uri", "up", "c"], "proxy": ["ip", "timeout", "client", "xy", "clone", "p", "pin", "pa", "host", "phone", "socket", " Proxy", "copy", "roxy", "port", "server", "cache", "address", "plus", "fe", "connection", "http", "resource", "cop", "pool", "Proxy", "ssl", "XY", "x", "prot", "f", "lib", "api", "wrapper", "zip", "type", "pe", "shadow", "force", "pc", "bean", "l", "pse", "remote", "web", "uri", "c", "create", "config", " proxies"], "baos": ["baOS", "baas", "haOS", "baros", "boOS", "caOS", "BAos", "boas", "haos", "BAis", "aos", "BAOS", "paos", "caas", "abOs", "BAOs", "BaOs", "hao", "paOS", "balos", "abos", "bao", "Baos", "aas", "abis", "pais", "bais", "hais", "baOs", "bolos", "aOS", "abros", "BAros", "boos", "BAo", "alos", "pao", "caos", "calos", "Baros", "Bais"]}}
{"id1": "21326424", "id2": "596993", "code1": "    public APIResponse delete(String id) throws Exception {\n        APIResponse response = new APIResponse();\n        connection = (HttpURLConnection) new URL(url + \"/api/variable/delete/\" + id).openConnection();\n        connection.setRequestMethod(\"DELETE\");\n        connection.setConnectTimeout(TIMEOUT);\n        connection.connect();\n        if (connection.getResponseCode() == HttpURLConnection.HTTP_OK) {\n            response.setDone(true);\n            response.setMessage(\"Variable Deleted!\");\n        } else {\n            response.setDone(false);\n            response.setMessage(\"Delete Variable Error Code: Http (\" + connection.getResponseCode() + \")\");\n        }\n        connection.disconnect();\n        return response;\n    }\n", "code2": "    private String makeLoginRequest(URL url) throws IOException {\n        HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection();\n        urlConnection.setRequestMethod(\"POST\");\n        urlConnection.setDoInput(true);\n        urlConnection.setDoOutput(true);\n        urlConnection.setUseCaches(false);\n        urlConnection.setRequestProperty(\"Content-Type\", \"application/x-www-form-urlencoded\");\n        StringBuilder content = new StringBuilder();\n        content.append(\"Email=\").append(URLEncoder.encode(EMAIL, \"UTF-8\"));\n        content.append(\"&Passwd=\").append(URLEncoder.encode(PASSWORD, \"UTF-8\"));\n        content.append(\"&service=\").append(URLEncoder.encode(SERVICE, \"UTF-8\"));\n        content.append(\"&source=\").append(URLEncoder.encode(\"Google Base data API\", \"UTF-8\"));\n        OutputStream outputStream = urlConnection.getOutputStream();\n        outputStream.write(content.toString().getBytes(\"UTF-8\"));\n        outputStream.close();\n        int responseCode = urlConnection.getResponseCode();\n        InputStream inputStream;\n        if (responseCode == HttpURLConnection.HTTP_OK) {\n            inputStream = urlConnection.getInputStream();\n        } else {\n            inputStream = urlConnection.getErrorStream();\n        }\n        return toString(inputStream);\n    }\n", "label": 0, "substitutes": {"delete": ["request", "get", "process", "de", "del", "save", "release", "reply", "load", "Delete", "complete", "replace", "info", "resource", "edit", "post", "set", "update", "clear", "execute", "drop", "remove", "lete", "stop", "list", "destroy", "create"], "id": ["request", "error", "ip", "in", "query", "i", "key", "oid", "version", "Id", "ID", "address", "info", "code", "ident", "path", "resource", "str", "end", "uid", "url", "sid", "nil", "model", "data", "type", "method", "ids", "name", "string", "variable", "and", "aid", "uri", "pid", "kid"], "response": ["request", "next", "image", "error", "success", "client", "service", "offer", "tree", "i", "output", "reply", "object", "relation", "proxy", "view", "user", "version", "instance", "reference", "route", "page", "handler", "server", "json", "example", "result", "http", "array", "resource", "message", "index", "Response", "description", "function", "value", "resp", "f", "ception", "api", "onse", "model", "data", "v", "collection", "status", "application", "site", "body", "respond", "uri"], "connection": ["request", "image", "position", "error", "timeout", "client", "connect", "writer", "union", "creator", "query", "entry", "relation", "socket", "proxy", "context", "character", "bug", "version", "section", "directory", "handler", "server", "cache", "conn", "or", "http", "inner", "resource", "index", "io", "translation", "manager", "function", "description", "connected", "url", "channel", "session", "builder", "log", "database", "collection", "application", "number", "document", "volume", "driver", "ion", "communication", "network", "Connection", "uri", "event", "config", "c", "condition"]}}
{"id1": "13086936", "id2": "14877116", "code1": "            public void run() {\n                waiting(200);\n                txtinfo.post(new Runnable() {\n\n                    public void run() {\n                        txtinfo.setText(\"Searching\");\n                    }\n                });\n                try {\n                    URL url = new URL(urlAddress);\n                    SAXParserFactory spf = SAXParserFactory.newInstance();\n                    SAXParser sp = spf.newSAXParser();\n                    XMLReader xr = sp.getXMLReader();\n                    XMLHandlerReviews myXMLHandler = new XMLHandlerReviews();\n                    xr.setContentHandler(myXMLHandler);\n                    xr.parse(new InputSource(url.openStream()));\n                    if (statuscode != 200 && statuscode != 206) {\n                        throw new Exception();\n                    }\n                    nReviewsOnPage = myXMLHandler.nItems;\n                    statuscode = myXMLHandler.statuscode;\n                    if (nReviewsOnPage > 0) {\n                        authors = new String[nReviewsOnPage];\n                        reviews = new String[nReviewsOnPage];\n                        ratings = new String[nReviewsOnPage];\n                        titles = new String[nReviewsOnPage];\n                        listtext = new String[nReviewsOnPage];\n                        for (int i = 0; i < nReviewsOnPage; i++) {\n                            reviews[i] = myXMLHandler.reviews[i];\n                            authors[i] = myXMLHandler.authors[i];\n                            titles[i] = myXMLHandler.titles[i];\n                            ratings[i] = myXMLHandler.ratings[i];\n                            if (authors[i] == null || authors[i] == \"\") {\n                                authors[i] = \"Anonymous\";\n                            }\n                            if (ratings[i] == null || ratings[i] == \"\") {\n                                listtext[i] = titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            } else {\n                                listtext[i] = \"Score: \" + ratings[i] + \" - \" + titles[i] + \" - \" + reviews[i] + \" - \" + authors[i];\n                            }\n                        }\n                        nTotalReviews = myXMLHandler.nTotalItems;\n                        final int fnmin = iFirstReviewOnPage;\n                        final int fnmax = iFirstReviewOnPage + nReviewsOnPage - 1;\n                        final int fntotalitems = nTotalReviews;\n                        if (nTotalReviews > fnmax) {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(0);\n                                }\n                            });\n                        } else {\n                            nextButton.post(new Runnable() {\n\n                                public void run() {\n                                    nextButton.setVisibility(8);\n                                }\n                            });\n                        }\n                        if (iFirstReviewOnPage > 1) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(0);\n                                }\n                            });\n                        } else if (nTotalReviews > fnmax) {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(8);\n                                }\n                            });\n                        } else {\n                            previousButton.post(new Runnable() {\n\n                                public void run() {\n                                    previousButton.setVisibility(4);\n                                }\n                            });\n                        }\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                if (title != null && title != \"\") {\n                                    txtinfo.setText(title + \"\\n\" + getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                } else {\n                                    txtinfo.setText(getString(R.string.showing) + \" \" + fnmin + \" \" + getString(R.string.through) + \" \" + fnmax + \" \" + getString(R.string.of) + \" \" + fntotalitems);\n                                }\n                            }\n                        });\n                        handlerSetList.sendEmptyMessage(0);\n                    } else {\n                        txtinfo.post(new Runnable() {\n\n                            public void run() {\n                                txtinfo.setText(title + getString(R.string.no_reviews_for_this_album));\n                            }\n                        });\n                    }\n                } catch (Exception e) {\n                    final Exception ef = e;\n                    txtinfo.post(new Runnable() {\n\n                        public void run() {\n                            txtinfo.setText(R.string.search_failed);\n                        }\n                    });\n                }\n                dialog.dismiss();\n                handlerDoneLoading.sendEmptyMessage(0);\n            }\n", "code2": "    public void cpFile(File source, File target, boolean replace, int bufferSize) throws IOException {\n        if (!source.exists()) throw new IOException(\"source file not exists\");\n        if (!source.isFile()) throw new IOException(\"source file not exists(is a directory)\");\n        InputStream src = new FileInputStream(source);\n        File tarn = target;\n        if (target.isDirectory() || !(!(target.exists()) || replace)) {\n            String tardir = target.isDirectory() ? target.getPath() : target.getParent();\n            tarn = new File(tardir + File.separator + source.getName());\n            int n = 1;\n            while (!(!tarn.exists() || replace)) {\n                tarn = new File(tardir + File.separator + String.valueOf(n) + \" copy of \" + source.getName());\n                n++;\n            }\n        }\n        if (source.getPath().equals(tarn.getPath()) && replace) return;\n        OutputStream tar = new FileOutputStream(tarn);\n        byte[] bytes = new byte[bufferSize];\n        int readn = -1;\n        while ((readn = src.read(bytes)) > 0) {\n            tar.write(bytes, 0, readn);\n        }\n        tar.flush();\n        tar.close();\n        src.close();\n    }\n", "label": 0, "substitutes": {"run": ["job", "process", "su", "in", "worker", "output", "man", "use", "apply", "submit", "graph", "container", "Run", "work", "thread", "build", "fun", "start", "pass", "exec", "unit", "base", "login", "execute", "runner", "running", "call", "name", "background", "un", "runs", "loop", "func"], "url": ["r", "image", "buffer", "service", "sl", "left", "html", "stream", "src", "user", "page", "server", "address", "open", "connection", "http", "location", "URL", "path", "resource", "io", "ssl", "file", "sr", "f", "Url", "this", "api", "base", "channel", "b", "org", "ll", "l", "string", "uri", "source", "www"], "spf": ["ppfx", "skfs", " spfen", "skf", "ppf", "Spfs", "scF", "Spf", "spfx", " spfx", "spfd", "skfen", "ppfs", " spfs", "scf", "pfs", "Spfd", "spfs", "scfs", "ppfen", "pfd", "spF", "pF", "pf", "skfx", "scfd", "SpF", "spfen"], "sp": ["sc", "sw", "p", "sl", "service", "g", "html", "pp", "par", "pg", "scope", "parse", "sa", "SP", "Sp", "sb", "py", "server", "sf", "sh", "asp", "esp", "http", "lp", "se", "xml", "ssl", "space", "sr", "f", "st", "sm", "serv", "er", "wp", "so", "si", "parser", "steam", "sv", "source", "pr"], "xr": ["txhr", "byR", "byrr", "xhr", "xer", " xrs", "swrb", " xhr", "Xr", "txer", "rxrr", "txR", "xrb", "txr", "rxr", "xrr", " xrb", " xrr", " xer", "swrs", "Xrs", "swhr", "byrb", "byr", "Xer", "rxR", "txrs", "swr", "txrb", "rxrb", "xrs", "XR", " xR", "xR"], "myXMLHandler": ["myXmlHandler", "myFXMLManager", "myYSLConfig", "myXSLParser", "myXSLHandler", "myXELEvent", "myYSLHandler", "myYSLParser", "myXPCContext", "myWorkMLHandler", "myYSLContext", "myXCLService", "myFXMLReader", "myXSLEvent", "myFXMLHandler", "myXSLManager", "myTXmlEvent", "myTXMLInfo", "myWorkmlHandler", "myXSLPath", "myXELParser", "myXmlReader", "myYMLContext", "myXMLEvent", "myXLSLParser", "myXmlEvent", "myFXmlParser", "myXMLManager", "myYMLHandler", "myXMLConfig", "myTXELEvent", "myXMLPath", "myXCLConfig", "myFXmlPath", "myXRLPath", "myWorkmlParser", "myWorkmlReader", "myXPCReader", "myXLSParser", "myXCLPath", "myXSLConfig", "myTXELHandler", "myXmlManager", "myXLSHandler", "myXmlConfig", "myXMLService", "myXCLManager", "myXRLContext", "myXLSLPath", "myWorkMLReader", "myXLSLHandler", "myXRLHandler", "myXMLReader", "myYMLParser", "myYMLConfig", "myXELHandler", "myTXMLEvent", "myXMLInfo", "myYMLService", "myTXmlHandler", "myXRLReader", "myTXELReader", "myXLMLHandler", "myXCLReader", "myXCLHandler", "myXLMLReader", "myXLSReader", "myXCLParser", "myFXmlManager", "myXRLParser", "myXSLReader", "myXmlContext", "myXPCService", "myXSLInfo", "myXMLParser", "myXLSLReader", "myXPCHandler", "myXLMLParser", "myFXMLPath", "myXSLService", "myXmlParser", "myYSLReader", "myTXMLParser", "myTXMLReader", "myXMLContext", "myTXMLHandler", "myXELPath", "myXSLContext", "myTXmlInfo", "myXmlInfo", "myWorkmlPath", "myFXmlReader", "myYMLReader", "myXmlPath", "myWorkMLParser", "myFXmlHandler", "myXRLEvent", "myWorkMLPath", "myXRLInfo", "myXELReader", "myXLSEvent", "myTXmlReader", "myXCLContext", "myXELManager", "myXLMLPath", "myTXELParser", "myYSLService", "myFXMLParser"], "nReviewsOnPage": ["nReviewsOffPages", "nReviewsThisSection", "nReviewingsOnRequest", "nReviewingsOnLine", "nReviewsThisLine", "nReviewsOnPages", "nReviewesPerLine", "nReviewsonFile", "nReviewsPerRequest", "nReviewsForFile", "nReviewmentsOnPage", "nReviewesOnLine", "nReviewsThisFile", "nReviewsPerpage", "nReviewsOffpage", "nReviewsInLine", "nReviewsOnSection", "nReviewsOnLine", "nReviewsOnRequest", "nReviewmentsPerLine", "nReviewesOnPages", "nReviewingsONLine", "nReviewsDuringLine", "nReviewsOnlineRequest", "nReviewsPerDisk", "nReviewesOnpage", "nReviewsONRequest", "nReviewsThisPage", "nReviewingsPerPage", "nReviewmentsPerPage", "nReviewsCurrentpage", "nReviewsCurrentFile", "nReviewmentsOnDisk", "nReviewsOnDisk", "nReviewingsPerFile", "nReviewsOffLine", "nReviewsDuringpage", "nReviewsONpage", "nReviewsPerLine", "nReviewesCurrentLine", "nReviewsOnlinepage", "nReviewsInFile", "nReviewsForLine", "nReviewsCurrentPage", "nReviewsForpage", "nReviewsOnlineLine", "nReviewmentsOnpage", "nReviewsInSection", "nReviewingsONRequest", "nReviewsOnlinePage", "nReviewsPerPage", "nReviewsONPage", "nReviewingsONPage", "nReviewsPerPages", "nReviewingsOnSection", "nReviewingsONpage", "nReviewsInDisk", "nReviewingsPerLine", "nReviewsOnpage", "nReviewsonpage", "nReviewsONLine", "nReviewesOnPage", "nReviewmentsPerpage", "nReviewingsOnpage", "nReviewsonPages", "nReviewesCurrentPage", "nReviewesPerPage", "nReviewsonPage", "nReviewesOnFile", "nReviewingsPerSection", "nReviewingsOnPage", "nReviewsDuringDisk", "nReviewingsOnFile", "nReviewesCurrentpage", "nReviewsOffPage", "nReviewmentsOnLine", "nReviewesPerpage", "nReviewesCurrentFile", "nReviewmentsPerDisk", "nReviewsForPage", "nReviewsDuringPage", "nReviewsONPages", "nReviewsonLine", "nReviewingsPerpage", "nReviewsPerSection", "nReviewsInPage", "nReviewsInpage", "nReviewsCurrentLine", "nReviewsOnFile", "nReviewesPerPages", "nReviewsPerFile"], "statuscode": ["statstate", "statuscase", " statusCode", "zipcode", "statcode", "levelcase", " statusstate", " statuscase", "levelcodes", "Statuscount", "msgcodes", "msgstate", "zipcodes", "resultcode", "levelstate", "Statuscode", " statuscodes", "statusCode", "zipCode", "zipstatus", "levelcode", "statuscount", "resultstate", "postCode", "resultcount", "statusmessage", "poststatus", "statcodes", "statcase", "statuscodes", "resultmessage", "statusstatus", " statusmessage", "resultcodes", "Statusstate", "msgmessage", "statusstate", "postcode", "msgcode", "Statuscodes", "msgcount", "postcodes", " statusstatus"], "authors": ["letters", "testers", "yrs", "words", "itles", "styles", "people", "author", "verbs", "casters", "apers", "sections", "tags", "strings", "headers", "archives", "runners", "comments", "ors", "rators", "workers", "projects", "abilities", "humans", "features", "reads", "quarters", "blogs", "marks", "attacks", "atts", "builders", "writers", "owners", "docs", "reports", "services", "posts", "images", "ants", "resources", "members", "apps", "abet", "relations", "pages", "articles", "agents", "papers", "rights", "blocks", "weights", "users", "artifacts", "errors", "criptions", "ins", "parents", "names", "apters", "settings", "versions", "includes", "books", "thumbnails", "rules", "anners", "journal", "archs", "masters", "ppers", "plugins"], "reviews": ["reviewings", "Reviews", "followings", "Reviewments", "reviewions", "authorments", "reviewing", "authoring", "Reviewers", "authorers", " reviewp", "signations", "signs", " reviewings", "Reviewions", "downloadings", "signings", "feedings", "sellings", "Reviewing", "downloading", "downloadments", "downloads", "authorp", "Reviewings", "following", "signins", "Reviewp", "Reviewes", "sells", "reviewins", "feedins", "sellers", "reviewers", "authorations", "reviewp", "feeds", "followes", "feedations", "reviewments", "follows", "reviewations", " reviewments", "authores", "authorions", "sellions", "authorins", "reviewes", "authorings"], "ratings": ["prensions", "variations", "latitles", "tions", "pititles", " ratickets", "variions", "statickets", "raties", " ratensions", "pritles", "ratios", "statitles", "ties", "ritings", "trages", "statifications", "pitations", "trios", "roundings", "roundations", "rounditles", "authorages", "statios", "ratickets", "ratensions", "tacters", "latings", "prings", "authorifications", " ratning", "latations", "statings", "tings", "variitles", " ratifications", "authories", " ratacters", "ratations", "authorning", "tations", "variings", "rities", "ratifications", "ritions", "tins", "pitings", "statations", "statning", " ratios", "latensions", "statensions", "practers", "pitions", "ritins", " ratitles", "ratins", "ratitles", "ratages", "trickets", " ratages", "roundensions", "ratacters", "trings", "authorions", "ratning", "tensions", "statages", "authorins", "rations", "authorings"], "titles": ["Tapers", " tractions", "ttickets", " ticks", "thips", "Tacters", " tributes", " tames", "ships", "ticks", "Tings", "tickets", "ttls", "tractions", "lributes", "tributes", "Tales", " thips", "tacters", "untickets", "tasks", "lhips", "tings", "untls", "ratames", "lasks", "lractions", "litles", " tickets", " tls", " tings", "ttales", " tapes", "ttractions", " tales", "Ticks", "Titles", "sapes", "ttributes", "untitles", "ttitles", " tasks", " tacters", "sasks", "tapes", "ratapers", "tticks", "ratitles", "lickets", "lapes", "sitles", "tapers", "ratacters", "tls", "untings", "tames", "Tames", "tales", "ttings", " tapers"], "listtext": ["flatText", " listTEXT", " listtxt", "teststr", " listobject", "listtxt", "summaryTEXT", "listTEXT", "summaryname", "listbody", " listbody", "summarytxt", "listformat", "flattext", "LISTtext", "summaryformat", "LISTname", "testbody", " listname", "testtext", " listText", "detailobject", " listformat", "liststr", "summaryText", "listname", "testobject", "detailbody", "detailstr", "detailtext", "summarytext", "flattxt", "flatTEXT", "listobject", "LISTformat", " liststr", "listText", "LISTTEXT"], "i": ["ai", "ip", "uli", "m", "ki", "j", "p", "ic", "ie", "g", "eni", "is", "s", "init", "multi", "fi", "ix", "e", "phi", "abi", "lc", "ci", "gi", "cli", "id", "isi", "ui", "info", "li", "index", "ii", "io", "ei", "ori", "iu", "vi", "z", "ini", "sup", "bi", "uni", "x", "pi", "f", "o", "xi", "api", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "it", "di", "hi", "l", "si", "yi", "chi", "qi", "uri", "iv", "current", "I"], "nTotalReviews": ["nAllreviewes", "nTotalreviewEvents", "nTotalDownloadEvents", "nTotalReviewed", "nAllreviewed", "nAllReviewed", "nAllReviews", "nTotalreviewed", "nAllreviews", "nTotalGraphEvents", "nTotalDownloades", "nAllReviewes", "nAllReviewEvents", "nTotalDownloaded", "nTotalGraphs", "nTotalDownloads", "nTotalReviewes", "nTotalreviewes", "nTotalGraphes", "nTotalreviews", "nAllreviewEvents", "nTotalReviewEvents", "nTotalGraphed"], "fnmin": [" fall", " fstart", " nmin", " fmin", "fnall", " fnstart", " fndiff", " fnall", " nall", " nstart", "fndiff", " ndiff", "fnstart", " fdiff"]}}
{"id1": "16388708", "id2": "18613870", "code1": "    public static boolean decodeFileToFile(String infile, String outfile) {\n        boolean success = false;\n        java.io.InputStream in = null;\n        java.io.OutputStream out = null;\n        try {\n            in = new Base64.InputStream(new java.io.BufferedInputStream(new java.io.FileInputStream(infile)), Base64.DECODE);\n            out = new java.io.BufferedOutputStream(new java.io.FileOutputStream(outfile));\n            byte[] buffer = new byte[65536];\n            int read = -1;\n            while ((read = in.read(buffer)) >= 0) {\n                out.write(buffer, 0, read);\n            }\n            success = true;\n        } catch (java.io.IOException exc) {\n            exc.printStackTrace();\n        } finally {\n            try {\n                in.close();\n            } catch (Exception exc) {\n            }\n            try {\n                out.close();\n            } catch (Exception exc) {\n            }\n        }\n        return success;\n    }\n", "code2": "    private static void copyFile(File src, File dst) throws IOException {\n        FileChannel in = new FileInputStream(src).getChannel();\n        FileChannel out = new FileOutputStream(dst).getChannel();\n        in.transferTo(0, in.size(), out);\n        in.close();\n        out.close();\n    }\n", "label": 1, "substitutes": {"decodeFileToFile": ["decodeFileToString", "decodeString2String", "decodeString2Files", "decodeFile2Files", "decodeFileFromStream", "decodeFileToStream", "decodeString2Stream", "decodeFile2String", "decodeStringToStream", "decodeFileToFiles", "decodeFile2File", "decodeStringToFiles", "decodeStringToFile", "decodeFileFromString", "decodeFileFromFile", "decodeStringToString", "decodeFileAsString", "decodeFileAsFiles", "decodeFileFromFiles", "decodeFile2Stream", "decodeFileAsStream", "decodeFileAsFile", "decodeString2File"], "infile": ["infilename", "Infile", "Inbase", " instream", "inputfiles", "outfp", "inputfilename", " infp", "outfiles", " inbase", "instream", "outfilename", "infp", "Instream", "infiles", " infiles", "minFile", "inputfile", "minstream", "inbase", " inFile", "inFile", "inputfp", "minfile", " infilename", "InFile", "minbase"], "outfile": ["infilename", " outfilename", "outputFile", "inputdatabase", "outputdatabase", "outputfilename", "outputfolder", "outfolder", "outputpath", "outfilename", " outFile", " outdatabase", "outpath", "infolder", "inputpath", "inputfile", " outpath", "outdatabase", "inputFile", " outfolder", "outFile", "inFile", "outputfile"], "in": ["r", "m", "pin", "ic", "inn", "gin", "isin", "i", "is", "socket", "s", "init", "cin", "input", "thin", "id", "sin", "din", "conn", "inas", "lin", "a", "inner", "nin", "ini", "into", "rin", "con", "inside", "min", "pass", "login", "data", "err", "b", "ins", "bin", "In", "reader", "IN", "as", "again", "re", "win", "source", "ac", "inc"], "out": ["Out", "job", "error", "timeout", "client", "writer", "image", "sync", "obj", "off", "one", "up", "output", "socket", "ou", "write", "parent", "copy", "ex", "cache", "home", "conn", "to", "or", "inner", "io", "exit", "line", "file", "work", "post", "o", "no", "exec", "base", "channel", "session", "lib", "err", "pass", "log", "net", "co", "name", "bin", "In", "again", "point", "outs", "outer", "OUT", "inc"], "buffer": ["bytes", "size", "batch", "queue", "transfer", "feed", "slice", "input", "reference", "write", "bb", "limit", "Buffer", "cache", "server", "address", "source", "result", "padding", "buff", "raw", "value", "count", "uffer", "iter", "url", "buf", "binary", "channel", "base", "null", "data", "type", "b", "border", "offset", "split", "wave", "bin", "reader", "seed", "flush", "layer", "length"], "read": ["ind", "next", "ip", "get", " Read", "connect", "size", "tell", "sync", "n", "Read", "i", "current", "use", "feed", "load", "slice", "ad", "write", "parse", "copy", " write", "id", "limit", "reads", "run", "check", "seek", " copy", "READ", "io", "se", "sleep", "_", "work", "send", "count", "reading", "fill", "find", "lex", "len", "start", "x", "iter", "f", "end", "pass", "exec", "wait", "allow", "ride", "r", "raw", "reader", " count", "add", "play", " skip", "length", "select", "inc"], "success": [" successful", "rolling", "error", "fast", "flash", "cess", "default", "comment", "construct", "valid", "fail", "complete", "open", "good", "result", "Success", "positive", "content", "failed", "response", "message", "successful", "path", "results", "value", "successfully", "winner", "growth", "ccess", "warning", "null", "pass", "primary", "model", "data", " succ", "better", "rolled", "xx", "done", "status", "ceed", "continue", "method", "danger", "true", " succeed", "again", "follow", "roll", "first", " Success", "func", "right", "initial"]}}
{"id1": "12349563", "id2": "19910627", "code1": "    public boolean resourceExists(String location) {\n        if ((location == null) || (location.length() == 0)) {\n            return false;\n        }\n        try {\n            URL url = buildURL(location);\n            URLConnection cxn = url.openConnection();\n            InputStream is = null;\n            try {\n                byte[] byteBuffer = new byte[2048];\n                is = cxn.getInputStream();\n                while (is.read(byteBuffer, 0, 2048) >= 0) ;\n                return true;\n            } finally {\n                if (is != null) {\n                    is.close();\n                }\n            }\n        } catch (IOException ex) {\n            return false;\n        }\n    }\n", "code2": "    public String getData(DefaultHttpClient httpclient) {\n        try {\n            HttpGet get = new HttpGet(\"http://3dforandroid.appspot.com/api/v1/note\");\n            get.setHeader(\"Content-Type\", \"application/json\");\n            get.setHeader(\"Accept\", \"*/*\");\n            HttpResponse response = httpclient.execute(get);\n            HttpEntity entity = response.getEntity();\n            InputStream instream = entity.getContent();\n            responseMessage = read(instream);\n            if (instream != null) instream.close();\n        } catch (ClientProtocolException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return responseMessage;\n    }\n", "label": 0, "substitutes": {"resourceExists": [" resourceExits", " fileexistence", " resourceexits", " fileExits", " resourceCompists", " resourceexes", " fileExists", " fileExes", " resourceexistence", " resourceAbsits", " fileexes", " resourceExistence", " resourceAbses", " resourceAbsistence", " fileExistence", " resourceexists", " fileexists", " resourceCompits", " resourceCompistence", " resourceCompes", " fileexits", " resourceExes", " resourceAbsists"], "location": ["position", "image", "localhost", "shape", "host", "object", "layout", "layer", "reference", "route", "directory", "server", "address", "home", "loc", "info", "target", "connection", "pointer", "content", "path", "resource", "response", "region", "message", "operation", "description", "file", "Location", "area", "base", "data", "type", "LOC", "local", "collection", "provided", "language", "name", "node", "remote", "href", "string", "point", "folder", "uri", "source", "filename", "length"], "url": ["r", "blog", "image", "sl", "obj", "i", "host", "impl", "user", "fl", "www", "page", "server", "address", "open", "loc", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "build", "f", "Url", "lib", "api", "base", "zip", "b", "ll", "l", "string", "web", "uri", "source", "config", "c"], "cxn": ["cdsg", "cexns", "crexp", " cxcon", "Cxns", "Cxn", "cxne", " crexn", "crexg", "cxns", "cxp", "Cuxne", " cxp", "cexg", "Cxp", "cexn", "crexn", "cuxn", "cxxn", "Cxne", "cdsn", "cxxns", "cexcon", "cexp", "Cuxns", "cexne", "cdsp", "Cuxn", "cxcon", " crexp", " crexcon", "cxxne", "cxg", "cuxp", " crexg", " cxg", "cdscon", "cuxns", "cxxp", "cuxne", "Cuxp", "crexcon"], "is": ["lis", "next", "get", "os", "in", "ip", "ai", "Is", "us", "bis", "iso", "isl", "stream", "isa", "src", "i", "oss", "bs", "s", "app", "init", "ois", "was", "its", "id", "ens", "es", "isi", "ris", "IS", "info", "ui", "or", "iss", "http", "ios", "isc", "ori", "nis", "has", "cos", "ob", "ir", "out", "iris", "ais", "abs", "x", "close", "fs", "api", "does", "im", "it", "ar", "internet", "as", "js", "ms", "web", "cms", "uri"], "byteBuffer": ["ByteArray", "bitBuffer", "byteLength", " byteBB", "bitBuff", "bitBB", "ByteBB", "byteArray", "byteBB", " byteArray", "bitLength", " byteLength", "ByteLength", "ByteBuffer", "ByteBuff", " byteBuff", "byteBuff", "bitArray"]}}
{"id1": "5998352", "id2": "539195", "code1": "    @Test\n    public void testStandardTee() throws Exception {\n        final String reference = \"test\";\n        final Reader source = new StringReader(reference);\n        final StringWriter destination1 = new StringWriter();\n        final StringWriter destination2 = new StringWriter();\n        final TeeWriter tee = new TeeWriter(destination1, destination2);\n        org.apache.commons.io.IOUtils.copy(source, tee);\n        tee.close();\n        assertEquals(\"the two string are equals\", reference, destination1.toString());\n        assertEquals(\"the two string are equals\", reference, destination2.toString());\n        assertEquals(\"byte count\", reference.length(), tee.getSize());\n    }\n", "code2": "    static void copy(String src, String dest) throws IOException {\n        File ifp = new File(src);\n        File ofp = new File(dest);\n        if (ifp.exists() == false) {\n            throw new IOException(\"file '\" + src + \"' does not exist\");\n        }\n        FileInputStream fis = new FileInputStream(ifp);\n        FileOutputStream fos = new FileOutputStream(ofp);\n        byte[] b = new byte[1024];\n        while (fis.read(b) > 0) fos.write(b);\n        fis.close();\n        fos.close();\n    }\n", "label": 1, "substitutes": {"testStandardTee": ["testStandardBee", "testStandardFees", "testStandardMae", "testStandardTees", "teststandardTee", "testStandardBees", "teststandardMeed", "testStandardFeed", "testStandardMeed", "testStandardBae", "teststandardMee", "teststandardTae", "testStandardFee", "testStandardFae", "teststandardTees", "teststandardTeed", "testStandardMee", "testStandardTae", "testStandardTeed", "testStandardMees", "teststandardMees", "teststandardMae", "testStandardBeed"], "reference": ["request", "buffer", "compatible", "hello", "output", "relation", " Reference", "order", "proxy", "sequence", "version", "copy", "attribute", "directory", "archive", "REF", "server", "address", "code", "relative", "target", "length", "pointer", "connection", "location", "format", "path", "resource", "message", "ref", "index", "report", "see", "single", "pair", "description", "References", "url", "prefix", "forward", "primary", "binary", "Reference", "type", "database", "test", "collection", "number", "document", "name", "memory", "specified", "external", "remote", "string", "variable", "ference", "uri", "rice", "distance", "re", "filename", "c"], "source": ["r", "writer", "buffer", "service", "ie", "g", "src", "i", "output", "ce", "object", "view", "proxy", "context", "input", "slice", "copy", "parent", "e", "server", "fe", "target", "result", "connection", "code", "ref", "resource", "io", "se", "Source", "iter", "url", "temp", "SOURCE", "text", "driver", "table", "reader", "string", "ource", "config"], "destination1": ["destinateOne", "destinatorOne", "destention1", "DestinateOne", "destinatorOnce", "destinator2", "destinationOnce", "Destination1", "destributionOne", "Destination0", "constinator01", "destentionOnce", "constinator1", "destarationOne", "DestinationOne", "constinationOne", "constination01", "destribution1", "constinator2", "Destension1", "destinate1", "destinationOne", "destinations01", "destinator1", "destentionOne", "destinate2", "Destinate1", "DestinateOnce", "destinateOnce", "destinate01", "destinationsOne", "destaration1", "destaration0", "DestinationOnce", "destination01", "constination2", "DestensionOne", "destination0", "destension1", "destinator01", "constinatorOne", "destinations2", "destinations1", "destribution0", "Destension0", "destensionOne", "constination1", "destension0"], "destination2": ["Destination2", "destination22", "destribution2", "descinationSecond", "destignment1", "destinatingtwo", "Destination1", "coordinate8", "descination1", "destication8", "descinations2", "destation1", "destinationsSecond", "destribution8", "destinationSecond", "destationtwo", "destinate22", "Destinate4", "coordination8", "coordinateSecond", "destribution22", "destributionSecond", "destinate1", "destation4", "desticationSecond", "destinationtwo", "destinating2", "destinating1", "descinationsSecond", "descinations02", "Destinate2", "coordinate2", "destinate8", "Destination4", "coordinate22", "destication2", "destinate2", "destignmentSecond", "Destinate1", "destation2", "destinations02", "coordination2", "destinate4", "coordination22", "destinating4", "destignment2", "Destinationtwo", "coordinationSecond", "destination8", "descination02", "destinate02", "destinatetwo", "destication22", "Destinatetwo", "descination2", "destination02", "destignment02", "destination4", "destinations2", "descinations1", "destinations1", "destinateSecond"], "tee": [" teea", "ettef", "etteee", "lef", " tec", "leec", "chee", "TEee", "teea", "tepe", " teffe", "chei", "leee", "etteae", "teec", "chef", "tei", "TEe", "ceea", "see", "teee", "eee", "TEc", "ettee", " teae", "tef", "lei", "ceee", "sef", " tepe", " tef", "chepe", "eeffe", "seae", " teec", "lepe", "cec", " teee", "eeec", "TEea", "tec", "leffe", "teffe", "lee", "eeee", "teae", "seee", "cee", " tei"]}}
{"id1": "12055086", "id2": "310182", "code1": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "code2": "    public void convert(File src, File dest) throws IOException {\n        InputStream in = new BufferedInputStream(new FileInputStream(src));\n        DcmParser p = pfact.newDcmParser(in);\n        Dataset ds = fact.newDataset();\n        p.setDcmHandler(ds.getDcmHandler());\n        try {\n            FileFormat format = p.detectFileFormat();\n            if (format != FileFormat.ACRNEMA_STREAM) {\n                System.out.println(\"\\n\" + src + \": not an ACRNEMA stream!\");\n                return;\n            }\n            p.parseDcmFile(format, Tags.PixelData);\n            if (ds.contains(Tags.StudyInstanceUID) || ds.contains(Tags.SeriesInstanceUID) || ds.contains(Tags.SOPInstanceUID) || ds.contains(Tags.SOPClassUID)) {\n                System.out.println(\"\\n\" + src + \": contains UIDs!\" + \" => probable already DICOM - do not convert\");\n                return;\n            }\n            boolean hasPixelData = p.getReadTag() == Tags.PixelData;\n            boolean inflate = hasPixelData && ds.getInt(Tags.BitsAllocated, 0) == 12;\n            int pxlen = p.getReadLength();\n            if (hasPixelData) {\n                if (inflate) {\n                    ds.putUS(Tags.BitsAllocated, 16);\n                    pxlen = pxlen * 4 / 3;\n                }\n                if (pxlen != (ds.getInt(Tags.BitsAllocated, 0) >>> 3) * ds.getInt(Tags.Rows, 0) * ds.getInt(Tags.Columns, 0) * ds.getInt(Tags.NumberOfFrames, 1) * ds.getInt(Tags.NumberOfSamples, 1)) {\n                    System.out.println(\"\\n\" + src + \": mismatch pixel data length!\" + \" => do not convert\");\n                    return;\n                }\n            }\n            ds.putUI(Tags.StudyInstanceUID, uid(studyUID));\n            ds.putUI(Tags.SeriesInstanceUID, uid(seriesUID));\n            ds.putUI(Tags.SOPInstanceUID, uid(instUID));\n            ds.putUI(Tags.SOPClassUID, classUID);\n            if (!ds.contains(Tags.NumberOfSamples)) {\n                ds.putUS(Tags.NumberOfSamples, 1);\n            }\n            if (!ds.contains(Tags.PhotometricInterpretation)) {\n                ds.putCS(Tags.PhotometricInterpretation, \"MONOCHROME2\");\n            }\n            if (fmi) {\n                ds.setFileMetaInfo(fact.newFileMetaInfo(ds, UIDs.ImplicitVRLittleEndian));\n            }\n            OutputStream out = new BufferedOutputStream(new FileOutputStream(dest));\n            try {\n            } finally {\n                ds.writeFile(out, encodeParam());\n                if (hasPixelData) {\n                    if (!skipGroupLen) {\n                        out.write(PXDATA_GROUPLEN);\n                        int grlen = pxlen + 8;\n                        out.write((byte) grlen);\n                        out.write((byte) (grlen >> 8));\n                        out.write((byte) (grlen >> 16));\n                        out.write((byte) (grlen >> 24));\n                    }\n                    out.write(PXDATA_TAG);\n                    out.write((byte) pxlen);\n                    out.write((byte) (pxlen >> 8));\n                    out.write((byte) (pxlen >> 16));\n                    out.write((byte) (pxlen >> 24));\n                }\n                if (inflate) {\n                    int b2, b3;\n                    for (; pxlen > 0; pxlen -= 3) {\n                        out.write(in.read());\n                        b2 = in.read();\n                        b3 = in.read();\n                        out.write(b2 & 0x0f);\n                        out.write(b2 >> 4 | ((b3 & 0x0f) << 4));\n                        out.write(b3 >> 4);\n                    }\n                } else {\n                    for (; pxlen > 0; --pxlen) {\n                        out.write(in.read());\n                    }\n                }\n                out.close();\n            }\n            System.out.print('.');\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"copyDeleting": [" copyDeletting", " copyDequeing", " copydeleting", " copyDeletter", " copyDeletging", " copydeleing", " copyDequeter", " copydeletter", " copyDeleteting", " copydeletting", " copyDeleing", " copyDeleteter", " copyDeleteging", " copyDequeting", " copyDequeging", " copydeleging", " copyDeleging", " copyDeleteing", " copydeletging", " copyDeleter", " copydeleter"], "source": ["image", "service", "ie", "stream", "src", "master", "i", "view", "use", "s", "input", "copy", "e", "route", "sin", "archive", "cache", "from", "target", "connection", "inner", "path", "resource", "file", "Source", "storage", "down", "iter", "f", "base", "SOURCE", "site", "reader", "remote", "ource", "config", "ources"], "dest": ["de", "src", "master", "class", "default", "comb", "tmp", "opt", "slice", "slave", "thin", "home", "Dest", "target", "result", "content", "desc", "path", "orig", "exit", "destruct", "later", "img", "file", "dist", "dir", "die", "wb", "null", "temp", "flat", "trans", "done", "bin", " destination", "folder", "destroy", "pipe"], "buf": ["pad", "bp", "buffer", "seq", "bytes", "batch", "bf", "ctx", "br", "off", "pos", "src", "queue", "cp", "rc", "ff", "tmp", "feed", "Buffer", "port", "loc", "result", "bc", "rb", "fb", "code", "buff", "img", "raw", "uc", "bag", "len", "config", "bh", "bd", "feat", "base", "vec", "data", "append", "b", "cv", "uf", "cmd", "cb", "length", "txt"], "in": ["image", "p", "pin", "n", "inn", "gin", "isin", "src", "i", "is", "stream", "socket", "init", "input", "tin", "thin", "id", "sin", "din", "conn", "plus", "inner", "io", "nin", "rin", "con", "ini", "file", "inside", "min", "f", "url", "exec", "login", "data", "b", "ins", "bin", "In", "again", "IN", "reader", "read", "win", "up", "c", "inc"], "out": ["Out", "image", "client", "writer", "buffer", "obj", "sync", "n", "i", "output", "socket", "app", "parent", "ex", "conn", "exp", "inner", "ext", "io", "pool", "img", "file", "at", "part", "down", "f", "o", "lib", "exec", "err", "b", "w", "bin", "again", "OUT", "outs", "outer", "win", "up", "inc"], "count": ["ind", "buffer", "size", "max", "n", "cond", "Count", "all", "key", "current", "use", "feed", "parent", "id", "limit", "coll", "cache", "val", "child", "length", "handle", "code", "sum", "index", "num", "weight", "path", "pool", "part", "len", "start", "f", "close", "depth", "ch", "base", "zip", "type", "b", "offset", "number", "allow", "name", "lock", "read", "c"]}}
{"id1": "3731077", "id2": "22366505", "code1": "    public static void copyFile(File from, File to) throws IOException {\n        assert (from != null);\n        assert (to != null);\n        if (!to.exists()) {\n            File parentDir = to.getParentFile();\n            if (!parentDir.exists()) parentDir.mkdirs();\n            to.createNewFile();\n        }\n        FileInputStream in = null;\n        FileOutputStream out = null;\n        try {\n            in = new FileInputStream(from);\n            try {\n                out = new FileOutputStream(to);\n                FileChannel ic = in.getChannel();\n                try {\n                    FileChannel oc = out.getChannel();\n                    try {\n                        oc.transferFrom(ic, 0, from.length());\n                    } finally {\n                        if (oc != null) {\n                            oc.close();\n                        }\n                    }\n                } finally {\n                    if (ic != null) {\n                        ic.close();\n                    }\n                }\n            } finally {\n                if (out != null) {\n                    out.close();\n                }\n            }\n        } finally {\n            if (in != null) {\n                in.close();\n            }\n        }\n    }\n", "code2": "    @Override\n    public void incluir(Igreja igreja) throws Exception {\n        Connection connection = criaConexao(false);\n        String sql = \"insert into igreja ? as idlocal, ? as possui_salao;\";\n        String sql2 = \"SELECT MAX(idlocal) FROM Local\";\n        PreparedStatement stmt = null;\n        PreparedStatement stmt2 = null;\n        ResultSet rs = null;\n        try {\n            stmt = connection.prepareStatement(sql);\n            stmt2 = connection.prepareStatement(sql2);\n            rs = stmt2.executeQuery();\n            stmt.setInt(1, rs.getInt(\"max\"));\n            stmt.setBoolean(2, igreja.getPossuiSalao());\n            int retorno = stmt.executeUpdate();\n            if (retorno == 0) {\n                connection.rollback();\n                throw new SQLException(\"Ocorreu um erro inesperado no momento de inserir dados de cliente no banco!\");\n            }\n            connection.commit();\n        } catch (SQLException e) {\n            connection.rollback();\n            throw e;\n        } finally {\n            try {\n                stmt.close();\n                stmt2.close();\n                rs.close();\n                this.fechaConexao();\n            } catch (SQLException e) {\n                throw e;\n            }\n        }\n    }\n", "label": 0, "substitutes": {"copyFile": [" copyFiles", " copyfile", "copySourceFile", "transferfile", "transferSourceFile", "importFiles", " copySourceFile", "copyFiles", "copyfile", "importfile", "transferFile", "importFile", "transferFiles", "importSourceFile"], "from": ["before", "From", "client", "ca", "original", "left", "src", "form", "ce", "old", "user", "id", "address", "origin", "or", "a", "path", "resource", "io", "se", "at", "file", "of", "part", "start", "f", "url", "o", "this", "base", "data", "with", "range", "name", "by", " form", "d", "front", "without", "as", "remote", "about", "add", "back", "source", "config", "c"], "to": ["auto", "os", "toc", "client", "p", "size", "one", "too", "output", "socket", "object", "parent", "copy", "po", "office", "To", "t", "target", "or", "location", "TO", "top", "io", "into", "at", "file", "dest", "of", "root", "storage", "f", "o", "eto", "null", "until", "api", "base", "this", "temp", "type", "with", "b", "database", "token", "so", "name", "by", "site", "again", "as", "two", "point", "about", "source"], "parentDir": ["parentFile", "rootDir", "parentDirectory", "rootFolder", "ParentDirectory", "ParentFolder", "parentFolder", "currentDir", "currentFolder", "ParentFile", " parentDirectory", "currentdir", "rootDirectory", "rootFile", " parentdir", "outDir", "parentdir", " parentFile", "outFile", "ParentDir", "currentFile", "outFolder", "Parentdir", " parentFolder", "outDirectory"], "in": ["r", "image", "m", "pin", "sync", "ie", "inn", "isin", "gin", "i", "form", "rc", "pre", "init", "cin", "input", "on", "id", "arin", "din", "conn", "diff", "or", "lin", "inner", "vin", "io", "nin", "con", "ini", "fc", "rec", "kin", "work", "part", "inside", "rin", "min", "url", "o", "exec", "login", "err", "with", "trial", "it", "ins", "pc", "bin", "In", "l", "plugin", "again", "IN", "reader", "win", "source", "ac", "inc"], "out": ["Out", "ico", "auto", "client", "writer", "p", "sync", "off", "gin", "output", "init", "app", "cin", "input", "user", "ou", "win", "on", "cy", "ex", "option", "conn", "or", "inner", "io", "op", "at", "ot", "o", "channel", "exec", "vert", "can", "org", "w", "other", "net", "co", "call", "bin", "plugin", "again", "outer", "outs", "about", "c", "OUT", "ac", "inc"], "ic": ["ico", "aic", "ai", "auto", "irc", "cus", "sync", "IC", "i", "ik", "rc", "cc", "cs", "cin", "ix", "input", "ex", "ci", "lc", "conn", "loc", "or", "cu", "bc", "dc", "io", "op", "voc", "uc", "fc", "xc", "pic", "enc", "o", "vc", "ac", "iac", "cl", "nic", "ct", "pc", "co", "anc", "ig", "mc", "ics", "acs", "icc", "c", "inc", "ec"], "oc": ["aic", "toc", "sc", "ca", "cus", "i", "cc", "aco", "cy", "ci", "circ", "OC", "alloc", "loc", "or", "bc", "dc", "cur", "ocol", "io", "ob", "op", "wic", "voc", "uc", "fc", "xc", "oca", "oci", "roc", "o", "enc", "vc", "ac", "can", "ack", "org", "AC", "soc", "nic", "pc", "co", "anc", "mc", "ocon", "acs", "og", "mic", "oco", "c", "inc", "ec"]}}
{"id1": "8135072", "id2": "5035872", "code1": "    public void setImg() {\n        JFileChooser jFileChooser1 = new JFileChooser();\n        String separator = \"\";\n        if (JFileChooser.APPROVE_OPTION == jFileChooser1.showOpenDialog(this.getFatherFrame())) {\n            setPath(jFileChooser1.getSelectedFile().getPath());\n            separator = jFileChooser1.getSelectedFile().separator;\n            File dirImg = new File(\".\" + separator + \"images\");\n            if (!dirImg.exists()) {\n                dirImg.mkdir();\n            }\n            int index = getPath().lastIndexOf(separator);\n            String imgName = getPath().substring(index);\n            String newPath = dirImg + imgName;\n            try {\n                File inputFile = new File(getPath());\n                File outputFile = new File(newPath);\n                if (!inputFile.getCanonicalPath().equals(outputFile.getCanonicalPath())) {\n                    FileInputStream in = new FileInputStream(inputFile);\n                    FileOutputStream out = new FileOutputStream(outputFile);\n                    int c;\n                    while ((c = in.read()) != -1) out.write(c);\n                    in.close();\n                    out.close();\n                }\n            } catch (Exception ex) {\n                ex.printStackTrace();\n                LogHandler.log(ex.getMessage(), Level.INFO, \"LOG_MSG\", isLoggingEnabled());\n                JOptionPane.showMessageDialog(null, ex.getMessage().substring(0, Math.min(ex.getMessage().length(), getFatherPanel().MAX_DIALOG_MSG_SZ)) + \"-\" + getClass(), \"Set image\", JOptionPane.ERROR_MESSAGE);\n            }\n            setPath(newPath);\n            bckImg = new ImageIcon(getPath());\n        }\n    }\n", "code2": "    public static boolean copyFile(final File src, final File dst) {\n        boolean result = false;\n        FileChannel inChannel = null;\n        FileChannel outChannel = null;\n        synchronized (FileUtil.DATA_LOCK) {\n            try {\n                inChannel = new FileInputStream(src).getChannel();\n                outChannel = new FileOutputStream(dst).getChannel();\n                inChannel.transferTo(0, inChannel.size(), outChannel);\n                result = true;\n            } catch (IOException e) {\n            } finally {\n                if (inChannel != null && inChannel.isOpen()) {\n                    try {\n                        inChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n                if (outChannel != null && outChannel.isOpen()) {\n                    try {\n                        outChannel.close();\n                    } catch (IOException e) {\n                    }\n                }\n            }\n        }\n        return result;\n    }\n", "label": 1, "substitutes": {"setImg": ["setImgm", "setImageg", "getImagevg", "getImagegs", "setImagegs", "setAmg", "getImageg", "getImgs", "setIMgs", "getImvg", "getImgm", "setIMgm", "setAmvg", "setImagevg", "getImagegm", "setImgs", "setImagegm", "setAmgs", "setAmgm", "setImvg", "setIMg", "getImg", "setIMvg"], "jFileChooser1": ["jFileCloserOne", "jFileChooser3", "jFileChooseone", "jFileChoose2", "jFileCloser3", "jFileChooserone", "jFileChoosing3", "jFileChoosing2", "jFileChoiser2", "jFileChoosen1", "jFileChoouter1", "jFileChooserOne", "jFileChoosen3", "jFileChoosingL", "jFileChooseL", "jFileChoitcher2", "jFileClose2", "jFileChoitcher3", "jFileClose01", "jFileChoosing1", "jFileChoose3", "jFileChoicker3", "jFileCloserL", "jFileChoickerOne", "jFileCloser1", "jFileChoouter2", "jFileChoosingOne", "jFileChoosen2", "jFileChoosen01", "jFileChoicker1", "jFileChoitcher1", "jFileChoitcherone", "jFileChoiser3", "jFileChoiser1", "jFileCloseOne", "jFileChoickerL", "jFileChoose01", "jFileCloser2", "jFileChooser01", "jFileChoosenone", "jFileCloser01", "jFileChooseOne", "jFileChooserL", "jFileChoouter3", "jFileChoose1", "jFileChooser2", "jFileChoouter01", "jFileChoiserOne", "jFileClose3", "jFileClose1", "jFileCloseL"], "separator": ["terminate", "seator", "separated", "generating", "separate", "separinator", "locating", "decigator", "escapate", "generate", "locoder", " separators", " separate", "escapators", "separner", " separner", "escapigator", "escapator", "locator", "location", "separoder", "variated", "seoder", "peration", "decators", "decate", "variation", "locate", "separigator", " separar", "separation", "generator", " separinator", "terminator", " separoder", "seate", "locinator", " separated", " separigator", "seinator", "perner", "separar", "separating", "variator", "terminar", "terminner", "perar", "perate", "variate", "generation", "decator", " separation", " separating", "perated", "perator", "separators"], "dirImg": ["dirImagesg", " dirImgs", " dirImimg", "dirImgb", "dirimg", "dirIMgd", "dirImvg", "dirIMgb", "directoryImgs", "folderImgs", "dirSeg", "dirImgs", "dirImgd", "directoryImagesg", "dirAnimgd", "dirSevg", "dirIMimg", "dirSegs", "folderImvg", " dirImgd", "dirAmog", "directoryImageg", "directoryImagegs", "dirUrg", "dirImog", "homeIMg", "dirImagegb", "directoryImgb", "homeImvg", "dirImsg", "directoryImg", "dirImagegs", "dirAnimvg", "dirimsg", "dirAnimm", "dirUrimg", "dirIMvg", "dirAmgs", "dirImimg", "folderImg", "dirUrgd", "folderImog", "dirAmg", "homeIMm", "dirIMgs", "dirIMm", "dirimgb", "dirAmvg", "dirImm", "dirImageg", "dirimgs", "homeIMvg", "dirSeog", "dirAnimg", "homeIMgd", "dirUrgs", "dirIMsg", "dirIMg", "directoryImagegb", "homeImm", "homeImg", "directoryImsg", "homeImgd"], "index": ["ind", "position", "match", "level", "size", "pos", "key", "i", "default", "action", "slice", "id", "page", "section", "address", "loc", "diff", "num", "path", "weight", "line", "value", "part", "len", "end", "x", "active", "axis", "type", "offset", "number", "Index", "name", "string", "point", "field", "length", "inc", "condition"], "imgName": [" imgType", "imgname", "imagePath", " imgPath", "iconType", "imgPart", "imageName", "iconPath", "iconName", " imgname", "imageType", "iconname", "ngPart", "imagename", "ngName", "imgType", " imgPart", "ngPath", "ngname", "imagePart", "imgPath"], "newPath": ["newFile", "NewPath", "oldPath", "NewFile", "workingName", "NewLocation", "Newpath", " newLocation", "nextFile", "nextLocation", "workingFile", "nextpath", "newpath", "oldpath", "newName", " newUrl", " newName", "workingpath", "nextPath", "oldFile", "nextUrl", "NewName", "workingPath", " newFile", " newpath", "newLocation", "newUrl", "NewUrl", "oldLocation"], "inputFile": ["InputFile", " inputPage", "InputFolder", "outputPath", "viewFile", "InputDirectory", " inputFolder", "InputFiles", " inputDirectory", "inputFolder", " inputStream", "InputDir", " inputFiles", "viewFolder", " inputPath", "outputFiles", "InputStream", "InputPage", "inPath", "inputDirectory", "viewDirectory", "inDir", "viewPath", "inputFiles", "InputPath", " inputDir", "inFile", "inputDir", "inputPage", "inputStream", "inputPath", "outputPage", "inStream"], "outputFile": ["outputDirectory", " outputFolder", "OutputDirectory", "targetFolder", "writefile", "outputPath", "writeFile", "outputDir", "targetPath", "outputStream", "inputFolder", "OutputFiles", " outputStream", " outputDirectory", "outputFolder", " outputfile", "outputFiles", "targetFiles", "OutputFile", "OutputPath", "inputDirectory", "inputfile", "writeStream", " outputDir", "inputFiles", "writeDir", " outputPath", "inputDir", " outputFiles", "targetFile", "outputfile", "inputStream", "inputPath"], "in": ["r", "h", "pin", "n", "inn", "fa", "isin", "i", "is", "socket", "init", "cin", "input", "id", "ex", "sin", "din", "conn", "plus", "diff", "lin", "connection", "a", "inner", "io", "nin", "ini", "into", "part", "inside", "f", "o", "login", "err", "ins", "bin", "In", "l", "reader", "IN", "as", "again", "lock", "win", "source", "up", "inc"], "out": ["Out", "plain", "error", "client", "writer", "sync", "off", "i", "output", "socket", "copy", "ex", "cache", "conn", "to", "plus", "inner", "io", "line", "file", "part", "down", "o", "lib", "exec", "err", "ins", "other", "net", "co", "name", "bin", "OUT", "again", "IN", "point", "outs", "outer", "up", "inc"], "c": ["r", "C", "sc", "m", "p", "ic", "n", "cp", "i", "ce", "rc", "cc", "character", "dec", "e", "cr", "cy", "ci", "lc", "t", "cu", "code", "nc", "bc", "pointer", "dc", "cm", "xc", "uc", "esc", "x", "f", "col", "cent", "o", "enc", "ch", "abc", "k", "ac", "b", "arc", "v", "cl", "ct", "pc", "l", "d", "ec"], "bckImg": ["bccImf", "bckIngl", "bckIngs", "bckInf", "bckImgl", "bccPg", "bckimg", "bccPgl", "bckimf", "bckImf", "bckPgs", "bckPg", "bckPgl", "bccPf", "bckPf", "bckimgs", "bckimgl", "bckImgs", "bccImg", "bccImgs", "bccImgl", "bckIng", "bccPgs"]}}
{"id1": "21316706", "id2": "22411381", "code1": "    @Override\n    protected URLConnection openConnection(URL url, Proxy proxy) throws IOException {\n        if ((url == null) || (proxy == null)) {\n            throw new IllegalArgumentException(Messages.getString(\"luni.1B\"));\n        }\n        return new HttpsURLConnectionImpl(url, getDefaultPort(), proxy);\n    }\n", "code2": "    public PTask stop(PTask task, SyrupConnection con) throws Exception {\n        PreparedStatement s = null;\n        ResultSet result = null;\n        try {\n            s = con.prepareStatementFromCache(sqlImpl().sqlStatements().checkWorkerStatement());\n            s.setString(1, task.key());\n            result = s.executeQuery();\n            con.commit();\n            if (result.next()) {\n                String url = result.getString(\"worker\");\n                InputStream i = null;\n                try {\n                    Object b = new URL(url).getContent();\n                    if (b instanceof InputStream) {\n                        i = (InputStream) b;\n                        byte[] bb = new byte[256];\n                        int ll = i.read(bb);\n                        String k = new String(bb, 0, ll);\n                        if (k.equals(task.key())) {\n                            return task;\n                        }\n                    }\n                } catch (Exception e) {\n                } finally {\n                    if (i != null) {\n                        i.close();\n                    }\n                }\n                PreparedStatement s2 = null;\n                s2 = con.prepareStatementFromCache(sqlImpl().sqlStatements().resetWorkerStatement());\n                s2.setString(1, task.key());\n                s2.executeUpdate();\n                task = sqlImpl().queryFunctions().readPTask(task.key(), con);\n                sqlImpl().loggingFunctions().log(task.key(), LogEntry.STOPPED, con);\n                con.commit();\n            }\n        } finally {\n            con.rollback();\n            close(result);\n        }\n        return task;\n    }\n", "label": 0, "substitutes": {"openConnection": [" openConnect", "initConnect", "initConnector", "createconnection", "openConnector", "openConnect", "openconnection", "initConnection", "createConnection", "createConnector", " openConnector", "createConnect", "initconnection", " openconnection"], "url": ["lr", "image", "db", "client", "email", "service", "sl", "host", "socket", "object", "default", "user", "layer", "ls", "page", "port", "server", "address", "or", "connection", "http", "URL", "path", "ref", "io", "resource", "library", "ob", "ssl", "file", "str", "link", "f", "Url", "null", "base", "channel", "loader", "log", "name", "l", "string", "web", "uri", "source"], "proxy": ["ip", "client", "clone", "service", "p", "fax", "pa", "host", "socket", "object", "instance", "parent", "roxy", "page", "port", "server", "cache", "address", "child", "connection", "pointer", "http", "resource", "io", "library", "pool", "ssl", "Proxy", "manager", "lib", "base", "zip", "pe", "friend", "project", "pse", "web", "uri", "source", "config", " proxies"]}}
{"id1": "4118412", "id2": "13783549", "code1": "    private void compress(String outputFile, ArrayList<String> inputFiles, PrintWriter log, boolean compress) throws Exception {\n        String absPath = getAppConfig().getPathConfig().getAbsoluteServerPath();\n        log.println(\"Concat files into: \" + outputFile);\n        OutputStream out = new FileOutputStream(absPath + outputFile);\n        byte[] buffer = new byte[4096];\n        int readBytes;\n        for (String file : inputFiles) {\n            log.println(\" Read: \" + file);\n            InputStream in = new FileInputStream(absPath + file);\n            while ((readBytes = in.read(buffer)) != -1) {\n                out.write(buffer, 0, readBytes);\n            }\n            in.close();\n        }\n        out.close();\n        if (compress) {\n            long normalSize = new File(absPath + outputFile).length();\n            ProcessBuilder builder = new ProcessBuilder(\"java\", \"-jar\", \"WEB-INF/yuicompressor.jar\", outputFile, \"-o\", outputFile, \"--line-break\", \"4000\");\n            builder.directory(new File(absPath));\n            Process process = builder.start();\n            process.waitFor();\n            long minSize = new File(absPath + outputFile).length();\n            long diff = normalSize - minSize;\n            double percentage = Math.floor((double) diff / normalSize * 1000.0) / 10.0;\n            double diffSize = (Math.floor(diff / 1024.0 * 10.0) / 10.0);\n            log.println(\"Result: \" + percentage + \" % (\" + diffSize + \" KB)\");\n        }\n    }\n", "code2": "    private static void copy(String sourceName, String destName) throws IOException {\n        File source = new File(sourceName);\n        File dest = new File(destName);\n        FileChannel in = null, out = null;\n        try {\n            in = new FileInputStream(source).getChannel();\n            out = new FileOutputStream(dest).getChannel();\n            long size = in.size();\n            MappedByteBuffer buf = in.map(FileChannel.MapMode.READ_ONLY, 0, size);\n            out.write(buf);\n        } finally {\n            if (in != null) in.close();\n            if (out != null) out.close();\n        }\n    }\n", "label": 1, "substitutes": {"compress": ["ompressed", "comression", "compose", "comressed", "compressor", "Compression", "comress", "suppression", "Compress", "omppose", "compression", "compressing", " comprypt", "Compressor", "comppose", "Compressing", "Comppose", "Compressed", "ompression", " compressed", " compressing", "Comprypt", "comressing", "suppressor", "suppress", "suppressed", "comressor", "comrypt", "ompress", "compressed", "comprypt"], "outputFile": ["outputDirectory", "targetDir", " outputFolder", " outputLine", "OutputDirectory", "OutputF", "targetFolder", "outputPath", "externalPath", "outputDir", "externalDirectory", "inputF", "targetPath", " outputF", "inputFolder", "outputLine", "OutputLine", "OutputFiles", "inputLine", " outputDirectory", "Outputfile", "outputFolder", "outputF", " outputfile", "outputFiles", "externalFile", "OutputDir", "OutputFile", "OutputPath", "inputDirectory", "OutputFolder", " outputDir", "inputFile", "inputDir", " outputPath", " outputFiles", "outputfile", "targetFile", "externalfile", "inputPath"], "inputFiles": ["InputFile", "inputFile", " inputfiles", "outputFiles", " inputFile", "inputfiles", "Inputfiles", "InputFiles", "outputfiles"], "log": ["job", "db", "blog", "console", "stat", "entry", "up", "key", "output", "print", "trace", "feed", "user", "bug", "write", "cli", "ex", "cache", "per", "info", "or", "http", "exp", "path", "report", "low", "io", "xml", "pool", "debug", "row", "crit", "lex", "Log", "url", "exec", "base", "model", "zip", "temp", "pe", "put", "spec", "w", "tag", "cl", "net", "l", "LOG", "og", "pro", "pot", "lock", "pl", "config"], "absPath": ["resStream", "atsAuth", "apspath", "absParent", "atsPath", "absolutepath", "httpPath", "absolutePath", "httpDir", "atspath", "respath", "resDir", "bspath", "resPath", "abAuth", "abPath", "AbsPath", "abpath", "AbsStream", "absPo", "absStream", "apiPath", "apiDir", "bsPath", "bsParent", "labpath", "absolutePo", "bsHome", "abDirectory", "absoluteParent", "labParent", "Abspath", "abTime", "absDirectory", "absoluteDirectory", "atsPo", "httppath", "atsDir", "abspath", "absDir", "labPath", "AbsDir", "abDir", "apipath", "absAuth", "absoluteDir", "apsTime", "apsAuth", "AbsDirectory", " absStream", "absHome", "atsTime", "apsPath", "labHome", "absoluteHome", "abPo", " abspath", "absTime", " absDir"], "out": ["Out", "plain", "client", "writer", "sync", "obj", "off", "output", "socket", "app", "parent", "cli", "ex", "cache", "conn", "plus", "sum", "a", "inner", "ext", "io", "conf", "at", "work", "part", "prefix", "o", "serv", "this", "exec", "base", "err", "loader", "b", "w", "net", "bin", "In", "OUT", "again", "reader", "outs", "outer", "up", "inc"], "buffer": ["pad", "timeout", "writer", "bytes", "size", "shape", "batch", "block", "queue", "transfer", "feed", "slice", "input", "reference", "page", "limit", "Buffer", "cache", "phrase", "stack", "source", "padding", "buff", "uffer", "iter", "url", "buf", "binary", "channel", "base", "data", "border", "offset", "split", "wave", "memory", "reader", "header", "seed", "read", "layer", "length"], "readBytes": ["readByte", " readPages", "ReadBlocks", "inCount", " readByte", "writeCount", "readBlocks", " readParts", "writebytes", " readbytes", "writeByte", "readbytes", "ReadCount", "writeBlocks", "readCount", "ReadPages", "inBytes", "readParts", "ReadParts", "ReadByte", " readBlocks", "inPages", " readCount", "ReadBytes", "writeParts", "inbytes", "Readbytes", "writeBytes", "readPages"], "file": ["lf", " feed", "entry", "files", "key", "queue", "object", "el", "feed", "comment", "input", "slice", " message", "route", " path", "directory", "File", "rule", " directory", "fe", "source", "child", " input", "http", "path", "fp", "word", " File", " entry", " source", "FILE", "ile", "part", "work", "line", "dir", "f", "url", "letter", "unit", "base", "model", "type", "fil", "cl", " module", "name", "l", " url", "style", " files", "string", " f", "folder", "uri", " filename", "layer", "filename"], "in": ["r", "image", "pin", "n", "inn", "gin", "isin", "stream", "i", "is", "socket", "s", "init", "cin", "input", "id", "ex", "sin", "din", "lin", "a", "inner", "nin", "con", "ini", "kin", "part", "f", "pass", "login", "data", "err", "b", "ins", "bin", "In", "l", "reader", "IN", "again", "win", "up", "ac", "inc"], "normalSize": [" normalHeight", "smallSize", "normalInfo", "normalLength", "NormalHeight", "NormalPosition", "normLen", "NormalInfo", " normalWidth", "normalsize", "NormalSize", "normalTime", "normSize", "smallPosition", "normalNumber", "originalLen", " normalsize", " normalInfo", "NormalTime", "smallInfo", "normLength", "NormalWidth", " normalLen", "normalHeight", "NormalNumber", "originalsize", "normalLen", "normTime", "normWidth", "originalSize", " normalNumber", "normalPosition", "normNumber", " normalLength", " normalPosition", "normsize", "originalLength", "smallHeight", " normalTime", "normalWidth"], "builder": ["job", "r", "writer", "creator", "worker", "block", "entry", "bug", "slave", "e", "office", "sb", "info", "result", "builders", "hub", "inner", "editor", "later", "xml", "keeper", "angler", "manager", "building", "row", "build", "iter", "f", "this", "wrapper", "loader", "b", "er", "runner", "built", "driver", "l", "processor", "bean", "utils", "reader", "parser", "bridge", "outer", "Builder", "layer"], "process": ["job", "image", "large", "p", "worker", "script", "cess", "console", "cp", "output", "object", "use", "app", "e", "cache", "run", "program", "result", "handle", "share", "path", "resource", "proc", "thread", "build", "exec", "session", "task", "pm", "status", "processing", "method", "call", "node", "processor", "project", "commit", "command", "cmp", "Process", "sp"], "minSize": ["initOffset", "MinCount", "minOffset", "MinOffset", "normalLength", "minLength", "MinSize", "minWidth", " minOffset", "MinLength", "minCount", "initWidth", "normalCount", "initSize", " minWidth", "MinWidth", " minCount", " minLength", "initCount"], "diff": ["error", "equal", "progress", " difference", "size", "pos", "def", "flow", "same", "default", "multi", "version", "bug", "between", "mix", "fail", "iff", "low", "ref", "message", "change", "dist", "part", "f", "update", "scale", "div", "missing", "err", "range", "rel", "comp", "split", "changed", "frac", "remote", "Diff", "different", "distance", "extra", "cmp", "add", "neg", "shift"], "percentage": ["advantgrade", "spage", " percentency", "spce", "advantant", " percentile", " percentgrade", " percentant", "Percentant", "spile", "Percentce", " percentce", "Percentage", "percentgrade", "percentency", "Percentile", "spacity", "Percentacity", "Percentency", "percentant", "advantage", "percentile", "percentacity", " percentacity", "Percentgrade", "advantency", "percentce"], "diffSize": ["errorCount", "errorLen", "differentSize", "differentLen", "DiffCount", "differentCount", "diffLen", " diffsize", "Diffsize", "errorSize", "diffCount", "diffsize", "DiffSize", "differentsize", "DiffLen"]}}
{"id1": "14390569", "id2": "14231545", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    public void createTempFile(String resourceName) throws IOException {\n        InputStream input = JulImportCallableTest.class.getResourceAsStream(resourceName);\n        if (input == null) {\n            fail(\"Couldn't resolve resource '\" + resourceName + \"'!\");\n        }\n        inputFile = File.createTempFile(\"Import\", \"test\");\n        inputFile.delete();\n        FileOutputStream output = new FileOutputStream(inputFile);\n        IOUtils.copyLarge(input, output);\n        IOUtilities.closeQuietly(output);\n    }\n", "label": 1, "substitutes": {"title": ["ppa", "image", "details", "size", "itles", "term", "alpha", "html", "msg", "label", "summary", "notes", "layout", "TIT", "theme", "version", "id", "section", "page", "phrase", "format", "filename", "content", "desc", "message", "resource", "description", "part", "url", "prefix", "Title", "data", "type", "license", "subject", "chapter", "text", "name", "body", "string", "header", "heading", " Title", "itle"], "imageURL": ["imgPath", "pictureURI", "imageURI", "imagePath", "imageurl", "pictureURL", "imgURL", "ImageURL", "pictureUrl", "mediaUrl", " imageURI", " imageurl", "pictureurl", "fileUrl", "ImagePath", "fileURI", "mediaURI", "imgURI", "imageUrl", "mediaURL", "filePath", "ImageUrl", "fileurl", " imageUrl", "ImageURI", "fileURL", "imgUrl"], "jd": [" jf", "zb", " jD", "zdo", "ajb", "Jdos", "jds", "ajdh", "ssdo", "qdo", "jackd", "jsd", "jsdo", "Je", "qd", " jdl", "jdl", "jdi", "jjdo", "ajdos", "argdl", "Jdom", "argdo", " je", " jdom", "jdo", "Jl", "ssD", "ajD", "argd", "qb", "jdos", "jjb", "zf", "ajdi", " jdi", "jf", "qdom", "jdd", "adjdos", "jjdh", "jobD", "ajf", "jackb", "Jd", "Jf", "adjb", "jobb", "Jds", "adjdo", "ze", "Jb", "jobd", "Jdo", "argf", "qdh", "ssdi", " jdo", "ajdo", "jsb", " jds", "je", "ajdl", "adjd", "jobdo", "jdh", "zl", "ssd", "jdom", "jackf", "jsdh", "zds", "zdd", "jackdd", "JD", "jD", "ajd", " jdh", "jjd", " jdd", "zd"], "jl": ["j", "lf", "label", "lb", "el", "jon", "kel", "bn", "uj", "syn", "igl", "Label", "il", "cli", "hl", "iji", "adj", "elly", "lv", "chal", "jj", "ja", "li", "bl", "lp", "oji", "dj", "fp", "NJ", "bj", "kn", "eb", "wl", "iol", "dl", "ji", "ll", "jc", "kl", "l", "vd", "elt", "nl", "ld", "kj", "lu", "JM", "zl"], "icon": ["ico", "image", "artist", "size", "ic", "note", "n", "label", "cn", "bn", "action", "on", "css", " image", " Icon", "picture", "core", "ann", "gn", "info", "ui", "alias", "eye", "content", "resource", "io", "img", "Icon", "fc", "uni", "icons", "png", "url", "pic", "token", "text", "plugin", "ion", "cha", "header", "iao", "uri"], "chooser": [" choose", " choressor", "joose", "Choer", "Chooser", "Chooder", "boose", "closer", "closen", "cler", "dialose", " choosen", "choressor", "dialosen", "Choosen", "choer", "close", " chooses", "dialoser", "chooses", "booser", "Chooses", "jooder", "Choose", "jooses", "boressor", "dialer", "clressor", "choose", " chooder", "boosen", "chooder", "choosen", "jooser"], "jp": [" cm", " pane", " je", " dj", "j", " np", " j", " pa", " mp", " tmp", " JM", " cp", " plugin", "Panel", " js", "ja", " pic", " dock", "bj", " ax", " robot", " sp", " bridge", "JP", "ji", " bar", " gp", " obj", " app"], "jb": ["qsb", " jf", "qb", " jcb", " jbb", "ajsb", " jsb", "ajb", "jf", "djd", "jsbb", "djcb", "ajf", "jsd", "jbb", "djbb", "jsb", "jcb", "qf", "jscb", "ajcb", "djb", "qcb"], "e": ["in", "de", " fe", "ctx", "ie", "ce", "ee", "t", "a", "E", " E", " Event", "exc", "x", "ev", "f", "ception", " ate", "pe", "v", "je", "et", "ae", "te", "event", "c", "ec"], "returnVal": [" returnval", "replyValue", "returnval", "returnVAL", " returnNum", " returnValue", "replyVal", "resultval", "ReturnValue", "resultValue", "returnValue", "Returnval", "resultNum", "returnNum", "ReturnVAL", "replyVAL", "ReturnNum", " returnVAL", "resultVal", "replyval", "ReturnVal"], "file": ["image", "comment", "parent", "info", "http", "build", "die", "letter", "base", "name", "body", "folder", "get", "db", "full", "load", "user", "parse", "future", "page", "File", "rule", "home", "module", "path", "message", "io", "single", "pool", "ban", "FILE", "part", "unit", "b", "local", "live", "l", "lock", "auto", "files", "object", "use", "directory", "core", "picture", "show", "work", "line", "out", "function", "ile", "dir", "url", "lib", "pe", "log", "play", "filename", "buffer", "queue", "il", "po", "handler", "fp", "book", "f", "binary", "model", "zip", "data", "type", "force", "document"], "fileName": ["imagePath", "singleInfo", "Filename", "resourceInfo", "imageName", "resourcePath", "binaryUrl", "FileType", "binaryPath", "fileType", " fileType", "singlePath", " fileInfo", "singleName", "FileName", "binaryName", "resourcename", "imagename", "imageInfo", "fileUrl", "fileInfo", "FilePath", "FileInfo", " filePath", " fileUrl", "resourceName", "imageUrl", "filePath", "singleType", " filename", "singlename", "filename"], "ext": ["ace", "p", "xt", "obj", "sec", "xp", "class", "eng", "version", "ension", "ex", "t", "phrase", "Ext", "ax", "format", "alg", "fb", "exp", "path", "orig", "desc", "word", "qt", "EXT", "feat", "f", " Ext", "ch", "enc", "lib", "oct", "abc", "type", "pe", "v", "ct", "name", " extension", "extra", "txt"], "i": ["ai", "ip", "m", "j", "p", "bis", "is", "multi", "phi", "id", "cli", "gi", "ci", "ui", "info", "mini", "a", "li", "ii", "io", "iu", "z", "ini", "bi", "pi", "o", "xi", "ment", "api", "ti", "ri", "u", "ni", "b", "y", "v", "mi", "di", "ion", "si", "uri", "I", "c"], "doIt": ["diIT", " doIts", "odoWhich", "hoYou", "odoIt", "DOIT", "doNot", "poYou", "skipit", "skipIts", "skipIT", "doIT", "hoit", "addIT", " doIT", " doNot", "hoIT", "diit", " doit", "doIts", "addIt", "poIT", "doYou", "DOIt", "diIts", "odoit", "DOit", "poIt", "odoIT", "DOWhich", " doYou", "hoIt", "doWhich", "poit", "skipIt", "diIt", " doWhich", "addNot", "addit", "odoNot", "doit"], "src": ["r", "sc", "us", "sl", "attr", "ctx", "sync", "upload", "stream", "ff", "rc", "socket", "tmp", "impl", "fi", "input", "rs", "slice", "bb", "rx", "sn", "RC", "sb", "loc", "Dest", "target", "bc", "rb", "cos", "path", "desc", "inst", "pull", "cur", "gb", "img", "ssl", "cdn", "sup", "fc", "dist", "secure", "uc", "storage", "sel", "url", "buf", "st", "conv", "rest", "sq", "b", "rel", "split", "sub", "sth", "gz", "cmp", "ource", "source", "cb", "ources"], "dest": [" Dest", "output", "comb", "uv", "std", "tmp", "ctr", "route", "home", "Dest", "loc", "target", "dc", "desc", "inst", "dep", "exit", "later", "img", "proc", "wd", "sup", "cdn", "dist", "gd", "uc", "dir", "die", "st", "wb", "rest", "trans", "done", "di", "prop", "destroy", "usr", "cont", "dev", "gen", "dat", "source", "config"]}}
{"id1": "9109613", "id2": "13657103", "code1": "    public static void fileCopy(String from_name, String to_name) throws IOException {\n        File fromFile = new File(from_name);\n        File toFile = new File(to_name);\n        if (fromFile.equals(toFile)) abort(\"cannot copy on itself: \" + from_name);\n        if (!fromFile.exists()) abort(\"no such currentSourcepartName file: \" + from_name);\n        if (!fromFile.isFile()) abort(\"can't copy directory: \" + from_name);\n        if (!fromFile.canRead()) abort(\"currentSourcepartName file is unreadable: \" + from_name);\n        if (toFile.isDirectory()) toFile = new File(toFile, fromFile.getName());\n        if (toFile.exists()) {\n            if (!toFile.canWrite()) abort(\"destination file is unwriteable: \" + to_name);\n        } else {\n            String parent = toFile.getParent();\n            if (parent == null) abort(\"destination directory doesn't exist: \" + parent);\n            File dir = new File(parent);\n            if (!dir.exists()) abort(\"destination directory doesn't exist: \" + parent);\n            if (dir.isFile()) abort(\"destination is not a directory: \" + parent);\n            if (!dir.canWrite()) abort(\"destination directory is unwriteable: \" + parent);\n        }\n        FileInputStream from = null;\n        FileOutputStream to = null;\n        try {\n            from = new FileInputStream(fromFile);\n            to = new FileOutputStream(toFile);\n            byte[] buffer = new byte[4096];\n            int bytes_read;\n            while ((bytes_read = from.read(buffer)) != -1) to.write(buffer, 0, bytes_read);\n        } finally {\n            if (from != null) try {\n                from.close();\n            } catch (IOException e) {\n                ;\n            }\n            if (to != null) try {\n                to.close();\n            } catch (IOException e) {\n                ;\n            }\n        }\n    }\n", "code2": "    private void forBundle(BundleManipulator manip) {\n        ByteArrayOutputStream bout = null;\n        try {\n            bout = new ByteArrayOutputStream();\n            ZipOutputStream zout = new ZipOutputStream(bout);\n            Bundle bundle = getBundle();\n            Enumeration<URL> files = bundle.findEntries(\"/\", \"*.vm\", false);\n            if (files != null) {\n                while (files.hasMoreElements()) {\n                    URL url = files.nextElement();\n                    String name = url.getFile();\n                    if (name.startsWith(\"/\")) {\n                        name = name.substring(1);\n                    }\n                    if (manip.includeEntry(name)) {\n                        zout.putNextEntry(new ZipEntry(name));\n                        IOUtils.copy(url.openStream(), zout);\n                    }\n                }\n            }\n            manip.finish(bundle, zout);\n            Manifest mf = new Manifest(bundle.getEntry(\"META-INF/MANIFEST.MF\").openStream());\n            zout.putNextEntry(new ZipEntry(\"META-INF/MANIFEST.MF\"));\n            mf.write(zout);\n            zout.close();\n            File tmpFile = File.createTempFile(TEMPLATES_SYMBOLIC_NAME, \".jar\");\n            FileUtils.writeByteArrayToFile(tmpFile, bout.toByteArray());\n            if (pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_SYMBOLIC_NAME));\n            } else if (pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY) != null) {\n                pluginController.uninstall(pluginAccessor.getPlugin(TEMPLATES_PLUGIN_KEY));\n            }\n            pluginController.installPlugin(new JarPluginArtifact(tmpFile));\n            ServiceReference ref = bundleContext.getServiceReference(PackageAdmin.class.getName());\n            ((PackageAdmin) bundleContext.getService(ref)).refreshPackages(null);\n            tmpFile.delete();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            IOUtils.closeQuietly(bout);\n        }\n    }\n", "label": 1, "substitutes": {"fileCopy": ["Filecopy", "folderTransfer", "FileTransfer", " fileUpload", " filecopy", "FileUpload", "FileCopy", "fileUpload", "filecopy", "folderUpload", "fileTransfer", "folderCopy", "foldercopy", " fileTransfer"], "from_name": ["from_address", "fromqname", " from__address", "from__name", "fromqName", "from_resource", "fromqfilename", " from__alias", "from_key", " from_word", " from_space", "from_time", "from_size", " from__Name", "fromThespace", "from_alias", " from_filename", "fromTheName", "from_no", " from__name", "from_word", "fromameno", "from_filename", " from_resource", " from_path", "from__address", "from_space", "fromamename", "fromFullName", " from_Name", "fromameName", "fromTheword", "from_path", " from_address", "fromqpath", "from_image", " from_time", " from_key", "from_Name", "from__Name", "fromFullname", " from_alias", " from_no", " from_image", "from__alias", "fromThename", "fromFullalias", "fromFulladdress", "fromametime", " from_size"], "to_name": ["To_common", "tokName", "to_names", "To_Name", "from_names", " to_key", "to_path", "to_Name", "from_Name", " to_file", "from_path", "to_common", "to_file", "to_key", "To_name", "tokname", "tokcommon"], "fromFile": ["tofile", " fromfile", "autofile", "autoFile", " fromModel", "sourcePage", "oneModel", "fromFactory", " fromPackage", "toFunction", "FromFile", "ofFile", "offile", "autoFolder", "ofPackage", "fromFolder", "sourceLibrary", " fromDirectory", "FromFolder", "onefile", " fromPage", "FromDirectory", "fromfile", "ofFolder", "connectionFile", "FromDir", "fromFiles", " fromLibrary", "fromLibrary", "fromModel", " fromFiles", "FromModel", "fromDirectory", " fromLine", "sourceFile", "Fromfile", "fromPage", "connectionPackage", "fromDir", "oneFunction", "sourceDirectory", "asFiles", " fromFactory", "onePage", "asFactory", "toLine", " fromDir", "FromFunction", " fromFolder", "fromPackage", "connectionFolder", "oneFolder", "oneDir", "asfile", "toFiles", " fromFunction", "fromFunction", "fromLine", "autoPage", "asFile", "connectionfile", "FromFiles", "FromPage", "oneFile", "FromLine", "FromLibrary", "toFactory"], "toFile": [" tofile", "soFile", "toFunction", "basefile", "ToLine", " toFunction", "ToPage", "TODir", "fromDirectory", "ToFunction", "targetFactory", "fromDir", "aFile", " toTable", "baseTable", "baseFile", "cofile", "ofDir", " toLine", "ToPlace", "targetPlace", "targetFolder", "toPlace", "ToDirectory", "offile", "noLibrary", " toFiles", "tempfile", "ToFiles", " toFolder", "targetSourceFile", "toPage", "coDirectory", "TOFile", "TOPlace", "tempFile", " toDirectory", "ofFile", "afile", "ofTable", "toLibrary", "targetfile", " toDir", "nofile", "aDir", "noFile", "tempFolder", " toFactory", "soLibrary", " toPage", "tempFactory", "targetPage", "coFunction", "Tofile", "targetDir", "tofile", "toTable", "aFiles", "ToLibrary", "toDirectory", "fromfile", "fromFiles", "toDir", "soPage", "noPage", "ToFactory", "fromPage", "sofile", " toSourceFile", "toLine", "ToFile", "TOPage", "ToSourceFile", "baseDir", "ToDir", "toFolder", "fromLine", "toFiles", "targetFile", "coFile", "toFactory", "toSourceFile"], "parent": ["shape", "g", "master", "key", "section", "complete", "address", "content", "Parent", "root", "api", "test", "search", "name", "string", "pr", "ip", "client", "large", "p", "full", "pa", "user", "page", "patch", "rule", "home", "loc", "region", "path", "pool", "file", "part", "div", "any", "and", "ac", "inc", "class", "guard", "id", "lc", "directory", "port", "valid", "option", "child", "out", "manager", "line", "url", "null", "pe", "remote", "paren", "point", "source", "pt", "term", "par", "owner", "server", "or", "connection", "location", "exp", "resource", "col", "session", "data", "type", "parents", "current"], "dir": ["r", "db", "attr", "DIR", "block", "def", "class", "fd", "dict", "cat", "dec", "directory", "coll", "home", "per", "loc", "group", "or", "dr", "ver", "dc", "container", "path", "dep", "cur", "exp", "ir", "out", "manager", "rec", "file", "root", "dist", "wd", "director", "f", "url", "col", "lib", "die", "build", "doc", "iter", "div", "rel", "keep", "Dir", "name", "di", "mod", "d", "folder", "lock", "dev", "inc", "dis"], "from": ["when", "get", "auto", "From", "in", "clean", "fr", "client", "de", "component", "flo", "query", "one", "left", "stream", "old", "ce", "form", "view", "ou", "user", "parse", "e", "cr", "po", "per", "conn", "module", "or", "connection", "wh", "low", "io", "se", "cm", "ra", "out", "con", "file", "part", "who", "start", "link", "url", "ch", "o", "this", "base", "normal", "channel", "api", "with", "can", "range", "hand", "so", "name", "bean", "by", "without", "empty", "add", "source", "self", "c", "vol"], "to": ["auto", "db", "su", "size", "sync", "too", "flo", "go", "one", "http", "output", "object", "proxy", "copy", "on", "po", "tto", "office", "page", "To", "cache", "port", "plus", "target", "or", "connection", "fat", "fb", "TO", "ver", "be", "io", "top", "op", "see", "not", "out", "file", "pi", "store", "o", "eto", "until", "base", "api", "no", "will", "type", "with", "b", "token", "via", "tom", "so", "name", "co", "by", "again", "two", "about", "source"], "buffer": ["position", "bytes", "shape", "batch", "block", "queue", "texture", "transfer", "default", "comment", "feed", "character", "reference", "page", "Buffer", "cache", "server", "address", "result", "padding", "message", "resource", "buff", "value", "row", "uffer", "available", "iter", "buf", "binary", "device", "channel", "null", "data", "border", "number", "document", "total", "memory", "table", "reader", "string", "header", "variable", "seed", "vector", "duration", "read", "flush", "layer", "length"], "bytes_read": ["bytesayput", "bytes_received", " bytes_write", "classesavREAD", "classes_READ", "bytesESSput", "bytesESSreceived", "bytesayreceived", "bytes___READ", "classesavread", "classesavview", "lines_read", "classesavavailable", " bytes_load", "bytesavview", "classes_read", "bytes_load", "bytes_write", "bytes___read", "bytes_view", "bytes_available", " bytes_written", "bytes___available", "lines_put", "bytesavavailable", "bytes_put", "bytesavREAD", "bytes___view", "bytesayread", "bytesESSwritten", "bytesaywritten", "bytesavread", "bytesESSread", "bytes_READ", "bytes_written", "classes_available", "lines_received", "classes_view", "lines_written"]}}
{"id1": "14390569", "id2": "12055086", "code1": "    private DialogHelper(String title, final URL imageURL) {\n        jd = new JDialog();\n        jd.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n        jd.setAlwaysOnTop(true);\n        jd.setLayout(new BoxLayout(jd.getContentPane(), BoxLayout.Y_AXIS));\n        jd.setTitle(title);\n        JLabel jl = new JLabel();\n        ImageIcon icon = new ImageIcon(imageURL);\n        jl.setIcon(icon);\n        jd.add(new JScrollPane(jl));\n        final JFileChooser chooser = getSaveImageChooser();\n        JPanel jp = new JPanel();\n        JButton jb = new JButton(getMessage(\"btn_save_as\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                int returnVal = chooser.showSaveDialog(jd);\n                if (returnVal == JFileChooser.APPROVE_OPTION) {\n                    File file = chooser.getSelectedFile();\n                    String fileName = file.getPath();\n                    String ext = StringUtil.getLowerExtension(fileName);\n                    if (!\"png\".equals(ext)) {\n                        fileName += \".png\";\n                        file = new File(fileName);\n                    }\n                    boolean doIt = true;\n                    if (file.exists()) {\n                        int i = JOptionPane.showConfirmDialog(jd, getMessage(\"warn_file_exist\"));\n                        if (i != JOptionPane.YES_OPTION) doIt = false;\n                    } else if (!file.getParentFile().exists()) {\n                        doIt = file.getParentFile().mkdirs();\n                    }\n                    if (doIt) {\n                        FileChannel src = null;\n                        FileChannel dest = null;\n                        try {\n                            src = new FileInputStream(imageURL.getPath()).getChannel();\n                            dest = new FileOutputStream(fileName).getChannel();\n                            src.transferTo(0, src.size(), dest);\n                        } catch (FileNotFoundException e1) {\n                            warn(jd, getMessage(\"err_no_source_file\"));\n                        } catch (IOException e2) {\n                            warn(jd, getMessage(\"err_output_target\"));\n                        } finally {\n                            try {\n                                if (src != null) src.close();\n                            } catch (IOException e1) {\n                            }\n                            try {\n                                if (dest != null) dest.close();\n                            } catch (IOException e1) {\n                            }\n                            src = null;\n                            dest = null;\n                        }\n                    }\n                }\n            }\n        });\n        jp.add(jb);\n        jb = new JButton(getMessage(\"btn_close\"));\n        jb.addActionListener(new ActionListener() {\n\n            public void actionPerformed(ActionEvent e) {\n                jd.dispose();\n            }\n        });\n        jp.add(jb);\n        jd.add(jp);\n        jd.pack();\n        setCentral(jd);\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"title": ["ppa", "image", "details", "size", "itles", "term", "alpha", "html", "msg", "label", "summary", "notes", "layout", "TIT", "theme", "version", "id", "section", "page", "phrase", "format", "filename", "content", "desc", "message", "resource", "description", "part", "url", "prefix", "Title", "data", "type", "license", "subject", "chapter", "text", "name", "body", "string", "header", "heading", " Title", "itle"], "imageURL": ["imgPath", "pictureURI", "imageURI", "imagePath", "imageurl", "pictureURL", "imgURL", "ImageURL", "pictureUrl", "mediaUrl", " imageURI", " imageurl", "pictureurl", "fileUrl", "ImagePath", "fileURI", "mediaURI", "imgURI", "imageUrl", "mediaURL", "filePath", "ImageUrl", "fileurl", " imageUrl", "ImageURI", "fileURL", "imgUrl"], "jd": [" jf", "zb", " jD", "zdo", "ajb", "Jdos", "jds", "ajdh", "ssdo", "qdo", "jackd", "jsd", "jsdo", "Je", "qd", " jdl", "jdl", "jdi", "jjdo", "ajdos", "argdl", "Jdom", "argdo", " je", " jdom", "jdo", "Jl", "ssD", "ajD", "argd", "qb", "jdos", "jjb", "zf", "ajdi", " jdi", "jf", "qdom", "jdd", "adjdos", "jjdh", "jobD", "ajf", "jackb", "Jd", "Jf", "adjb", "jobb", "Jds", "adjdo", "ze", "Jb", "jobd", "Jdo", "argf", "qdh", "ssdi", " jdo", "ajdo", "jsb", " jds", "je", "ajdl", "adjd", "jobdo", "jdh", "zl", "ssd", "jdom", "jackf", "jsdh", "zds", "zdd", "jackdd", "JD", "jD", "ajd", " jdh", "jjd", " jdd", "zd"], "jl": ["j", "lf", "label", "lb", "el", "jon", "kel", "bn", "uj", "syn", "igl", "Label", "il", "cli", "hl", "iji", "adj", "elly", "lv", "chal", "jj", "ja", "li", "bl", "lp", "oji", "dj", "fp", "NJ", "bj", "kn", "eb", "wl", "iol", "dl", "ji", "ll", "jc", "kl", "l", "vd", "elt", "nl", "ld", "kj", "lu", "JM", "zl"], "icon": ["ico", "image", "artist", "size", "ic", "note", "n", "label", "cn", "bn", "action", "on", "css", " image", " Icon", "picture", "core", "ann", "gn", "info", "ui", "alias", "eye", "content", "resource", "io", "img", "Icon", "fc", "uni", "icons", "png", "url", "pic", "token", "text", "plugin", "ion", "cha", "header", "iao", "uri"], "chooser": [" choose", " choressor", "joose", "Choer", "Chooser", "Chooder", "boose", "closer", "closen", "cler", "dialose", " choosen", "choressor", "dialosen", "Choosen", "choer", "close", " chooses", "dialoser", "chooses", "booser", "Chooses", "jooder", "Choose", "jooses", "boressor", "dialer", "clressor", "choose", " chooder", "boosen", "chooder", "choosen", "jooser"], "jp": [" cm", " pane", " je", " dj", "j", " np", " j", " pa", " mp", " tmp", " JM", " cp", " plugin", "Panel", " js", "ja", " pic", " dock", "bj", " ax", " robot", " sp", " bridge", "JP", "ji", " bar", " gp", " obj", " app"], "jb": ["qsb", " jf", "qb", " jcb", " jbb", "ajsb", " jsb", "ajb", "jf", "djd", "jsbb", "djcb", "ajf", "jsd", "jbb", "djbb", "jsb", "jcb", "qf", "jscb", "ajcb", "djb", "qcb"], "e": ["in", "de", " fe", "ctx", "ie", "ce", "ee", "t", "a", "E", " E", " Event", "exc", "x", "ev", "f", "ception", " ate", "pe", "v", "je", "et", "ae", "te", "event", "c", "ec"], "returnVal": [" returnval", "replyValue", "returnval", "returnVAL", " returnNum", " returnValue", "replyVal", "resultval", "ReturnValue", "resultValue", "returnValue", "Returnval", "resultNum", "returnNum", "ReturnVAL", "replyVAL", "ReturnNum", " returnVAL", "resultVal", "replyval", "ReturnVal"], "file": ["image", "comment", "parent", "info", "http", "build", "die", "letter", "base", "name", "body", "folder", "get", "db", "full", "load", "user", "parse", "future", "page", "File", "rule", "home", "module", "path", "message", "io", "single", "pool", "ban", "FILE", "part", "unit", "b", "local", "live", "l", "lock", "auto", "files", "object", "use", "directory", "core", "picture", "show", "work", "line", "out", "function", "ile", "dir", "url", "lib", "pe", "log", "play", "filename", "buffer", "queue", "il", "po", "handler", "fp", "book", "f", "binary", "model", "zip", "data", "type", "force", "document"], "fileName": ["imagePath", "singleInfo", "Filename", "resourceInfo", "imageName", "resourcePath", "binaryUrl", "FileType", "binaryPath", "fileType", " fileType", "singlePath", " fileInfo", "singleName", "FileName", "binaryName", "resourcename", "imagename", "imageInfo", "fileUrl", "fileInfo", "FilePath", "FileInfo", " filePath", " fileUrl", "resourceName", "imageUrl", "filePath", "singleType", " filename", "singlename", "filename"], "ext": ["ace", "p", "xt", "obj", "sec", "xp", "class", "eng", "version", "ension", "ex", "t", "phrase", "Ext", "ax", "format", "alg", "fb", "exp", "path", "orig", "desc", "word", "qt", "EXT", "feat", "f", " Ext", "ch", "enc", "lib", "oct", "abc", "type", "pe", "v", "ct", "name", " extension", "extra", "txt"], "i": ["ai", "ip", "m", "j", "p", "bis", "is", "multi", "phi", "id", "cli", "gi", "ci", "ui", "info", "mini", "a", "li", "ii", "io", "iu", "z", "ini", "bi", "pi", "o", "xi", "ment", "api", "ti", "ri", "u", "ni", "b", "y", "v", "mi", "di", "ion", "si", "uri", "I", "c"], "doIt": ["diIT", " doIts", "odoWhich", "hoYou", "odoIt", "DOIT", "doNot", "poYou", "skipit", "skipIts", "skipIT", "doIT", "hoit", "addIT", " doIT", " doNot", "hoIT", "diit", " doit", "doIts", "addIt", "poIT", "doYou", "DOIt", "diIts", "odoit", "DOit", "poIt", "odoIT", "DOWhich", " doYou", "hoIt", "doWhich", "poit", "skipIt", "diIt", " doWhich", "addNot", "addit", "odoNot", "doit"], "src": ["r", "sc", "us", "sl", "attr", "ctx", "sync", "upload", "stream", "ff", "rc", "socket", "tmp", "impl", "fi", "input", "rs", "slice", "bb", "rx", "sn", "RC", "sb", "loc", "Dest", "target", "bc", "rb", "cos", "path", "desc", "inst", "pull", "cur", "gb", "img", "ssl", "cdn", "sup", "fc", "dist", "secure", "uc", "storage", "sel", "url", "buf", "st", "conv", "rest", "sq", "b", "rel", "split", "sub", "sth", "gz", "cmp", "ource", "source", "cb", "ources"], "dest": [" Dest", "output", "comb", "uv", "std", "tmp", "ctr", "route", "home", "Dest", "loc", "target", "dc", "desc", "inst", "dep", "exit", "later", "img", "proc", "wd", "sup", "cdn", "dist", "gd", "uc", "dir", "die", "st", "wb", "rest", "trans", "done", "di", "prop", "destroy", "usr", "cont", "dev", "gen", "dat", "source", "config"]}}
{"id1": "3430784", "id2": "23370621", "code1": "    public static Body decodeBody(InputStream in, String contentTransferEncoding) throws IOException {\n        if (contentTransferEncoding != null) {\n            contentTransferEncoding = MimeUtility.getHeaderParameter(contentTransferEncoding, null);\n            if (\"quoted-printable\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new QuotedPrintableInputStream(in);\n            } else if (\"base64\".equalsIgnoreCase(contentTransferEncoding)) {\n                in = new Base64InputStream(in);\n            }\n        }\n        BinaryTempFileBody tempBody = new BinaryTempFileBody();\n        OutputStream out = tempBody.getOutputStream();\n        IOUtils.copy(in, out);\n        out.close();\n        return tempBody;\n    }\n", "code2": "    private void downloadFile(File target, String s3key) throws IOException, S3ServiceException {\n        InputStream in = downloadData(s3key);\n        if (in == null) {\n            throw new IOException(\"No data found\");\n        }\n        in = new InflaterInputStream(new CryptInputStream(in, cipher, getDataEncryptionKey()));\n        File temp = File.createTempFile(\"dirsync\", null);\n        FileOutputStream fout = new FileOutputStream(temp);\n        try {\n            IOUtils.copy(in, fout);\n            if (target.exists()) {\n                target.delete();\n            }\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n            FileUtils.moveFile(temp, target);\n        } catch (IOException e) {\n            fetchStream(in);\n            throw e;\n        } finally {\n            IOUtils.closeQuietly(fout);\n            IOUtils.closeQuietly(in);\n        }\n    }\n", "label": 1, "substitutes": {"decodeBody": ["decodePart", " decodedStream", " decodePart", " decodedFile", "decodingBody", "decodesBody", "decodedStream", " decodedBody", "decodesFile", "decodedBody", "decodingStream", "decodingFile", "decodesStream", " decodeStream", "decodedFile", "decodingPart", "decodeFile", "decodesPart", " decodeFile", "decodedPart", " decodedPart", "decodeStream"], "in": ["request", "get", "image", "r", "m", "buffer", "inn", "isin", "gin", "src", "i", "is", "socket", "init", "load", "cin", "input", "win", "version", "id", "ex", "din", "inas", "conn", "connection", "content", "inner", "resource", "nin", "ini", "con", "into", "file", "work", "inside", "min", "f", "url", "pass", "exec", "serv", "login", "session", "data", "err", "loader", "b", "it", "ins", "bin", "In", "reader", "IN", "as", "again", "body", "read", "c", "source", "config", "ac", "inc"], "contentTransferEncoding": ["contentRestEnoding", "contentTransferEcaming", "contentRestEncoding", "contentTransferEnoder", "contentTransferEcitting", "contentTransferEryption", "contentTransferencoder", "contentPartEncasing", "contentTransferEosing", "contentTransferEncasing", "contentTransferEcoding", "contentRestEncording", "contentTransferEngearing", "contentTransferCoding", "contentPartEncoder", "contentTransferCasing", "contentTransferEncryption", "contentPartEncoding", "contentTransferEncitting", "contentTransferAcoder", "contentPartEryption", "contentTransferEncoded", "contentTransferencoding", "contentTransferEncosing", "contentTransferAcasing", "contentTransferEncoder", "contentTransferEcoder", "contentTransferEnoded", "contentTransferEnosing", "contentTransferEnording", "contentTransferEncearing", "contentTransferencording", "contentTransferCearing", "contentTransferCoder", "contentRestEncaming", "contentTransferCryption", "contentTransferEndasing", "contentTransferEnryption", "contentTransferEoding", "contentTransferCoded", "contentTransferEnearing", "contentTransferEndoding", "contentTransferEnasing", "contentPartEoder", "contentPartEasing", "contentPartEoding", "contentTransferEnaming", "contentTransferEcording", "contentRestEnoder", "contentTransferEasing", "contentTransferAcosing", "contentTransferEncording", "contentPartEncryption", "contentTransferEndoded", "contentTransferencitting", "contentRestEncoder", "contentRestEnaming", "contentTransferEncaming", "contentTransferEnitting", "contentTransferCaming", "contentTransferEngoding", "contentTransferEngasing", "contentRestEnording", "contentTransferCording", "contentTransferEndoder", "contentTransferEoder", "contentTransferEngoded", "contentTransferEnoding", "contentTransferAcoding"], "tempBody": ["tempFile", "outputLife", "outputFile", "tempLife", "TempBody", "outputbody", " tempCore", "tempbody", "tempCore", "tmpCore", "TempCore", "tmpLife", "outputBody", " tempLife", " tempbody", "tmpBody", " tempFile", "TempFile", "Tempbody", "tmpFile", "tmpbody"], "out": ["Out", "client", "writer", "obj", "sync", "off", "i", "output", "socket", "object", "app", "init", "user", "copy", "parent", "page", "ex", "cache", "conn", "connection", "a", "inner", "path", "resource", "ext", "io", "pool", "line", "raw", "file", "o", "null", "base", "this", "channel", "exec", "data", "err", "temp", "bin", "body", "again", "outs", "extra", "source", "OUT", "c"]}}
{"id1": "21979462", "id2": "17580775", "code1": "    protected String downloadURLtoString(URL url) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n        StringBuffer sb = new StringBuffer(100 * 1024);\n        String str;\n        while ((str = in.readLine()) != null) {\n            sb.append(str);\n        }\n        in.close();\n        return sb.toString();\n    }\n", "code2": "        public void runInternal() {\n            connection = null;\n            boolean itemsLoadedPartially = false;\n            boolean loadNext = false;\n            HashSet<String> visited = new HashSet<String>();\n            do {\n                try {\n                    setProgressMessage(url.toString(), -1);\n                    visited.add(url.toString());\n                    long startTimeStamp = System.currentTimeMillis();\n                    delayedProgress = coolReader.getEngine().showProgressDelayed(0, progressMessage, PROGRESS_DELAY_MILLIS);\n                    URLConnection conn = url.openConnection();\n                    if (conn instanceof HttpsURLConnection) {\n                        onError(\"HTTPs is not supported yet\");\n                        return;\n                    }\n                    if (!(conn instanceof HttpURLConnection)) {\n                        onError(\"Only HTTP supported\");\n                        return;\n                    }\n                    connection = (HttpURLConnection) conn;\n                    connection.setRequestProperty(\"User-Agent\", \"CoolReader/3(Android)\");\n                    if (referer != null) connection.setRequestProperty(\"Referer\", referer);\n                    connection.setInstanceFollowRedirects(true);\n                    connection.setAllowUserInteraction(false);\n                    connection.setConnectTimeout(CONNECT_TIMEOUT);\n                    connection.setReadTimeout(READ_TIMEOUT);\n                    connection.setDoInput(true);\n                    String fileName = null;\n                    String disp = connection.getHeaderField(\"Content-Disposition\");\n                    if (disp != null) {\n                        int p = disp.indexOf(\"filename=\");\n                        if (p > 0) {\n                            fileName = disp.substring(p + 9);\n                        }\n                    }\n                    int response = -1;\n                    response = connection.getResponseCode();\n                    L.d(\"Response: \" + response);\n                    if (response != 200) {\n                        onError(\"Error \" + response);\n                        return;\n                    }\n                    String contentType = connection.getContentType();\n                    String contentEncoding = connection.getContentEncoding();\n                    int contentLen = connection.getContentLength();\n                    L.d(\"Entity content length: \" + contentLen);\n                    L.d(\"Entity content type: \" + contentType);\n                    L.d(\"Entity content encoding: \" + contentEncoding);\n                    setProgressMessage(url.toString(), contentLen);\n                    InputStream is = connection.getInputStream();\n                    delayedProgress.cancel();\n                    is = new ProgressInputStream(is, startTimeStamp, progressMessage, contentLen, 80);\n                    final int MAX_CONTENT_LEN_TO_BUFFER = 256 * 1024;\n                    boolean isZip = contentType != null && contentType.equals(\"application/zip\");\n                    if (expectedType != null) contentType = expectedType; else if (contentLen > 0 && contentLen < MAX_CONTENT_LEN_TO_BUFFER) {\n                        byte[] buf = new byte[contentLen];\n                        if (is.read(buf) != contentLen) {\n                            onError(\"Wrong content length\");\n                            return;\n                        }\n                        is.close();\n                        is = null;\n                        is = new ByteArrayInputStream(buf);\n                        if (findSubstring(buf, \"<?xml version=\") >= 0 && findSubstring(buf, \"<feed\") >= 0) contentType = \"application/atom+xml\";\n                    }\n                    if (contentType.startsWith(\"application/atom+xml\")) {\n                        L.d(\"Parsing feed\");\n                        parseFeed(is);\n                        itemsLoadedPartially = true;\n                        if (handler.docInfo.nextLink != null && handler.docInfo.nextLink.type.startsWith(\"application/atom+xml;profile=opds-catalog\")) {\n                            if (handler.entries.size() < MAX_OPDS_ITEMS) {\n                                url = new URL(handler.docInfo.nextLink.href);\n                                loadNext = !visited.contains(url.toString());\n                                L.d(\"continue with next part: \" + url);\n                            } else {\n                                L.d(\"max item count reached: \" + handler.entries.size());\n                                loadNext = false;\n                            }\n                        } else {\n                            loadNext = false;\n                        }\n                    } else {\n                        if (fileName == null) fileName = defaultFileName;\n                        L.d(\"Downloading book: \" + contentEncoding);\n                        downloadBook(contentType, url.toString(), is, contentLen, fileName, isZip);\n                        if (progressShown) coolReader.getEngine().hideProgress();\n                        loadNext = false;\n                        itemsLoadedPartially = false;\n                    }\n                } catch (Exception e) {\n                    L.e(\"Exception while trying to open URI \" + url.toString(), e);\n                    if (progressShown) coolReader.getEngine().hideProgress();\n                    onError(\"Error occured while reading OPDS catalog\");\n                    break;\n                } finally {\n                    if (connection != null) try {\n                        connection.disconnect();\n                    } catch (Exception e) {\n                    }\n                }\n            } while (loadNext);\n            if (progressShown) coolReader.getEngine().hideProgress();\n            if (itemsLoadedPartially) BackgroundThread.guiExecutor.execute(new Runnable() {\n\n                @Override\n                public void run() {\n                    L.d(\"Parsing is finished successfully. \" + handler.entries.size() + \" entries found\");\n                    callback.onFinish(handler.docInfo, handler.entries);\n                }\n            });\n        }\n", "label": 1, "substitutes": {"downloadURLtoString": [" downloadURLtoLong", " downloadUrltoLong", " downloadURLasStr", " downloadURLtostring", " downloadUrlasString", " downloadUrltostring", " downloadUrlasLong", " downloadURLasString", " downloadUrlasstring", " downloadURL2string", " downloadURLasstring", " downloadUrltoStr", " downloadURL2Long", " downloadURLasLong", " downloadURLintoLong", " downloadURLtoStr", " downloadUrltoString", " downloadURL2String", " downloadUrlasStr", " downloadURL2Str", " downloadURLintoString", " downloadURLintostring", " downloadURLintoStr"], "url": ["lr", "image", "job", "buffer", "service", "sl", "el", "user", "page", "server", "rule", "address", "bel", "loc", "connection", "http", "URL", "resource", "path", "ref", "ssl", "file", "link", "f", "Url", "base", "data", "gl", "loader", "b", "name", "l", "remote", "uri", "source", "config"], "in": ["r", "db", "fr", "buffer", "h", "ic", "n", "inn", "gin", "isin", "read", "i", "is", "s", "init", "impl", "input", "ln", "rx", "din", "lin", "af", "fb", "inner", "nin", "ssl", "out", "ini", "into", "at", "min", "f", "ilo", "login", "data", "err", "b", "it", "ins", "bin", "In", "reader", "IN", "again", "as", "cms", "re", "source", "ac", "inc"], "sb": ["lr", "db", "abb", "bp", "buffer", "bf", "src", "lb", "bs", "s", "zb", "SB", "bt", "amb", "ib", "bb", "ls", "usb", "sa", "sf", "sg", "bc", "rb", "bm", "fb", "kb", "mb", "buff", "gb", "Bs", "pb", "ub", "bh", "B", "bd", "eb", "buf", "wb", " SB", "BB", "b", "bsp", "xb", "obb", " eb", "si", "nb", "lab", "sth", "sv", "cb", "erb"], "str": ["STR", "r", "fr", "txt", "sl", "obj", "br", "n", "i", "key", "s", "cr", "lc", "Str", "stri", "coll", "result", "dr", "bl", "exp", "cur", "line", "wr", "sr", "iter", "f", "st", "pass", "enc", "doc", "data", "err", "div", "b", "char", "spec", "cl", "text", "ct", "arr", "name", "l", "string", "list", "tr", "read", "pr", "sp"]}}
{"id1": "20073619", "id2": "2525897", "code1": "    public static String getPagina(String strurl) {\n        String resp = \"\";\n        Authenticator.setDefault(new Autenticador());\n        try {\n            URL url = new URL(strurl);\n            BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));\n            String str;\n            while ((str = in.readLine()) != null) {\n                resp += str;\n            }\n            in.close();\n        } catch (MalformedURLException e) {\n            resp = e.toString();\n        } catch (IOException e) {\n            resp = e.toString();\n        } catch (Exception e) {\n            resp = e.toString();\n        }\n        return resp;\n    }\n", "code2": "    public static byte[] decode(String cryptPassword, byte[] encoded, byte[] salt) {\n        try {\n            MessageDigest digester = MessageDigest.getInstance(DIGEST);\n            SecureRandom random = SecureRandom.getInstance(RANDOM);\n            digester.reset();\n            for (int i = 0; i < ITERATIONS; i++) {\n                digester.update(salt);\n                digester.update(cryptPassword.getBytes(\"UTF-8\"));\n            }\n            byte[] hash = digester.digest();\n            random.setSeed(hash);\n            int maxKeySize = Cipher.getMaxAllowedKeyLength(CIPHER);\n            KeyGenerator generator = KeyGenerator.getInstance(CIPHER);\n            generator.init(maxKeySize, random);\n            SecretKey key = generator.generateKey();\n            Cipher cipher = Cipher.getInstance(CIPHER);\n            cipher.init(Cipher.DECRYPT_MODE, key);\n            byte[] decoded = cipher.doFinal(encoded);\n            return decoded;\n        } catch (Exception e) {\n            StorePlugin.getDefault().log(e);\n        }\n        return new byte[0];\n    }\n", "label": 0, "substitutes": {"getPagina": ["getChangina", "getPangira", "getPaginate", "getPanginate", "getPaminate", "getChagira", "getPaguira", "getChagina", "getPaguine", "getPamina", "getChaginate", "getChagine", "getPangine", "getPangina", "getPamira", "getPagine", "getChangine", "getChangira", "getPaguina", "getPagira", "getPamine", "getPaguinate", "getChanginate"], "strurl": ["sthttp", "Strurl", "arrstr", "arrurl", "strURL", "wrURL", "STRstr", "StrUrl", "stristr", "striURL", "strUrl", "arrUrl", "wrstring", "strstr", "strstring", "arrhttp", "Strstr", "wrstr", "wrurl", "STRstring", "strhttp", "Strhttp", "sturl", "STRurl", "STRURL", "stUrl", "striurl", "ststr", "stristring"], "resp": ["success", "fr", "p", "obj", "html", "pp", "msg", "host", "reply", "default", "respons", "bb", "page", "coll", "json", "conn", "fe", "pretty", "result", "esp", "content", "rss", "response", "ref", "report", "lp", "reason", "rh", "exp", "ret", "esi", "Response", "Resp", "rec", "dest", "part", "rev", "req", "api", "serv", "rep", "zip", "rest", "model", "err", "rel", "wp", "comp", "news", "res", "remote", "respond", "cmp", "www", "sp"], "url": ["r", "image", "ball", "job", "buffer", "service", "sl", "entry", "stream", "rl", "i", "socket", "user", "ls", "e", "page", "server", "bel", "open", "inf", "connection", "http", "URL", "resource", "path", "io", "ssl", "file", "f", "Url", "base", "gl", "log", "b", "org", "ll", "l", "web", "ur", "uri", "source"], "in": ["r", "image", "fr", "inn", "stream", "gin", "i", "is", "s", "init", "el", "impl", "input", "e", "id", "cf", "din", "lin", "inner", "nin", "out", "ini", "con", "rec", "into", "file", "inside", "f", "doc", "login", "ac", "err", "b", "it", "ins", "bin", "In", "l", "ar", "reader", "IN", "d", "again", "as", "source", "c", "inc"], "str": ["STR", "r", "fr", "p", "sl", "obj", "br", "i", "s", "rs", "e", "cr", "lc", "Str", "stri", "coll", "dr", "code", "cur", "rr", "line", "raw", "rec", "wr", "sr", "iter", "f", "st", "enc", "doc", "data", "err", "div", "char", "cl", "text", "arr", "l", "reader", "string", "tr", "read", "c", "pr", "sp"]}}
{"id1": "4618237", "id2": "3187685", "code1": "    public static void writeFileToFile(File fin, File fout, boolean append) throws IOException {\n        FileChannel inChannel = new FileInputStream(fin).getChannel();\n        FileChannel outChannel = new FileOutputStream(fout, append).getChannel();\n        try {\n            inChannel.transferTo(0, inChannel.size(), outChannel);\n        } finally {\n            if (inChannel != null) try {\n                inChannel.close();\n            } catch (IOException ex) {\n            }\n            if (outChannel != null) try {\n                outChannel.close();\n            } catch (IOException ex) {\n            }\n        }\n    }\n", "code2": "    private void copyJar(File src, File dst) throws IOException {\n        FileChannel srcChannel = null;\n        FileChannel dstChannel = null;\n        try {\n            srcChannel = new FileInputStream(src).getChannel();\n            dstChannel = new FileOutputStream(dst).getChannel();\n            dstChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        } catch (IOException e) {\n            fLog.log(Level.SEVERE, e.getMessage(), e);\n        } finally {\n            srcChannel.close();\n            dstChannel.close();\n        }\n    }\n", "label": 1, "substitutes": {"writeFileToFile": ["writeFilesToStream", "writeFile2Stream", "writeFileAndFiles", "writeFileToFiles", "writeFilesAsChannel", "writeFilesToFiles", "writeFileToStream", "writeFileAsFile", "writeFilesAsFiles", "writeFileAndStream", "writeFile2Files", "writeFile2File", "writeFilesAsStream", "writeFile2Channel", "writeFileAndFile", "writeFilesToChannel", "writeFileAndChannel", "writeFilesAsFile", "writeFileAsChannel", "writeFileAsStream", "writeFileToChannel", "writeFileAsFiles", "writeFilesToFile"], "fin": ["fr", "pin", "inn", "fa", "fd", "init", "fi", "ln", "fen", "thin", "include", "arin", "din", "fm", "conn", "ris", "inf", "lin", "fat", "Fin", "ori", "raf", "fp", "FIN", "nir", "ini", "rin", "fn", "kin", "file", "en", "rf", "f", "fine", "pins", "rt", "inv"], "fout": ["FOut", "bout", " fint", "Fout", "rfin", "Fin", " foff", "boff", "bOut", "foff", "Fint", "fOut", "bin", "rfOut", "fint", "rfint", "Foff", " fOut", "rfout"], "append": ["pad", "opp", "batch", "save", "atten", "spread", "app", "optional", "future", "want", "fail", "apply", "open", "padding", "ext", "only", "ending", "pack", "send", "adjust", "ended", "end", "enc", "null", "update", "flat", "protect", "vert", "except", "printf", "pend", "remove", "text", "password", "string", "leaf", "push", "add", "flush"], "inChannel": ["innStream", "outStream", "innerchannel", "inputChannel", " inchannel", "inchannel", "INStream", "innerChan", "INChan", "outchannel", "loginchannel", "outChan", "inQueue", "innChannel", "InStream", "inputConnection", "innerStream", "INChannel", "InChan", "inputChan", "inChan", "outQueue", "inConnection", "InChannel", " inStream", "loginChannel", "Inchannel", "innchannel", "innerConnection", "INchannel", " inQueue", "INConnection", "loginStream", "innerChannel", "INQueue", "inputStream", "inStream"], "outChannel": ["outStream", " outchannel", "externalChannel", "inchannel", "OutContext", "externalchannel", "outchannel", "OutChan", "outChan", "ioStream", "OutChannel", "outputChan", "outputchannel", "outputSocket", "ioChan", "externalChan", "OutStream", " outChan", "outputChannel", "outSocket", "inChan", "inSocket", "externalSocket", " outContext", "ioChannel", "outContext", "Outchannel", "iochannel", "inContext", "inStream"]}}
{"id1": "5707205", "id2": "8047989", "code1": "            public void run() {\n                Log.d(LOG_TAG, \"Fetching \" + url);\n                WebDbAdapter dbHelper = new WebDbAdapter(mContext);\n                dbHelper.open();\n                boolean errorOccurred = true;\n                int notifyId = 0;\n                String host = AppUtils.getHostFromUrl(url);\n                try {\n                    if (host == null) {\n                        Log.d(LOG_TAG, \"Bad url \" + url);\n                        errorOccurred = true;\n                    } else {\n                        notifyId = showNotification(\"Fetching \" + host, \"Fetching \" + host, android.R.drawable.stat_sys_download, 0);\n                        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(mContext);\n                        String userAgent = sp.getString(mContext.getString(R.string.pref_key_user_agent), mContext.getString(R.string.default_user_agent));\n                        Log.d(LOG_TAG, \"Using user agent=\" + userAgent);\n                        AndroidHttpClient ahc = AndroidHttpClient.newInstance(mContext, url, userAgent);\n                        URI uri = new URI(url);\n                        URI norm = new URI(uri.getScheme().toLowerCase(), uri.getUserInfo(), uri.getHost().toLowerCase(), uri.getPort(), uri.getPath(), uri.getQuery(), null);\n                        norm = norm.normalize();\n                        HttpUriRequest get = new HttpGet(norm);\n                        HttpResponse response = ahc.execute(get);\n                        if (response.getStatusLine().getStatusCode() == 200) {\n                            HttpEntity entity = response.getEntity();\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            entity.writeTo(baos);\n                            String data = baos.toString();\n                            for (int i = 0; i < undesirables.length; i++) {\n                                Pattern p = Pattern.compile(undesirables[i], Pattern.CASE_INSENSITIVE | Pattern.DOTALL);\n                                data = data.replaceAll(p.pattern(), \"\");\n                            }\n                            long sysMillis = System.currentTimeMillis();\n                            String newFileName = getPath(sysMillis, sp.getBoolean(mContext.getString(R.string.pref_key_store_sdcard), false));\n                            FileOutputStream strm = new FileOutputStream(newFileName);\n                            Log.d(LOG_TAG, \"Writing to \" + newFileName + \" for url \" + url);\n                            String jsData = AppUtils.fromRawResourceFile(R.raw.retain_loadcolors, mContext);\n                            jsData = jsData.replaceAll(\"@css_file\", RETAIN_COLORS_CSS);\n                            strm.write(jsData.getBytes());\n                            strm.write(data.getBytes());\n                            strm.write(jsData.getBytes());\n                            strm.flush();\n                            strm.close();\n                            String entryName = getTitle(newFileName, url);\n                            long newRowId = dbHelper.createEntry(entryName, newFileName, url, sysMillis);\n                            postToast(\"Downloaded \\\"\" + entryName + \"\\\"\");\n                            errorOccurred = false;\n                            if (deleteRowId != 0) {\n                                Log.d(LOG_TAG, \"Deleting rowId=\" + deleteRowId);\n                                dbHelper.deleteEntry(deleteRowId);\n                                if (url == null) postToast(\"Item Deleted\");\n                                mContext.startActivity(new Intent(mContext, RetainActivity.class));\n                            } else {\n                                showNotification(\"Download Complete\", entryName, android.R.drawable.stat_sys_download_done, newRowId);\n                            }\n                        } else {\n                            Log.e(LOG_TAG, \"Response code=\" + String.valueOf(response.getStatusLine().getStatusCode()));\n                        }\n                    }\n                } catch (IOException ioe) {\n                    Log.e(LOG_TAG, \"RETAIN IOException: \" + ioe.getMessage());\n                } catch (URISyntaxException u) {\n                    Log.e(LOG_TAG, \"RETAIN URISyntaxException: \" + u.getMessage());\n                } catch (OutOfMemoryError oome) {\n                    Log.e(LOG_TAG, \"RETAIN OutOfMemoryError: \" + oome.getMessage());\n                } catch (Exception e) {\n                    Log.e(LOG_TAG, \"RETAIN Exception: \" + e.getMessage());\n                }\n                hideNotification(notifyId);\n                if (errorOccurred && host != null) {\n                    showNotification(\"Error Downloading\", host, android.R.drawable.stat_notify_error, 0);\n                    postToast(\"Error fetching \" + host);\n                }\n                dbHelper.close();\n            }\n", "code2": "    protected byte[] getHashedID(String ID) {\n        try {\n            MessageDigest md5 = MessageDigest.getInstance(\"MD5\");\n            md5.reset();\n            md5.update(ID.getBytes());\n            byte[] digest = md5.digest();\n            byte[] bytes = new byte[WLDB_ID_SIZE];\n            for (int i = 0; i < bytes.length; i++) {\n                bytes[i] = digest[i];\n            }\n            return bytes;\n        } catch (NoSuchAlgorithmException exception) {\n            System.err.println(\"Java VM is not compatible\");\n            exit();\n            return null;\n        }\n    }\n", "label": 0, "substitutes": {"run": ["request", "process", "client", "query", "worker", "app", "load", "server", "check", "submit", "show", "Run", "work", "build", "find", "start", "url", "exec", "update", "test", "runner", "running", "search", "loop", "create", "launch"], "dbHelper": ["DBManager", " dbFactory", " dbSupport", " dbManager", "DBFactory", "DbHelper", "dbFactory", "DBServer", "DbServer", " dbServer", "dbServer", "dbManager", "DbManager", "DbFactory", "DBHelper", "DBSupport", "DbSupport", "dbSupport"], "notifyId": ["notificationID", "notiqUrl", "noteifyUrl", "notounceID", " notifyID", "notiqID", "noteifierID", "notifyID", "noteifierId", "notifierId", "noteifyId", "notificationUrl", "noteifierUrl", " notifyCount", "notificationCount", "notounceId", "notounceCount", "notifierUrl", "notiqId", "noteifyID", "notifierID", "notifyUrl", "notifyCount", "notificationId"], "host": ["mac", "domain", "ip", "localhost", "h", "service", "key", "pattern", "object", "proxy", "feed", "user", "Host", "id", "port", "server", "valid", "home", "address", "loc", "target", "connection", "format", "http", "location", "path", "message", "hub", "work", "root", "part", "url", "prefix", "null", "database", "bind", "name", "auth", "node", "project", "string", "addr", "source", "username"], "sp": ["db", "sc", "bp", "sw", "service", "sl", "pp", "html", "pa", "profile", "pre", "sk", "scope", "gp", "SP", "Sp", "sb", "py", "per", "sf", "sh", "asp", "ap", "esp", "lp", "fp", "op", "se", "manager", "sup", "space", "sr", "tp", "sm", "serv", "jp", "isp", " SP", "bsp", "mp", "hp", "spe", "si", "osp", "np", "jar", "policy"], "userAgent": ["userInfo", "UserAgent", " userAg", "sourceAg", "useInfo", "UserInfo", "useragent", "useAgent", "useAg", "sourceAgent", "sourceData", "useText", "userText", " useragent", " userInfo", "userAg", "userData", "sourceText", "Useragent", " userText", " userData", "useData", "sourceagent", "useagent"], "ahc": ["ihf", "ehp", "ohpc", "yahl", "yahb", "ihci", "ohb", "ohp", "ihc", "ahl", "ahci", "chef", "chepc", "ohl", "ahb", "ohci", "ehc", "ahp", "checi", "yahp", "chec", "ahf", "ihpc", "ohc", "ohf", "ahpc", "ehb", "yahc", "ehl"], "uri": ["domain", "image", "absolute", "iri", "component", " URI", "term", "query", "iso", "object", "consumer", "URI", "uno", "future", "environment", "cli", "route", "directory", "gi", "archive", "server", "address", "universal", "ui", "or", "connection", "http", "location", "resource", "message", "ori", "direction", "uni", "storage", "pi", "ilo", "url", "prefix", "api", "base", "unit", "system", "ri", "license", "range", "database", "done", "controller", "document", "di", "site", "browser", "remote", "general", "verb", "string", "doi", "source", "filename", "username"], "norm": ["Normal", "domain", "process", "generic", "union", "orm", "term", "sync", "nor", "chrom", "ord", "common", "global", "rom", "parent", "orr", "route", "orient", "core", "coll", "origin", "NOR", "info", "or", "handle", "cos", "desc", "radius", "resource", "orig", "our", "ori", "real", "line", "raw", "cdn", "uni", "bas", "dist", "function", "url", "normal", "unit", "base", "orbit", "Norm", "system", "known", "flat", "range", "transform", "coord", "custom", "front", "center", "gen", "neg", "cb"], "get": ["request", "GET", "r", "client", "Get", "service", "getting", "query", "read", "object", "view", "gi", "check", "open", "handle", "message", "resource", "pull", "show", "send", "find", " Get", "post", "start", "url", "req", "api", "set", "update", "search", "method", "call", "invoke", "body", "like", "gen", "create"], "response": ["request", "next", "success", "error", "client", "service", "received", "full", "output", "reply", "object", "relation", "feed", "respons", "version", "page", "handler", "json", "server", "result", "connection", "http", "message", "resource", "successful", "report", "translation", "Response", "resp", "ception", "api", "onse", "collection", "status", "application", "wave", "method", "document", "body", "respond"], "entity": ["image", "error", "component", "service", "query", "element", "entry", "output", "object", "el", "action", "instance", "e", "environment", "json", "server", "metadata", "cache", "info", "result", "connection", "content", "resource", "Entity", "message", "xml", "file", "api", "security", "type", "ent", "article", "status", "application", "document", "node", "body", "string", "event", "person"], "baos": ["baOS", "nao", "baas", " baios", " bais", "waos", "naios", "BAos", "pao", "wao", "waas", " bao", "BAis", "paos", "daOS", "paOS", "laOS", "bao", "taOS", "lao", " baom", "waOS", "laom", "dao", "naos", "daos", "taas", "baios", "nais", "bais", "taos", "paom", "baom", "daas", " baOS", "BAo", "laos", "BAios", "tao"], "data": ["image", "buffer", "bytes", "batch", "html", "key", "output", "pattern", "object", "layout", "action", "input", "json", "complete", "info", "result", "media", "format", "content", "array", "message", "resource", "results", "value", "description", "part", "space", "url", "partial", "database", "done", "text", "record", "memory", "bin", "style", "body", "string", "DATA", "parts", "ata", "reader", "dat"], "i": ["ind", "ai", "ip", "h", "j", "n", "eni", "multi", "fi", "slice", "e", "phi", "id", "abi", "ci", "gi", "mu", "ui", "info", "li", "index", "ii", "io", "ini", "uni", "bi", "part", "end", "x", "pi", "f", "start", "o", "xi", "ti", "ri", "u", "ni", "b", "y", "v", "ji", "mi", "oi", "di", "hi", "l", "si", "yi", "chi", "field", "I", "c"], "p": ["r", "ip", "m", "j", "P", "pp", "n", "g", "pa", "cp", "pattern", "pre", "parse", "po", "patch", "t", "py", "per", "ap", "lp", "op", "proc", "part", "f", "o", "api", "pe", "u", "pat", "v", "pc", "l", "d", "string", "ps", "parser", "point", "np", "c", "pr"], "sysMillis": ["sysMils", "sysMinis", "sysMilli", "sysmillis", " systemMillis", "sysMills", "sysMilis", "sysMini", " systemmilli", " systemmillis", " systemMilli", "sysmilles", "sysMines", " systemMills", "sysMins", "sysmills", "sysMilles", " systemmills", " systemMilles", "sysMili", " systemmilles", "sysMiles", "sysmilli"], "errorOccurred": ["errorIssured", "erroroccur", "errorOccurrence", "errorOccur", "errorAccurrence", "erroroccured", " errorOccured", " errorOccurrence", "errorIssurrence", " errorOccur", "errorAccur", "errorOccured", "errorAccurred", "errorAccured", "errorIssurred", "erroroccurrence", "errorIssur", "erroroccurred"]}}
{"id1": "17337238", "id2": "6371580", "code1": "    private Retailer create() throws SQLException, IOException {\n        Connection conn = null;\n        Statement st = null;\n        String query = null;\n        ResultSet rs = null;\n        try {\n            conn = dataSource.getConnection();\n            st = conn.createStatement();\n            query = \"insert into \" + DB.Tbl.ret + \"(\" + col.title + \",\" + col.addDate + \",\" + col.authorId + \") \" + \"values('\" + title + \"',now(),\" + user.getId() + \")\";\n            st.executeUpdate(query, new String[] { col.id });\n            rs = st.getGeneratedKeys();\n            if (!rs.next()) {\n                throw new SQLException(\"\u041d\u0435 \u0443\u0434\u0430\u0435\u0442\u0441\u044f \u043f\u043e\u043b\u0443\u0447\u0438\u0442\u044c generated key 'id' \u0432 \u0442\u0430\u0431\u043b\u0438\u0446\u0435 retailers.\");\n            }\n            int genId = rs.getInt(1);\n            rs.close();\n            saveDescr(genId);\n            conn.commit();\n            Retailer ret = new Retailer();\n            ret.setId(genId);\n            ret.setTitle(title);\n            ret.setDescr(descr);\n            RetailerViewer.getInstance().somethingUpdated();\n            return ret;\n        } catch (SQLException e) {\n            try {\n                conn.rollback();\n            } catch (Exception e1) {\n            }\n            throw e;\n        } finally {\n            try {\n                rs.close();\n            } catch (Exception e) {\n            }\n            try {\n                st.close();\n            } catch (Exception e) {\n            }\n            try {\n                conn.close();\n            } catch (Exception e) {\n            }\n        }\n    }\n", "code2": "    public void insertDomain(final List<String> domains) {\n        try {\n            connection.setAutoCommit(false);\n            new ProcessEnvelope().executeNull(new ExecuteProcessAbstractImpl(connection, false, false, true, true) {\n\n                @Override\n                public void executeProcessReturnNull() throws SQLException {\n                    psImpl = connImpl.prepareStatement(sqlCommands.getProperty(\"domain.add\"));\n                    Iterator<String> iter = domains.iterator();\n                    String domain;\n                    while (iter.hasNext()) {\n                        domain = iter.next();\n                        psImpl.setString(1, domain);\n                        psImpl.setString(2, domain.toLowerCase(locale));\n                        psImpl.executeUpdate();\n                    }\n                }\n            });\n            connection.commit();\n            cmDB.updateDomains(null, null);\n        } catch (SQLException sqle) {\n            log.error(sqle);\n            if (connection != null) {\n                try {\n                    connection.rollback();\n                } catch (SQLException ex) {\n                }\n            }\n        } finally {\n            if (connection != null) {\n                try {\n                    connection.setAutoCommit(true);\n                } catch (SQLException ex) {\n                    log.error(ex);\n                }\n            }\n        }\n    }\n", "label": 1, "substitutes": {"create": ["request", "creator", "save", "one", "init", "created", "construct", "instance", "write", "copy", "open", "replace", " recreate", "config", "start", "store", "make", "update", "type", "creation", "record", "Create", "setup", "insert", "destroy", "add", " Create"], "IOException": ["TimeoutError", "IOError", "TimeoutException", "Timeoutception", "Databaseception", "DatabaseError", "IOception", "DatabaseException", " IOError", " IOception"], "conn": ["error", "Coll", "db", "os", "r", "client", "connect", "ca", "Conn", "h", "p", "sync", "ctx", "n", "apt", "oss", "cp", "rc", "cn", "cc", "pg", "ad", "cr", "po", "nt", "ci", "ht", "ens", "coll", "reg", "ann", "loc", "dn", "connection", "nc", "ob", "con", "conf", "wd", "ds", "dh", "pub", "en", "col", "ch", "enc", "sql", "session", "err", "log", "rt", "ct", "Connect", "res", "Connection", "lock", "act", "c", "pr"], "st": ["ST", "r", "sts", "db", "sc", "fr", "sw", "sl", "ast", "sync", "St", "rd", "src", "ste", "s", "std", "sa", "cr", "nt", "ft", "sn", "ist", "t", "sb", "ut", "sh", "inst", "se", "td", "con", "sta", "step", "ds", "str", "ts", "est", "rest", "rt", "put", "nd", "cl", "mt", "ct", "stop", "ost", "ss", "ld", "sth", "ust", "ess", "dd", "pt", "pr", "sp"], "query": ["request", "eries", "where", "error", "clean", "timeout", "iq", "term", "script", "q", "form", "comment", "scope", "qq", "parse", "cr", "select", "Query", "statement", "rule", "json", "qu", "result", "code", "sum", "index", "report", "resource", "rr", "description", " Query", "how", "build", "str", "value", "sql", "update", "sq", "database", "test", "search", "table", "ql", "string", "seed", "command", "question", "filter", "push", "uri", "join", "dq", "pr"], "rs": ["r", "rys", "RS", "arms", "rd", "rl", "rc", "cs", "s", "Rs", "xs", "ls", "cr", "rx", "ns", "ows", "ros", "asts", "ges", "ris", "reg", "ks", "result", "dr", "vers", "rss", "rm", "issues", "ras", "results", "rr", "row", "ds", "hr", "sr", "mr", "ts", "req", "ars", "ans", "ack", "rt", "hs", "rows", "ins", "ys", "acks", "vs", "ues", "res", "rg", "ps", "runs", "ers", "ms", "ws", "pr", "repl"], "genId": ["GenID", "ginID", "gID", "genType", "ginId", "generId", "ginid", " genType", " genInt", " genid", "generType", "ginById", "genById", "libId", "genID", " genID", "winID", "gid", "GenId", "libInt", "winById", "winid", "genInt", " genById", "gId", "winId", "genid", "libType", "Genid", "generInt"], "ret": ["att", "detail", "entry", "rc", "reply", "RET", "reg", "desc", "Pub", "vet", "proc", "pb", "fun", "pub", "grid", "base", "v", "search", "res", "usr", "back", "r", "db", "fit", "def", "gen", "proxy", "ft", "val", "let", "response", "num", "resp", "part", "active", "alt", "rt", "bot", "utils", "gt", "job", "success", "class", "cat", "id", "result", " result", "ext", "ref", "REG", "rev", "auth", "pro", "place", "match", "seq", "obj", "bf", "default", " Ret", "server", "Reg", "rets", "f", "login", "data", "Ret", "vr", "true", "general", "det", "tr", "re", "arg", "repl"]}}
{"id1": "14473781", "id2": "7296597", "code1": "        @Override\n        protected String doInBackground(Void... params) {\n            HttpClient httpClient = new DefaultHttpClient();\n            HttpContext localContext = new BasicHttpContext();\n            HttpPost httpPost = new HttpPost(urlFormated);\n            try {\n                MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);\n                for (int index = 0; index < POSTparamList.size(); index++) {\n                    if (POSTparamList.get(index).getName().equalsIgnoreCase(\"image\")) {\n                        entity.addPart(POSTparamList.get(index).getName(), new FileBody(new File(POSTparamList.get(index).getValue())));\n                    } else {\n                        entity.addPart(POSTparamList.get(index).getName(), new StringBody(POSTparamList.get(index).getValue()));\n                    }\n                }\n                httpPost.setEntity(entity);\n                HttpResponse response = httpClient.execute(httpPost, localContext);\n                return processAnswer(response);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n", "code2": "    public void create() {\n        Connection conn = OrmHandler.getInstance().getSession().getConnection(this);\n        Statement stat = null;\n        StringBuilder sql = new StringBuilder(256);\n        try {\n            getRenderer().printCreateDatabase(this, sql);\n            conn = createConnection();\n            stat = conn.createStatement();\n            stat.executeUpdate(sql.toString());\n            conn.commit();\n            if (LOGGER.isLoggable(Level.INFO)) {\n                LOGGER.info(sql.toString());\n            }\n        } catch (Throwable e) {\n            if (conn != null) {\n                try {\n                    conn.rollback();\n                } catch (SQLException ex) {\n                    LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n                }\n            }\n            throw new IllegalArgumentException(\"Statement error:\\n\" + sql, e);\n        } finally {\n            try {\n                close(conn, stat, null, true);\n            } catch (IllegalStateException ex) {\n                LOGGER.log(Level.WARNING, \"Can't rollback DB\" + toString(), ex);\n            }\n        }\n    }\n", "label": 0, "substitutes": {"doInBackground": [" doUsingNode", " doInContext", " doOnBuffer", " doOnNode", "doInContext", "doInNode", "doOnBuffer", " doUsingContext", " doWithinBuffer", " doUsingBuffer", " doOnBackground", " doWithinBackground", "doOnNode", "doOnContext", "doOnBackground", " doWithinContext", " doInBuffer", " doWithinNode", " doUsingBackground", " doOnContext", " doInNode", "doInBuffer"], "params": ["ip", "Par", "query", "Param", "i", "par", "instance", "parse", "page", "handler", "json", "properties", "ams", "array", "param", "resources", "options", "pi", "Parameters", "url", "api", "data", "type", "list", "ps", "uri", "config"], "httpClient": ["HttpProxy", "HttpPost", "httpContext", " httpContext", "HttpCase", "httpsCase", "ttpContext", "httpsClient", "ttpProxy", "HttpClient", "httpCall", "httpProxy", "httpCase", "HttpCall", "HttpContext", "ttpClient", "ttpPost", "httpsPost", "httpsCall", " httpCase", " httpCall", " httpProxy"], "localContext": ["localcontext", " localConfig", "globalContext", "httpContext", "LocalClient", "LocalContext", "httpcontext", " localClient", " localData", "httpData", "locData", "loccontext", "globalClient", "locConfig", "Localcontext", "httpConfig", "globalPort", "locContext", "localClient", "localPort", " localPort", "localData", "LocalPort", " localcontext", "localConfig", "globalcontext"], "httpPost": [" httppost", "phpPOST", "cachePOST", "HttpPost", "phpCopy", "httpPOST", " httpPOST", "requestPOST", "httpCopy", "requestpost", "httpsRequest", "Httppost", "httpRequest", "ttpCreate", "HttpCopy", " httpPatch", "requestPost", "ttpCopy", " httpCopy", "httppost", "phppost", "requestCopy", "phpPost", "httpPatch", "HttpCreate", "cacheRequest", " httpCreate", "ttpPost", "ttppost", "httpCreate", "httpsPOST", "httpsPatch", "cachePatch", "cachePost", "httpsPost", " httpRequest"], "entity": ["image", "component", "email", "p", "service", "oe", "eme", "element", "entry", "ce", "object", "el", "instance", "e", "environment", "om", "page", "coll", "server", "address", "per", "json", "connection", "media", "http", "content", "resource", "Entity", "xml", "translation", "line", "file", "part", "post", "url", "enc", "api", "base", "channel", "model", "pe", "ent", "article", "collection", "activity", "ity", "document", "node", "body", "event", "person", "issue", "create"], "index": ["image", "size", "author", "i", "key", "old", "section", "address", "word", "value", "edit", "x", "prefix", "letter", "update", "axis", "search", "width", "name", "string", "column", "length", "request", "ind", "batch", "element", "label", "view", "route", "page", "diff", "num", "weight", "operation", "part", "active", "offset", "again", "initial", "inc", "success", "in", "level", "alpha", "argument", "pattern", "object", "action", "slice", "id", "expression", "pointer", "step", "number", "Index", "position", "left", "pos", "all", "default", "version", "coll", "connection", "date", "second", "f", "primary", "data", "type", "other", "site", "list", "loop", "condition"], "response": ["request", "image", "client", "service", "offer", "i", "output", "reply", "object", "feed", "respons", "e", "page", "handler", "json", "server", "answer", "result", "connection", "http", "array", "message", "resource", "Response", "value", "resp", "post", "api", "onse", "model", "data", "v", "collection", "status", "application", "method", "body", "respond", "related"]}}
{"id1": "4593011", "id2": "20365090", "code1": "    private void loadDDL() throws IOException {\n        try {\n            conn.createStatement().executeQuery(\"SELECT * FROM overrides\").close();\n        } catch (SQLException e) {\n            Statement stmt = null;\n            if (!e.getMessage().startsWith(ERR_MISSING_TABLE)) {\n                LOG.fatal(SQL_ERROR, e);\n                throw new IOException(\"Error on initial data store read\", e);\n            }\n            String[] qry = { \"CREATE TABLE monitor (id INTEGER PRIMARY KEY NOT NULL, status VARCHAR(32) NOT NULL, next_update TIMESTAMP NOT NULL)\", \"CREATE TABLE overrides (id INT NOT NULL, title VARCHAR(255) NOT NULL, subtitle VARCHAR(255) NOT NULL, enable BOOLEAN NOT NULL DEFAULT TRUE, PRIMARY KEY(id))\", \"CREATE TABLE settings (var VARCHAR(32) NOT NULL, val VARCHAR(255) NOT NULL, PRIMARY KEY(var))\", \"INSERT INTO settings (var, val) VALUES ('schema', '1')\" };\n            try {\n                conn.setAutoCommit(false);\n                stmt = conn.createStatement();\n                for (String q : qry) stmt.executeUpdate(q);\n                conn.commit();\n            } catch (SQLException e2) {\n                try {\n                    conn.rollback();\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                }\n                LOG.fatal(SQL_ERROR, e2);\n                throw new IOException(\"Error initializing data store\", e2);\n            } finally {\n                if (stmt != null) {\n                    try {\n                        stmt.close();\n                    } catch (SQLException e4) {\n                        LOG.fatal(SQL_ERROR, e4);\n                        throw new IOException(\"Unable to cleanup data store resources\", e4);\n                    }\n                }\n                try {\n                    conn.setAutoCommit(true);\n                } catch (SQLException e3) {\n                    LOG.fatal(SQL_ERROR, e3);\n                    throw new IOException(\"Unable to reset data store auto commit\", e3);\n                }\n            }\n        }\n        return;\n    }\n", "code2": "        public HttpResponseExchange execute() throws Exception {\n            HttpResponseExchange forwardResponse = null;\n            int fetchSizeLimit = Config.getInstance().getFetchLimitSize();\n            while (null != lastContentRange) {\n                forwardRequest.setBody(new byte[0]);\n                ContentRangeHeaderValue old = lastContentRange;\n                long sendSize = fetchSizeLimit;\n                if (old.getInstanceLength() - old.getLastBytePos() - 1 < fetchSizeLimit) {\n                    sendSize = (old.getInstanceLength() - old.getLastBytePos() - 1);\n                }\n                if (sendSize <= 0) {\n                    break;\n                }\n                lastContentRange = new ContentRangeHeaderValue(old.getLastBytePos() + 1, old.getLastBytePos() + sendSize, old.getInstanceLength());\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_RANGE, lastContentRange);\n                forwardRequest.setHeader(HttpHeaders.Names.CONTENT_LENGTH, String.valueOf(sendSize));\n                forwardResponse = syncFetch(forwardRequest);\n                if (sendSize < fetchSizeLimit) {\n                    lastContentRange = null;\n                }\n            }\n            return forwardResponse;\n        }\n", "label": 0, "substitutes": {"loadDDL": ["loadSDL", "loadDDE", "LoadDDLL", "loadODL", "loadODML", "LoadCDE", "LoadCDLL", "LoadDDML", "loadDDML", "LoadDDL", "loadCDLL", "LoadCDML", "loadDDLL", "loadSDLL", "loadODLL", "LoadCDL", "loadCDL", "loadCDE", "LoadDDE", "loadSDML", "loadODE", "loadSDE", "loadCDML"], "stmt": [" stm", "STpr", "stmr", "estmd", "Stmr", "Stm", "STmb", " stdb", "constmt", " stmn", "tmd", "stgr", "tmt", "sttt", "estmr", " stpr", "Stmd", "estmb", "esttt", "sttr", "strpr", "stmd", "strgr", "constdb", " sttr", "stmp", "strmt", " stmd", "rm", "STmr", "Stmp", " stgr", "Stmb", "STtr", "STmt", "Sttt", "rmt", "rdb", "estm", "rmd", "constm", "estmt", "STgr", "stm", "stpr", " sttt", "strtr", "tm", "Stmt", "stmn", "Stmn", "Stdb", "STmp", "stmb", "constmn", "estmp", "stdb", "tdb"], "qry": ["quury", "qurys", "Qri", "quri", " qries", " qri", "Qries", "qury", "qries", "quRY", " qrys", "qRY", " qRY", "eqRY", "eqrys", "qri", "Qrys", "equry", "Qry", "eqry", "quries", "qrys", " qury"], "q": ["request", "r", "iq", "p", "query", "n", "qs", "quant", "eq", "queue", "i", "key", " sq", "qq", "e", "id", "t", "qu", " req", " p", "quest", "qt", " query", "qa", "f", "ch", "req", "k", "sq", "b", "v", "requ", "ql", "d", "Q", "dq", "config", "c", "select"]}}
{"id1": "17791385", "id2": "12869602", "code1": "    public static void copyFile(File src, File dst) throws IOException {\n        InputStream in = new FileInputStream(src);\n        OutputStream out = new FileOutputStream(dst);\n        byte[] buf = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    @Test\n    public void test_validate_tag_getTopAlbums() {\n        try {\n            SchemaFactory factory = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\n            File schemaLocation = new File(\"tes.xsd\");\n            Schema schema = factory.newSchema(schemaLocation);\n            Validator validator = schema.newValidator();\n            URL url = new URL(\"http://ws.audioscrobbler.com/2.0/?method=tag.gettopalbums&tag=disco&api_key=b25b959554ed76058ac220b7b2e0a026\");\n            InputStream inputStream = url.openStream();\n            Source source = new StreamSource(inputStream);\n            validator.validate(source);\n        } catch (IOException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"File not found\", true);\n        } catch (SAXException ex) {\n            Logger.getLogger(GetTopAlbums_Test.class.getName()).log(Level.SEVERE, null, ex);\n            assertFalse(\"Schema did not validate\", true);\n        }\n        assertTrue(true);\n    }\n", "label": 0, "substitutes": {"copyFile": ["CopyFiles", " copyFiles", " copyfile", "transferfile", "copyStream", "transferStream", " copyStream", "copyFiles", "copyfile", "CopyStream", "transferFile", "transferFiles", "CopyFile", "Copyfile"], "src": ["image", "sc", "sl", "obj", "upload", "ipl", "stream", "files", "rc", "s", "input", "sit", "ls", "sin", "sb", "loc", "inf", "rb", "http", "inst", "resource", "img", "dest", "file", "sup", "dist", "config", "sel", "url", "st", "b", "ins", "uri", "back", "source", "filename", "txt"], "dst": ["fdsp", " dsts", "dfd", "stlt", "ddst", "dsts", "ddft", "stst", "ddfd", "pdft", "ddest", "Dsts", " ddest", "Ddest", "ststs", "stdest", "Dst", "fdfd", "Dlt", "dsp", "pdsp", "dlt", "fdft", "fdst", "dft", "pdfd", "pdst", " dlt", "ddsp"], "in": ["r", "m", "h", "pin", "n", "inn", "gin", "i", "is", "socket", "init", "cin", "impl", "input", "ln", "id", "sin", "din", "conn", "lin", "inner", "pull", "nin", "rin", "ini", "kin", "con", "file", "inside", "f", "url", "login", "data", "err", "oin", "ins", "bin", "In", "reader", "IN", "as", "again", "win", "inc"], "out": ["Out", "plain", "client", "writer", "self", "obj", "sync", "n", "off", "i", "output", "s", "copy", "parent", "ex", "server", "cache", "conn", "exp", "ext", "io", "at", "file", "raw", "part", "post", "line", "x", "f", "o", "null", "exec", "err", "temp", "w", "other", "net", "bin", "OUT", "again", "outs", "outer", "up", "inc"], "buf": ["pad", "buffer", "seq", "bytes", "batch", "bf", "ctx", "br", "off", "queue", "fd", "rc", "ff", "lim", "fl", "cat", "bb", "val", "loc", "bc", "rb", "fb", "bl", "cur", "buff", "raw", "uc", "count", "bag", "bd", "bh", "wb", "base", "vec", "data", "b", "cap", "v", "uf", "bin", "cmd", "c", "cb", "length"], "len": ["ind", "fin", "size", "sl", "lf", "n", "pos", "all", "i", "fd", "el", "lt", "fl", "lim", "ix", "ln", "nt", "lc", "val", "lin", "li", "line", "Len", "count", "part", "en", "end", "f", "rev", "no", "base", "data", "err", "cap", "ll", "split", "cl", "name", "l", "bin", "le", "c", "length"]}}
{"id1": "11484416", "id2": "2221297", "code1": "    private void moveFile(File orig, File target) throws IOException {\n        byte buffer[] = new byte[1000];\n        int bread = 0;\n        FileInputStream fis = new FileInputStream(orig);\n        FileOutputStream fos = new FileOutputStream(target);\n        while (bread != -1) {\n            bread = fis.read(buffer);\n            if (bread != -1) fos.write(buffer, 0, bread);\n        }\n        fis.close();\n        fos.close();\n        orig.delete();\n    }\n", "code2": "    public static String getURLContent(String urlToSearchString) throws IOException {\n        URL url = new URL(urlToSearchString);\n        URLConnection conn = url.openConnection();\n        String encoding = conn.getContentEncoding();\n        if (encoding == null) encoding = \"ISO-8859-1\";\n        BufferedReader br = new BufferedReader(new InputStreamReader(conn.getInputStream(), encoding));\n        StringBuilder sb = new StringBuilder(16384);\n        try {\n            String line;\n            while ((line = br.readLine()) != null) {\n                sb.append(line);\n                sb.append('\\n');\n            }\n        } finally {\n            br.close();\n        }\n        return sb.toString();\n    }\n", "label": 0, "substitutes": {"moveFile": [" moveFiles", "MovePath", "moveDirectory", " movedFiles", "MoveFiles", " movePath", " movedFile", "moveFiles", " moveDirectory", " movedDirectory", "MoveFile", "movePath", "MoveDirectory", " movedPath"], "orig": ["image", "original", "obj", "src", "old", "tmp", "proxy", "init", "comb", "impl", "ctr", "internal", "Orig", "exe", "copy", "id", "archive", "coll", "home", "origin", "loc", "info", "rb", "array", "ext", "ori", "raf", "img", "real", "imag", "dest", "file", "bas", "build", "iter", "raid", "f", "buf", "base", "temp", "org", "transform", "bin", "coord", "frame", "remote", "prev", "folder", "source"], "target": ["next", "auto", "match", "template", "original", "compatible", "current", "master", "object", "tmp", "reference", "eth", "copy", "parent", "nt", "archive", "t", "origin", "to", " Target", "replace", "result", "format", "path", "resource", "ret", "manager", "dest", "build", "prot", "f", "this", "base", "platform", "temp", "Target", "it", "force", "external", "arget", "project", "remote", "join", "source"], "buffer": ["request", "position", "bytes", "batch", "block", "queue", "transfer", "feed", "input", "slice", "sequence", "reference", "write", "copy", "bb", "layer", "Buffer", "cache", "address", "stack", "result", "padding", "code", "content", "message", "resource", "buff", "raw", "file", "uffer", "iter", "url", "buf", "binary", "null", "base", "data", "b", "wave", "bin", "frame", "header", "repeat", "read", "source", "length"], "bread": ["rib", "design", "batch", "beat", "hello", "fee", "fall", "ble", "inn", "knife", "key", "meal", "raft", "feed", "bn", "fen", "bb", "abi", "circ", "bare", "grain", "fe", "good", "bc", "zero", "num", "sleep", "buck", "four", "wake", "fed", "bee", "str", "food", "eb", "wen", "fine", "brew", "choice", "broken", "die", "div", "zip", "ffe", "cake", "bat", "rows", "width", "rub", "robe", "cook", "piece", "fif", "loop", "web", "fle", "fred", "length"], "fis": ["lfIs", "fxis", "ufis", "qiss", "qis", "lfiss", "hIs", "hos", "his", "fIs", "fxIs", "fxos", "ufiss", "afiss", " fiss", " fIs", " fisa", "hisa", "afos", "qils", "lfos", "afis", "qos", "lfis", " fils", "fiss", "afIs", "fils", "fxisa", "fisa", "ufils", "ufos"], "fos": ["flors", "flaos", "Faos", "Fros", " foss", "floses", "gros", "gis", "fros", "flos", "flose", "faos", "fois", "foss", "Fos", "infos", "foses", "Foses", "infors", " fens", "Foss", "infaos", "Fors", "fens", "infois", "fors", " fros", "gos", " fose", "flois", " foses", "Fose", "Fis", "fose", "flens", "goss", "Fens", "Fois"]}}
{"id1": "15510198", "id2": "1862616", "code1": "    protected static Parser buildParser(URL url) throws IOException, ParserException {\n        Parser parser;\n        URLConnection connection = openConnection(url);\n        if (!(connection instanceof HttpURLConnection) || ((HttpURLConnection) connection).getResponseCode() == 200) {\n            parser = new Parser(connection);\n        } else {\n            parser = null;\n        }\n        return parser;\n    }\n", "code2": "    public static String fetch(String reference) throws IOException {\n        URL url = new URL(reference);\n        HttpURLConnection c = (HttpURLConnection) url.openConnection();\n        c.setRequestMethod(\"GET\");\n        c.setDoOutput(true);\n        c.setRequestProperty(\"Content-Type\", \"text/xml; charset=UTF-8\");\n        return parseISToString(c.getInputStream());\n    }\n", "label": 0, "substitutes": {"buildParser": ["constructParser", "newParser", "constructReader", "buildHandler", "newReader", "makeParser", "makeReader", "constructWriter", "makeWriter", "constructHandler", "buildWriter", "makeHandler", "newHandler", "newWriter", "buildReader"], "url": ["image", "service", "obj", "sl", "host", "class", "object", "proxy", "bug", "page", "www", "server", "address", "open", "loc", "http", "location", "path", "resource", "URL", "io", "ssl", "file", "str", "link", "Url", "this", "null", "base", "channel", "data", "loader", " URL", "name", "l", "uri", "source", "config", "c"], "ParserException": ["IOError", " IOExc", "IOExc", "IOException", "SSLExc", " IOException", "SSLException", "ParserError", " IOError", "ParserExc", "SSLError"], "parser": ["writer", "p", "worker", "master", "class", "object", "instance", "parse", "parent", "slave", "Parser", "handler", "pd", "server", "cache", "ler", "result", "http", "php", "fp", "se", "library", "xml", "pool", "angler", "manager", "pard", "root", "x", "this", "null", "api", "data", "pe", "jp", "type", "builder", "loader", "er", "test", "jack", "pc", "arser", "processor", "plugin", "reader", "style", "seed", "au", "config", "fruit"], "connection": ["image", "position", "db", "client", "connect", "service", "j", "class", "relation", "object", "socket", "context", "character", "proxy", "instance", "reference", "section", "lc", "directory", "handler", "server", "conn", "loc", "open", "bc", "http", "pointer", "response", "resource", "message", "io", "con", "function", "link", "connected", "this", "channel", "session", "database", "collection", "application", " Connection", "document", "reader", "ion", "communication", "Connection", "uri", "event", "config", "c", "condition"]}}
{"id1": "17999474", "id2": "12055086", "code1": "    private static File getZipAsFile(DigitalObject digOb) {\n        String folderName = randomizeFileName(getFolderNameFromDigObject(digOb));\n        File tmpFolder = new File(utils_tmp, folderName);\n        File zip = null;\n        try {\n            FileUtils.forceMkdir(tmpFolder);\n            zip = new File(tmpFolder, getFileNameFromDigObject(digOb, null));\n            FileOutputStream out = new FileOutputStream(zip);\n            IOUtils.copyLarge(digOb.getContent().getInputStream(), out);\n            out.close();\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return zip;\n    }\n", "code2": "    protected static void copyDeleting(File source, File dest) throws IOException {\n        byte[] buf = new byte[8 * 1024];\n        FileInputStream in = new FileInputStream(source);\n        try {\n            FileOutputStream out = new FileOutputStream(dest);\n            try {\n                int count;\n                while ((count = in.read(buf)) >= 0) out.write(buf, 0, count);\n            } finally {\n                out.close();\n            }\n        } finally {\n            in.close();\n        }\n    }\n", "label": 1, "substitutes": {"getZipAsFile": ["getZipAtDir", "getTempAsPlace", "getTempAsFile", "getZipAtfile", "getTempAsDir", "getZipAsfile", "getZipasPlace", "getZipAsPlace", "getZipAtFile", "getZipasFile", "getZipasDir", "getZipAsDir", "getZipasfile", "getZipAtPlace", "getTempAsfile"], "digOb": [" digObject", "dimObject", " digObj", " digob", "signObject", "ditOb", "dimObj", "signob", "Digob", "signOb", "dimOl", "ditob", "DigOl", "signObj", "digob", " digOl", "signOB", "ditObject", "digObj", "DigObject", "DigOb", "digOl", "dimOb", "DigObj", "ditOB", "digOB", "digObject", " digOB"], "folderName": ["folderPath", "Foldername", "FolderDir", "foldername", "packagename", "foldPath", " folderPath", "FolderInfo", "packageName", "folderInfo", "foldname", "packagePath", "packageDir", "fileInfo", "folderDir", "foldName", " folderDir", "FolderName", "fileName", " foldername", "FolderPath", "filePath", "foldInfo", "filename"], "tmpFolder": [" temporaryManager", "tempDir", "tmpfolder", " tmpDir", "mpDir", "tempfolder", " tmpfolder", "mpfolder", "tmpManager", " tmpManager", " tmpDirectory", "tmpDir", "tempFolder", " temporaryFolder", " temporaryfolder", "mpDirectory", "tmpDirectory", " temporaryDirectory", "tempDirectory", "tempManager", "mpFolder"], "zip": ["job", "ip", "ress", "p", "sl", "upload", "ie", "flow", "ce", "tmp", "proxy", "feed", "slice", "install", "copy", "pkg", "ze", "cf", "archive", "json", "py", "Zip", " ZIP", "clip", "io", "cop", "zone", "pack", "ignore", "z", "xml", "fp", "file", "ulp", "lex", "bag", "f", "url", "lib", " zipper", "temp", "download", "flat", "wrap", "seed", "folder", "gz", "lock", "jar", "source", "ipped", "pipe"], "out": ["Out", "plain", "os", "in", "client", "writer", "obj", "sync", "upload", "flow", "output", "is", "object", "socket", "user", "write", "copy", "parent", "cli", "page", "ex", "cache", "conn", "child", "info", "result", "connection", "a", "path", "io", "z", "line", "file", "box", "f", "url", "o", "null", "base", "this", "temp", "err", "download", "log", "loader", "again", "outs", "gz", "gen", "flush", "source", "OUT"]}}
{"id1": "7006052", "id2": "1357662", "code1": "    public static void copyFileTo(String src, String dest) throws FileNotFoundException, IOException {\n        File destFile = new File(dest);\n        InputStream in = new FileInputStream(new File(src));\n        OutputStream out = new FileOutputStream(destFile);\n        byte buf[] = new byte[1024];\n        int len;\n        while ((len = in.read(buf)) > 0) out.write(buf, 0, len);\n        in.close();\n        out.close();\n    }\n", "code2": "    private void copyFileTo(File destination) throws IOException {\n        logger.fine(\"Copying from \" + destination + \"...\");\n        FileChannel srcChannel = new FileInputStream(getAbsolutePath()).getChannel();\n        logger.fine(\"...got source channel \" + srcChannel + \"...\");\n        FileChannel destChannel = new FileOutputStream(new File(destination.getAbsolutePath())).getChannel();\n        logger.fine(\"...got destination channel \" + destChannel + \"...\");\n        logger.fine(\"...Got channels...\");\n        destChannel.transferFrom(srcChannel, 0, srcChannel.size());\n        logger.fine(\"...transferred.\");\n        srcChannel.close();\n        destChannel.close();\n    }\n", "label": 1, "substitutes": {"copyFileTo": ["copyFileFrom", "copySourceFileInfo", " copyFilesTo", "copyfileInfo", " copyFilesInfo", "copyFilesFrom", "copyfileTo", "copyFileFile", "copyFilesFile", " copyFileFrom", " copyFilesFile", " copyFilesFrom", " copyFileInfo", "copyFileInfo", "copyFilesInfo", "copySourceFileFile", "copySourceFileFrom", "copyFilesTo", "copyfileFrom", " copyFileFile", "copyfileFile", "copySourceFileTo"], "src": ["image", "sc", "sl", "upload", "sync", "stream", "old", "rc", "s", "slice", "rs", "sin", "archive", "sb", "loc", "source", "inf", "code", "rb", "path", "resource", "img", "fn", "file", "sup", "config", "sel", "url", "data", "b", "remote", "string", "href", "js", "uri", "sub", "filename", "txt"], "dest": [" Dest", "output", "delete", "default", "tmp", "comb", "opt", "route", "const", "home", "Dest", "loc", "source", "target", "result", "desc", "orig", "later", "img", "sup", "dist", "secure", "dir", "die", "wb", "des", "data", "temp", "flat", "b", "done", "test", "name", "bin", " destination", "project", "folder", "sub", "filename", "txt"], "destFile": ["targetDir", " destF", " destDir", "DestFile", " destinationF", "destDir", "Destfile", "destfile", "targetfile", "destFiles", " destfile", " destinationFile", "DestF", "targetFiles", "DestDir", " destinationDir", "DestFiles", "targetFile", " destFiles", " destinationFiles", "destF"], "in": ["r", "image", "pin", "n", "inn", "gin", "stream", "is", "i", "socket", "s", "init", "cin", "impl", "input", "ln", "thin", "id", "din", "diff", "lin", "inner", "nin", "con", "rin", "ini", "kin", "inside", "f", "url", "pass", "login", "data", "err", "trans", "ins", "bin", "In", "l", "reader", "IN", "again", "win", "source", "up", "inc"], "out": ["Out", "image", "plain", "client", "writer", "obj", "sync", "n", "off", "one", "output", "user", "parent", "copy", "ex", "cache", "conn", "cos", "exp", "ext", "inner", "io", "pool", "work", "file", "part", "post", "o", "null", "exec", "this", "data", "err", "log", "w", "other", "net", "bin", "OUT", "again", "outer", "extra", "up", "ac", "inc"], "buf": ["pad", "buffer", "cas", "bytes", "seq", "batch", "bf", "ctx", "br", "block", "off", "queue", "ff", "rc", "tmp", "map", "Buffer", "cache", "loc", "length", "result", "bc", "rb", "fb", "bl", "path", "orig", "buff", "pool", "raw", "uc", "box", "bag", "bh", "bd", "vec", "data", "blocks", "b", "v", "uf", "cap", "cv", "bin", "cb", "c"], "len": ["ind", "fin", "bytes", "size", "lf", "n", "pos", "off", "ie", "all", "fd", "pre", "el", "fl", "lim", "ln", "id", "nt", "lc", "coll", "val", "li", "num", "line", "Len", "count", "part", "end", "en", "min", "f", "url", "rev", "no", "base", "iter", "data", "cap", "split", "l", "body", "c", "length"]}}
